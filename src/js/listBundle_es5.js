/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojlogger',[], function()
{
  "use strict";


/* jslint browser: true*/

/**
 * @namespace
 * @name oj.Logger
 * @hideconstructor
 * @ojtsmodule
 * @since 1.0.0
 *
 * @classdesc
 * <h3>JET Logger</h3>
 *
 * <p>Logger object writes into the native browser console or a custom writer, if a custom writer is set as an option.
 * To use a custom writer, implement the following writer methods: log(), info(), warn(), error()
 *
 * <p>When any of the logging methods is called, it compares the requested log level with the value of a log level option
 * and logs the message if the log level is sufficient.
 *
 * <p>If the logging options are changed at a later point, the Logger will use the modified options for the subsequent log operations.
 *
 * <p>All the logging methods support string formatting, accept variable number of arguments and accept a function as a parameter.
 * When a callback function is specified as a parameter the function will be called if the log level is sufficient.
 *
 * <h3> Usage : </h3>
 * <pre class="prettyprint">
 * <code>
 * //optional calls, see defaults
 * oj.Logger.option("level",  oj.Logger.LEVEL_INFO);
 * oj.Logger.option("writer",  customWriter);  //an object that implements the following methods: log(), info(), warn(), error()
 *
 * // logging a message
 * oj.Logger.info("My log level is %d", oj.Logger.option("level"));  // string formatting
 * oj.Logger.warn("Beware of bugs", "in the above code");            // multiple parameters
 *
 * // using a callback function as a parameter
 * oj.Logger.info(function(){
 *    var foo = "This ";
 *    var bar = "is ";
 *    var zing = "a function";
 *    return foo + bar + zing;
 * });
 * </code></pre>
 *
 * @desc oj.Logger cannot be instantiated
 * @export
 */
var Logger = {};
/**
 * Log level none
 * @const
 * @export
 * @type {number}
 * @memberof oj.Logger
 * @alias LEVEL_NONE
 */

Logger.LEVEL_NONE = 0;
/**
 * Log level error
 * @const
 * @type {number}
 * @export
 * @memberof oj.Logger
 * @alias LEVEL_ERROR
 */

Logger.LEVEL_ERROR = 1;
/**
 * Log level warning
 * @const
 * @type {number}
 * @export
 * @memberof oj.Logger
 * @alias LEVEL_WARN
 */

Logger.LEVEL_WARN = 2;
/**
 * Log level info
 * @const
 * @type {number}
 * @export
 * @memberof oj.Logger
 * @alias LEVEL_INFO
 */

Logger.LEVEL_INFO = 3;
/**
 * Log level - general message
 * @const
 * @type {number}
 * @export
 * @memberof oj.Logger
 * @alias LEVEL_LOG
 */

Logger.LEVEL_LOG = 4;
/* private constants*/

Logger._METHOD_ERROR = 'error';
Logger._METHOD_WARN = 'warn';
Logger._METHOD_INFO = 'info';
Logger._METHOD_LOG = 'log';
Logger._defaultOptions = {
  level: Logger.LEVEL_ERROR,
  writer: null
};
Logger._options = Logger._defaultOptions;
/* public members*/

/**
 * Writes an error message.
 * @param {any=} message A function that returns the message to be logged, a string containing zero or more substitution strings, or an object to be logged.
 *                      See examples in the overview section above.
 * @param {...any} optionalParams Objects with which to replace substitution strings within messages or simply additional objects to be logged.
 * @return {void}
 * @export
 * @memberof oj.Logger
 * @method error
 * @since 1.0.0
 * @ojsignature {target: "Type", for: "optionalParams", value: "any[]"}
 */
// eslint-disable-next-line no-unused-vars

Logger.error = function (message, optionalParams) {
  Logger._write(Logger.LEVEL_ERROR, Logger._METHOD_ERROR, arguments);
};
/**
 * Writes an informational  message.
 * @param {any=} message A function that returns the message to be logged, a string containing zero or more substitution strings, or an object to be logged.
 *                      See examples in the overview section above.
 * @param {...any} optionalParams Objects with which to replace substitution strings within messages or simply additional objects to be logged.
 * @return {void}
 * @export
 * @memberof oj.Logger
 * @method info
 * @since 1.0.0
 * @ojsignature {target: "Type", for: "optionalParams", value: "any[]"}
 */
// eslint-disable-next-line no-unused-vars


Logger.info = function (message, optionalParams) {
  Logger._write(Logger.LEVEL_INFO, Logger._METHOD_INFO, arguments);
};
/**
 * Writes a warning message.
 * @param {any=} message A function that returns the message to be logged, a string containing zero or more substitution strings, or an object to be logged.
 *                      See examples in the overview section above.
 * @param {...any} optionalParams Objects with which to replace substitution strings within messages or simply additional objects to be logged.
 * @export
 * @return {void}
 * @memberof oj.Logger
 * @method warn
 * @since 1.0.0
 * @ojsignature {target: "Type", for: "optionalParams", value: "any[]"}
 */
// eslint-disable-next-line no-unused-vars


Logger.warn = function (message, optionalParams) {
  Logger._write(Logger.LEVEL_WARN, Logger._METHOD_WARN, arguments);
};
/**
 * Writes a general message.
 * @param {any=} message A function that returns the message to be logged, a string containing zero or more substitution strings, or an object to be logged.
 *                      See examples in the overview section above.
 * @param {...any} optionalParams Objects with which to replace substitution strings within messages or simply additional objects to be logged.
 * @return {void}
 * @export
 * @memberof oj.Logger
 * @method log
 * @since 1.0.0
 * @ojsignature {target: "Type", for: "optionalParams", value: "any[]"}
 */
// eslint-disable-next-line no-unused-vars


Logger.log = function (message, optionalParams) {
  Logger._write(Logger.LEVEL_LOG, Logger._METHOD_LOG, arguments);
};
/**
 * Method for setting and getting logger option/options
 * <p>Sets/gets logger configuration - level and/or writer. Accepts variable number of arguments.
 * <p><h5>Defaults:</h5>
 * Default level: oj.Logger.LEVEL_ERROR<br/>
 * Default writer: null; writes to the console
 * <p><h5>Usages:</h5>
 * <i>oj.Logger.option(optionName)</i> gets the value associated the the specified optionName<br/>
 * <i>oj.Logger.option()</i> gets an object containing key/value pairs representing the logger options hash<br/>
 * <i>oj.Logger.option(optionName, value)</i> sets  the option value associated with optionName<br/>
 * <i>oj.Logger.option(options)</i> sets  one or more options for the logger
 *
 * @example <caption>Overriding default options</caption>
 * oj.Logger.option("level",  oj.Logger.LEVEL_INFO);
 * oj.Logger.option("writer",  customWriter);  //an object that implements the following methods: log(), info(), warn(), error()
 *
 * @param {Object|string} [key]
 * @param {any} [value]
 * @return {any}
 * @export
 * @memberof oj.Logger
 * @method option
 * @since 1.0.0
 * @ojsignature {target: "Type", for: "key", value: "'level'|'writer'|{level?: any, writer?: any}"}
 */


Logger.option = function (key, value) {
  // getters
  var ret = {};
  var i;
  var keys;

  if (arguments.length === 0) {
    keys = Object.keys(Logger._options);

    for (i = 0; i < keys.length; i++) {
      ret[keys[i]] = Logger._options[keys[i]];
    }

    return ret;
  }

  if (typeof key === 'string' && value === undefined) {
    return Logger._options[key] === undefined ? null : Logger._options[key];
  } // setters


  if (typeof key === 'string') {
    Logger._options[key] = value;
  } else {
    // case when all options are set in one call
    var options = key;
    keys = Object.keys(options);

    for (i = 0; i < keys.length; i++) {
      Logger.option(keys[i], options[keys[i]]);
    }
  }

  return undefined;
};
/* private members*/

/*
 * Helper method - calls a specified method on the available writer (console or custom)
 * if the logging level is sufficient
 */


Logger._write = function (level, method, args) {
  if (Logger.option('level') < level) {
    return;
  }

  var writer = Logger._getWriter();

  if (writer != null) {
    if (args.length === 1 && args[0] instanceof Function) {
      var msg = args[0](); // eslint-disable-next-line no-param-reassign

      args = [msg];
    }

    if (writer[method] && writer[method].apply) {
      writer[method].apply(writer, args);
    } else if (writer[method]) {
      writer[method] = Function.prototype.bind.call(writer[method], writer);

      Logger._write(level, method, args);
    }
  }
};
/*
 * Helper method - returns available writer (console or custom)
 */


Logger._getWriter = function () {
  var writer = null;

  if (Logger.option('writer')) {
    writer = Logger.option('writer');
  } else if (typeof window !== 'undefined' && window.console !== undefined) {
    writer = window.console;
  }

  return writer;
};

;return Logger;
});
define('corejs',['module'], function(module) {
/**
 * core-js 2.6.5
 * https://github.com/zloirock/core-js
 * License: http://rock.mit-license.org
 * Â© 2019 Denis Pushkarev
 */
!function(__e, __g, undefined){
'use strict';
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 129);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var core = __webpack_require__(26);
var hide = __webpack_require__(11);
var redefine = __webpack_require__(12);
var ctx = __webpack_require__(18);
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(4);
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),
/* 2 */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(47)('wks');
var uid = __webpack_require__(33);
var Symbol = __webpack_require__(2).Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(20);
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(3)(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(1);
var IE8_DOM_DEFINE = __webpack_require__(93);
var toPrimitive = __webpack_require__(22);
var dP = Object.defineProperty;

exports.f = __webpack_require__(7) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(23);
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),
/* 10 */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(8);
var createDesc = __webpack_require__(32);
module.exports = __webpack_require__(7) ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var hide = __webpack_require__(11);
var has = __webpack_require__(14);
var SRC = __webpack_require__(33)('src');
var $toString = __webpack_require__(131);
var TO_STRING = 'toString';
var TPL = ('' + $toString).split(TO_STRING);

__webpack_require__(26).inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var fails = __webpack_require__(3);
var defined = __webpack_require__(23);
var quot = /"/g;
// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
var createHTML = function (string, tag, attribute, value) {
  var S = String(defined(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};
module.exports = function (NAME, exec) {
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function () {
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};


/***/ }),
/* 14 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(48);
var defined = __webpack_require__(23);
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__(49);
var createDesc = __webpack_require__(32);
var toIObject = __webpack_require__(15);
var toPrimitive = __webpack_require__(22);
var has = __webpack_require__(14);
var IE8_DOM_DEFINE = __webpack_require__(93);
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(7) ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(14);
var toObject = __webpack_require__(9);
var IE_PROTO = __webpack_require__(68)('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(10);
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),
/* 19 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),
/* 20 */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {



var fails = __webpack_require__(3);

module.exports = function (method, arg) {
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call
    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);
  });
};


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(4);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),
/* 23 */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(0);
var core = __webpack_require__(26);
var fails = __webpack_require__(3);
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = __webpack_require__(18);
var IObject = __webpack_require__(48);
var toObject = __webpack_require__(9);
var toLength = __webpack_require__(6);
var asc = __webpack_require__(84);
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};


/***/ }),
/* 26 */
/***/ (function(module, exports) {

var core = module.exports = { version: '2.6.5' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {



if (__webpack_require__(7)) {
  var LIBRARY = __webpack_require__(29);
  var global = __webpack_require__(2);
  var fails = __webpack_require__(3);
  var $export = __webpack_require__(0);
  var $typed = __webpack_require__(62);
  var $buffer = __webpack_require__(92);
  var ctx = __webpack_require__(18);
  var anInstance = __webpack_require__(39);
  var propertyDesc = __webpack_require__(32);
  var hide = __webpack_require__(11);
  var redefineAll = __webpack_require__(41);
  var toInteger = __webpack_require__(20);
  var toLength = __webpack_require__(6);
  var toIndex = __webpack_require__(122);
  var toAbsoluteIndex = __webpack_require__(35);
  var toPrimitive = __webpack_require__(22);
  var has = __webpack_require__(14);
  var classof = __webpack_require__(44);
  var isObject = __webpack_require__(4);
  var toObject = __webpack_require__(9);
  var isArrayIter = __webpack_require__(81);
  var create = __webpack_require__(36);
  var getPrototypeOf = __webpack_require__(17);
  var gOPN = __webpack_require__(37).f;
  var getIterFn = __webpack_require__(83);
  var uid = __webpack_require__(33);
  var wks = __webpack_require__(5);
  var createArrayMethod = __webpack_require__(25);
  var createArrayIncludes = __webpack_require__(52);
  var speciesConstructor = __webpack_require__(51);
  var ArrayIterators = __webpack_require__(86);
  var Iterators = __webpack_require__(46);
  var $iterDetect = __webpack_require__(57);
  var setSpecies = __webpack_require__(38);
  var arrayFill = __webpack_require__(85);
  var arrayCopyWithin = __webpack_require__(110);
  var $DP = __webpack_require__(8);
  var $GOPD = __webpack_require__(16);
  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';

  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function (it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function (it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function (C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    } return new C(length);
  };

  var speciesFromList = function (O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);
    while (length > index) result[index] = list[index++];
    return result;
  };

  var addGetter = function (it, key, internal) {
    dP(it, key, { get: function () { return this._d[internal]; } });
  };

  var $from = function from(source /* , mapfn, thisArg */) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;
    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      } O = values;
    }
    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var $of = function of(/* ...items */) {
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);
    while (length > index) result[index] = arguments[index++];
    return result;
  };

  // iOS Safari 6.x fails here
  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start /* , end */) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn /* , thisArg */) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn /* , thisArg */) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
        arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate /* , thisArg */) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate /* , thisArg */) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn /* , thisArg */) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement /* , fromIndex */) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement /* , fromIndex */) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) { // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn /* , thisArg */) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;
      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      } return that;
    },
    some: function some(callbackfn /* , thisArg */) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
        O.buffer,
        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)
      );
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /* , offset */) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);
    while (index < len) this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function (target, key) {
    return isObject(target)
      && target[TYPED_ARRAY]
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true))
      ? propertyDesc(2, target[key])
      : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true))
      && isObject(desc)
      && has(desc, 'value')
      && !has(desc, 'get')
      && !has(desc, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !desc.configurable
      && (!has(desc, 'writable') || desc.writable)
      && (!has(desc, 'enumerable') || desc.enumerable)
    ) {
      target[key] = desc.value;
      return target;
    } return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () { arrayToString.call({}); })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function () { /* noop */ },
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function () { return this[TYPED_ARRAY]; }
  });

  // eslint-disable-next-line max-statements
  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
    var getter = function (that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };
    var setter = function (that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };
    var addElement = function (that, index) {
      dP(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }
        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new
      new TypedArray(null); // eslint-disable-line no-new
      new TypedArray(1.5); // eslint-disable-line no-new
      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass;
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
        if (!isObject(data)) return new Base(toIndex(data));
        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined
            ? new Base(data, toOffset($offset, BYTES), $length)
            : $offset !== undefined
              ? new Base(data, toOffset($offset, BYTES))
              : new Base(data);
        }
        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }
    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator
      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function () { return NAME; }
      });
    }

    O[NAME] = TypedArray;

    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });

    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {
      from: $from,
      of: $of
    });

    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

    $export($export.P, NAME, proto);

    setSpecies(NAME);

    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, { slice: $slice });

    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, { toLocaleString: $toLocaleString });

    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () { /* empty */ };


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

var Map = __webpack_require__(116);
var $export = __webpack_require__(0);
var shared = __webpack_require__(47)('metadata');
var store = shared.store || (shared.store = new (__webpack_require__(119))());

var getOrCreateMetadataMap = function (target, targetKey, create) {
  var targetMetadata = store.get(target);
  if (!targetMetadata) {
    if (!create) return undefined;
    store.set(target, targetMetadata = new Map());
  }
  var keyMetadata = targetMetadata.get(targetKey);
  if (!keyMetadata) {
    if (!create) return undefined;
    targetMetadata.set(targetKey, keyMetadata = new Map());
  } return keyMetadata;
};
var ordinaryHasOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
};
var ordinaryGetOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
};
var ordinaryDefineOwnMetadata = function (MetadataKey, MetadataValue, O, P) {
  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
};
var ordinaryOwnMetadataKeys = function (target, targetKey) {
  var metadataMap = getOrCreateMetadataMap(target, targetKey, false);
  var keys = [];
  if (metadataMap) metadataMap.forEach(function (_, key) { keys.push(key); });
  return keys;
};
var toMetaKey = function (it) {
  return it === undefined || typeof it == 'symbol' ? it : String(it);
};
var exp = function (O) {
  $export($export.S, 'Reflect', O);
};

module.exports = {
  store: store,
  map: getOrCreateMetadataMap,
  has: ordinaryHasOwnMetadata,
  get: ordinaryGetOwnMetadata,
  set: ordinaryDefineOwnMetadata,
  keys: ordinaryOwnMetadataKeys,
  key: toMetaKey,
  exp: exp
};


/***/ }),
/* 29 */
/***/ (function(module, exports) {

module.exports = false;


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__(33)('meta');
var isObject = __webpack_require__(4);
var has = __webpack_require__(14);
var setDesc = __webpack_require__(8).f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__(3)(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = __webpack_require__(5)('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__(11)(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};


/***/ }),
/* 32 */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),
/* 33 */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(95);
var enumBugKeys = __webpack_require__(69);

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(20);
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(1);
var dPs = __webpack_require__(96);
var enumBugKeys = __webpack_require__(69);
var IE_PROTO = __webpack_require__(68)('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(66)('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(70).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__(95);
var hiddenKeys = __webpack_require__(69).concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {



var global = __webpack_require__(2);
var dP = __webpack_require__(8);
var DESCRIPTORS = __webpack_require__(7);
var SPECIES = __webpack_require__(5)('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};


/***/ }),
/* 39 */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(18);
var call = __webpack_require__(108);
var isArrayIter = __webpack_require__(81);
var anObject = __webpack_require__(1);
var toLength = __webpack_require__(6);
var getIterFn = __webpack_require__(83);
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

var redefine = __webpack_require__(12);
module.exports = function (target, src, safe) {
  for (var key in src) redefine(target, key, src[key], safe);
  return target;
};


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(4);
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(8).f;
var has = __webpack_require__(14);
var TAG = __webpack_require__(5)('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(19);
var TAG = __webpack_require__(5)('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var defined = __webpack_require__(23);
var fails = __webpack_require__(3);
var spaces = __webpack_require__(73);
var space = '[' + spaces + ']';
var non = '\u200b\u0085';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function (KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;


/***/ }),
/* 46 */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(26);
var global = __webpack_require__(2);
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__(29) ? 'pure' : 'global',
  copyright: 'Â© 2019 Denis Pushkarev (zloirock.ru)'
});


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(19);
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),
/* 49 */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {



// 21.2.5.3 get RegExp.prototype.flags
var anObject = __webpack_require__(1);
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__(1);
var aFunction = __webpack_require__(10);
var SPECIES = __webpack_require__(5)('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(15);
var toLength = __webpack_require__(6);
var toAbsoluteIndex = __webpack_require__(35);
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),
/* 53 */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(19);
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(20);
var defined = __webpack_require__(23);
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.8 IsRegExp(argument)
var isObject = __webpack_require__(4);
var cof = __webpack_require__(19);
var MATCH = __webpack_require__(5)('match');
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__(5)('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {




var classof = __webpack_require__(44);
var builtinExec = RegExp.prototype.exec;

 // `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec
module.exports = function (R, S) {
  var exec = R.exec;
  if (typeof exec === 'function') {
    var result = exec.call(R, S);
    if (typeof result !== 'object') {
      throw new TypeError('RegExp exec method returned something other than an Object or null');
    }
    return result;
  }
  if (classof(R) !== 'RegExp') {
    throw new TypeError('RegExp#exec called on incompatible receiver');
  }
  return builtinExec.call(R, S);
};


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {



__webpack_require__(112);
var redefine = __webpack_require__(12);
var hide = __webpack_require__(11);
var fails = __webpack_require__(3);
var defined = __webpack_require__(23);
var wks = __webpack_require__(5);
var regexpExec = __webpack_require__(87);

var SPECIES = wks('species');

var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  return ''.replace(re, '$<a>') !== '7';
});

var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = (function () {
  // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function () { return originalExec.apply(this, arguments); };
  var result = 'ab'.split(re);
  return result.length === 2 && result[0] === 'a' && result[1] === 'b';
})();

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);

  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;
    re.exec = function () { execCalled = true; return null; };
    if (KEY === 'split') {
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES] = function () { return re; };
    }
    re[SYMBOL]('');
    return !execCalled;
  }) : undefined;

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) ||
    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
  ) {
    var nativeRegExpMethod = /./[SYMBOL];
    var fns = exec(
      defined,
      SYMBOL,
      ''[KEY],
      function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
        if (regexp.exec === regexpExec) {
          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
            // The native String method already delegates to @@method (this
            // polyfilled function), leasing to infinite recursion.
            // We avoid it by directly calling the native @@method method.
            return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
          }
          return { done: true, value: nativeMethod.call(str, regexp, arg2) };
        }
        return { done: false };
      }
    );
    var strfn = fns[0];
    var rxfn = fns[1];

    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return rxfn.call(string, this); }
    );
  }
};


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var navigator = global.navigator;

module.exports = navigator && navigator.userAgent || '';


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {



var global = __webpack_require__(2);
var $export = __webpack_require__(0);
var redefine = __webpack_require__(12);
var redefineAll = __webpack_require__(41);
var meta = __webpack_require__(30);
var forOf = __webpack_require__(40);
var anInstance = __webpack_require__(39);
var isObject = __webpack_require__(4);
var fails = __webpack_require__(3);
var $iterDetect = __webpack_require__(57);
var setToStringTag = __webpack_require__(43);
var inheritIfRequired = __webpack_require__(72);

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  var fixMethod = function (KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY,
      KEY == 'delete' ? function (a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a) {
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }
        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  };
  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
    // weak collections should not contains .clear method
    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var hide = __webpack_require__(11);
var uid = __webpack_require__(33);
var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;

var TypedArrayConstructors = (
  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
).split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {



// Forced replacement prototype accessors methods
module.exports = __webpack_require__(29) || !__webpack_require__(3)(function () {
  var K = Math.random();
  // In FF throws only define methods
  // eslint-disable-next-line no-undef, no-useless-call
  __defineSetter__.call(null, K, function () { /* empty */ });
  delete __webpack_require__(2)[K];
});


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {



// https://tc39.github.io/proposal-setmap-offrom/
var $export = __webpack_require__(0);

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { of: function of() {
    var length = arguments.length;
    var A = new Array(length);
    while (length--) A[length] = arguments[length];
    return new this(A);
  } });
};


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {



// https://tc39.github.io/proposal-setmap-offrom/
var $export = __webpack_require__(0);
var aFunction = __webpack_require__(10);
var ctx = __webpack_require__(18);
var forOf = __webpack_require__(40);

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
    var mapFn = arguments[1];
    var mapping, A, n, cb;
    aFunction(this);
    mapping = mapFn !== undefined;
    if (mapping) aFunction(mapFn);
    if (source == undefined) return new this();
    A = [];
    if (mapping) {
      n = 0;
      cb = ctx(mapFn, arguments[2], 2);
      forOf(source, false, function (nextItem) {
        A.push(cb(nextItem, n++));
      });
    } else {
      forOf(source, false, A.push, A);
    }
    return new this(A);
  } });
};


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(4);
var document = __webpack_require__(2).document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var core = __webpack_require__(26);
var LIBRARY = __webpack_require__(29);
var wksExt = __webpack_require__(94);
var defineProperty = __webpack_require__(8).f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(47)('keys');
var uid = __webpack_require__(33);
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),
/* 69 */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(2).document;
module.exports = document && document.documentElement;


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __webpack_require__(4);
var anObject = __webpack_require__(1);
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = __webpack_require__(18)(Function.call, __webpack_require__(16).f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(4);
var setPrototypeOf = __webpack_require__(71).set;
module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  } return that;
};


/***/ }),
/* 73 */
/***/ (function(module, exports) {

module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {



var toInteger = __webpack_require__(20);
var defined = __webpack_require__(23);

module.exports = function repeat(count) {
  var str = String(defined(this));
  var res = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;
  return res;
};


/***/ }),
/* 75 */
/***/ (function(module, exports) {

// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};


/***/ }),
/* 76 */
/***/ (function(module, exports) {

// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = (!$expm1
  // Old FF bug
  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
  // Tor Browser bug
  || $expm1(-2e-17) != -2e-17
) ? function expm1(x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

// helper for String#{startsWith, endsWith, includes}
var isRegExp = __webpack_require__(56);
var defined = __webpack_require__(23);

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

var MATCH = __webpack_require__(5)('match');
module.exports = function (KEY) {
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) { /* empty */ }
  } return true;
};


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {



var LIBRARY = __webpack_require__(29);
var $export = __webpack_require__(0);
var redefine = __webpack_require__(12);
var hide = __webpack_require__(11);
var Iterators = __webpack_require__(46);
var $iterCreate = __webpack_require__(80);
var setToStringTag = __webpack_require__(43);
var getPrototypeOf = __webpack_require__(17);
var ITERATOR = __webpack_require__(5)('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {



var create = __webpack_require__(36);
var descriptor = __webpack_require__(32);
var setToStringTag = __webpack_require__(43);
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(11)(IteratorPrototype, __webpack_require__(5)('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(46);
var ITERATOR = __webpack_require__(5)('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {



var $defineProperty = __webpack_require__(8);
var createDesc = __webpack_require__(32);

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(44);
var ITERATOR = __webpack_require__(5)('iterator');
var Iterators = __webpack_require__(46);
module.exports = __webpack_require__(26).getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__(213);

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {


// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)

var toObject = __webpack_require__(9);
var toAbsoluteIndex = __webpack_require__(35);
var toLength = __webpack_require__(6);
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {



var addToUnscopables = __webpack_require__(31);
var step = __webpack_require__(111);
var Iterators = __webpack_require__(46);
var toIObject = __webpack_require__(15);

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(79)(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {




var regexpFlags = __webpack_require__(50);

var nativeExec = RegExp.prototype.exec;
// This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.
var nativeReplace = String.prototype.replace;

var patchedExec = nativeExec;

var LAST_INDEX = 'lastIndex';

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/,
      re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
})();

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re));
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];

    match = nativeExec.call(re, str);

    if (UPDATES_LAST_INDEX_WRONG && match) {
      re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      // eslint-disable-next-line no-loop-func
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

module.exports = patchedExec;


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {



var at = __webpack_require__(55)(true);

 // `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex
module.exports = function (S, index, unicode) {
  return index + (unicode ? at(S, index).length : 1);
};


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(18);
var invoke = __webpack_require__(101);
var html = __webpack_require__(70);
var cel = __webpack_require__(66);
var global = __webpack_require__(2);
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (__webpack_require__(19)(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var macrotask = __webpack_require__(89).set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__(19)(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {



// 25.4.1.5 NewPromiseCapability(C)
var aFunction = __webpack_require__(10);

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {



var global = __webpack_require__(2);
var DESCRIPTORS = __webpack_require__(7);
var LIBRARY = __webpack_require__(29);
var $typed = __webpack_require__(62);
var hide = __webpack_require__(11);
var redefineAll = __webpack_require__(41);
var fails = __webpack_require__(3);
var anInstance = __webpack_require__(39);
var toInteger = __webpack_require__(20);
var toLength = __webpack_require__(6);
var toIndex = __webpack_require__(122);
var gOPN = __webpack_require__(37).f;
var dP = __webpack_require__(8).f;
var arrayFill = __webpack_require__(85);
var setToStringTag = __webpack_require__(43);
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError;
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
function packIEEE754(value, mLen, nBytes) {
  var buffer = new Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value);
  // eslint-disable-next-line no-self-compare
  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);
    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
  buffer[--i] |= s * 128;
  return buffer;
}
function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;
  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  } return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}
function packI8(it) {
  return [it & 0xff];
}
function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}
function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}
function packF64(it) {
  return packIEEE754(it, 52, 8);
}
function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}
function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);
  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    this._b = arrayFill.call(new Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    $ArrayBuffer(1);
  }) || !fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new
    new $ArrayBuffer(1.5); // eslint-disable-line no-new
    new $ArrayBuffer(NaN); // eslint-disable-line no-new
    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new BaseBuffer(toIndex(length));
    };
    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
    }
    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(7) && !__webpack_require__(3)(function () {
  return Object.defineProperty(__webpack_require__(66)('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(5);


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(14);
var toIObject = __webpack_require__(15);
var arrayIndexOf = __webpack_require__(52)(false);
var IE_PROTO = __webpack_require__(68)('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(8);
var anObject = __webpack_require__(1);
var getKeys = __webpack_require__(34);

module.exports = __webpack_require__(7) ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(15);
var gOPN = __webpack_require__(37).f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {



// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = __webpack_require__(34);
var gOPS = __webpack_require__(53);
var pIE = __webpack_require__(49);
var toObject = __webpack_require__(9);
var IObject = __webpack_require__(48);
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__(3)(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;


/***/ }),
/* 99 */
/***/ (function(module, exports) {

// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {



var aFunction = __webpack_require__(10);
var isObject = __webpack_require__(4);
var invoke = __webpack_require__(101);
var arraySlice = [].slice;
var factories = {};

var construct = function (F, len, args) {
  if (!(len in factories)) {
    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';
    // eslint-disable-next-line no-new-func
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  } return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction(this);
  var partArgs = arraySlice.call(arguments, 1);
  var bound = function (/* args... */) {
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
  return bound;
};


/***/ }),
/* 101 */
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

var cof = __webpack_require__(19);
module.exports = function (it, msg) {
  if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);
  return +it;
};


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var isObject = __webpack_require__(4);
var floor = Math.floor;
module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

var $parseFloat = __webpack_require__(2).parseFloat;
var $trim = __webpack_require__(45).trim;

module.exports = 1 / $parseFloat(__webpack_require__(73) + '-0') !== -Infinity ? function parseFloat(str) {
  var string = $trim(String(str), 3);
  var result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

var $parseInt = __webpack_require__(2).parseInt;
var $trim = __webpack_require__(45).trim;
var ws = __webpack_require__(73);
var hex = /^[-+]?0[xX]/;

module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
  var string = $trim(String(str), 3);
  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
} : $parseInt;


/***/ }),
/* 106 */
/***/ (function(module, exports) {

// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x) {
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.16 Math.fround(x)
var sign = __webpack_require__(75);
var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);

var roundTiesToEven = function (n) {
  return n + 1 / EPSILON - 1 / EPSILON;
};

module.exports = Math.fround || function fround(x) {
  var $abs = Math.abs(x);
  var $sign = sign(x);
  var a, result;
  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
  a = (1 + EPSILON32 / EPSILON) * $abs;
  result = a - (a - $abs);
  // eslint-disable-next-line no-self-compare
  if (result > MAX32 || result != result) return $sign * Infinity;
  return $sign * result;
};


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(1);
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__(10);
var toObject = __webpack_require__(9);
var IObject = __webpack_require__(48);
var toLength = __webpack_require__(6);

module.exports = function (that, callbackfn, aLen, memo, isRight) {
  aFunction(callbackfn);
  var O = toObject(that);
  var self = IObject(O);
  var length = toLength(O.length);
  var index = isRight ? length - 1 : 0;
  var i = isRight ? -1 : 1;
  if (aLen < 2) for (;;) {
    if (index in self) {
      memo = self[index];
      index += i;
      break;
    }
    index += i;
    if (isRight ? index < 0 : length <= index) {
      throw TypeError('Reduce of empty array with no initial value');
    }
  }
  for (;isRight ? index >= 0 : length > index; index += i) if (index in self) {
    memo = callbackfn(memo, self[index], index, O);
  }
  return memo;
};


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {


// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)

var toObject = __webpack_require__(9);
var toAbsoluteIndex = __webpack_require__(35);
var toLength = __webpack_require__(6);

module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else delete O[to];
    to += inc;
    from += inc;
  } return O;
};


/***/ }),
/* 111 */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {



var regexpExec = __webpack_require__(87);
__webpack_require__(0)({
  target: 'RegExp',
  proto: true,
  forced: regexpExec !== /./.exec
}, {
  exec: regexpExec
});


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

// 21.2.5.3 get RegExp.prototype.flags()
if (__webpack_require__(7) && /./g.flags != 'g') __webpack_require__(8).f(RegExp.prototype, 'flags', {
  configurable: true,
  get: __webpack_require__(50)
});


/***/ }),
/* 114 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(1);
var isObject = __webpack_require__(4);
var newPromiseCapability = __webpack_require__(91);

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {



var strong = __webpack_require__(117);
var validate = __webpack_require__(42);
var MAP = 'Map';

// 23.1 Map Objects
module.exports = __webpack_require__(61)(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {



var dP = __webpack_require__(8).f;
var create = __webpack_require__(36);
var redefineAll = __webpack_require__(41);
var ctx = __webpack_require__(18);
var anInstance = __webpack_require__(39);
var forOf = __webpack_require__(40);
var $iterDefine = __webpack_require__(79);
var step = __webpack_require__(111);
var setSpecies = __webpack_require__(38);
var DESCRIPTORS = __webpack_require__(7);
var fastKey = __webpack_require__(30).fastKey;
var validate = __webpack_require__(42);
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {



var strong = __webpack_require__(117);
var validate = __webpack_require__(42);
var SET = 'Set';

// 23.2 Set Objects
module.exports = __webpack_require__(61)(SET, function (get) {
  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {



var global = __webpack_require__(2);
var each = __webpack_require__(25)(0);
var redefine = __webpack_require__(12);
var meta = __webpack_require__(30);
var assign = __webpack_require__(98);
var weak = __webpack_require__(120);
var isObject = __webpack_require__(4);
var validate = __webpack_require__(42);
var NATIVE_WEAK_MAP = __webpack_require__(42);
var IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global;
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = __webpack_require__(61)(WEAK_MAP, wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if (NATIVE_WEAK_MAP && IS_IE11) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {



var redefineAll = __webpack_require__(41);
var getWeak = __webpack_require__(30).getWeak;
var anObject = __webpack_require__(1);
var isObject = __webpack_require__(4);
var anInstance = __webpack_require__(39);
var forOf = __webpack_require__(40);
var createArrayMethod = __webpack_require__(25);
var $has = __webpack_require__(14);
var validate = __webpack_require__(42);
var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function () {
  this.a = [];
};
var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;      // collection type
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

// all object keys, includes non-enumerable and symbols
var gOPN = __webpack_require__(37);
var gOPS = __webpack_require__(53);
var anObject = __webpack_require__(1);
var Reflect = __webpack_require__(2).Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = __webpack_require__(20);
var toLength = __webpack_require__(6);
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {



// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
var isArray = __webpack_require__(54);
var isObject = __webpack_require__(4);
var toLength = __webpack_require__(6);
var ctx = __webpack_require__(18);
var IS_CONCAT_SPREADABLE = __webpack_require__(5)('isConcatSpreadable');

function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;
  var element, spreadable;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

      spreadable = false;
      if (isObject(element)) {
        spreadable = element[IS_CONCAT_SPREADABLE];
        spreadable = spreadable !== undefined ? !!spreadable : isArray(element);
      }

      if (spreadable && depth > 0) {
        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1fffffffffffff) throw TypeError();
        target[targetIndex] = element;
      }

      targetIndex++;
    }
    sourceIndex++;
  }
  return targetIndex;
}

module.exports = flattenIntoArray;


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-string-pad-start-end
var toLength = __webpack_require__(6);
var repeat = __webpack_require__(74);
var defined = __webpack_require__(23);

module.exports = function (that, maxLength, fillString, left) {
  var S = String(defined(that));
  var stringLength = S.length;
  var fillStr = fillString === undefined ? ' ' : String(fillString);
  var intMaxLength = toLength(maxLength);
  if (intMaxLength <= stringLength || fillStr == '') return S;
  var fillLen = intMaxLength - stringLength;
  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

var getKeys = __webpack_require__(34);
var toIObject = __webpack_require__(15);
var isEnum = __webpack_require__(49).f;
module.exports = function (isEntries) {
  return function (it) {
    var O = toIObject(it);
    var keys = getKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) if (isEnum.call(O, key = keys[i++])) {
      result.push(isEntries ? [key, O[key]] : O[key]);
    } return result;
  };
};


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = __webpack_require__(44);
var from = __webpack_require__(127);
module.exports = function (NAME) {
  return function toJSON() {
    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

var forOf = __webpack_require__(40);

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};


/***/ }),
/* 128 */
/***/ (function(module, exports) {

// https://rwaldron.github.io/proposal-math-extensions/
module.exports = Math.scale || function scale(x, inLow, inHigh, outLow, outHigh) {
  if (
    arguments.length === 0
      // eslint-disable-next-line no-self-compare
      || x != x
      // eslint-disable-next-line no-self-compare
      || inLow != inLow
      // eslint-disable-next-line no-self-compare
      || inHigh != inHigh
      // eslint-disable-next-line no-self-compare
      || outLow != outLow
      // eslint-disable-next-line no-self-compare
      || outHigh != outHigh
  ) return NaN;
  if (x === Infinity || x === -Infinity) return x;
  return (x - inLow) * (outHigh - outLow) / (inHigh - inLow) + outLow;
};


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(130);
__webpack_require__(133);
__webpack_require__(134);
__webpack_require__(135);
__webpack_require__(136);
__webpack_require__(137);
__webpack_require__(138);
__webpack_require__(139);
__webpack_require__(140);
__webpack_require__(141);
__webpack_require__(142);
__webpack_require__(143);
__webpack_require__(144);
__webpack_require__(145);
__webpack_require__(146);
__webpack_require__(147);
__webpack_require__(148);
__webpack_require__(149);
__webpack_require__(150);
__webpack_require__(151);
__webpack_require__(152);
__webpack_require__(153);
__webpack_require__(154);
__webpack_require__(155);
__webpack_require__(156);
__webpack_require__(157);
__webpack_require__(158);
__webpack_require__(159);
__webpack_require__(160);
__webpack_require__(161);
__webpack_require__(162);
__webpack_require__(163);
__webpack_require__(164);
__webpack_require__(165);
__webpack_require__(166);
__webpack_require__(167);
__webpack_require__(168);
__webpack_require__(169);
__webpack_require__(170);
__webpack_require__(171);
__webpack_require__(172);
__webpack_require__(173);
__webpack_require__(174);
__webpack_require__(175);
__webpack_require__(176);
__webpack_require__(177);
__webpack_require__(178);
__webpack_require__(179);
__webpack_require__(180);
__webpack_require__(181);
__webpack_require__(182);
__webpack_require__(183);
__webpack_require__(184);
__webpack_require__(185);
__webpack_require__(186);
__webpack_require__(187);
__webpack_require__(188);
__webpack_require__(189);
__webpack_require__(190);
__webpack_require__(191);
__webpack_require__(192);
__webpack_require__(193);
__webpack_require__(194);
__webpack_require__(195);
__webpack_require__(196);
__webpack_require__(197);
__webpack_require__(198);
__webpack_require__(199);
__webpack_require__(200);
__webpack_require__(201);
__webpack_require__(202);
__webpack_require__(203);
__webpack_require__(204);
__webpack_require__(205);
__webpack_require__(206);
__webpack_require__(207);
__webpack_require__(208);
__webpack_require__(209);
__webpack_require__(210);
__webpack_require__(211);
__webpack_require__(212);
__webpack_require__(214);
__webpack_require__(215);
__webpack_require__(216);
__webpack_require__(217);
__webpack_require__(218);
__webpack_require__(219);
__webpack_require__(220);
__webpack_require__(221);
__webpack_require__(222);
__webpack_require__(223);
__webpack_require__(224);
__webpack_require__(225);
__webpack_require__(86);
__webpack_require__(226);
__webpack_require__(227);
__webpack_require__(112);
__webpack_require__(228);
__webpack_require__(113);
__webpack_require__(229);
__webpack_require__(230);
__webpack_require__(231);
__webpack_require__(232);
__webpack_require__(233);
__webpack_require__(116);
__webpack_require__(118);
__webpack_require__(119);
__webpack_require__(234);
__webpack_require__(235);
__webpack_require__(236);
__webpack_require__(237);
__webpack_require__(238);
__webpack_require__(239);
__webpack_require__(240);
__webpack_require__(241);
__webpack_require__(242);
__webpack_require__(243);
__webpack_require__(244);
__webpack_require__(245);
__webpack_require__(246);
__webpack_require__(247);
__webpack_require__(248);
__webpack_require__(249);
__webpack_require__(250);
__webpack_require__(251);
__webpack_require__(253);
__webpack_require__(254);
__webpack_require__(256);
__webpack_require__(257);
__webpack_require__(258);
__webpack_require__(259);
__webpack_require__(260);
__webpack_require__(261);
__webpack_require__(262);
__webpack_require__(263);
__webpack_require__(264);
__webpack_require__(265);
__webpack_require__(266);
__webpack_require__(267);
__webpack_require__(268);
__webpack_require__(269);
__webpack_require__(270);
__webpack_require__(271);
__webpack_require__(272);
__webpack_require__(273);
__webpack_require__(274);
__webpack_require__(275);
__webpack_require__(276);
__webpack_require__(277);
__webpack_require__(278);
__webpack_require__(279);
__webpack_require__(280);
__webpack_require__(281);
__webpack_require__(282);
__webpack_require__(283);
__webpack_require__(284);
__webpack_require__(285);
__webpack_require__(286);
__webpack_require__(287);
__webpack_require__(288);
__webpack_require__(289);
__webpack_require__(290);
__webpack_require__(291);
__webpack_require__(292);
__webpack_require__(293);
__webpack_require__(294);
__webpack_require__(295);
__webpack_require__(296);
__webpack_require__(297);
__webpack_require__(298);
__webpack_require__(299);
__webpack_require__(300);
__webpack_require__(301);
__webpack_require__(302);
__webpack_require__(303);
__webpack_require__(304);
__webpack_require__(305);
__webpack_require__(306);
__webpack_require__(307);
__webpack_require__(308);
__webpack_require__(309);
__webpack_require__(310);
__webpack_require__(311);
__webpack_require__(312);
__webpack_require__(313);
__webpack_require__(314);
__webpack_require__(315);
__webpack_require__(316);
__webpack_require__(317);
__webpack_require__(318);
__webpack_require__(319);
__webpack_require__(320);
__webpack_require__(321);
__webpack_require__(322);
__webpack_require__(323);
__webpack_require__(324);
module.exports = __webpack_require__(325);


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {



// ECMAScript 6 symbols shim
var global = __webpack_require__(2);
var has = __webpack_require__(14);
var DESCRIPTORS = __webpack_require__(7);
var $export = __webpack_require__(0);
var redefine = __webpack_require__(12);
var META = __webpack_require__(30).KEY;
var $fails = __webpack_require__(3);
var shared = __webpack_require__(47);
var setToStringTag = __webpack_require__(43);
var uid = __webpack_require__(33);
var wks = __webpack_require__(5);
var wksExt = __webpack_require__(94);
var wksDefine = __webpack_require__(67);
var enumKeys = __webpack_require__(132);
var isArray = __webpack_require__(54);
var anObject = __webpack_require__(1);
var isObject = __webpack_require__(4);
var toIObject = __webpack_require__(15);
var toPrimitive = __webpack_require__(22);
var createDesc = __webpack_require__(32);
var _create = __webpack_require__(36);
var gOPNExt = __webpack_require__(97);
var $GOPD = __webpack_require__(16);
var $DP = __webpack_require__(8);
var $keys = __webpack_require__(34);
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__(37).f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(49).f = $propertyIsEnumerable;
  __webpack_require__(53).f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__(29)) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(11)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(47)('native-function-to-string', Function.toString);


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(34);
var gOPS = __webpack_require__(53);
var pIE = __webpack_require__(49);
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__(7), 'Object', { defineProperty: __webpack_require__(8).f });


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !__webpack_require__(7), 'Object', { defineProperties: __webpack_require__(96) });


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = __webpack_require__(15);
var $getOwnPropertyDescriptor = __webpack_require__(16).f;

__webpack_require__(24)('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: __webpack_require__(36) });


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = __webpack_require__(9);
var $getPrototypeOf = __webpack_require__(17);

__webpack_require__(24)('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__(9);
var $keys = __webpack_require__(34);

__webpack_require__(24)('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 Object.getOwnPropertyNames(O)
__webpack_require__(24)('getOwnPropertyNames', function () {
  return __webpack_require__(97).f;
});


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.5 Object.freeze(O)
var isObject = __webpack_require__(4);
var meta = __webpack_require__(30).onFreeze;

__webpack_require__(24)('freeze', function ($freeze) {
  return function freeze(it) {
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.17 Object.seal(O)
var isObject = __webpack_require__(4);
var meta = __webpack_require__(30).onFreeze;

__webpack_require__(24)('seal', function ($seal) {
  return function seal(it) {
    return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.15 Object.preventExtensions(O)
var isObject = __webpack_require__(4);
var meta = __webpack_require__(30).onFreeze;

__webpack_require__(24)('preventExtensions', function ($preventExtensions) {
  return function preventExtensions(it) {
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.12 Object.isFrozen(O)
var isObject = __webpack_require__(4);

__webpack_require__(24)('isFrozen', function ($isFrozen) {
  return function isFrozen(it) {
    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.13 Object.isSealed(O)
var isObject = __webpack_require__(4);

__webpack_require__(24)('isSealed', function ($isSealed) {
  return function isSealed(it) {
    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.11 Object.isExtensible(O)
var isObject = __webpack_require__(4);

__webpack_require__(24)('isExtensible', function ($isExtensible) {
  return function isExtensible(it) {
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(0);

$export($export.S + $export.F, 'Object', { assign: __webpack_require__(98) });


/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.10 Object.is(value1, value2)
var $export = __webpack_require__(0);
$export($export.S, 'Object', { is: __webpack_require__(99) });


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__(0);
$export($export.S, 'Object', { setPrototypeOf: __webpack_require__(71).set });


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {



// 19.1.3.6 Object.prototype.toString()
var classof = __webpack_require__(44);
var test = {};
test[__webpack_require__(5)('toStringTag')] = 'z';
if (test + '' != '[object z]') {
  __webpack_require__(12)(Object.prototype, 'toString', function toString() {
    return '[object ' + classof(this) + ']';
  }, true);
}


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = __webpack_require__(0);

$export($export.P, 'Function', { bind: __webpack_require__(100) });


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(8).f;
var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// 19.2.4.2 name
NAME in FProto || __webpack_require__(7) && dP(FProto, NAME, {
  configurable: true,
  get: function () {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});


/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {



var isObject = __webpack_require__(4);
var getPrototypeOf = __webpack_require__(17);
var HAS_INSTANCE = __webpack_require__(5)('hasInstance');
var FunctionProto = Function.prototype;
// 19.2.3.6 Function.prototype[@@hasInstance](V)
if (!(HAS_INSTANCE in FunctionProto)) __webpack_require__(8).f(FunctionProto, HAS_INSTANCE, { value: function (O) {
  if (typeof this != 'function' || !isObject(O)) return false;
  if (!isObject(this.prototype)) return O instanceof this;
  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
  while (O = getPrototypeOf(O)) if (this.prototype === O) return true;
  return false;
} });


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {



var global = __webpack_require__(2);
var has = __webpack_require__(14);
var cof = __webpack_require__(19);
var inheritIfRequired = __webpack_require__(72);
var toPrimitive = __webpack_require__(22);
var fails = __webpack_require__(3);
var gOPN = __webpack_require__(37).f;
var gOPD = __webpack_require__(16).f;
var dP = __webpack_require__(8).f;
var $trim = __webpack_require__(45).trim;
var NUMBER = 'Number';
var $Number = global[NUMBER];
var Base = $Number;
var proto = $Number.prototype;
// Opera ~12 has broken Object#toString
var BROKEN_COF = cof(__webpack_require__(36)(proto)) == NUMBER;
var TRIM = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber = function (argument) {
  var it = toPrimitive(argument, false);
  if (typeof it == 'string' && it.length > 2) {
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0);
    var third, radix, maxCode;
    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
        default: return +it;
      }
      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
  $Number = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var that = this;
    return that instanceof $Number
      // check on 1..constructor(foo) case
      && (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER)
        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for (var keys = __webpack_require__(7) ? gOPN(Base) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES6 (in case, if modules with ES6 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (has(Base, key = keys[j]) && !has($Number, key)) {
      dP($Number, key, gOPD(Base, key));
    }
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  __webpack_require__(12)(global, NUMBER, $Number);
}


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {



var $export = __webpack_require__(0);
var toInteger = __webpack_require__(20);
var aNumberValue = __webpack_require__(102);
var repeat = __webpack_require__(74);
var $toFixed = 1.0.toFixed;
var floor = Math.floor;
var data = [0, 0, 0, 0, 0, 0];
var ERROR = 'Number.toFixed: incorrect invocation!';
var ZERO = '0';

var multiply = function (n, c) {
  var i = -1;
  var c2 = c;
  while (++i < 6) {
    c2 += n * data[i];
    data[i] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};
var divide = function (n) {
  var i = 6;
  var c = 0;
  while (--i >= 0) {
    c += data[i];
    data[i] = floor(c / n);
    c = (c % n) * 1e7;
  }
};
var numToString = function () {
  var i = 6;
  var s = '';
  while (--i >= 0) {
    if (s !== '' || i === 0 || data[i] !== 0) {
      var t = String(data[i]);
      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
    }
  } return s;
};
var pow = function (x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};
var log = function (x) {
  var n = 0;
  var x2 = x;
  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }
  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  } return n;
};

$export($export.P + $export.F * (!!$toFixed && (
  0.00008.toFixed(3) !== '0.000' ||
  0.9.toFixed(0) !== '1' ||
  1.255.toFixed(2) !== '1.25' ||
  1000000000000000128.0.toFixed(0) !== '1000000000000000128'
) || !__webpack_require__(3)(function () {
  // V8 ~ Android 4.3-
  $toFixed.call({});
})), 'Number', {
  toFixed: function toFixed(fractionDigits) {
    var x = aNumberValue(this, ERROR);
    var f = toInteger(fractionDigits);
    var s = '';
    var m = ZERO;
    var e, z, j, k;
    if (f < 0 || f > 20) throw RangeError(ERROR);
    // eslint-disable-next-line no-self-compare
    if (x != x) return 'NaN';
    if (x <= -1e21 || x >= 1e21) return String(x);
    if (x < 0) {
      s = '-';
      x = -x;
    }
    if (x > 1e-21) {
      e = log(x * pow(2, 69, 1)) - 69;
      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if (e > 0) {
        multiply(0, z);
        j = f;
        while (j >= 7) {
          multiply(1e7, 0);
          j -= 7;
        }
        multiply(pow(10, j, 1), 0);
        j = e - 1;
        while (j >= 23) {
          divide(1 << 23);
          j -= 23;
        }
        divide(1 << j);
        multiply(1, 1);
        divide(2);
        m = numToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        m = numToString() + repeat.call(ZERO, f);
      }
    }
    if (f > 0) {
      k = m.length;
      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
    } else {
      m = s + m;
    } return m;
  }
});


/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {



var $export = __webpack_require__(0);
var $fails = __webpack_require__(3);
var aNumberValue = __webpack_require__(102);
var $toPrecision = 1.0.toPrecision;

$export($export.P + $export.F * ($fails(function () {
  // IE7-
  return $toPrecision.call(1, undefined) !== '1';
}) || !$fails(function () {
  // V8 ~ Android 4.3-
  $toPrecision.call({});
})), 'Number', {
  toPrecision: function toPrecision(precision) {
    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
  }
});


/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.1 Number.EPSILON
var $export = __webpack_require__(0);

$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.2 Number.isFinite(number)
var $export = __webpack_require__(0);
var _isFinite = __webpack_require__(2).isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it) {
    return typeof it == 'number' && _isFinite(it);
  }
});


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var $export = __webpack_require__(0);

$export($export.S, 'Number', { isInteger: __webpack_require__(103) });


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.4 Number.isNaN(number)
var $export = __webpack_require__(0);

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.5 Number.isSafeInteger(number)
var $export = __webpack_require__(0);
var isInteger = __webpack_require__(103);
var abs = Math.abs;

$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number) {
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = __webpack_require__(0);

$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = __webpack_require__(0);

$export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var $parseFloat = __webpack_require__(104);
// 20.1.2.12 Number.parseFloat(string)
$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', { parseFloat: $parseFloat });


/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var $parseInt = __webpack_require__(105);
// 20.1.2.13 Number.parseInt(string, radix)
$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', { parseInt: $parseInt });


/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var $parseInt = __webpack_require__(105);
// 18.2.5 parseInt(string, radix)
$export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt });


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var $parseFloat = __webpack_require__(104);
// 18.2.4 parseFloat(string)
$export($export.G + $export.F * (parseFloat != $parseFloat), { parseFloat: $parseFloat });


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.3 Math.acosh(x)
var $export = __webpack_require__(0);
var log1p = __webpack_require__(106);
var sqrt = Math.sqrt;
var $acosh = Math.acosh;

$export($export.S + $export.F * !($acosh
  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
  && Math.floor($acosh(Number.MAX_VALUE)) == 710
  // Tor Browser bug: Math.acosh(Infinity) -> NaN
  && $acosh(Infinity) == Infinity
), 'Math', {
  acosh: function acosh(x) {
    return (x = +x) < 1 ? NaN : x > 94906265.62425156
      ? Math.log(x) + Math.LN2
      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.5 Math.asinh(x)
var $export = __webpack_require__(0);
var $asinh = Math.asinh;

function asinh(x) {
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
}

// Tor Browser bug: Math.asinh(0) -> -0
$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.7 Math.atanh(x)
var $export = __webpack_require__(0);
var $atanh = Math.atanh;

// Tor Browser bug: Math.atanh(-0) -> 0
$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x) {
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});


/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.9 Math.cbrt(x)
var $export = __webpack_require__(0);
var sign = __webpack_require__(75);

$export($export.S, 'Math', {
  cbrt: function cbrt(x) {
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});


/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.11 Math.clz32(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  clz32: function clz32(x) {
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.12 Math.cosh(x)
var $export = __webpack_require__(0);
var exp = Math.exp;

$export($export.S, 'Math', {
  cosh: function cosh(x) {
    return (exp(x = +x) + exp(-x)) / 2;
  }
});


/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.14 Math.expm1(x)
var $export = __webpack_require__(0);
var $expm1 = __webpack_require__(76);

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 });


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.16 Math.fround(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', { fround: __webpack_require__(107) });


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.17 Math.hypot([value1[, value2[, â¦ ]]])
var $export = __webpack_require__(0);
var abs = Math.abs;

$export($export.S, 'Math', {
  hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;
    while (i < aLen) {
      arg = abs(arguments[i++]);
      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else sum += arg;
    }
    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.18 Math.imul(x, y)
var $export = __webpack_require__(0);
var $imul = Math.imul;

// some WebKit versions fails with big numbers, some has wrong arity
$export($export.S + $export.F * __webpack_require__(3)(function () {
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y) {
    var UINT16 = 0xffff;
    var xn = +x;
    var yn = +y;
    var xl = UINT16 & xn;
    var yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.21 Math.log10(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  log10: function log10(x) {
    return Math.log(x) * Math.LOG10E;
  }
});


/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.20 Math.log1p(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', { log1p: __webpack_require__(106) });


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.22 Math.log2(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  log2: function log2(x) {
    return Math.log(x) / Math.LN2;
  }
});


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.28 Math.sign(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', { sign: __webpack_require__(75) });


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.30 Math.sinh(x)
var $export = __webpack_require__(0);
var expm1 = __webpack_require__(76);
var exp = Math.exp;

// V8 near Chromium 38 has a problem with very small numbers
$export($export.S + $export.F * __webpack_require__(3)(function () {
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x) {
    return Math.abs(x = +x) < 1
      ? (expm1(x) - expm1(-x)) / 2
      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.33 Math.tanh(x)
var $export = __webpack_require__(0);
var expm1 = __webpack_require__(76);
var exp = Math.exp;

$export($export.S, 'Math', {
  tanh: function tanh(x) {
    var a = expm1(x = +x);
    var b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.34 Math.trunc(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  trunc: function trunc(it) {
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var toAbsoluteIndex = __webpack_require__(35);
var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars
    var res = [];
    var aLen = arguments.length;
    var i = 0;
    var code;
    while (aLen > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      );
    } return res.join('');
  }
});


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var toIObject = __webpack_require__(15);
var toLength = __webpack_require__(6);

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite) {
    var tpl = toIObject(callSite.raw);
    var len = toLength(tpl.length);
    var aLen = arguments.length;
    var res = [];
    var i = 0;
    while (len > i) {
      res.push(String(tpl[i++]));
      if (i < aLen) res.push(String(arguments[i]));
    } return res.join('');
  }
});


/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {



// 21.1.3.25 String.prototype.trim()
__webpack_require__(45)('trim', function ($trim) {
  return function trim() {
    return $trim(this, 3);
  };
});


/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {



var $export = __webpack_require__(0);
var $at = __webpack_require__(55)(false);
$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos) {
    return $at(this, pos);
  }
});


/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {


// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])

var $export = __webpack_require__(0);
var toLength = __webpack_require__(6);
var context = __webpack_require__(77);
var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];

$export($export.P + $export.F * __webpack_require__(78)(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString /* , endPosition = @length */) {
    var that = context(this, searchString, ENDS_WITH);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    var search = String(searchString);
    return $endsWith
      ? $endsWith.call(that, search, end)
      : that.slice(end - search.length, end) === search;
  }
});


/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {


// 21.1.3.7 String.prototype.includes(searchString, position = 0)

var $export = __webpack_require__(0);
var context = __webpack_require__(77);
var INCLUDES = 'includes';

$export($export.P + $export.F * __webpack_require__(78)(INCLUDES), 'String', {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~context(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: __webpack_require__(74)
});


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {


// 21.1.3.18 String.prototype.startsWith(searchString [, position ])

var $export = __webpack_require__(0);
var toLength = __webpack_require__(6);
var context = __webpack_require__(77);
var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];

$export($export.P + $export.F * __webpack_require__(78)(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith
      ? $startsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {



var $at = __webpack_require__(55)(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(79)(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {



// B.2.3.2 String.prototype.anchor(name)
__webpack_require__(13)('anchor', function (createHTML) {
  return function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  };
});


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {



// B.2.3.3 String.prototype.big()
__webpack_require__(13)('big', function (createHTML) {
  return function big() {
    return createHTML(this, 'big', '', '');
  };
});


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {



// B.2.3.4 String.prototype.blink()
__webpack_require__(13)('blink', function (createHTML) {
  return function blink() {
    return createHTML(this, 'blink', '', '');
  };
});


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {



// B.2.3.5 String.prototype.bold()
__webpack_require__(13)('bold', function (createHTML) {
  return function bold() {
    return createHTML(this, 'b', '', '');
  };
});


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {



// B.2.3.6 String.prototype.fixed()
__webpack_require__(13)('fixed', function (createHTML) {
  return function fixed() {
    return createHTML(this, 'tt', '', '');
  };
});


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {



// B.2.3.7 String.prototype.fontcolor(color)
__webpack_require__(13)('fontcolor', function (createHTML) {
  return function fontcolor(color) {
    return createHTML(this, 'font', 'color', color);
  };
});


/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {



// B.2.3.8 String.prototype.fontsize(size)
__webpack_require__(13)('fontsize', function (createHTML) {
  return function fontsize(size) {
    return createHTML(this, 'font', 'size', size);
  };
});


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {



// B.2.3.9 String.prototype.italics()
__webpack_require__(13)('italics', function (createHTML) {
  return function italics() {
    return createHTML(this, 'i', '', '');
  };
});


/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {



// B.2.3.10 String.prototype.link(url)
__webpack_require__(13)('link', function (createHTML) {
  return function link(url) {
    return createHTML(this, 'a', 'href', url);
  };
});


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {



// B.2.3.11 String.prototype.small()
__webpack_require__(13)('small', function (createHTML) {
  return function small() {
    return createHTML(this, 'small', '', '');
  };
});


/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {



// B.2.3.12 String.prototype.strike()
__webpack_require__(13)('strike', function (createHTML) {
  return function strike() {
    return createHTML(this, 'strike', '', '');
  };
});


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {



// B.2.3.13 String.prototype.sub()
__webpack_require__(13)('sub', function (createHTML) {
  return function sub() {
    return createHTML(this, 'sub', '', '');
  };
});


/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {



// B.2.3.14 String.prototype.sup()
__webpack_require__(13)('sup', function (createHTML) {
  return function sup() {
    return createHTML(this, 'sup', '', '');
  };
});


/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = __webpack_require__(0);

$export($export.S, 'Array', { isArray: __webpack_require__(54) });


/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {



var ctx = __webpack_require__(18);
var $export = __webpack_require__(0);
var toObject = __webpack_require__(9);
var call = __webpack_require__(108);
var isArrayIter = __webpack_require__(81);
var toLength = __webpack_require__(6);
var createProperty = __webpack_require__(82);
var getIterFn = __webpack_require__(83);

$export($export.S + $export.F * !__webpack_require__(57)(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {



var $export = __webpack_require__(0);
var createProperty = __webpack_require__(82);

// WebKit Array.of isn't generic
$export($export.S + $export.F * __webpack_require__(3)(function () {
  function F() { /* empty */ }
  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of(/* ...args */) {
    var index = 0;
    var aLen = arguments.length;
    var result = new (typeof this == 'function' ? this : Array)(aLen);
    while (aLen > index) createProperty(result, index, arguments[index++]);
    result.length = aLen;
    return result;
  }
});


/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {



// 22.1.3.13 Array.prototype.join(separator)
var $export = __webpack_require__(0);
var toIObject = __webpack_require__(15);
var arrayJoin = [].join;

// fallback for not array-like strings
$export($export.P + $export.F * (__webpack_require__(48) != Object || !__webpack_require__(21)(arrayJoin)), 'Array', {
  join: function join(separator) {
    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
  }
});


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {



var $export = __webpack_require__(0);
var html = __webpack_require__(70);
var cof = __webpack_require__(19);
var toAbsoluteIndex = __webpack_require__(35);
var toLength = __webpack_require__(6);
var arraySlice = [].slice;

// fallback for not array-like ES3 strings and DOM objects
$export($export.P + $export.F * __webpack_require__(3)(function () {
  if (html) arraySlice.call(html);
}), 'Array', {
  slice: function slice(begin, end) {
    var len = toLength(this.length);
    var klass = cof(this);
    end = end === undefined ? len : end;
    if (klass == 'Array') return arraySlice.call(this, begin, end);
    var start = toAbsoluteIndex(begin, len);
    var upTo = toAbsoluteIndex(end, len);
    var size = toLength(upTo - start);
    var cloned = new Array(size);
    var i = 0;
    for (; i < size; i++) cloned[i] = klass == 'String'
      ? this.charAt(start + i)
      : this[start + i];
    return cloned;
  }
});


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {



var $export = __webpack_require__(0);
var aFunction = __webpack_require__(10);
var toObject = __webpack_require__(9);
var fails = __webpack_require__(3);
var $sort = [].sort;
var test = [1, 2, 3];

$export($export.P + $export.F * (fails(function () {
  // IE8-
  test.sort(undefined);
}) || !fails(function () {
  // V8 bug
  test.sort(null);
  // Old WebKit
}) || !__webpack_require__(21)($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn) {
    return comparefn === undefined
      ? $sort.call(toObject(this))
      : $sort.call(toObject(this), aFunction(comparefn));
  }
});


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {



var $export = __webpack_require__(0);
var $forEach = __webpack_require__(25)(0);
var STRICT = __webpack_require__(21)([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn /* , thisArg */) {
    return $forEach(this, callbackfn, arguments[1]);
  }
});


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(4);
var isArray = __webpack_require__(54);
var SPECIES = __webpack_require__(5)('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};


/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {



var $export = __webpack_require__(0);
var $map = __webpack_require__(25)(1);

$export($export.P + $export.F * !__webpack_require__(21)([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments[1]);
  }
});


/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {



var $export = __webpack_require__(0);
var $filter = __webpack_require__(25)(2);

$export($export.P + $export.F * !__webpack_require__(21)([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments[1]);
  }
});


/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {



var $export = __webpack_require__(0);
var $some = __webpack_require__(25)(3);

$export($export.P + $export.F * !__webpack_require__(21)([].some, true), 'Array', {
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn /* , thisArg */) {
    return $some(this, callbackfn, arguments[1]);
  }
});


/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {



var $export = __webpack_require__(0);
var $every = __webpack_require__(25)(4);

$export($export.P + $export.F * !__webpack_require__(21)([].every, true), 'Array', {
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn /* , thisArg */) {
    return $every(this, callbackfn, arguments[1]);
  }
});


/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {



var $export = __webpack_require__(0);
var $reduce = __webpack_require__(109);

$export($export.P + $export.F * !__webpack_require__(21)([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});


/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {



var $export = __webpack_require__(0);
var $reduce = __webpack_require__(109);

$export($export.P + $export.F * !__webpack_require__(21)([].reduceRight, true), 'Array', {
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: function reduceRight(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
  }
});


/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {



var $export = __webpack_require__(0);
var $indexOf = __webpack_require__(52)(false);
var $native = [].indexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(21)($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? $native.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments[1]);
  }
});


/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {



var $export = __webpack_require__(0);
var toIObject = __webpack_require__(15);
var toInteger = __webpack_require__(20);
var toLength = __webpack_require__(6);
var $native = [].lastIndexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(21)($native)), 'Array', {
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
    // convert -0 to +0
    if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
    var O = toIObject(this);
    var length = toLength(O.length);
    var index = length - 1;
    if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
    if (index < 0) index = length + index;
    for (;index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0;
    return -1;
  }
});


/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = __webpack_require__(0);

$export($export.P, 'Array', { copyWithin: __webpack_require__(110) });

__webpack_require__(31)('copyWithin');


/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = __webpack_require__(0);

$export($export.P, 'Array', { fill: __webpack_require__(85) });

__webpack_require__(31)('fill');


/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {



// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = __webpack_require__(0);
var $find = __webpack_require__(25)(5);
var KEY = 'find';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__webpack_require__(31)(KEY);


/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {



// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var $export = __webpack_require__(0);
var $find = __webpack_require__(25)(6);
var KEY = 'findIndex';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__webpack_require__(31)(KEY);


/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(38)('Array');


/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var inheritIfRequired = __webpack_require__(72);
var dP = __webpack_require__(8).f;
var gOPN = __webpack_require__(37).f;
var isRegExp = __webpack_require__(56);
var $flags = __webpack_require__(50);
var $RegExp = global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;
// "new" creates a new object, old webkit buggy here
var CORRECT_NEW = new $RegExp(re1) !== re1;

if (__webpack_require__(7) && (!CORRECT_NEW || __webpack_require__(3)(function () {
  re2[__webpack_require__(5)('match')] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
    var tiRE = this instanceof $RegExp;
    var piRE = isRegExp(p);
    var fiU = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
      : inheritIfRequired(CORRECT_NEW
        ? new Base(piRE && !fiU ? p.source : p, f)
        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
      , tiRE ? this : proto, $RegExp);
  };
  var proxy = function (key) {
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function () { return Base[key]; },
      set: function (it) { Base[key] = it; }
    });
  };
  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);
  proto.constructor = $RegExp;
  $RegExp.prototype = proto;
  __webpack_require__(12)(global, 'RegExp', $RegExp);
}

__webpack_require__(38)('RegExp');


/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {



__webpack_require__(113);
var anObject = __webpack_require__(1);
var $flags = __webpack_require__(50);
var DESCRIPTORS = __webpack_require__(7);
var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function (fn) {
  __webpack_require__(12)(RegExp.prototype, TO_STRING, fn, true);
};

// 21.2.5.14 RegExp.prototype.toString()
if (__webpack_require__(3)(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {
  define(function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/',
      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  });
// FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}


/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {




var anObject = __webpack_require__(1);
var toLength = __webpack_require__(6);
var advanceStringIndex = __webpack_require__(88);
var regExpExec = __webpack_require__(58);

// @@match logic
__webpack_require__(59)('match', 1, function (defined, MATCH, $match, maybeCallNative) {
  return [
    // `String.prototype.match` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.match
    function match(regexp) {
      var O = defined(this);
      var fn = regexp == undefined ? undefined : regexp[MATCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
    },
    // `RegExp.prototype[@@match]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
    function (regexp) {
      var res = maybeCallNative($match, regexp, this);
      if (res.done) return res.value;
      var rx = anObject(regexp);
      var S = String(this);
      if (!rx.global) return regExpExec(rx, S);
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
      var A = [];
      var n = 0;
      var result;
      while ((result = regExpExec(rx, S)) !== null) {
        var matchStr = String(result[0]);
        A[n] = matchStr;
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
        n++;
      }
      return n === 0 ? null : A;
    }
  ];
});


/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {




var anObject = __webpack_require__(1);
var toObject = __webpack_require__(9);
var toLength = __webpack_require__(6);
var toInteger = __webpack_require__(20);
var advanceStringIndex = __webpack_require__(88);
var regExpExec = __webpack_require__(58);
var max = Math.max;
var min = Math.min;
var floor = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
};

// @@replace logic
__webpack_require__(59)('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {
  return [
    // `String.prototype.replace` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.replace
    function replace(searchValue, replaceValue) {
      var O = defined(this);
      var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
      return fn !== undefined
        ? fn.call(searchValue, O, replaceValue)
        : $replace.call(String(O), searchValue, replaceValue);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
    function (regexp, replaceValue) {
      var res = maybeCallNative($replace, regexp, this, replaceValue);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var functionalReplace = typeof replaceValue === 'function';
      if (!functionalReplace) replaceValue = String(replaceValue);
      var global = rx.global;
      if (global) {
        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }
      var results = [];
      while (true) {
        var result = regExpExec(rx, S);
        if (result === null) break;
        results.push(result);
        if (!global) break;
        var matchStr = String(result[0]);
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      }
      var accumulatedResult = '';
      var nextSourcePosition = 0;
      for (var i = 0; i < results.length; i++) {
        result = results[i];
        var matched = String(result[0]);
        var position = max(min(toInteger(result.index), S.length), 0);
        var captures = [];
        // NOTE: This is equivalent to
        //   captures = result.slice(1).map(maybeToString)
        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = [matched].concat(captures, position, S);
          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
          var replacement = String(replaceValue.apply(undefined, replacerArgs));
        } else {
          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
        }
        if (position >= nextSourcePosition) {
          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
          nextSourcePosition = position + matched.length;
        }
      }
      return accumulatedResult + S.slice(nextSourcePosition);
    }
  ];

    // https://tc39.github.io/ecma262/#sec-getsubstitution
  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
    if (namedCaptures !== undefined) {
      namedCaptures = toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }
    return $replace.call(replacement, symbols, function (match, ch) {
      var capture;
      switch (ch.charAt(0)) {
        case '$': return '$';
        case '&': return matched;
        case '`': return str.slice(0, position);
        case "'": return str.slice(tailPos);
        case '<':
          capture = namedCaptures[ch.slice(1, -1)];
          break;
        default: // \d\d?
          var n = +ch;
          if (n === 0) return match;
          if (n > m) {
            var f = floor(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return match;
          }
          capture = captures[n - 1];
      }
      return capture === undefined ? '' : capture;
    });
  }
});


/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {




var anObject = __webpack_require__(1);
var sameValue = __webpack_require__(99);
var regExpExec = __webpack_require__(58);

// @@search logic
__webpack_require__(59)('search', 1, function (defined, SEARCH, $search, maybeCallNative) {
  return [
    // `String.prototype.search` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.search
    function search(regexp) {
      var O = defined(this);
      var fn = regexp == undefined ? undefined : regexp[SEARCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
    },
    // `RegExp.prototype[@@search]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
    function (regexp) {
      var res = maybeCallNative($search, regexp, this);
      if (res.done) return res.value;
      var rx = anObject(regexp);
      var S = String(this);
      var previousLastIndex = rx.lastIndex;
      if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
      var result = regExpExec(rx, S);
      if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
      return result === null ? -1 : result.index;
    }
  ];
});


/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {




var isRegExp = __webpack_require__(56);
var anObject = __webpack_require__(1);
var speciesConstructor = __webpack_require__(51);
var advanceStringIndex = __webpack_require__(88);
var toLength = __webpack_require__(6);
var callRegExpExec = __webpack_require__(58);
var regexpExec = __webpack_require__(87);
var fails = __webpack_require__(3);
var $min = Math.min;
var $push = [].push;
var $SPLIT = 'split';
var LENGTH = 'length';
var LAST_INDEX = 'lastIndex';
var MAX_UINT32 = 0xffffffff;

// babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
var SUPPORTS_Y = !fails(function () { RegExp(MAX_UINT32, 'y'); });

// @@split logic
__webpack_require__(59)('split', 2, function (defined, SPLIT, $split, maybeCallNative) {
  var internalSplit;
  if (
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function (separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return [];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) return $split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? MAX_UINT32 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;
      while (match = regexpExec.call(separatorCopy, string)) {
        lastIndex = separatorCopy[LAST_INDEX];
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }
        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    internalSplit = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : $split.call(this, separator, limit);
    };
  } else {
    internalSplit = $split;
  }

  return [
    // `String.prototype.split` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.split
    function split(separator, limit) {
      var O = defined(this);
      var splitter = separator == undefined ? undefined : separator[SPLIT];
      return splitter !== undefined
        ? splitter.call(separator, O, limit)
        : internalSplit.call(String(O), separator, limit);
    },
    // `RegExp.prototype[@@split]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
    //
    // NOTE: This cannot be properly polyfilled in engines that don't support
    // the 'y' flag.
    function (regexp, limit) {
      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== $split);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var C = speciesConstructor(rx, RegExp);

      var unicodeMatching = rx.unicode;
      var flags = (rx.ignoreCase ? 'i' : '') +
                  (rx.multiline ? 'm' : '') +
                  (rx.unicode ? 'u' : '') +
                  (SUPPORTS_Y ? 'y' : 'g');

      // ^(? + rx + ) is needed, in combination with some S slicing, to
      // simulate the 'y' flag.
      var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
      var p = 0;
      var q = 0;
      var A = [];
      while (q < S.length) {
        splitter.lastIndex = SUPPORTS_Y ? q : 0;
        var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
        var e;
        if (
          z === null ||
          (e = $min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p
        ) {
          q = advanceStringIndex(S, q, unicodeMatching);
        } else {
          A.push(S.slice(p, q));
          if (A.length === lim) return A;
          for (var i = 1; i <= z.length - 1; i++) {
            A.push(z[i]);
            if (A.length === lim) return A;
          }
          q = p = e;
        }
      }
      A.push(S.slice(p));
      return A;
    }
  ];
});


/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {



var LIBRARY = __webpack_require__(29);
var global = __webpack_require__(2);
var ctx = __webpack_require__(18);
var classof = __webpack_require__(44);
var $export = __webpack_require__(0);
var isObject = __webpack_require__(4);
var aFunction = __webpack_require__(10);
var anInstance = __webpack_require__(39);
var forOf = __webpack_require__(40);
var speciesConstructor = __webpack_require__(51);
var task = __webpack_require__(89).set;
var microtask = __webpack_require__(90)();
var newPromiseCapabilityModule = __webpack_require__(91);
var perform = __webpack_require__(114);
var userAgent = __webpack_require__(60);
var promiseResolve = __webpack_require__(115);
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[__webpack_require__(5)('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function')
      && promise.then(empty) instanceof FakePromise
      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // we can't detect it synchronously, so just check versions
      && v8.indexOf('6.6') !== 0
      && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // may throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = __webpack_require__(41)($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
__webpack_require__(43)($Promise, PROMISE);
__webpack_require__(38)(PROMISE);
Wrapper = __webpack_require__(26)[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(57)(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});


/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {



var weak = __webpack_require__(120);
var validate = __webpack_require__(42);
var WEAK_SET = 'WeakSet';

// 23.4 WeakSet Objects
__webpack_require__(61)(WEAK_SET, function (get) {
  return function WeakSet() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value) {
    return weak.def(validate(this, WEAK_SET), value, true);
  }
}, weak, false, true);


/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export = __webpack_require__(0);
var aFunction = __webpack_require__(10);
var anObject = __webpack_require__(1);
var rApply = (__webpack_require__(2).Reflect || {}).apply;
var fApply = Function.apply;
// MS Edge argumentsList argument is optional
$export($export.S + $export.F * !__webpack_require__(3)(function () {
  rApply(function () { /* empty */ });
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList) {
    var T = aFunction(target);
    var L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});


/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export = __webpack_require__(0);
var create = __webpack_require__(36);
var aFunction = __webpack_require__(10);
var anObject = __webpack_require__(1);
var isObject = __webpack_require__(4);
var fails = __webpack_require__(3);
var bind = __webpack_require__(100);
var rConstruct = (__webpack_require__(2).Reflect || {}).construct;

// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(rConstruct(function () { /* empty */ }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  rConstruct(function () { /* empty */ });
});

$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args /* , newTarget */) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});


/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP = __webpack_require__(8);
var $export = __webpack_require__(0);
var anObject = __webpack_require__(1);
var toPrimitive = __webpack_require__(22);

// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
$export($export.S + $export.F * __webpack_require__(3)(function () {
  // eslint-disable-next-line no-undef
  Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 });
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes) {
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);
    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch (e) {
      return false;
    }
  }
});


/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export = __webpack_require__(0);
var gOPD = __webpack_require__(16).f;
var anObject = __webpack_require__(1);

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey) {
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});


/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {



// 26.1.5 Reflect.enumerate(target)
var $export = __webpack_require__(0);
var anObject = __webpack_require__(1);
var Enumerate = function (iterated) {
  this._t = anObject(iterated); // target
  this._i = 0;                  // next index
  var keys = this._k = [];      // keys
  var key;
  for (key in iterated) keys.push(key);
};
__webpack_require__(80)(Enumerate, 'Object', function () {
  var that = this;
  var keys = that._k;
  var key;
  do {
    if (that._i >= keys.length) return { value: undefined, done: true };
  } while (!((key = keys[that._i++]) in that._t));
  return { value: key, done: false };
});

$export($export.S, 'Reflect', {
  enumerate: function enumerate(target) {
    return new Enumerate(target);
  }
});


/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD = __webpack_require__(16);
var getPrototypeOf = __webpack_require__(17);
var has = __webpack_require__(14);
var $export = __webpack_require__(0);
var isObject = __webpack_require__(4);
var anObject = __webpack_require__(1);

function get(target, propertyKey /* , receiver */) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var desc, proto;
  if (anObject(target) === receiver) return target[propertyKey];
  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value')
    ? desc.value
    : desc.get !== undefined
      ? desc.get.call(receiver)
      : undefined;
  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', { get: get });


/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD = __webpack_require__(16);
var $export = __webpack_require__(0);
var anObject = __webpack_require__(1);

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
    return gOPD.f(anObject(target), propertyKey);
  }
});


/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.8 Reflect.getPrototypeOf(target)
var $export = __webpack_require__(0);
var getProto = __webpack_require__(17);
var anObject = __webpack_require__(1);

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target) {
    return getProto(anObject(target));
  }
});


/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.9 Reflect.has(target, propertyKey)
var $export = __webpack_require__(0);

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey) {
    return propertyKey in target;
  }
});


/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.10 Reflect.isExtensible(target)
var $export = __webpack_require__(0);
var anObject = __webpack_require__(1);
var $isExtensible = Object.isExtensible;

$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target) {
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});


/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.11 Reflect.ownKeys(target)
var $export = __webpack_require__(0);

$export($export.S, 'Reflect', { ownKeys: __webpack_require__(121) });


/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.12 Reflect.preventExtensions(target)
var $export = __webpack_require__(0);
var anObject = __webpack_require__(1);
var $preventExtensions = Object.preventExtensions;

$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target) {
    anObject(target);
    try {
      if ($preventExtensions) $preventExtensions(target);
      return true;
    } catch (e) {
      return false;
    }
  }
});


/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP = __webpack_require__(8);
var gOPD = __webpack_require__(16);
var getPrototypeOf = __webpack_require__(17);
var has = __webpack_require__(14);
var $export = __webpack_require__(0);
var createDesc = __webpack_require__(32);
var anObject = __webpack_require__(1);
var isObject = __webpack_require__(4);

function set(target, propertyKey, V /* , receiver */) {
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDesc = gOPD.f(anObject(target), propertyKey);
  var existingDescriptor, proto;
  if (!ownDesc) {
    if (isObject(proto = getPrototypeOf(target))) {
      return set(proto, propertyKey, V, receiver);
    }
    ownDesc = createDesc(0);
  }
  if (has(ownDesc, 'value')) {
    if (ownDesc.writable === false || !isObject(receiver)) return false;
    if (existingDescriptor = gOPD.f(receiver, propertyKey)) {
      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
      existingDescriptor.value = V;
      dP.f(receiver, propertyKey, existingDescriptor);
    } else dP.f(receiver, propertyKey, createDesc(0, V));
    return true;
  }
  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', { set: set });


/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export = __webpack_require__(0);
var setProto = __webpack_require__(71);

if (setProto) $export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto) {
    setProto.check(target, proto);
    try {
      setProto.set(target, proto);
      return true;
    } catch (e) {
      return false;
    }
  }
});


/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = __webpack_require__(0);

$export($export.S, 'Date', { now: function () { return new Date().getTime(); } });


/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {



var $export = __webpack_require__(0);
var toObject = __webpack_require__(9);
var toPrimitive = __webpack_require__(22);

$export($export.P + $export.F * __webpack_require__(3)(function () {
  return new Date(NaN).toJSON() !== null
    || Date.prototype.toJSON.call({ toISOString: function () { return 1; } }) !== 1;
}), 'Date', {
  // eslint-disable-next-line no-unused-vars
  toJSON: function toJSON(key) {
    var O = toObject(this);
    var pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});


/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var $export = __webpack_require__(0);
var toISOString = __webpack_require__(252);

// PhantomJS / old WebKit has a broken implementations
$export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {
  toISOString: toISOString
});


/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {



// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var fails = __webpack_require__(3);
var getTime = Date.prototype.getTime;
var $toISOString = Date.prototype.toISOString;

var lz = function (num) {
  return num > 9 ? num : '0' + num;
};

// PhantomJS / old WebKit has a broken implementations
module.exports = (fails(function () {
  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
}) || !fails(function () {
  $toISOString.call(new Date(NaN));
})) ? function toISOString() {
  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
  var d = this;
  var y = d.getUTCFullYear();
  var m = d.getUTCMilliseconds();
  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
    '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
    'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
    ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
} : $toISOString;


/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

var DateProto = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var $toString = DateProto[TO_STRING];
var getTime = DateProto.getTime;
if (new Date(NaN) + '' != INVALID_DATE) {
  __webpack_require__(12)(DateProto, TO_STRING, function toString() {
    var value = getTime.call(this);
    // eslint-disable-next-line no-self-compare
    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}


/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

var TO_PRIMITIVE = __webpack_require__(5)('toPrimitive');
var proto = Date.prototype;

if (!(TO_PRIMITIVE in proto)) __webpack_require__(11)(proto, TO_PRIMITIVE, __webpack_require__(255));


/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {



var anObject = __webpack_require__(1);
var toPrimitive = __webpack_require__(22);
var NUMBER = 'number';

module.exports = function (hint) {
  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};


/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {



var $export = __webpack_require__(0);
var $typed = __webpack_require__(62);
var buffer = __webpack_require__(92);
var anObject = __webpack_require__(1);
var toAbsoluteIndex = __webpack_require__(35);
var toLength = __webpack_require__(6);
var isObject = __webpack_require__(4);
var ArrayBuffer = __webpack_require__(2).ArrayBuffer;
var speciesConstructor = __webpack_require__(51);
var $ArrayBuffer = buffer.ArrayBuffer;
var $DataView = buffer.DataView;
var $isView = $typed.ABV && ArrayBuffer.isView;
var $slice = $ArrayBuffer.prototype.slice;
var VIEW = $typed.VIEW;
var ARRAY_BUFFER = 'ArrayBuffer';

$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });

$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it) {
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});

$export($export.P + $export.U + $export.F * __webpack_require__(3)(function () {
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end) {
    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix
    var len = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, len);
    var fin = toAbsoluteIndex(end === undefined ? len : end, len);
    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(fin - first));
    var viewS = new $DataView(this);
    var viewT = new $DataView(result);
    var index = 0;
    while (first < fin) {
      viewT.setUint8(index++, viewS.getUint8(first++));
    } return result;
  }
});

__webpack_require__(38)(ARRAY_BUFFER);


/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
$export($export.G + $export.W + $export.F * !__webpack_require__(62).ABV, {
  DataView: __webpack_require__(92).DataView
});


/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(27)('Int8', 1, function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(27)('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(27)('Uint8', 1, function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);


/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(27)('Int16', 2, function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(27)('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(27)('Int32', 4, function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(27)('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(27)('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(27)('Float64', 8, function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {



// https://github.com/tc39/Array.prototype.includes
var $export = __webpack_require__(0);
var $includes = __webpack_require__(52)(true);

$export($export.P, 'Array', {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__(31)('includes');


/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {



// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap
var $export = __webpack_require__(0);
var flattenIntoArray = __webpack_require__(123);
var toObject = __webpack_require__(9);
var toLength = __webpack_require__(6);
var aFunction = __webpack_require__(10);
var arraySpeciesCreate = __webpack_require__(84);

$export($export.P, 'Array', {
  flatMap: function flatMap(callbackfn /* , thisArg */) {
    var O = toObject(this);
    var sourceLen, A;
    aFunction(callbackfn);
    sourceLen = toLength(O.length);
    A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
    return A;
  }
});

__webpack_require__(31)('flatMap');


/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {



// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatten
var $export = __webpack_require__(0);
var flattenIntoArray = __webpack_require__(123);
var toObject = __webpack_require__(9);
var toLength = __webpack_require__(6);
var toInteger = __webpack_require__(20);
var arraySpeciesCreate = __webpack_require__(84);

$export($export.P, 'Array', {
  flatten: function flatten(/* depthArg = 1 */) {
    var depthArg = arguments[0];
    var O = toObject(this);
    var sourceLen = toLength(O.length);
    var A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
    return A;
  }
});

__webpack_require__(31)('flatten');


/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {



// https://github.com/mathiasbynens/String.prototype.at
var $export = __webpack_require__(0);
var $at = __webpack_require__(55)(true);

$export($export.P, 'String', {
  at: function at(pos) {
    return $at(this, pos);
  }
});


/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {



// https://github.com/tc39/proposal-string-pad-start-end
var $export = __webpack_require__(0);
var $pad = __webpack_require__(124);
var userAgent = __webpack_require__(60);

// https://github.com/zloirock/core-js/issues/280
var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);

$export($export.P + $export.F * WEBKIT_BUG, 'String', {
  padStart: function padStart(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});


/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {



// https://github.com/tc39/proposal-string-pad-start-end
var $export = __webpack_require__(0);
var $pad = __webpack_require__(124);
var userAgent = __webpack_require__(60);

// https://github.com/zloirock/core-js/issues/280
var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);

$export($export.P + $export.F * WEBKIT_BUG, 'String', {
  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});


/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {



// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
__webpack_require__(45)('trimLeft', function ($trim) {
  return function trimLeft() {
    return $trim(this, 1);
  };
}, 'trimStart');


/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {



// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
__webpack_require__(45)('trimRight', function ($trim) {
  return function trimRight() {
    return $trim(this, 2);
  };
}, 'trimEnd');


/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {



// https://tc39.github.io/String.prototype.matchAll/
var $export = __webpack_require__(0);
var defined = __webpack_require__(23);
var toLength = __webpack_require__(6);
var isRegExp = __webpack_require__(56);
var getFlags = __webpack_require__(50);
var RegExpProto = RegExp.prototype;

var $RegExpStringIterator = function (regexp, string) {
  this._r = regexp;
  this._s = string;
};

__webpack_require__(80)($RegExpStringIterator, 'RegExp String', function next() {
  var match = this._r.exec(this._s);
  return { value: match, done: match === null };
});

$export($export.P, 'String', {
  matchAll: function matchAll(regexp) {
    defined(this);
    if (!isRegExp(regexp)) throw TypeError(regexp + ' is not a regexp!');
    var S = String(this);
    var flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp);
    var rx = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
    rx.lastIndex = toLength(regexp.lastIndex);
    return new $RegExpStringIterator(rx, S);
  }
});


/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(67)('asyncIterator');


/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(67)('observable');


/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export = __webpack_require__(0);
var ownKeys = __webpack_require__(121);
var toIObject = __webpack_require__(15);
var gOPD = __webpack_require__(16);
var createProperty = __webpack_require__(82);

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIObject(object);
    var getDesc = gOPD.f;
    var keys = ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;
    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) createProperty(result, key, desc);
    }
    return result;
  }
});


/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(0);
var $values = __webpack_require__(125)(false);

$export($export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  }
});


/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(0);
var $entries = __webpack_require__(125)(true);

$export($export.S, 'Object', {
  entries: function entries(it) {
    return $entries(it);
  }
});


/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {



var $export = __webpack_require__(0);
var toObject = __webpack_require__(9);
var aFunction = __webpack_require__(10);
var $defineProperty = __webpack_require__(8);

// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
__webpack_require__(7) && $export($export.P + __webpack_require__(63), 'Object', {
  __defineGetter__: function __defineGetter__(P, getter) {
    $defineProperty.f(toObject(this), P, { get: aFunction(getter), enumerable: true, configurable: true });
  }
});


/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {



var $export = __webpack_require__(0);
var toObject = __webpack_require__(9);
var aFunction = __webpack_require__(10);
var $defineProperty = __webpack_require__(8);

// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
__webpack_require__(7) && $export($export.P + __webpack_require__(63), 'Object', {
  __defineSetter__: function __defineSetter__(P, setter) {
    $defineProperty.f(toObject(this), P, { set: aFunction(setter), enumerable: true, configurable: true });
  }
});


/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {



var $export = __webpack_require__(0);
var toObject = __webpack_require__(9);
var toPrimitive = __webpack_require__(22);
var getPrototypeOf = __webpack_require__(17);
var getOwnPropertyDescriptor = __webpack_require__(16).f;

// B.2.2.4 Object.prototype.__lookupGetter__(P)
__webpack_require__(7) && $export($export.P + __webpack_require__(63), 'Object', {
  __lookupGetter__: function __lookupGetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;
    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.get;
    } while (O = getPrototypeOf(O));
  }
});


/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {



var $export = __webpack_require__(0);
var toObject = __webpack_require__(9);
var toPrimitive = __webpack_require__(22);
var getPrototypeOf = __webpack_require__(17);
var getOwnPropertyDescriptor = __webpack_require__(16).f;

// B.2.2.5 Object.prototype.__lookupSetter__(P)
__webpack_require__(7) && $export($export.P + __webpack_require__(63), 'Object', {
  __lookupSetter__: function __lookupSetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;
    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.set;
    } while (O = getPrototypeOf(O));
  }
});


/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = __webpack_require__(0);

$export($export.P + $export.R, 'Map', { toJSON: __webpack_require__(126)('Map') });


/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = __webpack_require__(0);

$export($export.P + $export.R, 'Set', { toJSON: __webpack_require__(126)('Set') });


/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
__webpack_require__(64)('Map');


/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
__webpack_require__(64)('Set');


/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
__webpack_require__(64)('WeakMap');


/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of
__webpack_require__(64)('WeakSet');


/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
__webpack_require__(65)('Map');


/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
__webpack_require__(65)('Set');


/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
__webpack_require__(65)('WeakMap');


/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from
__webpack_require__(65)('WeakSet');


/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-global
var $export = __webpack_require__(0);

$export($export.G, { global: __webpack_require__(2) });


/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-global
var $export = __webpack_require__(0);

$export($export.S, 'System', { global: __webpack_require__(2) });


/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/ljharb/proposal-is-error
var $export = __webpack_require__(0);
var cof = __webpack_require__(19);

$export($export.S, 'Error', {
  isError: function isError(it) {
    return cof(it) === 'Error';
  }
});


/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  clamp: function clamp(x, lower, upper) {
    return Math.min(upper, Math.max(lower, x));
  }
});


/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);

$export($export.S, 'Math', { DEG_PER_RAD: Math.PI / 180 });


/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);
var RAD_PER_DEG = 180 / Math.PI;

$export($export.S, 'Math', {
  degrees: function degrees(radians) {
    return radians * RAD_PER_DEG;
  }
});


/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);
var scale = __webpack_require__(128);
var fround = __webpack_require__(107);

$export($export.S, 'Math', {
  fscale: function fscale(x, inLow, inHigh, outLow, outHigh) {
    return fround(scale(x, inLow, inHigh, outLow, outHigh));
  }
});


/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  iaddh: function iaddh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
  }
});


/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  isubh: function isubh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
  }
});


/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  imulh: function imulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >> 16;
    var v1 = $v >> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
  }
});


/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);

$export($export.S, 'Math', { RAD_PER_DEG: 180 / Math.PI });


/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);
var DEG_PER_RAD = Math.PI / 180;

$export($export.S, 'Math', {
  radians: function radians(degrees) {
    return degrees * DEG_PER_RAD;
  }
});


/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);

$export($export.S, 'Math', { scale: __webpack_require__(128) });


/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  umulh: function umulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >>> 16;
    var v1 = $v >>> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
  }
});


/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

// http://jfbastien.github.io/papers/Math.signbit.html
var $export = __webpack_require__(0);

$export($export.S, 'Math', { signbit: function signbit(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) != x ? x : x == 0 ? 1 / x == Infinity : x > 0;
} });


/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {


// https://github.com/tc39/proposal-promise-finally

var $export = __webpack_require__(0);
var core = __webpack_require__(26);
var global = __webpack_require__(2);
var speciesConstructor = __webpack_require__(51);
var promiseResolve = __webpack_require__(115);

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });


/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {



// https://github.com/tc39/proposal-promise-try
var $export = __webpack_require__(0);
var newPromiseCapability = __webpack_require__(91);
var perform = __webpack_require__(114);

$export($export.S, 'Promise', { 'try': function (callbackfn) {
  var promiseCapability = newPromiseCapability.f(this);
  var result = perform(callbackfn);
  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
  return promiseCapability.promise;
} });


/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(28);
var anObject = __webpack_require__(1);
var toMetaKey = metadata.key;
var ordinaryDefineOwnMetadata = metadata.set;

metadata.exp({ defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) {
  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
} });


/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(28);
var anObject = __webpack_require__(1);
var toMetaKey = metadata.key;
var getOrCreateMetadataMap = metadata.map;
var store = metadata.store;

metadata.exp({ deleteMetadata: function deleteMetadata(metadataKey, target /* , targetKey */) {
  var targetKey = arguments.length < 3 ? undefined : toMetaKey(arguments[2]);
  var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
  if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;
  if (metadataMap.size) return true;
  var targetMetadata = store.get(target);
  targetMetadata['delete'](targetKey);
  return !!targetMetadata.size || store['delete'](target);
} });


/***/ }),
/* 314 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(28);
var anObject = __webpack_require__(1);
var getPrototypeOf = __webpack_require__(17);
var ordinaryHasOwnMetadata = metadata.has;
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

var ordinaryGetMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P);
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
};

metadata.exp({ getMetadata: function getMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });


/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

var Set = __webpack_require__(118);
var from = __webpack_require__(127);
var metadata = __webpack_require__(28);
var anObject = __webpack_require__(1);
var getPrototypeOf = __webpack_require__(17);
var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

var ordinaryMetadataKeys = function (O, P) {
  var oKeys = ordinaryOwnMetadataKeys(O, P);
  var parent = getPrototypeOf(O);
  if (parent === null) return oKeys;
  var pKeys = ordinaryMetadataKeys(parent, P);
  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
};

metadata.exp({ getMetadataKeys: function getMetadataKeys(target /* , targetKey */) {
  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
} });


/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(28);
var anObject = __webpack_require__(1);
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

metadata.exp({ getOwnMetadata: function getOwnMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryGetOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });


/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(28);
var anObject = __webpack_require__(1);
var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

metadata.exp({ getOwnMetadataKeys: function getOwnMetadataKeys(target /* , targetKey */) {
  return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
} });


/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(28);
var anObject = __webpack_require__(1);
var getPrototypeOf = __webpack_require__(17);
var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

var ordinaryHasMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return true;
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
};

metadata.exp({ hasMetadata: function hasMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });


/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(28);
var anObject = __webpack_require__(1);
var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

metadata.exp({ hasOwnMetadata: function hasOwnMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryHasOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });


/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

var $metadata = __webpack_require__(28);
var anObject = __webpack_require__(1);
var aFunction = __webpack_require__(10);
var toMetaKey = $metadata.key;
var ordinaryDefineOwnMetadata = $metadata.set;

$metadata.exp({ metadata: function metadata(metadataKey, metadataValue) {
  return function decorator(target, targetKey) {
    ordinaryDefineOwnMetadata(
      metadataKey, metadataValue,
      (targetKey !== undefined ? anObject : aFunction)(target),
      toMetaKey(targetKey)
    );
  };
} });


/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
var $export = __webpack_require__(0);
var microtask = __webpack_require__(90)();
var process = __webpack_require__(2).process;
var isNode = __webpack_require__(19)(process) == 'process';

$export($export.G, {
  asap: function asap(fn) {
    var domain = isNode && process.domain;
    microtask(domain ? domain.bind(fn) : fn);
  }
});


/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {



// https://github.com/zenparsing/es-observable
var $export = __webpack_require__(0);
var global = __webpack_require__(2);
var core = __webpack_require__(26);
var microtask = __webpack_require__(90)();
var OBSERVABLE = __webpack_require__(5)('observable');
var aFunction = __webpack_require__(10);
var anObject = __webpack_require__(1);
var anInstance = __webpack_require__(39);
var redefineAll = __webpack_require__(41);
var hide = __webpack_require__(11);
var forOf = __webpack_require__(40);
var RETURN = forOf.RETURN;

var getMethod = function (fn) {
  return fn == null ? undefined : aFunction(fn);
};

var cleanupSubscription = function (subscription) {
  var cleanup = subscription._c;
  if (cleanup) {
    subscription._c = undefined;
    cleanup();
  }
};

var subscriptionClosed = function (subscription) {
  return subscription._o === undefined;
};

var closeSubscription = function (subscription) {
  if (!subscriptionClosed(subscription)) {
    subscription._o = undefined;
    cleanupSubscription(subscription);
  }
};

var Subscription = function (observer, subscriber) {
  anObject(observer);
  this._c = undefined;
  this._o = observer;
  observer = new SubscriptionObserver(this);
  try {
    var cleanup = subscriber(observer);
    var subscription = cleanup;
    if (cleanup != null) {
      if (typeof cleanup.unsubscribe === 'function') cleanup = function () { subscription.unsubscribe(); };
      else aFunction(cleanup);
      this._c = cleanup;
    }
  } catch (e) {
    observer.error(e);
    return;
  } if (subscriptionClosed(this)) cleanupSubscription(this);
};

Subscription.prototype = redefineAll({}, {
  unsubscribe: function unsubscribe() { closeSubscription(this); }
});

var SubscriptionObserver = function (subscription) {
  this._s = subscription;
};

SubscriptionObserver.prototype = redefineAll({}, {
  next: function next(value) {
    var subscription = this._s;
    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      try {
        var m = getMethod(observer.next);
        if (m) return m.call(observer, value);
      } catch (e) {
        try {
          closeSubscription(subscription);
        } finally {
          throw e;
        }
      }
    }
  },
  error: function error(value) {
    var subscription = this._s;
    if (subscriptionClosed(subscription)) throw value;
    var observer = subscription._o;
    subscription._o = undefined;
    try {
      var m = getMethod(observer.error);
      if (!m) throw value;
      value = m.call(observer, value);
    } catch (e) {
      try {
        cleanupSubscription(subscription);
      } finally {
        throw e;
      }
    } cleanupSubscription(subscription);
    return value;
  },
  complete: function complete(value) {
    var subscription = this._s;
    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      subscription._o = undefined;
      try {
        var m = getMethod(observer.complete);
        value = m ? m.call(observer, value) : undefined;
      } catch (e) {
        try {
          cleanupSubscription(subscription);
        } finally {
          throw e;
        }
      } cleanupSubscription(subscription);
      return value;
    }
  }
});

var $Observable = function Observable(subscriber) {
  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
};

redefineAll($Observable.prototype, {
  subscribe: function subscribe(observer) {
    return new Subscription(observer, this._f);
  },
  forEach: function forEach(fn) {
    var that = this;
    return new (core.Promise || global.Promise)(function (resolve, reject) {
      aFunction(fn);
      var subscription = that.subscribe({
        next: function (value) {
          try {
            return fn(value);
          } catch (e) {
            reject(e);
            subscription.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
    });
  }
});

redefineAll($Observable, {
  from: function from(x) {
    var C = typeof this === 'function' ? this : $Observable;
    var method = getMethod(anObject(x)[OBSERVABLE]);
    if (method) {
      var observable = anObject(method.call(x));
      return observable.constructor === C ? observable : new C(function (observer) {
        return observable.subscribe(observer);
      });
    }
    return new C(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          try {
            if (forOf(x, false, function (it) {
              observer.next(it);
              if (done) return RETURN;
            }) === RETURN) return;
          } catch (e) {
            if (done) throw e;
            observer.error(e);
            return;
          } observer.complete();
        }
      });
      return function () { done = true; };
    });
  },
  of: function of() {
    for (var i = 0, l = arguments.length, items = new Array(l); i < l;) items[i] = arguments[i++];
    return new (typeof this === 'function' ? this : $Observable)(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          for (var j = 0; j < items.length; ++j) {
            observer.next(items[j]);
            if (done) return;
          } observer.complete();
        }
      });
      return function () { done = true; };
    });
  }
});

hide($Observable.prototype, OBSERVABLE, function () { return this; });

$export($export.G, { Observable: $Observable });

__webpack_require__(38)('Observable');


/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var $task = __webpack_require__(89);
$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});


/***/ }),
/* 324 */
/***/ (function(module, exports, __webpack_require__) {

var $iterators = __webpack_require__(86);
var getKeys = __webpack_require__(34);
var redefine = __webpack_require__(12);
var global = __webpack_require__(2);
var hide = __webpack_require__(11);
var Iterators = __webpack_require__(46);
var wks = __webpack_require__(5);
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}


/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

// ie9- setTimeout & setInterval additional parameters fix
var global = __webpack_require__(2);
var $export = __webpack_require__(0);
var userAgent = __webpack_require__(60);
var slice = [].slice;
var MSIE = /MSIE .\./.test(userAgent); // <- dirty ie9- check
var wrap = function (set) {
  return function (fn, time /* , ...args */) {
    var boundArgs = arguments.length > 2;
    var args = boundArgs ? slice.call(arguments, 2) : false;
    return set(boundArgs ? function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
    } : fn, time);
  };
};
$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout: wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});


/***/ })
/******/ ]);
// CommonJS export
if (typeof module != 'undefined' && module.exports) module.exports = __e;
// RequireJS export
else if (typeof define == 'function' && define.amd) define(function () { return __e; });
// Export to global object
else __g.core = __e;
}(1, 1);
});

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var regeneratorRuntime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
  (typeof module === "object" && module.exports) ? module.exports : {}
));

define("regenerator-runtime", function(){});

/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */



  define('polyfills', ['corejs', 'regenerator-runtime']);

  define('promise', ['polyfills'], function () {
    Promise.polyfill = function () {};
    return Promise;
  });

define('ojs/ojcore-base',['require', 'ojs/ojlogger', 'polyfills'], function(require, Logger)
{
  "use strict";



/* jslint browser: true*/

/**
 * Defines the oj namespace
 */

/**
 * @private
 */
var _scope = {}; //  - check if the window object is available
// Note that the 'typeof' check  is required

if (typeof window !== 'undefined') {
  _scope = window; // eslint-disable-next-line no-restricted-globals
} else if (typeof self !== 'undefined') {
  // eslint-disable-next-line no-restricted-globals
  _scope = self;
}
/**
 * @private
 */


var _oldVal = _scope.oj; // eslint-disable-next-line no-unused-vars

var oj = {
  /**
   * @global
   * @member {string} version JET version numberr
   */
  version: '9.1.0',

  /**
   * @global
   * @member {string} revision JET source code revision number
   */
  revision: '2020-08-05_19-00-35',
  // This function is only meant to be used outside the library, so quoting the name
  // to avoid renaming is appropriate
  noConflict: function noConflict() {
    _scope.oj = _oldVal;
  },

  /**
   * Adds a property to the "oj" namespace. This is used by ES6 modules to set
   * legacy exported objects onto the import "oj" namespace, since modifying the
   * original imported object isn't allowed under ES6.
   * @param {string} name The property name, such as "PopupService"
   * @param {object} value The value to set for the property
   * @private
   */
  _registerLegacyNamespaceProp: function _registerLegacyNamespaceProp(name, value) {
    this[name] = value;
  }
};
_scope.oj = oj;

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }



/* global _scope:false */

/* jslint browser: true*/

/**
 * Assertion utilities.
 * The container is expected to have already initialized the oj.Assert Object before this
 * code is executed and initialized the oj.Assert.DEBUG flag/
 * @class
 * @export
 * @ignore
 */
oj.Assert = {};
/**
 * @private
 */

var _DEBUG = 'DEBUG';
/**
 * Forces DEBUG to be set to true
 * @export
 * @memberof oj.Assert
 */

oj.Assert.forceDebug = function () {
  oj.Assert[_DEBUG] = true;
};
/**
 * Forces DEBUG to be set to false
 * @export
 * @memberof oj.Assert
 */


oj.Assert.clearDebug = function () {
  oj.Assert[_DEBUG] = false;
};
/**
 * Determines whether oj.Assert is running in debug mode
 * @return {boolean} true for debug mode, false otherwise
 * @export
 * @memberof oj.Assert
 */


oj.Assert.isDebug = function () {
  return oj.Assert[_DEBUG] === true;
};
/**
 * Asserts that a condition is true.  If the condition does not
 * evaluate to true, an exception is thrown with the optional message
 * and reason
 * @param {boolean} condition condition to test
 * @param {string=} message message to display
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assert = function (condition, message) {
  if (oj.Assert[_DEBUG] && !condition) {
    var myMessage = message || '';

    if (arguments.length > 2) {
      myMessage += '(';

      for (var i = 2; i < arguments.length; i += 1) {
        myMessage += arguments[i];
      }

      myMessage += ')';
    }

    oj.Assert.assertionFailed(myMessage, 1);
  }
};
/**
 * Convenience function for asserting when an abstact function is called
 * @export
 * @memberof oj.Assert
 */


oj.Assert.failedInAbstractFunction = function () {
  if (oj.Assert[_DEBUG]) {
    oj.Assert.assertionFailed('Abstract function called', 1);
  }
};
/**
 * Asserts that the the target object has the same prototype as the example
 * type
 * @param {Object} target description
 * @param {Function} theConstructor
 * @param {string=} reason
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertPrototype = function (target, theConstructor, reason) {
  if (oj.Assert[_DEBUG]) {
    var thePrototype = theConstructor.prototype;

    if (target != null) {
      oj.Assert.assertType(theConstructor, 'function', null, 1, false);
      var isPrototypeOf = Object.prototype.isPrototypeOf;

      if (!isPrototypeOf.call(thePrototype, target)) {
        oj.Assert.assertionFailed("object '" + target + "' doesn't match prototype " + thePrototype, 1, reason);
      }
    } else {
      oj.Assert.assertionFailed("null object doesn't match prototype " + thePrototype, 1, reason);
    }
  }
};
/**
 * Asserts that the the target object has the same prototype as the example
 * type or is null.
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertPrototypeOrNull = function (target, theConstructor, reason) {
  if (oj.Assert[_DEBUG] && target != null) {
    oj.Assert.assertType(theConstructor, 'function', null, 1, false);
    var thePrototype = theConstructor.prototype;
    var isPrototypeOf = Object.prototype.isPrototypeOf;

    if (!isPrototypeOf.call(thePrototype, target)) {
      oj.Assert.assertionFailed("object '" + target + "' doesn't match prototype " + thePrototype, 1, reason);
    }
  }
};
/**
 * Asserts that the the target object has the same prototype as the example
 * types
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertPrototypes = function (target, instanceOne, instanceTwo, reason) {
  if (oj.Assert[_DEBUG]) {
    var thePrototype = instanceOne.prototype;
    var thePrototypeTwo = instanceTwo.prototype;
    var isPrototypeOf = Object.prototype.isPrototypeOf;

    if (!(isPrototypeOf.call(thePrototype, target) || isPrototypeOf.call(thePrototypeTwo, target))) {
      oj.Assert.assertionFailed("object '" + target + "' doesn't match prototype " + thePrototype + ' or ' + thePrototypeTwo, 1, reason);
    }
  }
};
/**
 * Asserts that the target is a DOM Node or Null
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertDomNodeOrNull = function (target, depth) {
  if (oj.Assert[_DEBUG] && target) {
    if (target.nodeType === undefined) {
      oj.Assert.assertionFailed(target + ' is not a DOM Node', depth + 1);
    }
  }
};
/**
 * Asserts that the target is a DOM Node
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertDomNode = function (target, depth) {
  if (oj.Assert[_DEBUG]) {
    if (!target || target.nodeType === undefined) {
      oj.Assert.assertionFailed(target + ' is not a DOM Node', depth + 1);
    }
  }
};
/**
 * Asserts that the target is a DOM Element and optionally has the specified
 * element name
 * @param {Object} target target object
 * @param {string=} nodeName name of the element
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertDomElement = function (target, nodeName) {
  if (oj.Assert[_DEBUG]) {
    oj.Assert.assertDomNode(target, 1);

    if (target.nodeType !== 1) {
      oj.Assert.assertionFailed(target + ' is not a DOM Element', 1);
    } else if (nodeName && target.nodeName !== nodeName) {
      oj.Assert.assertionFailed(target + ' is not a ' + nodeName + ' Element', 1);
    }
  }
};
/**
 * Asserts that the target is a DOM Element and optionally has the specified
 * element name
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertDomElementOrNull = function (target, nodeName) {
  if (oj.Assert[_DEBUG] && target != null) {
    oj.Assert.assertDomNode(target, 1);

    if (target.nodeType !== 1) {
      oj.Assert.assertionFailed(target + ' is not a DOM Element', 1);
    } else if (nodeName && target.nodeName !== nodeName) {
      oj.Assert.assertionFailed(target + ' is not a ' + nodeName + ' Element', 1);
    }
  }
};
/**
 * Asserts that the target object has the typeof specified
 *
 * @param {Object|null|string|undefined} target
 * @param {string} type typeof type that statisfies this condition
 * @param {string|undefined|null} prefix
 * @param {number} depth stack depth to skip when printing stack traces
 * @param {boolean} nullOK true if a null value satisfies this condition
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertType = function (target, type, prefix, depth, nullOK) {
  if (oj.Assert[_DEBUG]) {
    // either the target is null and null is OK, or the target better
    // be of the correct type
    var targetType = _typeof(target);

    if (!(target == null && nullOK || targetType === type)) {
      var message = target + ' is not of type ' + type;

      if (prefix) {
        message = prefix + message;
      }

      if (!depth) {
        // eslint-disable-next-line no-param-reassign
        depth = 0;
      }

      oj.Assert.assertionFailed(message, depth + 1);
    }
  }
};
/**
 * Asserts that the target is an Object
 * @param {Object} target description
 * @param {string=} prefix
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertObject = function (target, prefix) {
  if (oj.Assert[_DEBUG]) {
    oj.Assert.assertType(target, 'object', prefix, 1, false);
  }
};
/**
 * Asserts that the target is an Object or null
 * @param {Object} target description
 * @param {string=} prefix
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertObjectOrNull = function (target, prefix) {
  if (oj.Assert[_DEBUG]) {
    oj.Assert.assertType(target, 'object', prefix, 1, true);
  }
};
/**
 * Asserts that the target is a non-empty String
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertNonEmptyString = function (target, prefix) {
  if (oj.Assert[_DEBUG]) {
    oj.Assert.assertType(target, 'string', prefix, 1, false);
    oj.Assert.assert(target.length > 0, 'empty string');
  }
};
/**
 * Asserts that the target is a String
 * @param target target object
 * @param {string=} prefix prefix string
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertString = function (target, prefix) {
  if (oj.Assert[_DEBUG]) {
    oj.Assert.assertType(target, 'string', prefix, 1, false);
  }
};
/**
 * Asserts that the target is a String or null
 * @param {string|null|undefined|Object} target target object
 * @param {string=} prefix prefix string
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertStringOrNull = function (target, prefix) {
  if (oj.Assert[_DEBUG]) {
    oj.Assert.assertType(target, 'string', prefix, 1, true);
  }
};
/**
 * Asserts that the target is a Function
 * @param {Object} target target object
 * @param {string=} prefix prefix string
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertFunction = function (target, prefix) {
  if (oj.Assert[_DEBUG]) {
    oj.Assert.assertType(target, 'function', prefix, 1, false);
  }
};
/**
 * Asserts that the target is a Function or null
 * @param {Object} target target object
 * @param {string=} prefix prefix
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertFunctionOrNull = function (target, prefix) {
  if (oj.Assert[_DEBUG]) {
    oj.Assert.assertType(target, 'function', prefix, 1, true);
  }
};
/**
 * Asserts that the target is a boolean
 * @param {Object} target description
 * @param {string=} prefix
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertBoolean = function (target, prefix) {
  if (oj.Assert[_DEBUG]) {
    oj.Assert.assertType(target, 'boolean', prefix, 1, false);
  }
};
/**
 * Asserts that the target is a number
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertNumber = function (target, prefix) {
  if (oj.Assert[_DEBUG]) {
    oj.Assert.assertType(target, 'number', prefix, 1, false);
  }
};
/**
 * Asserts that the target is a number or Null
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertNumberOrNull = function (target, prefix) {
  if (oj.Assert[_DEBUG]) {
    oj.Assert.assertType(target, 'number', prefix, 1, true);
  }
};
/**
 * Asserts that the target object is an Array
 * @param {Object} target target object
 * @param {string=} message optional message
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertArray = function (target, message) {
  if (oj.Assert[_DEBUG]) {
    if (!Array.isArray(target)) {
      if (message === undefined) {
        // eslint-disable-next-line no-param-reassign
        message = target + ' is not an array';
      }

      oj.Assert.assertionFailed(message, 1);
    }
  }
};
/**
 * Asserts that the target object is an Array or null
 * @param {Object} target target object
 * @param {string=} message optional message
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertArrayOrNull = function (target, message) {
  if (oj.Assert[_DEBUG] && target != null) {
    if (!Array.isArray(target)) {
      if (message === undefined) {
        // eslint-disable-next-line no-param-reassign
        message = target + ' is not an array';
      }

      oj.Assert.assertionFailed(message, 1);
    }
  }
};
/**
 * Asserts that the target object is not either a number, or convertible to a number
 * @param {Object} target target object
 * @param {string=} message optional message
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertNonNumeric = function (target, message) {
  if (oj.Assert[_DEBUG]) {
    if (!isNaN(target)) {
      if (message === undefined) {
        // eslint-disable-next-line no-param-reassign
        message = target + ' is convertible to a number';
      }

      oj.Assert.assertionFailed(message, 1);
    }
  }
};
/**
 * Asserts that the target object is either a number, or convertible to a number
 * @param {Object} target target object
 * @param {string=} message optional message
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertNumeric = function (target, message) {
  if (oj.Assert[_DEBUG]) {
    if (isNaN(target)) {
      if (message === undefined) {
        // eslint-disable-next-line no-param-reassign
        message = target + ' is not convertible to a number';
      }

      oj.Assert.assertionFailed(message, 1);
    }
  }
};
/**
 * Asserts that value String is in the Set
 * @param {Object} value value to check
 * @param {Object} set set to check
 * @param {string=} message optional message
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertInSet = function (value, set, message) {
  if (value == null || set[value.toString()] === undefined) {
    if (message === undefined) {
      var keyString = ' is not in set: {';
      var keys = Object.keys(set);

      for (var k = 0; k < keys.length; k++) {
        var key = keys[k];
        keyString += key;
        keyString += ',';
      }

      keyString += '}'; // eslint-disable-next-line no-param-reassign

      message = value + keyString;
    }

    oj.Assert.assertionFailed(message, 1);
  }
};
/**
 * Base assertion failure support that supports specifying the stack skipping
 * level
 * @param {string} message Message to display
 * @param {number} skipLevel assertion level
 * @param {string=} reason reason to display
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertionFailed = function (message, skipLevel, reason) {
  if (!skipLevel) {
    // eslint-disable-next-line no-param-reassign
    skipLevel = 0;
  }

  var errorMessage = 'Assertion';

  if (reason) {
    errorMessage += ' (' + reason + ')';
  }

  errorMessage += ' failed: ';

  if (message !== undefined) {
    errorMessage += message;
  }

  var error = new Error(errorMessage);
  throw error;
};
/**
 * @private
 * @memberof oj.Assert
 */


var _assertSetting = _scope.__oj_Assert_DEBUG;

if (_assertSetting !== undefined) {
  oj.Assert[_DEBUG] = _assertSetting;
}

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Utilities for working with collections
 * @export
 */
oj.CollectionUtils = {};
/**
 * Copies all of the properties of source into the target and returns the target
 *
 * @param {Object} target - target collection
 * @param {Object} source - source collection
 * @param {function(string)=} keyConverter a callback for converting the key
 * @param {boolean=} recurse - true if this method should recurse into plain Javascript object properties
 * @param {number=} maxRecursionDepth - the maximum depth of the recursion into plain Javascript object properties
 * @return target collection
 * @export
 * @memberof! oj.CollectionUtils
 */

oj.CollectionUtils.copyInto = function (target, source, keyConverter, recurse, maxRecursionDepth) {
  return oj.CollectionUtils._copyIntoImpl(target, source, keyConverter, recurse, maxRecursionDepth, 0);
};
/**
 * A simpler alternative to copyInto()
 * @param {Object} target - target collection
 * @param Array{Object} - one or more sources to merge into the target
 * @ignore
 */


oj.CollectionUtils.mergeDeep = function (target) {
  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    sources[_key - 1] = arguments[_key];
  }

  if (!sources.length) return target;
  var isPlain = oj.CollectionUtils.isPlainObject;
  var merge = oj.CollectionUtils.mergeDeep;
  var source = sources.shift();

  if (isPlain(target) && isPlain(source)) {
    Object.keys(source).forEach(function (key) {
      if (isPlain(source[key])) {
        if (!target[key]) Object.assign(target, _defineProperty({}, key, {}));
        merge(target[key], source[key]);
      } else {
        Object.assign(target, _defineProperty({}, key, source[key]));
      }
    });
  }

  return merge.apply(void 0, [target].concat(sources));
};
/**
 * Checks whether the object is a direct instance of Object
 * @param {Object} obj - object to test
 *
 * @return {boolean} true if the object is a direct instance of Object, false otherwise
 * @export
 * @memberof! oj.CollectionUtils
 */


oj.CollectionUtils.isPlainObject = function (obj) {
  if (obj !== null && _typeof(obj) === 'object') {
    try {
      var hasOwnProperty = Object.prototype.hasOwnProperty;

      if (obj.constructor && hasOwnProperty.call(obj.constructor.prototype, 'isPrototypeOf')) {
        return true;
      }
    } catch (e) {// Ignore errors
    }
  }

  return false;
};
/**
 * @private
 * @memberof! oj.CollectionUtils
 */


oj.CollectionUtils._copyIntoImpl = function (target, source, keyConverter, recurse, maxRecursionDepth, currentLevel) {
  var targetKey;

  if (maxRecursionDepth === undefined || maxRecursionDepth === null) {
    // eslint-disable-next-line no-param-reassign
    maxRecursionDepth = Number.MAX_VALUE;
  }

  if (target && source && target !== source) {
    var keys = Object.keys(source);

    for (var i = 0; i < keys.length; i++) {
      var k = keys[i]; // allow the key mapping to be overridden

      if (keyConverter) {
        targetKey = keyConverter(k);
      } else {
        targetKey = k;
      }

      var sourceVal = source[k];
      var recursed = false;

      if (recurse && currentLevel < maxRecursionDepth) {
        var targetVal = target[targetKey];

        if (oj.CollectionUtils.isPlainObject(sourceVal) && (targetVal == null || oj.CollectionUtils.isPlainObject(targetVal))) {
          recursed = true; // eslint-disable-next-line no-param-reassign

          target[targetKey] = targetVal || {};

          oj.CollectionUtils._copyIntoImpl(target[targetKey], sourceVal, keyConverter, true, maxRecursionDepth, currentLevel + 1);
        }
      }

      if (!recursed) {
        // eslint-disable-next-line no-param-reassign
        target[targetKey] = sourceVal;
      }
    }
  }

  return target;
};

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }



/* jslint browser: true*/

/* global define: false, Promise:false*/

/**
 * Base class of all OJET Objects.
 * <p>
 * To create a subclass of another oj.Object, use oj.Object.createSubclass.
 * The subclass can specify class-level initialization by implementing an
 * <code>InitClass()</code> method on its constructor.  <code>InitClass</code>
 * is guaranteed to be called only once per class.  Further, a class'
 * <code>InitClass</code> method is guranteed to be called only after its
 * superclass' class initialization has been called.  When <code>InitClass</code>
 * is called, <code>this</code> is the class' constructor.  This allows class
 * initialization implementations to be shared in some cases.
 * </p>
 */

/**
 * @constructor oj.Object
 * @final
 * @ojtsignore
 * @since 1.0
 * @export
 */
oj.Object = function () {
  this.Init();
};

oj.Object.superclass = null;
/**
 * @private
 */

oj.Object._typeName = 'oj.Object'; // regular expressicloneon for stripping out the name of a function

/**
 * @private
 */

oj.Object._GET_FUNCTION_NAME_REGEXP = /function\s+([\w$][\w$\d]*)\s*\(/; // oj.Object._TRIM_REGEXP = /(^\s*)|(\s*$)/g; this.replace(/(^\s*)|(\s*$)/g, "");

oj.Object.prototype = {};
oj.Object.prototype.constructor = oj.Object;
/**
 * Creates a subclass of a baseClass
 * @method createSubclass
 * @memberof oj.Object
 * @param {Object} extendingClass The class to extend from the base class
 * @param {Object} baseClass class to make the superclass of extendingClass
 * @param {string=} typeName to use for new class.  If not specified, the typeName will be extracted from the
 * baseClass's function if possible
 * @return {void}
 * @export
 */

oj.Object.createSubclass = function (extendingClass, baseClass, typeName) {
  // optional name to name this class
  oj.Assert.assertFunction(extendingClass);
  oj.Assert.assertFunctionOrNull(baseClass);
  oj.Assert.assertStringOrNull(typeName);

  if (baseClass === undefined) {
    // assume oj.Object
    // eslint-disable-next-line no-param-reassign
    baseClass = oj.Object;
  }

  oj.Assert.assert(extendingClass !== baseClass, "Class can't extend itself"); // use a temporary constructor to get our superclass as our prototype
  // without out having to initialize the superclass

  /**
   * @private
   * @constructor
   */

  var TempConstructor = oj.Object._tempSubclassConstructor;
  TempConstructor.prototype = baseClass.prototype; // eslint-disable-next-line no-param-reassign

  extendingClass.prototype = new TempConstructor(); // eslint-disable-next-line no-param-reassign

  extendingClass.prototype.constructor = extendingClass; // eslint-disable-next-line no-param-reassign

  extendingClass.superclass = baseClass.prototype;

  if (typeName) {
    // eslint-disable-next-line no-param-reassign
    extendingClass._typeName = typeName;
  }
};
/**
 * Copies properties from the source object to the prototype of the target class
 * Only properties 'owned' by the source object will be copied, i.e. the properties
 * from the source object's prototype chain will not be included.
 * To copy properties from another class with methods defined on the prototype, pass
 * otherClass.prototype as the source.
 * @method copyPropertiesForClass
 * @memberof oj.Object
 * @param {Object} targetClass - the function whose prototype will be used a
 * copy target
 * @param {Object} source - object whose properties will be copied
 * @return {void}
 * @export
 */


oj.Object.copyPropertiesForClass = function (targetClass, source) {
  oj.Assert.assertFunction(targetClass);
  oj.Assert.assert(source != null, 'source object cannot be null');
  var props = Object.keys(source);

  for (var i = 0; i < props.length; i++) {
    var prop = props[i]; // eslint-disable-next-line no-param-reassign

    targetClass.prototype[prop] = source[prop];
  }
};
/**
 * @private
 */


oj.Object._tempSubclassConstructor = function () {};
/**
 * Returns the class object for the instance
 * @method getClass
 * @memberof oj.Object
 * @instance
 * @param {Object=} otherInstance - if specified, the instance whose type
 * should be returned. Otherwise the type of this instance will be returned
 * @return {Object} the class object for the instance
 * @final
 * @export
 */


oj.Object.prototype.getClass = function (otherInstance) {
  if (otherInstance === undefined) {
    // eslint-disable-next-line no-param-reassign
    otherInstance = this;
  } else if (otherInstance === null) {
    return null;
  }

  return otherInstance.constructor;
};
/**
 * Returns a clone of this object.  The default implementation is a shallow
 * copy.  Subclassers can override this method to implement a deep copy.
 * @method clone
 * @memberof oj.Object
 * @instance
 * @return {Object} a clone of this object
 * @export
 */


oj.Object.prototype.clone = function () {
  var clone = new this.constructor();
  oj.CollectionUtils.copyInto(clone, this);
  return clone;
};
/**
 * @export
 * @method toString
 * @memberof oj.Object
 * @instance
 * @return {string}
 */


oj.Object.prototype.toString = function () {
  return this.toDebugString();
};
/**
 * @export
 * @method toDebugString
 * @memberof oj.Object
 * @instance
 * @return {string}
 */


oj.Object.prototype.toDebugString = function () {
  return this.getTypeName() + ' Object';
};
/**
 * Returns the type name for a class derived from oj.Object
 * @method getTypeName
 * @memberof oj.Object
 * @instance
 * @param {Object|null} clazz Class to get the name of
 * @return {string} name of the Class
 * @export
 */


oj.Object.getTypeName = function (clazz) {
  oj.Assert.assertFunction(clazz);
  var typeName = clazz._typeName;

  if (typeName == null) {
    var constructorText = clazz.toString();

    var matches = oj.Object._GET_FUNCTION_NAME_REGEXP.exec(constructorText);

    if (matches) {
      typeName = matches[1];
    } else {
      typeName = 'anonymous';
    } // cache the result on the function
    // eslint-disable-next-line no-param-reassign


    clazz._typeName = typeName;
  }

  return typeName;
};
/**
 * Returns the type name for this instance
 * @method getTypeName
 * @memberof oj.Object
 * @return {string} name of the Class
 * @final
 * @export
 */


oj.Object.prototype.getTypeName = function () {
  return oj.Object.getTypeName(this.constructor);
};
/**
 * Initializes the instance.  Subclasses of oj.Object must call
 * their superclass' Init
 * @export
 * @method Init
 * @return {void}
 * @memberof oj.Object
 * @instance
 */


oj.Object.prototype.Init = function () {
  if (oj.Assert.isDebug()) {
    oj.Assert.assert(this.getTypeName, 'Not an oj.Object');
  } // do any class initialization.  This code is duplicated from
  // oj.Object.ensureClassInitialization()


  var currClass = this.constructor;

  if (!currClass._initialized) {
    oj.Object._initClasses(currClass);
  }
};
/**
 * Ensures that a class is initialized.  Although class initialization occurs
 * by default the first time that an instance of a class is created, classes that
 * use static factory methods to create their instances may
 * still need to ensure that their class has been initialized when the factory
 * method is called.
 *
 * @method ensureClassInitialization
 * @memberof oj.Object
 * @param {Object} clazz The class to ensure initialization of
 * @return {void}
 * @export
 */


oj.Object.ensureClassInitialization = function (clazz) {
  oj.Assert.assertFunction(clazz);

  if (!clazz._initialized) {
    oj.Object._initClasses(clazz);
  }
};
/**
 * Indicates whether some other oj.Object is "equal to" this one.
 * Method is equivalent to java ".equals()" method.
 * @method equals
 * @memberof oj.Object
 * @instance
 * @param {Object} object - comparison target
 * @return {boolean} true if if the comparison target is equal to this object, false otherwise
 * @export
 */


oj.Object.prototype.equals = function (object) {
  return this === object;
};
/**
 * Binds the supplied callback function to an object
 * @method createCallback
 * @memberof oj.Object
 * @param {!Object} obj - object that will be available to the supplied callback
 * function as 'this'
 * @param {!Object} func - the original callback
 * @return {function()} a function that will be invoking the original callback with
 * 'this' object assigned to obj
 * @ojsignature {target: "Type", for: "returns", value: "()=>any"}
 * @export
 */


oj.Object.createCallback = function (obj, func) {
  oj.Assert.assertFunction(func); // All browsers supported by JET support bind() method

  return func.bind(obj);
};
/**
 * @private
 */


oj.Object._initClasses = function (currClass) {
  if (oj.Assert.isDebug()) {
    oj.Assert.assertFunction(currClass);
    oj.Assert.assert(!currClass._initialized);
  } // eslint-disable-next-line no-param-reassign


  currClass._initialized = true;
  var superclass = currClass.superclass; // initialize the superclass if necessary

  if (superclass) {
    var superclassConstructor = superclass.constructor;

    if (superclassConstructor && !superclassConstructor._initialized) {
      oj.Object._initClasses(superclassConstructor);
    }
  } // if the class has an initialization function, call it


  var InitClassFunc = currClass.InitClass;

  if (InitClassFunc) {
    InitClassFunc.call(currClass);
  }
};
/**
 * Compares 2 values using strict equality except for the case of
 * <ol>
 *   <li> Array [order matters]; will traverse through the arrays and compare oj.Object.compareValues(array[i], array2[i]) </li>
 *   <li> Instances that support valueOf [i.e. Boolean, String, Number, Date, and etc] will be compared by usage of that function </li>
 * </ol>
 * @param {any} obj1 The first value to compare.
 * @param {any} obj2 The second value to compare.
 * @return {boolean}
 * @public
 * @export
 * @method compareValues
 * @memberof oj.Object
 */


oj.Object.compareValues = function (obj1, obj2) {
  if (obj1 === obj2) {
    return true;
  }

  var obj1Type = _typeof(obj1);

  var obj2Type = _typeof(obj2);

  if (obj1Type !== obj2Type) {
    // of different type so consider them unequal
    return false;
  } // At this point means the types are equal
  // note that if the operand is an array or a null then typeof is an object
  // check if either is null and if so return false [i.e. case where one might be a null and another an object]
  // and one wishes to avoid the null pointer in the following checks. Note that null === null has been already tested


  if (obj1 === null || obj2 === null) {
    return false;
  } // now check for constructor since I think by here one has ruled out primitive values and if the constructors
  // aren't equal then return false


  if (obj1.constructor === obj2.constructor) {
    // these are special cases and will need to be modded on a need to have basis
    if (Array.isArray(obj1)) {
      return oj.Object._compareArrayValues(obj1, obj2);
    } else if (obj1.constructor === Object) {
      // for now invoke innerEquals and in the future if there are issues then resolve them
      return oj.Object.__innerEquals(obj1, obj2);
    } else if (obj1.valueOf && typeof obj1.valueOf === 'function') {
      // test cases for Boolean, String, Number, Date
      // Note if some future JavaScript constructors
      // do not impl it then it's their fault
      return obj1.valueOf() === obj2.valueOf();
    }
  }

  return false;
};

oj.Object._compareArrayValues = function (array1, array2) {
  if (array1.length !== array2.length) {
    return false;
  }

  for (var i = 0, j = array1.length; i < j; i++) {
    // recurse on each of the values, order does matter for our case since do not wish to search
    // for the value [expensive]
    if (!oj.Object.compareValues(array1[i], array2[i])) {
      return false;
    }
  }

  return true;
}; // Comparion of two Objects containing id and or index properties.
// Note: it returns false if one is an id and other is an index
// if ids are the same, index will be ignored if there is only one is provided


oj.Object._compareIdIndexObject = function (obj1, obj2) {
  if (typeof obj1 === 'number' && typeof obj2 === 'number' || typeof obj1 === 'string' && typeof obj2 === 'string') {
    return obj1 === obj2;
  }

  if (_typeof(obj1) === 'object' && _typeof(obj2) === 'object') {
    if (obj1.id && obj2.id) {
      if (obj1.id !== obj2.id) {
        return false;
      }

      if (obj1.index && obj2.index) {
        return obj1.index === obj2.index;
      }

      return true;
    } else if (obj1.index && obj2.index) {
      return obj1.index === obj2.index;
    }
  }

  return false;
}; // Comparion of two arrays containing ids, indexes, or objects where each object has id,
// index or both properties.
// order needn't be same but no duplicates


oj.Object._compareArrayIdIndexObject = function (array1, array2) {
  // null and [] are equals
  if (!array1) {
    return !array2 || array2.length === 0;
  }

  if (!array2) {
    return !array1 || array1.length === 0;
  }

  if (array1.length !== array2.length) {
    return false;
  }

  for (var i = 0; i < array1.length; i++) {
    var found = false;

    for (var j = 0; j < array2.length; j++) {
      if (oj.Object._compareIdIndexObject(array1[i], array2[j])) {
        found = true;
        break;
      }
    }

    if (!found) {
      return false;
    }
  }

  return true;
};

oj.Object.__innerEquals = function (obj1, obj2) {
  if (obj1 === obj2) {
    return true;
  }

  if (!(obj1 instanceof Object) || !(obj2 instanceof Object)) {
    return false;
  }

  if (obj1.constructor !== obj2.constructor) {
    return false;
  }

  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var props1 = Object.keys(obj1);
  var prop;
  var i;

  for (i = 0; i < props1.length; i++) {
    prop = props1[i];

    if (hasOwnProperty.call(obj1, prop)) {
      if (!hasOwnProperty.call(obj2, prop)) {
        return false;
      }

      if (obj1[prop] !== obj2[prop]) {
        if (_typeof(obj1[prop]) !== 'object') {
          return false;
        }

        if (!oj.Object.__innerEquals(obj1[prop], obj2[prop])) {
          return false;
        }
      }
    }
  }

  var props2 = Object.keys(obj2);

  for (i = 0; i < props2.length; i++) {
    prop = props2[i];

    if (hasOwnProperty.call(obj2, prop) && !hasOwnProperty.call(obj1, prop)) {
      return false;
    }
  }

  if (props1.length === 0 && props2.length === 0) {
    // we are dealing with objects that have no properties like Number or Date.
    return JSON.stringify(obj1) === JSON.stringify(obj2);
  }

  return true;
};
/**
 * @method isEmpty
 * @return {boolean}
 * @memberof oj.Object
 */


oj.Object.isEmpty = function (object) {
  var prop; // Test if an object is empty

  if (object === undefined || object === null) {
    return true;
  }

  for (prop in object) {
    // eslint-disable-line no-restricted-syntax
    if (object.hasOwnProperty(prop)) {
      // eslint-disable-line no-prototype-builtins
      return false;
    }
  }

  return true;
};
/**
 * @private
 * @return  {boolean} true if AMD Loader (such as Require.js) is present,
 *                    false otherwise
 */


oj.__isAmdLoaderPresent = function () {
  return typeof define === 'function' && define.amd;
};
/**
 * Loads a file using require if AMD loader is present, otherwise returns null
 * If loading multiple files then use multiple calls to this and Promise.all
 * @private
 * @param {string} module sting of the module to load
 * @param {function} requireFunc what to use as the require function, if not specified require will be used
 * @returns {Promise|null} returns null if no AMD loader
 */


oj.__getRequirePromise = function (module, requireFunc) {
  if (oj.__isAmdLoaderPresent()) {
    return new Promise(function (resolve, reject) {
      requireFunc([module], resolve, reject);
    });
  }

  return null;
};



/**
 * String utilities.
 * @class oj.StringUtils
 * @export
 * @ignore
 */
oj.StringUtils = {};
oj.StringUtils._TRIM_ALL_RE = /^\s*|\s*$/g;
/**
 * Returns true if the value is null or if the trimmed value is of zero length.
 *
 * @param {Object|string|null} value
 * @returns {boolean} true if the string or Object (e.g., Array) is of zero length.
 * @export
 * @memberof oj.StringUtils
 */

oj.StringUtils.isEmpty = function (value) {
  if (value === null) {
    return true;
  }

  var trimValue = oj.StringUtils.trim(value);
  return trimValue.length === 0;
};
/**
 * Returns true if the value is null, undefined or if the trimmed value is of zero length.
 *
 * @param {Object|string|null=} value
 * @returns {boolean} true if the string or Object (e.g., Array) is of zero length.
 * @export
 * @memberof oj.StringUtils
 */


oj.StringUtils.isEmptyOrUndefined = function (value) {
  if (value === undefined || oj.StringUtils.isEmpty(value)) {
    return true;
  }

  return false;
};
/**
 * Test if an object is a string (either a string constant or a string object)
 * @param {Object|string|null} obj object to test
 * @return {boolean} true if a string constant or string object
 * @export
 * @memberof oj.StringUtils
 */


oj.StringUtils.isString = function (obj) {
  return obj !== null && (typeof obj === 'string' || obj instanceof String);
};
/**
 * Remove leading and trailing whitespace
 * @param {Object|string|null} data to trim
 * @return {Object|string|null}
 * @export
 * @memberof oj.StringUtils
 */


oj.StringUtils.trim = function (data) {
  if (oj.StringUtils.isString(data)) {
    return data.replace(oj.StringUtils._TRIM_ALL_RE, '');
  }

  return data;
};
/**
 * Port of the Java String.hashCode method.
 * http://erlycoder.com/49/javascript-hash-functions-to-convert-string-into-integer-hash-
 *
 * @param {string} str
 * @returns {number}
 * @public
 * @memberof oj.StringUtils
 */


oj.StringUtils.hashCode = function (str) {
  var hash = 0;

  if (str.length === 0) {
    return hash;
  }

  for (var i = 0; i < str.length; i++) {
    var c = str.charCodeAt(i); // eslint-disable-next-line no-bitwise

    hash = (hash << 5) - hash + c; // eslint-disable-next-line no-bitwise

    hash &= hash;
  }

  return hash;
}; // Polyfills for IE11


(function () {
  // String.startsWith requires for IE11
  if (!String.prototype.startsWith) {
    // eslint-disable-next-line no-extend-native
    String.prototype.startsWith = function (searchString, position) {
      // eslint-disable-next-line no-param-reassign
      position = position || 0;
      return this.substr(position, searchString.length) === searchString;
    };
  } // String.endsWith requires for IE11


  if (!String.prototype.endsWith) {
    // eslint-disable-next-line no-extend-native
    String.prototype.endsWith = function (searchString, position) {
      var subjectString = this.toString();

      if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {
        // eslint-disable-next-line no-param-reassign
        position = subjectString.length;
      } // eslint-disable-next-line no-param-reassign


      position -= searchString.length;
      var lastIndex = subjectString.lastIndexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    };
  }
})();



/**
 * This list should be kept in sync with typings/jsx-interfaces.d.ts
 *
 * This list provides a map of global property to attribute names
 * where the attribute name is used for both key and value if no property
 * exists. We start with the list of global attributes found here:
 * https://html.spec.whatwg.org/multipage/dom.html#global-attributes
 * and check those against the Element and HTMLElement specs to determine
 * the property name if different:
 * https://dom.spec.whatwg.org/#interface-element
 * https://html.spec.whatwg.org/multipage/dom.html#htmlelement
 * This list is not exhaustive of all Element and HTMLElement properties.
 * @ignore
 */
// eslint-disable-next-line no-unused-vars
var _GLOBAL_PROPS = {
  accessKey: 'accesskey',
  autocapitalize: 'autocapitalize',
  autofocus: 'autofocus',
  class: 'class',
  // We support class instead of className for JSX
  contentEditable: 'contenteditable',
  dir: 'dir',
  draggable: 'draggable',
  enterKeyHint: 'enterkeyhint',
  hidden: 'hidden',
  id: 'id',
  inputMode: 'inputmode',
  is: 'is',
  itemid: 'itemid',
  itemprop: 'itemprop',
  itemref: 'itemref',
  itemscope: 'itemscope',
  itemtype: 'itemtype',
  lang: 'lang',
  nonce: 'nonce',
  role: 'role',
  slot: 'slot',
  spellcheck: 'spellcheck',
  style: 'style',
  tabIndex: 'tabindex',
  title: 'title',
  translate: 'translate'
};
/**
 * This map includes property to attribute names for
 * all native HTML elements where the two differ.
 * This list should only be manually populated for attributes belonging to
 * *subclasses* of HTMLElement.
 * @ignore
 */
// eslint-disable-next-line no-unused-vars

var _NATIVE_PROPS = {
  acceptCharset: 'accept-charset',
  allowFullscreen: 'allowfullscreen',
  allowPaymentRequest: 'allowpaymentrequest',
  colSpan: 'colspan',
  crossOrigin: 'crossorigin',
  dateTime: 'datetime',
  dirName: 'dirname',
  encoding: 'enctype',
  formAction: 'formaction',
  formEnctype: 'formenctype',
  formMethod: 'formmethod',
  formNoValidate: 'formnovalidate',
  formTarget: 'formtarget',
  for: 'for',
  // We support for instead of htmlFor for JSX
  httpEquiv: 'http-equiv',
  imageSizes: 'imagesizes',
  imageSrcset: 'imagesrcset',
  inputMode: 'inputmode',
  isMap: 'ismap',
  maxLength: 'maxlength',
  minLength: 'minlength',
  noModule: 'nomodule',
  noValidate: 'novalidate',
  readOnly: 'readonly',
  referrerPolicy: 'referrerpolicy',
  rowSpan: 'rowspan',
  useMap: 'usemap'
};



/* jslint browser: true*/

/**
 * @ojtsignore
 * @class oj.AgentUtils
 * @classdesc Utilities for qualifying the user agent string.
 * @public
 * @ignore
 */
oj.AgentUtils = function () {};
/**
 * Identity of the target browser.
 * @enum {string}
 * @public
 * @memberof oj.AgentUtils
 */


oj.AgentUtils.BROWSER = {
  IE: 'ie',
  FIREFOX: 'firefox',
  SAFARI: 'safari',
  CHROME: 'chrome',
  EDGE: 'edge',
  EDGE_CHROMIUM: 'edge-chromium',
  UNKNOWN: 'unknown'
};
/**
 * Browser layout engine identity.
 * @enum {string}
 * @public
 * @memberof oj.AgentUtils
 */

oj.AgentUtils.ENGINE = {
  TRIDENT: 'trident',
  WEBKIT: 'webkit',
  GECKO: 'gecko',
  BLINK: 'blink',
  EDGE_HTML: 'edgehtml',
  UNKNOWN: 'unknown'
};
/**
 * Operating system identity.
 * @enum {string}
 * @public
 * @memberof oj.AgentUtils
 */

oj.AgentUtils.OS = {
  WINDOWS: 'Windows',
  SOLARIS: 'Solaris',
  MAC: 'Mac',
  UNKNOWN: 'Unknown',
  ANDROID: 'Android',
  IOS: 'IOS',
  WINDOWSPHONE: 'WindowsPhone',
  LINUX: 'Linux'
};
/**
 * Device type identity.
 * @enum {string}
 * @public
 * @memberof oj.AgentUtils
 */

oj.AgentUtils.DEVICETYPE = {
  PHONE: 'phone',
  TABLET: 'tablet',
  OTHERS: 'others'
};
/**
 * Parses the browser user agent string determining what browser and layout engine
 * is being used.
 *
 * @param {Object|null|string=} userAgent a specific agent string but defaults to navigator userAgent if not provided
 * @return {{os: oj.AgentUtils.OS, browser: oj.AgentUtils.BROWSER, browserVersion: number, deviceType: oj.AgentUtils.DEVICETYPE,
 *          engine: oj.AgentUtils.ENGINE, engineVersion: number, hashCode: number}}
 * @public
 * @memberof oj.AgentUtils
 */

oj.AgentUtils.getAgentInfo = function (userAgent) {
  if (oj.StringUtils.isEmptyOrUndefined(userAgent)) {
    // eslint-disable-next-line no-param-reassign
    userAgent = navigator.userAgent;
  } // eslint-disable-next-line no-param-reassign


  userAgent = userAgent.toLowerCase();
  /** @type {number} */

  var hashCode = oj.StringUtils.hashCode(userAgent);
  var currAgentInfo = oj.AgentUtils._currAgentInfo;

  if (currAgentInfo && currAgentInfo.hashCode === hashCode) {
    return {
      os: currAgentInfo.os,
      browser: currAgentInfo.browser,
      browserVersion: currAgentInfo.browserVersion,
      deviceType: currAgentInfo.deviceType,
      engine: currAgentInfo.engine,
      engineVersion: currAgentInfo.engineVersion,
      hashCode: currAgentInfo.hashCode
    };
  }
  /** @type {oj.AgentUtils.OS} */


  var os = oj.AgentUtils.OS.UNKNOWN;
  /** @type {oj.AgentUtils.BROWSER} */

  var browser = oj.AgentUtils.BROWSER.UNKNOWN;
  /** @type {number} */

  var browserVersion = 0;
  /** @type {oj.AgentUtils.DEVICETYPE} */

  var deviceType = oj.AgentUtils.DEVICETYPE.OTHERS;
  /** @type {oj.AgentUtils.ENGINE} */

  var engine = oj.AgentUtils.ENGINE.UNKNOWN;
  /** @type {number} */

  var engineVersion = 0;

  if (userAgent.indexOf('iphone') > -1 || userAgent.indexOf('ipad') > -1) {
    os = oj.AgentUtils.OS.IOS;
  } else if (userAgent.indexOf('mac') > -1) {
    os = oj.AgentUtils.OS.MAC;
  } else if (userAgent.indexOf('sunos') > -1) {
    os = oj.AgentUtils.OS.SOLARIS;
  } else if (userAgent.indexOf('android') > -1) {
    os = oj.AgentUtils.OS.ANDROID;
  } else if (userAgent.indexOf('linux') > -1) {
    os = oj.AgentUtils.OS.LINUX;
  } else if (userAgent.indexOf('windows phone') > -1) {
    os = oj.AgentUtils.OS.WINDOWSPHONE;
  } else if (userAgent.indexOf('win') > -1) {
    os = oj.AgentUtils.OS.WINDOWS;
  }

  if (os === oj.AgentUtils.OS.ANDROID) {
    // This works for Chrome, Firefox, and Edge on Android, even though only Chrome is officially supported.
    // This also works for Edge on Windows 10 Mobile, which announces itself as android-compatible user agent.
    deviceType = userAgent.indexOf('mobile') > -1 ? oj.AgentUtils.DEVICETYPE.PHONE : oj.AgentUtils.DEVICETYPE.TABLET;
  } else if (os === oj.AgentUtils.OS.IOS) {
    // This works for Safari, Chrome, Firefox, and Edge on iOS, even though only Safari is officially supported.
    deviceType = userAgent.indexOf('iphone') > -1 ? oj.AgentUtils.DEVICETYPE.PHONE : oj.AgentUtils.DEVICETYPE.TABLET;
  }

  if (userAgent.indexOf('msie') > -1) {
    browser = oj.AgentUtils.BROWSER.IE;
    browserVersion = oj.AgentUtils._parseFloatVersion(userAgent, /msie (\d+[.]\d+)/);

    if (userAgent.indexOf('trident')) {
      engine = oj.AgentUtils.ENGINE.TRIDENT;
      engineVersion = oj.AgentUtils._parseFloatVersion(userAgent, /trident\/(\d+[.]\d+)/);
    }
  } else if (userAgent.indexOf('trident') > -1) {
    browser = oj.AgentUtils.BROWSER.IE;
    browserVersion = oj.AgentUtils._parseFloatVersion(userAgent, /rv:(\d+[.]\d+)/);

    if (userAgent.indexOf('trident')) {
      engine = oj.AgentUtils.ENGINE.TRIDENT;
      engineVersion = oj.AgentUtils._parseFloatVersion(userAgent, /trident\/(\d+[.]\d+)/);
    }
  } else if (userAgent.indexOf('edge') > -1) {
    browser = oj.AgentUtils.BROWSER.EDGE;
    engineVersion = oj.AgentUtils._parseFloatVersion(userAgent, /edge\/(\d+[.]\d+)/);
    browserVersion = engineVersion;
    engine = oj.AgentUtils.ENGINE.EDGE_HTML;
  } else if (userAgent.indexOf('edg') > -1) {
    browser = oj.AgentUtils.BROWSER.EDGE_CHROMIUM;
    browserVersion = oj.AgentUtils._parseFloatVersion(userAgent, /edg\/(\d+[.]\d+)/);
    engine = oj.AgentUtils.ENGINE.BLINK;
    engineVersion = browserVersion;
  } else if (userAgent.indexOf('chrome') > -1) {
    browser = oj.AgentUtils.BROWSER.CHROME;
    browserVersion = oj.AgentUtils._parseFloatVersion(userAgent, /chrome\/(\d+[.]\d+)/);

    if (browserVersion >= 28) {
      engine = oj.AgentUtils.ENGINE.BLINK;
      engineVersion = browserVersion;
    } else {
      engine = oj.AgentUtils.ENGINE.WEBKIT;
      engineVersion = oj.AgentUtils._parseFloatVersion(userAgent, /applewebkit\/(\d+[.]\d+)/);
    }
  } else if (userAgent.indexOf('safari') > -1) {
    browser = oj.AgentUtils.BROWSER.SAFARI;
    browserVersion = oj.AgentUtils._parseFloatVersion(userAgent, /version\/(\d+[.]\d+)/);
    engine = oj.AgentUtils.ENGINE.WEBKIT;
    engineVersion = oj.AgentUtils._parseFloatVersion(userAgent, /applewebkit\/(\d+[.]\d+)/);
  } else if (userAgent.indexOf('firefox') > -1) {
    browser = oj.AgentUtils.BROWSER.FIREFOX;
    browserVersion = oj.AgentUtils._parseFloatVersion(userAgent, /rv:(\d+[.]\d+)/);
    engine = oj.AgentUtils.ENGINE.GECKO;
    engineVersion = oj.AgentUtils._parseFloatVersion(userAgent, /gecko\/(\d+)/);
  }

  currAgentInfo = {
    hashCode: hashCode,
    os: os,
    browser: browser,
    browserVersion: browserVersion,
    deviceType: deviceType,
    engine: engine,
    engineVersion: engineVersion
  };
  oj.AgentUtils._currAgentInfo = currAgentInfo;
  return {
    os: currAgentInfo.os,
    browser: currAgentInfo.browser,
    browserVersion: currAgentInfo.browserVersion,
    deviceType: currAgentInfo.deviceType,
    engine: currAgentInfo.engine,
    engineVersion: currAgentInfo.engineVersion,
    hashCode: currAgentInfo.hashCode
  };
};
/**
 * @param {string!} userAgent
 * @param {RegExp!} versionNumberPattern
 * @return {number}
 * @private
 * @memberof oj.AgentUtils
 */


oj.AgentUtils._parseFloatVersion = function (userAgent, versionNumberPattern) {
  var matches = userAgent.match(versionNumberPattern);

  if (matches) {
    var versionString = matches[1];

    if (versionString) {
      return parseFloat(versionString);
    }
  }

  return 0;
};



/* global _GLOBAL_PROPS:false,_NATIVE_PROPS:false */
(function () {
  // Checks that a string either starts with 'array' or contains '|array'
  var _ARRAY_TYPE_EXP = /(^array)|(\|array)/; // Checks that a string either starts with 'object' or contains '|object'

  var _OBJ_TYPE_EXP = /(^object)|(\|object)/;
  var _ARRAY_VALUE_EXP = /^\s*\[[^]*\]\s*$/;
  var _OBJ_VALUE_EXP = /^\s*\{[^]*\}\s*$/; // Check for {{..}} and [[..]] at the beginning of strings to avoid matching
  // any usages mid string

  var _ATTR_EXP = /^(?:\{\{)([^]+)(?:\}\})$/;
  var _ATTR_EXP_RO = /^(?:\[\[)([^]+)(?:\]\])$/;
  /**
   * This map includes attribute to property names for
   * all global attributes where the two differ.
   * @ignore
   */

  var _GLOBAL_ATTRS = {};
  Object.keys(_GLOBAL_PROPS).forEach(function (prop) {
    var attr = _GLOBAL_PROPS[prop];

    if (prop !== attr) {
      _GLOBAL_ATTRS[attr] = prop;
      _NATIVE_PROPS[prop] = attr;
    }
  });
  /**
   * @ignore
   * @private
   */

  oj.__AttributeUtils = {};
  /**
   * @ignore
   * @return {{expr: (null|string), downstreamOnly: boolean}}
   * @private
   */

  oj.__AttributeUtils.getExpressionInfo = function (attrValue) {
    var info = {};

    if (attrValue) {
      var trimmedVal = attrValue.trim();

      var exp = _ATTR_EXP.exec(trimmedVal);

      exp = exp ? exp[1] : null;

      if (!exp) {
        info.downstreamOnly = true;
        exp = _ATTR_EXP_RO.exec(trimmedVal);
        exp = exp ? exp[1] : null;
      }

      info.expr = exp;
    }

    return info;
  };
  /**
   * @ignore
   * @param {string} attr attribute name
   * @return {string} property name
   * @private
   */


  oj.__AttributeUtils.attributeToPropertyName = function (attr) {
    return attr.toLowerCase().replace(/-(.)/g, function (match, group1) {
      return group1.toUpperCase();
    });
  };
  /**
   * @ignore
   * @param {string} name property name
   * @return {string} attribute name
   * @private
   */


  oj.__AttributeUtils.propertyNameToAttribute = function (name) {
    return name.replace(/([A-Z])/g, function (match) {
      return "-".concat(match.toLowerCase());
    });
  };
  /**
   * @ignore
   * @param {string} type event type (e.g. ojBeforeExpand)
   * @return {string} event listener property name (e.g. onOjBeforeExpand)
   * @private
   */


  oj.__AttributeUtils.eventTypeToEventListenerProperty = function (type) {
    return 'on' + type.substr(0, 1).toUpperCase() + type.substr(1);
  };
  /**
   * @ignore
   * @param {string} property event listener property name (e.g. onOjBeforeExpand)
   * @return {string|null} event type (e.g. ojBeforeExpand)
   * @private
   */


  oj.__AttributeUtils.eventListenerPropertyToEventType = function (property) {
    if (/^on[A-Z]/.test(property)) {
      return property.substr(2, 1).toLowerCase() + property.substr(3);
    }

    return null;
  };
  /**
   * @ignore
   * @param {string} name property name (e.g. expanded)
   * @return {string} change event type (e.g. expandedChanged)
   * @private
   */


  oj.__AttributeUtils.propertyNameToChangeEventType = function (name) {
    return name + 'Changed';
  };
  /**
   * @ignore
   * @param {string} trigger event trigger (e.g. beforeExpand)
   * @return {string} event type (e.g. ojBeforeExpand)
   * @private
   */


  oj.__AttributeUtils.eventTriggerToEventType = function (trigger) {
    return 'oj' + trigger.substr(0, 1).toUpperCase() + trigger.substr(1);
  };
  /**
   * Parses attribute values to the specified metadata type. Throws
   * an error if the value cannot be parsed to the metadata type
   * or if no type was provided.
   * @ignore
   * @param {Element} elem The element whose value we are parsing
   * @param {string} attr attribute
   * @param {string} value attribute value
   * @param {string} type property type
   * @return {any} coerced value
   * @private
   */


  oj.__AttributeUtils.coerceValue = function (elem, attr, value, type) {
    var tagName = elem.tagName.toLowerCase();

    if (!type) {
      throw new Error("Unable to parse ".concat(attr, "='").concat(value, "' for ").concat(tagName, " with id '").concat(elem.id, "'.         This attribute only supports data bound values. Check the API doc for supported types"));
    } // We only support primitive types and JSON objects for coerced properties.
    // Generally, we support parsing of a single type except for Object|string or Array|string cases
    // defined in metadata.


    var typeLwr = type.toLowerCase(); // The below checks ignore the couble {{}} [[]] cases since expression checking occurs
    // before attribute value coercion
    // Tests to see if the value starts and ends with matched [...] ignoring whitespace

    var isValueArray = _ARRAY_VALUE_EXP.test(value); // Tests to see if the value starts and ends with matched {...} ignoring whitespace


    var isValueObj = _OBJ_VALUE_EXP.test(value);

    if (_ARRAY_TYPE_EXP.test(typeLwr) && isValueArray || _OBJ_TYPE_EXP.test(typeLwr) && isValueObj || typeLwr === 'any' && (isValueArray || isValueObj)) {
      try {
        return JSON.parse(value);
      } catch (ex) {
        throw new Error("Unable to parse ".concat(attr, "='").concat(value, "' for ").concat(tagName, " with id '").concat(elem.id, "'           to a JSON Object. Check the value for correct JSON syntax, e.g. double quoted strings. ").concat(ex));
      }
    } else if (typeLwr === 'boolean') {
      return oj.__AttributeUtils.coerceBooleanValue(elem, attr, value, type);
    } else if (typeLwr === 'number') {
      if (!isNaN(value)) {
        return Number(value);
      }
    } else if (typeLwr === 'any') {
      // The any type will return a string if not matched as an object or array in first check
      return value;
    } else {
      var typeAr = typeLwr.split('|').filter(function (item) {
        return item.trim() === 'string';
      });

      if (typeAr.length > 0) {
        return value;
      }
    }

    throw new Error("Unable to parse ".concat(attr, "='").concat(value, "' for ").concat(tagName, " with id '").concat(elem.id, "'       to a ").concat(type, "."));
  };
  /**
   * Parses boolean attribute values. Throws
   * an error if the value cannot be parsed.
   * @ignore
   * @param {Element} elem The element whose value we are parsing
   * @param {string} attr attribute
   * @param {string} value attribute value
   * @param {string} type property type
   * @return {boolean} coerced value
   * @private
   */


  oj.__AttributeUtils.coerceBooleanValue = function (elem, attr, value, type) {
    // Boolean attributes are considered true if the attribute is:
    // 1) Set to the empty string
    // 2) Present in the DOM without a value assignment
    // 3) Set to the 'true' string
    // 4) Set to the case-insensitive attribute name
    // Boolean values are considered false if set to the false string.
    // An error is thrown for all other values and the attribute value will not be set.
    if (value == null || value === 'true' || value === '' || value.toLowerCase() === attr) {
      return true;
    } else if (value === 'false') {
      return false;
    }

    throw new Error('Unable to parse ' + attr + "='" + value + "' for " + elem + ' with id ' + elem.id + ' to a ' + type + '.');
  };
  /**
  * Returns true if the given property name maps to a global attribute.
  * For global attributes with no property getter, this method will check
  * the attribute name and handle data- and aria- dash cases.
  * @param {string} prop The property name to check
  * @return {boolean}
  * @private
  * @ignore
  */


  oj.__AttributeUtils.isGlobalOrData = function (prop) {
    // TODO: watch out for performance of hasOwnProperty given how often we expect isGlobal to be called
    return Object.prototype.hasOwnProperty.call(_GLOBAL_PROPS, prop) || prop.startsWith('data-') || prop.startsWith('aria-');
  };
  /**
   * This method assumes that the given property name has already been confirmed to
   * be global and will return the attribute syntax or the original value which could be
   * the global attribute name that does not have a property equivalent, e.g.
   * data- or aria-.
   * @ignore
   * @param {string} prop The property name to check
   * @return {string}
   * @private
   */


  oj.__AttributeUtils.getGlobalAttrForProp = function (prop) {
    return _GLOBAL_PROPS[prop] || prop;
  };
  /**
   * This method assumes that the given attribute name has already been confirmed
   * to be global and will return the attribute syntax or the original value which could be
   * the global attribute name that does not have a property equivalent, e.g.
   * data- or aria-.
   * @ignore
   * @param {string} attr The attribute name to check
   * @return {string}
   * @private
   */


  oj.__AttributeUtils.getGlobalPropForAttr = function (attr) {
    return _GLOBAL_ATTRS[attr] || attr;
  };
  /**
   * This method assumes that the given attribute name has already been confirmed
   * to be come from a native HTML element and will return the attribute name if
   * different from the property name for any native HTML element or the original value.
   * @ignore
   * @param {string} prop The property name to check
   * @return {string}
   * @private
   */


  oj.__AttributeUtils.getNativeAttr = function (prop) {
    return _NATIVE_PROPS[prop] || prop;
  };

  var _UNIQUE_INCR = 0;
  var _UNIQUE = '_ojcustomelem';
  /**
   * Returns either the passed id or a unique string that can be used for
   * a custom element id.
   * @ignore
   * @param {string} id
   * @return {string}
   * @private
   */

  oj.__AttributeUtils.getUniqueId = function (id) {
    if (id) {
      return id;
    }

    var ret = _UNIQUE + _UNIQUE_INCR;
    _UNIQUE_INCR += 1;
    return ret;
  };
})();



/* global Promise:false Map:false */

/**
 * NOTE: When adding a new polyfill, please include a description of what the
 * polyfill is for, the source and any copyright info, along with the browsers
 * it is needed for.
 */
(function () {
  if (typeof window === 'undefined') {
    return;
  } // polyfill for Element.closest()


  if (window.Element && !Element.prototype.closest) {
    Element.prototype.closest = function (s) {
      var matches = (this.document || this.ownerDocument).querySelectorAll(s);
      var i;
      var el = this;

      do {
        // eslint-disable-line no-cond-assign
        i = matches.length;

        while (--i >= 0 && matches.item(i) !== el) {} // eslint-disable-line no-plusplus, no-empty

      } while (i < 0 && (el = el.parentElement)); // eslint-disable-line no-cond-assign


      return el;
    };
  }
})();

(function () {
  // Polyfill for addEventListener & removeEventListener in browsers
  // that do not support an options object. The polyfilled methods accept
  // an options object, extract the capture option and pass it on as useCapture

  /**
  * Detect if options object is supported by checking if
  * browser looks for passive option. Code taken from
  * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
  * under "Safely detecting option support"
  * @ignore
  * @return {boolean} true if option object is supported,
  * false otherwise
  */
  function browserSupportsOptionObject() {
    var supportsOptionsObject = false;

    try {
      var opts = Object.defineProperty({}, 'passive', {
        get: function get() {
          supportsOptionsObject = true;
        }
      });
      window.addEventListener('testPassive', null, opts);
      window.removeEventListener('testPassive', null, opts); // eslint-disable-next-line no-empty
    } catch (e) {}

    return supportsOptionsObject;
  }
  /**
   * If option is object, extract capture and pass on
   * as useCapture. Otherwise simply pass on useCapture
   * @ignore
   * @param {Object|boolean} option option object or useCapture
   * @return {boolean} value for useCapture
  */


  function getCaptureOption(option) {
    if (typeof option === 'boolean') {
      return option;
    }

    return option ? option.capture : false;
  }
  /**
   * Helper for creating polyfilled addEventListener
   * or removeEventListener
   * @ignore
   * @param {Function} native addEventlister or
   * removeEventListener
   * @return {Function} polyfilled addEventListenr or
   * removeEventListener that accepts either options
   * object or useCapture.
  */


  function polyfill(native) {
    /**
     * @ignore
     * @param {string} event
     * @param {Function} handler
     * @param {Object|boolean} option options object or useCapture
    */
    return function (event, handler, option) {
      return native.call(this, event, handler, getCaptureOption(option));
    };
  }

  if (typeof window !== 'undefined' && !browserSupportsOptionObject()) {
    var nativePrototype;

    if (window.EventTarget) {
      // modern browsers define addEventListener and
      // removeEventListener on EventTarget
      nativePrototype = EventTarget.prototype;
    } else if (window.Node) {
      // IE defines addEventListener and removeEventListener
      // on Node
      nativePrototype = Node.prototype;
    }

    if (nativePrototype) {
      nativePrototype.addEventListener = polyfill(nativePrototype.addEventListener);
      nativePrototype.removeEventListener = polyfill(nativePrototype.removeEventListener);
    }
  }
})();

(function () {
  /**
   * @license
   * Code taken from
   * https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/queueMicrotask
   * under "When queueMicrotask() isn't available".
   * @ignore
   */
  if (typeof window !== 'undefined' && typeof window.queueMicrotask !== 'function') {
    // check for window being undefined for WebWorker cases
    window.queueMicrotask = function (callback) {
      Promise.resolve().then(callback).catch(function (e) {
        setTimeout(function () {
          throw e;
        });
      });
    };
  }
})();
/* The custom element (webcomponents) support requires the native CustomEvent
 * object.  This polyfill provides CustomEvent implementation for browsers that
 * don't support it yet.
 */


(function () {
  if (typeof window === 'undefined') {
    return;
  } // defaultPrevented is broken in IE.
  // https://connect.microsoft.com/IE/feedback/details/790389/event-defaultprevented-returns-false-after-preventdefault-was-called


  var workingDefaultPrevented = function () {
    var e = document.createEvent('Event');
    e.initEvent('foo', true, true);
    e.preventDefault();
    return e.defaultPrevented;
  }();

  if (!workingDefaultPrevented) {
    var origPreventDefault = Event.prototype.preventDefault;

    Event.prototype.preventDefault = function () {
      if (!this.cancelable) {
        return;
      }

      origPreventDefault.call(this);
      Object.defineProperty(this, 'defaultPrevented', {
        get: function get() {
          return true;
        },
        configurable: true
      });
    };
  }

  if (typeof window.CustomEvent === 'function') {
    return;
  }

  function CustomEvent(event, params) {
    // eslint-disable-next-line no-param-reassign
    params = params || {
      bubbles: false,
      cancelable: false,
      detail: undefined
    };
    var evt = document.createEvent('CustomEvent');
    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
    return evt;
  }

  CustomEvent.prototype = Object.getPrototypeOf(new CustomEvent('bogusEvent'));
  window.CustomEvent = CustomEvent;
})();
/**
 * Polyfill FocusEvent constructor for IE.
 */


(function () {
  if (typeof window === 'undefined' || typeof window.FocusEvent === 'function') {
    return;
  } // Note that since we can only use initEvent, we don't have a way to
  // polyfill the optional param to specify a relatedTarget for the FocusEvent.


  function FocusEvent(type) {
    var evt = document.createEvent('FocusEvent');
    evt.initEvent(type, false, false);
    return evt;
  }

  FocusEvent.prototype = Object.getPrototypeOf(new FocusEvent('focus'));
  window.FocusEvent = FocusEvent;
})();
/* This polyfill implements a proposed Microsoft standard [1] for effective yielding.
 * With the setImmediate global function, developers can yield control flow to the
 * user agent before running script.  The yield is similar to the setTimeout function
 * in that it is evaluated in the macrotask queue.  However, the setTimeout often has
 * a minimum delay and is also subject to long delays when the browser is placed in the
 * background.  The setImmediate function implemented by this polyfill invokes the
 * callback in the "next-tick" after the current macrotask queue has been exhausted.
 *
 * [1] https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html
 *
 * The strategy for the polyfill implementation uses the window.postMessage API for
 * creating a context for calling the target function evaulated as a macrotask. This
 * plugin will not work in a webworker where the window object doesn't exist.
 */


(function () {
  if (typeof window === 'undefined' || window.setImmediate || !window.postMessage) {
    return;
  }

  var _setImmediateMap;

  var _setImmediateCounter;

  function _nextId() {
    if (isNaN(_setImmediateCounter)) {
      _setImmediateCounter = 0;
    }

    _setImmediateCounter += 1;
    return _setImmediateCounter;
  } // postMessage "message" event listener for the setImmediate impl


  function _nextTickHandler(event) {
    var data = event.data;

    if (!data || data.message !== 'oj-setImmediate') {
      return;
    }

    var id = data.id;

    var entry = _setImmediateMap.get(id);

    clearImmediateImpl(id);

    if (entry) {
      var callback = entry.callback;
      var args = entry.args;
      callback.apply(window, args);
    }
  }

  function setImmediateImpl() {
    var callback = arguments[0];
    var slice = Array.prototype.slice;
    var args = slice.call(arguments, 1);
    oj.Assert.assertFunction(callback);

    var id = _nextId();

    if (!_setImmediateMap) {
      _setImmediateMap = new Map();
    }

    _setImmediateMap.set(id, {
      callback: callback,
      args: args
    });

    if (_setImmediateMap.size === 1) {
      window.addEventListener('message', _nextTickHandler);
    }

    window.postMessage({
      id: id,
      message: 'oj-setImmediate'
    }, '*');
    return id;
  }

  function clearImmediateImpl(id) {
    if (!_setImmediateMap) {
      return;
    }

    _setImmediateMap.delete(id);

    if (_setImmediateMap.size < 1) {
      window.removeEventListener('message', _nextTickHandler);
      _setImmediateMap = null;
    }
  }

  window.setImmediate = setImmediateImpl;
  window.clearImmediate = clearImmediateImpl;
})();

(function () {
  if (typeof window === 'undefined') {
    return;
  }

  if (window.Symbol) {
    if (!window.Symbol.asyncIterator) {
      window.Symbol.asyncIterator = 'asyncIterator';
    }

    if (!window.Symbol.iterator) {
      window.Symbol.iterator = 'iterator';
    }
  } else {
    window.Symbol = {};
    window.Symbol.asyncIterator = 'asyncIterator';
    window.Symbol.iterator = 'iterator';
  }
})();

(function () {
  if (typeof window === 'undefined') {
    return;
  }

  if (new window.Set([0]).size === 0) {
    var NativeSet = window.Set; // eslint-disable-next-line no-inner-declarations

    function _Set(iterable) {
      var set = new NativeSet();

      if (iterable) {
        iterable.forEach(set.add, set);
      }

      return set;
    }

    _Set.prototype = NativeSet.prototype; // eslint-disable-next-line no-extend-native

    _Set.prototype.constructor = _Set;
    window.Set = _Set;
  }
})();

(function () {
  if (typeof window === 'undefined') {
    return;
  } // IE11 supports Array.forEach


  if (window.NodeList && !NodeList.prototype.forEach) {
    NodeList.prototype.forEach = Array.prototype.forEach;
  }

  if (window.DOMTokenList && !DOMTokenList.prototype.forEach) {
    DOMTokenList.prototype.forEach = Array.prototype.forEach;
  }
})();
/**
 * Node.isConnected polyfill for IE and EdgeHTML
 * 2020-02-04
 * By Eli Grey, https://eligrey.com
 * Public domain.
 * From: https://developer.mozilla.org/en-US/docs/Web/API/Node/isConnected
 */


(function () {
  if (typeof window === 'undefined' || window.Node === 'undefined') {
    return;
  }

  if (!('isConnected' in Node.prototype)) {
    Object.defineProperty(Node.prototype, 'isConnected', {
      get: function get() {
        return !this.ownerDocument || // eslint-disable-next-line no-bitwise
        !(this.ownerDocument.compareDocumentPosition(this) & this.DOCUMENT_POSITION_DISCONNECTED);
      }
    });
  }
})();



/* global Set:false */

/**
 * Element utilities.
 * @class oj.ElementUtils
 * @ignore
 */
oj.ElementUtils = {
  /**
   * Custom element name check
   * @param {String} localName Element name
   * @return {boolean}
   * @ignore
   */
  isValidCustomElementName: function isValidCustomElementName(localName) {
    var reservedTagList = new Set(['annotation-xml', 'color-profile', 'font-face', 'font-face-src', 'font-face-uri', 'font-face-format', 'font-face-name', 'missing-glyph']);
    var reserved = reservedTagList.has(localName);
    var validForm = /^[a-z][.0-9_a-z]*-[-.0-9_a-z]*$/.test(localName);
    return !reserved && validForm && !localName.startsWith('oj-bind-', 0);
  }
};



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true*/

/**
 * @export
 * @class oj.EventSource
 * @classdesc Object which supports subscribing to and firing events
 * @constructor
 * @final
 * @since 1.1
 * @ojdeprecated {since: '5.0.0', description: 'Use DataProvider instead.'}
 */
oj.EventSource = function () {
  this.Init();
}; // Subclass from oj.Object


oj.Object.createSubclass(oj.EventSource, oj.Object, 'oj.EventSource');
/**
 * Initializes the instance.
 * @export
 */

oj.EventSource.prototype.Init = function () {
  this._eventHandlers = [];
  oj.EventSource.superclass.Init.call(this);
};
/**
 * Attach an event handler.
 * <p>Application can call this if it wants to be notified of an event.  It can call the <code class="prettyprint">off</code> method to detach the handler when it no longer wants to be notified.</p>
 * @param {string} eventType eventType
 * @param {function(Object)} eventHandler event handler function
 * @return {void}
 * @memberof oj.EventSource
 * @export
 */


oj.EventSource.prototype.on = function (eventType, eventHandler) {
  var foundEventHandler = false;

  for (var i = 0; i < this._eventHandlers.length; i++) {
    if (this._eventHandlers[i].eventType === eventType && this._eventHandlers[i].eventHandlerFunc === eventHandler) {
      foundEventHandler = true;
      break;
    }
  }

  if (!foundEventHandler) {
    this._eventHandlers.push({
      eventType: eventType,
      eventHandlerFunc: eventHandler
    });
  }
};
/**
 * Detach an event handler.
 * <p>Application can call this if it no longer wants to be notified of an event that it has attached an handler to using the <code class="prettyprint">on</code> method.</p>
 * @param {string} eventType eventType
 * @param {function(Object)} eventHandler event handler function
 * @return {void}
 * @memberof oj.EventSource
 * @export
 */


oj.EventSource.prototype.off = function (eventType, eventHandler) {
  for (var i = this._eventHandlers.length - 1; i >= 0; i--) {
    if (this._eventHandlers[i].eventType === eventType && this._eventHandlers[i].eventHandlerFunc === eventHandler) {
      this._eventHandlers.splice(i, 1);

      break;
    }
  }
};
/**
 * Handle the event
 * @param {string} eventType  event type
 * @param {Object} event  event
 * @return {boolean} Returns false if event is cancelled
 * @memberof oj.EventSource
 * @export
 */
// eslint-disable-next-line no-unused-vars


oj.EventSource.prototype.handleEvent = function (eventType, event) {
  var returnValue;

  for (var i = 0; i < this._eventHandlers.length; i++) {
    var eventHandler = this._eventHandlers[i];

    if (eventHandler.eventType === eventType) {
      returnValue = eventHandler.eventHandlerFunc.apply(this, Array.prototype.slice.call(arguments).slice(1));

      if (returnValue === false) {
        // event cancelled
        return false;
      }
    }
  }

  return true;
};



/**
 * Key utilities.
 * @class oj.KeyUtils
 * @export
 * @ignore
 */
oj.KeyUtils = {};
/**
 * Determine whether the two keys specified are considered equal.
 *
 * @param {any} key1 first key to compare
 * @param {any} key2 second key to compare
 * @returns {boolean} true if the keys are considered the same, false otherwise.
 * @export
 * @memberof oj.KeyUtils
 */

oj.KeyUtils.equals = function (key1, key2) {
  // algorithm for key equality:
  // if the keys are of type primitive, then do === comparison
  // if the keys are object, then do deep comparison of properties
  // for now, this is the same as compareValues, but this allows us to diverge in the future
  // ex: generate hash with key and compare hash value instead
  return oj.Object.compareValues(key1, key2);
};



/* global _scope:false, Logger:false */

/**
 * @private
 */
var _checkpointManagerDelegate = _scope.__ojCheckpointManager;
/**
 * Global Checkpoint Manager Instance
 * @const
 * @export
 * @ignore
 */

oj.CHECKPOINT_MANAGER = {};
/**
 * Starts a checkpoint
 * @param {!string} name - the name of the checkpoint
 * @param {string=} description - optional description of the checkpoint
 * @export
 * @memberof! oj.CHECKPOINT_MANAGER
 */

oj.CHECKPOINT_MANAGER.startCheckpoint = function (name, description) {
  if (_checkpointManagerDelegate) {
    _checkpointManagerDelegate.startCheckpoint(name, description);
  }
};
/**
 * Ends a checkpoint
 * @param {!string} name - the name of the checkpoint
 * @export
 * @memberof! oj.CHECKPOINT_MANAGER
 */


oj.CHECKPOINT_MANAGER.endCheckpoint = function (name) {
  if (_checkpointManagerDelegate) {
    _checkpointManagerDelegate.endCheckpoint(name);
  }
};
/**
 * Retrieves a checkpoint record for a given name
 * @param {!string} name - the name of the checkpoint
 * @return {undefined|{start: number, end: number, duration: number, name: {string}, description: (string|undefined)}}
 * @export
 * @memberof! oj.CHECKPOINT_MANAGER
 */


oj.CHECKPOINT_MANAGER.getRecord = function (name) {
  return _checkpointManagerDelegate ? _checkpointManagerDelegate.getRecord(name) : undefined;
};
/**
 * Retrieves all checkpoint records matching a regular expression
 * @param {!RegExp} regexp - regular expression to match.
 * @return Array.{{start: number, end: number, duration: number, name: {string}, description: (string|undefined)}}
 * @export
 * @memberof! oj.CHECKPOINT_MANAGER
 */


oj.CHECKPOINT_MANAGER.matchRecords = function (regexp) {
  return _checkpointManagerDelegate ? _checkpointManagerDelegate.matchRecords(regexp) : [];
};
/**
 * Dumps matched records into oj.Logger
 * @param {!RegExp} regexp - regular expression for the records to dump.
 * @export
 * @memberof! oj.CHECKPOINT_MANAGER
 */


oj.CHECKPOINT_MANAGER.dump = function (regexp) {
  Logger.info(function () {
    var logMsg = 'Checkpoint Records:';
    var records = oj.CHECKPOINT_MANAGER.matchRecords(regexp);

    for (var i = 0; i < records.length; i++) {
      var record = records[i];
      logMsg = logMsg + '\n' + record.name;
      var desc = record.description;

      if (desc != null) {
        logMsg = logMsg + ' (' + desc + ')';
      }

      logMsg += ':\n';
      logMsg = logMsg + 'start: ' + record.start + '\tduration: ' + record.duration;
    }

    return logMsg;
  });
};

;return oj;
});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojcontext',['ojs/ojcore-base', 'ojs/ojlogger' ], function(oj, Logger)
{
  "use strict";


/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* global Promise:false, Map:false, Logger:false */

/**
 * <p>The purpose of the BusyContext API is to accommodate sequential dependencies of asynchronous
 * operations. A common use cases defining the API is for automation testing (qunit and webdriver).
 * Automation test developers can use this API to wait until components finish animation effects
 * or data fetch before trying to interact with components. The BusyContext is not limited to
 * test automation developers usages. It is also needed by page developers for waiting on run-time
 * operation readiness.</p>
 *
 * The Busy Context API will wait until busy states have resolved or a timeout period has elapsed.
 * There are several primary wait scenarios:
 * <ol>
 *   <li>Component creation and page bindings applied.</li>
 *   <li>Components that implement animation effects.</li>
 *   <li>Components that must fetch data from a REST endpoint.</li>
 *   <li>General wait conditions that are not specific to the Jet framework. The customer might
 *       choose to register some busy condition associated with application domain logic such
 *       as REST endpoints.</li>
 *   <li>Wait until the bootstrap of the page has completed - jet libraries loaded via requireJS.</li>
 * </ol>
 *
 * <p>The first step for waiting on a busy context is to determine what conditions are of interest
 *   to wait on. The granularity of a busy context can be scoped for the entirety of the page or
 *   for a specific DOM element. Busy contexts have hierarchical dependencies mirroring the
 *   document's DOM structure with the root being the page context. Depending on the particular
 *   scenario, developers might need to target one of the following busy context scopes:</p>
 * <ul>
 *   <li>Scoped for the Page - Automation test developers will more commonly choose the page busy
 *     context. This context represents the page as a whole. Automation developers commonly need
 *     to wait until the page is fully loaded before starting automation. More commonly, automation
 *     developers are interesting in testing the functionality of an application having multiple
 *     JET components versus just a single component.
 *
 *     <pre class="prettyprint">
 *     <code>
 *     var busyContext = oj.Context.getPageContext().getBusyContext();
 *     </code></pre>
 *
 *   </li>
 *   <li>Scoped for the nearest DOM Element - Application developers sometime need a mechanism to
 *     wait until a specific component operation has complete. For example, it might be desirable
 *     to wait until a component has been created and bindings applied before setting a property or
 *     calling a method on the component. Another scenario, waiting for a popup to finish
 *     open or close animation before initiating the next action in their application flow.
 *     For this problem space developers would need to obtain a busy context scoped for a DOM node.
 *     The "data-oj-context" marker attribute is used to define a busy context for a dom subtree.
 *
 *     <pre class="prettyprint">
 *     <code>
 *     <!-- subtree assigned a marker 'data-oj-context' attribute -->
 *     &lt;div id="mycontext" data-oj-context&gt;
 *        ...
 *        &lt;!-- JET content --&gt;
 *        ...
 *     &lt;/div&gt;
 *
 *     var node = document.querySelector("#mycontext");
 *     var busyContext = oj.Context.getContext(node).getBusyContext();
 *     busyContext.whenReady().then(function ()
 *     {
 *       var component = document.querySelector("#myInput");
 *       component.value = "foo";
 *       component.validate().then(function (isValid)
 *       {
 *         if (!isValid)
 *           component.value = "foobar";
 *       });
 *     });
 *     </code></pre>
 *
 *   </li>
 * </ul>
 *
 * The BusyContext API utilizes {@link Logger.LEVEL_LOG} to log detail busy state activity.
 * <pre class="prettyprint">
 * <code>
 *  Logger.option("level", Logger.LEVEL_LOG);
 * </code></pre>
 *
 * <b>This constructor should never be invoked by the application code directly.</b>
 * @hideconstructor
 * @param {Element=} hostNode DOM element associated with this busy context
 * @export
 * @constructor oj.BusyContext
 * @ojtsmodule
 * @ojtsnoexport
 * @ojtsexportastype Context
 * @since 2.1.0
 * @classdesc Framework service for querying the busy state of components on the page.
 */
oj.BusyContext = function (hostNode) {
  this.Init(hostNode);
};

oj.Object.createSubclass(oj.BusyContext, oj.Object, 'oj.BusyContext');
/**
 * see oj.BusyContext#setDefaultTimeout
 * @type {number}
 * @ignore
 * @private
 */

oj.BusyContext._defaultTimeout = Number.NaN;
/**
 * Sets a default for the optional <code>timeout</code> argument of the {@link oj.BusyContext#whenReady}
 * for all BusyContext instances. The default value will be implicitly used if a timeout argument is not
 * provided.
 *
 * @export
 * @see oj.BusyContext#whenReady
 * @since 3.1.0
 * @memberof oj.BusyContext
 * @method setDefaultTimeout
 * @param {number} timeout in milliseconds
 * @ojdeprecated {since: '6.0.0', description: 'Use oj.Context.setBusyContextDefaultTimeout instead.'}
 * @return {undefined}
 */

oj.BusyContext.setDefaultTimeout = function (timeout) {
  if (!isNaN(timeout)) {
    oj.BusyContext._defaultTimeout = timeout;
  }
};
/**
 * @param {Element=} hostNode DOM element associated with this busy context
 * @instance
 * @protected
 */


oj.BusyContext.prototype.Init = function (hostNode) {
  oj.BusyContext.superclass.Init.call(this);
  this._hostNode = hostNode;
  /**
   * Busy states cache.
   *
   * @type {?}
   * @ignore
   * @private
   */

  this._statesMap = new Map();
  /**
   * Coordinates resolution of the master when ready promise with one or more slave
   * when ready promises having a timeout period.
   *
   * @type {Object}
   * @ignore
   * @private
   */

  this._mediator = {
    /**
     * Returns a master primise that will resolve when all busy states have been resolved.
     *
     * @returns {Promise}
     * @ignore
     * @private
     */
    getMasterWhenReadyPromise: function getMasterWhenReadyPromise() {
      if (!this._masterWhenReadyPromise) {
        this._masterWhenReadyPromise = new Promise(this._captureWhenReadyPromiseResolver.bind(this));
      }

      return this._masterWhenReadyPromise;
    },

    /**
     * Triggers resolution of the master promise and clears all timeouts associated with slave
     * when ready promises.
     *
     * @returns {void}
     * @ignore
     * @private
     */
    resolveMasterWhenReadyPromise: function resolveMasterWhenReadyPromise() {
      if (this._masterWhenReadyPromiseResolver) {
        this._masterWhenReadyPromiseResolver(true);
      }

      this._masterWhenReadyPromise = null;
      this._masterWhenReadyPromiseResolver = null;
      this._masterWhenReadyPromiseRejecter = null;
    },

    /**
     * Triggers rejections of the master promise.
     * @param {Object=} error
     * @returns {void}
     * @ignore
     * @private
     */
    rejectMasterWhenReadyPromise: function rejectMasterWhenReadyPromise(error) {
      if (this._masterWhenReadyPromiseRejecter) {
        this._masterWhenReadyPromiseRejecter(error);
      }

      this._masterWhenReadyPromise = null;
      this._masterWhenReadyPromiseRejecter = null;
      this._masterWhenReadyPromiseResolver = null;
    },

    /**
     * Returns a promise that will resolve when the master promise resolves or reject when
     * the slave timeout promise rejects.
     *
     * @param {Promise} master
     * @param {Function} generateErrorCallback
     * @param {number} timeout
     * @returns {Promise}
     * @ignore
     * @private
     */
    getSlaveTimeoutPromise: function getSlaveTimeoutPromise(master, generateErrorCallback, timeout) {
      var timer;
      var slaveTimeoutPromise = new Promise(function (resolve, reject) {
        timer = window.setTimeout(function () {
          reject(generateErrorCallback());
        }, timeout);
      });

      this._slaveTimeoutPromiseTimers.push(timer); // When the master promise is resolved, all timers may be cleared


      return Promise.race([master, slaveTimeoutPromise]).then(this._clearAllSlaveTimeouts.bind(this));
    },

    /**
     * @private
     * @ignore
     * @return {Promise} resolves on the next-tick using setImmediate.
     */
    getNextTickPromise: function getNextTickPromise() {
      if (!this._nextTickPromise) {
        this._nextTickPromise = new Promise(function (resolve) {
          window.setImmediate(function () {
            this._nextTickPromise = null;
            resolve(true);
          }.bind(this));
        }.bind(this));
      }

      return this._nextTickPromise;
    },

    /**
     * Clears all window timeout timeers that are slave when ready promises.
     *
     * @returns {boolean}
     * @ignore
     * @private
     */
    _clearAllSlaveTimeouts: function _clearAllSlaveTimeouts() {
      var slaveTimeoutPromiseTimers = this._slaveTimeoutPromiseTimers;
      this._slaveTimeoutPromiseTimers = [];

      for (var i = 0; i < slaveTimeoutPromiseTimers.length; i++) {
        window.clearTimeout(slaveTimeoutPromiseTimers[i]);
      }

      return true;
    },

    /**
     * Promise executor function passed as the single master promise constructor.  Captures the
     * promise resolve callback function.  The resolve promise function will be called when all the
     * busy states have been removed.
     *
     * @param {Function} resolve
     * @param {Function} reject
     * @returns {void}
     * @ignore
     * @private
     */
    // eslint-disable-next-line no-unused-vars
    _captureWhenReadyPromiseResolver: function _captureWhenReadyPromiseResolver(resolve, reject) {
      this._masterWhenReadyPromiseResolver = resolve;
      this._masterWhenReadyPromiseRejecter = reject;
    },

    /**
     * Array of setTimeout timers that should be cancled when the busy state resolves.
     *
     * @type {Array.<number>}
     * @ignore
     * @private
     */
    _slaveTimeoutPromiseTimers: []
    /**
     * The master when ready promise that will resovle when all busy states resolve.
     *
     * @type {Promise|undefined}
     * @ignore
     * @private
     */
    // _masterWhenReadyPromise : undefined,

    /**
     * The resolve function of the masterWhenReadyPromise.
     *
     * @type {Function|undefined}
     * @ignore
     * @private
     */
    // _masterWhenReadyPromiseResolver : undefined,

    /**
    * The reject function of the masterWhenReadyPromise.
    *
    * @type {Function|undefined}
    * @ignore
    * @private
    */
    // _masterWhenReadyPromiseRejecter : undefined,

    /**
     * Promise evaluated next-tick.
     *
     * @type {Promise|undefined}
     * @ignore
     * @private
     */
    // _nextTickPromise : undefined

  };
};
/**
 * Logs the current registered busy states ordered acceding by the order they were added.
 * The cost of compiling the list is only made if the logger level is Logger.LEVEL_LOG.
 * @param {?} statesMap busy states
 * @returns {void}
 * @private
 */


oj.BusyContext._log = function (statesMap) {
  if (Logger.option('level') !== Logger.LEVEL_LOG) {
    return;
  }

  Logger.log('>> Busy states: %d', statesMap.size);

  var busyStates = oj.BusyContext._values(statesMap);

  if (busyStates.length > 0) {
    Logger.log(busyStates.join('\n'));
  }
};
/**
 * @param {?} statesMap busy states
 * @return {Array.<oj.BusyState>} Returns an array of busy states entries from the states map
 * @private
 */


oj.BusyContext._values = function (statesMap) {
  var busyStates = [];
  statesMap.forEach(function (value) {
    busyStates.push(value);
  });
  return busyStates;
};
/**
 * <p>Called by components or services performing a task that should be considered
 * in the overall busy state of the page. An example would be animation or fetching data.</p>
 *
 * Caveats:
 * <ul>
 *   <li>Busy context dependency relationships are determined at the point the first busy state
 *       is added.  If the DOM node is re-parented after a busy context was added, the context will
 *       maintain dependencies with any parent DOM contexts.</li>
 *   <li>The application logic creating busy states is responsible for ensuring these busy states
 *       are resolved. Busy states added internally by JET are automatically accounted for.
 *       The busy states added by the application logic must manage a reference to the resolve
 *       function associated with a busy state and it must be called to release the busy state.</li>
 * </ul>
 *
 * <pre class="prettyprint">
 * <code>// apply the marker attribute to the element
 * &lt;div id="context1" data-oj-context ... &gt;&lt;/&gt;
 * ...
 * ...
 * var context1 = document.querySelector("#context1");
 *
 * // obtain a busy context scoped for the target node
 * var busyContext1 = oj.Context.getContext(context1).getBusyContext();
 * // add a busy state to the target context
 * var options = {"description": "#context1 fetching data"};
 * var resolve = busyContext1.addBusyState(options);
 * ...
 * ...  // perform asynchronous operation that needs guarded by a busy state
 * ...
 * // resolve the busy state after the operation completes
 * resolve();
 * </code></pre>
 *
 * @since 2.1.0
 * @export
 * @memberof oj.BusyContext
 * @instance
 * @method addBusyState
 * @param {Object} options object that describes the busy state being registered.<br/>
 * @param {Object|function():string} options.description
 *         description: Option additional information of what is registering a busy state. Added to
 *                      logging and handling rejected status. Can be supplied as a Object or a
 *                      function.  If the type is an object the toString function needs to be
 *                      implemented.
 * @ojsignature [{target: "Type",
 *                value: "{
 *                         toString: ()=>string;
 *                         [propName: string]: any;
 *                       } | (() => string) | string",
 *                for: "options.description"}]
 * @returns {function():void} resolve function called by the registrant when the busy state completes.
 *                     The resultant function will throw an error if the busy state is no longer
 *                     registered.
 */


oj.BusyContext.prototype.addBusyState = function (options) {
  Logger.log("BusyContext.addBusyState: start scope='%s'", this._getDebugScope());
  var statesMap = this._statesMap;
  /** @type {oj.BusyState} */

  var busyState = new oj.BusyState(options[oj.BusyContext._DESCRIPTION]);
  Logger.log('>> ' + busyState);
  statesMap.set(busyState.id, busyState);

  this._addBusyStateToParent();

  Logger.log("BusyContext.addBusyState: end scope='%s'", this._getDebugScope());
  return this._removeBusyState.bind(this, busyState);
};
/**
 * Logs all active busy states to the {@link oj.Logger} at {Logger.LEVEL_INFO}.
 * <pre class="prettyprint">
 * <code>
 *  Logger.option("level", Logger.LEVEL_INFO);
 *  oj.Context.getPageContext().getBusyContext().dump("before popup open");
 * </code></pre>
 *
 * @export
 * @since 3.1.0
 * @memberof oj.BusyContext
 * @instance
 * @method dump
 * @param {string=} message optional text used to further denote a debugging point
 * @return {undefined}
 */


oj.BusyContext.prototype.dump = function (message) {
  Logger.info("BusyContext.dump: start scope='%s' %s", this._getDebugScope(), message || '');
  var statesMap = this._statesMap;
  Logger.info('>> Busy states: %d', statesMap.size);

  var busyStates = oj.BusyContext._values(statesMap);

  if (busyStates.length > 0) {
    Logger.info(busyStates.join('\n'));
  }

  Logger.info("BusyContext.dump: start scope='%s' %s", this._getDebugScope(), message || '');
};
/**
 * Returns an array of states representing the active busy states managed by the instance.
 *
 * @export
 * @since 3.1.0
 * @method getBusyStates
 * @memberof oj.BusyContext
 * @instance
 * @return {Array.<{id:string, description:string}>} active busy states managed by the context
 *         instance
 */


oj.BusyContext.prototype.getBusyStates = function () {
  var statesMap = this._statesMap;
  /** @type {?} */

  var busyStates = oj.BusyContext._values(statesMap);

  return busyStates;
};
/**
 * Forces all busy states per context instance to release.
 * Use with discretion - last course of action.
 *
 * @since 3.1.0
 * @method clear
 * @memberof oj.BusyContext
 * @instance
 * @export
 * @return {undefined}
 */


oj.BusyContext.prototype.clear = function () {
  Logger.log("BusyContext.clear: start scope='%s'", this._getDebugScope());
  var statesMap = this._statesMap;

  var busyStates = oj.BusyContext._values(statesMap);

  for (var i = 0; i < busyStates.length; i++) {
    /** @type {?} **/
    var busyState = busyStates[i];

    try {
      this._removeBusyState(busyState);
    } catch (e) {
      Logger.log('BusyContext.clear: %o', e);
    }

    Object.defineProperty(busyState, oj.BusyContext._OJ_RIP, {
      value: true,
      enumerable: false
    });
  }

  Logger.log("BusyContext.clear: end scope='%s'", this._getDebugScope());
};
/**
 * <p>Returns a Promise that will resolve when all registered busy states have completed or a maximum
 * timeout period has elapsed. The promise will be rejected if all the busy states are not resolved
 * within the timeout period. The busyness of the whenReady promsie is evaluated in the next-tick
 * of resolving a busy state.</p>
 *
 * "next-tick" is at the macrotask level. "whenReady" is waiting for the microtask queue to be exhausted,
 * yielding control flow to the user agent, before resolving busyness.
 *
 * @see oj.BusyContext#applicationBootstrapComplete
 * @since 2.1.0
 * @export
 * @memberof oj.BusyContext
 * @instance
 * @method whenReady
 * @param {number=} timeout "optional" maximum period in milliseconds the resultant promise
 *        will wait. Also see {@link oj.BusyContext.setDefaultTimeout}.
 * @returns {Promise.<boolean|Error>}
 */


oj.BusyContext.prototype.whenReady = function (timeout) {
  var debugScope = this._getDebugScope();

  Logger.log("BusyContext.whenReady: start, scope='%s', timeout=%d", debugScope, timeout);
  /** @type {?} */

  var statesMap = this._statesMap;
  var mediator = this._mediator;
  var nextTickPromise = mediator.getNextTickPromise();

  var bootstrapPromise = oj.BusyContext._BOOTSTRAP_MEDIATOR.whenReady();

  var promise = Promise.all([nextTickPromise, bootstrapPromise]).then(function () {
    Logger.log('BusyContext.whenReady: bootstrap mediator ready scope=%s', debugScope);

    try {
      // Since we are executing this code on 'next tick', it is safe to flush any JET throttled updates.
      // Doing so will allow us to take into account any busy states added in response to the pending updates
      oj.BusyContext._deliverThrottledUpdates();
    } catch (e) {
      Logger.error('Fatal exception delivering binding updates: %o', e);
      throw e;
    }

    if (statesMap.size === 0 && !this._waitingOnNextTickBusynessEval) {
      // no busy states, promise resolves immediately
      Logger.log('BusyContext.whenReady: resolved no busy states scope=%s', debugScope);
      return true;
    }

    Logger.log('BusyContext.whenReady: busy states returning master scope=%s', debugScope);
    return mediator.getMasterWhenReadyPromise();
  }.bind(this)); // if a timeout argument is not provided, check the default timeout

  if (isNaN(timeout) && !isNaN(oj.BusyContext._defaultTimeout)) {
    // eslint-disable-next-line no-param-reassign
    timeout = oj.BusyContext._defaultTimeout;
  }

  if (!isNaN(timeout)) {
    var handleTimeout = function handleTimeout() {
      var error;
      var expiredText = 'whenReady timeout of ' + timeout + 'ms expired ';

      oj.BusyContext._log(statesMap);

      var busyStates = oj.BusyContext._values(statesMap);

      if (!oj.BusyContext._BOOTSTRAP_MEDIATOR.isReady()) {
        error = new Error(expiredText + 'while the application is loading.' + ' Busy state enabled by setting the "window.oj_whenReady = true;" global variable.' + ' Application bootstrap busy state is released by calling' + ' "oj.Context.getPageContext().getBusyContext().applicationBootstrapComplete();".');
      } else {
        error = new Error(expiredText + 'with the following busy states: ' + busyStates.join(', '));
      }

      error.busyStates = busyStates;
      Logger.log("BusyContext.whenReady: rejected scope='%s'\n%s", debugScope, error.message);
      return error;
    };

    promise = mediator.getSlaveTimeoutPromise(promise, handleTimeout, timeout);
  }

  Logger.log("BusyContext.whenReady: end scope='%s'", this._getDebugScope());
  return promise;
};
/**
 * <p>Describes the busyness of the context. The busyness is evaluated in the "next-tick" of a busy
 * state being resolved, meaning the number of busy states doesn't necessarily equate to readiness.
 * The readiness is in sync with the {@link oj.BusyContext#whenReady} resultant promise resolution.</p>
 *
 * @see oj.BusyContext#getBusyStates
 * @since 2.1.0
 * @export
 * @memberof oj.BusyContext
 * @instance
 * @method isReady
 * @returns {boolean} <code>true</code> if the context is not busy
 */


oj.BusyContext.prototype.isReady = function () {
  Logger.log("BusyContext.isReady: start scope='%s'", this._getDebugScope());
  var rtn = false;

  if (oj.BusyContext._BOOTSTRAP_MEDIATOR.isReady() && !this._waitingOnNextTickBusynessEval) {
    var statesMap = this._statesMap;
    rtn = statesMap.size === 0;

    oj.BusyContext._log(statesMap);
  }

  Logger.log("BusyContext.isReady: end scope='%s'", this._getDebugScope());
  return rtn;
};
/**
 * @private
 * @param {oj.BusyState} busyState added busy state
 * @returns {void}
 * @throws {Error} Busy state has already been resolved
 */


oj.BusyContext.prototype._removeBusyState = function (busyState) {
  var debugScope = this._getDebugScope();

  Logger.log("BusyContext._removeBusyState: start scope='%s'", debugScope); // The BusyState object is passed here instead of just the generated id to provide a more
  // descriptive message when the busy state is removed twice. The description (if provided) of
  // the busy state will be captured in the error message.

  var statesMap = this._statesMap;

  if (busyState[oj.BusyContext._OJ_RIP]) {
    Logger.log('Busy state has been forcefully resolved via clear:\n' + busyState);
    return;
  } else if (!statesMap.delete(busyState.id)) {
    // quoted to make the closure compiler happy
    throw new Error('Busy state has already been resolved:\n' + busyState);
  }

  Logger.log('BusyContext._removeBusyState: resolving busy state:\n' + busyState);

  if (statesMap.size === 0 && !this._waitingOnNextTickBusynessEval) {
    // no more busy states; evaluate busyness in the next tick
    this._waitingOnNextTickBusynessEval = true;
    window.setImmediate(this._evalBusyness.bind(this));
  }

  Logger.log("BusyContext._removeBusyState: end scope='%s'", debugScope);
};
/**
 * Evaluates the busyness of the context.
 * @private
 */


oj.BusyContext.prototype._evalBusyness = function () {
  var debugScope = this._getDebugScope();

  Logger.log("BusyContext._evalBusyness: begin scope='%s'", debugScope);

  try {
    // Since we are executing this code on 'next tick', it is safe to flush any JET throttled updates.
    // Doing so will allow us to take into account any busy states added in response to the pending updates
    oj.BusyContext._deliverThrottledUpdates();
  } catch (e) {
    Logger.error('Fatal exception delivering binding updates: %o', e);

    this._mediator.rejectMasterWhenReadyPromise(e);

    this._waitingOnNextTickBusynessEval = false;
    return;
  }

  var statesMap = this._statesMap;
  var mediator = this._mediator; // "appears" the Edge promise invokes the resolve callback immediately after
  // resolving versus waiting next micro tick.  Toggle the flag here so if
  // isReady() is called from the promise resolve callback, it returns true.

  this._waitingOnNextTickBusynessEval = false;

  if (statesMap.size === 0) {
    Logger.log('BusyContext._evalBusyness: resolving whenReady promises');
    mediator.resolveMasterWhenReadyPromise();

    this._resolveBusyStateForParent();
  } else {
    oj.BusyContext._log(statesMap);
  }

  Logger.log("BusyContext._evalBusyness: end scope='%s'", debugScope);
};
/**
 * <p>This function should be invoke by application domain logic to indicate all application
 * libraries are loaded and bootstrap processes complete.  The assumed strategy is that the
 * application will set a single global variable "oj_whenReady" from a inline script from the
 * document header section indicating the {@link oj.BusyContext#whenReady}
 * should {@link oj.BusyContext#addBusyState} until the application determines its bootstrap
 * sequence has completed.</p>
 *
 * Inline Script Example:
 * <pre class="prettyprint">
 * <code>
 * &lt;head&gt;
 *   &lt;script type=&quot;text/javascript&quot;&gt;
 *     // The "oj_whenReady" global variable enables a strategy that the busy context whenReady,
 *     // will implicitly add a busy state, until the application calls applicationBootstrapComplete
 *     // on the busy state context.
 *     window["oj_whenReady"] = true;
 *   &lt;/script&gt;
 * ...
 * ...
 * </code></pre>
 *
 * Requirejs callback Example:
 * <pre class="prettyprint">
 * <code>
 * require(['knockout', 'jquery', 'app', 'ojs/ojknockout', 'ojs/ojselectcombobox' ...],
 *   function(ko, $, app)
 *   {
 *     // release the application bootstrap busy state
 *     oj.Context.getPageContext().getBusyContext().applicationBootstrapComplete();
 *     ...
 *     ...
 *   });
 * </code></pre>
 *
 * @since 3.2.0
 * @export
 * @memberof oj.BusyContext
 * @instance
 * @method applicationBootstrapComplete
 * @returns {undefined}
 */


oj.BusyContext.prototype.applicationBootstrapComplete = function () {
  var debugScope = this._getDebugScope();

  Logger.log("BusyContext.applicationBootstrapComplete: begin scope='%s'", debugScope);

  oj.BusyContext._BOOTSTRAP_MEDIATOR.notifyComplete();

  Logger.log("BusyContext.applicationBootstrapComplete: end scope='%s'", debugScope);
};
/**
 * @ignore
 * @private
 * @return {oj.BusyContext} returns the nearest parent context
 */


oj.BusyContext.prototype._getParentBusyContext = function () {
  if (this._hostNode) {
    var parentContext = oj.Context.getContext(oj.Context.getParentElement(this._hostNode));

    if (parentContext) {
      return parentContext.getBusyContext();
    }
  }

  return null;
};
/**
 * Links a child context to its parent by registering a busy state with the parent
 * that will recursively register with its parent.
 *
 * @ignore
 * @private
 */


oj.BusyContext.prototype._addBusyStateToParent = function () {
  if (!this._parentNotified) {
    this._parentNotified = true;

    var parentContext = this._getParentBusyContext();

    if (parentContext) {
      var opts = {};
      opts[oj.BusyContext._DESCRIPTION] = this._getCompoundDescription.bind(this);
      this._parentResolveCallback = parentContext.addBusyState(opts);
    }
  }
};
/**
 * Resolves the busy state linking a child context with its parent.
 *
 * @ignore
 * @private
 */


oj.BusyContext.prototype._resolveBusyStateForParent = function () {
  this._parentNotified = false;

  if (this._parentResolveCallback) {
    this._parentResolveCallback();

    this._parentResolveCallback = null;
  }
};
/**
 * @private
 * @ignore
 * @return {string} description of all active busy states held by the context.
 */


oj.BusyContext.prototype._getCompoundDescription = function () {
  var busyStates = oj.BusyContext._values(this._statesMap);

  return '[' + busyStates.join(', ') + ']';
};
/**
 * @private
 * @ignore
 * @return {string} context debug scope
 */


oj.BusyContext.prototype._getDebugScope = function () {
  function toSelector(node) {
    var selector = 'undefined';

    if (node) {
      if (node.id && node.id.length > 0) {
        selector = '#' + node.id;
      } else {
        selector = node.nodeName;

        if (node.hasAttribute('data-oj-context')) {
          selector += '[data-oj-context]';
        }

        var clazz = node.getAttribute('class');

        if (clazz) {
          selector += '.' + clazz.split(' ').join('.');
        }
      }
    }

    return selector;
  }

  if (!this._debugScope) {
    if (this._hostNode) {
      this._debugScope = toSelector(this._hostNode.parentElement) + ' > ' + toSelector(this._hostNode);
    } else {
      this._debugScope = 'page';
    }
  }

  return this._debugScope;
};
/**
 * @since 3.1.0
 * @override
 * @memberof oj.BusyContext
 * @instance
 * @method toString
 * @returns {string} returns the value of the object as a string
 */


oj.BusyContext.prototype.toString = function () {
  var msg = 'Busy Context: [scope=';
  msg += this._getDebugScope();
  msg += ' states=' + this._getCompoundDescription() + ']';
  return msg;
};
/**
 * @ignore
 * @private
 */


oj.BusyContext._deliverThrottledUpdates = function () {
  // Dynamically check for the presence of ojs/ojknockout
  if (oj.ComponentBinding) {
    oj.ComponentBinding.deliverChanges();
  }
};
/**
 * @private
 * @ignore
 * @const
 * attribute name describing a busystate
 * @type {string}
 */


oj.BusyContext._DESCRIPTION = 'description';
/**
 * @ignore
 * @private
 * @constant
 * {@link oj.BusyState} property name indicating the instance is dead
 * @type {string}
 */

oj.BusyContext._OJ_RIP = '__ojRip';
/**
 * @ojtsignore
 * @private
 * @ignore
 */

oj.BusyContext._BOOTSTRAP_MEDIATOR = new
/** @constructor */
function () {
  var _tracking;

  var _readyPromise;

  var _resolveCallback;

  if (typeof window !== 'undefined') {
    _tracking = window.oj_whenReady;
  }

  this.whenReady = function () {
    if (_readyPromise) {
      return _readyPromise;
    }

    if (!_tracking) {
      _readyPromise = Promise.resolve(true);
    } else {
      _readyPromise = new Promise(function (resolve) {
        _resolveCallback = resolve;
      });
    }

    return _readyPromise;
  };

  this.isReady = function () {
    return !_tracking;
  };

  this.notifyComplete = function () {
    if (_resolveCallback) {
      // resovle the promise in the next-tick.
      window.setImmediate(function () {
        _tracking = false;

        _resolveCallback(true);

        _resolveCallback = null;
      });
    } else {
      _tracking = false;
    }
  };
}();



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/**
 * Internally used by the {@link oj.BusyContext} to track a components state
 * while it is performing a task such as animation or fetching data.
 *
 * @hideconstructor
 * @ignore
 * @protected
 * @constructor
 * @param {Function|Object|undefined} description of the component and cause
 *        of the busy state
 */
oj.BusyState = function (description) {
  /**
   * @ignore
   * @private
   * @type {?}
   */
  this._description = description;
  /**
   * @ignore
   * @private
   * @type {number}
   */

  this._addedWaitTs = oj.BusyState._getTs();
  /**
   * @ignore
   * @private
   * @type {string}
   */

  this._id = this._addedWaitTs.toString(36) + '_' + Math.random().toString(36); // @RandomNumberOK -
  // random number concatinated to the current timestamp is used for a unique id for a local Map
  // key. This random number is not used use as a cryptography key.
};

Object.defineProperties(oj.BusyState.prototype, {
  /**
   * Identifies the usage instance of a busy state.
   * @memberof oj.BusyState
   * @instance
   * @property {!string} id
   */
  id: {
    get: function get() {
      return this._id;
    },
    enumerable: true
  },

  /**
   * Further definition of the busy state instance.
   * @memberof oj.BusyState
   * @instance
   * @property {?string} description
   */
  description: {
    get: function get() {
      if (this._description) {
        if (this._description instanceof Function) {
          return this._description();
        }

        return this._description.toString();
      }

      return undefined;
    },
    enumerable: true
  }
});
/**
 * @override
 * @returns {string} returns the value of the object as a string
 */

oj.BusyState.prototype.toString = function () {
  var buff = 'Busy state: [description=';
  var description = this.description;

  if (description !== null) {
    buff += description;
  }

  var elapsed = oj.BusyState._getTs() - this._addedWaitTs;

  buff += ', elapsed=' + elapsed + ']';
  return buff;
};
/**
 * @private
 * @returns {number} current date represented by a number
 */


oj.BusyState._getTs = function () {
  // Safari V9.1.1 doesn't yet support performance.now
  return window.performance ? window.performance.now() : new Date().getTime();
};



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/**
 * <b>The constructor should never be invoked by an application directly</b>. Use
 * {@link oj.Context.getPageContext} and {@link oj.Context.getContext} APIs to
 * retrieve an instance of the context.
 * @param {Element=} node DOM node where the context should be created
 * @export
 * @hideconstructor
 * @ojtsmodule
 * @constructor oj.Context
 * @since 2.1.0
 * @classdesc This is a general purpose context. Initially it only exposes the BusyContext
 * that keeps track of components that are currently animating or fetching data.
 * In the future this context might be expanded for other purposes.
 */
var Context = function Context(node) {
  this.Init(node);
};

oj.Object.createSubclass(Context, oj.Object, 'oj.Context');
/**
 * @method Init
 * @param {Element=} node DOM node where the context should be created
 * @instance
 * @memberof oj.Context
 * @instance
 * @protected
 */

Context.prototype.Init = function (node) {
  Context.superclass.Init.call(this);
  this._node = node;
};
/**
 * Returns the closest enclosing JET context for a node.
 * Any DOM element may be designated by the page author as a host of JET context.
 * The designation must be expressed in HTML markup by specifying the "data-oj-context"
 * attribute on the host element:

 * <pre class="prettyprint">
 * &lt;div data-oj-context>&lt;div>
 * </pre>
 *
 * <p>This method will walk up the element hierarchy starting with the source node to
 * find an element that has the data-oj-context attribute. If no such element is found,
 * the page context will be returned.</p>
 *
 * If the JET context is established on a particular element, the {@link oj.BusyContext}
 * associated with that context will be tracking busy states for that element and
 * its subtree
 *
 * @see oj.BusyContext for code examples
 * @method getContext
 * @memberof oj.Context
 * @param {Element} node DOM element whose enclosing context will be provided
 * @return {oj.Context} context object scoped per the target node
 * @since 2.2.0
 * @export
 */


Context.getContext = function (node) {
  while (node) {
    var context = node[Context._OJ_CONTEXT_INSTANCE];

    if (context) {
      return context;
    }

    if (node.hasAttribute(Context._OJ_CONTEXT_ATTRIBUTE)) {
      context = new Context(node);
      Object.defineProperty(node, Context._OJ_CONTEXT_INSTANCE, {
        value: context
      });
      return context;
    } // eslint-disable-next-line no-param-reassign


    node = Context.getParentElement(node);
  }

  return Context.getPageContext();
};
/**
 * Static factory method that returns the page context.
 * @see oj.BusyContext for code examples
 * @export
 * @since 2.1.0
 * @method getPageContext
 * @return {oj.Context} context scoped for the page
 * @memberof oj.Context
 */


Context.getPageContext = function () {
  if (!Context._pageContext) {
    Context._pageContext = new Context();
  }

  return Context._pageContext;
};
/**
 * @see oj.BusyContext for code examples
 * @since 2.1.0
 * @export
 * @method getBusyContext
 * @memberof oj.Context
 * @instance
 * @returns {oj.BusyContext} busy state context
 */


Context.prototype.getBusyContext = function () {
  if (!this._busyContext) {
    this._busyContext = new oj.BusyContext(this._node);
  }

  return this._busyContext;
};
/**
 * Sets a default for the optional <code>timeout</code> argument of the {@link oj.BusyContext#whenReady}
 * for all BusyContext instances. The default value will be implicitly used if a timeout argument is not
 * provided.
 *
 * @see oj.BusyContext#whenReady
 * @since 6.0.0
 * @memberof oj.Context
 * @method setBusyContextDefaultTimeout
 * @param {number} timeout in milliseconds
 */


Context.setBusyContextDefaultTimeout = function (timeout) {
  oj.BusyContext.setDefaultTimeout(timeout);
};
/**
 * @ignore
 * @private
 * @constant
 * Element marker attribute defining a context
 * @type {string}
 */


Context._OJ_CONTEXT_ATTRIBUTE = 'data-oj-context';
/**
 * @ignore
 * @private
 * @constant
 * Element property name for a context
 * @type {string}
 */

Context._OJ_CONTEXT_INSTANCE = '__ojContextInstance';
/**
 * @ignore
 * @private
 * @constant
 * attribute identifying an open popup
 * @type {string}
 */

Context._OJ_SURROGATE_ATTR = 'data-oj-surrogate-id';
/**
 * @ignore
 * @public
 * @param {Element} element target
 * @return {Element} the logical parent of an element accounting for open popups
 * @memberof oj.Context
 */

Context.getParentElement = function (element) {
  // @see oj.ZOrderUtils._SURROGATE_ATTR in "ojpopupcore/PopupService.js" for the details on how
  // this attribute is used by the popup service. The constant was re-declared to simplify module
  // dependencies.
  if (element && element.hasAttribute(Context._OJ_SURROGATE_ATTR)) {
    var surrogate = document.getElementById(element.getAttribute(Context._OJ_SURROGATE_ATTR));

    if (surrogate) {
      return surrogate.parentElement;
    }
  }

  return element.parentElement;
};

;return Context;
});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * @license RequireJS i18n 2.0.2 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/requirejs/i18n for details
 */
!function(){"use strict";var e=/(^.*(^|\/)nls(\/|$))([^/]*)\/?([^/]*)/;function n(e,n,o,a,r,t,l){if(n[e]||(e=e.replace(/^zh-(Hans|Hant)-([^-]+)$/,"zh-$2")),n[e]){if(o.push(e),!0===n[e]||1===n[e]){var u=l?l+e:e;a.push(r+u+"/"+t)}return!0}return!1}function o(e){return"object"==typeof e}function a(e,n){for(var r=Object.keys(n),t=0;t<r.length;t++){var l=r[t];null==e[l]?e[l]=n[l]:o(n[l])&&o(e[l])&&a(e[l],n[l])}}define('ojL10n',["module"],function(o){var r=o.config?o.config():{};return{version:"2.0.1+",load:function(o,t,l,u){var c;(u=u||{}).locale&&(r.locale=u.locale);var i,f,s,v,g,h,p,d,y,m,L,O=e.exec(o),_=O[1],b=O[5],j=[],H={},k="";O[5]?(c=(_=O[1])+b,i=O[4]):(c=o,b=O[4],i=r.locale,"undefined"!=typeof document?(i||(i=u.isBuild?"root":document.documentElement.lang)||(i=void 0===navigator?"root":navigator.systemLanguage||navigator.language||navigator.userLanguage||"root"),r.locale=i):i="root"),f=function(e){var n,o=e.toLowerCase().split(/-|_/),a=[o[0]],r=1;for(n=1;n<o.length;n++){var t=o[n],l=t.length;if(1===l)break;switch(r){case 1:if(r=2,4===l){a.push(t.charAt(0).toUpperCase()+t.slice(1));break}case 2:r=3,a.push(t.toUpperCase());break;default:a.push(t)}}return function(e){if(!("zh"!==e[0]||e.length>1&&4===e[1].length)){var n="Hans",o=e.length>1?e[1]:null;"TW"!==o&&"MO"!==o&&"HK"!==o||(n="Hant"),e.splice(1,0,n)}}(a),a}(i),v=r.noOverlay,g=r.defaultNoOverlayLocale;var x=r.localePrefix;for((y=r.merge)&&(h=y[_+b])&&(O=e.exec(h),p=O[1],d=O[4]),m=[],s=0;s<f.length;s++)k+=(k?"-":"")+f[s],m.push(k);u.isBuild?(j.push(c),h&&j.push(h),t(j,function(){l()})):("query"===r.includeLocale&&(c=t.toUrl(c+".js"),c+=(-1===c.indexOf("?")?"?":"&")+"loc="+i),L=[c],h&&L.push(h),t(L,function(e,o){var r=[],u=function(e,o,a){for(var t=v||!0===e.__noOverlay,l=g||e.__defaultNoOverlayLocale,u=!1,c=m.length-1;c>=0&&(!u||!t);c--)u=n(m[c],e,r,j,o,a,x);var i=1===m.length&&"root"===m[0];t&&(i||!u)&&l&&n(l,e,r,j,o,a,x),i||n("root",e,r,j,o,a,x)};u(e,_,b);var c=r.length;o&&u(o,p,d),t(j,function(){var n=function(e,n,o,l,u){for(var c=n;c<o&&r[c];c++){var i=r[c],f=x?x+i:i,s=e[i];!0!==s&&1!==s||(s=t(l+f+"/"+u)),a(H,s||{})}};n(o,c,r.length,p,d),n(e,0,c,_,b),H._ojLocale_=f.join("-"),l(H)})}))}}})}();
define('ojtranslations/nls/ojtranslations',{root:{"oj-message":{fatal:"Fatal",error:"Error",warning:"Warning",info:"Info",confirmation:"Confirmation","compact-type-summary":"{0}: {1}"},"oj-converter":{summary:"Value is not in the expected format.",detail:"Enter a value in the expected format.","plural-separator":", ",hint:{summary:"Example: {exampleValue}",detail:"Enter a value in this format: '{exampleValue}'.","detail-plural":"Enter a value in these formats: '{exampleValue}'."},optionHint:{detail:"An accepted value for option '{propertyName}' is '{propertyValueValid}'.","detail-plural":"Accepted values for option '{propertyName}' are '{propertyValueValid}'."},optionTypesMismatch:{summary:"A value for the option '{requiredPropertyName}' is required when the option '{propertyName}' is set to '{propertyValue}'."},optionTypeInvalid:{summary:"A value of the expected type was not provided for option '{propertyName}'."},optionOutOfRange:{summary:"Value {propertyValue} is out of range for the option '{propertyName}'."},optionValueInvalid:{summary:"An invalid value '{propertyValue}' was specified for the option '{propertyName}'."},number:{decimalFormatMismatch:{summary:"The provided value is not in the expected number format."},shortLongUnsupportedParse:{summary:"'short' and 'long' are not supported for converter parsing.",detail:"Change component to readonly. readonly fields do not call the converter's parse function."},currencyFormatMismatch:{summary:"The provided value is not in the expected currency format."},percentFormatMismatch:{summary:"The provided value is not in the expected percent format."},invalidNumberFormat:{summary:"The provided value is not a valid number.",detail:"Please provide valid number."}},color:{invalidFormat:{summary:"Invalid color format.",detail:"Invalid color format option specification."},invalidSyntax:{summary:"Invalid color specification.",detail:"Enter a color value that conforms to the CSS3 standard."}},datetime:{datetimeOutOfRange:{summary:"Value '{value}' is out of range for the '{propertyName}'.",detail:"Enter a value between '{minValue}' and '{maxValue}'.",hour:"hour",minute:"minute",second:"second",millisec:"millisec",month:"month",day:"day",year:"year","month name":"month name",weekday:"weekday"},dateFormatMismatch:{summary:"The provided value is not in the expected date format."},invalidTimeZoneID:{summary:"Invalid timezone id {timeZoneID} provided."},nonExistingTime:{summary:"The input time does not exist because it falls during the transition to daylight saving time."},missingTimeZoneData:{summary:"TimeZone data is missing. Please call require 'ojs/ojtimezonedata' in order to load the TimeZone data."},timeFormatMismatch:{summary:"The provided value is not in the expected time format."},datetimeFormatMismatch:{summary:"The provided value is not in the expected date and time format."},dateToWeekdayMismatch:{summary:"Day '{date}' does not fall on a '{weekday}'.",detail:"Enter a weekday that corresponds with the date."},invalidISOString:{invalidRangeSummary:"The value '{value}' is out of range for the '{propertyName}' field in the ISO 8601 string '{isoStr}'.",summary:"The provided '{isoStr}' is not a valid ISO 8601 string.",detail:"Please provide valid ISO 8601 string."}}},"oj-validator":{length:{hint:{min:"Enter {min} or more characters.",max:"Enter {max} or fewer characters.",inRange:"Enter {min} to {max} characters.",exact:"Enter {length} characters."},messageDetail:{tooShort:"Enter {min} or more characters.",tooLong:"Enter no more than {max} characters."},messageSummary:{tooShort:"There are too few characters.",tooLong:"There are too many characters."}},range:{number:{hint:{min:"Enter a number greater than or equal to {min}.",max:"Enter a number less than or equal to {max}.",inRange:"Enter a number between {min} and {max}.",exact:"Enter the number {num}."},messageDetail:{rangeUnderflow:"Enter {min} or a higher number.",rangeOverflow:"Enter {max} or a lower number.",exact:"Enter the number {num}."},messageSummary:{rangeUnderflow:"The number is too low.",rangeOverflow:"The number is too high."}},datetime:{hint:{min:"Enter a date and time on or after {min}.",max:"Enter a date and time on or before {max}.",inRange:"Enter a date and time between {min} and {max}."},messageDetail:{rangeUnderflow:"Enter a date on or after {min}.",rangeOverflow:"Enter a date on or before {max}."},messageSummary:{rangeUnderflow:"Date and time is earlier than the minimum date and time.",rangeOverflow:"Date and time is later than the maximum date and time."}},date:{hint:{min:"Enter a date on or after {min}.",max:"Enter a date on or before {max}.",inRange:"Enter a date between {min} and {max}."},messageDetail:{rangeUnderflow:"Enter a date on or after {min}.",rangeOverflow:"Enter a date on or before {max}."},messageSummary:{rangeUnderflow:"Date is earlier than the minimum date.",rangeOverflow:"Date is later than the maximum date."}},time:{hint:{min:"Enter a time on or after {min}.",max:"Enter a time on or before {max}.",inRange:"Enter a time between {min} and {max}."},messageDetail:{rangeUnderflow:"Enter a time at or after {min}.",rangeOverflow:"Enter a time at or before {max}."},messageSummary:{rangeUnderflow:"Time is earlier than the minimum time.",rangeOverflow:"Time is later than the maximum time."}}},restriction:{date:{messageSummary:"Date {value} is of a disabled entry.",messageDetail:"The date you selected isn't available. Try another date."}},regExp:{summary:"Format is incorrect.",detail:"Enter allowable values described in this regular expression: '{pattern}'."},required:{summary:"Value is required.",detail:"Enter a value."}},"oj-ojEditableValue":{loading:"Loading",requiredText:"Required"},"oj-ojInputDate":{done:"Done",cancel:"Cancel",prevText:"Previous",nextText:"Next",currentText:"Today",weekHeader:"Wk",tooltipCalendar:"Select Date.",tooltipCalendarTime:"Select Date Time.",tooltipCalendarDisabled:"Select Date Disabled.",tooltipCalendarTimeDisabled:"Select Date Time Disabled.",picker:"Picker",weekText:"Week",datePicker:"Date Picker",inputHelp:"Press Key down or Key up for access to Calendar.",inputHelpBoth:"Press Key down or Key up for access to Calendar and Shift + Key down or Shift Key up for access to time drop down.",dateTimeRange:{hint:{min:"",max:"",inRange:""},messageDetail:{rangeUnderflow:"",rangeOverflow:""},messageSummary:{rangeUnderflow:"",rangeOverflow:""}},dateRestriction:{hint:"",messageSummary:"",messageDetail:""}},"oj-ojInputTime":{cancelText:"Cancel",okText:"OK",currentTimeText:"Now",hourWheelLabel:"Hour",minuteWheelLabel:"Minute",ampmWheelLabel:"AMPM",tooltipTime:"Select Time.",tooltipTimeDisabled:"Select Time Disabled.",inputHelp:"Press Key down or Key up for access to time drop down.",dateTimeRange:{hint:{min:"",max:"",inRange:""},messageDetail:{rangeUnderflow:"",rangeOverflow:""},messageSummary:{rangeUnderflow:"",rangeOverflow:""}}},"oj-inputBase":{required:{hint:"",messageSummary:"",messageDetail:""},regexp:{messageSummary:"",messageDetail:""},accessibleMaxLengthExceeded:"Maximum length {len} exceeded.",accessibleMaxLengthRemaining:"{chars} characters left."},"oj-ojInputPassword":{regexp:{messageDetail:"Value must match this pattern: '{pattern}'."}},"oj-ojFilmStrip":{labelAccFilmStrip:"Displaying page {pageIndex} of {pageCount}",labelAccArrowNextPage:"Select Next to display next page",labelAccArrowPreviousPage:"Select Previous to display previous page",tipArrowNextPage:"Next",tipArrowPreviousPage:"Previous"},"oj-ojDataGrid":{accessibleSortAscending:"{id} sorted in ascending order",accessibleSortDescending:"{id} sorted in descending order",accessibleActionableMode:"Enter actionable mode.",accessibleNavigationMode:"Enter navigation mode, press F2 to enter edit or actionable mode.",accessibleEditableMode:"Enter editable mode, press escape to navigate outside the data grid.",accessibleSummaryExact:"This is a data grid with {rownum} rows and {colnum} columns",accessibleSummaryEstimate:"This is a data grid with unknown number of rows and columns",accessibleSummaryExpanded:"There are currently {num} rows expanded",accessibleRowExpanded:"Row expanded",accessibleRowCollapsed:"Row collapsed",accessibleRowSelected:"Row {row} selected",accessibleColumnSelected:"Column {column} selected",accessibleStateSelected:"selected",accessibleMultiCellSelected:"{num} cells selected",accessibleColumnSpanContext:"{extent} wide",accessibleRowSpanContext:"{extent} high",accessibleRowContext:"Row {index}",accessibleColumnContext:"Column {index}",accessibleRowHeaderContext:"Row Header {index}",accessibleColumnHeaderContext:"Column Header {index}",accessibleRowEndHeaderContext:"Row End Header {index}",accessibleColumnEndHeaderContext:"Column End Header {index}",accessibleRowHeaderLabelContext:"Row Header Label {level}",accessibleColumnHeaderLabelContext:"Column Header Label {level}",accessibleRowEndHeaderLabelContext:"Row End Header Label {level}",accessibleColumnEndHeaderLabelContext:"Column End Header Label {level}",accessibleLevelContext:"Level {level}",accessibleRangeSelectModeOn:"Add selected range of cells mode on.",accessibleRangeSelectModeOff:"Add selected range of cells mode off.",accessibleFirstRow:"You have reached the first row.",accessibleLastRow:"You have reached the last row.",accessibleFirstColumn:"You have reached the first column",accessibleLastColumn:"You have reached the last column.",accessibleSelectionAffordanceTop:"Top selection handle.",accessibleSelectionAffordanceBottom:"Bottom selection handle.",msgFetchingData:"Fetching Data...",msgNoData:"No items to display.",labelResize:"Resize",labelResizeWidth:"Resize Width",labelResizeHeight:"Resize Height",labelSortRow:"Sort Row",labelSortRowAsc:"Sort Row Ascending",labelSortRowDsc:"Sort Row Descending",labelSortCol:"Sort Column",labelSortColAsc:"Sort Column Ascending",labelSortColDsc:"Sort Column Descending",labelCut:"Cut",labelPaste:"Paste",labelEnableNonContiguous:"Enable Non-Contiguous Selection",labelDisableNonContiguous:"Disable Non-Contiguous Selection",labelResizeDialogSubmit:"OK",labelResizeDialogCancel:"Cancel"},"oj-ojRowExpander":{accessibleLevelDescription:"Level {level}",accessibleRowDescription:"Level {level}, Row {num} of {total}",accessibleRowExpanded:"Row expanded",accessibleRowCollapsed:"Row collapsed",accessibleStateExpanded:"expanded",accessibleStateCollapsed:"collapsed"},"oj-ojListView":{msgFetchingData:"Fetching Data...",msgNoData:"No items to display.",msgItemsAppended:"{count} items appended to the end.",indexerCharacters:"A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z",accessibleReorderTouchInstructionText:"Double tap and hold.  Wait for the sound then drag to rearrange.",accessibleReorderBeforeItem:"Before {item}",accessibleReorderAfterItem:"After {item}",accessibleReorderInsideItem:"Into {item}",accessibleNavigateSkipItems:"Skipping {numSkip} items",labelCut:"Cut",labelCopy:"Copy",labelPaste:"Paste",labelPasteBefore:"Paste Before",labelPasteAfter:"Paste After"},"oj-_ojLabel":{tooltipHelp:"Help",tooltipRequired:"Required"},"oj-ojLabel":{tooltipHelp:"Help",tooltipRequired:"Required"},"oj-ojInputNumber":{required:{hint:"",messageSummary:"",messageDetail:""},numberRange:{hint:{min:"",max:"",inRange:"",exact:""},messageDetail:{rangeUnderflow:"",rangeOverflow:"",exact:""},messageSummary:{rangeUnderflow:"",rangeOverflow:""}},tooltipDecrement:"Decrement",tooltipIncrement:"Increment"},"oj-ojTable":{accessibleColumnContext:"Column {index}",accessibleColumnHeaderContext:"Column Header {index}",accessibleRowContext:"Row {index}",accessibleSortAscending:"{id} sorted in ascending order",accessibleSortDescending:"{id} sorted in descending order",accessibleStateSelected:"selected",labelAccSelectionAffordanceTop:"Top selection handle",labelAccSelectionAffordanceBottom:"Bottom selection handle",labelEnableNonContiguousSelection:"Enable Non-Contiguous Selection",labelDisableNonContiguousSelection:"Disable Non-Contiguous Selection",labelResize:"Resize",labelResizePopupSubmit:"OK",labelResizePopupCancel:"Cancel",labelResizePopupSpinner:"Resize Column",labelSelectRow:"Select Row",labelEditRow:"Edit Row",labelSelectAndEditRow:"Select And Edit Row",labelSelectColumn:"Select Column",labelSort:"Sort",labelSortAsc:"Sort Ascending",labelSortDsc:"Sort Descending",msgFetchingData:"Fetching Data...",msgNoData:"No data to display.",msgInitializing:"Initializing...",msgColumnResizeWidthValidation:"Width value must be an integer.",msgScrollPolicyMaxCountSummary:"Exceeded maximum rows for table scrolling.",msgScrollPolicyMaxCountDetail:"Please reload with smaller data set.",msgStatusSortAscending:"{0} sorted in ascending order.",msgStatusSortDescending:"{0} sorted in descending order."},"oj-ojTabs":{labelCut:"Cut",labelPasteBefore:"Paste Before",labelPasteAfter:"Paste After",labelRemove:"Remove",labelReorder:"Reorder",removeCueText:"Removable"},"oj-ojCheckboxset":{readonlyNoValue:"",required:{hint:"",messageSummary:"",messageDetail:""}},"oj-ojRadioset":{readonlyNoValue:"",required:{hint:"",messageSummary:"",messageDetail:""}},"oj-ojSelect":{required:{hint:"",messageSummary:"",messageDetail:""},searchField:"Search field",noMatchesFound:"No matches found",oneMatchesFound:"One match found",moreMatchesFound:"{num} matches found",filterFurther:"More results available, please filter further."},"oj-ojSwitch":{SwitchON:"On",SwitchOFF:"Off"},"oj-ojCombobox":{required:{hint:"",messageSummary:"",messageDetail:""},noMatchesFound:"No matches found",oneMatchesFound:"One match found",moreMatchesFound:"{num} matches found",filterFurther:"More results available, please filter further."},"oj-ojSelectSingle":{required:{hint:"",messageSummary:"",messageDetail:""},noMatchesFound:"No matches found",oneMatchFound:"One match found",multipleMatchesFound:"{num} matches found",nOrMoreMatchesFound:"{num} or more matches found",cancel:"Cancel",labelAccOpenDropdown:"expand",labelAccClearValue:"clear value",noResultsLine1:"No results found",noResultsLine2:"We can't find anything matching your search."},"oj-ojInputSearch":{required:{hint:"",messageSummary:"",messageDetail:""},noMatchesFound:"No matches found",oneMatchesFound:"One match found",moreMatchesFound:"{num} matches found"},"oj-ojTree":{stateLoading:"Loading...",labelNewNode:"New Node",labelMultiSelection:"Multiple Selection",labelEdit:"Edit",labelCreate:"Create",labelCut:"Cut",labelCopy:"Copy",labelPaste:"Paste",labelPasteAfter:"Paste After",labelPasteBefore:"Paste Before",labelRemove:"Remove",labelRename:"Rename",labelNoData:"No data"},"oj-ojPagingControl":{labelAccPaging:"Pagination",labelAccPageNumber:"Page {pageNum} content loaded",labelAccNavFirstPage:"First Page",labelAccNavLastPage:"Last Page",labelAccNavNextPage:"Next Page",labelAccNavPreviousPage:"Previous Page",labelAccNavPage:"Page",labelLoadMore:"Show More...",labelLoadMoreMaxRows:"Reached Maximum Limit of {maxRows} rows",labelNavInputPage:"Page",labelNavInputPageMax:"of {pageMax}",fullMsgItemRange:"{pageFrom}-{pageTo} of {pageMax} items",fullMsgItemRangeAtLeast:"{pageFrom}-{pageTo} of at least {pageMax} items",fullMsgItemRangeApprox:"{pageFrom}-{pageTo} of approx {pageMax} items",msgItemRangeNoTotal:"{pageFrom}-{pageTo} items",fullMsgItem:"{pageTo} of {pageMax} items",fullMsgItemAtLeast:"{pageTo} of at least {pageMax} items",fullMsgItemApprox:"{pageTo} of approx {pageMax} items",msgItemNoTotal:"{pageTo} items",msgItemRangeCurrent:"{pageFrom}-{pageTo}",msgItemRangeCurrentSingle:"{pageFrom}",msgItemRangeOf:"of",msgItemRangeOfAtLeast:"of at least",msgItemRangeOfApprox:"of approx.",msgItemRangeItems:"items",tipNavInputPage:"Go To Page",tipNavPageLink:"Go To Page {pageNum}",tipNavNextPage:"Next",tipNavPreviousPage:"Previous",tipNavFirstPage:"First",tipNavLastPage:"Last",pageInvalid:{summary:"The page value entered is invalid.",detail:"Please enter a value greater than 0."},maxPageLinksInvalid:{summary:"Value for maxPageLinks is invalid.",detail:"Please enter a value greater than 4."}},"oj-ojMasonryLayout":{labelCut:"Cut",labelPasteBefore:"Paste Before",labelPasteAfter:"Paste After"},"oj-panel":{labelAccButtonExpand:"Expand",labelAccButtonCollapse:"Collapse",labelAccButtonRemove:"Remove",labelAccFlipForward:"Flip forward",labelAccFlipBack:"Flip back",tipDragToReorder:"Drag to reorder",labelAccDragToReorder:"Drag to reorder, context menu available"},"oj-ojChart":{labelDefaultGroupName:"Group {0}",labelSeries:"Series",labelGroup:"Group",labelDate:"Date",labelValue:"Value",labelTargetValue:"Target",labelX:"X",labelY:"Y",labelZ:"Z",labelPercentage:"Percentage",labelLow:"Low",labelHigh:"High",labelOpen:"Open",labelClose:"Close",labelVolume:"Volume",labelQ1:"Q1",labelQ2:"Q2",labelQ3:"Q3",labelMin:"Min",labelMax:"Max",labelOther:"Other",tooltipPan:"Pan",tooltipSelect:"Marquee select",tooltipZoom:"Marquee zoom",componentName:"Chart"},"oj-dvtBaseGauge":{componentName:"Gauge"},"oj-ojDiagram":{promotedLink:"{0} link",promotedLinks:"{0} links",promotedLinkAriaDesc:"Indirect",componentName:"Diagram"},"oj-ojGantt":{componentName:"Gantt",accessibleDurationDays:"{0} days",accessibleDurationHours:"{0} hours",accessibleTaskInfo:"Start time is {0}, end time is {1}, duration is {2}",accessibleMilestoneInfo:"Time is {0}",accessibleRowInfo:"Row {0}",accessibleTaskTypeMilestone:"Milestone",accessibleTaskTypeSummary:"Summary",accessiblePredecessorInfo:"{0} predecessors",accessibleSuccessorInfo:"{0} successors",accessibleDependencyInfo:"Dependency type {0}, connects {1} to {2}",startStartDependencyAriaDesc:"start to start",startFinishDependencyAriaDesc:"start to finish",finishStartDependencyAriaDesc:"finish to start",finishFinishDependencyAriaDesc:"finish to finish",tooltipZoomIn:"Zoom In",tooltipZoomOut:"Zoom Out",labelLevel:"Level",labelRow:"Row",labelStart:"Start",labelEnd:"End",labelDate:"Date",labelBaselineStart:"Baseline Start",labelBaselineEnd:"Baseline End",labelBaselineDate:"Baseline Date",labelLabel:"Label",labelProgress:"Progress",labelMoveBy:"Move By",labelResizeBy:"Resize By",taskMoveInitiated:"Task move initiated",taskResizeEndInitiated:"Task resize end initiated",taskResizeStartInitiated:"Task resize start initiated",taskMoveSelectionInfo:"{0} others selected",taskResizeSelectionInfo:"{0} others selected",taskMoveInitiatedInstruction:"Use the arrow keys to move",taskResizeInitiatedInstruction:"Use the arrow keys to resize",taskMoveFinalized:"Task move finalized",taskResizeFinalized:"Task resize finalized",taskMoveCancelled:"Task move cancelled",taskResizeCancelled:"Task resize cancelled",taskResizeStartHandle:"Task resize start handle",taskResizeEndHandle:"Task resize end handle"},"oj-ojLegend":{componentName:"Legend",tooltipExpand:"Expand",tooltipCollapse:"Collapse"},"oj-ojNBox":{highlightedCount:"{0}/{1}",labelOther:"Other",labelGroup:"Group",labelSize:"Size",labelAdditionalData:"Additional Data",componentName:"{0} Box"},"oj-ojPictoChart":{componentName:"Picture Chart"},"oj-ojSparkChart":{componentName:"Chart"},"oj-ojSunburst":{labelColor:"Color",labelSize:"Size",tooltipExpand:"Expand",tooltipCollapse:"Collapse",componentName:"Sunburst"},"oj-ojTagCloud":{componentName:"Tag Cloud"},"oj-ojThematicMap":{componentName:"Thematic Map",areasRegion:"Areas",linksRegion:"Links",markersRegion:"Markers"},"oj-ojTimeAxis":{componentName:"Time Axis"},"oj-ojTimeline":{componentName:"Timeline",accessibleItemDesc:"Description is {0}.",accessibleItemEnd:"End time is {0}.",accessibleItemStart:"Start time is {0}.",accessibleItemTitle:"Title is {0}.",labelSeries:"Series",tooltipZoomIn:"Zoom In",tooltipZoomOut:"Zoom Out",labelStart:"Start",labelEnd:"End",labelDate:"Date",labelTitle:"Title",labelDescription:"Description"},"oj-ojTreemap":{labelColor:"Color",labelSize:"Size",tooltipIsolate:"Isolate",tooltipRestore:"Restore",componentName:"Treemap"},"oj-dvtBaseComponent":{labelScalingSuffixThousand:"K",labelScalingSuffixMillion:"M",labelScalingSuffixBillion:"B",labelScalingSuffixTrillion:"T",labelScalingSuffixQuadrillion:"Q",labelInvalidData:"Invalid data",labelNoData:"No data to display",labelClearSelection:"Clear Selection",labelDataVisualization:"Data Visualization",stateSelected:"Selected",stateUnselected:"Unselected",stateMaximized:"Maximized",stateMinimized:"Minimized",stateExpanded:"Expanded",stateCollapsed:"Collapsed",stateIsolated:"Isolated",stateHidden:"Hidden",stateVisible:"Visible",stateDrillable:"Drillable",labelAndValue:"{0}: {1}",labelCountWithTotal:"{0} of {1}"},"oj-ojNavigationList":{defaultRootLabel:"Navigation List",hierMenuBtnLabel:"Hierarchical Menu button",selectedLabel:"selected",previousIcon:"Previous",msgFetchingData:"Fetching Data...",msgNoData:"No items to display.",overflowItemLabel:"More",accessibleReorderTouchInstructionText:"Double tap and hold.  Wait for the sound then drag to rearrange.",accessibleReorderBeforeItem:"Before {item}",accessibleReorderAfterItem:"After {item}",labelCut:"Cut",labelPasteBefore:"Paste Before",labelPasteAfter:"Paste After",labelRemove:"Remove",removeCueText:"Removable"},"oj-ojSlider":{noValue:"ojSlider has no value",maxMin:"Max must not be less than or equal to min",startEnd:"value.start must not be greater than value.end",valueRange:"Value must be within min to max range",optionNum:"{option} option is not a number",invalidStep:"Invalid step; step must be > 0"},"oj-ojDialog":{labelCloseIcon:"Close"},"oj-ojPopup":{ariaLiveRegionInitialFocusFirstFocusable:"Entering pop-up. Press F6 to navigate between the pop-up and associated control.",ariaLiveRegionInitialFocusNone:"Pop-up opened. Press F6 to navigate between the pop-up and associated control.",ariaLiveRegionInitialFocusFirstFocusableTouch:"Entering pop-up. Pop-up can be closed by navigating to the last link within the pop-up.",ariaLiveRegionInitialFocusNoneTouch:"Pop-up opened. Navigate to the next link to establish focus within the pop-up.",ariaFocusSkipLink:"Double tap to navigate to the open pop-up.",ariaCloseSkipLink:"Double tap to close the open pop-up."},"oj-ojRefresher":{ariaRefreshLink:"Activate link to refresh content",ariaRefreshingLink:"Refreshing content",ariaRefreshCompleteLink:"Refresh complete"},"oj-ojSwipeActions":{ariaShowStartActionsDescription:"Show start actions",ariaShowEndActionsDescription:"Show end actions",ariaHideActionsDescription:"Hide actions"},"oj-ojIndexer":{indexerCharacters:"A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z",indexerOthers:"#",ariaDisabledLabel:"No matching group header",ariaOthersLabel:"number",ariaInBetweenText:"Between {first} and {second}",ariaKeyboardInstructionText:"Press enter to select value.",ariaTouchInstructionText:"Double tap and hold to enter gesture mode, then drag up or down to adjust value."},"oj-ojMenu":{labelCancel:"Cancel",ariaFocusSkipLink:"Focus is within the menu, double tap or swipe to move focus to the first menu item."},"oj-ojColorSpectrum":{labelHue:"Hue",labelOpacity:"Opacity",labelSatLum:"Saturation/Luminance",labelThumbDesc:"Color spectrum four way slider."},"oj-ojColorPalette":{labelNone:"None"},"oj-ojColorPicker":{labelSwatches:"Swatches",labelCustomColors:"Custom Colors",labelPrevColor:"Previous Color",labelDefColor:"Default Color",labelDelete:"Delete",labelDeleteQ:"Delete?",labelAdd:"Add",labelAddColor:"Add color",labelMenuHex:"HEX",labelMenuRgba:"RGBa",labelMenuHsla:"HSLa",labelSliderHue:"Hue",labelSliderSaturation:"Saturation",labelSliderSat:"Sat",labelSliderLightness:"Lightness",labelSliderLum:"Luminosity",labelSliderAlpha:"Alpha",labelOpacity:"Opacity",labelSliderRed:"Red",labelSliderGreen:"Green",labelSliderBlue:"Blue"},"oj-ojFilePicker":{dropzoneText:"Drop files here or click to upload",singleFileUploadError:"Upload one file at a time.",singleFileTypeUploadError:"You can't upload files of type {fileType}.",multipleFileTypeUploadError:"You can't upload files of type: {fileTypes}.",dropzonePrimaryText:"Drag and Drop",secondaryDropzoneText:"Select a file or drop one here.",secondaryDropzoneTextMultiple:"Select or drop files here.",unknownFileType:"unknown"},"oj-ojProgressbar":{ariaIndeterminateProgressText:"In Progress"},"oj-ojMessage":{labelCloseIcon:"Close",categories:{error:"Error",warning:"Warning",info:"Information",confirmation:"Confirmation"}},"oj-ojSelector":{checkboxAriaLabel:"Checkbox Select {rowKey}"},"oj-ojMessages":{labelLandmark:"Messages",ariaLiveRegion:{navigationFromKeyboard:"Entering messages region. Press F6 to navigate back to prior focused element.",navigationToTouch:"Messages region has new messages. Use the voice-over rotor to navigate to the messages landmark.",navigationToKeyboard:"Messages region has new messages.  Press F6 to navigate to the most recent message region.",newMessage:"Message category {category}. {summary}. {detail}."}}},ar:1,"ar-XB":1,cs:1,da:1,de:1,el:1,"en-XA":1,"en-XC":1,es:1,et:1,fi:1,fr:1,"fr-CA":1,he:1,hr:1,hu:1,is:1,it:1,ja:1,ko:1,lt:1,lv:1,nl:1,no:1,pl:1,pseudo:1,pt:1,"pt-PT":1,ro:1,ru:1,sk:1,sl:1,sr:1,"sr-Latn":1,sv:1,th:1,tr:1,"zh-Hans":1,"zh-Hant":1});

/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

//although Config has a direct dependency on oj.LocaleData and oj.TimezoneData we will not list 
// these direct dependencies here because of circulare reference error. 
// The oj.LocaleData and oj.TimezoneData dependencies are tested in the code
// if they exist. We purposely leave them out for two reasons: one is they have a circular reference,
// and another is to not incur the download cost if the code doesn't need them.
define('ojs/ojconfig',['require','ojs/ojcore-base', 'ojL10n!ojtranslations/nls/ojtranslations'  ], function(require, oj, ojt)
{
  "use strict";


/* jslint browser: true*/

/* global ojt:true, Promise:false */

/**
 * @namespace oj.Config
 * @hideconstructor
 * @classdesc Services for setting and retrieving configuration options
 * @since 1.0
 * @ojtsmodule
 * @export
 * @ojtsimport {module: "ojcspexpressionevaluator", type: "AMD", importName: "CspExpressionEvaluator"}
 */
var Config = {};
/**
 * Retrieves the render mode the application should use.  This allows the application to render content
 * differently based on the type of device.
 * <p>By default, this function returns the value from getDeviceType.</p>
 * <p>An application can override it by adding a "data-oj-device-render-mode" attribute with the desired value
 * to the document body.  This may be useful in simulating the look of one device type on a different device type,
 * such as simulating the look of "phone" on a destop computer.</p>
 *
 * @memberof oj.Config
 * @method getDeviceRenderMode
 * @return {"phone" | "tablet" | "others"} The render mode
 * @export
 */

Config.getDeviceRenderMode = function () {
  return document.body.getAttribute('data-oj-device-render-mode') || Config.getDeviceType();
};
/**
 * Retrieves the type of device the application is running on.  This allows the application to behave
 * differently based on the type of device.
 * <p>This function always return the actual device type.  Use getDeviceRenderMode if the application wants
 * to render content differently based on the device type, including simulated device type.</p>
 *
 * @memberof oj.Config
 * @method getDeviceType
 * @return {"phone" | "tablet" | "others"} The device type
 * @export
 */


Config.getDeviceType = function () {
  return oj.AgentUtils.getAgentInfo().deviceType;
};
/**
 * Retrieves the current locale
 * @memberof oj.Config
 * @method getLocale
 * @return {string} current locale
 * @export
 */


Config.getLocale = function () {
  if (oj.__isAmdLoaderPresent()) {
    oj.Assert.assert(typeof ojt !== 'undefined', 'ojtranslations module must be defined');
    var rl = ojt._ojLocale_; // If Require.js internationalziation plugin resolved the locale to "root" (presumably because "lang" attribute was not
    // set, and neither navigator.language or navigator.userLanguage were not available), return "en"

    return rl === 'root' ? 'en' : rl;
  }

  var loc = Config._locale;

  if (loc == null) {
    loc = document.documentElement.lang;

    if (!loc) {
      loc = navigator === undefined ? 'en' : (navigator.language || navigator.userLanguage || 'en').toLowerCase();
    }

    loc = loc.toLowerCase();
    Config._locale = loc;
  }

  return loc;
};
/**
 * Changes the current locale
 * @method setLocale
 * @param {string} locale (language code and subtags separated by dash)
 * @param {function(): void} [callback] - for applications running with an AMD Loader (such as Require.js), this optional callback
 * will be invoked when the framework is done loading its translated resources and Locale Elements for the newly specified locale.
 * For applications running without an AMD loader, this optional callback will be invoked immediately
 * @return {undefined}
 * @export
 * @memberof oj.Config
 */


Config.setLocale = function (locale, callback) {
  if (oj.__isAmdLoaderPresent()) {
    var prefix = 'ojL10n!ojtranslations/nls/';
    var requestedBundles = [prefix + locale + '/ojtranslations'];
    var timezoneBundleCount = 0; // Request LocaleElements only if the ojs/ojlocaledata module is loaded;
    // oj.LocaleData will exist in that case.
    // Validators/Converters that need locale data import ojs/ojlocaledata
    // themselves.
    // If you're just using Config.setLocale to change your
    // translation bundle, this code will do that without
    // incurring the download hit of the ojs/ojlocaledata module.

    if (oj.LocaleData) {
      requestedBundles.push(prefix + locale + '/localeElements');

      if (oj.TimezoneData) {
        var tzBundles = oj.TimezoneData.__getBundleNames();

        timezoneBundleCount = tzBundles.length;
        tzBundles.forEach(function (bundle) {
          requestedBundles.push(prefix + locale + bundle);
        });
      }
    } // eslint-disable-next-line global-require


    require(
    /* ojWebpackError: 'oj.Config.setLocale() is not supported when the ojs/ojcore module has been bundled by Webpack' */
    requestedBundles, function (translations, localeElements) {
      ojt = translations;

      if (localeElements) {
        oj.LocaleData.__updateBundle(localeElements);
      }

      for (var i = 0; i < timezoneBundleCount; i++) {
        var tzBundle = arguments[i + 2];

        oj.TimezoneData.__mergeIntoLocaleElements(tzBundle);
      }

      if (callback) {
        callback();
      }
    });
  } else {
    Config._locale = locale;

    if (callback) {
      callback();
    }
  }
};
/**
 * Retrieves a URL for loading a component-specific resource.
 * The URL is resolved as follows:
 * 1. If the application has specified a base URL with setResourceBaseUrl(), the return values will be
 * a relative path appended to the base URL.
 * 2. Otherwise, if the application running with an AMD Loader (such as Require.js), the parent folder of a
 * module with ojs/ mapping will be used as a base URL.
 * 3. Otherwise, the original relative path will be returned.
 * @method getResourceUrl
 * @param {string} relativePath resource path
 * @return {string} resource URL
 * @see oj.Config.setResourceBaseUrl
 * @export
 * @memberof oj.Config
 */


Config.getResourceUrl = function (relativePath) {
  // Returning null and full URLs (containing protocol or a leading slash) as is
  var fullUrlExp = /^\/|:/;

  if (relativePath == null || fullUrlExp.test(relativePath)) {
    return relativePath;
  }

  var base = Config._resourceBaseUrl;

  if (base == null) {
    base = Config._getOjBaseUrl() || '';
  }

  var len = base.length;
  return base + (len === 0 || base.charAt(len - 1) === '/' ? '' : '/') + relativePath;
};
/**
 * Sets the base URL for retrieving component-specific resources
 * @method setResourceBaseUrl
 * @param {string} baseUrl base URL
 * @return {undefined}
 * @see oj.Config.getResourceUrl
 * @export
 * @memberof oj.Config
 */


Config.setResourceBaseUrl = function (baseUrl) {
  Config._resourceBaseUrl = baseUrl;
};
/**
 * Sets the automation mode.
 * @method setAutomationMode
 * @param {string} mode "enabled" for running in automation mode
 * @return {undefined}
 * @see oj.Config.getAutomationMode
 * @export
 * @memberof oj.Config
 */


Config.setAutomationMode = function (mode) {
  Config._automationMode = mode;
};
/**
 * Gets the automation mode.
 * @method getAutomationMode
 * @return {string} automation mode
 * @see oj.Config.setAutomationMode
 * @export
 * @memberof oj.Config
 */


Config.getAutomationMode = function () {
  return Config._automationMode;
};
/**
 * Return a string containing important version information about JET and the libraries
 * it has loaded
 * @method getVersionInfo
 * @return {string}
 * @export
 * @memberof oj.Config
 */


Config.getVersionInfo = function () {
  // JET information
  var info = 'Oracle JET Version: ' + oj.version + '\n';
  info += 'Oracle JET Revision: ' + oj.revision + '\n';
  var windowDefined = typeof window !== 'undefined'; // Browser information

  if (windowDefined && window.navigator) {
    info += 'Browser: ' + window.navigator.userAgent + '\n';
    info += 'Browser Platform: ' + window.navigator.platform + '\n';
  } // 3rd party libraries


  if ($) {
    if ($.fn) {
      info += 'jQuery Version: ' + $.fn.jquery + '\n';
    }

    if ($.ui && $.ui.version) {
      info += 'jQuery UI Version: ' + $.ui.version + '\n';
    }
  }

  if (oj.ComponentBinding) {
    info += 'Knockout Version: ' + oj.ComponentBinding.__getKnockoutVersion() + '\n';
  } // Local require doesn't have version #


  if (windowDefined && window.require) {
    info += 'Require Version: ' + window.require.version + '\n';
  }

  return info;
};
/**
 * Dump information to the browser's console containing important version information about JET and
 * the libraries it has loaded
 * @method logVersionInfo
 * @return {undefined}
 * @memberof oj.Config
 * @export
 */


Config.logVersionInfo = function () {};
/**
 * This method gets replaced by JET's Webpack plugin to return the value provided as baseResourceUrl in the
 * config for the plugin
 * @private
 * @ignore
 */


Config._getOjBaseUrl = function () {
  var base = null;

  if (oj.__isAmdLoaderPresent()) {
    // : use ojs/_foo_ instead of ojs/ojcore to handle the case when ojs.core ends up in a partition bundle
    // in a different location
    var modulePath = require.toUrl('ojs/_foo_');

    base = modulePath.replace(/[^/]*$/, '../');
  }

  return base;
};
/**
 * Retrives JET's template engine for dealing with inline templates (currently internal only)
 * @ignore
 * @memberof oj.Config
 * @private
 */


Config.__getTemplateEngine = function () {
  if (!Config._templateEnginePromise) {
    if (!oj.__isAmdLoaderPresent()) {
      throw new Error('JET Template engine cannot be loaded with an AMD loader');
    }

    Config._templateEnginePromise = new Promise(function (resolve, reject) {
      // eslint-disable-next-line global-require
      require(['./ojtemplateengine'], resolve, reject);
    });
  }

  return Config._templateEnginePromise;
};
/**
 * Returns ojtranslation module. Called by oj.Translations, in this way we can make sure that the ojtranslation module
 * instance is shared between Config and Translations.
 * @ignore
 * @memberof oj.Config
 * @private
 */


Config.getConfigBundle = function () {
  return ojt;
};
/**
 * Returns expression evaluator
 * @return {undefined | Object}
 * @ignore
 * @export
 * @memberof oj.Config
 * @since 7.1.0
 */


Config.getExpressionEvaluator = function () {
  return Config._expressionEvaluator;
};
/**
 * Sets an optional CSP-compliant expression evaluator for the JET binding provider and JET ExpressionUtils.
 * This method can only be called once and must be called before applying
 * knockout bindings in the application for the first time.
 * @see <a href="oj.CspExpressionEvaluator.html">CspExpressionEvaluator</a>
 * @method setExpressionEvaluator
 * @param {Object} expressionEvaluator An instance of CspExpressionEvaluator class
 * @return {undefined}
 * @memberof oj.Config
 * @ojshortdesc Sets a CSP-compliant expression evaluator.
 * @export
 * @ojsignature {target:"Type", value: "oj.CspExpressionEvaluator", for: "expressionEvaluator"}
 * @since 7.1.0
 */


Config.setExpressionEvaluator = function (expressionEvaluator) {
  if (Config._expressionEvaluator) {
    throw new Error("JET Expression evaluator can't be set more than once.");
  }

  Config._expressionEvaluator = expressionEvaluator;
};

;return Config;
});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojresponsiveutils',['ojs/ojlogger'], function(Logger)
{
  "use strict";


/* jslint browser: true*/

/* global Logger:false */

/**
 * @namespace oj.ResponsiveUtils
 * @classdesc Utilities for working with the framework's responsive screen widths
 * and ranges. Often used in conjunction with {@link oj.ResponsiveKnockoutUtils}
 * to create knockout observables that can be used to drive responsive page behavior.
 * See the method doc below for specific examples.
 * @ojtsmodule
 * @since 1.1.0
 * @hideconstructor
 * @export
 */
var ResponsiveUtils = function ResponsiveUtils() {};
/**
 * <p>In the jet sass files there are variables for
 * responsive screen widths, these look something like</p>
 *  <ul>
 *    <li>$screenSmallRange:  0, 767px;</li>
 *    <li>$screenMediumRange: 768px, 1023px;</li>
 *    <li>$screenLargeRange:  1024px, 1280px;</li>
 *    <li>$screenXlargeRange: 1281px, null;</li>
 *  </ul>
 *
 * <p>These constants are used to identify these ranges.</p>
 * @enum {string}
 * @memberof oj.ResponsiveUtils
 * @alias SCREEN_RANGE
 * @constant
 * @export
 */


ResponsiveUtils.SCREEN_RANGE = {
  /**
   * @expose
   * @constant
   */
  SM: 'sm',

  /**
   * @expose
   * @constant
   */
  MD: 'md',

  /**
   * @expose
   * @constant
   */
  LG: 'lg',

  /**
   * @expose
   * @constant
   */
  XL: 'xl',

  /**
   * @expose
   * @constant
   */
  XXL: 'xxl'
};
/**
 * <p>In the jet sass files there are variables for
 * responsive screen widths,
 * see {@link oj.ResponsiveUtils.SCREEN_RANGE} for details.
 * The jet sass files also has variables for
 * responsive queries like $responsiveQuerySmallUp,
 * $responsiveQuerySmallOnly, $responsiveQueryMediumUp, etc.</p>
 *
 * <p>These constants are used to identify these queries.</p>
 * @enum {string}
 * @memberof oj.ResponsiveUtils
 * @alias FRAMEWORK_QUERY_KEY
 * @constant
 * @export
 */

ResponsiveUtils.FRAMEWORK_QUERY_KEY = {
  /**
   * Matches screen width small and wider
   * @expose
   * @constant
   */
  SM_UP: 'sm-up',

  /**
   * matches screen width medium and wider
   * @expose
   * @constant
   */
  MD_UP: 'md-up',

  /**
   * matches screen width large and wider
   * @expose
   * @constant
   */
  LG_UP: 'lg-up',

  /**
   * matches screen width extra-large and wider
   * @expose
   * @constant
   */
  XL_UP: 'xl-up',

  /**
   * matches screen width extra-extra-large and wider
   * @expose
   * @constant
   */
  XXL_UP: 'xxl-up',

  /**
   * matches screen width small only
   * @expose
   * @constant
   */
  SM_ONLY: 'sm-only',

  /**
   * matches screen width medium only
   * @expose
   * @constant
   */
  MD_ONLY: 'md-only',

  /**
   * matches screen width large only
   * @expose
   * @constant
   */
  LG_ONLY: 'lg-only',

  /**
   * matches screen width extra-large only
   * @expose
   * @constant
   */
  XL_ONLY: 'xl-only',

  /**
   * matches screen width medium and narrower
   * @expose
   * @constant
   */
  MD_DOWN: 'md-down',

  /**
   * matches screen width large and narrower
   * @expose
   * @constant
   */
  LG_DOWN: 'lg-down',

  /**
   * matches screen width extra-large and narrower
   * @expose
   * @constant
   */
  XL_DOWN: 'xl-down',

  /**
   * matches high resolution screens
   * @expose
   * @constant
   */
  HIGH_RESOLUTION: 'high-resolution'
}; // used by the compare function

ResponsiveUtils._RANGE = {};
ResponsiveUtils._RANGE[ResponsiveUtils.SCREEN_RANGE.SM] = 0;
ResponsiveUtils._RANGE[ResponsiveUtils.SCREEN_RANGE.MD] = 1;
ResponsiveUtils._RANGE[ResponsiveUtils.SCREEN_RANGE.LG] = 2;
ResponsiveUtils._RANGE[ResponsiveUtils.SCREEN_RANGE.XL] = 3;
ResponsiveUtils._RANGE[ResponsiveUtils.SCREEN_RANGE.XXL] = 4;
/**
 * This idea/code is from zurb foundation, thanks zurb!
 *
 * In the jet sass files there are variables for
 * responsive screen sizes, these look something like

 *  <ul>
 *    <li>$screenSmallRange:  0, 767px;</li>
 *    <li>$screenMediumRange: 768px, 1023px;</li>
 *    <li>$screenLargeRange:  1024px, 1280px;</li>
 *    <li>$screenXlargeRange: 1281px, null;</li>
 *  </ul>
 *
 * <p>These variables in turn are used to generate responsive media queries in variables like
 * $responsiveQuerySmallUp, $responsiveQueryMediumUp, etc.</p>
 *
 * <p>we send down these media queries as the font family in classes
 * that look something like this:<p>
 *
 * <pre class="prettyprint">
 * <code>
 * .oj-mq-md {
 *    font-family: "/screen and (min-width: 768px)/";
 * }
 * </code></pre>
 *
 * <p>This function applies the class and then reads the font family off a dom
 * element to get the media query string</p>
 *
 * @param {string} selector a class selector name, for example 'oj-mq-md';
 * @return {string} the media query sent down for that class
 * @private
 */

ResponsiveUtils._getMediaQueryFromClass = function (selector) {
  var elem =
  /** @type {(Element | null)} */
  document.getElementsByClassName(selector).item(0);

  if (elem === null) {
    elem = document.createElement('meta');
    elem.className = selector;
    document.head.appendChild(elem); // @HTMLUpdateOK
  }

  var fontFamily = window.getComputedStyle(elem).getPropertyValue('font-family');
  return fontFamily.replace(/^[/\\'"]+|(;\s?})+|[/\\'"]+$/g, '');
};
/**
 * Get a framework (built in) media query string,
 * see {@link oj.ResponsiveUtils.FRAMEWORK_QUERY_KEY} for details on framework queries.
 * The media query string returned can be passed to
 * {@link oj.ResponsiveKnockoutUtils.createMediaQueryObservable} to create a knockout
 * observable, which in turn can be used to drive responsive page behavior.
 *
 * <p>Example:</p>
 * <pre class="prettyprint">
 * <code>
 *
 *     var lgQuery = oj.ResponsiveUtils.getFrameworkQuery(
 *                             oj.ResponsiveUtils.FRAMEWORK_QUERY_KEY.LG_UP);
 *
 *     self.large = oj.ResponsiveKnockoutUtils.createMediaQueryObservable(lgQuery);
 * </code></pre>
 *
 *
 * @method getFrameworkQuery
 * @memberof oj.ResponsiveUtils
 * @param {oj.ResponsiveUtils.FRAMEWORK_QUERY_KEY} frameworkQueryKey one of the FRAMEWORK_QUERY_KEY constants,
 *                       for example oj.ResponsiveUtils.FRAMEWORK_QUERY_KEY.MD_UP
 * @return {string | null} the media query to use for the framework query key passed in
 * @export
 * @static
 */


ResponsiveUtils.getFrameworkQuery = function (frameworkQueryKey) {
  var selector = 'oj-mq-' + frameworkQueryKey;

  var query = ResponsiveUtils._getMediaQueryFromClass(selector);

  if (query === 'null') {
    Logger.warn('Framework query not found. Please check that the value of the theming variable' + '$includeResponsiveMediaQueryClasses is set to true, if it' + 'is set to false the media queries are not sent down to the browser.');
    return null;
  }

  return query;
};
/**
 * <p> Compare can be used in conjunction with
 * {@link oj.ResponsiveKnockoutUtils.createScreenRangeObservable}</p>
 *
 *
 * <p>Example:</p>
 * <pre class="prettyprint">
 * <code>
 *        // create an observable which returns the current screen range
 *        self.screenRange = oj.ResponsiveKnockoutUtils.createScreenRangeObservable();
 *
 *        self.label2 = ko.computed(function() {
 *          var range = self.screenRange();
 *
 *          if ( oj.ResponsiveUtils.compare(
 *                       range, oj.ResponsiveUtils.SCREEN_RANGE.MD) <= 0)
 *          {
 *            // code for when screen is in small or medium range
 *          }
 *          else if (range == oj.ResponsiveUtils.SCREEN_RANGE.XL)
 *          {
 *            // code for when screen is in XL range
 *          }
 *        });
 * </code></pre>
 *
 * @method compare
 * @memberof oj.ResponsiveUtils
 * @param {oj.ResponsiveUtils.SCREEN_RANGE} size1 one of the screen size constants,
 * for example oj.ResponsiveUtils.SCREEN_RANGE.MD
 * @param {oj.ResponsiveUtils.SCREEN_RANGE} size2 one of the screen size constants,
 * for example oj.ResponsiveUtils.SCREEN_RANGE.LG
 * @return {number} a negative integer if the first
 * argument is less than the second. Zero if the two are equal.
 * 1 or greater if the first argument is more than the second.
 *
 * @export
 * @static
 */


ResponsiveUtils.compare = function (size1, size2) {
  var range1 = ResponsiveUtils._RANGE[size1];
  var range2 = ResponsiveUtils._RANGE[size2];

  if (range1 == null) {
    throw new Error('size1 param ' + size1 + ' illegal, please use one of the screen size constants like oj.ResponsiveUtils.SCREEN_RANGE.MD');
  }

  if (range2 == null) {
    throw new Error('size2 param ' + size2 + ' illegal, please use one of the screen size constants like oj.ResponsiveUtils.SCREEN_RANGE.MD');
  }

  return range1 - range2;
};

;return ResponsiveUtils;
});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojthemeutils',['ojs/ojlogger'], function(Logger)
{
  "use strict";


/* jslint browser: true*/

/* global Logger:false */

/**
 * @namespace oj.ThemeUtils
 * @classdesc Services for getting information from the theme
 * @since 1.2.0
 * @ojtsmodule
 * @export
 */
var ThemeUtils = function ThemeUtils() {};
/**
 * get the name of the current theme
 * @method getThemeName
 * @memberof oj.ThemeUtils
 * @export
 * @static
 * @memberof oj.ThemeUtils
 *
 * @return {string|null} the name of the theme
 */


ThemeUtils.getThemeName = function () {
  // get the map of theme info
  var themeMap = ThemeUtils.parseJSONFromFontFamily('oj-theme-json') || {};
  return themeMap.name;
};
/**
 * <p>Get the target platform of the current theme. </p>
 * <p>This API does not look at the user agent and therefore it
 *    tells you nothing about the current platform you are actually on.
 *    Instead it tells you the target platform the theme was written
 *    for so that programmatic behaviors that match the theme's UI can be written.
 *    This can be useful when writing a cross platform hybrid mobile app.  </p>
 *
 * <p>Example</p>
 * <pre class="prettyprint">
 * <code>
 * var themeTargetPlatform = oj.ThemeUtils.getThemeTargetPlatform();
 *
 * if (themeTargetPlatform == 'ios')
 *    // code for a behavior familiar in ios
 * else if (themeTargetPlatform == 'android')
 *    // code for a behavior familiar on android
 * else
 *    // code for the default behavior
 * </code></pre>
 * @export
 * @static
 * @method getThemeTargetPlatform
 * @memberof oj.ThemeUtils
 * @return {string|null} the target platform can be any string the theme
 * wants to send down, but common values are 'all', 'web', 'ios', 'android', 'windows'
 */


ThemeUtils.getThemeTargetPlatform = function () {
  // get the map of theme info
  var themeMap = ThemeUtils.parseJSONFromFontFamily('oj-theme-json') || {};
  return themeMap.targetPlatform;
};
/**
 * clear values cached in  [oj.ThemeUtils.parseJSONFromFontFamily]{@link oj.ThemeUtils.parseJSONFromFontFamily}
 * @export
 * @static
 * @method clearCache
 * @return {void}
 * @memberof oj.ThemeUtils
 */


ThemeUtils.clearCache = function () {
  this._cache = null;
};
/**
 *
 * <p>json can be sent down as the font family in classes
 * that look something like this
 * (on the sass side of things see the file
 * scss/utilities/_oj.utilities.json.scss
 * for information on jet mixins available to generate json):<p>
 *
 * <p>Example CSS</p>
 * <pre class="prettyprint">
 * <code>
 * .demo-map-json {
 *    font-family: '{"foo":"bar", "binky": 4}';
 * }
 *
 * .demo-list-json {
 *    font-family: '["foo","bar","binky"}';
 * }
 * </code></pre>
 * <p>Example Usage</p>
 * <pre class="prettyprint">
 * <code>
 * var mymap = oj.ThemeUtils.parseJSONFromFontFamily("demo-map-json");
 * var myarray = oj.ThemeUtils.parseJSONFromFontFamily("demo-list-json");
 * </code></pre>
 *
 * This function
 * <ul>
 *   <li>Gets the font family string by creating a dom element,
 *      applying the selector passed in, calling getcomputedstyle,
 *      and then reading the value for font-family.
 *   </li>
 *   <li>Parses the font family value by calling JSON.pars.</li>
 *   <li>Caches the parsed value because calling getComputedStyle is a perf hit.
 *       Subsequent requests for the same selector will return the cached value.
 *       Call [oj.ThemeUtils.clearCache]{@link oj.ThemeUtils.clearCache} if new css is loaded.</li>
 *   <li>Return the parsed value.</li>
 * </ul>
 *
 * <p>
 * If new css is loaded call oj.ThemeUtils.clearCache to clear the cache</p>
 *
 * @method parseJSONFromFontFamily
 * @memberof oj.ThemeUtils
 * @param {string} selector a class selector name, for example 'demo-map-json';
 * @return {any} the result of parsing the font family with JSON.parse.
 *      The returned value is cached, so if you modify the returned
 *      value it will be reflected in the cache.
 * @throws {SyntaxError} If JSON.parse throws a SyntaxError exception we will log an error and rethrow
 * @export
 * @static
 */


ThemeUtils.parseJSONFromFontFamily = function (selector) {
  // NOTE: I first tried code inspired by
  // https://css-tricks.com/making-sass-talk-to-javascript-with-json/
  // so I was using :before and content, for example
  //   .oj-button-option-defaults:before {
  //     content: '{"foo":"bar", "binky": 4}';
  //    }
  //
  //  however IE 11 has a bug where the computed style doesn't actually
  //  seem to be computed when it comes to :before,
  //  so if you set a class that affects :before after the page loads
  //  on IE getComputedStyle doesn't work.
  //  See the pen below, the yellow box has the class applied in js,
  //  computedstyle works on chrome, doesn't work on IE11 for
  //  class applied after page load.
  //     http://codepen.io/gabrielle/pen/OVOwev
  // if needed create the cache and initialize some things
  if (this._cache == null) {
    this._cache = {}; // magic value that means null in the cache

    this._null_cache_value = {}; // font family is inherited, so even if no selector/json
    // is sent down we will get a string like
    // 'HelveticaNeue',Helvetica,Arial,sans-serif' off of our generated element.
    // So save off the font family from the head
    // element to compare to what we read off our generated element.

    this._headfontstring = window.getComputedStyle(document.head).getPropertyValue('font-family');
  } // see if we already have a map for this component's option defaults


  var jsonval = this._cache[selector]; // if there's something already cached return it

  if (jsonval === this._null_cache_value) {
    return null;
  } else if (jsonval != null) {
    return jsonval;
  } // there's nothing cached, so we need to create a dom element to apply the class to.
  // We're creating a meta element,
  // the hope is that the browser is smart enough to realize the
  // meta element isn't visible and therefore we avoid perf issues of calling
  // getcomputedstyle


  var elem = document.createElement('meta');
  elem.className = selector;
  document.head.appendChild(elem); // @HTMLUpdateOK

  var rawfontstring = window.getComputedStyle(elem).getPropertyValue('font-family');

  if (rawfontstring != null) {
    // if the raw font string is the same value as the saved header
    // font value then log a warning that no value was sent down.
    if (rawfontstring === this._headfontstring) {
      Logger.warn('parseJSONFromFontFamily: When the selector ', selector, ' is applied the font-family read off the dom element is ', rawfontstring, '. The parent dom elment has the same font-family value.', ' This is interpreted to mean that no value was sent down for selector ', selector, '. Null will be returned.');
    } else {
      // remove inconsistent quotes
      var fontstring = rawfontstring.replace(/^['"]+|\s+|\\|(;\s?})+|['"]$/g, ''); // console.log("json fontstring for selector " + selector + ': ' + fontstring);

      if (fontstring) {
        try {
          jsonval = JSON.parse(fontstring);
        } catch (e) {
          // In Firefox you can turn off the page font
          // Options -> Content -> Fonts and Colors -> Advanced
          // Uncheck the "Allow pages to choose their own fonts, instead of my selections above"
          // In that case they stick something like 'serif,"'at the front of the font family,
          // so search for the first comma, add 2, and try parsing again.
          var commaindex = fontstring.indexOf(',');
          var reparseSuccess = false;

          if (commaindex > -1) {
            fontstring = fontstring.substring(commaindex + 2);

            try {
              jsonval = JSON.parse(fontstring);
              reparseSuccess = true;
            } catch (e2) {// Ignore Error
            }
          }

          if (reparseSuccess === false) {
            Logger.error('Error parsing json for selector ' + selector + '.\nString being parsed is ' + fontstring + '. Error is:\n', e); // remove the meta tag

            document.head.removeChild(elem);
            throw e;
          }
        }
      }
    }
  } // remove the meta tag


  document.head.removeChild(elem); // cache the result

  if (jsonval == null) {
    this._cache[selector] = this._null_cache_value;
  } else {
    this._cache[selector] = jsonval;
  } // console.log(this._cache);


  return jsonval;
};

;return ThemeUtils;
});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojtimerutils',[], function()
{
  "use strict";


/* global Promise:false */

/**
 * Timing related utilities
 * @namespace
 * @name oj.TimerUtils
 * @since 4.1.0
 *
 * @ojtsignore
 */
var TimerUtils = {};
/**
 * A Timer encapsulates a Promise associated with a deferred function execution
 * and the ability to cancel the timer before timeout.
 * @interface Timer
 * @ojtsignore
 */

function Timer() {}
/**
 * Get the Promise assocaited with this timer.  Promise callbacks will be
 * passed a single boolean value indicating if the timer's timeout expired
 * normally (without being canceled/cleared).  If the timer is left to expire
 * after its configured timeout has been exceeded, then it will pass
 * boolean(true) to the callbacks.  If the timer's {@link #clear} method is
 * called before its configured timeout has been reached, then the callbacks
 * will receive boolean(false).
 * @memberof Timer
 * @return {Promise.<boolean>} This timer's Promise
 */


Timer.prototype.getPromise = function () {};
/**
 * Clears the timer and resolves the Promise.  If the normal timeout hasn't
 * yet expired, the value passed to the Promise callbacks will be boolean(false).
 * If the timeout has already expired, this function will do nothing, and all of
 * its Promise callbacks will receive boolean(true).
 * @return {void}
 * @memberof Timer
 */


Timer.prototype.clear = function () {};
/**
 * Get a Timer object with the given timeout in milliseconds.  The Promise
 * associated with the timer is resolved when the timeout window expires, or if
 * the clear() function is called.
 * This is useful for when code needs to be executed on timeout (setTimeout) and
 * must handle cleanup tasks such as clearing {@link BusyState} when the timer
 * expires or is canceled.
 *
 * @param  {number} timeout The timeout value in milliseconds to wait before the
 * promise is resolved.
 * @return {Timer}
 * A Timer object which encapsulates the Promise that will be
 * resolved once the timeout has been exceeded or cleared.
 * @export
 * @memberof oj.TimerUtils
 * @alias getTimer
 * @example <caption>Get a timer to execute code on normal timeout and
 * cancelation.  If the timeout occurs normally (not canceled), both
 * callbacks are executed and the value of the 'completed' parameter will be
 * true.</caption>
 * var timer = oj.TimerUtils.getTimer(1000);
 * timer.getPromise().then(function(completed) {
 *     if (completed) {
 *       // Delayed code
 *     }
 *   })
 * timer.getPromise().then(function() {
 *   // Code always to be run
 * })
 *
 * @example <caption>Get a timer to execute code on normal timeout and cancelation.
 * In this example, the timer is canceled before its timeout expires, and the
 * value of the 'completed' parameter will be false.</caption>
 * var timer = oj.TimerUtils.getTimer(1000);
 * timer.getPromise()
 *   .then(function(completed) {
 *     if (completed) {
 *       // Delayed code
 *     }
 *   })
 * timer.getPromise()
 *   .then(function() {
 *     // Code always to be run
 *   })
 * ...
 * timer.clear(); // timer cleared before timeout expires
 */


TimerUtils.getTimer = function (timeout) {
  return new TimerUtils._TimerImpl(timeout);
};
/**
 * @constructor
 * @implements {Timer}
 * @param  {number} timeout The timeout value in milliseconds.
 * @private
 */


TimerUtils._TimerImpl = function (timeout) {
  var _promise;

  var _resolve;

  var _timerId;

  this.getPromise = function () {
    return _promise;
  };

  this.clear = function () {
    window.clearTimeout(_timerId);
    _timerId = null;

    _timerDone(false);
  };
  /**
   * Called on normal and early timeout (cancelation)
   */


  function _timerDone(completed) {
    _timerId = null;

    _resolve(completed);
  }

  if (typeof window === 'undefined') {
    _promise = Promise.reject();
  } else {
    _promise = new Promise(function (resolve) {
      _resolve = resolve;
      _timerId = window.setTimeout(_timerDone.bind(null, true), timeout); // @HTMLUpdateOK
    });
  }
};

;return TimerUtils;
});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojtranslation',['ojs/ojcore-base', 'ojs/ojconfig'], function(oj, Config)
{
  "use strict";
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }



/* global Config:false */

/**
 * @namespace oj.Translations
 * @classdesc Services for Retrieving Translated Resources
 * @export
 * @since 1.0
 * @ojtsmodule
 * @hideconstructor
 */
var Translations = {};
/**
 * Sets the translation bundle used by JET
 * If an AMD loader (such as Require.js) is not present, this method should be called by the application to provide
 * translated strings for JET.
 * This method may also be used by an application that wants to completely replace the resource bundle that is automatically
 * fetched by an AMD loader.
 * @method setBundle
 * @memberof oj.Translations
 * @param {Object} bundle resource bundle that should be used by the framework
 * @return {void}
 * @export
 */

Translations.setBundle = function (bundle) {
  Translations._bundle = bundle;
};
/**
 * Retrives a translated resource for a given key
 * @method getResource
 * @memberof oj.Translations
 * @param {string} key resource key The dot character (.) within the key string
 * is interpreted as a separator for the name of a sub-section within the bundle.
 * For example, 'components.chart', would be read as the 'chart' section within
 * 'components'. Thus the key name for an individual section should never contain a dot.
 * @return {Object|string|null} resource associated with the key or null if none was found
 * @export
 */


Translations.getResource = function (key) {
  return Translations._getResourceString(key);
};
/**
 * Applies parameters to a format pattern
 * @method applyParameters
 * @memberof oj.Translations
 * @param {string} pattern pattern that may contain tokens like {0}, {1}, {name}. These tokens
 * will be used to define string keys for retrieving values from the parameters
 * object. Token strings should not contain comma (,)
 * or space characters, since they are reserved for future format type enhancements.
 * The reserved characters within a pattern are:
 * $ { } [ ]
 * These characters will not appear in the formatted output unless they are escaped
 * with a dollar character ('$').
 *
 * @param {Object|Array} parameters parameters to be inserted into the string. Both arrays and
 * Javascript objects with string keys are accepted.
 *
 * @return {string|null} formatted message or null if the pattern argument was null
 * @export
 */


Translations.applyParameters = function (pattern, parameters) {
  return pattern == null ? null : Translations._format(pattern, parameters);
};
/**
 * Retrieves a translated string after inserting optional parameters.
 * The method uses a key to retrieve a format pattern from the resource bundle.
 * Tokens like {0}, {1}, {name} within the pattern will be used to define placement
 * for the optional parameters.  Token strings should not contain comma (,)
 * or space characters, since they are reserved for future format type enhancements.
 * The reserved characters within a pattern are:
 * $ { } [ ]
 * These characters will not appear in the formatted output unless they are escaped
 * with a dollar character ('$').
 * @method getTranslatedString
 * @memberof oj.Translations
 * @param {string} key  translations resource key. The dot character (.) within the key string
 * is interpreted as a separator for the name of a sub-section within the bundle.
 * For example, 'components.chart', would be read as the 'chart' section within
 * 'components'. Thus the key name for an individual section should never contain a dot.
 *
 * @param {...(string|Object|Array)} var_args  - optional parameters to be inserted into the
 * translated pattern.
 *
 * If more than one var_args arguments are passed, they will be treated as an array
 * for replacing positional tokens like {0}, {1}, etc.
 * If a single argument is passed, it will be treated as a Javascript Object whose
 * keys will be matched to tokens within the pattern. Note that an Array is just
 * a special kind of such an Object.
 *
 * For backward compatibility, a var_args argument whose type is neither
 * Object or Array will be used to replace {0} in the pattern.
 *
 * @return formatted translated string
 * @ojsignature {target: "Type", for:"returns", value: "string"}
 * @export
 */
// eslint-disable-next-line camelcase, no-unused-vars


Translations.getTranslatedString = function (key, var_args) {
  var val = Translations._getResourceString(key);

  if (val == null) {
    return key;
  }

  var params = {};

  if (arguments.length > 2) {
    params = Array.prototype.slice.call(arguments, 1);
  } else if (arguments.length === 2) {
    params = arguments[1];

    if (_typeof(params) !== 'object' && !(params instanceof Array)) {
      params = [params];
    }
  }

  return Translations.applyParameters(val, params);
};
/**
 * Provides a key-to-value map of the translated resources for a given component name
 * @method getComponentTranslations
 * @memberof oj.Translations
 * @param {string} componentName name of the component
 * @return {Object} a map of translated resources
 * @export
 */


Translations.getComponentTranslations = function (componentName) {
  var bundle = Translations._getBundle()[componentName];

  if (bundle == null) {
    return {};
  } // Assume that the set of keys remains constant regardless of the current locale


  var translations = {};
  var keys = Object.keys(bundle);

  for (var k = 0; k < keys.length; k++) {
    var key = keys[k];
    translations[key] = bundle[key];
  }

  return translations;
};
/**
 * Retrives a translated resource for a given key, accounting for nested keys
 * @param {string} key
 * @return {string|null} resource associated with the key or null if none was found
 * @private
 */


Translations._getResourceString = function (key) {
  // Account for dot separated nested keys
  var keys = key ? key.split('.') : [];

  var bundle = Translations._getBundle();

  oj.Assert.assertObject(bundle); // even though we start with a valid bundle it's possible that part or all of the key is invalid,
  // so check we have a valid bundle in the for loop
  // if we have a key like a.b.c

  for (var index = 0; index < keys.length && bundle != null; index++) {
    var subkey = keys[index];
    bundle = bundle[subkey];
  }

  return bundle != null ? bundle : null;
};

Translations._format = function (formatString, parameters) {
  var formatLength = formatString.length; // Use the javascript StringBuffer technique.

  var buffer = [];
  var token = null;
  var escaped = false;
  var isToken = false;
  var isGroup = false;
  var isExcluded = false;
  var tokenTerminated; // this will be set to true when a comma or space is
  // encountered in teh token

  var i;

  for (i = 0; i < formatLength; i++) {
    var ch = formatString.charAt(i);
    var accumulate = false;

    if (!escaped) {
      switch (ch) {
        case '$':
          escaped = true;
          break;

        case '{':
          if (!isExcluded) {
            if (!isToken) {
              tokenTerminated = false;
              token = [];
            }

            isToken = true;
          }

          break;

        case '}':
          if (isToken && token.length > 0) {
            var val = parameters[token.join('')];
            buffer.push(val === undefined ? 'null' : val);
          }

          isToken = false;
          break;

        case '[':
          if (!isToken) {
            if (isGroup) {
              isExcluded = true;
            } else {
              isGroup = true;
            }
          }

          break;

        case ']':
          if (isExcluded) {
            isExcluded = false;
          } else {
            isGroup = false;
          }

          break;

        default:
          accumulate = true;
      }
    } else {
      accumulate = true;
      escaped = false;
    }

    if (accumulate) {
      if (isToken) {
        if (ch === ',' || ch === ' ') {
          tokenTerminated = true;
        } else if (!tokenTerminated) {
          token.push(ch);
        }
      } else if (!isExcluded) {
        buffer.push(ch);
      }
    }
  } // Use the javascript StringBuffer technique for toString()


  return buffer.join('');
};

Translations._getBundle = function () {
  var b = Translations._bundle;

  if (b) {
    return b;
  }

  if (oj.__isAmdLoaderPresent()) {
    var ojt = Config.getConfigBundle();
    oj.Assert.assert(ojt !== undefined, 'ojtranslations module must be defined');
    return ojt;
  }

  return {};
};

;return Translations;
});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojcore',['require', 'ojs/ojcore-base', 'ojs/ojcontext', 'ojs/ojconfig', 'ojs/ojlogger', 'ojs/ojresponsiveutils', 'ojs/ojthemeutils', 'ojs/ojtimerutils', 'ojs/ojtranslation'], function(require, oj, Context, Config, Logger, ResponsiveUtils, ThemeUtils, TimerUtils, Translations)
{
  "use strict";


/**
 * @ojoverviewdoc ModuleLoadingOverview - [5]JET Module Loading
 * @classdesc
 * {@ojinclude "name":"moduleLoadingOverviewDoc"}
 */

/**
 * <h2 id="usage">Overview
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#overview"></a>
 * </h2>
 * <p>
 *  JET classes and components are delivered via a set of <a href="https://github.com/amdjs/amdjs-api/wiki/AMD">asynchronous module definitions</a> (AMDs or more informally, modules).
 *  JET applications typically use <a href="https://requirejs.org/">RequireJS</a> to load the necessary modules and call API as required.  The values returned from JET modules come in one of three forms:
 * </p>
 * <h4>No return value</h4>
 *  <p>Some modules may not return any value at all.  The purpose of these modules is simply to load the associated JavaScript into memory,
 *     but the application typically does not directly interact with or instantiate this code. For example, modules that define
 *     JET Web Components typically would not have return values.
 *  </p>
 * <pre class="prettyprint"><code>
 * //Loading a JET component in your Typescript code
 *
 * //To typecheck the element APIs, import as below.
 * import {ojAccordion} from "ojs/ojaccordion";
 *
 * //For the transpiled javascript to load the element's module, import as below
 * import "ojs/ojaccordion";</code></pre>
 * <h4>One return value</h4>
 *  <p>Some modules directly return a single object or constructor function.  Applications would typically call functions on the returned
 *     object or instantiate new objects via the constructor function.  For example, the 'ojs/ojcontext' module
 *     has a single return value:
 *  </p>
 * <pre class="prettyprint"><code>
 * //Javascript example
 * define(['ojs/ojcontext'], function(Context) {
 *   var pageContext = Context.getPageContext();
 * })</code></pre>
 * <pre class="prettyprint"><code>
 * //TypeScript example
 * import Context = require('ojs/ojcontext');
 *   let pageContext = Context.getPageContext();
 * </code></pre>
 * <h4>Multiple return values</h4>
 *  <p>Some modules package several objects or constructor functions inside a single JavaScript object.  Applications would typically retrieve the relevant object or constructor function via a
 *     documented property on this object and then either call functions or instantiate new objects as appropriate.  For example, the 'ojs/ojattributegrouphandler' module has multiple return values.
 *  </p>
 * <pre class="prettyprint"><code>
 * //TypeScript example
 * import {ColorAttributeGroupHandler, ShapeAttributeGroupHandler} from "ojs/ojattributegrouphandler";
 *  let colorHandler = new ColorAttributeGroupHandler();
 *  let shapeHandler = new ShapeAttributeGroupHandler({'0-2 years': 'triangleDown',
 *                                                     '3-5 years': 'circle',
 *                                                     '6+ years': 'triangleUp'});
 *  var getLegendData = function(data, colorHandler) {
 *     var items = [];
 *     for (var i = 0; i < data.length; i++)
 *     {
 *       items.push({
 *         value: data[i].value,
 *         text: data[i].category,
 *         color: colorHandler.getValue(data[i].category),
 *       });
 *     }
 *     return [{items: items}];
 *   };
 *
 * //Another example
 * import * as Logger from "ojs/ojlogger";
 *  Logger.log("Please enter a valid input");
 * </code></pre>
 *
 * @ojfragment moduleLoadingOverviewDoc
 * @memberof ModuleLoadingOverview
 */



/* global Logger:false, Context:false, Config:false, ResponsiveUtils:false, ThemeUtils:false, TimerUtils:false, Translations:false */
oj.Logger = Logger;
oj.Context = Context;
oj.Config = Config;
oj.ResponsiveUtils = ResponsiveUtils;
oj.ThemeUtils = ThemeUtils;
oj.TimerUtils = TimerUtils;
oj.Translations = Translations;

;return oj;
});
/*! Hammer.JS - v2.0.8 - 2016-04-23
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
!function(a,b,c,d){"use strict";function e(a,b,c){return setTimeout(j(a,c),b)}function f(a,b,c){return Array.isArray(a)?(g(a,c[b],c),!0):!1}function g(a,b,c){var e;if(a)if(a.forEach)a.forEach(b,c);else if(a.length!==d)for(e=0;e<a.length;)b.call(c,a[e],e,a),e++;else for(e in a)a.hasOwnProperty(e)&&b.call(c,a[e],e,a)}function h(b,c,d){var e="DEPRECATED METHOD: "+c+"\n"+d+" AT \n";return function(){var c=new Error("get-stack-trace"),d=c&&c.stack?c.stack.replace(/^[^\(]+?[\n$]/gm,"").replace(/^\s+at\s+/gm,"").replace(/^Object.<anonymous>\s*\(/gm,"{anonymous}()@"):"Unknown Stack Trace",f=a.console&&(a.console.warn||a.console.log);return f&&f.call(a.console,e,d),b.apply(this,arguments)}}function i(a,b,c){var d,e=b.prototype;d=a.prototype=Object.create(e),d.constructor=a,d._super=e,c&&la(d,c)}function j(a,b){return function(){return a.apply(b,arguments)}}function k(a,b){return typeof a==oa?a.apply(b?b[0]||d:d,b):a}function l(a,b){return a===d?b:a}function m(a,b,c){g(q(b),function(b){a.addEventListener(b,c,!1)})}function n(a,b,c){g(q(b),function(b){a.removeEventListener(b,c,!1)})}function o(a,b){for(;a;){if(a==b)return!0;a=a.parentNode}return!1}function p(a,b){return a.indexOf(b)>-1}function q(a){return a.trim().split(/\s+/g)}function r(a,b,c){if(a.indexOf&&!c)return a.indexOf(b);for(var d=0;d<a.length;){if(c&&a[d][c]==b||!c&&a[d]===b)return d;d++}return-1}function s(a){return Array.prototype.slice.call(a,0)}function t(a,b,c){for(var d=[],e=[],f=0;f<a.length;){var g=b?a[f][b]:a[f];r(e,g)<0&&d.push(a[f]),e[f]=g,f++}return c&&(d=b?d.sort(function(a,c){return a[b]>c[b]}):d.sort()),d}function u(a,b){for(var c,e,f=b[0].toUpperCase()+b.slice(1),g=0;g<ma.length;){if(c=ma[g],e=c?c+f:b,e in a)return e;g++}return d}function v(){return ua++}function w(b){var c=b.ownerDocument||b;return c.defaultView||c.parentWindow||a}function x(a,b){var c=this;this.manager=a,this.callback=b,this.element=a.element,this.target=a.options.inputTarget,this.domHandler=function(b){k(a.options.enable,[a])&&c.handler(b)},this.init()}function y(a){var b,c=a.options.inputClass;return new(b=c?c:xa?M:ya?P:wa?R:L)(a,z)}function z(a,b,c){var d=c.pointers.length,e=c.changedPointers.length,f=b&Ea&&d-e===0,g=b&(Ga|Ha)&&d-e===0;c.isFirst=!!f,c.isFinal=!!g,f&&(a.session={}),c.eventType=b,A(a,c),a.emit("hammer.input",c),a.recognize(c),a.session.prevInput=c}function A(a,b){var c=a.session,d=b.pointers,e=d.length;c.firstInput||(c.firstInput=D(b)),e>1&&!c.firstMultiple?c.firstMultiple=D(b):1===e&&(c.firstMultiple=!1);var f=c.firstInput,g=c.firstMultiple,h=g?g.center:f.center,i=b.center=E(d);b.timeStamp=ra(),b.deltaTime=b.timeStamp-f.timeStamp,b.angle=I(h,i),b.distance=H(h,i),B(c,b),b.offsetDirection=G(b.deltaX,b.deltaY);var j=F(b.deltaTime,b.deltaX,b.deltaY);b.overallVelocityX=j.x,b.overallVelocityY=j.y,b.overallVelocity=qa(j.x)>qa(j.y)?j.x:j.y,b.scale=g?K(g.pointers,d):1,b.rotation=g?J(g.pointers,d):0,b.maxPointers=c.prevInput?b.pointers.length>c.prevInput.maxPointers?b.pointers.length:c.prevInput.maxPointers:b.pointers.length,C(c,b);var k=a.element;o(b.srcEvent.target,k)&&(k=b.srcEvent.target),b.target=k}function B(a,b){var c=b.center,d=a.offsetDelta||{},e=a.prevDelta||{},f=a.prevInput||{};b.eventType!==Ea&&f.eventType!==Ga||(e=a.prevDelta={x:f.deltaX||0,y:f.deltaY||0},d=a.offsetDelta={x:c.x,y:c.y}),b.deltaX=e.x+(c.x-d.x),b.deltaY=e.y+(c.y-d.y)}function C(a,b){var c,e,f,g,h=a.lastInterval||b,i=b.timeStamp-h.timeStamp;if(b.eventType!=Ha&&(i>Da||h.velocity===d)){var j=b.deltaX-h.deltaX,k=b.deltaY-h.deltaY,l=F(i,j,k);e=l.x,f=l.y,c=qa(l.x)>qa(l.y)?l.x:l.y,g=G(j,k),a.lastInterval=b}else c=h.velocity,e=h.velocityX,f=h.velocityY,g=h.direction;b.velocity=c,b.velocityX=e,b.velocityY=f,b.direction=g}function D(a){for(var b=[],c=0;c<a.pointers.length;)b[c]={clientX:pa(a.pointers[c].clientX),clientY:pa(a.pointers[c].clientY)},c++;return{timeStamp:ra(),pointers:b,center:E(b),deltaX:a.deltaX,deltaY:a.deltaY}}function E(a){var b=a.length;if(1===b)return{x:pa(a[0].clientX),y:pa(a[0].clientY)};for(var c=0,d=0,e=0;b>e;)c+=a[e].clientX,d+=a[e].clientY,e++;return{x:pa(c/b),y:pa(d/b)}}function F(a,b,c){return{x:b/a||0,y:c/a||0}}function G(a,b){return a===b?Ia:qa(a)>=qa(b)?0>a?Ja:Ka:0>b?La:Ma}function H(a,b,c){c||(c=Qa);var d=b[c[0]]-a[c[0]],e=b[c[1]]-a[c[1]];return Math.sqrt(d*d+e*e)}function I(a,b,c){c||(c=Qa);var d=b[c[0]]-a[c[0]],e=b[c[1]]-a[c[1]];return 180*Math.atan2(e,d)/Math.PI}function J(a,b){return I(b[1],b[0],Ra)+I(a[1],a[0],Ra)}function K(a,b){return H(b[0],b[1],Ra)/H(a[0],a[1],Ra)}function L(){this.evEl=Ta,this.evWin=Ua,this.pressed=!1,x.apply(this,arguments)}function M(){this.evEl=Xa,this.evWin=Ya,x.apply(this,arguments),this.store=this.manager.session.pointerEvents=[]}function N(){this.evTarget=$a,this.evWin=_a,this.started=!1,x.apply(this,arguments)}function O(a,b){var c=s(a.touches),d=s(a.changedTouches);return b&(Ga|Ha)&&(c=t(c.concat(d),"identifier",!0)),[c,d]}function P(){this.evTarget=bb,this.targetIds={},x.apply(this,arguments)}function Q(a,b){var c=s(a.touches),d=this.targetIds;if(b&(Ea|Fa)&&1===c.length)return d[c[0].identifier]=!0,[c,c];var e,f,g=s(a.changedTouches),h=[],i=this.target;if(f=c.filter(function(a){return o(a.target,i)}),b===Ea)for(e=0;e<f.length;)d[f[e].identifier]=!0,e++;for(e=0;e<g.length;)d[g[e].identifier]&&h.push(g[e]),b&(Ga|Ha)&&delete d[g[e].identifier],e++;return h.length?[t(f.concat(h),"identifier",!0),h]:void 0}function R(){x.apply(this,arguments);var a=j(this.handler,this);this.touch=new P(this.manager,a),this.mouse=new L(this.manager,a),this.primaryTouch=null,this.lastTouches=[]}function S(a,b){a&Ea?(this.primaryTouch=b.changedPointers[0].identifier,T.call(this,b)):a&(Ga|Ha)&&T.call(this,b)}function T(a){var b=a.changedPointers[0];if(b.identifier===this.primaryTouch){var c={x:b.clientX,y:b.clientY};this.lastTouches.push(c);var d=this.lastTouches,e=function(){var a=d.indexOf(c);a>-1&&d.splice(a,1)};setTimeout(e,cb)}}function U(a){for(var b=a.srcEvent.clientX,c=a.srcEvent.clientY,d=0;d<this.lastTouches.length;d++){var e=this.lastTouches[d],f=Math.abs(b-e.x),g=Math.abs(c-e.y);if(db>=f&&db>=g)return!0}return!1}function V(a,b){this.manager=a,this.set(b)}function W(a){if(p(a,jb))return jb;var b=p(a,kb),c=p(a,lb);return b&&c?jb:b||c?b?kb:lb:p(a,ib)?ib:hb}function X(){if(!fb)return!1;var b={},c=a.CSS&&a.CSS.supports;return["auto","manipulation","pan-y","pan-x","pan-x pan-y","none"].forEach(function(d){b[d]=c?a.CSS.supports("touch-action",d):!0}),b}function Y(a){this.options=la({},this.defaults,a||{}),this.id=v(),this.manager=null,this.options.enable=l(this.options.enable,!0),this.state=nb,this.simultaneous={},this.requireFail=[]}function Z(a){return a&sb?"cancel":a&qb?"end":a&pb?"move":a&ob?"start":""}function $(a){return a==Ma?"down":a==La?"up":a==Ja?"left":a==Ka?"right":""}function _(a,b){var c=b.manager;return c?c.get(a):a}function aa(){Y.apply(this,arguments)}function ba(){aa.apply(this,arguments),this.pX=null,this.pY=null}function ca(){aa.apply(this,arguments)}function da(){Y.apply(this,arguments),this._timer=null,this._input=null}function ea(){aa.apply(this,arguments)}function fa(){aa.apply(this,arguments)}function ga(){Y.apply(this,arguments),this.pTime=!1,this.pCenter=!1,this._timer=null,this._input=null,this.count=0}function ha(a,b){return b=b||{},b.recognizers=l(b.recognizers,ha.defaults.preset),new ia(a,b)}function ia(a,b){this.options=la({},ha.defaults,b||{}),this.options.inputTarget=this.options.inputTarget||a,this.handlers={},this.session={},this.recognizers=[],this.oldCssProps={},this.element=a,this.input=y(this),this.touchAction=new V(this,this.options.touchAction),ja(this,!0),g(this.options.recognizers,function(a){var b=this.add(new a[0](a[1]));a[2]&&b.recognizeWith(a[2]),a[3]&&b.requireFailure(a[3])},this)}function ja(a,b){var c=a.element;if(c.style){var d;g(a.options.cssProps,function(e,f){d=u(c.style,f),b?(a.oldCssProps[d]=c.style[d],c.style[d]=e):c.style[d]=a.oldCssProps[d]||""}),b||(a.oldCssProps={})}}function ka(a,c){var d=b.createEvent("Event");d.initEvent(a,!0,!0),d.gesture=c,c.target.dispatchEvent(d)}var la,ma=["","webkit","Moz","MS","ms","o"],na=b.createElement("div"),oa="function",pa=Math.round,qa=Math.abs,ra=Date.now;la="function"!=typeof Object.assign?function(a){if(a===d||null===a)throw new TypeError("Cannot convert undefined or null to object");for(var b=Object(a),c=1;c<arguments.length;c++){var e=arguments[c];if(e!==d&&null!==e)for(var f in e)e.hasOwnProperty(f)&&(b[f]=e[f])}return b}:Object.assign;var sa=h(function(a,b,c){for(var e=Object.keys(b),f=0;f<e.length;)(!c||c&&a[e[f]]===d)&&(a[e[f]]=b[e[f]]),f++;return a},"extend","Use `assign`."),ta=h(function(a,b){return sa(a,b,!0)},"merge","Use `assign`."),ua=1,va=/mobile|tablet|ip(ad|hone|od)|android/i,wa="ontouchstart"in a,xa=u(a,"PointerEvent")!==d,ya=wa&&va.test(navigator.userAgent),za="touch",Aa="pen",Ba="mouse",Ca="kinect",Da=25,Ea=1,Fa=2,Ga=4,Ha=8,Ia=1,Ja=2,Ka=4,La=8,Ma=16,Na=Ja|Ka,Oa=La|Ma,Pa=Na|Oa,Qa=["x","y"],Ra=["clientX","clientY"];x.prototype={handler:function(){},init:function(){this.evEl&&m(this.element,this.evEl,this.domHandler),this.evTarget&&m(this.target,this.evTarget,this.domHandler),this.evWin&&m(w(this.element),this.evWin,this.domHandler)},destroy:function(){this.evEl&&n(this.element,this.evEl,this.domHandler),this.evTarget&&n(this.target,this.evTarget,this.domHandler),this.evWin&&n(w(this.element),this.evWin,this.domHandler)}};var Sa={mousedown:Ea,mousemove:Fa,mouseup:Ga},Ta="mousedown",Ua="mousemove mouseup";i(L,x,{handler:function(a){var b=Sa[a.type];b&Ea&&0===a.button&&(this.pressed=!0),b&Fa&&1!==a.which&&(b=Ga),this.pressed&&(b&Ga&&(this.pressed=!1),this.callback(this.manager,b,{pointers:[a],changedPointers:[a],pointerType:Ba,srcEvent:a}))}});var Va={pointerdown:Ea,pointermove:Fa,pointerup:Ga,pointercancel:Ha,pointerout:Ha},Wa={2:za,3:Aa,4:Ba,5:Ca},Xa="pointerdown",Ya="pointermove pointerup pointercancel";a.MSPointerEvent&&!a.PointerEvent&&(Xa="MSPointerDown",Ya="MSPointerMove MSPointerUp MSPointerCancel"),i(M,x,{handler:function(a){var b=this.store,c=!1,d=a.type.toLowerCase().replace("ms",""),e=Va[d],f=Wa[a.pointerType]||a.pointerType,g=f==za,h=r(b,a.pointerId,"pointerId");e&Ea&&(0===a.button||g)?0>h&&(b.push(a),h=b.length-1):e&(Ga|Ha)&&(c=!0),0>h||(b[h]=a,this.callback(this.manager,e,{pointers:b,changedPointers:[a],pointerType:f,srcEvent:a}),c&&b.splice(h,1))}});var Za={touchstart:Ea,touchmove:Fa,touchend:Ga,touchcancel:Ha},$a="touchstart",_a="touchstart touchmove touchend touchcancel";i(N,x,{handler:function(a){var b=Za[a.type];if(b===Ea&&(this.started=!0),this.started){var c=O.call(this,a,b);b&(Ga|Ha)&&c[0].length-c[1].length===0&&(this.started=!1),this.callback(this.manager,b,{pointers:c[0],changedPointers:c[1],pointerType:za,srcEvent:a})}}});var ab={touchstart:Ea,touchmove:Fa,touchend:Ga,touchcancel:Ha},bb="touchstart touchmove touchend touchcancel";i(P,x,{handler:function(a){var b=ab[a.type],c=Q.call(this,a,b);c&&this.callback(this.manager,b,{pointers:c[0],changedPointers:c[1],pointerType:za,srcEvent:a})}});var cb=2500,db=25;i(R,x,{handler:function(a,b,c){var d=c.pointerType==za,e=c.pointerType==Ba;if(!(e&&c.sourceCapabilities&&c.sourceCapabilities.firesTouchEvents)){if(d)S.call(this,b,c);else if(e&&U.call(this,c))return;this.callback(a,b,c)}},destroy:function(){this.touch.destroy(),this.mouse.destroy()}});var eb=u(na.style,"touchAction"),fb=eb!==d,gb="compute",hb="auto",ib="manipulation",jb="none",kb="pan-x",lb="pan-y",mb=X();V.prototype={set:function(a){a==gb&&(a=this.compute()),fb&&this.manager.element.style&&mb[a]&&(this.manager.element.style[eb]=a),this.actions=a.toLowerCase().trim()},update:function(){this.set(this.manager.options.touchAction)},compute:function(){var a=[];return g(this.manager.recognizers,function(b){k(b.options.enable,[b])&&(a=a.concat(b.getTouchAction()))}),W(a.join(" "))},preventDefaults:function(a){var b=a.srcEvent,c=a.offsetDirection;if(this.manager.session.prevented)return void b.preventDefault();var d=this.actions,e=p(d,jb)&&!mb[jb],f=p(d,lb)&&!mb[lb],g=p(d,kb)&&!mb[kb];if(e){var h=1===a.pointers.length,i=a.distance<2,j=a.deltaTime<250;if(h&&i&&j)return}return g&&f?void 0:e||f&&c&Na||g&&c&Oa?this.preventSrc(b):void 0},preventSrc:function(a){this.manager.session.prevented=!0,a.preventDefault()}};var nb=1,ob=2,pb=4,qb=8,rb=qb,sb=16,tb=32;Y.prototype={defaults:{},set:function(a){return la(this.options,a),this.manager&&this.manager.touchAction.update(),this},recognizeWith:function(a){if(f(a,"recognizeWith",this))return this;var b=this.simultaneous;return a=_(a,this),b[a.id]||(b[a.id]=a,a.recognizeWith(this)),this},dropRecognizeWith:function(a){return f(a,"dropRecognizeWith",this)?this:(a=_(a,this),delete this.simultaneous[a.id],this)},requireFailure:function(a){if(f(a,"requireFailure",this))return this;var b=this.requireFail;return a=_(a,this),-1===r(b,a)&&(b.push(a),a.requireFailure(this)),this},dropRequireFailure:function(a){if(f(a,"dropRequireFailure",this))return this;a=_(a,this);var b=r(this.requireFail,a);return b>-1&&this.requireFail.splice(b,1),this},hasRequireFailures:function(){return this.requireFail.length>0},canRecognizeWith:function(a){return!!this.simultaneous[a.id]},emit:function(a){function b(b){c.manager.emit(b,a)}var c=this,d=this.state;qb>d&&b(c.options.event+Z(d)),b(c.options.event),a.additionalEvent&&b(a.additionalEvent),d>=qb&&b(c.options.event+Z(d))},tryEmit:function(a){return this.canEmit()?this.emit(a):void(this.state=tb)},canEmit:function(){for(var a=0;a<this.requireFail.length;){if(!(this.requireFail[a].state&(tb|nb)))return!1;a++}return!0},recognize:function(a){var b=la({},a);return k(this.options.enable,[this,b])?(this.state&(rb|sb|tb)&&(this.state=nb),this.state=this.process(b),void(this.state&(ob|pb|qb|sb)&&this.tryEmit(b))):(this.reset(),void(this.state=tb))},process:function(a){},getTouchAction:function(){},reset:function(){}},i(aa,Y,{defaults:{pointers:1},attrTest:function(a){var b=this.options.pointers;return 0===b||a.pointers.length===b},process:function(a){var b=this.state,c=a.eventType,d=b&(ob|pb),e=this.attrTest(a);return d&&(c&Ha||!e)?b|sb:d||e?c&Ga?b|qb:b&ob?b|pb:ob:tb}}),i(ba,aa,{defaults:{event:"pan",threshold:10,pointers:1,direction:Pa},getTouchAction:function(){var a=this.options.direction,b=[];return a&Na&&b.push(lb),a&Oa&&b.push(kb),b},directionTest:function(a){var b=this.options,c=!0,d=a.distance,e=a.direction,f=a.deltaX,g=a.deltaY;return e&b.direction||(b.direction&Na?(e=0===f?Ia:0>f?Ja:Ka,c=f!=this.pX,d=Math.abs(a.deltaX)):(e=0===g?Ia:0>g?La:Ma,c=g!=this.pY,d=Math.abs(a.deltaY))),a.direction=e,c&&d>b.threshold&&e&b.direction},attrTest:function(a){return aa.prototype.attrTest.call(this,a)&&(this.state&ob||!(this.state&ob)&&this.directionTest(a))},emit:function(a){this.pX=a.deltaX,this.pY=a.deltaY;var b=$(a.direction);b&&(a.additionalEvent=this.options.event+b),this._super.emit.call(this,a)}}),i(ca,aa,{defaults:{event:"pinch",threshold:0,pointers:2},getTouchAction:function(){return[jb]},attrTest:function(a){return this._super.attrTest.call(this,a)&&(Math.abs(a.scale-1)>this.options.threshold||this.state&ob)},emit:function(a){if(1!==a.scale){var b=a.scale<1?"in":"out";a.additionalEvent=this.options.event+b}this._super.emit.call(this,a)}}),i(da,Y,{defaults:{event:"press",pointers:1,time:251,threshold:9},getTouchAction:function(){return[hb]},process:function(a){var b=this.options,c=a.pointers.length===b.pointers,d=a.distance<b.threshold,f=a.deltaTime>b.time;if(this._input=a,!d||!c||a.eventType&(Ga|Ha)&&!f)this.reset();else if(a.eventType&Ea)this.reset(),this._timer=e(function(){this.state=rb,this.tryEmit()},b.time,this);else if(a.eventType&Ga)return rb;return tb},reset:function(){clearTimeout(this._timer)},emit:function(a){this.state===rb&&(a&&a.eventType&Ga?this.manager.emit(this.options.event+"up",a):(this._input.timeStamp=ra(),this.manager.emit(this.options.event,this._input)))}}),i(ea,aa,{defaults:{event:"rotate",threshold:0,pointers:2},getTouchAction:function(){return[jb]},attrTest:function(a){return this._super.attrTest.call(this,a)&&(Math.abs(a.rotation)>this.options.threshold||this.state&ob)}}),i(fa,aa,{defaults:{event:"swipe",threshold:10,velocity:.3,direction:Na|Oa,pointers:1},getTouchAction:function(){return ba.prototype.getTouchAction.call(this)},attrTest:function(a){var b,c=this.options.direction;return c&(Na|Oa)?b=a.overallVelocity:c&Na?b=a.overallVelocityX:c&Oa&&(b=a.overallVelocityY),this._super.attrTest.call(this,a)&&c&a.offsetDirection&&a.distance>this.options.threshold&&a.maxPointers==this.options.pointers&&qa(b)>this.options.velocity&&a.eventType&Ga},emit:function(a){var b=$(a.offsetDirection);b&&this.manager.emit(this.options.event+b,a),this.manager.emit(this.options.event,a)}}),i(ga,Y,{defaults:{event:"tap",pointers:1,taps:1,interval:300,time:250,threshold:9,posThreshold:10},getTouchAction:function(){return[ib]},process:function(a){var b=this.options,c=a.pointers.length===b.pointers,d=a.distance<b.threshold,f=a.deltaTime<b.time;if(this.reset(),a.eventType&Ea&&0===this.count)return this.failTimeout();if(d&&f&&c){if(a.eventType!=Ga)return this.failTimeout();var g=this.pTime?a.timeStamp-this.pTime<b.interval:!0,h=!this.pCenter||H(this.pCenter,a.center)<b.posThreshold;this.pTime=a.timeStamp,this.pCenter=a.center,h&&g?this.count+=1:this.count=1,this._input=a;var i=this.count%b.taps;if(0===i)return this.hasRequireFailures()?(this._timer=e(function(){this.state=rb,this.tryEmit()},b.interval,this),ob):rb}return tb},failTimeout:function(){return this._timer=e(function(){this.state=tb},this.options.interval,this),tb},reset:function(){clearTimeout(this._timer)},emit:function(){this.state==rb&&(this._input.tapCount=this.count,this.manager.emit(this.options.event,this._input))}}),ha.VERSION="2.0.8",ha.defaults={domEvents:!1,touchAction:gb,enable:!0,inputTarget:null,inputClass:null,preset:[[ea,{enable:!1}],[ca,{enable:!1},["rotate"]],[fa,{direction:Na}],[ba,{direction:Na},["swipe"]],[ga],[ga,{event:"doubletap",taps:2},["tap"]],[da]],cssProps:{userSelect:"none",touchSelect:"none",touchCallout:"none",contentZooming:"none",userDrag:"none",tapHighlightColor:"rgba(0,0,0,0)"}};var ub=1,vb=2;ia.prototype={set:function(a){return la(this.options,a),a.touchAction&&this.touchAction.update(),a.inputTarget&&(this.input.destroy(),this.input.target=a.inputTarget,this.input.init()),this},stop:function(a){this.session.stopped=a?vb:ub},recognize:function(a){var b=this.session;if(!b.stopped){this.touchAction.preventDefaults(a);var c,d=this.recognizers,e=b.curRecognizer;(!e||e&&e.state&rb)&&(e=b.curRecognizer=null);for(var f=0;f<d.length;)c=d[f],b.stopped===vb||e&&c!=e&&!c.canRecognizeWith(e)?c.reset():c.recognize(a),!e&&c.state&(ob|pb|qb)&&(e=b.curRecognizer=c),f++}},get:function(a){if(a instanceof Y)return a;for(var b=this.recognizers,c=0;c<b.length;c++)if(b[c].options.event==a)return b[c];return null},add:function(a){if(f(a,"add",this))return this;var b=this.get(a.options.event);return b&&this.remove(b),this.recognizers.push(a),a.manager=this,this.touchAction.update(),a},remove:function(a){if(f(a,"remove",this))return this;if(a=this.get(a)){var b=this.recognizers,c=r(b,a);-1!==c&&(b.splice(c,1),this.touchAction.update())}return this},on:function(a,b){if(a!==d&&b!==d){var c=this.handlers;return g(q(a),function(a){c[a]=c[a]||[],c[a].push(b)}),this}},off:function(a,b){if(a!==d){var c=this.handlers;return g(q(a),function(a){b?c[a]&&c[a].splice(r(c[a],b),1):delete c[a]}),this}},emit:function(a,b){this.options.domEvents&&ka(a,b);var c=this.handlers[a]&&this.handlers[a].slice();if(c&&c.length){b.type=a,b.preventDefault=function(){b.srcEvent.preventDefault()};for(var d=0;d<c.length;)c[d](b),d++}},destroy:function(){this.element&&ja(this,!1),this.handlers={},this.session={},this.input.destroy(),this.element=null}},la(ha,{INPUT_START:Ea,INPUT_MOVE:Fa,INPUT_END:Ga,INPUT_CANCEL:Ha,STATE_POSSIBLE:nb,STATE_BEGAN:ob,STATE_CHANGED:pb,STATE_ENDED:qb,STATE_RECOGNIZED:rb,STATE_CANCELLED:sb,STATE_FAILED:tb,DIRECTION_NONE:Ia,DIRECTION_LEFT:Ja,DIRECTION_RIGHT:Ka,DIRECTION_UP:La,DIRECTION_DOWN:Ma,DIRECTION_HORIZONTAL:Na,DIRECTION_VERTICAL:Oa,DIRECTION_ALL:Pa,Manager:ia,Input:x,TouchAction:V,TouchInput:P,MouseInput:L,PointerEventInput:M,TouchMouseInput:R,SingleTouchInput:N,Recognizer:Y,AttrRecognizer:aa,Tap:ga,Pan:ba,Swipe:fa,Pinch:ca,Rotate:ea,Press:da,on:m,off:n,each:g,merge:ta,extend:sa,assign:la,inherit:i,bindFn:j,prefixed:u});var wb="undefined"!=typeof a?a:"undefined"!=typeof self?self:{};wb.Hammer=ha,"function"==typeof define&&define.amd?define('hammerjs',[],function(){return ha}):"undefined"!=typeof module&&module.exports?module.exports=ha:a[c]=ha}(window,document,"Hammer");

/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojmessaging',['ojs/ojcore', 'jquery'], function(oj, $)
{
  "use strict";


/**
 * Constructs a message object.
 * <p><strong>NOTE:</strong>  Instead of using the constructor, please use an Object
 * that duck-types oj.Message - has summary, detail, and severity properties.
 * Creating an oj.Message Object provides no additional value than
 * the duck-typed Object.
 * </p>
 * @param {string} summary - Localized summary message text
 * @param {string} detail - Localized detail message text
 * @param {(number|string)=} severity - An optional severity for this message. Use constants
 * oj.Message.SEVERITY_LEVEL for number types and oj.Message.SEVERITY_TYPE for string types. Default
 * is SEVERITY_ERROR if no severity is specified
 * @constructor
 * @final
 * @ojtsmodule
 * @export
 * @since 0.6.0
 * @example <caption>Set application messages using the
 * <code class="prettyprint">messages-custom</code> attribute. This example creates messages
 * the recommended way, by creating an Object that duck-types oj.Message.</caption>
 * --- HTML ---
 * &lt;oj-input-text messages-custom="{{appMessages}}");>&lt;/oj-input-text>
 *
 * --- Javascript ---
 * // for messagesCustom property
 * self.appMessages = ko.observable();
 * var msgs = [];
 * msgs.push({summary: "Error Summary", detail: "Error Detail",
 *  severity: oj.Message.SEVERITY_TYPE['CONFIRMATION']});
 * self.appMessages(msgs);
 * @ojsignature [{target: "Type",
 *                value: "oj.Message.SEVERITY_TYPE| oj.Message.SEVERITY_LEVEL",
 *                for: "severity"}]
 */
oj.Message = function (summary, detail, severity) {
  this.Init(summary, detail, severity);
};
/**
 * Indicates the type of severity that the message represents.
 * @enum {string}
 * @export
 */


oj.Message.SEVERITY_TYPE = {
  /**
   * Indicates a confirmation that an operation or task was completed. This is the lowest severity
   * level.
   */
  CONFIRMATION: 'confirmation',

  /**
   * Indicates information or operation messages. This has a lower severity level than warning.
   */
  INFO: 'info',

  /**
   * Indicates an application condition or situation that might require users' attention. This has a
   * lower severity than error.
   */
  WARNING: 'warning',

  /**
   * Used when data inaccuracies occur when completing a field and that needs fixing before user can
   * continue. This has a lower severity level than fatal.
   * fatal.
   */
  ERROR: 'error',

  /**
   * Used when a critical application error or an unknown failure occurs. This is the highest
   * severity level.
   * @const
   * @export
   */
  FATAL: 'fatal'
};
/**
 * Message severity level
 * @enum {number}
 * @export
 */

oj.Message.SEVERITY_LEVEL = {
  FATAL: 5,
  ERROR: 4,
  WARNING: 3,
  INFO: 2,
  CONFIRMATION: 1
}; // Subclass from oj.Object

oj.Object.createSubclass(oj.Message, oj.Object, 'oj.Message');
/**
 * Localized summary text.
 *
 * @member
 * @name summary
 * @memberof oj.Message
 * @instance
 * @type {string}
 * @default ""
 */

/**
 * Localized detail text.
 *
 * @member
 * @name detail
 * @memberof oj.Message
 * @instance
 * @type {string}
 * @default ""
 */

/**
 * Severity type of message. See oj.Message.SEVERITY_TYPE for string types and oj.Message.SEVERITY_LEVEL for number types.
 *
 * @member
 * @name severity
 * @memberof oj.Message
 * @instance
 * @type {string|number}
 * @ojsignature [{target: "Type",
 *                value: "oj.Message.SEVERITY_TYPE| oj.Message.SEVERITY_LEVEL"}]
 * @default oj.Message.SEVERITY_TYPE.ERROR
 */

/**
 * Initializes Message instance with the set options
 * @param {string} summary a localized summary message text
 * @param {string} detail a localized detail message text
 * @param {number|string=} severity - An optional severity for this message.  Use constants
 * oj.Message.SEVERITY_LEVEL for number types and oj.Message.SEVERITY_TYPE for string types.
 *
 * @export
 * @ignore
 */

oj.Message.prototype.Init = function (summary, detail, severity) {
  oj.Message.superclass.Init.call(this);
  this.summary = summary;
  this.detail = detail;
  this.severity = severity || oj.Message.SEVERITY_TYPE.ERROR; // defaults to ERROR
};
/**
 * A convenience method that returns the severity level when given either a severity level of type
 * number or a severity type of string.
 * If severity level is not provided or is not valid this returns a severity error.
 * @param {(string|number)=} severity
 * @return {number}
 * @memberof oj.Message
 * @ojsignature [{target: "Type",
 *                value: "oj.Message.SEVERITY_LEVEL",
 *                for: "returns"},
 *               {target: "Type",
 *                value: "oj.Message.SEVERITY_TYPE|oj.Message.SEVERITY_LEVEL",
 *                for: "severity"}]
 * @public
 * @export
 */


oj.Message.getSeverityLevel = function (severity) {
  var _severity = severity;

  if (_severity) {
    if (typeof severity === 'string') {
      var index = oj.Message._LEVEL_TO_TYPE.indexOf(_severity, 1);

      if (index === -1) {
        _severity = oj.Message.SEVERITY_LEVEL.ERROR;
      } else {
        _severity = index;
      }
    } else if (typeof _severity === 'number' && (_severity < oj.Message.SEVERITY_LEVEL.CONFIRMATION || _severity > oj.Message.SEVERITY_LEVEL.FATAL)) {
      _severity = oj.Message.SEVERITY_LEVEL.ERROR;
    }
  }

  return _severity || oj.Message.SEVERITY_LEVEL.ERROR;
};
/**
 * A convenience method that returns the severity type when given either a severity level of type
 * number or a severity type of string.
 * If severity level is not provided or is not valid this return a severity error.
 * @param {(string|number)=} level
 * @return {string}
 * @ojsignature [{target: "Type",
 *                value: "oj.Message.SEVERITY_TYPE",
 *                for: "returns"},
 *               {target: "Type",
 *                value: "oj.Message.SEVERITY_TYPE|oj.Message.SEVERITY_LEVEL",
 *                for: "level"}]
 * @memberof oj.Message
 * @public
 * @export
 */


oj.Message.getSeverityType = function (level) {
  var _level = level;

  if (_level) {
    if (typeof _level === 'string') {
      var index = oj.Message._LEVEL_TO_TYPE.indexOf(_level, 1);

      if (index === -1) {
        // when given an unrecognized type return "error"
        _level = oj.Message.SEVERITY_TYPE.ERROR;
      }
    } else if (typeof _level === 'number') {
      if (_level < oj.Message.SEVERITY_LEVEL.CONFIRMATION || _level > oj.Message.SEVERITY_LEVEL.FATAL) {
        _level = oj.Message.SEVERITY_TYPE.ERROR;
      } else {
        _level = oj.Message._LEVEL_TO_TYPE[level];
      }
    }
  }

  return _level || oj.Message.SEVERITY_TYPE.ERROR;
};
/**
 * Returns the max severity level in a array of message objects.
 *
 * @param {Array.<oj.Message>=} messages an array of message instances or duck typed messages
 * @returns {number} -1 if none can be determined; otherwise a severity level as defined by
 * oj.Message.SEVERITY_LEVEL.
 * @export
 * @memberof oj.Message
 * @ojsignature [{target: "Type",
 *                value: "oj.Message.SEVERITY_LEVEL| -1",
 *                for: "returns"}]
 * @public
 */


oj.Message.getMaxSeverity = function (messages) {
  var maxLevel = -1;

  if (messages && messages.length > 0) {
    $.each(messages, function (i, message) {
      var currLevel = oj.Message.getSeverityLevel(message.severity);
      maxLevel = maxLevel < currLevel ? currLevel : maxLevel;
    });
  }

  return maxLevel;
};
/**
 * Returns false if messages are of severity error or greater.
 *
 * @param {Array.<oj.Message>} messages an array of message instances or duck-typed messages
 * @returns {boolean} true if none of the messages are of severity error or greater. false otherwise
 * @export
 * @memberof oj.Message
 * @public
 */


oj.Message.isValid = function (messages) {
  var maxSeverity = oj.Message.getMaxSeverity(messages);

  if (maxSeverity >= oj.Message.SEVERITY_LEVEL.ERROR) {
    return false;
  }

  return true;
};
/**
 * @private
 * @type Array
 */


oj.Message._LEVEL_TO_TYPE = ['none', // this can never be set
oj.Message.SEVERITY_TYPE.CONFIRMATION, oj.Message.SEVERITY_TYPE.INFO, oj.Message.SEVERITY_TYPE.WARNING, oj.Message.SEVERITY_TYPE.ERROR, oj.Message.SEVERITY_TYPE.FATAL]; // mapping a variable to the name used in the require callback function for this module
// it is used in a no-require environment
// eslint-disable-next-line no-unused-vars

var Message = oj.Message;



/**
 * Extends oj.Message to represent a component specific message, this defines options that control
 * how the message will display.
 *
 * @param {string} summary - Localized summary message text
 * @param {string} detail - Localized detail message text
 * @param {number|string} severity - An optional severity for this message. Use constants
 * oj.Message.SEVERITY_LEVEL for number types and oj.Message.SEVERITY_TYPE for string types. Default
 * is SEVERITY_ERROR if no severity is specified
 * @param {Object} options - an Object literal that defines the following properties
 * @property {string} display - whether the message needs to be displayed immediately or not.
 * Accepted values are 'immediate', 'deferred'. The default is 'immediate'.
 * @property {string} context - the context the component was in when the validation messages was
 * added.<p>
 *
 * NOTE: messages added to the component directly by applications are unknown context and always
 * shown {display: 'immediate', context: ''}. </p>
 * @private
 * @constructor
 * @since 0.7.0
 */
oj.ComponentMessage = function (summary, detail, severity, options) {
  this.Init(summary, detail, severity, options);
}; // Subclass from oj.Message


oj.Object.createSubclass(oj.ComponentMessage, oj.Message, 'oj.ComponentMessage');
/**
 * Determines whether the message is displayed immediately or not. Deferred messages are not shown
 * to the user right away but are deferred until component explicitly does. See
 * {@link oj.editableValue#showMessages}.
 * @private
 * @const
 * @type {Object}
 */

oj.ComponentMessage.DISPLAY = {
  SHOWN: 'shown',
  HIDDEN: 'hidden'
};
/**
 * The default display options to use when none set.
 *
 * @type {Object}
 * @private
 */

oj.ComponentMessage._DEFAULT_OPTIONS = {
  display: oj.ComponentMessage.DISPLAY.SHOWN,
  context: ''
};
/**
 * Initializes the strategy based on the display options that specify the messaging artifacts that
 * will be displayed by this strategy.
 *
 * @param {string} summary - Localized summary message text
 * @param {string} detail - Localized detail message text
 * @param {number|string} severity - An optional severity for this message. Use constants
 * oj.Message.SEVERITY_LEVEL for number types and oj.Message.SEVERITY_TYPE for string types. Default
 * is SEVERITY_ERROR if no severity is specified
 * @param {Object} options - an Object literal that defines the following properties
 * @memberof! oj.ComponentMessage
 * @instance
 * @protected
 * @ignore
 */

oj.ComponentMessage.prototype.Init = function (summary, detail, severity, options) {
  oj.ComponentMessage.superclass.Init.call(this, summary, detail, severity);
  this._options = $.extend({}, oj.ComponentMessage._DEFAULT_OPTIONS, options);
};
/**
 * Clones this and returns the new instance.
 *
 * @memberof! oj.ComponentMessage
 * @instance
 * @protected
 * @ignore
 * @returns {Object}
 */


oj.ComponentMessage.prototype.clone = function () {
  return new oj.ComponentMessage(this.summary, this.detail, this.severity, this._options);
};
/**
 * Whether a message can display on the UI.
 *
 * @memberof! oj.ComponentMessage
 * @returns {boolean} true if messages can be displayed; false if marked as deferred by component.
 * @instance
 * @protected
 * @ignore
 */


oj.ComponentMessage.prototype.canDisplay = function () {
  return !(this._options && this._options.display ? this._options.display === oj.ComponentMessage.DISPLAY.HIDDEN : false);
};
/**
 *
 * Called by framework when the message needs to be shown
 *
 * @returns {boolean} true if shown; false if message display was already shown
 *
 * @memberof! oj.ComponentMessage
 * @instance
 * @private
 */


oj.ComponentMessage.prototype._forceDisplayToShown = function () {
  if (this._options && oj.ComponentMessage.DISPLAY.HIDDEN === this._options.display) {
    this._options.display = oj.ComponentMessage.DISPLAY.SHOWN;
    return true;
  }

  return false;
};
/**
 * Called by framework to determine if message was added by component versus app.
 *
 * @returns {boolean} true if messages was added by component. Usually the context is set.
 *
 * @memberof! oj.ComponentMessage
 * @instance
 * @private
 */


oj.ComponentMessage.prototype._isMessageAddedByComponent = function () {
  if (this._options && this._options.context) {
    return true;
  }

  return false;
};

  return oj.Message;
});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojmetadatautils',['ojs/ojcore-base'], function(oj)
{
  "use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }



/**
 * Component Metadata utilities.
 * @class MetadataUtils
 * @export
 * @ignore
 */
var MetadataUtils = {};
/**
 * Default values can be specified at the top level or at leaf subproperties.
 * This utility walks complex property subproperties to generate default value.
 * @property {object} metadata property-level metadata
 * @property {boolean?} shouldFreeze Contol whether we copy or freeze Object/Array types
 * @memberof MetadataUtils
 * @ignore
 */

MetadataUtils.getDefaultValue = function (metadata, shouldFreeze) {
  var defaultValue = metadata.value;

  if (defaultValue === undefined) {
    // If top level metadata isn't specified, check subproperties.
    // Note that we are not handling cases where both top level and subproperty
    // default values are provided, leaving that to auditing and build tools to check.
    var subMeta = metadata.properties;

    if (subMeta) {
      var complexValue = {};
      var keys = Object.keys(subMeta);

      for (var i = 0; i < keys.length; i++) {
        var subpropDefault = MetadataUtils.getDefaultValue(subMeta[keys[i]]);

        if (subpropDefault !== undefined) {
          complexValue[keys[i]] = subpropDefault;
        }
      } // Cache the default value on the top level property. This is ok
      // because we make a copy of the metadata when we process it for
      // event listener properties


      if (Object.keys(complexValue).length > 0) {
        // eslint-disable-next-line no-param-reassign
        metadata.value = complexValue;
        defaultValue = complexValue;
      }
    }
  }

  if (defaultValue !== undefined) {
    // For object/array types, either freeze or make a copy of the value
    // to prevent modification
    if (Array.isArray(defaultValue)) {
      defaultValue = shouldFreeze ? MetadataUtils.deepFreeze(defaultValue) : defaultValue.slice();
    } else if (defaultValue !== null && _typeof(defaultValue) === 'object') {
      defaultValue = shouldFreeze ? MetadataUtils.deepFreeze(defaultValue) : oj.CollectionUtils.copyInto({}, defaultValue, undefined, true);
    }
  }

  return defaultValue;
};
/**
 * Default values can be specified at the top level or at leaf subproperties.
 * This utility creates an object containing the default values for all properties
 * in the metadata (including rolling up subproperty defaults).  Returns null if no
 * default values are found
 * @property {object} metadata properties metadata (i.e. the value of the 'properties' property in component.json)
 * @property {boolean?} shouldFreeze Contol whether we copy or freeze Object/Array types
 * @memberof MetadataUtils
 * @ignore
 */


MetadataUtils.getDefaultValues = function (metadata, shouldFreeze) {
  var defaults = {};
  var propNames = Object.keys(metadata);
  var hasDefaults = false;
  propNames.forEach(function (propName) {
    // would be nice if this could be done lazily via defineProperty, but this causes
    // Object.assign to fail because the property has no setter
    var defaultValue = MetadataUtils.getDefaultValue(metadata[propName], shouldFreeze);

    if (defaultValue !== undefined) {
      defaults[propName] = defaultValue;
      hasDefaults = true;
    }
  });
  return hasDefaults ? defaults : null;
};
/**
 * Helper to deep freeze object literals. This method will walk arrays and
 * freeze array contents as needed. If anything other than a plain old object,
 * we will not attempt to freeze it so the owner should ensure that the
 * object is immutable.
 * @param {any} value The value to freeze
 * @return {any}
 * @ignore
 */


MetadataUtils.deepFreeze = function (value) {
  if (Object.isFrozen(value)) {
    return value;
  } else if (Array.isArray(value)) {
    // eslint-disable-next-line no-param-reassign
    value = value.map(function (item) {
      return MetadataUtils.deepFreeze(item);
    });
  } else if (value !== null && _typeof(value) === 'object') {
    // We should only recurse/freeze if value is a pojo.
    // proto will be null if Object.create(null) was used
    var proto = Object.getPrototypeOf(value);

    if (proto === null || proto === Object.prototype) {
      // Retrieve the property names defined on object
      Object.keys(value).forEach(function (name) {
        // eslint-disable-next-line no-param-reassign
        value[name] = MetadataUtils.deepFreeze(value[name]);
      });
      Object.freeze(value);
    }
  }

  return value;
};

;return MetadataUtils;
});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojdefaultsutils',['ojs/ojmetadatautils'], function(MetadataUtils)
{
  "use strict";


/**
 * Utility methods for handling defaults coming from metadata,
 * Props classes, and dynamic defaults for various JET component
 * models.
 * @private
 */
var DefaultsUtils;

(function (DefaultsUtils) {
  function getFrozenDefault(property, constr, metadata) {
    var defaults = DefaultsUtils.getDefaults(constr, metadata, true); // Default values must be either:
    // 1. primitives
    // 2. immutable classes, e.g. KeySetImpl
    // 3. Object/Arrays composed of #1 or #2

    return MetadataUtils.deepFreeze(defaults[property]);
  }

  DefaultsUtils.getFrozenDefault = getFrozenDefault;

  function getDefaults(constr, metadata, shouldFreeze) {
    // Defaults are created once and stashed on the constructor
    var defaults = constr['_defaults'];

    if (defaults === undefined) {
      // Adding the optional shouldFreeze param for definitional elements so we don't break
      // backwards compatibility, but our preference is to freeze the defaults and clone internally
      // where needed instead (e.g. dot notation sets).
      var staticDefaults = getStaticDefaults(constr, metadata, shouldFreeze); // If staticDefaults is null Object.create will return an empty object

      defaults = Object.create(staticDefaults); // Metadata defaults always override dynamic defaults

      applyDynamicDefaults(constr, defaults);
      constr['_defaults'] = defaults;
    }

    return defaults;
  }

  DefaultsUtils.getDefaults = getDefaults;

  function getStaticDefaults(constr, metadata, shouldFreeze) {
    var _a; // Defaults are created once and stashed on the constructor


    var defaults = constr['_staticDefaults'];

    if (defaults === undefined) {
      // Instantiate defaults to null in case we don't have metadata or properties
      // so when we call Object.create(null) we'll get an empty {} back vs an error for
      // Object.create(undefined);
      defaults = null;

      if (metadata) {
        var propertiesMetadata = metadata.properties;
        var PropDefaults = (_a = metadata.extension) === null || _a === void 0 ? void 0 : _a._DEFAULTS;

        if (PropDefaults) {
          // For VComponents, use the Props class stashed in the metadata and instantiate
          // it in order to get the properties and default values.
          var defaultsInstance = new PropDefaults();
          defaults = Object.create(defaultsInstance);
        } else if (propertiesMetadata) {
          defaults = Object.create( // Adding the optional shouldFreeze param for definitional elements so we don't break
          // backwards compatibility, but our preference is to freeze the defaults and clone internally
          // where needed instead (e.g. dot notation sets).
          MetadataUtils.getDefaultValues(propertiesMetadata, shouldFreeze));
        }
      }

      constr['_staticDefaults'] = defaults;
    }

    return defaults;
  }

  DefaultsUtils.getStaticDefaults = getStaticDefaults; // Keep for oj-form-layout which is the only usage

  function applyDynamicDefaults(constr, props) {
    if (constr['getDynamicDefaults']) {
      var dynamicDefaults = constr['getDynamicDefaults']();

      if (dynamicDefaults) {
        // Dyanmic getters specified via the es6 get function() syntax
        // will be added to the object prototype instead of instance so we
        // use a for...in loop here instead of Object.keys
        // eslint-disable-next-line no-restricted-syntax
        for (var key in dynamicDefaults) {
          if (props[key] === undefined) {
            props[key] = dynamicDefaults[key];
          }
        }
      }
    }
  }

  DefaultsUtils.applyDynamicDefaults = applyDynamicDefaults;
})(DefaultsUtils || (DefaultsUtils = {}));

;return { DefaultsUtils: DefaultsUtils };
});
(function(){
'use strict';var h=new function(){};var aa=new Set("annotation-xml color-profile font-face font-face-src font-face-uri font-face-format font-face-name missing-glyph".split(" "));function m(b){var a=aa.has(b);b=/^[a-z][.0-9_a-z]*-[\-.0-9_a-z]*$/.test(b);return!a&&b}function n(b){var a=b.isConnected;if(void 0!==a)return a;for(;b&&!(b.__CE_isImportDocument||b instanceof Document);)b=b.parentNode||(window.ShadowRoot&&b instanceof ShadowRoot?b.host:void 0);return!(!b||!(b.__CE_isImportDocument||b instanceof Document))}
function p(b,a){for(;a&&a!==b&&!a.nextSibling;)a=a.parentNode;return a&&a!==b?a.nextSibling:null}
function t(b,a,c){c=c?c:new Set;for(var d=b;d;){if(d.nodeType===Node.ELEMENT_NODE){var e=d;a(e);var f=e.localName;if("link"===f&&"import"===e.getAttribute("rel")){d=e.import;if(d instanceof Node&&!c.has(d))for(c.add(d),d=d.firstChild;d;d=d.nextSibling)t(d,a,c);d=p(b,e);continue}else if("template"===f){d=p(b,e);continue}if(e=e.__CE_shadowRoot)for(e=e.firstChild;e;e=e.nextSibling)t(e,a,c)}d=d.firstChild?d.firstChild:p(b,d)}}function u(b,a,c){b[a]=c};function v(){this.a=new Map;this.s=new Map;this.f=[];this.b=!1}function ba(b,a,c){b.a.set(a,c);b.s.set(c.constructor,c)}function w(b,a){b.b=!0;b.f.push(a)}function x(b,a){b.b&&t(a,function(a){return y(b,a)})}function y(b,a){if(b.b&&!a.__CE_patched){a.__CE_patched=!0;for(var c=0;c<b.f.length;c++)b.f[c](a)}}function z(b,a){var c=[];t(a,function(b){return c.push(b)});for(a=0;a<c.length;a++){var d=c[a];1===d.__CE_state?b.connectedCallback(d):A(b,d)}}
function B(b,a){var c=[];t(a,function(b){return c.push(b)});for(a=0;a<c.length;a++){var d=c[a];1===d.__CE_state&&b.disconnectedCallback(d)}}
function C(b,a,c){c=c?c:{};var d=c.w||new Set,e=c.i||function(a){return A(b,a)},f=[];t(a,function(a){if("link"===a.localName&&"import"===a.getAttribute("rel")){var c=a.import;c instanceof Node&&(c.__CE_isImportDocument=!0,c.__CE_hasRegistry=!0);c&&"complete"===c.readyState?c.__CE_documentLoadHandled=!0:a.addEventListener("load",function(){var c=a.import;if(!c.__CE_documentLoadHandled){c.__CE_documentLoadHandled=!0;var f=new Set(d);f.delete(c);C(b,c,{w:f,i:e})}})}else f.push(a)},d);if(b.b)for(a=0;a<
f.length;a++)y(b,f[a]);for(a=0;a<f.length;a++)e(f[a])}
function A(b,a){if(void 0===a.__CE_state){var c=a.ownerDocument;if(c.defaultView||c.__CE_isImportDocument&&c.__CE_hasRegistry)if(c=b.a.get(a.localName)){c.constructionStack.push(a);var d=c.constructor;try{try{if(new d!==a)throw Error("The custom element constructor did not produce the element being upgraded.");}finally{c.constructionStack.pop()}}catch(r){throw a.__CE_state=2,r;}a.__CE_state=1;a.__CE_definition=c;if(c.attributeChangedCallback)for(c=c.observedAttributes,d=0;d<c.length;d++){var e=c[d],
f=a.getAttribute(e);null!==f&&b.attributeChangedCallback(a,e,null,f,null)}n(a)&&b.connectedCallback(a)}}}v.prototype.connectedCallback=function(b){var a=b.__CE_definition;a.connectedCallback&&a.connectedCallback.call(b)};v.prototype.disconnectedCallback=function(b){var a=b.__CE_definition;a.disconnectedCallback&&a.disconnectedCallback.call(b)};
v.prototype.attributeChangedCallback=function(b,a,c,d,e){var f=b.__CE_definition;f.attributeChangedCallback&&-1<f.observedAttributes.indexOf(a)&&f.attributeChangedCallback.call(b,a,c,d,e)};function D(b,a){this.c=b;this.a=a;this.b=void 0;C(this.c,this.a);"loading"===this.a.readyState&&(this.b=new MutationObserver(this.f.bind(this)),this.b.observe(this.a,{childList:!0,subtree:!0}))}function E(b){b.b&&b.b.disconnect()}D.prototype.f=function(b){var a=this.a.readyState;"interactive"!==a&&"complete"!==a||E(this);for(a=0;a<b.length;a++)for(var c=b[a].addedNodes,d=0;d<c.length;d++)C(this.c,c[d])};function ca(){var b=this;this.b=this.a=void 0;this.f=new Promise(function(a){b.b=a;b.a&&a(b.a)})}function F(b){if(b.a)throw Error("Already resolved.");b.a=void 0;b.b&&b.b(void 0)};function G(b){this.j=!1;this.c=b;this.o=new Map;this.l=function(b){return b()};this.g=!1;this.m=[];this.u=new D(b,document)}
G.prototype.define=function(b,a){var c=this;if(!(a instanceof Function))throw new TypeError("Custom element constructors must be functions.");if(!m(b))throw new SyntaxError("The element name '"+b+"' is not valid.");if(this.c.a.get(b))throw Error("A custom element with name '"+b+"' has already been defined.");if(this.j)throw Error("A custom element is already being defined.");this.j=!0;var d,e,f,r,k;try{var g=function(b){var a=l[b];if(void 0!==a&&!(a instanceof Function))throw Error("The '"+b+"' callback must be a function.");
return a},l=a.prototype;if(!(l instanceof Object))throw new TypeError("The custom element constructor's prototype is not an object.");d=g("connectedCallback");e=g("disconnectedCallback");f=g("adoptedCallback");r=g("attributeChangedCallback");k=a.observedAttributes||[]}catch(q){return}finally{this.j=!1}a={localName:b,constructor:a,connectedCallback:d,disconnectedCallback:e,adoptedCallback:f,attributeChangedCallback:r,observedAttributes:k,constructionStack:[]};ba(this.c,b,a);this.m.push(a);this.g||
(this.g=!0,this.l(function(){return da(c)}))};G.prototype.i=function(b){C(this.c,b)};function da(b){if(!1!==b.g){b.g=!1;for(var a=b.m,c=[],d=new Map,e=0;e<a.length;e++)d.set(a[e].localName,[]);C(b.c,document,{i:function(a){if(void 0===a.__CE_state){var e=a.localName,f=d.get(e);f?f.push(a):b.c.a.get(e)&&c.push(a)}}});for(e=0;e<c.length;e++)A(b.c,c[e]);for(;0<a.length;){for(var f=a.shift(),e=f.localName,f=d.get(f.localName),r=0;r<f.length;r++)A(b.c,f[r]);(e=b.o.get(e))&&F(e)}}}
G.prototype.get=function(b){if(b=this.c.a.get(b))return b.constructor};G.prototype.whenDefined=function(b){if(!m(b))return Promise.reject(new SyntaxError("'"+b+"' is not a valid custom element name."));var a=this.o.get(b);if(a)return a.f;a=new ca;this.o.set(b,a);this.c.a.get(b)&&!this.m.some(function(a){return a.localName===b})&&F(a);return a.f};G.prototype.v=function(b){E(this.u);var a=this.l;this.l=function(c){return b(function(){return a(c)})}};window.CustomElementRegistry=G;
G.prototype.define=G.prototype.define;G.prototype.upgrade=G.prototype.i;G.prototype.get=G.prototype.get;G.prototype.whenDefined=G.prototype.whenDefined;G.prototype.polyfillWrapFlushCallback=G.prototype.v;var H=window.Document.prototype.createElement,I=window.Document.prototype.createElementNS,ea=window.Document.prototype.importNode,fa=window.Document.prototype.prepend,ga=window.Document.prototype.append,ha=window.DocumentFragment.prototype.prepend,ia=window.DocumentFragment.prototype.append,J=window.Node.prototype.cloneNode,K=window.Node.prototype.appendChild,L=window.Node.prototype.insertBefore,M=window.Node.prototype.removeChild,N=window.Node.prototype.replaceChild,O=Object.getOwnPropertyDescriptor(window.Node.prototype,
"textContent"),P=window.Element.prototype.attachShadow,Q=Object.getOwnPropertyDescriptor(window.Element.prototype,"innerHTML"),R=window.Element.prototype.getAttribute,S=window.Element.prototype.setAttribute,T=window.Element.prototype.removeAttribute,U=window.Element.prototype.getAttributeNS,ja=window.Element.prototype.setAttributeNS,ka=window.Element.prototype.removeAttributeNS,la=window.Element.prototype.insertAdjacentElement,ma=window.Element.prototype.insertAdjacentHTML,na=window.Element.prototype.prepend,
oa=window.Element.prototype.append,V=window.Element.prototype.before,pa=window.Element.prototype.after,qa=window.Element.prototype.replaceWith,ra=window.Element.prototype.remove,sa=window.HTMLElement,W=Object.getOwnPropertyDescriptor(window.HTMLElement.prototype,"innerHTML"),ta=window.HTMLElement.prototype.insertAdjacentElement,ua=window.HTMLElement.prototype.insertAdjacentHTML;function va(){var b=X;window.HTMLElement=function(){function a(){var a=this.constructor,d=b.s.get(a);if(!d)throw Error("The custom element being constructed was not registered with `customElements`.");var e=d.constructionStack;if(!e.length)return e=H.call(document,d.localName),Object.setPrototypeOf(e,a.prototype),e.__CE_state=1,e.__CE_definition=d,y(b,e),e;var d=e.length-1,f=e[d];if(f===h)throw Error("The HTMLElement constructor was either called reentrantly for this constructor or called multiple times.");
e[d]=h;Object.setPrototypeOf(f,a.prototype);y(b,f);return f}a.prototype=sa.prototype;Object.defineProperty(a.prototype,"constructor",{writable:!0,configurable:!0,enumerable:!1,value:a});return a}()};function Y(b,a,c){function d(a){return function(c){for(var e=[],d=0;d<arguments.length;++d)e[d-0]=arguments[d];for(var d=[],f=[],l=0;l<e.length;l++){var q=e[l];q instanceof Element&&n(q)&&f.push(q);if(q instanceof DocumentFragment)for(q=q.firstChild;q;q=q.nextSibling)d.push(q);else d.push(q)}a.apply(this,e);for(e=0;e<f.length;e++)B(b,f[e]);if(n(this))for(e=0;e<d.length;e++)f=d[e],f instanceof Element&&z(b,f)}}c.h&&(a.prepend=d(c.h));c.append&&(a.append=d(c.append))};function wa(){var b=X;u(Document.prototype,"createElement",function(a){if(this.__CE_hasRegistry){var c=b.a.get(a);if(c)return new c.constructor}a=H.call(this,a);y(b,a);return a});u(Document.prototype,"importNode",function(a,c){a=ea.call(this,a,c);this.__CE_hasRegistry?C(b,a):x(b,a);return a});u(Document.prototype,"createElementNS",function(a,c){if(this.__CE_hasRegistry&&(null===a||"http://www.w3.org/1999/xhtml"===a)){var d=b.a.get(c);if(d)return new d.constructor}a=I.call(this,a,c);y(b,a);return a});
Y(b,Document.prototype,{h:fa,append:ga})};function xa(){var b=X;function a(a,d){Object.defineProperty(a,"textContent",{enumerable:d.enumerable,configurable:!0,get:d.get,set:function(a){if(this.nodeType===Node.TEXT_NODE)d.set.call(this,a);else{var e=void 0;if(this.firstChild){var c=this.childNodes,k=c.length;if(0<k&&n(this))for(var e=Array(k),g=0;g<k;g++)e[g]=c[g]}d.set.call(this,a);if(e)for(a=0;a<e.length;a++)B(b,e[a])}}})}u(Node.prototype,"insertBefore",function(a,d){if(a instanceof DocumentFragment){var e=Array.prototype.slice.apply(a.childNodes);
a=L.call(this,a,d);if(n(this))for(d=0;d<e.length;d++)z(b,e[d]);return a}e=n(a);d=L.call(this,a,d);e&&B(b,a);n(this)&&z(b,a);return d});u(Node.prototype,"appendChild",function(a){if(a instanceof DocumentFragment){var c=Array.prototype.slice.apply(a.childNodes);a=K.call(this,a);if(n(this))for(var e=0;e<c.length;e++)z(b,c[e]);return a}c=n(a);e=K.call(this,a);c&&B(b,a);n(this)&&z(b,a);return e});u(Node.prototype,"cloneNode",function(a){a=J.call(this,a);this.ownerDocument.__CE_hasRegistry?C(b,a):x(b,a);
return a});u(Node.prototype,"removeChild",function(a){var c=n(a),e=M.call(this,a);c&&B(b,a);return e});u(Node.prototype,"replaceChild",function(a,d){if(a instanceof DocumentFragment){var e=Array.prototype.slice.apply(a.childNodes);a=N.call(this,a,d);if(n(this))for(B(b,d),d=0;d<e.length;d++)z(b,e[d]);return a}var e=n(a),f=N.call(this,a,d),c=n(this);c&&B(b,d);e&&B(b,a);c&&z(b,a);return f});O&&O.get?a(Node.prototype,O):w(b,function(b){a(b,{enumerable:!0,configurable:!0,get:function(){for(var a=[],b=
0;b<this.childNodes.length;b++)a.push(this.childNodes[b].textContent);return a.join("")},set:function(a){for(;this.firstChild;)M.call(this,this.firstChild);K.call(this,document.createTextNode(a))}})})};function ya(b){var a=Element.prototype;function c(a){return function(e){for(var c=[],d=0;d<arguments.length;++d)c[d-0]=arguments[d];for(var d=[],k=[],g=0;g<c.length;g++){var l=c[g];l instanceof Element&&n(l)&&k.push(l);if(l instanceof DocumentFragment)for(l=l.firstChild;l;l=l.nextSibling)d.push(l);else d.push(l)}a.apply(this,c);for(c=0;c<k.length;c++)B(b,k[c]);if(n(this))for(c=0;c<d.length;c++)k=d[c],k instanceof Element&&z(b,k)}}V&&(a.before=c(V));V&&(a.after=c(pa));qa&&u(a,"replaceWith",function(a){for(var e=
[],c=0;c<arguments.length;++c)e[c-0]=arguments[c];for(var c=[],d=[],k=0;k<e.length;k++){var g=e[k];g instanceof Element&&n(g)&&d.push(g);if(g instanceof DocumentFragment)for(g=g.firstChild;g;g=g.nextSibling)c.push(g);else c.push(g)}k=n(this);qa.apply(this,e);for(e=0;e<d.length;e++)B(b,d[e]);if(k)for(B(b,this),e=0;e<c.length;e++)d=c[e],d instanceof Element&&z(b,d)});ra&&u(a,"remove",function(){var a=n(this);ra.call(this);a&&B(b,this)})};function za(){var b=X;function a(a,c){Object.defineProperty(a,"innerHTML",{enumerable:c.enumerable,configurable:!0,get:c.get,set:function(a){var e=this,d=void 0;n(this)&&(d=[],t(this,function(a){a!==e&&d.push(a)}));c.set.call(this,a);if(d)for(var f=0;f<d.length;f++){var r=d[f];1===r.__CE_state&&b.disconnectedCallback(r)}this.ownerDocument.__CE_hasRegistry?C(b,this):x(b,this);return a}})}function c(a,c){u(a,"insertAdjacentElement",function(a,e){var d=n(e);a=c.call(this,a,e);d&&B(b,e);n(a)&&z(b,e);
return a})}function d(a,c){function e(a,e){for(var c=[];a!==e;a=a.nextSibling)c.push(a);for(e=0;e<c.length;e++)C(b,c[e])}u(a,"insertAdjacentHTML",function(a,b){a=a.toLowerCase();if("beforebegin"===a){var d=this.previousSibling;c.call(this,a,b);e(d||this.parentNode.firstChild,this)}else if("afterbegin"===a)d=this.firstChild,c.call(this,a,b),e(this.firstChild,d);else if("beforeend"===a)d=this.lastChild,c.call(this,a,b),e(d||this.firstChild,null);else if("afterend"===a)d=this.nextSibling,c.call(this,
a,b),e(this.nextSibling,d);else throw new SyntaxError("The value provided ("+String(a)+") is not one of 'beforebegin', 'afterbegin', 'beforeend', or 'afterend'.");})}P&&u(Element.prototype,"attachShadow",function(a){return this.__CE_shadowRoot=a=P.call(this,a)});Q&&Q.get?a(Element.prototype,Q):W&&W.get?a(HTMLElement.prototype,W):w(b,function(b){a(b,{enumerable:!0,configurable:!0,get:function(){return J.call(this,!0).innerHTML},set:function(a){var b="template"===this.localName,e=b?this.content:this,
c=I.call(document,this.namespaceURI,this.localName);for(c.innerHTML=a;0<e.childNodes.length;)M.call(e,e.childNodes[0]);for(a=b?c.content:c;0<a.childNodes.length;)K.call(e,a.childNodes[0])}})});u(Element.prototype,"setAttribute",function(a,c){if(1!==this.__CE_state)return S.call(this,a,c);var e=R.call(this,a);S.call(this,a,c);c=R.call(this,a);b.attributeChangedCallback(this,a,e,c,null)});u(Element.prototype,"setAttributeNS",function(a,c,d){if(1!==this.__CE_state)return ja.call(this,a,c,d);var e=U.call(this,
a,c);ja.call(this,a,c,d);d=U.call(this,a,c);b.attributeChangedCallback(this,c,e,d,a)});u(Element.prototype,"removeAttribute",function(a){if(1!==this.__CE_state)return T.call(this,a);var c=R.call(this,a);T.call(this,a);null!==c&&b.attributeChangedCallback(this,a,c,null,null)});u(Element.prototype,"removeAttributeNS",function(a,c){if(1!==this.__CE_state)return ka.call(this,a,c);var d=U.call(this,a,c);ka.call(this,a,c);var e=U.call(this,a,c);d!==e&&b.attributeChangedCallback(this,c,d,e,a)});ta?c(HTMLElement.prototype,
ta):la?c(Element.prototype,la):console.warn("Custom Elements: `Element#insertAdjacentElement` was not patched.");ua?d(HTMLElement.prototype,ua):ma?d(Element.prototype,ma):console.warn("Custom Elements: `Element#insertAdjacentHTML` was not patched.");Y(b,Element.prototype,{h:na,append:oa});ya(b)};/*

 Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 Code distributed by Google as part of the polymer project is also
 subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
var Z=window.customElements;if(!Z||Z.forcePolyfill||"function"!=typeof Z.define||"function"!=typeof Z.get){var X=new v;va();wa();Y(X,DocumentFragment.prototype,{h:ha,append:ia});xa();za();document.__CE_hasRegistry=!0;var customElements=new G(X);Object.defineProperty(window,"customElements",{configurable:!0,enumerable:!0,value:customElements})};
}).call(self);

//# sourceMappingURL=custom-elements.min.js.map
;
define("customElements", function(){});

/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojcustomelement',['ojs/ojcore', 'require', 'ojs/ojlogger', 'ojs/ojcontext', 'ojs/ojmetadatautils', 'customElements'],
  function(oj, require, Logger, Context, MetadataUtils)
{
  "use strict";
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }



/* global Promise:false, Set:false, Logger:false, Context:false */

/**
 * Custom element bridge prototype.
 *
 * @class
 * @ignore
 */
oj.BaseCustomElementBridge = {};
/**
 * Prototype for subclasses
 * @ignore
 */

oj.BaseCustomElementBridge.proto = {
  getClass: function getClass(descriptor) {
    var proto = Object.create(HTMLElement.prototype);
    this.InitializePrototype(proto);
    var metadata = this.GetMetadata(descriptor); // Enumerate metadata to define the prototype properties, methods, and events

    oj.BaseCustomElementBridge._enumerateMetadataForKey(proto, metadata, 'properties', this.DefinePropertyCallback.bind(this));

    oj.BaseCustomElementBridge._enumerateMetadataForKey(proto, metadata, 'methods', this.DefineMethodCallback.bind(this)); // Add additional element methods not defined in metadata, e.g. getNodeBySubId/getSubIdByNode or get/setProperty


    this.AddComponentMethods(proto);

    proto.setProperties = function (props) {
      oj.BaseCustomElementBridge.getInstance(this)._setProperties(this, props);
    }; // The set/unset methods are used for TypeScript only so we should define these as non enumerated properties


    Object.defineProperty(proto, 'set', {
      value: function value(prop, _value2) {
        this.setProperty(prop, _value2);
      }
    });
    Object.defineProperty(proto, 'unset', {
      value: function value(prop) {
        this.setProperty(prop, undefined);
      }
    }); // Add lifecycle listeners

    proto.attributeChangedCallback = this.AttributeChangedCallback;
    proto.connectedCallback = this._connectedCallback;
    proto.disconnectedCallback = this._detachedCallback;

    var constructorFunc = function constructorFunc() {
      var reflect = window.Reflect;
      var ret;

      if (typeof reflect !== 'undefined') {
        ret = reflect.construct(HTMLElement, [], this.constructor);
      } else {
        ret = HTMLElement.call(this);
      }

      return ret;
    };

    var bridge = this;
    Object.defineProperty(constructorFunc, 'observedAttributes', {
      get: function get() {
        return bridge.GetAttributes(metadata);
      }
    });
    Object.defineProperty(proto, 'constructor', {
      value: constructorFunc,
      writable: true,
      configurable: true
    });
    constructorFunc.prototype = proto;
    Object.setPrototypeOf(constructorFunc, HTMLElement);
    return constructorFunc;
  },
  playbackEarlyPropertySets: function playbackEarlyPropertySets(element) {
    this._bCanSetProperty = true;
    this.PlaybackEarlyPropertySets(element);
  },
  resolveBindingProvider: function resolveBindingProvider(provider) {
    if (this._bpResolve) {
      this._bpResolve(provider);
    } else {
      this._bpInst = provider;
    }
  },
  disposeBindingProvider: function disposeBindingProvider(element) {
    this._bDisposed = true;

    if (!this._complete && this._bConnected) {
      // The creation busy state is normally resolved upon component creation.
      // In the event that a component is disposed or disconnected before
      // creation, the busy state will be resolved by the first of the
      // disposal or disconnected callbacks that gets invoked.
      this._resolveBusyState(element);
    }
  },
  resolveDelayedReadyPromise: function resolveDelayedReadyPromise() {
    this.GetDelayedReadyPromise().resolvePromise();
  },
  whenCreated: function whenCreated() {
    return this._whenCreatedPromise;
  },
  // eslint-disable-next-line no-unused-vars
  AddComponentMethods: function AddComponentMethods(proto) {},
  AttributeChangedCallback: function AttributeChangedCallback(attr, oldValue, newValue) {
    // The browser triggers this callback even if old and new values are the same
    // so we should do an equality check ourselves to prevent extra work
    if (oldValue !== newValue) {
      var bridge = oj.BaseCustomElementBridge.getInstance(this); // Due to  where IE11 disables child inputs for a parent with the disabled attribute,
      // we will remove the disabled attribute after we save the value and will ignore all disabled
      // attribute sets after component initialization when the application can just as easily use the property
      // setter instead. Expressions will be handled in the CustomElementBinding.

      if (attr === 'disabled' && bridge.ShouldRemoveDisabled() && bridge._isDisabledAttributeRemoved()) {
        // Always remove the disabled attribute even after component initialization and log warning.
        // A null value indicates that the value was removed already.
        if (newValue != null) {
          Logger.warn("Ignoring 'disabled' attribute change after component initialization. Use element property setter instead.");

          bridge._removeDisabledAttribute(this);
        }

        return;
      }

      if (bridge.ShouldHandleAttributeChanged(this)) {
        var prop = oj.__AttributeUtils.attributeToPropertyName(attr);

        var propMeta = oj.BaseCustomElementBridge.__GetPropertyMetadata(prop, oj.BaseCustomElementBridge.getProperties(bridge));

        oj.BaseCustomElementBridge.__CheckOverlappingAttribute(this, attr); // removeAttribute calls return null as the newValue which we want to treat as
        // a property unset and convert to undefined. We allow property null sets as an
        // actual property override.


        if (newValue === null) {
          // eslint-disable-next-line no-param-reassign
          newValue = undefined;
        }

        var params = {
          detail: {
            attribute: attr,
            value: newValue,
            previousValue: oldValue
          }
        };
        this.dispatchEvent(new CustomEvent('attribute-changed', params));

        var expression = oj.__AttributeUtils.getExpressionInfo(newValue).expr;

        if (!expression) {
          if (propMeta) {
            this.setProperty(prop, oj.BaseCustomElementBridge.__ParseAttrValue(this, attr, prop, newValue, propMeta));
          } // This allows subclasses to handle special cases like global transfer
          // attributes for JET components or controlled properties for virtual components


          bridge.HandleAttributeChanged(this, attr, oldValue, newValue);
        }
      }
    }
  },
  // eslint-disable-next-line no-unused-vars
  CreateComponent: function CreateComponent(element) {},
  // eslint-disable-next-line no-unused-vars
  DefineMethodCallback: function DefineMethodCallback(proto, method, methodMeta) {},
  // eslint-disable-next-line no-unused-vars
  DefinePropertyCallback: function DefinePropertyCallback(proto, property, propertyMeta) {},

  /**
   * Returns a promise that will be resolved when the component has been initialized.
   * @return {Promise}
   */
  GetDelayedReadyPromise: function GetDelayedReadyPromise() {
    if (!this._delayedReady) {
      this._delayedReady = new oj.BaseCustomElementBridge.__DelayedPromise();
    }

    return this._delayedReady;
  },
  GetAttributes: function GetAttributes(metadata) {
    return metadata ? oj.BaseCustomElementBridge.getAttributes(metadata.properties) : [];
  },
  GetMetadata: function GetMetadata(descriptor) {
    return descriptor[oj.BaseCustomElementBridge.DESC_KEY_META] || {};
  },

  /**
   * Returns the aliased component property for a given custom element property,
   * e.g. readOnly for oj-switch's readonly custom element property.
   * Will return the original property if there is no aliasing.
   * @param {string} property The property to check
   */
  GetAliasForProperty: function GetAliasForProperty(property) {
    return property;
  },
  // eslint-disable-next-line no-unused-vars
  GetTrackChildrenOption: function GetTrackChildrenOption(element) {
    return this.METADATA.extension && this.METADATA.extension._TRACK_CHILDREN ? this.METADATA.extension._TRACK_CHILDREN : 'none';
  },

  /**
   * Tests whether attribute changed processing should be performed.
   */
  // eslint-disable-next-line no-unused-vars
  ShouldHandleAttributeChanged: function ShouldHandleAttributeChanged(element) {
    return this._bCreateCalled;
  },

  /**
   * Tests whether the HandleAttributeChanged callback should be called.
   * This is only needed in the VirtualElementBridge case when a VComponent
   * is patching and updates a controlled property on the root element which we
   * want to update our internal _CONTROLLED_PROPS object with, but not cause a
   * rerender.
   */
  // eslint-disable-next-line no-unused-vars
  ShouldCallHandleAttributeChanged: function ShouldCallHandleAttributeChanged(element) {
    return this.ShouldHandleAttributeChanged();
  },
  // eslint-disable-next-line no-unused-vars
  HandleAttributeChanged: function HandleAttributeChanged(element, attr, oldValue, newValue) {},
  // eslint-disable-next-line no-unused-vars
  HandleBindingsApplied: function HandleBindingsApplied(element, bindingContext) {},
  // eslint-disable-next-line no-unused-vars
  HandleDetached: function HandleDetached(element) {},
  // eslint-disable-next-line no-unused-vars
  HandleReattached: function HandleReattached(element) {},
  // eslint-disable-next-line no-unused-vars
  InitializeElement: function InitializeElement(element) {},
  // eslint-disable-next-line no-unused-vars
  InitializePrototype: function InitializePrototype(proto) {},
  BatchedPropertySet: function BatchedPropertySet(elem, props) {
    var keys = Object.keys(props);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      elem.setProperty(key, props[key]);
    }
  },
  GetEventListenerProperty: function GetEventListenerProperty(property) {
    var event = oj.__AttributeUtils.eventListenerPropertyToEventType(property); // Get event listener


    var eventListener = this._eventListeners[event];

    if (eventListener) {
      return eventListener.getListener();
    }

    return undefined;
  },
  GetProperty: function GetProperty(element, prop, props) {
    var event = oj.__AttributeUtils.eventListenerPropertyToEventType(prop);

    var meta = oj.BaseCustomElementBridge.__GetPropertyMetadata(prop, oj.BaseCustomElementBridge.getProperties(this)); // For event listener and non component properties, retrieve the value directly stored on the element.
    // For top level properties, this will delegate to our 'set' methods so we can handle default values.
    // props is the properties object we pass the definitional element or composite ViewModel


    if (event || !meta || prop.indexOf('.') === -1) {
      return props[prop];
    }

    return oj.BaseCustomElementBridge.__GetProperty(props, prop);
  },
  InitializeBridge: function InitializeBridge(element, descriptor) {
    // Initialize property storage and other variables needed for property sets.
    // Since early property sets can occur before the element's connected callback
    // is triggered we can't rely on performing this logic there. The cases where
    // the connected callback isn't called before a property set can occur if the
    // custom element is programatically created and sets are done before adding
    // the element to the DOM or if the element is stamped by knockout and its expressions
    // processed disconnected as in the case for oj-bind-for-each.
    this.METADATA = this.GetMetadata(descriptor);
    this._eventListeners = {};
  },
  PlaybackEarlyPropertySets: function PlaybackEarlyPropertySets(element) {
    if (this._earlySets) {
      while (this._earlySets.length) {
        var setObj = this._earlySets.shift();

        element.setProperty(setObj.property, setObj.value);
      }
    }
  },

  /**
   * Returns true if this property set was handled as an early property set.
   * An early property set is any set that occurs before the component is created.
   * These sets do not trigger [property]Changed events.
   * @param {string} prop
   * @param {any} value
   * @return {boolean}
   */
  SaveEarlyPropertySet: function SaveEarlyPropertySet(prop, value) {
    // Do not save sets that occur during oj.BaseCustomElementBridge.__InitProperties
    // or expression evaluation. We can process these as normal. Playback occurs before the
    // binding provider promise is resolved leading to component creation.
    if (this.__INITIALIZING_PROPS || this._bCanSetProperty) {
      return false;
    }

    if (!this._earlySets) {
      this._earlySets = [];
    }

    this._earlySets.push({
      property: prop,
      value: value
    });

    return true;
  },
  SetEventListenerProperty: function SetEventListenerProperty(element, property, value) {
    var event = oj.__AttributeUtils.eventListenerPropertyToEventType(property); // Get event listener


    var eventListener = this._eventListeners[event];

    if (!eventListener) {
      // Create the wrapper
      eventListener = this._createEventListenerWrapper();
      this._eventListeners[event] = eventListener;
      element.addEventListener(event, eventListener);
    }

    if (value == null || value instanceof Function) {
      eventListener.setListener(value);
    } else {
      oj.BaseCustomElementBridge.__ThrowTypeError(element, property, value, 'function');
    }
  },
  SetProperty: function SetProperty(element, prop, value, props, bOuter) {
    // Check value against any defined enums
    var event = oj.__AttributeUtils.eventListenerPropertyToEventType(prop);

    var meta = oj.BaseCustomElementBridge.__GetPropertyMetadata(prop, oj.BaseCustomElementBridge.getProperties(this));

    if (event || !meta) {
      // eslint-disable-next-line no-param-reassign
      element[prop] = value;
    } else {
      // props is the properties object we pass the definitional element or composite ViewModel
      var previousValue = element.getProperty(prop);
      var propPath = prop.split('.');
      var topProp = propPath[0]; // If the top level property is an object, make a copy otherwise the old/new values
      // will be the same.

      var topPropPrevValue = props[topProp];

      if (oj.CollectionUtils.isPlainObject(topPropPrevValue)) {
        topPropPrevValue = oj.CollectionUtils.copyInto({}, topPropPrevValue, undefined, true);
      }

      if (!oj.BaseCustomElementBridge.__CompareOptionValues(prop, meta, value, previousValue)) {
        var isSubprop = prop.indexOf('.') !== -1;

        if (isSubprop) {
          // Set a flag for the case a subproperty results in a set of the top level property
          // which was not instantiated to an empty object to avoid firing two events.
          this._SKIP_PROP_CHANGE_EVENT = true;
        }

        if (bOuter) {
          // This ultimately triggers our element defined property setter
          this.ValidateAndSetProperty(this.GetAliasForProperty.bind(this), props, prop, value, element);
        } else {
          // Skip validation for inner sets so we don't throw an error when updating readOnly writeable properties
          oj.BaseCustomElementBridge.__SetProperty(this.GetAliasForProperty.bind(this), props, prop, value);
        }

        this._SKIP_PROP_CHANGE_EVENT = false; // Property change events for top level properties will be triggered by ValidateAndSetProperty so avoid firing twice

        if (isSubprop) {
          var subprop = {};
          subprop.path = prop;
          subprop.value = value;
          subprop.previousValue = previousValue; // Pass the top level property value/previousValues

          var updatedFrom = bOuter ? 'external' : 'internal';

          oj.BaseCustomElementBridge.__FirePropertyChangeEvent(element, topProp, props[topProp], topPropPrevValue, updatedFrom, subprop);
        }

        return {
          property: topProp,
          propertySet: true,
          isSubproperty: isSubprop
        };
      }
    } // We return true if a component property is updated with a different value and false
    // for other cases like on[Event] property updates


    return {
      property: null,
      propertySet: false,
      isSubproperty: false
    };
  },
  ShouldRemoveDisabled: function ShouldRemoveDisabled() {
    // Subclasses should override if the disabled attribute shouldn't be unconditionally removed
    // from the DOM, e.g. definitional and composite components
    return true;
  },
  ValidateAndSetProperty: function ValidateAndSetProperty(propNameFun, componentProps, property, value, element) {
    var _value = this.ValidatePropertySet(element, property, value);

    oj.BaseCustomElementBridge.__SetProperty(propNameFun, componentProps, property, _value);
  },
  ValidatePropertySet: function ValidatePropertySet(element, property, value) {
    var propsMeta = oj.BaseCustomElementBridge.getProperties(this);

    var propMeta = oj.BaseCustomElementBridge.__GetPropertyMetadata(property, propsMeta);

    var propAr = property.split('.');

    if (!propMeta) {
      Logger.warn(oj.BaseCustomElementBridge.getElementInfo(element) + ": Ignoring property set for undefined property '" + property + "'.");
      return undefined;
    } // Check readOnly property for top level property


    if (propsMeta[propAr[0]].readOnly) {
      this.throwError(element, "Read-only property '" + property + "' cannot be set.");
    }

    oj.BaseCustomElementBridge.checkEnumValues(element, property, value, propMeta); // TODO support checking for null values once we generate metadata from jsDoc and have accurate info
    // about component support for undefined/null

    if (value != null) {
      return oj.BaseCustomElementBridge.checkType(element, property, value, propMeta);
    }

    return value;
  },
  GetPreCreatePromise: function GetPreCreatePromise(element) {
    var preCreatePromise = this._getBindingProvider(element);

    var trackOption = oj.BaseCustomElementBridge.getTrackChildrenOption(element);

    if (trackOption !== 'none') {
      // this will return a promise that will get automatically chained to the binding provider promise
      preCreatePromise = preCreatePromise.then(function (bindingProvider) {
        return this._whenChildrenCreated(element, bindingProvider);
      }.bind(this));
    }

    return preCreatePromise;
  },
  PostCreate: function PostCreate(element) {
    // After parsing the DOM attribute values and initializing properties, remove the disabled
    // property if it exists due to 
    if (element.hasAttribute('disabled') && this.ShouldRemoveDisabled() && !this._isDisabledAttributeRemoved()) {
      this._removeDisabledAttribute(element);
    }
  },
  _connected: function _connected(element) {
    this._bConnected = true;

    if (!this._bCreateCalled) {
      // initial attach
      this._bCreateCalled = true;

      this._registerBusyState(element);

      this._monitorReadyPromise(element);

      this.InitializeElement(element);
      var self = this;

      var createComponentCallback = function createComponentCallback() {
        try {
          // Short circuit component creation if disposed.
          // The state of the various flags are being reset here, but that's
          // not critical because attempting to reconnect a disposed node
          // is an invalid use case.
          //
          // The create flag is reset here.  Busy states will have been
          // resolved in the disposal (or disconnect) callback.
          if (!self._bDisposed) {
            self.CreateComponent(element);
            self.PostCreate(element);
          } else {
            // Reset the create flag
            self._bCreateCalled = false;
          }
        } catch (ex) {
          // If an error occurs during component creation, resolve the busy context and throw an error.
          self.throwError(element, 'Error while rendering component.', ex);
        }
      };

      this._whenCreatedPromise = this.GetPreCreatePromise(element).then(createComponentCallback);
    } else if (!this._complete) {
      // If the component had been previously disconnected, and the 'ready'
      // promise is still not resolved, we need to re-register the busy state
      this._registerBusyState(element);
    } else {
      this.HandleReattached(element);
    }
  },
  _connectedCallback: function _connectedCallback() {
    var bridge = oj.BaseCustomElementBridge.getInstance(this);

    bridge._connected(this);
  },
  _detachedCallback: function _detachedCallback() {
    var bridge = oj.BaseCustomElementBridge.getInstance(this);
    bridge._bConnected = false;

    if (!bridge._complete) {
      if (!bridge._bDisposed) {
        // The creation busy state is normally resolved upon component creation.
        // In the event that a component is disposed or disconnected before
        // creation, the busy state will be resolved by the first of the
        // disposal or disconnected callbacks that gets invoked.
        bridge._resolveBusyState(this);
      }
    } else {
      bridge.HandleDetached(this);
    }
  },
  // This wrapper does not provide any additional functionality to event listener functions
  // It exists solely to preserve event listener order
  _createEventListenerWrapper: function _createEventListenerWrapper() {
    var eventListener;

    var domListener = function domListener(event) {
      if (eventListener) {
        eventListener(event);
      }
    };

    domListener.setListener = function (listener) {
      eventListener = listener;
    };

    domListener.getListener = function () {
      return eventListener;
    };

    return domListener;
  },
  _monitorReadyPromise: function _monitorReadyPromise(element) {
    var self = this;

    var completeHandler = function completeHandler() {
      // If the component is disconnected, the busy state
      // must be already resolved
      if (!self._complete && self._bConnected) {
        self._resolveBusyState(element);

        self._complete = true;
      }
    };

    this.GetDelayedReadyPromise().getPromise().then(function () {
      // Add marker class to unhide components
      element.classList.add('oj-complete');
      completeHandler();
    }, function () {
      // Add marker class to mark that there was an error duing upgrade so consumers like
      // VBCS can apply their own styling to incorrectly setup custom elements.
      element.classList.add('oj-incomplete');
      completeHandler();
    });
  },
  _registerBusyState: function _registerBusyState(element) {
    var busyContext = Context.getContext(element).getBusyContext();
    this._initCompleteCallback = busyContext.addBusyState({
      description: oj.BaseCustomElementBridge.getElementInfo(element) + ' is being upgraded.'
    });
  },
  _resolveBusyState: function _resolveBusyState(element) {
    var callback = this._initCompleteCallback;

    if (!callback) {
      this.throwError(element, 'Unexpected call to _resolveBusyState().');
    }

    this._initCompleteCallback = null;
    callback();
  },
  _setProperties: function _setProperties(elem, props) {
    var mutationKeys = []; // keys for the 'dot mutation' properties

    var regularProps = {}; // the rest of the properties

    var hasRegularProps = false;
    var keys = Object.keys(props);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];

      if (key.indexOf('.') >= 0) {
        mutationKeys.push(key);
      } else {
        regularProps[key] = props[key];
        hasRegularProps = true;
      }
    } // Regular property updates may be batched


    if (hasRegularProps) {
      this.BatchedPropertySet(elem, regularProps);
    } // 'Dot notation' properties can only be set individually for now


    for (var p = 0; p < mutationKeys.length; p++) {
      var mkey = mutationKeys[p];
      elem.setProperty(mkey, props[mkey]);
    }
  },

  /**
   * Throws new error.
   * @ignore
   * @param {Element} elem The element that reports an error
   * @param {string} msg Error message
   * @param {Error=} origErr Original error whose stack should be preserved
   */
  throwError: function throwError(elem, msg, origErr) {
    this.GetDelayedReadyPromise().rejectPromise();
    var errMsg = oj.BaseCustomElementBridge.getElementInfo(elem) + ': ' + msg;

    if (origErr) {
      // The error.stack feature is considered non-standard,
      // but all the browsers support it according to caniuse:
      // https://caniuse.com/#feat=mdn-javascript_builtins_error_stack
      errMsg = errMsg + ' ' + (origErr.stack ? origErr.stack : origErr);
    }

    throw new Error(errMsg);
  },
  _setBpResolver: function _setBpResolver(resolve) {
    this._bpResolve = resolve;
  },
  _getBindingProvider: function _getBindingProvider(element) {
    var name = this._getBindingProviderName(element);

    if (name === oj.BaseCustomElementBridge._NO_BINDING_PROVIDER) {
      this.playbackEarlyPropertySets(element);
      return Promise.resolve(null);
    } else if (name === 'knockout') {
      if (this._bpInst) {
        return Promise.resolve(this._bpInst);
      }

      return new Promise(this._setBpResolver.bind(this));
    }

    this.throwError(element, "Unknown binding provider '" + name + "'.");
    return undefined; // not reachable but eslint is too stupid to figure that out.
  },
  _getBindingProviderName: function _getBindingProviderName(element) {
    var cachedProp = '_ojBndgPrv';
    var name = element[cachedProp];

    if (name) {
      return name;
    }

    name = element.getAttribute('data-oj-binding-provider') || oj.BaseCustomElementBridge._getCompositeBindingProviderName(element);

    if (!name) {
      var parent = element.parentElement;

      if (parent == null) {
        if (element === document.documentElement) {
          name = 'knockout'; // the default
        } else {
          this.throwError(element, 'Cannot determine binding provider for a disconnected subtree.');
        }
      } else if (parent._vcomp) {
        // Content rendered by a VComponent parent does not get processed
        // by any binding provider.
        name = oj.BaseCustomElementBridge._NO_BINDING_PROVIDER;
      } else {
        name = this._getBindingProviderName(parent);
      }
    } // cache provider name as a non-enumerable property


    Object.defineProperty(element, cachedProp, {
      value: name
    });
    return name;
  },
  // used by _whenChildrenCreated() call - called for trackOption "immediate" or "nearestCustomElement"
  _getChildrenToTrack: function _getChildrenToTrack(element, trackOption, trackedElements) {
    var children = element.childNodes;

    for (var i = 0; i < children.length; i++) {
      var child = children[i];

      if (oj.ElementUtils.isValidCustomElementName(child.localName)) {
        trackedElements.push(child);
      } else if (trackOption === 'nearestCustomElement') {
        this._getChildrenToTrack(child, trackOption, trackedElements);
      }
    }

    return trackedElements;
  },
  // tracks upgrade and creation of relevant children for the element
  _whenChildrenCreated: function _whenChildrenCreated(element, bindingProvider) {
    var _UPGRADE_MESSAGE_INTERVAL = 20000;
    var trackOption = oj.BaseCustomElementBridge.getTrackChildrenOption(element);
    var busyContext = Context.getContext(element).getBusyContext();

    var trackedElements = this._getChildrenToTrack(element, trackOption, []); // map tracked elements to promises


    var promises = trackedElements.map(function (trackedElement) {
      // 1) if bindingProvider is null, then we don't expect to discover knockout custom components -
      //    wait for all components to be defined, then wait for JET components to be created
      // 2) if bindingProvider is knockout, then child JET components should already be registered -
      //    no need to wait for whenDefined, just wait for JET components to be created
      if (!bindingProvider) {
        // register busy state for the element
        var resolveElementDefinedBusyState = busyContext.addBusyState({
          description: 'Waiting for element ' + trackedElement.localName + ' to be defined.'
        }); // setup a timer to log 'waiting' message for an element

        var timer = setInterval(function () {
          Logger.warn('Warning: waiting for element ' + trackedElement.localName + ' to be defined.');
        }, _UPGRADE_MESSAGE_INTERVAL); // return a promise that will be resolved, when element is defined and created

        return customElements.whenDefined(trackedElement.localName).then(function () {
          resolveElementDefinedBusyState();
          clearInterval(timer);

          if (oj.BaseCustomElementBridge.getRegistered(trackedElement.tagName)) {
            return oj.BaseCustomElementBridge.getInstance(trackedElement).whenCreated();
          }

          return null;
        }).catch(function (error) {
          resolveElementDefinedBusyState();
          clearInterval(timer);
          throw new Error('Error defining element ' + trackedElement.localName + ' : ' + error);
        });
      } else if (oj.BaseCustomElementBridge.getRegistered(trackedElement.tagName)) {
        return oj.BaseCustomElementBridge.getInstance(trackedElement).whenCreated();
      }

      return null; // knockout binding provider, but the component is not JET component
    });
    return Promise.all(promises);
  },

  /**
   * Returns true if the disabled attribute has already been removed by the bridge.
   * @return  {boolean}
   * @private
   */
  _isDisabledAttributeRemoved: function _isDisabledAttributeRemoved() {
    return this._disabledProcessed === true;
  },

  /**
   * Removes the disabled attribute from an element and marks the bridge as having
   * processed the value to prevent evaluation of additional attribute sets.
   * @param  {Element} element The custom element
   * @private
   */
  _removeDisabledAttribute: function _removeDisabledAttribute(element) {
    this._disabledProcessed = true;
    element.removeAttribute('disabled');
  }
};
/** ***********************/

/* PUBLIC STATIC METHODS */

/** ***********************/

/**
 * Returns the attributes including the dot notation versions of all complex properties
 * not including readOnly properties.
 * @param {Object} props The properties object
 * @return {Array}
 * @ignore
 */

oj.BaseCustomElementBridge.getAttributes = function (props) {
  var attrs = [];

  oj.BaseCustomElementBridge._getAttributesFromProperties('', props, attrs);

  return attrs;
};
/**
 * Returns track children option for the element - 'none', 'immediate' or 'nearestCustomElement'
 * @param {Element} element Custom element
 * @return {String}
 * @ignore
 */


oj.BaseCustomElementBridge.getTrackChildrenOption = function (element) {
  var bridge = oj.BaseCustomElementBridge.getInstance(element);
  return bridge ? bridge.GetTrackChildrenOption(element) : 'none';
};
/**
 * Helper method for Returns the attributes including the dot notation versions of all complex attributes
 * stored on a bridge instance
 * @param {string} propName The property to evaluate
 * @param {Object} props The properties object
 * @param {Array} attrs The attribute array to add to
 * @ignore
 */


oj.BaseCustomElementBridge._getAttributesFromProperties = function (propName, props, attrs) {
  if (props) {
    var propKeys = Object.keys(props);

    for (var i = 0; i < propKeys.length; i++) {
      var prop = propKeys[i];
      var propMeta = props[prop];

      if (!propMeta.readOnly) {
        var concatName = propName + prop;
        attrs.push(oj.__AttributeUtils.propertyNameToAttribute(concatName));

        if (propMeta.properties) {
          oj.BaseCustomElementBridge._getAttributesFromProperties(concatName + '.', propMeta.properties, attrs);
        }
      }
    }
  }
};
/**
 * Returns a string including the element tag name and id for use in error messages and logging.
 * @param {Element} element The element to get the information for.
 * @return {string}
 * @ignore
 */


oj.BaseCustomElementBridge.getElementInfo = function (element) {
  if (element) {
    return element.tagName.toLowerCase() + " with id '" + element.id + "'";
  }

  return '';
};
/**
 * Returns the bridge instance for an element.
 * @ignore
 */


oj.BaseCustomElementBridge.getInstance = function (element) {
  var instance = element[oj.BaseCustomElementBridge._INSTANCE_KEY];

  if (!instance) {
    var info = oj.BaseCustomElementBridge._registry[element.tagName.toLowerCase()];

    if (!info) {
      Logger.error(oj.BaseCustomElementBridge.getElementInfo(element) + ' Attempt to interact with the custom element before it has been registered.');
    }

    instance = Object.create(info.bridgeProto);

    var descriptor = oj.BaseCustomElementBridge.__GetDescriptor(element.tagName);

    instance.InitializeBridge(element, descriptor);
    Object.defineProperty(element, oj.BaseCustomElementBridge._INSTANCE_KEY, {
      value: instance
    });
  }

  return instance;
};
/**
 * Returns the properties stored on a bridge instance
 * @param  {Object} bridge The bridge instance
 * @return {Object}
 * @ignore
 */
// eslint-disable-next-line no-unused-vars


oj.BaseCustomElementBridge.getProperties = function (bridge) {
  return bridge.METADATA.properties;
};
/**
 * Returns an object if JET component tag has been registered, null otherwise.
 * @param  {string}  tagName The tag name to look up
 * @return {Object|null} True if the component module has been loaded and registered
 * @ignore
 */


oj.BaseCustomElementBridge.getRegistered = function (tagName) {
  if (tagName) {
    var info = oj.BaseCustomElementBridge._registry[tagName.toLowerCase()];

    if (info) {
      return {
        composite: info.composite
      };
    }
  }

  return null;
};
/**
 * Returns the slot map of slot name to slotted child elements for a given custom element.
 * If the given element has no children, this method returns an empty object.
 * Note that the default slot name is mapped to the empty string.
 * @param  {Element} element The custom element
 * @return {Object} A map of the child elements for a given custom element.
 * @ignore
 */


oj.BaseCustomElementBridge.getSlotMap = function (element) {
  var slotMap = {};
  var childNodeList = element.childNodes;

  for (var i = 0; i < childNodeList.length; i++) {
    var child = childNodeList[i]; // Only assign Text and Element nodes to a slot

    if (oj.BaseCustomElementBridge.isSlotable(child)) {
      var slot = oj.BaseCustomElementBridge.getSlotAssignment(child);

      if (!slotMap[slot]) {
        slotMap[slot] = [];
      }

      slotMap[slot].push(child);
    }
  }

  return slotMap;
};
/**
 * Returns the slot that the node should get assigned to.
 * Note that the default slot name is mapped to the empty string.
 * @param  {Node} node The custom element
 * @return {string} The slot name of the element
 * @ignore
 */


oj.BaseCustomElementBridge.getSlotAssignment = function (node) {
  // Text nodes and elements with no slot attribute map to the default slot.
  // __oj_slots is the slot attribute saved from an oj-bind-slot or oj-bind-template-slot element
  // Remember that the slot name can be the empty string so we should do a null check instead of just using || directly
  var slot = node.__oj_slots != null ? node.__oj_slots : node.getAttribute && node.getAttribute('slot');

  if (!slot) {
    slot = '';
  }

  return slot;
};
/**
 * Returns true if an element is slot assignable.
 * @param {Element} node The element to check
 * @return {boolean}
 * @ignore
 */


oj.BaseCustomElementBridge.isSlotable = function (node) {
  // Ignore text nodes that only contain whitespace
  return node.nodeType === 1 || node.nodeType === 3 && node.nodeValue.trim();
};
/** ***************************/

/* NON PUBLIC STATIC METHODS */

/** ***************************/

/**
 * @ignore
 */


oj.BaseCustomElementBridge._NO_BINDING_PROVIDER = 'none';
/**
 * @ignore
 */

oj.BaseCustomElementBridge._enumerateMetadataForKey = function (proto, metadata, key, callback) {
  if (!metadata || !metadata[key]) {
    return;
  }

  var values = metadata[key];
  var names = Object.keys(values);
  names.forEach(function (name) {
    callback(proto, name, values[name]);
  });
};
/**
 * Returns a binding provder name if the element is managed by a JET composite
 * @ignore
 */


oj.BaseCustomElementBridge._getCompositeBindingProviderName = function (element) {
  // for upstream dependency we will still rely components being registered on the oj namespace.
  var name = oj.Composite ? oj.Composite.getBindingProviderName(element.parentElement) : null;
  return name;
};
/**
 * Checks to see whether a value is valid for an element property's enum and throws an error if not.
 * @param  {Element}  element The custom element
 * @param  {string}  property The property to check
 * @param  {string}  value The property value
 * @param  {Object}  metadata The property metadata
 * @ignore
 */


oj.BaseCustomElementBridge.checkEnumValues = function (element, property, value, metadata) {
  // Only check enum values for string types
  if (typeof value === 'string' && metadata) {
    var enums = metadata.enumValues;

    if (enums && enums.indexOf(value) === -1) {
      var bridge = oj.BaseCustomElementBridge.getInstance(element);
      bridge.throwError(element, "Invalid value '" + value + "' found for property '" + property + "'. Expected one of the following '" + enums.toString() + "'.");
    }
  }
};
/**
 * Checks to see whether a value is valid for an element property and throws an error if not.
 * @param  {Element}  element The custom element
 * @param  {string}  property The property to check
 * @param  {string}  value The property value
 * @param  {Object}  metadata The property metadata
 * @ignore
 */


oj.BaseCustomElementBridge.checkType = function (element, property, value, metadata) {
  // We currently support checking of single typed properties of type: string, number,
  // boolean, Array, Object OR properties w/ two possible types where
  // the value can either be of type string|Array, string|Object, string|function, Array|Promise.
  // Any other types are currently skipped, but can be validated by the component in a future ER.
  var type = metadata.type;

  if (type) {
    type = type.toLowerCase();
    var typeAr = type.split('|');

    var typeOf = _typeof(value);

    if (typeAr.length === 1) {
      if (type.substring(0, 5) === 'array' && !Array.isArray(value) || type.substring(0, 6) === 'object' && typeOf !== 'object' || type === 'number' && !(typeof value === 'number' && isFinite(value)) || // Number.isFinite isn't availabe on IE11
      type === 'string' && typeOf !== 'string') {
        oj.BaseCustomElementBridge.__ThrowTypeError(element, property, value, type);
      } // Treat boolean property sets like the DOM does where any value that passes
      // 'if (boolVal)' results in a true prop set


      if (type === 'boolean') {
        // eslint-disable-next-line no-param-reassign
        value = !!value;
      }
    } else if (typeAr.length === 2) {
      var strIdx = typeAr.indexOf('string');
      var promiseIdx = typeAr.indexOf('promise');
      var otherType;

      if (strIdx !== -1 && typeOf !== 'string') {
        otherType = strIdx === 0 ? typeAr[1] : typeAr[0];

        if (otherType === 'function' && typeOf !== 'function' || otherType.substring(0, 5) === 'array' && !Array.isArray(value) || otherType.substring(0, 6) === 'object' && typeOf !== 'object') {
          oj.BaseCustomElementBridge.__ThrowTypeError(element, property, value, type);
        }
      } else if (promiseIdx !== -1 && !(value instanceof Promise)) {
        otherType = promiseIdx === 0 ? typeAr[1] : typeAr[0];

        if (otherType.substring(0, 5) === 'array' && !Array.isArray(value)) {
          oj.BaseCustomElementBridge.__ThrowTypeError(element, property, value, type);
        }
      }
    }
  }

  return value;
};
/**
 * Compares two values, returning true if they are equal. Does a deeper check for writeback values
 * because we can't prevent knockout from triggering a second property set with the same values
 * when writing back, but we do want to prevent the addtional update and property changed event.
 * @ignore
 */


oj.BaseCustomElementBridge.__CompareOptionValues = function (property, metadata, value1, value2) {
  if (metadata.writeback) {
    return oj.Object.compareValues(value1, value2);
  }

  return value1 === value2;
};
/**
 * @ignore
 */


oj.BaseCustomElementBridge.__ThrowTypeError = function (element, property, value, type) {
  var bridge = oj.BaseCustomElementBridge.getInstance(element);
  bridge.throwError(element, "Invalid type '" + _typeof(value) + "' found for property '" + property + "'. Expected value of type '" + type + "'.");
};
/**
 * @ignore
 */


oj.BaseCustomElementBridge.__GetDescriptor = function (tagName) {
  return oj.BaseCustomElementBridge._registry[tagName.toLowerCase()].descriptor;
};
/**
 * @ignore
 */


oj.BaseCustomElementBridge.__GetCache = function (tagName) {
  if (tagName) {
    return oj.BaseCustomElementBridge._registry[tagName.toLowerCase()].cache;
  }

  return null;
};
/**
 * Checks to see if there are any overlapping attribute for the given element and attribute
 * @ignore
 */


oj.BaseCustomElementBridge.__CheckOverlappingAttribute = function (element, attr) {
  var attrPath = attr.split('.');

  if (attrPath.length > 1) {
    attrPath.pop();

    while (attrPath.length) {
      var attrSubPath = attrPath.join('.');

      if (element.hasAttribute(attrSubPath)) {
        var bridge = oj.BaseCustomElementBridge.getInstance(element);
        bridge.throwError(element, "Cannot set overlapping attributes '" + attr + "' and '" + attrSubPath + "'.");
      }

      attrPath.pop();
    }
  }
};
/**
  * Returns the metadata for the property, walking down the metadata hierarchy
  * for subproperties.
  * @param {string} prop The property including dot notation if applicable
  * @param {Object} metadata The component metadata
  * @return {Object|null} The metadata for the property or subproperty or
  *                       null if not a component property, e.g. a global attribute
  * @ignore
  */


oj.BaseCustomElementBridge.__GetPropertyMetadata = function (prop, metadata) {
  var meta = metadata;
  var propAr = prop.split('.');

  for (var i = 0; i < propAr.length; i++) {
    meta = meta[propAr[i]];

    if (!meta) {
      break;
    }

    if (propAr.length > 1 && i < propAr.length - 1) {
      meta = meta.properties;

      if (!meta) {
        break;
      }
    }
  }

  return meta;
};
/**
 * @ignore
 */


oj.BaseCustomElementBridge.__InitProperties = function (element, componentProps) {
  var bridge = oj.BaseCustomElementBridge.getInstance(element);
  bridge.__INITIALIZING_PROPS = true;
  var metaProps = oj.BaseCustomElementBridge.getProperties(bridge);

  if (metaProps) {
    var attrs = element.attributes; // attrs is a NodeList

    for (var i = 0; i < attrs.length; i++) {
      var attr = attrs[i];

      var property = oj.__AttributeUtils.attributeToPropertyName(attr.nodeName); // See if attribute is a component property


      var meta = oj.BaseCustomElementBridge.__GetPropertyMetadata(property, metaProps);

      if (meta && !meta.readOnly) {
        // If complex property, check if there are any overlapping attributes
        oj.BaseCustomElementBridge.__CheckOverlappingAttribute(element, attr.nodeName);

        var info = oj.__AttributeUtils.getExpressionInfo(attr.value);

        if (!info.expr) {
          var value = oj.BaseCustomElementBridge.__ParseAttrValue(element, attr.nodeName, property, attr.value, meta);

          bridge.ValidateAndSetProperty(bridge.GetAliasForProperty.bind(bridge), componentProps, property, value, element);
        }
      }
    }
  }

  bridge.__INITIALIZING_PROPS = false;
};
/**
 * @param {function} propNameFun A function that returns the actual property name to use, e.g. an alias
 * @param {Object} componentProps The object to set the new property value on which is the
 *                                element for outer property sets and the property bag for inner sets.
 * @param {string} property The property name
 * @param {Object} value The value to set for the property
 * @ignore
 */


oj.BaseCustomElementBridge.__SetProperty = function (propNameFun, componentProps, property, value) {
  var propsObj = componentProps;
  var propPath = property.split('.');
  var branchedProps; // Set subproperty, initializing parent objects along the way unless the top level
  // property is not defined since setting it to an empty object will trigger a property changed
  // event. Instead, branch and set at the end. We only have listeners on top level properties
  // so setting a subproperty will not trigger a property changed event along the way.

  var topProp = propNameFun(propPath[0]);

  if (propPath.length > 1 && !componentProps[topProp]) {
    branchedProps = {};
    propsObj = branchedProps;
  } // Walk to the correct location


  for (var i = 0; i < propPath.length; i++) {
    var subprop = propNameFun(propPath[i]);

    if (i === propPath.length - 1) {
      propsObj[subprop] = value;
    } else if (!propsObj[subprop]) {
      propsObj[subprop] = {};
    }

    propsObj = propsObj[subprop];
  } // Update the original component properties if we branched


  if (branchedProps) {
    // eslint-disable-next-line no-param-reassign
    componentProps[topProp] = branchedProps[topProp];
  }
};
/**
 * @ignore
 */


oj.BaseCustomElementBridge.__GetProperty = function (componentProps, property) {
  var propsObj = componentProps;
  var propPath = property.split('.');

  for (var i = 0; i < propPath.length; i++) {
    var subprop = propPath[i]; // If no metadata is passed in, assume that the value has already been evaluated

    if (i === propPath.length - 1) {
      return propsObj[subprop];
    } else if (!propsObj[subprop]) {
      return undefined;
    }

    propsObj = propsObj[subprop];
  }

  return undefined;
};
/**
 * Returns the coerced attribute value using a custom parse function or the framework default.
 * @ignore
 */


oj.BaseCustomElementBridge.__ParseAttrValue = function (elem, attr, prop, val, metadata) {
  if (val == null) {
    return val;
  }

  var type = metadata.type;
  var bridge = oj.BaseCustomElementBridge.getInstance(elem);

  function _coerceVal(value) {
    var coercedValue;

    try {
      coercedValue = oj.__AttributeUtils.coerceValue(elem, attr, value, type);
    } catch (ex) {
      bridge.throwError(elem, 'Error parsing attribute value.', ex);
    }

    return coercedValue;
  }

  var parseFunction = oj.BaseCustomElementBridge.__GetDescriptor(elem.tagName).parseFunction;

  if (parseFunction) {
    return parseFunction(val, prop, metadata, function (value) {
      return _coerceVal(value);
    });
  }

  return _coerceVal(val);
};
/**
 * @ignore
 */


oj.BaseCustomElementBridge.__ProcessEventListeners = function (_metadata) {
  var metadata = oj.CollectionUtils.copyInto({}, _metadata, undefined, true, 1);
  metadata.properties = metadata.properties || {};

  oj.BaseCustomElementBridge._enumerateMetadataForKey(null, metadata, 'properties', function (proto, property) {
    var eventName = oj.__AttributeUtils.propertyNameToChangeEventType(property);

    var eventListenerProperty = oj.__AttributeUtils.eventTypeToEventListenerProperty(eventName);

    metadata.properties[eventListenerProperty] = {
      _derived: true,
      _eventListener: true
    };
  });

  oj.BaseCustomElementBridge._enumerateMetadataForKey(null, metadata, 'events', function (proto, event) {
    var eventListenerProperty = oj.__AttributeUtils.eventTypeToEventListenerProperty(event);

    metadata.properties[eventListenerProperty] = {
      _derived: true,
      _eventListener: true
    };
  });

  return metadata;
};
/**
 * @ignore
 * @param {string} tagName
 * @param {Object} descriptor
 * @param {Object} bridgeProto
 * @param {boolean=} isComposite
 */


oj.BaseCustomElementBridge.__Register = function (tagName, descriptor, bridgeProto, isComposite) {
  var name = tagName.toLowerCase();

  if (!oj.BaseCustomElementBridge._registry[name]) {
    if (!descriptor) {
      Logger.error('Cannot register ' + tagName + '. Missing a descriptor.');
    }

    oj.BaseCustomElementBridge._registry[name] = {
      descriptor: descriptor,
      bridgeProto: bridgeProto,
      composite: isComposite,
      cache: {}
    };
    return true;
  }

  return false;
};
/**
 * @ignore
 * @param {Element} element
 * @param {string} name
 * @param {Object} value
 * @param {Object} previousValue
 * @param {string} updatedFrom
 * @param {Object=} subprop
 */


oj.BaseCustomElementBridge.__FirePropertyChangeEvent = function (element, name, value, previousValue, updatedFrom, subprop) {
  var bridge = oj.BaseCustomElementBridge.getInstance(element); // There are cases where a subproperty set can trigger a top level property set
  // if the top level property was not instantiated to an empty object. We don't want
  // to fire two events for that case. The BaseCustomElementBridge has logic to fire
  // the subproperty change event there.

  if (!bridge._SKIP_PROP_CHANGE_EVENT) {
    var detail = {};

    if (subprop) {
      detail.subproperty = subprop;
    }

    detail.value = value;
    detail.previousValue = previousValue;
    detail.updatedFrom = updatedFrom; // Check if the subclass needs to do anything before we fire the property change event,
    // e.g. composites that need to call the propertyChanged ViewModel callback.

    if (bridge.beforePropertyChangedEvent) {
      bridge.beforePropertyChangedEvent(element, name, detail);
    } // The bridge sets the ready to fire flag after the component has been instantiated.
    // We shouldn't fire property changed events before then unless the update comes from internally
    // for cases like readOnly property updates.


    if (updatedFrom !== 'external' || bridge.__READY_TO_FIRE) {
      element.dispatchEvent(new CustomEvent(name + 'Changed', {
        detail: detail
      }));
    }
  }
};
/**
 * @ignore
 */


oj.BaseCustomElementBridge.__DefineDynamicObjectProperty = function (obj, property, getter, setter) {
  Object.defineProperty(obj, property, {
    enumerable: true,
    get: getter,
    set: setter
  });
};
/**
 * @ignore
 */


oj.BaseCustomElementBridge._registry = {};
/** @ignore */

oj.BaseCustomElementBridge.DESC_KEY_CSS = 'css';
/** @ignore */

oj.BaseCustomElementBridge.DESC_KEY_META = 'metadata';
/** @ignore */

oj.BaseCustomElementBridge.DESC_KEY_PARSE_FUN = 'parseFunction';
/** @ignore */

oj.BaseCustomElementBridge.DESC_KEY_VIEW = 'view';
/** @ignore */

oj.BaseCustomElementBridge.DESC_KEY_VIEW_MODEL = 'viewModel';
/**
 * @ignore
 */

oj.BaseCustomElementBridge._INSTANCE_KEY = '_ojBridge';
/**
 * Class used to track the create state.
 * @constructor
 * @protected
 * @ignore
 */

oj.BaseCustomElementBridge.__DelayedPromise = function () {
  var _promise;

  var _resolve;

  var _reject;
  /**
   * Returns the create Promise, creating one as needed.
   * @return {Promise}
   * @ignore
   */


  this.getPromise = function () {
    if (!_promise) {
      _promise = new Promise(function (resolve, reject) {
        _resolve = resolve;
        _reject = reject;
      });
    }

    return _promise;
  };
  /**
   * Rejects the create Promise if one exists.
   * @ignore
   */


  this.rejectPromise = function (reason) {
    if (_reject) {
      _reject(reason);
    }
  };
  /**
   * Resolves the create Promise if one exists.
   * @ignore
   */


  this.resolvePromise = function (value) {
    if (_resolve) {
      _resolve(value);
    }
  };
};



/**
 * @ojoverviewdoc CustomElementOverview - [2]JET Web Components
 * @classdesc
 * {@ojinclude "name":"customElementOverviewDoc"}
 */

/**
 * <h2 id="ce-overview-section">
 *   Overview<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-overview-section"></a>
 * </h2>
 * <p>
 *   JET components and <a href="CompositeOverview.html">custom components</a>, collectively referred to as <b>JET Web Components</b>,
 *   are implemented as <a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Custom_Elements">custom HTML elements</a>
 *   and extend the <a href="https://html.spec.whatwg.org/multipage/dom.html#htmlelement">HTMLElement</a> interface. This means that
 *   JET custom elements automatically inherit
 *   <a href=https://html.spec.whatwg.org/multipage/dom.html#global-attributes>global attributes</a>
 *   and programmatic access to these components is similar to interacting with native HTML elements.
 *   All JET components live in the "oj" namespace and have HTML element names starting with "oj-". We will use
 *   the term "JET component" to refer to both native JET custom elements and custom elements implemented using the
 *   <a href="oj.Composite.html">Composite</a> component APIs after this point.
 * </p>
 * <h2 id="ce-overview-upgrade-section" class="subsection-title">
 *   Upgrading a Custom Element<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-overview-upgrade-section"></a>
 * </h2>
 * <p>
 *   The upgrade process will begin for current JET custom elements in the DOM when the component module is loaded,
 *   registering a class constructor with its tag name using the
 *   <a href="https://developer.mozilla.org/en-US/docs/Web/API/CustomElementRegistry/define">CustomElementRegistry</a>
 *   <code>define()</code> API. Existing elements matching the registered tag name will be updated to inherit the new
 *   class definition and all of the component properties and methods will be available on the custom element after
 *   this process completes. Additionally, JET components will resolve any data bindings during the upgrade process.
 *   The application is responsible for calling their binding provider to apply bindings or for adding a
 *   <code>data-oj-binding-provider="none"</code> attribute in their page to indicate that no data bindings exist.
 *   Note that the JET custom element upgrade process will not complete until data bindings
 *   are resolved or no binding provider is indicated using the <code>data-oj-binding-provider</code> attribute.
 *   Also, due to JET components' data binding support, all JET component upgrades will occur asynchronously regardless
 *   of whether a binding provider is used.
 *   Please see the <a href="#ce-databind-section">data binding</a> section for more details on binding providers and data binding.
 *   The application should not interact with the JET custom element except to  programmatically set properties until the
 *   custom element upgrade is complete. The recommended way to wait on the asynchronous upgrade process is to use an
 *   element-scoped or page-level <a href="oj.BusyContext.html">BusyContext</a>.
 * </p>
 * <h2 id="ce-overview-usage-section" class="subsection-title">
 *   Using a JET Custom Element<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-overview-usage-section"></a>
 * </h2>
 * <p>
 *   Custom elements can be used declaratively in HTML by using the component tag name and attributes. They are not self closing
 *   elements and applications should include a closing tag. To interact with them  programmatically, DOM APIs can be used to
 *   retrieve the element and then access properties and methods directly on the element instance. JET custom elements can also fire
 *   <code>CustomEvents</code> for which the application can attach event listeners both declaratively and  programmatically.
 *   The rest of this document discusses these features in more detail.
 * </p>
 *
 * <h2 id="ce-attributes-section" class="subsection-title">
 *   Attributes<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-attributes-section"></a>
 * </h2>
 * <p>
 *   Attribute values set as string literals will be parsed and coerced to the property type. JET currently
 *   only supports the following string literal type coercions: boolean, number, string, Object and Array, where
 *   Object and Array types must use JSON notation with double quoted strings. A special "any" type is also supported
 *   and is described <a href="#ce-attrs-any-section">below</a>. All other types should to be set using
 *   <a href="#ce-databind-section">expression syntax</a> in the DOM or using the element's property setters or <code>setProperty</code>
 *   and <code>setProperties</code> methods programmatically. Unless updates are done via the DOM element.setAttribute(),
 *   the DOM's attribute value will not reflect changes like those done via the property setters or the setProperty and
 *   setProperties methods. Attribute removals are treated as unsetting of a property where the component default value will be used if one exists.
 * </p>
 * <p>
 *   As described <a href="#ce-databind-section">below</a>, JET uses [[...]] and {{...}} syntax to represent data bound expressions.
 *   JET does not currently provide any escaping syntax for "[[" or "{{" appearing at the beginning of the attribute
 *   value. You will need to add a space character to avoid having the string literal value interpreted as a binding
 *   expression (e.g. &lt;oj-some-element some-attribute='[ ["arrayValue1", "arrayValue2", ... ] ]'>&lt;/oj-some-element>).
 * </p>
 * <h2 id="ce-attrs-boolean-section" class="subsection-title">
 *   Boolean Attributes<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-attrs-boolean-section"></a>
 * </h2>
 * <p>
 *   JET components treat boolean attributes differently than HTML5. Since a common application use case
 *   is to toggle a data bound boolean attribute, JET will coerce the string literal "false" to the boolean
 *   false for boolean attributes. The absence of a boolean attribute in the DOM will also be interpreted as false.
 *   JET will coerce the following string literal values to the boolean true and throw an Error for all other
 *   invalid values.
 *   <ul>
 *    <li>No value assignment (e.g. &lt;oj-some-element boolean-attribute>&lt;/oj-some-element>)</li>
 *    <li>Empty string (e.g. &lt;oj-some-element boolean-attribute="">&lt;/oj-some-element>)</li>
 *    <li>The "true" string literal (e.g. &lt;oj-some-element boolean-attribute="true">&lt;/oj-some-element>)</li>
 *    <li>The case-insensitive attribute name (e.g. &lt;oj-some-element boolean-attribute="boolean-attribute">&lt;/oj-some-element>)</li>
 *   </ul>
 * </p>
 * <h2 id="ce-attrs-object-section" class="subsection-title">
 *   Object-Typed Attributes<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-attrs-object-section"></a>
 * </h2>
 * <p>
 *   Attributes that support Object type can be declaratively set using dot notation.
 *   Note that applications should not set overlapping attributes as these will cause an error to be thrown.
 *   <pre class="prettyprint">
 *   <code>
 * &lt;!-- person is an Object typed attribute with a firstName subproperty -->
 * &lt;oj-some-element person.first-name="{{name}}">&lt;/oj-some-element>
 *
 * &lt;!-- overlapping attributes will throw an error -->
 * &lt;oj-some-element person="{{personInfo}}" person.first-name="{{name}}">&lt;/oj-some-element>
 *   </code>
 *   </pre>
 *   If applications need to programmatically set subproperties, they can call the JET components's <code>setProperty</code>
 *   method with dot notation using the camelCased property syntax (e.g. element.setProperty("person.firstName", "Sally")).
 * </p>
 * <h2 id="ce-attrs-any-section" class="subsection-title">
 *   Any-Typed Attributes<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-attrs-any-section"></a>
 * </h2>
 * <p>
 *   Attributes that support any type are documented with type {any} in the API doc and will be coerced as
 *   Objects, Arrays, or strings when set in HTML as a string literal. Numeric types are not supported due
 *   to the fact that we cannot determine whether value="2" on a property supporting any type should be
 *   coerced to a string or a number. The application should use data binding for all other value types and ensure
 *   that when linking any-typed attributes across multiple components, that the resolved types will match, e.g.
 *   do not data bind an <oj-select-one> <code>value</code> attribute to a numeric value and use a string literal
 *   number for its child <oj-option> <code>value</code> attributes since those would evaluate to strings.
 * </p>
 *
 * <h2 id="ce-databind-section" class="subsection-title">
 *   Data Binding<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-databind-section"></a>
 * </h2>
 * <p>
 *   Applications can use the JET data binding syntax in order to use expressions or a non coercible attribute
 *   type (e.g. a type other than boolean, number, string, Object or Array) declaratively in HTML.
 *   This syntax can be used on both JET custom elements and native HTML elements.
 *   The application is responsible for applying bindings using a supported binding provider which then notifies
 *   JET framework code that the bindings have been resolved and to finish the custom element upgrade process.
 * </p>
 * <h2 id="ce-databind-bindingprovider-section" class="subsection-title">
 *   Binding Providers<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-databind-bindingprovider-section"></a>
 * </h2>
 * <p>
 *   The binding provider is responsible for setting and updating attribute
 *   expressions and any custom elements within its managed subtree will not finish upgrading until it
 *   applies bindings on that subtree. By default, there is a single binding provider for a page,
 *   but subtree specific binding providers can be added by using the <code>data-oj-binding-provider</code>
 *   attribute with values of "none" and "knockout". The default binding provider is knockout, but if a
 *   page or DOM subtree does not use any expression syntax or knockout, the application can set
 *   <code>data-oj-binding-provider="none"</code> on that element so its dependent JET custom elements
 *   do not need to wait for bindings to be applied to finish upgrading. Note that regardless of whether a
 *   binding provider is used, the custom element upgrade process will be asynchronous. <b>When using the
 *   knockout binding provider, applications should require the ojknockout module.</b>
 * </p>
 * <h2 id="ce-databind-syntax-section" class="subsection-title">
 *   Data Binding Syntax for JET Components<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-databind-syntax-section"></a>
 * </h2>
 * <p>
 *   Data binding syntax can be used directly on component attributes. See the specific component API doc
 *   for the complete list of component attributes. Global HTML attributes inherited from HTMLElement can also be
 *   data bound, but require special syntax described below. JET detects data bound attributes by looking for values
 *   wrapped with {{...}} or [[...]]. Please note that there should be no spaces between the braces
 *   when using the data bind syntax (e.g. some-attribute="[ [...] ]"). The {{...}} wrapped expression indicates that the
 *   application is allowing the component to update the expression which can be a knockout observable. Attributes
 *   bound using [[...]] will not be updated or "written back" to by the component. Unless the component attribute documents
 *   that it supports "writeback", we recommend that the [[...]] syntax be used, e.g. selection-mode="[[currentSelectionMode]]".
 * </p>
 * <h2 id="ce-databind-writeback-section" class="subsection-title">
 *   Writeback<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-databind-writeback-section"></a>
 * </h2>
 * <p>
 *   Certain properties such as "value" on editable components support updating the associated expression
 *   automatically whenever their value changes. This usually occurs after user interaction such as with selection
 *   or typing into an input field. This expression update functionality is also known as "writeback".
 *   Applications can control expression writeback by using the {{...}} syntax for two-way writable
 *   binding expressions or [[...]] for one-way only expressions. The one-way expressions should
 *   be used when the application needs expressions strictly for "downstream-only" purposes, e.g. only for
 *   updating a component property. Note that if a writeback attribute is bound using the "downstream-only"
 *   syntax, the application and component states can become out of sync. This is different from the
 *   read-only properties, which are "upstream-only", e.g. they are used only to monitor component state.
 *   Thus an expression associated with a read-only property should always use the {{}} syntax.
 *   Most component properties do not writeback and those that do will indicate it in their API doc.
 * </p>
 * <pre class="prettyprint">
 *   <code>
 *   &lt;oj-some-element value="[[currentValue]]" selection={{currentSelection}}>&lt;/oj-some-element>
 *   </code>
 * </pre>
 * <h2 id="ce-databind-global-section" class="subsection-title">
 *   Data Binding Syntax for Native HTML Elements and Global Attributes
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-databind-global-section"></a>
 * </h2>
 * <p>
 *   JET's data binding syntax can also be used on native HTML elements and
 *   <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes">global attributes</a>
 *   to create one-way bindings by prefixing the attribute
 *   name with ":" (e.g. :id="[[idVar]]"). The attribute binding syntax results in the attribute being set in the DOM
 *   with the evaluated expression. Since global HTML attributes are always string typed, expressions using the ":"
 *   prefixing should resolve to strings with the exception of the style and class attributes which support additional types
 *   and are described in more detail below. In the case of component attributes, applications are recommended to bind
 *   the attribute names directly and avoid the use of the ":" prefix.
 * </p>
 * <h2 id="ce-databind-class-section" class="subsection-title">
 *   :Class Attribute<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-databind-class-section"></a>
 * </h2>
 * <p>
 *   The class attribute binding supports a space delimited string of classes, an Array of classes, or an Object whose keys are
 *   individual style classes and whose values are booleans to determine whether those style classes should be present in the DOM
 *   (e.g. :class="[[{errorClass: hasErrors}]]"). Note that the Array and string types will override existing values in the class
 *   attribute when updates occur, whereas the Object type will only add and remove the classes specified. Since JET custom elements
 *   add their own classes, we recommend using the Object type when using the class attribute binding on JET custom elements.
 * </p>
 * <h2 id="ce-databind-style-section" class="subsection-title">
 *   :Style Attribute<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-databind-style-section"></a>
 * </h2>
 * <p>
 *   When using the style attribute binding with an Object type, the style Object names should be the JavaScript
 *   names for that style (e.g. "fontWeight" instead of "font-weight" style='{"fontWeight": "..."}').
 *   Since the style attribute supports Object types, it also supports dot notation for setting style subproperties
 *   directly (e.g. :style.font-weight="[[...]]").
 * </p>
 *
 * <h2 id="ce-properties-section" class="subsection-title">
 *   Properties<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-properties-section"></a>
 * </h2>
 * <p>
 *   In addition to properties inherited from the HTMLElement prototype, attributes listed
 *   in the component API doc will also be exposed as properties on the JET custom element.
 *   See the <a href="#ce-proptoattr-section">property to attribute mapping</a>
 *   section below to see the syntax difference between setting attributes and properties.
 *   These properties can be set at any time, but can only be retrieved once the HTML element
 *   is fully upgraded. Early property sets before the component has been upgraded
 *   will not result in [property]Changed events and will be passed to the component as part of its initial state.
 * </p>
 * <h2 id="ce-properties-readonlywriteback-section" class="subsection-title">
 *   Read-only and Writeback Properties
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-properties-readonlywriteback-section"></a>
 * </h2>
 * <p>
 *   Some properties are specially marked as read-only or supporting writeback in the component API doc.
 *   Read-only properties can only be read and not set by the application and generally support writeback.
 *   Writeback properties support automatic updates if they are bound using two way data binding syntax to an
 *   expression, e.g. value="{{valueObservable}}".
 *   Applications can bind an expression to a read-only attribute in HTML by using the {{..}} to ensure
 *   that updates will be reflected in the observable, but should not use this syntax to try and push a
 *   value to the read-only attribute which will result in an error state.
 *   Similarly, property sets using the setProperty, setProperties, or the element property setters should also
 *   be avoided for a read-only property.
 * </p>
 * <h2 id="ce-properties-subproperties-section" class="subsection-title">Subproperties
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-properties-subproperties-section"></a>
 * </h2>
 * <p>
 *   Some JET components support complex properties where the top level property is of type Object and it
 *   contains additional subproperties. If the application needs to set a single subproperty
 *   instead of the entire complex property, the <code>setProperty</code> method should be used
 *   instead to ensure that [property]Changed events will be fired with the subproperty changes.
 *   Note that directly updating the subproperty via dot notation (e.g. element.topProp.subProp = newValue)
 *   will not result in a [property]Changed event being fired.
 * </p>
 * <h2 id="ce-properties-unset-section" class="subsection-title">Unsetting of a Property
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-properties-unset-section"></a>
 * </h2>
 * <p>
 *   The undefined value is treated as unsetting of a property when passed to the
 *   property setter and will result in the component using the default value if one exists. Unsetting of
 *   subproperties using the element's <code>setProperty</code> is not supported. Subproperties can only
 *   only be unset when the top level property is unset.
 *   Property sets will not result in DOM attribute updates and after the custom
 *   element is upgraded, the application should use the custom element properties, not attributes to check
 *   the current value.
 * </p>
 * <h2 id="ce-properties-changed-section" class="subsection-title">[property]Changed Events
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-properties-changed-section"></a>
 * </h2>
 * <p>
 *   When a property or attribute value changes, a non-bubbling [property]Changed <code>CustomEvent</code>
 *   will be fired with the following properties in the event's detail property.
 *   <table class="props">
 *     <thead>
 *       <tr>
 *         <th>Name</th>
 *         <th>Type</th>
 *         <th>Description</th>
 *       </tr>
 *     </thead>
 *     <tbody>
 *       <tr>
 *      <td>value</td>
 *      <td>any</td>
 *      <td>The current value of the property that changed.</td>
 *    </tr>
 *    <tr>
 *      <td>previousValue</td>
 *      <td>any</td>
 *      <td>The previous value of the property that changed.</td>
 *    </tr>
 *    <tr>
 *      <td>updatedFrom</td>
 *      <td>string</td>
 *      <td>
 *        Where the property was updated from. Supported values are:
 *        <ul>
 *          <li>external - By the application, using either the element's property setter, setAttribute, or external data binding.</li>
 *          <li>internal - By the component, e.g. after user interaction with a text field or selection.</li>
 *        </ul>
 *      </td>
 *    </tr>
 *    <tr>
 *      <td>subproperty</td>
 *      <td>Object</td>
 *      <td>An object holding information about the subproperty that changed.
 *        <table class="props">
 *          <thead>
 *            <tr>
 *              <th>Name</th>
 *              <th>Type</th>
 *              <th>Description</th>
 *            </tr>
 *          </thead>
 *        <tbody>
 *          <tr>
 *            <td>path</td>
 *            <td>string</td>
 *            <td>
 *              The subproperty path that changed, starting from the top level
 *              property with subproperties delimited by ".".
 *            </td>
 *          </tr>
 *          <tr>
 *            <td>value</td>
 *            <td>any</td>
 *            <td>The current value of the subproperty that changed.</td>
 *          </tr>
 *          <tr>
 *            <td>previousValue</td>
 *            <td>any</td>
 *            <td>The previous value of the subproperty that changed.</td>
 *            </tr>
 *            </tbody>
 *          </table>
 *        </td>
 *      </tr>
 *    </tbody>
 *   </table>
 * </p>
 * <p>
 *   Please note that in order for components to be notified of a property change for Array properties, the
 *   value should be data bound and updated using an expression, setting the property to an updated copy
 *   by calling slice(), or by refreshing the component after an in place Array mutation.
 * </p>
 * <p>
 *   See <a href="#ce-events-section">Events and Listeners</a> for additional information on how to listen for
 *   these events.
 * </p>
 * <p>
 * Note as well that in cases where a component property that supports writeback is bound to a writable expression,
 * the relative order of expression writing and invocation of property change listeners is not guaranteed.
 * For this reason, it is not recommended to write logic that depends both on component/event state and application
 * view model state.
 * </p>
 * <h2 id="ce-proptoattr-section" class="subsection-title">Property-to-Attribute Mapping
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-proptoattr-section"></a>
 * </h2>
 * <p>
 *   The following rules apply when mapping property to attribute names:
 *   <ul>
 *     <li>Attribute names are case insensitive. CamelCased properties are mapped to
 *   kebab-cased attribute names by inserting a dash before the uppercase letter and converting that letter to lower case
 *   (e.g. a "chartType" property will be mapped to a "chart-type" attribute).</li>
 *     <li> The reverse occurs when mapping a property name from an attribute name.</li>
 *   </ul>
 * </p>
 *
 * <h2 id="ce-methods-section" class="subsection-title">
 *   Methods<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-methods-section"></a>
 * </h2>
 * <p>
 *   Methods can be accessed on the JET component after the element is fully upgraded. See
 *   the component API doc for specifics.
 * </p>
 *
 * <h2 id="ce-events-section" class="subsection-title">
 *   Events and Listeners<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-events-section"></a>
 * </h2>
 * <p>
 *   JET Web Components, like other custom HTML elements, may fire <code>CustomEvents</code>.  These
 *   events will be described in component documentation, including whether they bubble, are cancelable and any
 *   event detail payloads. In addition, JET components
 *   fire non-bubbling, non-cancelable [property]Changed (e.g. valueChanged) <code>CustomEvents</code>
 *   whenever a property is updated. See the <a href="#ce-properties-section">properties section</a> above
 *   for details on the event payload.
 * </p>
 *  <p>
 *   JET <code>CustomEvents</code> can be listened to using the standard addEventListener mechanism:
 *   <pre class="prettyprint">
 *   <code>
 * someElement.addEventListener("eventName", function(event) {...});
 *   </code>
 *   </pre>
 * </p>
 * <p>
 *   Additionally, JET custom elements and native HTML elements within JET pages support declarative specification of event
 *   listeners via <code>on-[event-name]</code> attributes (e.g. <code>on-click</code>,
 *   <code>on-value-changed</code> or <code>on-oj-expand</code>). The attributes ultimately delegate to the standard
 *   <code>addEventListener</code> mechanism and only support data bound expressions
 *   that evaluate to functions; arbitrary JavaScript will not be accepted.
 * </p>
 * <p>
 *   Please note that event listeners specified using this syntax can only be set during component initialization.
 *   Subsequent setAttribute calls for the event listener attributes will be ignored.
 *   There is no associated <code>on[EventName]</code> property on the JET custom element for the equivalent
 *   <code>on-[event-name]</code> attribute.
 * </p>
 * <p>
 *   In addition to the event parameter, event listeners specified via <code>on-[event-name]</code>
 *   attributes will receive two additional parameters when they are invoked: <code>data</code> and <code>bindingContext</code>.
 *   The <code>bindingContext</code> parameter provides the listener with the entire data binding context that
 *   was applied to the element while the data parameter provides convenient access to relevant data.
 *   When in an iteration context (e.g. inside an <code>oj-bind-for-each</code>), the <code>data</code> parameter
 *   is equal to <code>bindingContext["$current"]</code>; otherwise, it is equal to <code>bindingContext["$data"]</code>.
 *   These declarative event listeners should take the form:
 *   <pre class="prettyprint">
 *   <code>
 * &lt;oj-some-element on-event-name="[[eventListener]]">&lt;/oj-some-element>
 *
 *
 * function eventListener(event, data, bindingContext) {
 *   ...
 * }
 *   </code>
 *   </pre>
 * </p>
 *
 * <h2 id="ce-slots-section" class="subsection-title">
 *   Slots<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-slots-section"></a>
 * </h2>
 * <p>
 *  Some JET components allow application provided child content. This child content will be moved by the JET component to
 *  a designated "slot" and is referred to as slot content. Slot content can have one of two characteristics:
 *  <ul>
 *    <li>
 *      Named slot content - Any direct child element with a slot attribute will be moved into that named slot, e.g.  &lt;span slot='startIcon'>... &lt;/span>.
 *      All supported named slots are described in the API Doc. Child elements with unsupported named slots will be removed from the DOM.
 *    </li>
 *    <li>
 *      Default slot content - Any direct child element lacking a slot attribute will be moved to the default slot, also known as a regular child.
 *    </li>
 *  </ul>
 *  Bindings are applied to slot content in the application's context with the exception of template slots which are described
 *  below. Slot content are moved to their designated component slots after bindings are applied. <b>Please note that only text and
 *  element nodes can be assigned to a slot. Comment nodes are not eligible, so oj-bind-* elements which resolve to comment nodes
 *  after bindings are applied should be wrapped in a span or other element node for slotting.</b>
 * </p>
 * <h3 id="ce-slots-template-section" class="subsection-title">
 *   Template Slots<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-slots-template-section"></a>
 * </h3>
 * <p>
 *  Some components support template slots which allow the application to pass a template element with a DOM fragment that
 *  will be stamped out by the component. Bindings are not applied to template slot content until they are stamped out by the
 *  component. All template slot children will have access to the following variables:
 *  <ul>
 *    <li>$current - Default variable that contains component exposed subproperties as documented in the component's API doc.</li>
 *    <li>component-level template alias - Set by the application if the component has provided a component-level alias attribute
 *        as part of its API. Provides a template alias available to all template slot binding contexts and has the same
 *        subproperties as the $current variable.</li>
 *    <li>template-level alias - Set by the application on the template element via the 'data-oj-as' attribute. Provides an alias
 *        for a specific template instance and has the same subproperties as the $current variable.</li>
 *  </ul>
 *  Note that $current is always availble on the binding context regardless of whether any application provided aliases are set.
 * </p>
 *
 * @ojfragment customElementOverviewDoc - General description doc fragment that shows up in every component's page via a link.
 * @memberof CustomElementOverview
 */

});
/*! jQuery UI - v1.12.1 - 2016-09-15
* http://jqueryui.com
* Copyright jQuery Foundation and other contributors; Licensed  */
!function(e){"function"==typeof define&&define.amd?define('jqueryui-amd/version',["jquery"],e):e(jQuery)}(function(e){return e.ui=e.ui||{},e.ui.version="1.12.1"});
/*! jQuery UI - v1.12.1 - 2016-09-15
* http://jqueryui.com
* Copyright jQuery Foundation and other contributors; Licensed  */
!function(t){"function"==typeof define&&define.amd?define('jqueryui-amd/widget',["jquery","./version"],t):t(jQuery)}(function(t){var e=0,i=Array.prototype.slice;return t.cleanData=function(e){return function(i){var s,n,o;for(o=0;null!=(n=i[o]);o++)try{s=t._data(n,"events"),s&&s.remove&&t(n).triggerHandler("remove")}catch(t){}e(i)}}(t.cleanData),t.widget=function(e,i,s){var n,o,a,r={},l=e.split(".")[0];e=e.split(".")[1];var u=l+"-"+e;return s||(s=i,i=t.Widget),t.isArray(s)&&(s=t.extend.apply(null,[{}].concat(s))),t.expr[":"][u.toLowerCase()]=function(e){return!!t.data(e,u)},t[l]=t[l]||{},n=t[l][e],o=t[l][e]=function(t,e){return this._createWidget?void(arguments.length&&this._createWidget(t,e)):new o(t,e)},t.extend(o,n,{version:s.version,_proto:t.extend({},s),_childConstructors:[]}),a=new i,a.options=t.widget.extend({},a.options),t.each(s,function(e,s){return t.isFunction(s)?void(r[e]=function(){function t(){return i.prototype[e].apply(this,arguments)}function n(t){return i.prototype[e].apply(this,t)}return function(){var e,i=this._super,o=this._superApply;return this._super=t,this._superApply=n,e=s.apply(this,arguments),this._super=i,this._superApply=o,e}}()):void(r[e]=s)}),o.prototype=t.widget.extend(a,{widgetEventPrefix:n?a.widgetEventPrefix||e:e},r,{constructor:o,namespace:l,widgetName:e,widgetFullName:u}),n?(t.each(n._childConstructors,function(e,i){var s=i.prototype;t.widget(s.namespace+"."+s.widgetName,o,i._proto)}),delete n._childConstructors):i._childConstructors.push(o),t.widget.bridge(e,o),o},t.widget.extend=function(e){for(var s,n,o=i.call(arguments,1),a=0,r=o.length;a<r;a++)for(s in o[a])n=o[a][s],o[a].hasOwnProperty(s)&&void 0!==n&&(t.isPlainObject(n)?e[s]=t.isPlainObject(e[s])?t.widget.extend({},e[s],n):t.widget.extend({},n):e[s]=n);return e},t.widget.bridge=function(e,s){var n=s.prototype.widgetFullName||e;t.fn[e]=function(o){var a="string"==typeof o,r=i.call(arguments,1),l=this;return a?this.length||"instance"!==o?this.each(function(){var i,s=t.data(this,n);return"instance"===o?(l=s,!1):s?t.isFunction(s[o])&&"_"!==o.charAt(0)?(i=s[o].apply(s,r),i!==s&&void 0!==i?(l=i&&i.jquery?l.pushStack(i.get()):i,!1):void 0):t.error("no such method '"+o+"' for "+e+" widget instance"):t.error("cannot call methods on "+e+" prior to initialization; attempted to call method '"+o+"'")}):l=void 0:(r.length&&(o=t.widget.extend.apply(null,[o].concat(r))),this.each(function(){var e=t.data(this,n);e?(e.option(o||{}),e._init&&e._init()):t.data(this,n,new s(o,this))})),l}},t.Widget=function(){},t.Widget._childConstructors=[],t.Widget.prototype={widgetName:"widget",widgetEventPrefix:"",defaultElement:"<div>",options:{classes:{},disabled:!1,create:null},_createWidget:function(i,s){s=t(s||this.defaultElement||this)[0],this.element=t(s),this.uuid=e++,this.eventNamespace="."+this.widgetName+this.uuid,this.bindings=t(),this.hoverable=t(),this.focusable=t(),this.classesElementLookup={},s!==this&&(t.data(s,this.widgetFullName,this),this._on(!0,this.element,{remove:function(t){t.target===s&&this.destroy()}}),this.document=t(s.style?s.ownerDocument:s.document||s),this.window=t(this.document[0].defaultView||this.document[0].parentWindow)),this.options=t.widget.extend({},this.options,this._getCreateOptions(),i),this._create(),this.options.disabled&&this._setOptionDisabled(this.options.disabled),this._trigger("create",null,this._getCreateEventData()),this._init()},_getCreateOptions:function(){return{}},_getCreateEventData:t.noop,_create:t.noop,_init:t.noop,destroy:function(){var e=this;this._destroy(),t.each(this.classesElementLookup,function(t,i){e._removeClass(i,t)}),this.element.off(this.eventNamespace).removeData(this.widgetFullName),this.widget().off(this.eventNamespace).removeAttr("aria-disabled"),this.bindings.off(this.eventNamespace)},_destroy:t.noop,widget:function(){return this.element},option:function(e,i){var s,n,o,a=e;if(0===arguments.length)return t.widget.extend({},this.options);if("string"==typeof e)if(a={},s=e.split("."),e=s.shift(),s.length){for(n=a[e]=t.widget.extend({},this.options[e]),o=0;o<s.length-1;o++)n[s[o]]=n[s[o]]||{},n=n[s[o]];if(e=s.pop(),1===arguments.length)return void 0===n[e]?null:n[e];n[e]=i}else{if(1===arguments.length)return void 0===this.options[e]?null:this.options[e];a[e]=i}return this._setOptions(a),this},_setOptions:function(t){var e;for(e in t)this._setOption(e,t[e]);return this},_setOption:function(t,e){return"classes"===t&&this._setOptionClasses(e),this.options[t]=e,"disabled"===t&&this._setOptionDisabled(e),this},_setOptionClasses:function(e){var i,s,n;for(i in e)n=this.classesElementLookup[i],e[i]!==this.options.classes[i]&&n&&n.length&&(s=t(n.get()),this._removeClass(n,i),s.addClass(this._classes({element:s,keys:i,classes:e,add:!0})))},_setOptionDisabled:function(t){this._toggleClass(this.widget(),this.widgetFullName+"-disabled",null,!!t),t&&(this._removeClass(this.hoverable,null,"ui-state-hover"),this._removeClass(this.focusable,null,"ui-state-focus"))},enable:function(){return this._setOptions({disabled:!1})},disable:function(){return this._setOptions({disabled:!0})},_classes:function(e){function i(i,o){var a,r;for(r=0;r<i.length;r++)a=n.classesElementLookup[i[r]]||t(),a=t(e.add?t.unique(a.get().concat(e.element.get())):a.not(e.element).get()),n.classesElementLookup[i[r]]=a,s.push(i[r]),o&&e.classes[i[r]]&&s.push(e.classes[i[r]])}var s=[],n=this;return e=t.extend({element:this.element,classes:this.options.classes||{}},e),this._on(e.element,{remove:"_untrackClassesElement"}),e.keys&&i(e.keys.match(/\S+/g)||[],!0),e.extra&&i(e.extra.match(/\S+/g)||[]),s.join(" ")},_untrackClassesElement:function(e){var i=this;t.each(i.classesElementLookup,function(s,n){t.inArray(e.target,n)!==-1&&(i.classesElementLookup[s]=t(n.not(e.target).get()))})},_removeClass:function(t,e,i){return this._toggleClass(t,e,i,!1)},_addClass:function(t,e,i){return this._toggleClass(t,e,i,!0)},_toggleClass:function(t,e,i,s){s="boolean"==typeof s?s:i;var n="string"==typeof t||null===t,o={extra:n?e:i,keys:n?t:e,element:n?this.element:t,add:s};return o.element.toggleClass(this._classes(o),s),this},_on:function(e,i,s){var n,o=this;"boolean"!=typeof e&&(s=i,i=e,e=!1),s?(i=n=t(i),this.bindings=this.bindings.add(i)):(s=i,i=this.element,n=this.widget()),t.each(s,function(s,a){function r(){if(e||o.options.disabled!==!0&&!t(this).hasClass("ui-state-disabled"))return("string"==typeof a?o[a]:a).apply(o,arguments)}"string"!=typeof a&&(r.guid=a.guid=a.guid||r.guid||t.guid++);var l=s.match(/^([\w:-]*)\s*(.*)$/),u=l[1]+o.eventNamespace,h=l[2];h?n.on(u,h,r):i.on(u,r)})},_off:function(e,i){i=(i||"").split(" ").join(this.eventNamespace+" ")+this.eventNamespace,e.off(i).off(i),this.bindings=t(this.bindings.not(e).get()),this.focusable=t(this.focusable.not(e).get()),this.hoverable=t(this.hoverable.not(e).get())},_delay:function(t,e){function i(){return("string"==typeof t?s[t]:t).apply(s,arguments)}var s=this;return setTimeout(i,e||0)},_hoverable:function(e){this.hoverable=this.hoverable.add(e),this._on(e,{mouseenter:function(e){this._addClass(t(e.currentTarget),null,"ui-state-hover")},mouseleave:function(e){this._removeClass(t(e.currentTarget),null,"ui-state-hover")}})},_focusable:function(e){this.focusable=this.focusable.add(e),this._on(e,{focusin:function(e){this._addClass(t(e.currentTarget),null,"ui-state-focus")},focusout:function(e){this._removeClass(t(e.currentTarget),null,"ui-state-focus")}})},_trigger:function(e,i,s){var n,o,a=this.options[e];if(s=s||{},i=t.Event(i),i.type=(e===this.widgetEventPrefix?e:this.widgetEventPrefix+e).toLowerCase(),i.target=this.element[0],o=i.originalEvent)for(n in o)n in i||(i[n]=o[n]);return this.element.trigger(i,s),!(t.isFunction(a)&&a.apply(this.element[0],[i].concat(s))===!1||i.isDefaultPrevented())}},t.each({show:"fadeIn",hide:"fadeOut"},function(e,i){t.Widget.prototype["_"+e]=function(s,n,o){"string"==typeof n&&(n={effect:n});var a,r=n?n===!0||"number"==typeof n?i:n.effect||i:e;n=n||{},"number"==typeof n&&(n={duration:n}),a=!t.isEmptyObject(n),n.complete=o,n.delay&&s.delay(n.delay),a&&t.effects&&t.effects.effect[r]?s[e](n):r!==e&&s[r]?s[r](n.duration,n.easing,o):s.queue(function(i){t(this)[e](),o&&o.call(s[0]),i()})}}),t.widget});
/*! jQuery UI - v1.12.1 - 2016-09-15
* http://jqueryui.com
* Copyright jQuery Foundation and other contributors; Licensed  */
!function(i){"function"==typeof define&&define.amd?define('jqueryui-amd/unique-id',["jquery","./version"],i):i(jQuery)}(function(i){return i.fn.extend({uniqueId:function(){var i=0;return function(){return this.each(function(){this.id||(this.id="ui-id-"+ ++i)})}}(),removeUniqueId:function(){return this.each(function(){/^ui-id-\d+$/.test(this.id)&&i(this).removeAttr("id")})}})});
/*! jQuery UI - v1.12.1 - 2016-09-15
* http://jqueryui.com
* Copyright jQuery Foundation and other contributors; Licensed  */
!function(E){"function"==typeof define&&define.amd?define('jqueryui-amd/keycode',["jquery","./version"],E):E(jQuery)}(function(E){return E.ui.keyCode={BACKSPACE:8,COMMA:188,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,LEFT:37,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SPACE:32,TAB:9,UP:38}});
/*! jQuery UI - v1.12.1 - 2016-09-15
* http://jqueryui.com
* Copyright jQuery Foundation and other contributors; Licensed  */
!function(e){"function"==typeof define&&define.amd?define('jqueryui-amd/focusable',["jquery","./version"],e):e(jQuery)}(function(e){function i(e){for(var i=e.css("visibility");"inherit"===i;)e=e.parent(),i=e.css("visibility");return"hidden"!==i}return e.ui.focusable=function(t,n){var a,r,s,o,u,f=t.nodeName.toLowerCase();return"area"===f?(a=t.parentNode,r=a.name,!(!t.href||!r||"map"!==a.nodeName.toLowerCase())&&(s=e("img[usemap='#"+r+"']"),s.length>0&&s.is(":visible"))):(/^(input|select|textarea|button|object)$/.test(f)?(o=!t.disabled,o&&(u=e(t).closest("fieldset")[0],u&&(o=!u.disabled))):o="a"===f?t.href||n:n,o&&e(t).is(":visible")&&i(e(t)))},e.extend(e.expr[":"],{focusable:function(i){return e.ui.focusable(i,null!=e.attr(i,"tabindex"))}}),e.ui.focusable});
/*! jQuery UI - v1.12.1 - 2016-09-15
* http://jqueryui.com
* Copyright jQuery Foundation and other contributors; Licensed  */
!function(e){"function"==typeof define&&define.amd?define('jqueryui-amd/tabbable',["jquery","./version","./focusable"],e):e(jQuery)}(function(e){return e.extend(e.expr[":"],{tabbable:function(n){var t=e.attr(n,"tabindex"),u=null!=t;return(!u||t>=0)&&e.ui.focusable(n,u)}})});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojdomutils',['ojs/ojcore-base', 'jquery', 'ojs/ojthemeutils'], function(oj, $, ThemeUtils)
{
  "use strict";
/* jslint browser: true*/



/* global ThemeUtils:false */

/**
 * DOM utilities.
 * @ignore
 */
var DomUtils = {}; // TODO Internal utility so we can remove once we replace oj.DomUtils
// usages w/ DomUtils as part of JET-35291

oj.DomUtils = DomUtils;
DomUtils._HTML_START_TAG = '\x3chtml\x3e';
DomUtils._HTML_END_TAG = '\x3c/html\x3e';
DomUtils._LEGAL_ELEMENTS = {
  SPAN: 1,
  B: 1,
  I: 1,
  EM: 1,
  BR: 1,
  HR: 1,
  LI: 1,
  OL: 1,
  UL: 1,
  P: 1,
  TT: 1,
  BIG: 1,
  SMALL: 1,
  PRE: 1
};
DomUtils._LEGAL_ATTRIBUTES = {
  class: 1,
  style: 1
};
/**
 * Returns true if the value is null or if the trimmed value is of zero length.
 *
 * @param {string|null} content
 * @return {boolean} true if the string is wrapped in <html> tag.
 */

DomUtils.isHTMLContent = function (content) {
  if (content.indexOf(DomUtils._HTML_START_TAG) === 0 && content.lastIndexOf(DomUtils._HTML_END_TAG) === content.length - 7) {
    return true;
  }

  return false;
};

DomUtils.cleanHtml = function (value) {
  var offSpan = $(document.createElement('span')).get(0);
  offSpan.innerHTML = value; // @HTMLUpdateOK safe manipulation

  if (value && value.indexOf('\x3c') >= 0) {
    DomUtils._cleanElementHtml(offSpan);
  }

  return offSpan;
};

DomUtils._cleanElementHtml = function (node) {
  var children = node.childNodes;

  for (var count = children.length - 1; count >= 0; count--) {
    var child = children.item(count);

    if (child && child.nodeType === 1) {
      if (DomUtils._LEGAL_ELEMENTS[child.nodeName]) {
        var attrs = child.attributes;

        for (var i = attrs.length - 1; i >= 0; i--) {
          var attr = attrs[i]; // jquery - the .attr() method returns undefined for attributes that have not been set.

          var childHasAttr = $(child).attr(attr.name) !== undefined;

          if (childHasAttr) {
            if (!DomUtils._LEGAL_ATTRIBUTES[attr.name]) {
              child.removeAttribute(attr.nodeName);
            }
          }
        }

        DomUtils._cleanElementHtml(child);
      } else if (child) {
        node.removeChild(child);
      }
    }
  }
};
/**
 * Checks to see if the "ancestorNode" is a ancestor of "node".
 *
 * @param {!Element} ancestorNode dom subtree to check to see if the target node exists
 * @param {!Element} node target node to check to see if it exists within a subtree rooted at the ancestorNode
 * @return {boolean} <code>true</code> if the "ancestorNode" is a ancestor of "node".
 */


DomUtils.isAncestor = function (ancestorNode, node) {
  // These can cause problems in IE11: sometimes the node is just an "empty" object
  // oj.Assert.assertDomElement(ancestorNode);
  // oj.Assert.assertDomElement(node);
  var parentNode = node.parentNode;

  while (parentNode) {
    if (parentNode === ancestorNode) {
      return true;
    }

    parentNode = parentNode.parentNode;
  }

  return false;
};
/**
 * Checks to see if the "ancestorNode" is a ancestor of "node" or if they are the same.
 *
 * @param {!Element} ancestorNode dom subtree to check to see if the target node exists
 * @param {!Element} node target node to check to see if it exists within a subtree rooted at the ancestorNode
 * @return {boolean} <code>true</code> if the "ancestorNode" is a ancestor of "node" or if they are the same
 */


DomUtils.isAncestorOrSelf = function (ancestorNode, node) {
  // These can cause problems in IE11: sometimes the node is just an "empty" object
  // oj.Assert.assertDomElement(ancestorNode);
  // oj.Assert.assertDomElement(node);
  return node === ancestorNode ? true : DomUtils.isAncestor(ancestorNode, node);
};
/**
 * Adds a resize listener for a block or inline-block element
 * @param {!Element} elem - node where the listener should be added
 * @param {!Function} listener - listener to be added. The listener will receive
 * two parameters: 1) the new width in pixels; 2) the new height in pixels
 * @param {number=} collapseEventTimeout - timeout in milliseconds for collapsing
 * multiple resize events into one
 * @export
 */


DomUtils.addResizeListener = function (elem, listener, collapseEventTimeout) {
  var jelem = $(elem);
  var tracker = jelem.data(DomUtils._RESIZE_TRACKER_KEY);

  if (tracker == null) {
    tracker = new DomUtils._ResizeTracker(elem);
    jelem.data(DomUtils._RESIZE_TRACKER_KEY, tracker);
    tracker.start();
  }

  tracker.addListener(listener, collapseEventTimeout);
};
/**
 * Removes a resize listener
 * @param {!Element} elem - node whose listener should be removed
 * @param {!Function} listener - listener to be removed
 * @export
 */


DomUtils.removeResizeListener = function (elem, listener) {
  var jelem = $(elem);
  var tracker = jelem.data(DomUtils._RESIZE_TRACKER_KEY);

  if (tracker != null) {
    tracker.removeListener(listener);

    if (tracker.isEmpty()) {
      tracker.stop();
      jelem.removeData(DomUtils._RESIZE_TRACKER_KEY);
    }
  }
};
/**
 * Fixes resize listeners after a subtree has been connected to the DOM or after
 * its display:none stayle has been removed
 * @param {!Element} subtreeRoot - subtree root
 */


DomUtils.fixResizeListeners = function (subtreeRoot) {
  $(subtreeRoot).find('.oj-helper-detect-expansion').parent().each(function (index, div) {
    var tracker = $(div).data(DomUtils._RESIZE_TRACKER_KEY);

    if (tracker != null) {
      tracker.init(true);
    }
  });
};
/**
 * Determines whether a special 'meta' key was pressed when the event was fired.
 * For Mac OS, the 'meta' key is mapped to the 'Command' key, for all other platforms it is mapped
 * to the 'Control' key.
 * Note that this method will only work for the events that support .ctrlKey and .metaKey fields.
 * @param {!Object} evt - the event
 * @return true if the meta key is pressed, false otherwise
 */


DomUtils.isMetaKeyPressed = function (evt) {
  var agentInfo = oj.AgentUtils.getAgentInfo();
  return oj.AgentUtils.OS.MAC === agentInfo.os ? evt.metaKey : evt.ctrlKey;
};
/**
 * Dispatches an event on the element
 * @param {!Element} element
 * @param {!Event} evt event object
 */


DomUtils.dispatchEvent = function (element, evt) {
  // Workaround for Mozilla issue #329509 - dispatchEvent() throws an error if
  // the element is disabled and disconnected
  // Also, IE simply ignores the .dispatchEvent() call for disabled elements
  var dis = 'disabled';
  var oldDisabled = element[dis];

  try {
    // eslint-disable-next-line no-param-reassign
    element[dis] = false;
    element.dispatchEvent(evt);
  } finally {
    // eslint-disable-next-line no-param-reassign
    element[dis] = oldDisabled;
  }
};
/**
 * @private
 */


DomUtils._invokeAfterPaint = (window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || function (fn) {
  return window.setTimeout(fn, 0); // @HTMLUpdateOK
}).bind(window);
/**
 * @private
 */


DomUtils._cancelInvokeAfterPaint = (window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || function (id) {
  return window.clearTimeout(id);
}).bind(window);
/**
 * Utility class for tracking resize events for a given element and  sispatching them
 * to listeners
 * @constructor
 * @ignore
 * @private
 */


DomUtils._ResizeTracker = function (div) {
  var _listeners = $.Callbacks();

  var _collapsingManagers = [];
  var _collapsingListeners = [];
  var _RETRY_MAX_COUNT = 2;
  var _retrySetScroll = 0;
  var _invokeId = null;
  var _oldWidth = null;
  var _oldHeight = null;
  var _detectExpansion = null;
  var _detectContraction = null;
  var _resizeListener = null;
  var _scrollListener = null;

  this.addListener = function (listener, collapseEventTimeout) {
    if (collapseEventTimeout === undefined || collapseEventTimeout === 0) {
      _listeners.add(listener);
    } else {
      _collapsingManagers.push(new DomUtils._collapsingListenerManager(listener, collapseEventTimeout));

      _collapsingListeners.push(listener);
    }
  };

  this.removeListener = function (listener) {
    var index = _collapsingListeners.indexOf(listener);

    if (index >= 0) {
      _collapsingListeners.splice(index, 1);

      var removed = _collapsingManagers.splice(index, 1);

      removed[0].stop();
    } else {
      _listeners.remove(listener);
    }
  };

  this.isEmpty = function () {
    return !_listeners.has() && _collapsingListeners.length === 0;
  };

  this.start = function () {
    _scrollListener = _handleScroll.bind(this); // : Use native onresize support on teh DIV in IE9/10 and  since no scroll events are fired on the
    // contraction/expansion DIVs in IE9

    if (div.attachEvent) {
      _resizeListener = _handleResize.bind(this);
      div.attachEvent('onresize', _resizeListener);
    } else {
      var firstChild = div.childNodes[0]; // This child DIV will track expansion events. It is meant to be 1px taller and wider than the DIV
      // whose resize events we are tracking. After we set its scrollTop and scrollLeft to 1, any increate in size
      // will fire a scroll event

      _detectExpansion = document.createElement('div');
      _detectExpansion.className = 'oj-helper-detect-expansion';
      var expansionChild = document.createElement('div');

      _detectExpansion.appendChild(expansionChild); // @HTMLUpdateOK expansionChild constructed by the code above


      if (firstChild != null) {
        div.insertBefore(_detectExpansion, firstChild); // @HTMLUpdateOK _detectExpansion constructed by the code above
      } else {
        div.appendChild(_detectExpansion); // @HTMLUpdateOK _detectExpansion constructed by the code above
      }

      _detectExpansion.addEventListener('scroll', _scrollListener, false); // This child DIV will track contraction events. Its height and width are set to 200%. After we set its scrollTop and
      // scrollLeft to the current height and width of its parent, any decrease in size will fire a scroll event


      _detectContraction = document.createElement('div');
      _detectContraction.className = 'oj-helper-detect-contraction';
      var contractionChild = document.createElement('div');
      contractionChild.style.width = '200%';
      contractionChild.style.height = '200%';

      _detectContraction.appendChild(contractionChild); // @HTMLUpdateOK contractionChild constructed by the code above


      div.insertBefore(_detectContraction, _detectExpansion); // @HTMLUpdateOK _detectContraction constructed by the code above

      _detectContraction.addEventListener('scroll', _scrollListener, false);

      this.init(false);
    }
  };

  this.stop = function () {
    if (_invokeId != null) {
      DomUtils._cancelInvokeAfterPaint(_invokeId);

      _invokeId = null;
    }

    if (_detectExpansion != null) {
      _detectExpansion.removeEventListener('scroll', _scrollListener);

      _detectContraction.removeEventListener('scroll', _scrollListener); // Check before removing to prevent CustomElement polyfill from throwing
      // a NotFoundError when removeChild is called with an element not in the DOM


      if (_detectExpansion.parentNode) {
        div.removeChild(_detectExpansion);
      }

      if (_detectContraction.parentNode) {
        div.removeChild(_detectContraction);
      }
    } else {
      // assume IE9/10
      div.detachEvent('onresize', _resizeListener);
    }
  };

  this.init = function (isFixup) {
    var adjusted = _checkSize(isFixup);

    if (isFixup && !adjusted && _detectExpansion.offsetParent != null) {
      _adjust(_oldWidth, _oldHeight);
    }
  };

  function _checkSize(fireEvent) {
    var adjusted = false;

    if (_detectExpansion.offsetParent != null) {
      var newWidth = _detectExpansion.offsetWidth;
      var newHeight = _detectExpansion.offsetHeight;

      if (_oldWidth !== newWidth || _oldHeight !== newHeight) {
        _retrySetScroll = _RETRY_MAX_COUNT;

        _adjust(newWidth, newHeight);

        adjusted = true;

        if (fireEvent) {
          _notifyListeners(true);
        }
      }
    }

    return adjusted;
  }

  function _notifyListeners(useAfterPaint) {
    var newWidth = div.offsetWidth;
    var newHeight = div.offsetHeight;

    if (_listeners.has()) {
      if (!useAfterPaint) {
        _listeners.fire(newWidth, newHeight);
      } else {
        if (_invokeId !== null) {
          DomUtils._cancelInvokeAfterPaint(_invokeId);
        }

        _invokeId = DomUtils._invokeAfterPaint(function () {
          _invokeId = null;

          _listeners.fire(newWidth, newHeight);
        });
      }
    }

    for (var i = 0; i < _collapsingManagers.length; i++) {
      _collapsingManagers[i].getCallback()(newWidth, newHeight);
    }
  }

  function _handleScroll(evt) {
    evt.stopPropagation();

    if (!_checkSize(true)) {
      // Workaround for the WebKit issue where scrollLeft gets reset to 0 without the DIV being expanded
      // We will retry to the set the scrollTop only twice to avoid infinite loops
      if (_retrySetScroll > 0 && _detectExpansion.offsetParent != null && (_detectExpansion.scrollLeft === 0 || _detectExpansion.scrollTop === 0)) {
        _retrySetScroll -= 1;

        _adjust(_oldWidth, _oldHeight);
      }
    }
  }

  function _handleResize() {
    _notifyListeners(false);
  }

  function _adjust(width, height) {
    _oldWidth = width;
    _oldHeight = height;
    var expansionChildStyle = _detectExpansion.firstChild.style;
    var delta = 1; // The following loop is a workaround for the WebKit issue with zoom < 100% -
    // the scrollTop/Left gets reset to 0 because it gets computed to a value less than 1px.
    // We will try up to the delta of 5 to support scaling down to 20% of the original size

    do {
      expansionChildStyle.width = width + delta + 'px';
      expansionChildStyle.height = height + delta + 'px';
      _detectExpansion.scrollLeft = delta;
      _detectExpansion.scrollTop = delta;
      delta += 1;
    } while ((_detectExpansion.scrollTop === 0 || _detectExpansion.scrollLeft === 0) && delta <= 5);

    _detectContraction.scrollLeft = width;
    _detectContraction.scrollTop = height;
  }
};

DomUtils._RESIZE_TRACKER_KEY = '_ojResizeTracker';
/**
 * Returns true if the name is a valid identifier
 *
 * @param {string} name
 * @return {boolean} true if the name is a valid identifier
 */

DomUtils.isValidIdentifier = function (name) {
  return /^[A-Za-z][0-9A-Z_a-z-]*$/.test(name);
};
/**
 * @constructor
 * @ignore
 */


DomUtils._collapsingListenerManager = function (originalCallback, timeout) {
  var _lastArgs = null;
  var _timerId = null;

  var _timerCallback = function _timerCallback() {
    originalCallback.apply(null, _lastArgs);
    _timerId = null;
  };

  var _callback = function _callback() {
    _lastArgs = Array.prototype.slice.call(arguments);

    if (_timerId == null) {
      _timerId = window.setTimeout(_timerCallback, timeout);
    }
  };

  this.getCallback = function () {
    return _callback;
  };

  this.stop = function () {
    if (_timerId != null) {
      window.clearTimeout(_timerId);
      _timerId = null;
    }
  };
};
/**
 * @return {boolean} true if touch is supported
 */


DomUtils.isTouchSupported = function () {
  return 'ontouchstart' in window || // C, FF, Safari, Edge
  navigator.msMaxTouchPoints > 0 // IE10
  || navigator.maxTouchPoints > 0; // IE11
};
/**
 * @ignore
 */


DomUtils.setInKoCleanExternal = function (node) {
  DomUtils._koCleanNode = node;
};
/**
 * Delegates to JQuery's unwrap() if the component's node is not currently
 * being removed by Knockout
 * @param {Object} locator
 * @param {Object=} replaceLocator - locator to be replaced. I fthis parameter is ommitted,
 * the parent node will be replaced
 * @ignore
 */


DomUtils.unwrap = function (locator, replaceLocator) {
  var koCleanNode = DomUtils._koCleanNode;

  if (koCleanNode) {
    if (locator.get(0) === koCleanNode) {
      // skip unwrap
      return;
    }
  }

  if (replaceLocator) {
    replaceLocator.replaceWith(locator); // @HTMLUpdateOK
  } else {
    locator.unwrap();
  }
};
/**
 * Determines if the mouse event target is on browser chrome - i.e. "scrollbar".
 * If the event is not a mouse event with a clientX and clientY, the resultant will
 * be false.
 *
 * @param {Event} event native dom event
 * @returns {boolean} <code>true</code> if the target of the mouse event is browser
 *          chrome such as scrollbars.
 * @public
 */


DomUtils.isChromeEvent = function (event) {
  /**
   * @param {Event} event
   * @return {boolean}
   */
  function _isChromeEventGecko(_event) {
    // assume that if we can't access the original target of the event, then it's because
    // the target was implemented in XUL and is part of the chrome;
    try {
      return !_event.originalTarget.localName;
    } catch (e) {
      return true;
    }
  }
  /**
   * @param {Event} event
   * @return {boolean}
   */


  function _isChromeEventIE(_event) {
    /*
      //IE has a specific API for this but doesn't seem to want to work in automation.
      //The webkit method works in IE too.  Using that over componentFromPoint but leaving
      //the code for future reference.
      //
      var target = event.target;
      var chromePart = target.componentFromPoint(event.clientX, event.clientY);
      if (oj.StringUtils.isEmpty(chromePart))
        return false;
      else
        return true;
    */
    return _isChromeEventWebkit(_event);
  }
  /**
   * @param {Event} event
   * @return {boolean}
   */


  function _isChromeEventWebkit(_event) {
    var domTarget = _event.target;
    var target = $(domTarget);
    var pos = domTarget.getBoundingClientRect();
    var sbw = DomUtils.getScrollBarWidth();
    var isLTR = DomUtils.getReadingDirection() === 'ltr';

    if (isLTR && (domTarget.nodeName === 'HTML' || target.css('overflow-x') !== 'visible') && _event.clientX > pos.right - sbw) {
      return true;
    } else if (!isLTR && domTarget.nodeName === 'HTML' && _event.clientX > pos.left - sbw) {
      // ltr scrollbar is always on the right
      return true;
    } else if (!isLTR && target.css('overflow-x') !== 'visible' && _event.clientX < pos.left + sbw) {
      // RTL scrollbar on the document is still on the right
      return true;
    } else if ((domTarget.nodeName === 'HTML' || target.css('overflow-y') !== 'visible') && _event.clientY > pos.bottom - sbw) {
      // RTL scrollbar not on the document is on the left
      return true;
    } // below the scrollbar


    return false;
  } // verify event is a mouse event


  if (!('clientX' in event) || !('clientY' in event)) {
    return false;
  }

  var agentInfo = oj.AgentUtils.getAgentInfo();

  if (oj.AgentUtils.OS.ANDROID === agentInfo.os || oj.AgentUtils.OS.IOS === agentInfo.os) {
    return false;
  }

  if (oj.AgentUtils.ENGINE.GECKO === agentInfo.engine) {
    return _isChromeEventGecko(event);
  } else if (oj.AgentUtils.ENGINE.WEBKIT === agentInfo.engine || oj.AgentUtils.ENGINE.BLINK === agentInfo.engine) {
    return _isChromeEventWebkit(event);
  }

  if (oj.AgentUtils.BROWSER.IE === agentInfo.browser) {
    return _isChromeEventIE(event);
  }

  return false;
};
/**
 * @returns {number} width of the browser scrollbar
 */


DomUtils.getScrollBarWidth = function () {
  var scrollBarWidth = DomUtils._scrollBarWidth;

  if ($.isNumeric(scrollBarWidth)) {
    return scrollBarWidth;
  }
  /** @type {jQuery} **/


  var scrollBarMeasure = $('<div></div>');
  $(document.body).append(scrollBarMeasure); // @HTMLUpdateOK scrollBarMeasure constructed by the code above

  scrollBarMeasure.width(50).height(50).css({
    overflow: 'scroll',
    visibility: 'hidden',
    position: 'absolute'
  });
  /** @type {jQuery} **/

  var scrollBarMeasureContent = $('<div></div>');
  scrollBarMeasureContent.height(1);
  scrollBarMeasure.append(scrollBarMeasureContent); // @HTMLUpdateOK scrollBarMeasureContent constructed by the code above

  var insideWidth = scrollBarMeasureContent.width();
  var outsideWitdh = scrollBarMeasure.width();
  scrollBarMeasure.remove();
  scrollBarWidth = outsideWitdh - insideWidth;
  DomUtils._scrollBarWidth = scrollBarWidth;
  return scrollBarWidth;
};
/**
 * @returns {string!} "rtl" or "ltr"
 */


DomUtils.getReadingDirection = function () {
  var dir = document.documentElement.getAttribute('dir');

  if (dir) {
    dir = dir.toLowerCase();
  }

  return dir === 'rtl' ? 'rtl' : 'ltr';
};
/**
 * Retrieve the bidi independent position of the horizontal scroll position that
 * is consistent across all browsers.
 * @param {Element} elem the element to retrieve the scrollLeft from
 * @return {number} the element's scrollLeft
 */


DomUtils.getScrollLeft = function (elem) {
  if (DomUtils.getReadingDirection() === 'rtl') {
    var browser = oj.AgentUtils.getAgentInfo().browser;

    if (browser === oj.AgentUtils.BROWSER.FIREFOX || browser === oj.AgentUtils.BROWSER.IE || browser === oj.AgentUtils.BROWSER.EDGE) {
      return Math.abs(elem.scrollLeft);
    } // webkit


    return Math.max(0, elem.scrollWidth - elem.clientWidth - elem.scrollLeft);
  }

  return elem.scrollLeft;
};
/**
 * Sets the bidi independent position of the horizontal scroll position that
 * is consistent across all browsers.
 * @param {Element} elem the element to set the scrollLeft on
 * @param {number} scrollLeft the element's new scrollLeft
 */


DomUtils.setScrollLeft = function (elem, scrollLeft) {
  if (DomUtils.getReadingDirection() === 'rtl') {
    var browser = oj.AgentUtils.getAgentInfo().browser;

    if (browser === oj.AgentUtils.BROWSER.FIREFOX) {
      // see mozilla , even though it's marked as fixed, they basically
      // did not change anything.  It still expects a negative value for RTL
      // eslint-disable-next-line no-param-reassign
      elem.scrollLeft = -scrollLeft;
    } else if (browser === oj.AgentUtils.BROWSER.IE || browser === oj.AgentUtils.BROWSER.EDGE) {
      // eslint-disable-next-line no-param-reassign
      elem.scrollLeft = scrollLeft;
    } else {
      // webkit
      // eslint-disable-next-line no-param-reassign
      elem.scrollLeft = Math.max(0, elem.scrollWidth - elem.clientWidth - scrollLeft);
    }
  } else {
    // eslint-disable-next-line no-param-reassign
    elem.scrollLeft = scrollLeft;
  }
};
/**
 * Converts a CSS length attribute into a integer value.
 * Conversion errors or non-number will result in a zero
 * resultant.
 *
 * @param {?} cssLength style attribute
 * @return {number} value as integer
 */


DomUtils.getCSSLengthAsInt = function (cssLength) {
  if (!isNaN(cssLength)) {
    return parseInt(cssLength, 10);
  }

  if (cssLength && cssLength.length > 0 && cssLength !== 'auto') {
    var intLength = parseInt(cssLength, 10);

    if (isNaN(intLength)) {
      intLength = 0;
    }

    return intLength;
  }

  return 0;
};
/**
 * Converts a CSS attribute into a float value.
 * Conversion errors or non-number will result in a zero
 * resultant.
 *
 * @param {?} cssLength style attribute
 * @return {number} value as integer
 */


DomUtils.getCSSLengthAsFloat = function (cssLength) {
  if (!isNaN(cssLength)) {
    return parseFloat(cssLength);
  }

  if (cssLength && cssLength.length > 0) {
    var floatLength = parseFloat(cssLength);

    if (isNaN(floatLength)) {
      floatLength = 0;
    }

    return floatLength;
  }

  return 0;
};
/**
 * Key used to store the logical parent of the popup element
 * as a jQuery data property. The logical parent refers the launcher of a popup.
 * @const
 * @private
 * @type {string}
 */


DomUtils._LOGICAL_PARENT_DATA = 'oj-logical-parent';
/**
 * This method returns the launcher of a popup when it's open.
 * Returns undefined otherwise.
 *
 * @param {jQuery} element jquery element
 * @returns {any}
 * @see #setLogicalParent
 */

DomUtils.getLogicalParent = function (element) {
  if (element) {
    return element.data(DomUtils._LOGICAL_PARENT_DATA);
  }

  return undefined;
};
/**
 * Set the logical parent as a jQuery data property
 *
 * @param {jQuery} element jquery element
 * @param {jQuery | null} parent jquery element
 * @see #getLogicalParent
 */


DomUtils.setLogicalParent = function (element, parent) {
  if (!element) {
    return;
  }

  if (parent === null) {
    element.removeData(DomUtils._LOGICAL_PARENT_DATA);
  } else {
    element.data(DomUtils._LOGICAL_PARENT_DATA, parent);
  }
};
/**
 * Checks to see if the "ancestorNode" is a logical ancestor of "node"
 *
 * @param {!Element} ancestorNode dom subtree to check to see if the target node exists
 * @param {!Element} node target node to check to see if it exists within a subtree rooted at the ancestorNode
 * @return {boolean} <code>true</code> if the "ancestorNode" is a logical ancestor of "node" or if they are the same
 */


DomUtils.isLogicalAncestorOrSelf = function (ancestorNode, node) {
  oj.Assert.assertDomElement(ancestorNode);
  oj.Assert.assertDomElement(node);
  var parentNode = node;

  while (parentNode) {
    if (parentNode === ancestorNode) {
      return true;
    }

    var logicalParent = DomUtils.getLogicalParent($(parentNode));

    if (logicalParent) {
      parentNode = logicalParent[0];
    } else {
      parentNode = parentNode.parentNode;
    }
  }

  return false;
};
/**
 * Checks whether the href represents a safe URL
 * @param {!string} href - HREF to test
 * @param {Array=} whitelist - optional list of the allowed protocols. Protocol name has to use lowercase letters and
 * be followed by a ':'. If the parameter is ommitted, ['http:', 'https:'] will be used
 * @throws {Exception} an error if the HREF represents an invalid URL
 * @ignore
 */


DomUtils.validateURL = function (href, whitelist) {
  var allowed = whitelist || ['http:', 'https:'];
  var link = document.createElement('a');
  link.href = href;
  var protocol = link.protocol;

  if (protocol != null) {
    protocol = protocol.toLowerCase();
  } // if it isn't on the allowed list and it isn't '', throw an error.
  // IE11 returns '' for hrefs like 'abc', other browsers return 'https'
  // and we want to allow hrefs like 'abc' since those are relative urls.


  if (allowed.indexOf(protocol) < 0 && protocol !== '') {
    throw new Error(protocol + ' is not a valid URL protocol');
  }
};
/**
 * Cancels native context menu events for hybrid mobile applications.
 * @private
 */


DomUtils._supressNativeContextMenu = function () {
  if ($(document.body).hasClass('oj-hybrid')) {
    document.body.addEventListener('contextmenu', function (event) {
      if (event.target.nodeName !== 'INPUT') {
        event.preventDefault();
      }
    }, true);
  }
};

DomUtils._supressNativeContextMenu(); // standard duration of a pressHold gesture.  Point of reference: default
// JQ Mobile threshold to be a press-and-hold is 750ms.


DomUtils.PRESS_HOLD_THRESHOLD = 750; // ------------------------------------------------------------------------------------------------
// Recent touch end
// ------------------------------------------------------------------------------------------------

/**
 * Returns true if a touchend or touchcancel has been detected anywhere in the document in the last 500 ms.
 * Note: This function adds event listeners only once per document load.
 *
 * @return {boolean} boolean indicating whether a touch has recently been detected
 */

DomUtils.recentTouchEnd = function () {
  // This function is immediately executed and returns the recentTouchEnd function
  // and therefore only execute once per document load.
  var touchTimestamp = 0;
  var TOUCH_THRESHOLD = 500;

  function _touchEndHandler() {
    touchTimestamp = Date.now();
  } // --- Document listeners ---


  document.addEventListener('touchend', _touchEndHandler, true);
  document.addEventListener('touchcancel', _touchEndHandler, true); // --- The function assigned to DomUtils.recentTouchEnd ---

  return function () {
    // must be at least 300 for the "300ms" delay
    return Date.now() - touchTimestamp < TOUCH_THRESHOLD;
  };
}();
/**
 * Returns true if a touchstart has been detected anywhere in the document in the last 800 ms.
 * Note: This function adds event listeners only once per document load.
 *
 * @return {boolean} boolean indicating whether a touch has recently been detected
 */


DomUtils.recentTouchStart = function () {
  // This function is immediately executed and returns the recentTouchStart function
  // and therefore only execute once per document load.
  var touchTimestamp = 0; // 800 because this is used to ignore mouseenter and focusin on 'press', and a 'press'
  // is usually detected after 750ms.

  var TOUCH_THRESHOLD = DomUtils.PRESS_HOLD_THRESHOLD + 50;

  function _touchStartHandler() {
    touchTimestamp = Date.now();
  } // --- Document listeners ---


  document.addEventListener('touchstart', _touchStartHandler, {
    passive: true,
    capture: true
  }); // --- The function assigned to DomUtils.recentTouchStart ---

  return function () {
    // must be at least TOUCH_THRESHOLD for the  delay
    return Date.now() - touchTimestamp < TOUCH_THRESHOLD;
  };
}(); // ------------------------------------------------------------------------------------------------
// Recent pointer
// ------------------------------------------------------------------------------------------------

/**
 * Returns true if a touchstart, touchend, mousedown, or mouseup has been detected anywhere in the
 * document in the last n ms, where n is calibrated across a variety of platforms to make this API
 * a maximally reliable indicator of whether the code now running was likely "caused by" the
 * specified touch and mouse interaction, vs. some other thing (e.g. mousemove, keyboard, or page
 * load).  E.g. the makeFocusable() / _focusable() mechanism uses this API to vary the focus theming
 * depending on whether the element was focused via keyboard or pointer.
 *
 * @return {boolean} boolean indicating whether a mouse button or finger has recently been down or up
 */


DomUtils.recentPointer = function () {
  // The comments in this function are tailored to the makeFocusable() usage.
  // - Let "pointer down" mean mousedown or touchstart, and "pointer up" likewise.  (Not MS pointer events.)
  // - Event order can be 1) mousedown>focus>mouseup (like push buttons) or 2) mousedown>mouseup>focus (like toggle buttons).
  // - For 2, semantics for "focus caused by pointer" must be "if pointer interaction in last n ms," rather than "if pointer is currently down".
  // - Those "last n ms" semantics are preferred for 1 as well, rather than relying on pointer up to cancel a state set by pointer down,
  //   since if the pointer up is never received, we'd get stuck in an inaccessible state.
  // - So both pointer down and pointer up set a timestamp, and recentPointer() returns true if Date.now() is within n ms of that timestamp,
  //   where n is higher for touchstart per below.
  // Timestamp of last mousedown/up or touchstart/end. Initial value of 0 (1/1/1970) guarantees that if element is focused before any
  // mouse/touch interaction, then recentPointer() is false, so focus ring appears as desired.
  var pointerTimestamp = 0;
  var pointerTimestampIsTouchStart; // whether the latest timestamp is for touchstart vs. touchend/mouse
  // On Edge (Surface Win10), the lag from the up event to resulting programmatic focus is routinely ~350ms, even when the 300ms "tap delay" has
  // been prevented and confirmed to be absent.  (In Chrome on same device the same lag is ~10 ms.)  So use 600ms to be safe.  Even on Chrome,
  // the lag from the down/up event to natively induced focus can routinely be well into the 1xx ms range. Can exceed 600 if needed. There is no
  // need for a tight bound; if there was pointer interaction in the last second or so, it's perfectly reasonable to suppress the focus ring.

  var POINTER_THRESHOLD_CUSHION = 600; // If the number of millis since the last pointer down or up is < this threshold, then recentPointer() considers it recent and returns true.
  // See also TOUCHSTART_THRESHOLD.

  var POINTER_THRESHOLD = POINTER_THRESHOLD_CUSHION; // For touchstart only, use 750+600ms so that focus set by a 750ms pressHold gesture (e.g. context menu) is recognized as touch-related.  Same
  // 600ms padding as for POINTER_THRESHOLD.  A high threshold is OK, as it is used only for actual pressHolds (and the unusual case where the
  // pointer up is never received), since for normal clicks and taps, the pointerUp replaces the "1350ms after touchstart" policy with a "600ms
  // after pointerUp" policy. On Edge and desktop FF (desktop version runs on hybrid devices like Surface), which lack touchstart, context menus
  // are launched by the contextmenu event, which happen after the pointer up in both browsers, so the fact that we're using the higher
  // threshold only for touchstart should not be a problem there.

  var TOUCHSTART_THRESHOLD = DomUtils.PRESS_HOLD_THRESHOLD + POINTER_THRESHOLD_CUSHION; // --- Document listeners ---
  // Use capture phase to make sure we hear the events before someone cancels them

  document.addEventListener('mousedown', function () {
    // If the mousedown immediately follows a touchstart, i.e. if it seems to be the compatibility mousedown
    // corresponding to the touchstart, then we want to consider it a "recent pointer activity" until the end time
    // that is max(touchstartTime + TOUCHSTART_THRESHOLD, now + POINTER_THRESHOLD), where now is mousedownTime in this
    // case.  (I.e. it would defeat the purpose if the inevitable mousedown replaced the longer touchstart threshold with
    // a shorter one.)  We don't do this in the touchend/mouseup listeners, as those obviously happen after the pressHold
    // is over, in which case the following analysis applies:
    // - If the pressHold was < PRESS_HOLD_THRESHOLD ms,
    // - then the higher TOUCHSTART_THRESHOLD is not needed or relevant, since anything focused on pressHold
    //   (like a context menu) never happened,
    // - else the touchend/mouseup happened > PRESS_HOLD_THRESHOLD ms after the touchstart, so in the max() above,
    //   the 2nd quantity is always bigger (later).
    var now = Date.now();

    if (!pointerTimestampIsTouchStart || now > pointerTimestamp + DomUtils.PRESS_HOLD_THRESHOLD) {
      pointerTimestamp = now;
      pointerTimestampIsTouchStart = false;
    }
  }, true);
  document.addEventListener('touchstart', function () {
    pointerTimestamp = Date.now();
    pointerTimestampIsTouchStart = true;
  }, {
    passive: true,
    capture: true
  });
  document.addEventListener('mouseup', function () {
    pointerTimestamp = Date.now();
    pointerTimestampIsTouchStart = false;
  }, true);
  document.addEventListener('touchend', function () {
    pointerTimestamp = Date.now();
    pointerTimestampIsTouchStart = false;
  }, true); // --- The function assigned to DomUtils.recentPointer ---

  return function () {
    var millisSincePointer = Date.now() - pointerTimestamp;
    var threshold = pointerTimestampIsTouchStart ? TOUCHSTART_THRESHOLD : POINTER_THRESHOLD;
    var isRecent = millisSincePointer < threshold;
    return isRecent;
  };
}(); // ------------------------------------------------------------------------------------------------
// Utility for suppressing focus ring for mouse/touch interaction, but not KB or other interaction:
// ------------------------------------------------------------------------------------------------

/**
 * This API works like baseComponent's _focusable() API (see its detailed JSDoc), with the
 * similarities and differences listed below.  This API is intended for non-component callers;
 * components should typically call the baseComponent API via this._focusable().
 *
 * Comparison to baseComponent._focusable() :
 *
 * - This function's "options" param must be an object.  Only baseComponent._focusable()
 *   supports the backward-compatibility syntax where the options param can be the element.
 * - Same usage of oj-focus, oj-focus-highlight, and $focusHighlightPolicy.
 * - Same required invariant that oj-focus-highlight must not be set if oj-focus is not set.
 * - Same parameters with same semantics, plus the additional "component" and "remove" params
 *   discussed below.
 * - New options.component param, which takes a JET component instance.  (When a component is
 *   involved, typically that component should call this._focusable() rather than calling this
 *   version of the method directly.)
 *
 * If options.component is specified, then the following things work like the baseComponent
 * version of this API:
 *
 * - If the specified element is in the component subtree,
 *   then the classes will automatically be removed when the component is
 *   destroyed/disabled/detached, as detailed in the baseComponent JSDoc,
 *   else the caller has the same responsibility to remove the classes at those times.
 * - Same rules as to whether listeners are automatically cleaned up, or suppressed when the
 *   component is disabled, vs. being the caller's responsibility to handle those things.
 *
 * If options.component is NOT specified (for non-component callers), then those things are
 * the caller's responsibility.  Specifically:
 *
 * - Class removal can be done directly, as needed.
 * - To remove the listeners, see the following.
 *
 * Listener removal:
 *
 * - If options.component was specified, see above.
 * - Else if options.setupHandlers was specified, then only the caller knows what listeners were
 *   registered and how, so it is the caller's responsibility to remove them directly when needed.
 * - The remaining case is that options.component and options.setupHandlers were not specified.
 *   To remove from element e both the 2 classes and all listeners applied to e by all previous
 *   invocations of makeFocusable() where these options were not specified,
 *   call makeFocusable( {'element': e, 'remove': true} ).
 */
// If this is named focusable(), Closure Compiler generates a warning, and fails to rename the function in minified code,
// which suggests that focusable (not just _focusable) is apparently externed somewhere (although not in
// 3rdparty\jquery\externs\jquery-1.8.js, main\javascript\externs.js, or build\tools\closure\compiler.jar\externs.zip\),
// perhaps for JQUI's :focusable selector.  So name it makeFocusable().


DomUtils.makeFocusable = function () {
  var nextId = 0; // used for unique namespace, for "remove" functionality
  // This private var is shared by all callers that use makeFocusable() and don't supply their own focus highlight policy.
  // If the oj-focus-config SASS object ever acquires a 2nd field, should continue to call pJFFF() only once, statically.

  var FOCUS_HIGHLIGHT_POLICY = (ThemeUtils.parseJSONFromFontFamily('oj-focus-config') || {}).focusHighlightPolicy;
  /**
   * @param {function()} focusPolicyCallback Optional getter passed to makeFocusable() by callers wishing to get use a caller-
   *   specific focus policy mechanism instead of the built-in mechanism.
   * @param {function()} recentPointerCallback Optional function passed to makeFocusable() by callers wishing to use a caller-
   *   specific mechanism in addition to the built-in mechanism.
   * @return {boolean} boolean indicating whether it is appropriate to apply the <code class="prettyprint">oj-focus-highlight</code>
   *   CSS class for a focus happening at the time of this method call.
   */

  var shouldApplyFocusHighlight = function shouldApplyFocusHighlight(focusPolicyCallback, recentPointerCallback) {
    var focusHighlightPolicy = focusPolicyCallback ? focusPolicyCallback() : FOCUS_HIGHLIGHT_POLICY;

    switch (focusHighlightPolicy) {
      case 'all':
        return true;

      case 'none':
        return false;

      default:
        // "nonPointer" or no value provided (e.g. SASS var missing)
        return !(DomUtils.recentPointer() || recentPointerCallback && recentPointerCallback());
    }
  }; // the function assigned to DomUtils.makeFocusable


  var makeFocusable = function makeFocusable(options) {
    var element = options.element;
    var dataKey = 'ojFocusable';
    var namespacePrefix = '.' + dataKey;
    var namespaceSeparator = ' ' + namespacePrefix;

    if (options.remove) {
      element.removeClass('oj-focus oj-focus-highlight'); // id's of listeners needing removal

      var ids = element.data(dataKey);

      if (ids == null) {
        return;
      } // map ids to namespaces.  "2" -> ".ojFocusable2".  "2,7" -> ".ojFocusable2 .ojFocusable7"


      var namespaces = namespacePrefix + ('' + ids).split(',').join(namespaceSeparator);
      element.off(namespaces) // remove the listeners
      .removeData(dataKey); // clear list of listener id's needing removal

      return;
    }

    var afterToggle = options.afterToggle || $.noop;

    function applyOnlyFocus(_element) {
      _element.addClass('oj-focus');

      afterToggle('focusin');
    }

    function applyBothClasses(_element) {
      _element.addClass('oj-focus');

      if (shouldApplyFocusHighlight(options.getFocusHighlightPolicy, options.recentPointer)) {
        _element.addClass('oj-focus-highlight');
      }

      afterToggle('focusin');
    }

    var addClasses = options.applyHighlight ? applyBothClasses : applyOnlyFocus;

    function removeClasses(_element) {
      _element.removeClass('oj-focus oj-focus-highlight');

      afterToggle('focusout');
    }

    var hasFocus = false;

    var setupHandlers = options.setupHandlers || function (focusInHandler, focusOutHandler) {
      var component = options.component;

      var focusInListener = function focusInListener(event) {
        focusInHandler($(event.currentTarget));
        hasFocus = true;
      };

      var focusOutListener = function focusOutListener(event) {
        // We should only do this once, even though this event may fire multiple times.
        if (hasFocus) {
          focusOutHandler($(event.currentTarget));
          hasFocus = false;
        }
      };

      if (component) {
        component._on(element, {
          focusin: focusInListener,
          focusout: focusOutListener
        });
      } else {
        // neither options.component nor options.setupHandlers were passed, so we must provide a
        // way for the caller to remove the listeners.  That's done via the "remove" param, which
        // uses the namespaces that we stash via data().
        var id = nextId;
        nextId += 1; // list of id's of existing listeners needing removal

        var _ids = element.data(dataKey); // append id to that list, or start new list if first one


        element.data(dataKey, _ids == null ? id : _ids + ',' + id); // add listeners namespaced by that id

        var handlers = {};
        var namespace = namespacePrefix + id;
        handlers['focusin' + namespace] = focusInListener;
        handlers['focusout' + namespace] = focusOutListener;
        element.on(handlers);
      }
    };

    setupHandlers(addClasses, removeClasses);
  };

  return makeFocusable;
}();

;return DomUtils;
});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojfocusutils',['ojs/ojcore-base', 'jquery', 'ojs/ojdomutils'], function(oj, $, DomUtils)
{
  "use strict";
/* jslint browser: true*/



/* global DomUtils:false */

/**
 * Focus utilities.
 * @ignore
 */
var FocusUtils = {}; // TODO Internal utility so we can remove once we replace oj.FocusUtils
// usages w/ FocusUtils as part of JET-35291

oj.FocusUtils = FocusUtils;
FocusUtils._TABBABLE = ':tabbable,iframe'; // These functions inspired by AdfFocusUtils

/**
 * Tests whether the specified element contains the keyboard focus.
 * @param {!Element} element Element for which to check if it contains focus.
 * @returns {boolean} True if the element contains focus, false otherwise.
 */

FocusUtils.containsFocus = function (element) {
  var activeElem = document.activeElement; // FIX : if either elem is undefined, just return false

  if (!element || !activeElem) {
    return false;
  }

  return DomUtils.isAncestorOrSelf(element, activeElem);
};
/**
 * Sets focus to the specified element.
 * @param {!Element} element Element to focus.
 */


FocusUtils.focusElement = function (element) {
  element.focus();
};
/**
 * Sets focus to the first tabbable element inside the given element, which
 * may be the given element itself.
 * @param {!Element} element Element to start searching for a tabbable element in.
 * @returns {Element} The DOM element that was focused, if any.
 */


FocusUtils.focusFirstTabStop = function (element) {
  var focusElement = FocusUtils.getFirstTabStop(element);

  if (focusElement) {
    FocusUtils.focusElement(focusElement);
  }

  return focusElement;
};
/**
 * Return true if the activeElement is the first tabbable. Used to ensure that tabbing cycles through dialogs/popups.
 * @param {!Element} element Element containing tabbable elements.
 * @returns {boolean} <code>true</code> if the active element is the first tabbable.
 */


FocusUtils.isFirstActiveElement = function (element) {
  var jqElem = $(element);
  var jqFocusables = jqElem.find(FocusUtils._TABBABLE);
  if (jqFocusables == null || jqFocusables.length === 0) return false;
  var first = jqFocusables[0];
  if (document.activeElement === first) return true; //
  // Return true if the activeElement is in the "first tabble set".
  // Check to see if the first tabbable and the active element are members
  // of the same radio set.
  // If this is the case, then return true.
  //

  if (first.name === document.activeElement.name && first.type === 'radio' && document.activeElement.type === 'radio') {
    return true;
  }

  return false;
};
/**
 * Return true if the activeElement is the last tabbable. Used to ensure that tabbing cycles through dialogs/popups.
 * @param {!Element} element Element containing tabbable elements.
 * @returns {boolean} <code>true</code> if the active element is the last tabbable.
 */


FocusUtils.isLastActiveElement = function (element) {
  var jqElem = $(element);
  var jqFocusables = jqElem.find(FocusUtils._TABBABLE);
  if (jqFocusables == null || jqFocusables.length === 0) return false;
  var last = jqFocusables[jqFocusables.length - 1];
  if (document.activeElement === last) return true; //
  // Return true if the activeElement is in the "first tabble set".
  // Check to see if the last tabbable and the active element are members
  // of the same radio set.
  // If this is the case, then return true.
  //

  if (last.name === document.activeElement.name && last.type === 'radio' && document.activeElement.type === 'radio') {
    return true;
  }

  return false;
};
/**
 * Get the first tabbable element inside the given element, which may be the
 * given element itself.
 * @param {!Element} element Element to start searching for a tabbable element in.
 * @returns {Element} The first tabbable element inside the given element.
 */


FocusUtils.getFirstTabStop = function (element) {
  var jqElem = $(element);

  if (jqElem.is(FocusUtils._TABBABLE)) {
    return element;
  }

  var jqFocusables = jqElem.find(FocusUtils._TABBABLE);

  if (jqFocusables && jqFocusables.length > 0) {
    //
    // Handle set-based content (radiosets).
    // Return the first selected radioset item.
    // Note that there are two cases
    //   Common case - a single radioset
    //   Other case - multiple radiosets
    // In both cases we return the first selected radioset item.
    //
    if (jqFocusables[0].classList.contains('oj-radio')) {
      var selectedItem = jqFocusables.filter('.oj-selected.oj-radio');

      if (selectedItem && selectedItem.length) {
        return selectedItem[0];
      }

      return jqFocusables[0];
    }

    return jqFocusables[0];
  }

  return null;
};
/**
 * Get the last tabbable element inside the given element, which may be the
 * given element itself.
 * @param {!Element} element Element to start searching for a tabbable element in.
 * @returns {Element} The last tabbable element inside the given element.
 */


FocusUtils.getLastTabStop = function (element) {
  var jqElem = $(element);
  var jqFocusables = jqElem.find(FocusUtils._TABBABLE);

  if (jqFocusables && jqFocusables.length > 0) {
    //
    // Handle set-based content (radiosets).
    // Return the last selected radioset item.
    //
    if (jqFocusables[jqFocusables.length - 1].classList.contains('oj-radio')) {
      var selectedItem = jqFocusables.filter('.oj-selected.oj-radio');

      if (selectedItem && selectedItem.length) {
        return selectedItem[selectedItem.length - 1];
      }

      return jqFocusables[jqFocusables.length - 1];
    }

    return jqFocusables[jqFocusables.length - 1];
  }

  return null;
};
/**
 * Extends the jquery ":focusable" pseudo selector check for a Safari browser specific
 * exception - an anchor element not having a tabindex attribute.
 *
 * @param {Element} element target dom element to test if it will take focus
 * @returns {boolean} <code>true</code> if the target element is focusable
 */


FocusUtils.isFocusable = function (element) {
  if ($(element).is(':focusable')) {
    // An anchor element in safari will not take focus unless it has a tabindex.
    // http://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#Clicking_and_focus
    if (element.nodeName === 'A' && !element.hasAttribute('tabindex') && oj.AgentUtils.getAgentInfo().browser === oj.AgentUtils.BROWSER.SAFARI) {
      return false;
    }

    return true;
  }

  return false;
};

;return FocusUtils;
});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojcomponentcore',['ojs/ojcore', 'ojs/ojtranslation', 'jquery', 'ojs/ojmessaging', 'ojs/ojlogger', 'ojs/ojmetadatautils',
        'ojs/ojdefaultsutils', 'ojs/ojcustomelement', 'jqueryui-amd/widget', 'jqueryui-amd/unique-id', 'jqueryui-amd/keycode', 'jqueryui-amd/focusable', 
        'jqueryui-amd/tabbable', 'ojs/ojdomutils', 'ojs/ojfocusutils'], 
  function(oj, Translations, $, Message, Logger, MetadataUtils, defaults)
{
  "use strict";
  var DefaultsUtils = defaults.DefaultsUtils;


/**
 * @namespace oj.Components
 * @classdesc JET Component services
 * @since 1.0
 * @export
 * @ojtsmodule
 * @hideconstructor
 */
oj.Components = {}; // this is the variable name that the AMD module will return in the require callback (used in a no-require environment)
// eslint-disable-next-line no-unused-vars

var Components = oj.Components;
/**
 * @private
 */

oj.Components._OJ_CONTAINER_ATTR = 'data-oj-container';
/**
 * @private
 */

var _OJ_WIDGET_NAMES_DATA = 'oj-component-names';
/**
 * Marks the element which is a jQueryUI component
 * @private
 */

var _OJ_COMPONENT_NODE_CLASS = 'oj-component-initnode';
/**
 * Marks an element as being hidden.
 *
 * @private
 */

var _OJ_SUBTREE_HIDDEN_CLASS = 'oj-subtree-hidden';
/**
 * Marks an element as a container that will control hidden of its children
 * once it finishes initializing
 *
 * @private
 */

var _OJ_PENDING_SUBTREE_HIDDEN_CLASS = 'oj-pending-subtree-hidden';
/**
 * Sets default options values for JET components.
 * @param {!Object} options - property values that will be merged into the values
 * that were previously set using this method. The options object is expected to have the format demonstrated
 * by the following example:
 * <pre>
 * {
 *   'default': // properties for all JET components
 *   {
 *     'option1': 'somevalue'
 *   },
 *   'editableValue': // properties for editableValue components
 *   {
 *     'option1': 'somevalue1',
 *     'option2': oj.Components.createDynamicPropertyGetter(function(context){
 *                                 return context['containers'].indexOf('ojTable') >= 0 ? 'tableValue' : 'normalValue'})
 *   },
 *   'ojText': // properties for instances of ojText
 *   {
 *     'option1': 'somevalue2'
 *   }
 * }
 * </pre>
 * To specify a dynamic getter for the property, pass your callback to oj.Components.createDynamicPropertyGetter(). Note
 * that dynamic getters nested within a complex property value are not supported
 * @see oj.Components.createDynamicPropertyGetter
 * @return {void}
 * @export
 * @ojtsignore
 */

oj.Components.setDefaultOptions = function (options) {
  var props = oj.Components._defaultProperties || {};
  var keys = Object.keys(options);
  keys.forEach(function (key) {
    var value = options[key];

    if (!oj.CollectionUtils.isPlainObject(value)) {
      throw new Error('Invalid default options');
    }

    props[key] = _accumulateValues(props[key] || {}, value, false);
  });
  oj.Components._defaultProperties = props;
};
/**
 * Retrieves default option values for JET components. This method should only be used internally by JET.
 * @deprecated since version 2.2
 * @ignore
 * @return {Object} default option values
 * @see oj.Components.setDefaultOptions
 * @export
 */


oj.Components.getDefaultOptions = function () {
  return oj.Components._defaultProperties || {};
};
/**
 * Creates a dynamic getter that can be used as a property value in oj.Components.setDefaultOptions()
 * @param {!Function} callback - dynamic property callback. The callback will receive a context object as a parameter.
 * The following properties are currently supported on the context object:
 * <ul>
 * <li>containers - an array of component names of the current component's containers that require special behavior from
 * their children</li>
 * <li>element - component's host DOM element</li>
 * </ul>
 * The callback should return the computed property value
 *
 * @return {Object} - dynamic property getter
 * @see oj.Components.setDefaultOptions
 * @export
 * @ojtsignore
 */


oj.Components.createDynamicPropertyGetter = function (callback) {
  return new __ojDynamicGetter(callback);
};
/**
 * This method should only be used for JQueryUI components and will return null if used
 * with a custom element. Retrieves widget constructor associated with the HTML element
 * or null if none is found. The returned constructor is already bound to the associated
 * JQuery element, so it can be invoked as a function directly. For example:
 * <pre>
 * widgetConstructor("option", "label", "custom"); // sets label option
 * </pre>
 * If widgetName is not specified, and if more than one widget is associated with the element,
 * the method will a return the widget that was created first.
 * @param {?(Element|Node)} element - HTML element
 * @param {string=} widgetName - optional widget name
 * @return {Function|null} widget constructor
 * @export
 * @ojtsignore
 */


oj.Components.getWidgetConstructor = function (element, widgetName) {
  if (element && !oj.BaseCustomElementBridge.getRegistered(element.tagName)) {
    return oj.Components.__GetWidgetConstructor(element, widgetName);
  }

  return null;
};
/**
 * Internal version for components to call which won't return null for
 * custom elements. See public method for jsDoc.
 * @param {?(Element|Node)} element - HTML element
 * @param {string=} widgetName - optional widget name
 * @return {Function|null} widget constructor
 * @ignore
 */


oj.Components.__GetWidgetConstructor = function (element, widgetName) {
  var jelem = $(element);
  var data = jelem.data(_OJ_WIDGET_NAMES_DATA);

  if (data) {
    if (widgetName == null) {
      // eslint-disable-next-line no-param-reassign
      widgetName = data[0];
    } else if (data.indexOf(widgetName) < 0) {
      // eslint-disable-next-line no-param-reassign
      widgetName = undefined;
    }

    if (widgetName != null) {
      var func = jelem[widgetName];

      if (typeof func === 'function') {
        return func.bind(jelem);
      }
    }
  }

  return null;
};
/**
 * Notifies JET framework that a subtree possibly containing JET components has been inserted
 * into the document programmatically.
 *
 * Note that there is no need to call this method when the new DOM is being inserted by the template engine
 * in Knockout.js
 * @param {!Element} node - the root of the subtree
 * @see oj.Components.subtreeDetached
 * @return {void}
 * @export
 */


oj.Components.subtreeAttached = function (node) {
  oj.DomUtils.fixResizeListeners(node);

  _applyToComponents(node, function (instance) {
    instance.__handleSubtreeAttached();
  });
};
/**
 * Notifies JET framework that a subtree possibly containing JET components has been removed
 * from the document programmatically.
 *
 * Note that calling this method is not needs after calling JQuery's .remove() because all JET components would have been
 * already destroyed in that case. Similarly, there is no need to call this method after the subtree has been removed by
 * Knockout.js
 * @param {!Element} node - the root of the subtree
 * @see oj.Components.subtreeAttached
 * @return {void}
 * @export
 */


oj.Components.subtreeDetached = function (node) {
  _applyToComponents(node, function (instance) {
    instance.__handleSubtreeDetached();
  });
};
/**
 * Notifies JET framework that a subtree possibly containing JET components is no longer hidden with display:none style
 * This method should be called by the application if the 'display' style is being changed from 'hidden' programmatically,
 * such as when JQuery's .show() method is called.
 * For cases where subtree is shown on initial render, this method should be called with the options parameter set to
 * {'initialRender':true}, that will result in _NotifyInitShown() calls to the subtree components.
 * All oj-defer elements in the entire subtree will be activated. Note that subtreeShown currently notifies the entire
 * subtree as well. This generally means that only non-nested oj-defer elements make sense in a subtree.
 *
 * @param {!Node} node - the root of the subtree
 * @param {Object=} options Options to control subtreeShown
 * @param {boolean} options.initialRender The index at which to start fetching records.
 * @see oj.Components.subtreeHidden
 * @return {void}
 * @export
 */


oj.Components.subtreeShown = function (node, options) {
  var _node = $(node)[0]; // Strip possible jQuery wrapper

  if (_node.nodeType !== Node.ELEMENT_NODE) {
    return;
  }

  var _options = options || {};

  var isInitialRender = _options.initialRender;

  if (!isInitialRender) {
    oj.DomUtils.fixResizeListeners(_node);
  }

  unmarkSubtreeHidden(_node);

  _applyHideShowToComponents(_node, function (instance) {
    if (isInitialRender) {
      instance._NotifyInitShown();
    } else {
      instance._NotifyShown();
    }
  }, true);
};
/**
 * Notifies JET framework that a subtree possibly containing JET components has been hidden  with display:none style
 * This method should be called by the application after the subtree has been hidden programmatically, such as
 * when JQuery's .hide() method is called.
 *
 * @param {!Node} node - the root of the subtree
 * @see oj.Components.subtreeShown
 * @return {void}
 * @export
 */


oj.Components.subtreeHidden = function (node) {
  var _node = $(node)[0]; // Strip possible jQuery wrapper

  if (_node.nodeType !== Node.ELEMENT_NODE) {
    return;
  }

  _applyHideShowToComponents(_node, function (instance) {
    instance._NotifyHidden();
  }, false);

  markSubtreeHidden(_node);
};
/**
 * Add a marker class indicating that this subtree is hidden.
 *
 * @ignore
 */


function markSubtreeHidden(element) {
  element.classList.add(_OJ_SUBTREE_HIDDEN_CLASS);
}
/**
 * Remove the marker class indicating that this subtree is hidden.
 *
 * @ignore
 */


function unmarkSubtreeHidden(element) {
  element.classList.remove(_OJ_SUBTREE_HIDDEN_CLASS);
}
/**
 * Called by CCAs and certain custom elements when they are first connected
 * to indicate that this component is initializing and will control
 * whether its child subtrees are hidden.
 *
 * @ignore
 */


oj.Components.markPendingSubtreeHidden = function (element) {
  element.classList.add(_OJ_PENDING_SUBTREE_HIDDEN_CLASS);
};
/**
 * Called by CCAs and certain custom elements right before they are first rendered.
 * This component will control whether its child subtrees are hidden.
 *
 * @ignore
 */


oj.Components.unmarkPendingSubtreeHidden = function (element) {
  element.classList.remove(_OJ_PENDING_SUBTREE_HIDDEN_CLASS);
};
/**
 * Determines if a component identified by the <code>widgetName</code> has been
 * bound and initialized on a given <code>jelement</code>.
 *
 * @param {jQuery} jelement to which the component is bound
 * @param {string} widgetName constructor name of the target component.
 * @return {boolean} <code>true</code> if the component identified by the widgetName
 *  has be bound and initialized to the target element.
 * @ojtsignore
 */


oj.Components.isComponentInitialized = function (jelement, widgetName) {
  /** @type {?} */
  var widgets = jelement.data(_OJ_WIDGET_NAMES_DATA);

  if ($.isArray(widgets) && widgets.indexOf(widgetName) > -1 && jelement.is('.' + _OJ_COMPONENT_NODE_CLASS)) {
    return true;
  }

  return false;
};
/**
 * @ignore
 */


oj.Components.__getDefaultOptions = function (hierarchyNames) {
  var defaults = {};
  var allProperties = oj.Components.getDefaultOptions();

  for (var i = hierarchyNames.length - 1; i >= 0; i--) {
    var name = hierarchyNames[i];
    var props = allProperties[name];

    if (props !== undefined) {
      defaults = _accumulateValues(defaults, props, true);
    }
  }

  return defaults;
};
/**
 * Retrieves the JET component element that
 * the node is in.
 * @param {?(Element|Node)} node - DOM node
 * @return {?(Element|Node)} componentElement - JET component element
 * A component element is the DOM element on which the JET component is
 * initialized.
 * @export
 * @ojtsignore
*/


oj.Components.getComponentElementByNode = function (node) {
  // Temporarily exposing this private flag in order to allow
  // MonkeyTalk to access JET components that are part of the
  // composite's implementation. We are not exposing this flag
  // as a public API as a) accessing composite implementation
  // components is bad and b) the need for this method will soon
  // go away. Once our new automation API (recording adapters) are
  // in place, even MonkeyTalk will no longer need this flag. Adding
  // this as a stop-gap measure to allow MonkeyTalk to carry on in the
  // meantime. Callers other than MonkeyTalk must avoid specifying this flag.
  var mtAccessCompositeInternals = !!(arguments.length > 1 && arguments[1]);
  return _getComponentElementByNode(node, mtAccessCompositeInternals);
};
/**
 * Private method implementing the functionality of
 * getComponentElementByNode. This was done because Closure
 * throws an error when the private, undocumented flag (mtAccessCompositeInternals)
 * is passed to recursive calls of getComponentElementByNode.
 * @private
*/


function _getComponentElementByNode(node, mtAccessCompositeInternals) {
  if (node == null) {
    return null;
  } // node can be a Node or Element but we call some Element only APIs
  // so we need to do an additional isElement check first


  var isElement = node.nodeType === 1; // for upstream or indirect dependency we will still rely components being registered on the oj namespace.

  var containingComposite = oj.Composite && !mtAccessCompositeInternals ? oj.Composite.getContainingComposite(node) : null;

  if (containingComposite) {
    // node is in or is a composite, return composite
    return containingComposite;
  } else if (isElement && node.hasAttribute('data-oj-internal')) {
    // node is an internal component
    if (node.parentNode instanceof Element && node.parentNode.hasAttribute('data-oj-surrogate-id')) {
      // internal component is a popup
      // eslint-disable-next-line no-param-reassign
      node = document.querySelector('[data-oj-popup-' + node.id + '-parent]'); // retrieves popups parent element

      return _getComponentElementByNode(node, mtAccessCompositeInternals);
    }

    return _getComponentElementByNode(node.parentNode, mtAccessCompositeInternals);
  } else if (_isComponentElement(node)) {
    // node is a component element
    return node;
  } else if (isElement && node.classList.contains('oj-component')) {
    // node is component wrapper
    // eslint-disable-next-line no-param-reassign
    node = node.querySelector('.oj-component-initnode:not([data-oj-internal])') || node;

    if (_isJQueryUI(node)) {
      return node;
    }
  } else if (isElement && node.hasAttribute('data-oj-containerid')) {
    // node is non-internal component popup e.g listbox
    // eslint-disable-next-line no-param-reassign
    node = document.getElementById(node.getAttribute('data-oj-containerid'));
    return _getComponentElementByNode(node, mtAccessCompositeInternals);
  }

  return _getComponentElementByNode(node.parentNode, mtAccessCompositeInternals);
}
/**
 * Retrieves the subId of the node as
 * as part of a locator object i.e. at least
 * {subId: subIdOfNode}
 * @param {?Element} componentElement - JET component element
 * @param {?Element} node - DOM node
 * @return {any} locator - object with at least a subId
 * or null if the node does not have a subId
 * @export
 * @ojtsignore
*/


oj.Components.getSubIdByNode = function (componentElement, node) {
  return oj.Components.callComponentMethod(componentElement, 'getSubIdByNode', node);
};
/**
 * Returns the component DOM node indicated
 * by the locator parameter.
 * @param {?Element} componentElement - JET component element
 * @param {Object} locator - Object containing, at minimum,
 * a subId property, whose value is a string that identifies
 * a particular DOM node in this component.
 * @return {any} node - The DOM node located by
 * the locator, or null if none is found
 * @export
 * @ojtsignore
*/


oj.Components.getNodeBySubId = function (componentElement, locator) {
  return oj.Components.callComponentMethod(componentElement, 'getNodeBySubId', locator);
};
/**
 * Retrieves the specified option of
 * the specified JET component element
 * @param {?Element} componentElement - JET component element
 * @param {string} option - option to retrieve
 * @return {any} value of option
 * @export
 * @ojtsignore
*/


oj.Components.getComponentOption = function (componentElement, option) {
  if (!_isComponentElement(componentElement)) {
    throw new Error('node is not a component element');
  } else if (_isCompositeOrCustom(componentElement)) {
    if (componentElement.getProperty) {
      return componentElement.getProperty.call(componentElement, option);
    }
  } else {
    return oj.Components.__GetWidgetConstructor(componentElement)('option', option);
  }

  return undefined;
};
/**
 * Sets the specified option of the specified
 * JET component element to the specified value
 * @param {?Element} componentElement - JET component element
 * @param {string} option - option to set
 * @param {any} value - value to set option to
 * @return {void}
 * @export
 * @ojtsignore
*/


oj.Components.setComponentOption = function (componentElement, option, value) {
  if (!_isComponentElement(componentElement)) {
    throw new Error('node is not a component element');
  } else if (_isCompositeOrCustom(componentElement)) {
    if (componentElement.setProperty) {
      componentElement.setProperty.call(componentElement, option, value);
    }
  } else {
    oj.Components.__GetWidgetConstructor(componentElement)('option', option, value);
  }
};
/**
 * Calls the specified JET component element's method
 * with the given arguments
 * @param {?Element} componentElement - JET component element
 * @param {string} method - name of JET component element method to call
 * @param {...*} methodArguments - list of arguments to pass to method call
 * @return {any}
 * @export
 * @ojtsignore
*/
// eslint-disable-next-line no-unused-vars


oj.Components.callComponentMethod = function (componentElement, method, methodArguments) {
  if (!_isComponentElement(componentElement)) {
    throw new Error('node is not a component element');
  } else if (_isCompositeOrCustom(componentElement)) {
    if (componentElement[method]) {
      return componentElement[method].apply(componentElement, [].slice.call(arguments, 2));
    }
  } else {
    return oj.Components.__GetWidgetConstructor(componentElement).apply($(componentElement), [].slice.call(arguments, 1));
  }

  return undefined;
};
/**
 * @private
 */


function _applyToComponents(subtreeRoot, jqCallback) {
  var processFunc = function processFunc() {
    var jelem = $(this);
    var names = jelem.data(_OJ_WIDGET_NAMES_DATA);

    if (names != null) {
      for (var i = 0; i < names.length; i++) {
        var instance = jelem.data('oj-' + names[i]);

        if (instance != null) {
          jqCallback(instance);
        }
      }
    }
  };

  var locator = $(subtreeRoot); // Include the root node itself, and not just children ()

  if (locator.hasClass(_OJ_COMPONENT_NODE_CLASS)) {
    processFunc.call(subtreeRoot);
  }

  locator.find('.' + _OJ_COMPONENT_NODE_CLASS).each(processFunc);
}
/**
 * @private
 */


function _applyHideShowToComponents(subtreeRoot, jqCallback, activateDefer) {
  // Detect hidden without forcing a layout.
  function isHidden(_node) {
    var node = _node;

    while (node) {
      if (node.nodeType === Node.DOCUMENT_NODE) {
        return false; // Walked up to document.  Not hidden
      }

      if (node.nodeType === Node.ELEMENT_NODE && node.classList.contains(_OJ_SUBTREE_HIDDEN_CLASS)) {
        return true;
      }

      node = node.parentNode;
    }

    return true; // Didn't find document, so it must be detached and therefore hidden.
  }
  /**
   * Both node lists must be in document order.
   * Return new array containing nodes in 'allNodes' that are not in 'hiddenNodes'
   * @private
   */


  function filterHidden(allNodes, hiddenNodes) {
    var shownNodes = [];
    var j = 0;

    for (var i = 0; i < hiddenNodes.length; i++) {
      var hidden = hiddenNodes[i];

      while (j < allNodes.length && allNodes[j] !== hidden) {
        shownNodes.push(allNodes[j]);
        j += 1;
      }

      j += 1;
    }

    while (j < allNodes.length) {
      shownNodes.push(allNodes[j]);
      j += 1;
    }

    return shownNodes;
  }

  function processFunc(element) {
    if (jqCallback && element.classList.contains(_OJ_COMPONENT_NODE_CLASS)) {
      var jelem = $(element);
      var names = jelem.data(_OJ_WIDGET_NAMES_DATA);

      if (names != null) {
        for (var i = 0; i < names.length; i++) {
          var instance = jelem.data('oj-' + names[i]);

          if (instance != null) {
            jqCallback(instance);
          }
        }
      }
    }

    if (activateDefer && element.tagName.toLowerCase() === 'oj-defer') {
      if (element._activate) {
        element._activate();
      } else {
        throw new Error('subtreeShown called before module ojs/ojdefer was loaded');
      }
    }
  }

  if (!isHidden(subtreeRoot)) {
    processFunc(subtreeRoot); // Create selectors for jquery components and oj-defer as needed.

    var selectors = ['.' + _OJ_COMPONENT_NODE_CLASS];

    if (activateDefer) {
      selectors.push('oj-defer');
    }

    var hiddenSelectors = [];
    selectors.forEach(function (s) {
      hiddenSelectors.push('.' + _OJ_SUBTREE_HIDDEN_CLASS + ' ' + s);
      hiddenSelectors.push('.' + _OJ_PENDING_SUBTREE_HIDDEN_CLASS + ' ' + s);
    }); // Create assemble a selector that gets all matches and the subset that are hidden

    var selector = selectors.join(',');
    var hiddenSelector = hiddenSelectors.join(','); // Fetch all matching elements and those that are hidden.
    // Use the second list to filter out hidden elements.

    var allNodes = subtreeRoot.querySelectorAll(selector);
    var hiddenNodes = subtreeRoot.querySelectorAll(hiddenSelector);
    var shownNodes = filterHidden(allNodes, hiddenNodes);

    for (var i = 0; i < shownNodes.length; i++) {
      processFunc(shownNodes[i]);
    }
  }
}
/**
 * @constructor
 * @param {!Function} callback
 * @private
 */


function __ojDynamicGetter(callback) {
  this.getCallback = function () {
    return callback;
  };
}
/**
 * @ignore
 */


function _accumulateValues(target, source, valueInArray) {
  var keys = Object.keys(source);
  keys.forEach(function (key) {
    var holder = target[key] || [];
    var sourceVal = source[key];

    if (valueInArray) {
      holder = holder.concat(sourceVal);
    } else {
      holder.push(sourceVal);
    } // eslint-disable-next-line no-param-reassign


    target[key] = holder;
  });
  return target;
}
/**
 * @ignore
 */


function _isCompositeOrCustom(node) {
  return oj.BaseCustomElementBridge.getRegistered(node.tagName);
}
/**
 * @ignore
 */


function _isJQueryUI(node) {
  return !!oj.Components.__GetWidgetConstructor(node);
}
/**
 * @ignore
 */


function _isComponentElement(node) {
  return _isCompositeOrCustom(node) || _isJQueryUI(node);
}

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }



/* global Promise:false, _OJ_COMPONENT_NODE_CLASS:false, _OJ_WIDGET_NAMES_DATA:false,
          __ojDynamicGetter:false, Translations:false, Logger: false*/

/* jslint browser: true*/

/**
 * @private
 */
var _OJ_TRANSLATIONS_OPTION = 'translations';
/**
 * @private
 */

var _OJ_TRANSLATIONS_PREFIX = _OJ_TRANSLATIONS_OPTION + '.';
/**
 * @private
 */


var _OJ_COMPONENT_EVENT_OVERRIDES = {
  isDefaultPrevented: function isDefaultPrevented() {
    return false;
  },
  preventDefault: function preventDefault() {
    this.isDefaultPrevented = _returnTrue;
  },
  stopPropagation: function stopPropagation() {
    this.isPropagationStopped = _returnTrue;
  },
  stopImmediatePropagation: function stopImmediatePropagation() {
    this.isImmediatePropagationStopped = _returnTrue;
  }
};

(function () {
  // BaseComponent wrapper function, to keep "private static members" private

  /**
   * @private
   */
  var _BASE_COMPONENT = 'baseComponent';
  var _STATE_CONNECTED = 0;
  var _STATE_DISCONNECTED = 1; // -----------------------------------------------------------------------------
  // "private static members" shared by all components
  // -----------------------------------------------------------------------------

  var _lastActiveElement;
  /**
   * @ojcomponent oj.baseComponent
   * @abstract
   * @since 0.6.0
   */


  $.widget('oj.' + _BASE_COMPONENT, {
    options: {
      /**
       * <p>There is no restriction on the order in which the JET Menu and the referencing component are initialized.  However, when specifying
       * the Menu via the HTML attribute, the referenced DOM element must be in the document at the time that the referencing component is
       * initialized.
       *
       * @ojfragment contextMenuInitOrderDoc - Decomped to fragment so Tabs, Tree, and MasonryLayout can override the fragment to convey their init order restrictions.
       * @memberof oj.baseComponent
       */

      /**
       * <p>To help determine whether it's appropriate to cancel the launch or customize the menu, the <code class="prettyprint">beforeOpen</code>
       * listener can use component API's to determine which table cell, chart item, etc., is the target of the context menu. See the JSDoc and
       * demos of the individual components for details.  Keep in mind that any such logic must work whether the context menu was launched via right-click,
       * <kbd>Shift-F10</kbd>, <kbd>Press & Hold</kbd>, or component-specific touch gesture.
       *
       * @ojfragment contextMenuTargetDoc - Decomped to fragment so components can override the fragment to convey their specific API's for this.
       * @memberof oj.baseComponent
       */

      /**
       * <p>Identifies the [JET Menu]{@link oj.ojMenu} that the component should launch as a context menu on right-click, <kbd>Shift-F10</kbd>, <kbd>Press & Hold</kbd>,
       * or component-specific gesture. If specified, the browser's native context menu will be replaced by the specified JET Menu.
       *
       * <p>The value can be an HTML element, JQ selector, JQ object, NodeList, or array of elements.  In all cases, the first indicated element is used.
       *
       * <p>To specify a JET context menu on a DOM element that is not a JET component, see the <code class="prettyprint">ojContextMenu</code> binding.
       *
       * <p>To make the page semantically accurate from the outset, applications are encouraged to specify the context menu via the standard
       * HTML5 syntax shown in the below example.  When the component is initialized, the context menu thus specified will be set on the component.
       *
       * {@ojinclude "name":"contextMenuInitOrderDoc"}
       *
       * <p>After create time, the <code class="prettyprint">contextMenu</code> option should be set via this API, not by setting the DOM attribute.
       *
       * <p>The application can register a listener for the Menu's [beforeOpen]{@link oj.ojMenu#event:beforeOpen} event.  The listener can cancel the
       * launch via <code class="prettyprint">event.preventDefault()</code>, or it can customize the menu contents by editing the menu DOM directly,
       * and then calling [refresh()]{@link oj.ojMenu#refresh} on the Menu.
       *
       * {@ojinclude "name":"contextMenuTargetDoc"}
       *
       * @ojfragment contextMenuDoc - Decomped to fragment so subclasses can extend the verbiage as needed, by ojinclude'ing this fragment and then adding their own verbiage.
       * @memberof oj.baseComponent
       */

      /**
       * {@ojinclude "name":"contextMenuDoc"}
       *
       * @ignore
       * @expose
       * @memberof oj.baseComponent
       * @instance
       * @type {Element|Array.<Element>|string|jQuery|NodeList}
       * @default <code class="prettyprint">null</code>
       *
       * @example <caption>Initialize a JET component with a context menu:</caption>
       * // via recommended HTML5 syntax:
       * &lt;div id="myComponent" contextmenu="myMenu" data-bind="ojComponent: { ... }>
       *
       * // via JET initializer (less preferred) :
       * // Foo is the component, e.g., InputText, InputNumber, Select, etc.
       * $( ".selector" ).ojFoo({ "contextMenu": "#myMenu" });
       *
       * @example <caption>Get or set the <code class="prettyprint">contextMenu</code> option, after initialization:</caption>
       * // getter
       * // Foo is the component, e.g., InputText, InputNumber, Select, etc.
       * var menu = $( ".selector" ).ojFoo( "option", "contextMenu" );
       *
       * // setter
       * // Foo is the component, e.g., InputText, InputNumber, Select, etc.
       * $( ".selector" ).ojFoo( "option", "contextMenu", ".my-marker-class" );
       *
       * @example <caption>Set a JET context menu on an ordinary HTML element:</caption>
       * &lt;a href="#" id="myAnchor" contextmenu="myMenu" data-bind="ojContextMenu: {}">Some text</a>
       */
      contextMenu: null,

      /**
       * <p>Attributes specified here will be set on the component's root DOM element at creation time.
       * This is particularly useful for components like Dialog that wrap themselves in a new root element
       * at creation time.
       *
       * <p>The supported attributes are <code class="prettyprint">id</code>, which overwrites any existing value,
       * and <code class="prettyprint">class</code> and <code class="prettyprint">style</code>, which are appended
       * to the current class and style, if any.
       *
       * <p>Setting this option after component creation has no effect.  At that time, the root element already
       * exists, and can be accessed directly via the <code class="prettyprint">widget</code> method, per the second example below.
       *
       * @example <caption>Initialize a JET component, specifying a set of attributes to be set
       * on the component's root DOM element:</caption>
       * // Foo is the component, e.g., Menu, Button, InputText, InputNumber, Select, etc.
       * $( ".selector" ).ojFoo({ "rootAttributes": {
       *   "id": "myId",
       *   "style": "max-width:100%; color:blue;",
       *   "class": "my-class"
       * }});
       *
       * @example <caption>After initialization, <code class="prettyprint">rootAttributes</code> should not be used.  It is
       * not needed at that time, as attributes of the root DOM element can simply be set directly, using
       * <code class="prettyprint">widget</code>:</caption>
       * // Foo is the component, e.g., Menu, Button, InputText, InputNumber, Select, etc.
       * $( ".selector" ).ojFoo( "widget" ).css( "height", "100px" );
       * $( ".selector" ).ojFoo( "widget" ).addClass( "my-class" );
       *
       * @ignore
       * @expose
       * @memberof oj.baseComponent
       * @instance
       * @type {?Object}
       * @default <code class="prettyprint">null</code>
       */
      rootAttributes: null,

      /**
       * <p>A collection of translated resources from the translation bundle, or <code class="prettyprint">null</code> if this
       * component has no resources.  Resources may be accessed and overridden individually or collectively, as seen in the examples.
       *
       * <p> If the component does not contain any translatable resource, the default value of this attribute will be
       * <code class="prettyprint">null</code>. If not, an object containing all resources relevant to the component.
       *
       * <p>If this component has translations, their documentation immediately follows this doc entry.
       *
       * @member
       * @name translations
       * @ojshortdesc A collection of translated resources from the translation bundle, or null if this component has no resources.
       * @memberof oj.baseComponent
       * @instance
       * @ojtranslatable
       * @type {object|null}
       *
       *
       * @example <caption>Initialize the component, overriding some translated resources and leaving the others intact:</caption>
       * &lt;!-- Using dot notation -->
       * &lt;oj-some-element translations.some-key='some value' translations.some-other-key='some other value'>&lt;/oj-some-element>
       *
       * &lt;!-- Using JSON notation -->
       * &lt;oj-some-element translations='{"someKey":"some value", "someOtherKey":"some other value"}'>&lt;/oj-some-element>
       *
       * @example <caption>Get or set the <code class="prettyprint">translations</code> property after initialization:</caption>
       * // Get one
       * var value = myComponent.translations.someKey;
       *
       * // Set one, leaving the others intact. Always use the setProperty API for
       * // subproperties rather than setting a subproperty directly.
       * myComponent.setProperty('translations.someKey', 'some value');
       *
       * // Get all
       * var values = myComponent.translations;
       *
       * // Set all.  Must list every resource key, as those not listed are lost.
       * myComponent.translations = {
       *     someKey: 'some value',
       *     someOtherKey: 'some other value'
       * };
       *
       */
      // translations property is initialized programmatically, so this top-level API doc lives in this virtual comment.
      // Translations for all components are listed and JSDoc'ed in rt\src\main\resources\nls\root\ojtranslations.js.
      // That JSDoc appears in the same generated doc page as this top-level doc.
      // Events

      /**
       * Fired whenever a supported component option changes, whether due to user interaction or programmatic
       * intervention.  If the new value is the same as the previous value, no event will be fired.  The event
       * listener will receive two parameters described below:
       *
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui event payload
       * @property {string} ui.option the name of the option that changed.
       * @property {Object} ui.previousValue - an Object holding the previous value of the option.
       * When previousValue is not a primitive type, i.e., is an Object, it may hold the same value as
       * the value property.
       * @property {Object} ui.value - an Object holding the current value of the option.
       * @property {?Object} ui.subproperty - an Object holding information about the subproperty that changed.
       * @property {string} ui.subproperty.path - the subproperty path that changed.
       * @property {Object} ui.subproperty.previousValue - an Object holding the previous value of the subproperty.
       * @property {Object} ui.subproperty.value - an Object holding the current value of the subproperty.
       * @property {Object} ui.optionMetadata information about the option that changed
       * @property {string} ui.optionMetadata.writeback <code class="prettyprint">"shouldWrite"</code> or
       *  <code class="prettyprint">"shouldNotWrite"</code>. For use by the JET writeback mechanism;
       *  'shouldWrite' indicates that the value should be written to the observable.
       *
       * @example <caption>Initialize component with the <code class="prettyprint">optionChange</code> callback</caption>
       * // Foo is Button, InputText, etc.
       * $(".selector").ojFoo({
       *   'optionChange': function (event, ui) {}
       * });
       * @example <caption>Bind an event listener to the ojoptionchange event</caption>
       * $(".selector").on({
       *   'ojoptionchange': function (event, ui) {
       *       // verify that the component firing the event is a component of interest
       *       if ($(event.target).is(".mySelector")) {
       *           window.console.log("option that changed is: " + ui['option']);
       *       }
       *   };
       * });
       *
       * @ignore
       * @memberof oj.baseComponent
       * @expose
       * @event
       * @instance
       */
      optionChange: undefined,

      /**
       * <p>Triggered before the component is destroyed. This event cannot be canceled; the
       * component will always be destroyed regardless.
       *
       * @example <caption>Initialize component with the <code class="prettyprint">destroy</code> callback</caption>
       * // Foo is Button, InputText, etc.
       * $(".selector").ojFoo({
       *   'destroy': function (event, data) {}
       * });
       * @example <caption>Bind an event listener to the destroy event</caption>
       * $(".selector").on({
       *   'ojdestroy': function (event, data) {
       *       // verify that the component firing the event is a component of interest
       *       if ($(event.target).is(".mySelector")) {
       *           window.console.log("The DOM node id for the destroyed component is : %s", event.target.id);
       *       }
       *   };
       * });
       *
       * @ignore
       * @memberof oj.baseComponent
       * @expose
       * @event
       * @instance
       */
      destroy: undefined
    },
    // TODO: flesh out JSDoc verbiage, re: call after dom changes underneath component...

    /**
     * Refreshes the component.
     * @return {void}
     * @expose
     * @memberof oj.baseComponent
     * @instance
     */
    refresh: function refresh() {
      this._propertyContext = null; // if application sets the context menu after initialization, it must refresh the component

      this._SetupContextMenu();
    },

    /**
     * <p>Overridden to save off component's default options and the options passed into the constructor (to be passed into
     * the _InitOptions() call).
     *
     * <p>This method is final. Components should instead override one or more of the overridable create-time methods
     * listed in <a href="#_ComponentCreate">_ComponentCreate</a>.
     *
     * @memberof oj.baseComponent
     * @instance
     * @private
     * @final
     */
    _createWidget: function _createWidget(options, element) {
      // Save wrapper element
      if (options) {
        this.OuterWrapper = options._wrapper;
      } // There is no need to clone these objects since they are not modified by the _createWidget() in the base class


      this._originalDefaults = this.options || {};
      this._constructorOptions = options || {};

      this._super(options, element);

      this._AfterCreateEvent();
    },

    /**
     * <p>Reads the <code class="prettyprint">rootAttributes</code> option, and sets the root attributes on the
     * component's root DOM element.  See <a href="#rootAttributes">rootAttributes</a> for the set of supported
     * attributes and how they are handled.
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     * @throws if unsupported attributes are supplied.
     */
    _SetRootAttributes: function _SetRootAttributes() {
      var value = this.options.rootAttributes;

      if (value) {
        var widget = this.widget();

        if (widget == null) {
          return;
        }

        var classValue = value.class;

        if (classValue) {
          widget.addClass(classValue);
        }

        var styleValue = value.style;

        if (styleValue) {
          var currStyle = widget.attr('style');

          if (currStyle) {
            widget.attr('style', currStyle + ';' + styleValue); // @HTMLUpdateOK
          } else {
            widget.attr('style', styleValue); // @HTMLUpdateOK
          }
        } // make shallow copy, remove class and style from the copy, and set all
        // remaining attrs on the element.  Currently id is the only remaining attr
        // that we support.


        value = $.extend({}, value);
        delete value.class;
        delete value.style;
        widget.attr(value);
        delete value.id; // remove the remaining supported value

        var unsupportedAttrs = Object.keys(value);

        if (unsupportedAttrs.length) {
          throw new Error('Unsupported values passed to rootAttributes option: ' + unsupportedAttrs.toString());
        }
      }
    },

    /**
     * <p>This method is final in JET. Components should instead override one or more of the overridable create-time methods
     * listed in <a href="#_ComponentCreate">_ComponentCreate</a>.
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     * @final
     */
    _create: function _create() {
      this._SaveAttributes(this.element);

      this._InitOptions(this._originalDefaults, this._constructorOptions);

      delete this._originalDefaults;
      delete this._constructorOptions;

      this._ComponentCreate();

      this._AfterCreate(); // allow subcomponent to setup needed resources
      // after the component is created.


      this._SetupResources(); // Marker class for all JET components on the init node (as opposed to the outer node)
      // This marker class is used to:
      // 1) find all JET components within a subtree
      // 2) to prevent FOUC:  init nodes NOT yet having this class are hidden.


      this.element.addClass(_OJ_COMPONENT_NODE_CLASS);
    },

    /**
     * <p>This method is not used in JET. Components should instead override <a href="#_InitOptions">_InitOptions</a>.
     *
     * @method
     * @name oj.baseComponent#_getCreateOptions
     * @memberof oj.baseComponent
     * @instance
     * @protected
     * @final
     */

    /**
     * <p>This method is called before <a href="#_ComponentCreate">_ComponentCreate</a>, at which point
     * the component has not yet been rendered.  Component options should be initialized in this method,
     * so that their final values are in place when <a href="#_ComponentCreate">_ComponentCreate</a> is called.
     *
     * <p>This includes getting option values from the DOM, where applicable, and coercing option
     * values (however derived) to their appropriate data type if needed.
     *
     * <p>No work other than setting options should be done in this method.  In particular, nothing should be
     * set on the DOM until <a href="#_ComponentCreate">_ComponentCreate</a>, e.g. setting the <code class="prettyprint">disabled</code>
     * DOM attribute from the <code class="prettyprint">disabled</code> option.
     *
     * <p>A given option (like <code class="prettyprint">disabled</code>) appears in the <code class="prettyprint">constructorOptions</code>
     * param iff the app set it in the constructor:
     *
     * <ul>
     *   <li>If it appears in <code class="prettyprint">constructorOptions</code>, it should win over what's in the DOM
     *     (e.g. <code class="prettyprint">disabled</code> DOM attribute).  If for some reason you need to tweak the value
     *     that the app set, then enable writeback when doing so:
     *     <code class="prettyprint">this.option('foo', bar, {'_context': {writeback: true, internalSet: true}})</code>.</li>
     *   <li>If it doesn't appear in <code class="prettyprint">constructorOptions</code>, then that option definitely is not bound,
     *     so writeback is not needed.  So if you need to set the option (e.g. from a DOM attribute), use
     *     <code class="prettyprint">this.option('foo', bar, {'_context': {internalSet: true}})</code>.</li>
     * </ul>
     *
     * <p>Overrides of this method should call <code class="prettyprint">this._super</code> first.
     *
     * @param {!Object} originalDefaults - original default options defined on the component and its ancestors
     * @param {?Object} constructorOptions - options passed into the widget constructor
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    _InitOptions: function _InitOptions(originalDefaults, constructorOptions) {
      this._setupDefaultOptions(originalDefaults, constructorOptions);

      this._initContextMenuOption(constructorOptions);
    },

    /**
     * <p>All component create-time initialization lives in this method, except the logic that specifically
     * needs to live in <a href="#_InitOptions">_InitOptions</a>, <a href="#_AfterCreate">_AfterCreate</a>,
     * or <a href="#_AfterCreateEvent">_AfterCreateEvent</a>,
     * per the documentation for those methods.  All DOM creation must happen here, since the intent of
     * <a href="#_AfterCreate">_AfterCreate</a>, which is called next, is to contain superclass logic that must
     * run after that DOM is created.
     *
     * <p>Overrides of this method should call <code class="prettyprint">this._super</code> first.
     *
     * <p>Summary of create-time methods that components can override, in the order that they are called:
     *
     * <ol>
     *   <li><a href="#_InitOptions">_InitOptions</a></li>
     *   <li><a href="#_ComponentCreate">_ComponentCreate</a> (this method)</li>
     *   <li><a href="#_AfterCreate">_AfterCreate</a></li>
     *   <li>(The <code class="prettyprint">create</code> event is fired here.)</li>
     *   <li><a href="#_AfterCreateEvent">_AfterCreateEvent</a></li>
     * </ol>
     *
     * <p>For all of these methods, the contract is that overrides must call <code class="prettyprint">this._super</code> <i>first</i>, so e.g., the
     * <code class="prettyprint">_ComponentCreate</code> entry means <code class="prettyprint">baseComponent._ComponentCreate</code>,
     * then <code class="prettyprint">_ComponentCreate</code> in any intermediate subclasses, then
     * <code class="prettyprint">_ComponentCreate</code> in the leaf subclass.
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    _ComponentCreate: function _ComponentCreate() {
      // Store widget name, so that oj.Components.__GetWidgetConstructor() can get widget from the element
      _storeWidgetName(this.element, this.widgetName); // namespace facilitates removing activeable and hoverable handlers handlers separately


      this.activeableEventNamespace = this.eventNamespace + 'activeable';
      this.hoverableEventNamespace = this.eventNamespace + 'hoverable';
    },

    /**
     * <p>This method is called after <a href="#_ComponentCreate">_ComponentCreate</a>, but before the
     * <code class="prettyprint">create</code> event is fired.  The JET base component does
     * tasks here that must happen after the component (subclass) has created itself in its override of
     * <a href="#_ComponentCreate">_ComponentCreate</a>.  Notably, the base component handles the
     * <a href="#rootAttributes">rootAttributes</a> and <a href="#contextMenu">contextMenu</a> options here,
     * since those options operate on the component root node, which for some components is created in their override
     * of <a href="#_ComponentCreate">_ComponentCreate</a>.
     *
     * <p>Subclasses should override this method only if they have tasks that must happen after a superclass's
     * implementation of this method, e.g. tasks that must happen after the context menu is set on the component.
     *
     * <p>Overrides of this method should call <code class="prettyprint">this._super</code> first.
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    _AfterCreate: function _AfterCreate() {
      this._SetRootAttributes(); // do first, since has no dependencies, but other stuff might care about these attrs
      // namespace facilitates removing contextMenu handlers separately, if app clears the "contextMenu" option


      this.contextMenuEventNamespace = this.eventNamespace + 'contextMenu'; // same for activeable and hoverable handlers

      this.activeableEventNamespace = this.eventNamespace + 'activeable';
      this.hoverableEventNamespace = this.eventNamespace + 'hoverable';
    },

    /**
     * <p>This method is called after the <code class="prettyprint">create</code> event is fired.
     * Components usually should not override this method, as it is rarely correct to wait until after the
     * <code class="prettyprint">create</code> event to perform a create-time task.
     *
     * <p>An example of a correct usage of this method is [Dialog's auto-open behavior]{@link oj.ojDialog#initialVisibility},
     * which needs to happen after the <code class="prettyprint">create</code> event.
     *
     * <p>Only <i>behaviors</i> (like Dialog auto-open behavior) should occur in this method.  Component <i>initialization</i>
     * must occur earlier, before the <code class="prettyprint">create</code> event is fired, so that
     * <code class="prettyprint">create</code> listeners see a fully inited component.
     *
     * <p>Overrides of this method should call <code class="prettyprint">this._super</code> first.
     *
     * <p>Do not confuse this method with the <a href="#_AfterCreate">_AfterCreate</a> method, which is more commonly used.
     *
     * @method
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    _AfterCreateEvent: $.noop,

    /**
     * <p>JET components should almost never implement this JQUI method.  Please consult an architect if you believe you have an exception.  Reasons:
     * <ul>
     *   <li>This method is called at create time, after the <code class="prettyprint">create</code> event is fired.  It is rare
     *       for that to be the appropriate time to perform a create-time task.  For those rare cases, we have the
     *       <a href="#_AfterCreateEvent">_AfterCreateEvent</a> method, which is preferred over this method since it is called only
     *       at that time, not also at re-init time (see next).</li>
     *   <li>This method is also called at "re-init" time, i.e. when the initializer is called after the component has already been created.
     *       JET has not yet identified any desired semantics for re-initing a component.</li>
     * </ul>
     *
     * @method
     * @name oj.baseComponent#_init
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    //  - remove JQUI memory leaks and CSS cruft introduced in 1.12 and 1.12.1
    _setOptionClasses: function _setOptionClasses() {},
    _setOptionDisabled: function _setOptionDisabled() {},
    _classes: function _classes() {
      return '';
    },
    _removeClass: function _removeClass() {
      return this;
    },
    _addClass: function _addClass() {
      return this;
    },
    _toggleClass: function _toggleClass() {
      return this;
    },

    /**
     * <p>Saves the element's attributes. This is called during _create.
     * <a href="#_RestoreAttributes">_RestoreAttributes</a> will restore all these attributes
     * and is called during _destroy.
     * </p>
     * <p> This base class default implementation does nothing.
     * </p>
     * <p>We also have <a href="#_SaveAllAttributes">_SaveAllAttributes</a> and
     * <a href="#_RestoreAllAttributes">_RestoreAllAttributes</a> methods
     *  that save and restore <i>all</i> the attributes on an element.
     *  Component subclasses can opt into these _SaveAllAttributes/_RestoreAllAttributes
     *  implementations by overriding _SaveAttributes and _RestoreAttributes to call
     *  _SaveAllAttributes/_RestoreAllAttributes. If the subclass wants a different implementation
     *  (like save only the 'class' attribute), it can provide the implementation itself in
     *  _SaveAttributes/_RestoreAttributes.
     *
     *
     * @param {Object} element - jQuery selection to save attributes for
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    // eslint-disable-next-line no-unused-vars
    _SaveAttributes: function _SaveAttributes(element) {// default implementation does nothing.
    },

    /**
     * <p>Saves all the element's attributes within an internal variable.
     * <a href="#_RestoreAllAttributes">_RestoreAllAttributes</a> will restore the attributes
     * from this internal variable.</p>
     * <p>
     * This method is final in JET.
     * Subclasses can override _RestoreAttributes and call _RestoreAllAttributes.
     * </p>
     *
     * <p>The JSON variable will be held as:
     *
     * <pre class="prettyprint">
     * <code>[
     *   {
     *   "element" : element[i],
     *   "attributes" :
     *     {
     *       attributes[m]["name"] : {"attr": attributes[m]["value"]
     *     }
     *   }
     * ]
     * </code></pre>
     *
     * @param {Object} element - jQuery selection to save attributes for
     * @memberof oj.baseComponent
     * @instance
     * @protected
     * @final
     */
    _SaveAllAttributes: function _SaveAllAttributes(element) {
      var self = this;
      this._savedAttributes = [];
      $.each(element, function (index, ele) {
        // need to be able to save for multiple elements
        var saveAttributes = {};
        var save = {
          element: ele,
          attributes: saveAttributes
        };
        var attributes = ele.attributes;

        self._savedAttributes.push(save);

        $.each(attributes, function (index2, attr) {
          // for proper access certain so called attributes should be accessed as properties
          // [i.e. required, disabled] so fetch them initially
          var attrName = attr.name;
          saveAttributes[attrName] = {
            attr: attr.value
          };
        });
      });
    },

    /**
     * <p>Gets the saved attributes for the provided element.
     *
     * <p>If you don't override <a href="#_SaveAttributes">_SaveAttributes</a> and
     * <a href="#_RestoreAttributes">_RestoreAttributes</a>, then this will return null.
     * <p>If you override _SaveAttributes to call <a href="#_SaveAllAttributes">_SaveAllAttributes</a>,
     * then this will return all the attributes.
     * If you override _SaveAttributes/_RestoreAttributes to do your own thing, then you may also have
     * to override _GetSavedAttributes to return whatever you saved if you need access to the saved
     * attributes.
     *
     * @param {Object} element - jQuery selection, should be a single entry
     * @return {Object|null} savedAttributes - attributes that were saved for this element
     * in <a href="#_SaveAttributes">_SaveAttributes</a>, or null if none were saved.
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    _GetSavedAttributes: function _GetSavedAttributes(element) {
      var savedAttributes = this._savedAttributes; // The component may not have saved any attributes. If so, return.

      if (savedAttributes === undefined) {
        return null;
      }

      var domElement = element[0];

      for (var i = 0, j = savedAttributes.length; i < j; i++) {
        var curr = savedAttributes[i];

        if (curr.element === domElement) {
          return curr.attributes;
        }
      }

      return {};
    },

    /**
     * <p>Restore the attributes saved in <a href="#_SaveAttributes">_SaveAttributes</a>.</p>
     * <p>
     * _SaveAttributes is called during _create. And _RestoreAttributes is called during _destroy.
     * </p>
     * <p> This base class default implementation does nothing.
     * </p>
     * <p>We also have <a href="#_SaveAllAttributes">_SaveAllAttributes</a> and
     * <a href="#_RestoreAllAttributes">_RestoreAllAttributes</a> methods
     *  that save and restore <i>all</i> the attributes on an element.
     *  Component subclasses can opt into these _SaveAllAttributes/_RestoreAllAttributes
     *  implementations by overriding _SaveAttributes and _RestoreAttributes to call
     *  _SaveAllAttributes/_RestoreAllAttributes. If the subclass wants a different implementation
     *  (like save only the 'class' attribute), it can provide the implementation itself in
     *  _SaveAttributes/_GetSavedAttributes/_RestoreAttributes.
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    _RestoreAttributes: function _RestoreAttributes() {// default implementation does nothing.
    },

    /**
     * <p>Restores <i>all</i> the element's attributes which were saved in
     * <a href="#_SaveAllAttributes">_SaveAllAttributes</a>.
     * This method is final in JET.</p>
     * <p>
     * If a subclass wants to save/restore all attributes on create/destroy, then the
     * subclass can override <a href="#_SaveAttributes">_SaveAttributes</a>
     *  and call  <a href="#_SaveAllAttributes">_SaveAllAttributes</a> and also
     *  override <a href="#_RestoreAttributes">_RestoreAttributes</a>
     *  and call <a href="#_RestoreAllAttributes">_RestoreAllAttributes</a>.
     *
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     * @final
     */
    _RestoreAllAttributes: function _RestoreAllAttributes() {
      $.each(this._savedAttributes, function (index, savedAttr) {
        var element = $(savedAttr.element);
        var attributes = savedAttr.attributes; // sanity check

        if (element.length === 1) {
          var currAttr = savedAttr.element.attributes;
          var removeAttr = [];
          var i;
          var j; // request is to remove any attributes that didn't exist previously
          // need to store the attributes in an array and remove them afterwards as otherwise there are side affects

          for (i = 0, j = currAttr.length; i < j; i++) {
            if (!(currAttr[i].name in attributes)) {
              removeAttr.push(currAttr[i].name);
            }
          }

          for (i = 0, j = removeAttr.length; i < j; i++) {
            element.removeAttr(removeAttr[i]);
          }

          var attributeKeys = Object.keys(attributes);

          for (i = 0; i < attributeKeys.length; i++) {
            var attribute = attributeKeys[i];
            element.attr(attribute, attributes[attribute].attr); // @HTMLUpdateOK
          }
        }
      });
    },

    /**
     * <p>Determines the name of the translation bundle section for this component.
     *
     * @return {string} the name of this component's translations section
     * @memberof oj.baseComponent
     * @protected
     */
    _GetTranslationsSectionName: function _GetTranslationsSectionName() {
      return this.widgetFullName;
    },

    /**
     * Compares 2 option values for equality and returns true if they are equal; false otherwise.
     * This method is called before _setOptions()/_internalSetOptions() to prevent an extra call
     * with the same values when observables are written back. Components should override this
     * method for options with non primitive writeback values like Arrays or Objects and ensure
     * their metadata has writeback properties correctly indicated.
     *
     * @param {String} option - the name of the option
     * @param {Object} value1 first value
     * @param {Object} value2 another value
     * @return {boolean}
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    _CompareOptionValues: function _CompareOptionValues(option, value1, value2) {
      // We process the metadata for custom elements for writeback properties and save them on the component.
      // For jQuery syntax, components are expected to override this method to check writeback values since
      // there's not always a straightforward mapping of custom element to jQuery widget name.
      if (this._IsCustomElement() && this._getWritebackOption(option)) {
        return oj.Object.compareValues(value1, value2);
      }

      return value1 === value2;
    },

    /**
     * <p>Retrieves a translated string after inserting optional parameters.
     *
     * @param {string} key the translations resource key
     * The key is used to retrieve a format pattern from the component options, or if none
     * is found - from the translated resource bundle.
     * Tokens like {0}, {1}, {name} within the pattern will be used to define placement
     * for the optional parameters.  Token strings should not contain comma (,)
     * or space characters, since they are reserved for future format type enhancements.
     * The reserved characters within a pattern are:
     * $ { } [ ]
     * These characters will not appear in the formatted output unless they are escaped
     * with a dollar character ('$').
     *
     * @param {...string|Object|Array} var_args  - optional parameters to be inserted into the
     * translated pattern.
     *
     * If more than one var_args arguments are passed, they will be treated as an array
     * for replacing positional tokens like {0}, {1}, etc.
     * If a single argument is passed, it will be treated as a Javascript Object whose
     * keys will be matched to tokens within the pattern. Note that an Array is just
     * a special kind of such an Object.
     *
     * For backward compatibility, a var_args argument whose type is neither
     * Object or Array will be used to replace {0} in the pattern.
     *
     * @return formatted translated string or the key argument if the resource for the
     * key was not found
     *
     * @memberof oj.baseComponent
     * @instance
     * @private
     */
    // TODO: non-public methods need to start with "_".  Pinged architect, who thinks this
    // method should become protected post-V1, which would imply a capital _GetTranslatedString
    // eslint-disable-next-line no-unused-vars, camelcase
    getTranslatedString: function getTranslatedString(key, var_args) {
      var params = {};

      if (arguments.length > 2) {
        params = Array.prototype.slice.call(arguments, 1);
      } else if (arguments.length === 2) {
        params = arguments[1];

        if (_typeof(params) !== 'object' && !(params instanceof Array)) {
          params = [params];
        }
      }

      var pattern = this.option(_OJ_TRANSLATIONS_PREFIX + key); // pattern could be undefined

      return pattern == null ? key : Translations.applyParameters(pattern.toString(), params);
    },
    // Subclasses should doc their sub-id's in the Sub-ID's section, via the ojsubid tag, not by overriding
    // and extending this method doc, which should remain general purpose.

    /**
     * <p>Returns the DOM node indicated by the <code class="prettyprint">locator</code> parameter.
     *
     * <p>If the <code class="prettyprint">locator</code> or its <code class="prettyprint">subId</code> is
     * <code class="prettyprint">null</code>, then this method returns this element.
     *
     * <p>If a non-null <code class="prettyprint">subId</code> is provided but no corresponding node
     * can be located, then this method returns <code class="prettyprint">null</code>.
     *
     * <p>This method is intended for use in test automation only, and should not be used in a production environment.
     *
     * @expose
     * @memberof oj.baseComponent
     * @instance
     * @ignore
     *
     * @param {Object} locator An Object containing, at minimum, a <code class="prettyprint">subId</code>
     * property, whose value is a string that identifies a particular DOM node in this element.
     *
     * <p>If this component has any subIds, then they are documented in the
     * <a href="#subids-section">Sub-ID's</a> section of this document.
     *
     * <p>Some components may support additional fields of the
     * <code class="prettyprint">locator</code> Object, to further specify the desired node.
     *
     * @returns {Element|null} The DOM node located by the
     * <code class="prettyprint">locator</code>, or <code class="prettyprint">null</code> if none is found.
     *
     * @example <caption>Get the node for a certain subId:</caption>
     * var node = myComponent.getNodeBySubId({'subId': 'oj-some-sub-id'});
     */
    getNodeBySubId: function getNodeBySubId(locator) {
      if (locator == null || locator.subId == null) {
        return this.element ? this.element[0] : null;
      } // Non-null locators have to be handled by the component subclasses


      return null;
    },

    /**
     * <p>Returns the subId string for the given DOM node in this element.  For details, see
     * <a href="#getNodeBySubId">getNodeBySubId</a> and the <a href="#subids-section">Sub-ID's</a>
     * section of this document.
     *
     * <p>This method is intended for use in test automation only, and should not be used in a production environment.
     *
     * @ojfragment getSubIdByNodeDesc
     * @memberof oj.baseComponent
     */

    /**
     * DOM node in this element
     *
     * @ojfragment getSubIdByNodeNodeParam
     * @memberof oj.baseComponent
     */

    /**
     * The subId for the DOM node, or <code class="prettyprint">null</code> if none is found.
     *
     * @ojfragment getSubIdByNodeReturn
     * @memberof oj.baseComponent
     */

    /**
     * Get the subId for a certain DOM node:
     *
     * @ojfragment getSubIdByNodeCaption
     * @memberof oj.baseComponent
     */

    /**
     * var locator = myComponent.getSubIdByNode(nodeInsideElement);
     *
     * @ojfragment getSubIdByNodeExample
     * @memberof oj.baseComponent
     */
    // While a subclass could technically extend the verbiage by adding its own verbiage after the ojinclude,
    // please doc sub-id's in the subid's section, not by extending this method doc.

    /**
     * {@ojinclude "name":"getSubIdByNodeDesc"}
     *
     * @expose
     * @memberof oj.baseComponent
     * @instance
     * @ignore
     *
     * @param {!Element} node {@ojinclude "name":"getSubIdByNodeNodeParam"}
     * @returns {Object|null} {@ojinclude "name":"getSubIdByNodeReturn"}
     *
     * @example <caption>{@ojinclude "name":"getSubIdByNodeCaption"}</caption>
     * {@ojinclude "name":"getSubIdByNodeExample"}
     */
    // eslint-disable-next-line no-unused-vars
    getSubIdByNode: function getSubIdByNode(node) {
      return null;
    },
    // Overridden to set oj-hover and oj-focus classes
    // TODO: Move JSDoc from subclasses to here.  Don't include above internal comment.  Make at-final.
    destroy: function destroy() {
      if (this._IsCustomElement()) {
        throw new Error('destroy cannot be called on a custom element');
      } // Fire 'destroy' event


      this._trigger('destroy'); // Since jQuery event listeners get removed before the destroy() method whne jQuery.clean() cleans up the subtree,
      // we need to fire a custom DOM event as well. This will allow component binding to execute destroy callbacks for
      // custom bindings and managed attributes.


      oj.DomUtils.dispatchEvent(this.element[0], new CustomEvent('_ojDestroy')); // allow subcomponent to release resources they hold.

      this._ReleaseResources();

      this._super(); // remove hover and active listeners
      //    this.widget().off(this.eventNamespace);
      // clean up states


      this.element.removeClass(_OJ_COMPONENT_NODE_CLASS);
      this.widget().removeClass('oj-disabled'); // pass init node (this.element), not root node if different (this.widget()), since all elements in
      // the root node subtree but not the init node subtree should have been removed by the call to _super.

      this._removeStateClasses(this.element);

      _removeWidgetName(this.element, this.widgetName);

      this._RestoreAttributes(); // TODO: move this to _RestoreAttributes?


      if (this._initialCmDomAttr) {
        this.element.attr('contextmenu', this._initialCmDomAttr);
      } else {
        this.element.removeAttr('contextmenu');
      }

      this._propertyContext = null;
    },

    /*
     * Internal notes:
     * Overridden to pass extra flags to _setOption
     * param {...Object} var_args - key (or map), value, flags
     */

    /**
     * <p>This method has several overloads, which get and set component options and their fields.  The functionality is unchanged from
     * that provided by JQUI.  See the examples for details on each overload.
     *
     * @ignore
     * @expose
     * @memberof oj.baseComponent
     * @instance
     * @final
     *
     * @param {string|Object=} optionName the option name (string, first two overloads), or the map (Object, last overload).
     *        Omitted in the third overload.
     * @param {Object=} value a value to set for the option.  Second overload only.
     * @return {Object|undefined} The getter overloads return the retrieved value(s).  When called via the public jQuery syntax, the setter overloads
     *         return the object on which they were called, to facilitate method chaining.
     *
     * @example <caption>First overload: get one option:
     * <p>This overload accepts a (possibly dot-separated) <code class="prettyprint">optionName</code> param as a string, and returns
     * the current value of that option.</caption>
     * var isDisabled = $( ".selector" ).ojFoo( "option", "disabled" ); // Foo is Button, Menu, etc.
     *
     * // For object-valued options, dot notation can be used to get the value of a field or nested field.
     * var startIcon = $( ".selector" ).ojButton( "option", "icons.start" ); // icons is object with "start" field
     *
     * @example <caption>Second overload: set one option:
     * <p>This overload accepts two params: a (possibly dot-separated) <code class="prettyprint">optionName</code> string, and a new value to
     * which that option will be set.</caption>
     * $( ".selector" ).ojFoo( "option", "disabled", true ); // Foo is Button, Menu, etc.
     *
     * // For object-valued options, dot notation can be used to set the value
     * // of a field or nested field, without altering the rest of the object.
     * $( ".selector" ).ojButton( "option", "icons.start", myStartIcon ); // icons is object with "start" field
     *
     * @example <caption>Third overload: get all options:
     * <p>This overload accepts no params, and returns a map of key/value pairs representing all the component
     * options and their values.</caption>
     * var options = $( ".selector" ).ojFoo( "option" ); // Foo is Button, Menu, etc.
     *
     * @example <caption>Fourth overload: set one or more options:
     * <p>This overload accepts a single map of option-value pairs to set on the component.  Unlike the first two
     * overloads, dot notation cannot be used.</caption>
     * $( ".selector" ).ojFoo( "option", { disabled: true, bar: 42 } ); // Foo is Button, Menu, etc.
     */
    option: function option(optionName, value) {
      // actually varArgs per comment above the JSDoc, but GCC warns unless matches the @param that we wish to doc
      if (arguments.length === 0) {
        // don't return a reference to the internal hash
        return $.widget.extend({}, this.options);
      }

      var key = arguments[0];
      var options = key;
      var subkey = null;
      var flags = {};
      var i;

      if (typeof key === 'string') {
        // handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
        options = {};
        var parts = key.split('.');
        key = parts.shift();

        if (parts.length) {
          subkey = parts.join('.');
          var curOption;

          try {
            // Inform dynamic getters that the subkey is being set
            if (arguments.length > 1) {
              this._settingNestedKey = subkey;
            }

            curOption = $.widget.extend({}, this.options[key]);
            options[key] = curOption;
          } finally {
            this._settingNestedKey = null;
          }

          for (i = 0; i < parts.length - 1; i++) {
            curOption[parts[i]] = curOption[parts[i]] || {};
            curOption = curOption[parts[i]];
          }

          key = parts.pop();

          if (arguments.length === 1) {
            return curOption[key] === undefined ? null : curOption[key];
          }

          curOption[key] = value;
        } else {
          if (arguments.length === 1) {
            return this.options[key] === undefined ? null : this.options[key];
          }

          options[key] = value;
        }

        flags = arguments[2] || flags;
      } else {
        flags = arguments[1] || flags;
      } // Store subkey on the flags to let _setOption() know that dot notation was used


      if (subkey != null) {
        var subprop = {
          path: optionName,
          value: value
        };
        flags = $.widget.extend({}, flags, {
          subkey: subkey,
          subproperty: subprop
        });
      }

      var context = flags ? flags._context : null;
      var internalSet = context ? context.internalSet : false; // This method can be called twice with the same value for writeback properties
      // so we need to go through the options object and only pass through the changed values

      var newOptions = {};
      var optionKeys = Object.keys(options);

      for (i = 0; i < optionKeys.length; i++) {
        var option = optionKeys[i];
        var newValue = options[option];
        var oldValue = this.options[option]; // The changed flag is set when components have updated an object or array value in place

        var changed = flags && flags.changed;

        if (changed || !this._CompareOptionValues(option, oldValue, newValue)) {
          newOptions[option] = newValue;
        } else if (this._IsCustomElement()) {
          Logger.info(oj.BaseCustomElementBridge.getElementInfo(this.element[0]) + ": Ignoring property set for property '" + option + "' with same value.");
        }
      }

      if (Object.keys(newOptions).length > 0) {
        // Avoid _setOption() calls for internal sets, since component's _setOption()
        // and setOptions() overrides do not expect to be called in that case
        if (internalSet) {
          this._internalSetOptions(newOptions, flags);
        } else {
          this._setOptions(newOptions, flags);
        }
      }

      return this;
    },

    /**
     * option() calls this rather than _setOption() if the caller was internal.
     *
     * @memberof oj.baseComponent
     * @instance
     * @private
     */
    _internalSetOptions: function _internalSetOptions(options, flags) {
      var keys = Object.keys(options);

      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var value = options[key];
        var oldValue = this.options[key];
        this.options[key] = value;

        this._optionChanged(key, value, oldValue, flags);
      }
    },

    /**
     * <p>Overridden to pass extra flags to _setOption.
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     * @ignore
     */
    _setOptions: function _setOptions(options, flags) {
      var keys = Object.keys(options);

      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var value = options[key];

        this._setOption(key, value, flags);
      }

      return this;
    },

    /**
     * Overridden to set oj-hover and oj-focus classes.
     * Components should not call this method directly, but instead call option().
     * @memberof oj.baseComponent
     * @instance
     * @protected
     * @ignore
     */
    _setOption: function _setOption(key, value, flags) {
      var originalValue = this.options[key];

      if (key === 'disabled') {
        // The JQUI superclass method has hard-coded style classes in the 'if key === "disabled"' block, so unfortunately
        // we must copy that logic here with updated style classes, and NOT call _super() for the disabled case.
        // TBD: keep this logic updated if superclass method changes.
        this.options[key] = value; // TBD: widget() is not always the thing that should have aria-disabled on it.  E.g. for the checkbox/radio flavors of ojButton,
        // widget() returns the root node, but aria-disabled belongs on the <input>.  We fixed this JQUI bug in ojButton by having ojButton
        // override this method to remove it from the root node and add it to the input.  Would be better for each component to know which
        // element to apply that to, e.g. an overridable method returning that element, or copying "hoverable" paradigm if appropriate.
        // In the cases where this.element is different than widget(), this.element is more likely to be the right thing, so maybe change
        // default to that.
        // Update: this issue is getting even more awkward now that we have "effectively disabled".  Probably need to refactor this code!

        this.widget().toggleClass('oj-disabled', !!value).attr('aria-disabled', value);

        if (value) {
          this._removeStateClasses(this.widget());
        }
      } else {
        try {
          var subkey = flags == null ? null : flags.subkey;

          if (subkey != null) {
            this._settingNestedKey = subkey;
          }

          this._super(key, value);
        } finally {
          this._settingNestedKey = null;
        } // if contextMenu option wasn't set before, we'll need to start detect gesture


        if (key === 'contextMenu') {
          this._SetupContextMenu();
        }
      }

      this._optionChanged(key, value, originalValue, flags);

      return this;
    },

    /**
     * @memberof oj.baseComponent
     * @instance
     * @private
     */
    _optionChanged: function _optionChanged(key, value, originalValue, flags) {
      // Assume that all values are different from originalValues as we do equality
      // checking before calling this method or trust components that have set the
      // 'changed' flag to indicate that they updated in place for an Object or Array
      // since we won't see any difference for those cases.
      // var changed = false;
      var context = null;
      var writeback = false;
      var readOnly = false;
      var originalEvent = null;
      var updatedFrom = 'external';
      var optionMetadata = null;
      var extraData;

      if (flags) {
        context = flags._context;

        if (context) {
          // Skip firing an option changed event for certain cases like
          // custom element default value sets where the bridge interprets an
          // application undefined value set to the property default defined in the
          // metadata.
          if (context.skipEvent) {
            return;
          }

          originalEvent = context.originalEvent;
          writeback = context.writeback === undefined ? originalEvent != null : context.writeback;
          readOnly = context.readOnly;
          optionMetadata = context.optionMetadata;
          extraData = context.extraData;

          if (context.internalSet) {
            updatedFrom = 'internal';
          }
        }
      }

      optionMetadata = optionMetadata || {};
      optionMetadata.writeback = writeback ? 'shouldWrite' : 'shouldNotWrite';

      if (readOnly) {
        optionMetadata.readOnly = true;
      }

      var optionChangeData = {
        option: key,
        previousValue: originalValue,
        value: value,
        optionMetadata: optionMetadata,
        updatedFrom: updatedFrom
      };
      var subkey = flags == null ? null : flags.subkey; // Walk previousValue object and find the subproperty previousValue

      if (subkey) {
        var subprops = subkey.split('.');
        var originalSubpropValue = originalValue;
        subprops.forEach(function (subprop) {
          if (!originalSubpropValue) {
            return;
          }

          originalSubpropValue = originalSubpropValue[subprop];
        });
        var subproperty = flags.subproperty;
        subproperty.previousValue = originalSubpropValue;
        optionChangeData.subproperty = subproperty;
      }

      if (extraData != null) {
        optionChangeData = $.extend({}, extraData, optionChangeData);
      }

      this._trigger('optionChange', originalEvent, optionChangeData);
    },

    /**
     * <p>Sets up needed resources for this component, for example, add
     * listeners. This is called during _create.
     * <a href="#_ReleaseResources">_ReleaseResources</a> will release resources
     * help by this component, and is called during destroy.
     * </p>
     *  Component subclasses can opt in by overriding _SetupResources and
     *   _ReleaseResources.
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    _SetupResources: function _SetupResources() {
      this._SetupContextMenu();
    },

    /**
     * <p>Release resources held by this component, for example, remove
     * listeners. This is called during destroy.
     * <a href="#_SetupResources">_SetupResources</a> will set up resources
     * needed by this component, and is called during _create.
     * </p>
     *  Component subclasses can opt in by overriding _SetupResources and
     *   _ReleaseResources.
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    _ReleaseResources: function _ReleaseResources() {
      this._ReleaseContextMenu();
    },

    /**
     * <p>Overridden to change the way the component events are treating original events:
     *
     * 1) preventDefault(), stopPropagation() and stopImmediatePropagation() no longer invoke
     *    the corresponding methods on the .originalEvent
     * 2) Properties of the .originalEvent are no longer copied to the new event being
     *    triggered
     *
     * @param {string} type - component event type
     * @param {?Object} event - original event
     * @param {Object=} data - event data
     * @return {boolean} true if the default action has not been prevented, false otherwise
     *
     * @private
     */
    _trigger: function _trigger(type, event, data) {
      return this._trigger2(type, event, data).proceed;
    },

    /**
     * <p>Same as _trigger(), but returns an object containing both the "prevented" status and the event.
     *
     * <p>This is useful for event chaining, so that the returned event (e.g. Menu's select event) can be
     * passed as the originalEvent of a subsequent event caused by the first (e.g. Menu's close event).
     *
     * @param {string} type - component event type
     * @param {?Object} event - original event
     * @param {Object=} data - event data
     * @return {!{proceed: boolean, event: ($.Event|CustomEvent)}}
     *     proceed is true if the default action has not been prevented, false otherwise
     *     event is the new event that was triggered
     *
     * @private
     */
    _trigger2: function _trigger2(type, event, data) {
      var eventData = data || {};

      if (this._IsCustomElement()) {
        return this._triggerCustomEvent(type, event, eventData);
      }

      var callback = this.options[type];
      var jqEvent = $.Event(event, _OJ_COMPONENT_EVENT_OVERRIDES);
      jqEvent.type = (this.widgetEventPrefix + type).toLowerCase(); // the original event may come from any element
      // so we need to reset the target on the new event

      jqEvent.target = this.element[0];
      this.element.trigger(jqEvent, eventData);
      return {
        proceed: !($.isFunction(callback) && callback.apply(this.element[0], [jqEvent].concat(eventData)) === false || jqEvent.isDefaultPrevented()),
        event: jqEvent
      };
    },

    /**
     * <p>Fires a CustomEvent instead of a jQuery event for when this component is created as a custom element.
     *
     * @param {string} type - component event type
     * @param {?Object} event - original event
     * @param {Object} data - event data
     * @return {!{proceed: boolean, event: CustomEvent}}
     *     proceed is true if the default action has not been prevented, false otherwise
     *     event is the new event that was triggered
     *
     * @private
     */
    _triggerCustomEvent: function _triggerCustomEvent(type, event, data) {
      var eventName;
      var detail = {};
      var bubbles;
      var cancelable;

      var rootElement = this._getRootElement();

      if (type === 'optionChange') {
        var property = oj.CustomElementBridge.getPropertyForAlias(rootElement, data.option);

        if (!oj.CustomElementBridge.isKnownProperty(rootElement, property)) {
          return {
            proceed: true,
            event: null
          };
        }

        eventName = oj.__AttributeUtils.propertyNameToChangeEventType(property); // Copy over component specific optionChange event properties, promoting those exposed
        // in the optionMetadata to the top level alongside value/previousValue/subproperty.

        var keys = Object.keys(data);

        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];

          if (key !== 'option') {
            if (key === 'optionMetadata') {
              // Do not expose optionMetadata for custom element property change events
              // Instead, promote any component specific metadata to the top level.
              var metaKeys = Object.keys(data[key]);

              for (var j = 0; j < metaKeys.length; j++) {
                var metaKey = metaKeys[j];

                if (metaKey !== 'writeback' && metaKey !== 'component') {
                  detail[metaKey] = data[key][metaKey];
                }
              }
            } else {
              detail[key] = data[key];
            }
          }
        }
      } else {
        eventName = oj.__AttributeUtils.eventTriggerToEventType(type);

        if (!oj.CustomElementBridge.isKnownEvent(rootElement, eventName)) {
          return {
            proceed: true,
            event: null
          };
        }

        bubbles = true;
        cancelable = true;
        detail = this._resolveJQueryObjects(data);
      }

      if (event) {
        detail.originalEvent = event instanceof $.Event ? event.originalEvent : event;
      }

      var params = {
        detail: detail
      };

      if (bubbles) {
        params.bubbles = true;
      }

      if (cancelable) {
        params.cancelable = true;
      }

      var customEvent = new CustomEvent(eventName, params);
      rootElement.dispatchEvent(customEvent);
      return {
        proceed: !customEvent.defaultPrevented,
        event: customEvent
      };
    },

    /**
     * <p>Creates a shallow copy of the passed in object where any top-level JQuery objects have been resolved to their underlying objects.
     * @param {Object} data the original object
     * @return {Object} the resolved object copy
     *
     * @private
     */
    _resolveJQueryObjects: function _resolveJQueryObjects(data) {
      var resolved = oj.CollectionUtils.copyInto({}, data);
      var keys = Object.keys(resolved);

      for (var k = 0; k < keys.length; k++) {
        var key = keys[k];
        var val = resolved[key];

        if (val && val instanceof $) {
          if (val.length === 0) {
            resolved[key] = null;
          } else if (val.length === 1) {
            resolved[key] = val[0];
          } else {
            resolved = val.toArray();
          }
        }
      }

      return resolved;
    },

    /**
     * <p>Sets contextMenu option from DOM if option not set.
     *
     * <p>Do not override.  To be called only from _InitOptions().
     *
     * @memberof oj.baseComponent
     * @instance
     * @private
     * @final
     */
    _initContextMenuOption: function _initContextMenuOption(constructorOptions) {
      var contextMenu = this.element.attr('contextmenu');
      this._initialCmDomAttr = contextMenu; // TODO: remove this after the _RestoreAttributes() call in destroy() is uncommented

      if (contextMenu && !('contextMenu' in constructorOptions)) {
        // if app set DOM attr but not option, then set the option from the DOM
        this.option('contextMenu', document.getElementById(contextMenu), {
          _context: {
            internalSet: true
          }
        }); // writeback not needed since "not in constructorOptions" means "not bound"
      }
    },

    /**
     * Handler
     * @param {Element} contextMenu root element of context menu
     * @param {Event} event the dom event
     * @param {string} eventType the type of event
     * @private
     */
    _handleContextMenuGesture: function _handleContextMenuGesture(contextMenu, event, eventType) {
      // For components like Button where "effectively disabled" --> "not focusable", keyboard CM launch is impossible, so
      // allowing right-click access would be an a11y issue.  If there's ever a need to enable this for focusable effectively
      // disabled components, we can always replace the _IsEffectivelyDisabled() call with a new protected method whose
      // baseComponent impl returns _IsEffectivelyDisabled().
      if (this._IsEffectivelyDisabled()) {
        return;
      } // contextMenu should reference the latest one from the scope


      var menu;

      if (contextMenu.tagName === 'OJ-MENU') {
        menu = contextMenu;
      } else {
        var constructor = oj.Components.__GetWidgetConstructor(contextMenu, 'ojMenu');

        menu = constructor && constructor('instance');

        if (!menu) {
          throw new Error('Invalid JET Menu.'); // keeping old behavior
        }
      }

      this._NotifyContextMenuGesture(menu, event, eventType); // todo: modify NotifyContextMenuGesture contract so we don't need to check visible


      if ($(contextMenu).is(':visible')) {
        event.preventDefault(); // don't show native context menu
      }
    },

    /**
     * <p>Call this method from _SetupResources().  It sets up listeners needed to detect context menu gestures.
     *
     * <p>We don't look for the menu until context menu gesture has been detected on the first launch,
     * so that the menu needn't be inited before this component.
     *
     * <p>If needed, override <code class="prettyprint">_NotifyContextMenuGesture()</code>, not this private method.
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    _SetupContextMenu: function _SetupContextMenu() {
      var contextMenu = this._GetContextMenu();

      if (!contextMenu) {
        contextMenu = this._GetDefaultContextMenu();
      }

      if (contextMenu && this._contextMenuGestureInit === undefined) {
        this._contextMenuGestureInit = contextMenu;
        var self = this;
        oj.GestureUtils.startDetectContextMenuGesture(this.widget()[0], function (event, eventType) {
          self._handleContextMenuGesture(contextMenu, event, eventType);
        });
      }
    },

    /**
     * <p>This method removes contextMenu functionality from the component and specified menu.
     *
     * @memberof oj.baseComponent
     * @instance
     * @private
     */
    _ReleaseContextMenu: function _ReleaseContextMenu() {
      this._contextMenuGestureInit = undefined; // access menu elem directly, rather than using the widget() of the Menu component, so listener is cleared even if component no longer exists.
      // $(contextMenuOption).off( this.contextMenuEventNamespace );

      oj.GestureUtils.stopDetectContextMenuGesture(this.widget()[0]);
    },

    /**
     * Helper method to retrieve the context menu element
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    _GetContextMenu: function _GetContextMenu() {
      if (this._IsCustomElement()) {
        var slotMap = oj.BaseCustomElementBridge.getSlotMap(this._getRootElement());
        var slot = slotMap.contextMenu;

        if (slot && slot.length > 0) {
          return slot[0];
        }
      } else if (this.options.contextMenu) {
        return $(this.options.contextMenu).first()[0];
      }

      return null;
    },

    /**
     * <p>When the <a href="#contextMenu">contextMenu</a> option is set, this method is called when the user invokes the context menu via
     * the default gestures: right-click, <kbd>Press & Hold</kbd>, and <kbd>Shift-F10</kbd>.  Components should not call this method directly.
     *
     * <p>The default implementation simply calls <a href="#_OpenContextMenu">this._OpenContextMenu(event, eventType)</a>.
     * Overrides of this method should call that same method, perhaps with additional params, not [menu.open()]{@link oj.ojMenu#open}.
     *
     * <p>This method may be overridden by components needing to do things like the following:
     *
     * <ul>
     * <li>Customize the [launcher]{@link oj.ojMenu#openOptions.launcher} or [position]{@link oj.ojMenu#openOptions.position} passed to
     * <a href="#_OpenContextMenu">_OpenContextMenu()</a>.  See that method for guidance on these customizations.</li>
     *
     * <li>Customize the menu contents.  E.g. some components need to enable/disable built-in commands like <kbd>Cut</kbd> and <kbd>Paste</kbd>,
     * based on state at launch time.</li>
     *
     * <li>Bail out in some cases.  E.g. components with UX approval to use <kbd>PressHoldRelease</kbd> rather than <kbd>Press & Hold</kbd> can override this method
     * to say <code class="prettyprint">if (eventType !== "touch") this._OpenContextMenu(event, eventType);</code>.  When those components
     * detect the alternate context menu gesture (e.g. <kbd>PressHoldRelease</kbd>), that separate listener should call <a href="#_OpenContextMenu">this._OpenContextMenu()</a>,
     * not this method (<code class="prettyprint">_NotifyContextMenuGesture()</code>), and not [menu.open()]{@link oj.ojMenu#open}.  </li>
     * </ul>
     *
     * <p>Components needing to do per-launch setup like the above tasks should do so in an override of this method, <i>not</i> in
     * a [beforeOpen]{@link oj.ojMenu#event:beforeOpen} listener or an <a href="#_OpenContextMenu">_OpenContextMenu()</a> override.
     * This is discussed more fully <a href="#_OpenContextMenu">here</a>.
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     *
     * @param {!Object} menu The JET Menu to open as a context menu.  Always non-<code class="prettyprint">null</code>.
     * @param {!Event} event What triggered the menu launch.  Always non-<code class="prettyprint">null</code>.
     * @param {string} eventType "mouse", "touch", or "keyboard".  Never <code class="prettyprint">null</code>.
     */
    _NotifyContextMenuGesture: function _NotifyContextMenuGesture(menu, event, eventType) {
      this._OpenContextMenu(event, eventType);
    },

    /**
     * <p>The only correct way for a component to open its context menu is by calling this method, not by calling [Menu.open()]{@link oj.ojMenu#open} or
     * <a href="#_NotifyContextMenuGesture">_NotifyContextMenuGesture()</a>.  This method should be called in two cases:
     *
     * <ul>
     * <li>This method is called by <a href="#_NotifyContextMenuGesture">_NotifyContextMenuGesture()</a> and its overrides.  That method is
     * called when the baseComponent detects the default context menu gestures: right-click, <kbd>Press & Hold</kbd>, and <kbd>Shift-F10</kbd>.</li>
     *
     * <li>Components with UX-approved support for alternate context menu gestures like <kbd>PressHoldRelease</kbd> should call this method directly
     * when those gestures are detected.</li>
     * </ul>
     *
     * <p>Components needing to customize how the context menu is launched, or do any per-launch setup, should do so in the caller of this method,
     * (which is one of the two callers listed above), often by customizing the params passed to this method
     * (<code class="prettyprint">_OpenContextMenu</code>) per the guidance below.  This setup should <i>not</i> be done in the following ways:
     *
     * <ul>
     * <li>Components should not perform setup in a [beforeOpen]{@link oj.ojMenu#event:beforeOpen} listener, as this can cause a race
     * condition where behavior depends on who got their listener registered first: the component or the app.  The only correct component use
     * of a <code class="prettyprint">beforeOpen</code> listener is when there's a need to detect whether <i>something else</i> launched the menu.</li>
     *
     * <li>Components should not override this method (<code class="prettyprint">_OpenContextMenu</code>), as this method is final.  Instead, customize
     * the params that are passed to it.</li>
     * </ul>
     *
     * <p><b>Guidance on setting OpenOptions fields:</b>
     *
     * <p><b>Launcher:</b>
     *
     * <p>Depending on individual component needs, any focusable element within the component can be the appropriate
     * [launcher]{@link oj.ojMenu#openOptions.launcher} for this launch.
     *
     * <p>Browser focus returns to the launcher on menu dismissal, so the launcher must at least be focusable.  Typically a tabbable (not just
     * focusable) element is safer, since it just focuses something the user could have focused on their own.
     *
     * <p>By default (i.e. if <code class="prettyprint">openOptions</code> is not passed, or if it lacks a <code class="prettyprint">launcher</code>
     * field), the component init node is used as the launcher for this launch.  If that is not focusable or is suboptimal for a given
     * component, that component should pass something else.  E.g. components with a "roving tabstop" (like Toolbar) should typically choose the
     * current tabstop as their launcher.
     *
     * <p>The [:focusable]{@link http://api.jqueryui.com/focusable-selector/} and [:tabbable]{@link http://api.jqueryui.com/tabbable-selector/} selectors
     * may come in handy for choosing a launcher, e.g. something like <code class="prettyprint">this.widget().find(".my-class:tabbable").first()</code>.
     *
     * <p><b>Position:</b>
     *
     * <p>By default, this method applies [positioning]{@link oj.ojMenu#openOptions.position} that differs from Menu's default in the following ways:
     * (The specific settings are subject to change.)
     *
     * <ul>
     * <li>For mouse and touch events, the menu is positioned relative to the event, not the launcher.</li>
     *
     * <li>For touch events, <code class="prettyprint">"my"</code> is set to <code class="prettyprint">"start>40 center"</code>,
     * to avoid having the context menu obscured by the user's finger.</li>
     * </ul>
     *
     * <p>Usually, if <code class="prettyprint">position</code> needs to be customized at all, the only thing that needs changing is its
     * <code class="prettyprint">"of"</code> field, and only for keyboard launches (since mouse/touch launches should almost certainly keep
     * the default <code class="prettyprint">"event"</code> positioning).  This situation arises anytime the element relative to which the menu
     * should be positioned for keyboard launches is different than the <code class="prettyprint">launcher</code> element (the element to which
     * focus should be returned upon dismissal).  For this case, <code class="prettyprint">{ "position": {"of": eventType==="keyboard" ? someElement : "event"} }</code>
     * can be passed as the <code class="prettyprint">openOptions</code> param.
     *
     * <p>Be careful not to clobber useful defaults by specifying too much.  E.g. if you only want to customize <code class="prettyprint">"of"</code>,
     * don't pass other fields like <code class="prettyprint">"my"</code>, since your value will be used for all modalities (mouse, touch, keyboard),
     * replacing the modality-specific defaults that are usually correct.  Likewise, don't forget the
     * <code class="prettyprint">eventType==="keyboard"</code> check if you only want to customize <code class="prettyprint">"of"</code> for keyboard launches.
     *
     * <p><b>InitialFocus:</b>
     *
     * <p>This method forces [initialFocus]{@link oj.ojMenu#openOptions.initialFocus} to <code class="prettyprint">"menu"</code> for this
     * launch, so the caller needn't specify it.
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     * @final
     *
     * @param {!Event} event What triggered the context menu launch.  Must be non-<code class="prettyprint">null</code>.
     * @param {string} eventType "mouse", "touch", or "keyboard".  Must be non-<code class="prettyprint">null</code>.  Passed explicitly since caller
     *        knows what it's listening for, and since events like <code class="prettyprint">contextmenu</code> and
     *        <code class="prettyprint">click</code> can be generated by various input modalities, making it potentially error-prone for
     *        this method to determine how they were generated.
     * @param {Object=} openOptions Options to merge with this method's defaults, which are discussed above.  The result will be passed to
     *        [Menu.open()]{@link oj.ojMenu#open}.  May be <code class="prettyprint">null</code> or omitted.  See also the
     *        <code class="prettyprint">shallow</code> param.
     * @param {Object=} submenuOpenOptions Options to be passed through to [Menu.open()]{@link oj.ojMenu#open}.  May be <code class="prettyprint">null</code>
     *        or omitted.
     * @param {boolean=} shallow Whether to perform a deep or shallow merge of <code class="prettyprint">openOptions</code> with this method's default
     *        value.  The default and most commonly correct / useful value is <code class="prettyprint">false</code>.
     *
     *        <ul>
     *        <li>If <code class="prettyprint">true</code>, a shallow merge is performed, meaning that the caller's <code class="prettyprint">position</code>
     *        object, if passed, will completely replace this method's default <code class="prettyprint">position</code> object.</li>
     *
     *        <li>If <code class="prettyprint">false</code> or omitted, a deep merge is performed.  For example, if the caller wishes to tweak
     *        <code class="prettyprint">position.of</code> while keeping this method's defaults for <code class="prettyprint">position.my</code>,
     *        <code class="prettyprint">position.at</code>, etc., it can pass <code class="prettyprint">{"of": anOfValue}</code> as the
     *        <code class="prettyprint">position</code> value.</li>
     *        </ul>
     *
     *        <p>The <code class="prettyprint">shallow</code> param is n/a for <code class="prettyprint">submenuOpenOptions</code>, since this method doesn't
     *        apply any defaults to that.  (It's a direct pass-through.)
     */
    _OpenContextMenu: function _OpenContextMenu(event, eventType, openOptions, submenuOpenOptions, shallow) {
      var contextMenuNode = this._GetContextMenu();

      if (!contextMenuNode) {
        // the context menu node could have been currently opened with another launcher
        if (this._contextMenuGestureInit && $(this._contextMenuGestureInit).is(':visible')) {
          contextMenuNode = this._contextMenuGestureInit;
        } else {
          contextMenuNode = this._GetDefaultContextMenu();
        }
      }

      if (contextMenuNode) {
        // Note: our touch positioning is similar to that of the iOS touch callout (bubble with "Open in New Tab", etc.), which is offset from the pressHold location as follows:
        // - to the right, vertically centered.  (by default)
        // - to the left, vertically centered.  (if fits better)
        // - above or below, horizontally centered.  (if fits better)
        // An offset like 40 prevents it from opening right under your finger, and is similar to iOS's offset.  It also prevents the issue (on iOS7 at least)
        // where touchend after the pressHold can dismiss the CM b/c the menu gets the touchend.
        var position = {
          mouse: {
            my: 'start top',
            at: 'start bottom',
            of: event,
            collision: 'flipfit'
          },
          touch: {
            my: 'start>40 center',
            at: 'start bottom',
            of: event,
            collision: 'flipfit'
          },
          keyboard: {
            my: 'start top',
            at: 'start bottom',
            of: 'launcher',
            collision: 'flipfit'
          }
        };
        var defaults = {
          launcher: this.element,
          position: position[eventType]
        }; // used for fields caller omitted

        var forcedOptions = {
          initialFocus: 'menu'
        };
        var mergedOpenOptions = shallow ? $.extend(defaults, openOptions, forcedOptions) : $.extend(true, defaults, openOptions, forcedOptions);
        contextMenuNode.__openingContextMenu = true; // Hack.  See todo on this ivar in Menu.open().

        if (contextMenuNode.tagName === 'OJ-MENU') {
          contextMenuNode.open(event, mergedOpenOptions, submenuOpenOptions);
        } else {
          var constructor = oj.Components.__GetWidgetConstructor(contextMenuNode, 'ojMenu');

          var menu = constructor && constructor('instance');
          menu.open(event, mergedOpenOptions, submenuOpenOptions); // Open is immediate for jquery UI menus.
          // Win FF will fire a contextmenu event on shift+F10 long after the keypress was prevented.
          // jquery ui needs immediate focus to the menu on open. The contextmenu event is fired on
          // the menu versus the launcher. This logic prevents the context menu event within a 50ms
          // window after the menu is open.

          var eatEventHandler = function eatEventHandler(e) {
            e.preventDefault();
          };

          contextMenuNode.addEventListener('contextmenu', eatEventHandler);
          window.setTimeout(function () {
            contextMenuNode.removeEventListener('contextmenu', eatEventHandler);
          }, 50);
        }

        contextMenuNode.__openingContextMenu = false;
      }
    },

    /**
     * Retrieve the default context menu.
     * @return {Element|null} the root element for the default context menu, or null if there is no default context menu.  The default is null.
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    _GetDefaultContextMenu: function _GetDefaultContextMenu() {
      return null;
    },

    /**
     * <p>Removes the <code class="prettyprint">oj-hover</code>, <code class="prettyprint">oj-focus</code>,
     * <code class="prettyprint">oj-focus-highlight</code>, and
     * <code class="prettyprint">oj-active</code> classes from the specified element and its subtree.
     *
     * @memberof oj.baseComponent
     * @instance
     * @private
     *
     * @param {!jQuery} element The element from whose subtree the 3 classes should be removed
     */
    _removeStateClasses: function _removeStateClasses(element) {
      element.removeClass('oj-hover oj-focus oj-focus-highlight oj-active');
      element.find('.oj-hover').removeClass('oj-hover');
      element.find('.oj-focus').removeClass('oj-focus');
      element.find('.oj-focus-highlight').removeClass('oj-focus-highlight');
      element.find('.oj-active').removeClass('oj-active');
    },

    /**
     * @private
     * @return {boolean} true if there is no touch detected within the last 500 ms
     */
    _isRealMouseEvent: function _isRealMouseEvent() {
      return !oj.DomUtils.recentTouchEnd();
    },

    /**
     * Add mouse listners to toggle oj-hover class
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
       * @param {(!Object|!jQuery)} options This param can either be the element
     * (convenience syntax for callers needing to
     *   specify only the element(s) that would
     *   otherwise have been passed as <code class="prettyprint">options.element</code>)
     *   or an object supporting the following fields:
     * @param {jQuery} options.element The element(s) to receive the <code class="prettyprint">oj-hover</code> class on hover
     *   Required if <code class="prettyprint">afterToggle</code> is specified.
     * @param {?function(string)} options.afterToggle Optional callback function called each time the hover classes have been toggled,
     *   after the toggle.  The string "mouseenter" or "mouseleave" is passed, indicating whether the classes were added or removed.
     *   Components with consistency requirements, such as "<code class="prettyprint">oj-default</code> must be applied iff no state classes
     *   such as <code class="prettyprint">oj-hover</code> are applied," can enforce those rules in this callback.
     * @see #_RemoveHoverable
     */
    _AddHoverable: function _AddHoverable(options) {
      var element;

      if ($.isPlainObject(options)) {
        element = options.element;
      } else {
        element = options; // eslint-disable-next-line no-param-reassign

        options = {};
      }

      var afterToggle = options.afterToggle || $.noop;
      var markerClass = 'oj-hover';
      element.on('mouseenter' + this.hoverableEventNamespace, this._hoverStartHandler.bind(this, afterToggle)).on('mouseleave' + this.hoverableEventNamespace, this._hoverAndActiveEndHandler.bind(this, markerClass, afterToggle));
    },

    /**
     * Remove mouse listners that were registered in _AddHoverable
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     * @param {!jQuery} element The same element passed to _AddHoverable
     * @see #_AddHoverable
     */
    _RemoveHoverable: function _RemoveHoverable(element) {
      if (element) {
        element.off(this.hoverableEventNamespace);
      }
    },

    /**
     * Add touch and mouse listeners to toggle oj-active class
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
       * @param {(!Object|!jQuery)} options This parameter can either be the element
     * (convenience syntax for callers needing to
     *   specify only the element(s) that would
     *   otherwise have been passed as <code class="prettyprint">options.element</code>)
     *   or an object supporting the following fields:
     * @param {jQuery} options.element The element(s) to receive the
     * <code class="prettyprint">oj-active</code> class on active
     *   Required if <code class="prettyprint">afterToggle</code> is specified.
     * @param {?function(string)} options.afterToggle Optional callback function called each time
     *   the active classes have been toggled, after the toggle.  The event.type string is passed
     *   and indicates whether the classes were added or removed. The active classes are added on
     *   "touchstart" or "mousedown" or "mouseenter" and the active classes are removed on
     *   "touchend" or "touchcancel" or "mouseup" or "mouseleave".
     *   Components with consistency requirements, such as
     *   "<code class="prettyprint">oj-default</code> must be applied iff no state classes
     *   such as <code class="prettyprint">oj-active</code> are applied,"
     *   can enforce those rules in this callback.
     * @see #_RemoveActiveable
     */
    _AddActiveable: function _AddActiveable(options) {
      var element;

      if ($.isPlainObject(options)) {
        element = options.element;
      } else {
        element = options; // eslint-disable-next-line no-param-reassign

        options = {};
      }

      var afterToggle = options.afterToggle || $.noop;
      var markerClass = 'oj-active';

      if (oj.DomUtils.isTouchSupported()) {
        // make sure native element exists
        if (element[0]) {
          // register touchstart with passive option
          this._touchstartListener = this._activeStartHandler.bind(this, afterToggle);
          element[0].addEventListener('touchstart', this._touchstartListener, {
            passive: true
          });
        }

        element.on('touchend' + this.activeableEventNamespace + ' ' + 'touchcancel' + this.activeableEventNamespace, this._hoverAndActiveEndHandler.bind(this, markerClass, afterToggle));
      }

      element.on('mousedown' + this.activeableEventNamespace, this._activeStartHandler.bind(this, afterToggle)).on('mouseup' + this.activeableEventNamespace, this._hoverAndActiveEndHandler.bind(this, markerClass, afterToggle)) // mouseenter/mouseleave is for the case where you mousedown, then move mouse
      // out of element, then move mouse back. We want oj-active to disappear when you move
      // outside and reappear when you move back.
      .on('mouseenter' + this.activeableEventNamespace, this._activeStartHandler.bind(this, afterToggle)).on('mouseleave' + this.activeableEventNamespace, this._hoverAndActiveEndHandler.bind(this, markerClass, afterToggle));
    },

    /**
     * Remove touch and mouse listeners that were registered in _AddActiveable
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     * @param {!jQuery} element The same element passed to _AddActiveable
     * @see #_AddActiveable
     */
    _RemoveActiveable: function _RemoveActiveable(element) {
      if (element) {
        // make sure native element exists
        if (element[0]) {
          // remove touchstart registered with passive option
          element[0].removeEventListener('touchstart', this._touchstartListener, {
            passive: true
          });
          delete this._touchstartListener;
        }

        element.off(this.activeableEventNamespace);
        _lastActiveElement = null;
      }
    },

    /**
     * Add oj-active style class and call the afterToggleFunction.
     * Set _lastActiveElement to event.currentTarget on mousedown. Clear it on mouseup.
     * _lastActiveElement is used to remove and add back oj-active on mouseleave and mouseenter
     * if the mouse stays down.
     * @private
     */
    _activeStartHandler: function _activeStartHandler(afterToggleFunction, event) {
      var elem = $(event.currentTarget); // do nothing on mouseenter if _lastActiveElement ivar is not the currentTarget or child of
      // currentTarget. Checking for the child is needed in case there are two nested
      // dom nodes that have set_AddActiveable. Since events bubble, the _lastActiveElement will
      // be the outermost dom that got the mousedown event.

      if (event.type === 'mouseenter' && !this._isTargetInActiveElement(event.currentTarget)) {
        return;
      } // do this for either touchstart or real mouse events, but not mouse compatibility event


      if (!elem.hasClass('oj-disabled') && (event.type === 'touchstart' || this._isRealMouseEvent(event))) {
        elem.addClass('oj-active');
        afterToggleFunction(event.type); // If we get mousedown on the element, we want oj-active to be removed on mouseleave
        // and added back on mouseenter if the mouse stays down.

        if (event.type === 'mousedown') {
          _lastActiveElement = event.currentTarget;
          this.document.one('mouseup', function () {
            _lastActiveElement = null;
          });
        }
      }
    },

    /**
     * @private
     */
    _hoverStartHandler: function _hoverStartHandler(afterToggleFunction, event) {
      // do this for real mouseenter, but not mouse compatibility event
      var elem = $(event.currentTarget);

      if (!elem.hasClass('oj-disabled') && this._isRealMouseEvent(event)) {
        elem.addClass('oj-hover');
        afterToggleFunction(event.type);
      }
    },

    /**
     * Remove markerClass and call the afterToggleFunction.
     * @private
     */
    _hoverAndActiveEndHandler: function _hoverAndActiveEndHandler(markerClass, afterToggleFunction, event) {
      // for oj-active we don't care about mouseleave unless it was triggered when _lastActiveElement
      // was set on the currentTarget. (see _activeStartHandler). If that's not the case, return.
      if (markerClass === 'oj-active' && event.type === 'mouseleave' && !this._isTargetInActiveElement(event.currentTarget)) {
        return;
      }

      $(event.currentTarget).removeClass(markerClass);
      afterToggleFunction(event.type);
    },

    /**
     * Returns true if the event target is _lastActiveElement or a child of _lastActiveElement.
     * Checking for the child is needed in case there are two nested dom nodes that have set
     * _AddActiveable. For example, inputDateTime -> the trigger root container and the trigger icon.
     * We are only keeping track of the _lastActiveElement, which means the ancestor element will
     * be stored in _lastActiveElement because the mouseleave event bubbles.
     * @private
     */
    _isTargetInActiveElement: function _isTargetInActiveElement(currentTarget) {
      return _lastActiveElement === currentTarget || _lastActiveElement != null && $.contains(_lastActiveElement, currentTarget);
    },
    // We no longer use _hoverable, but should still override it to ensure the JQUI impl is not called.
    _hoverable: function _hoverable() {},
    // The internal JSDoc of the DomUtils version of this API refers to this doc, so if changes are made here, that doc
    // must be updated as needed.

    /**
     * <p>Sets JET's "focus" CSS classes when the element is focused and removes them when focus is lost.
     *
     * <p>The <code class="prettyprint">oj-focus</code> class is set on all focuses.
     *
     * <p>Some components additionally have an <code class="prettyprint">oj-focus-highlight</code> class, which applies a focus
     * indicator that is appropriate on a subset of the occasions that <code class="prettyprint">oj-focus</code> is appropriate.
     * Those components should pass <code class="prettyprint">true</code> for the <code class="prettyprint">applyHighlight</code>
     * param, in which case the <code class="prettyprint">oj-focus-highlight</code> class is set if appropriate given the
     * current focus highlight policy.
     *
     * <h5>Focus highlight policy</h5>
     *
     * <p>The focus highlight policy supports the 3 values listed below.  By default, it is retrieved from the
     * <code class="prettyprint">$focusHighlightPolicy</code> SASS variable, shared by many components and patterns.  Components
     * with different needs, including those exposing a component-specific SASS variable or other API for this, should see the
     * <code class="prettyprint">getFocusHighlightPolicy</code> parameter below.
     *
     * Valid focus highlight policies:
     *
     * <table class="generic-table">
     *   <thead>
     *     <tr>
     *       <th>Policy</th>
     *       <th>Description</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>"nonPointer"</td>
     *       <td>Indicates that the component should apply the <code class="prettyprint">oj-focus-highlight</code>
     *           class only for focuses not resulting from pointer (touch or mouse) interaction.  (In the built-in themes, the
     *           SASS variable defaults to this value.)</td>
     *     </tr>
     *     <tr>
     *       <td>"all"</td>
     *       <td>Indicates that the component should apply the class for all focuses.</td>
     *     </tr>
     *     <tr>
     *       <td>"none"</td>
     *       <td>Indicates that the component should never apply the class, because the application has taken responsibility
     *           for applying the class when needed for accessibility.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h5>Toggling the classes</h5>
     *
     * <p>Components that toggle these focus classes outside of this API must maintain the invariant that
     * <code class="prettyprint">oj-focus-highlight</code> is applied to a given element in a (not necessarily strict) subset
     * of cases that <code class="prettyprint">oj-focus</code> is applied to that element.
     *
     * <p>Typically the specified element should be within the component subtree, in which case the classes will
     * automatically be removed from the element when the component is destroyed, when its <code class="prettyprint">disabled</code>
     * option is set to true, and when <code class="prettyprint">_NotifyDetached()</code> is called.
     *
     * <p>As a minor exception, for components that wrap themselves in a new root node at create time, if the specified
     * element is within the root node's subtree but not within the init node's subtree, then at destroy time only, the
     * classes will not be removed, since <code class="prettyprint">destroy()</code> is expected to remove such nodes.
     *
     * <p>If the element is NOT in the component subtree, then the caller is responsible for removing the classes at the
     * times listed above.
     *
     * <h5>Listeners</h5>
     *
     * <p>If <code class="prettyprint">setupHandlers</code> is not passed, or if <code class="prettyprint">setupHandlers</code>
     * is passed and uses <code class="prettyprint">_on</code> to register its listeners as seen in the example, then
     * the listeners are not invoked when the component is disabled, and the listeners are automatically cleaned up when the
     * component is destroyed.  Otherwise, the caller is responsible for ensuring that the disabled state is handled correctly,
     * and removing the listeners at destroy time.
     *
     * <h5>Related API's</h5>
     *
     * <p>Non-component internal callers should see oj.DomUtils.makeFocusable().  Per its JSDoc (unpublished; see the source), it
     * has a couple of additional usage considerations.
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     *
     * @param {(!Object|!jQuery)} options This param can either be the element (convenience syntax for callers needing to
     *   specify only the element(s) that would otherwise have been passed as <code class="prettyprint">options.element</code>)
     *   or an object supporting the following fields:
     * @param {jQuery} options.element The element(s) to receive the <code class="prettyprint">oj-focus</code> classes on focus.
     *   Required if <code class="prettyprint">setupHandlers</code> not passed; ignored otherwise.
     * @param {boolean} options.applyHighlight <code class="prettyprint">true</code> if the <code class="prettyprint">oj-focus-highlight</code>
     *   class should be applied when appropriate.  <code class="prettyprint">false</code> or omitted if that class should never be applied.
     * @param {?function(string)} options.afterToggle Optional callback function called each time the focus classes have been toggled,
     *   after the toggle.  The
     *   string "focusin" or "focusout" is passed, indicating whether the classes were added or removed.  Components
     *   with consistency requirements, such as "<code class="prettyprint">oj-default</code> must be applied iff no state classes such
     *   as <code class="prettyprint">oj-focus</code> are applied," can enforce those rules in this callback.
     * @param {?function()} options.getFocusHighlightPolicy Optional if <code class="prettyprint">applyHighlight</code> is
     *   <code class="prettyprint">true</code>; ignored otherwise.  Components with a component-specific focus policy
     *   mechanism should pass a function that always returns one of the three valid values listed above, keeping in mind
     *   that this method can be called on every focus.  See the example.
     * @param {?function()} options.recentPointer Relevant iff <code class="prettyprint">applyHighlight</code> is
     *   <code class="prettyprint">true</code> and the focus highlight policy is <code class="prettyprint">"nonPointer"</code>;
     *   ignored otherwise.  Recent pointer activity is considered to have occurred if (a) a mouse button or finger has
     *   recently been down or up, or (b) this optional callback function returns true.  Components wishing to additionally take into
     *   account (say) recent pointer <i>movements</i> can supply a function returning true if those movements have been detected,
     *   keeping in mind that this method can be called on every focus.  See the example.
     * @param {?function(function(!jQuery),function(!jQuery))} options.setupHandlers Can be omitted by components whose focus
     *   classes need to be added and removed on focusin and focusout, respectively.  Components needing to add/remove those
     *   classes in response to other events should specify this parameter, which is called once, immediately.  See the examples.
     *
     * @example <caption>Opt into the highlight behavior, and specify a function to be called every time the classes are toggled:</caption>
     * var self = this;
     * this._focusable({
     *     'element': this.element,
     *     'applyHighlight': true,
     *     'afterToggle' : function() {
     *         self._toggleDefaultClasses();
     *     }
     * });
     *
     * @example <caption>Arrange for mouse movement to be considered <u>in addition to</u> mouse/finger up/down.
     *   Also supply a component-specific focusHighlightPolicy:</caption>
     * var self = this;
     * this._focusable({
     *     'element': someElement,
     *     'applyHighlight': true,
     *     'recentPointer' : function() {
     *         // A timestamp-based approach avoids the risk of getting stuck in an inaccessible
     *         // state if (say) mouseenter is not followed by mouseleave for some reason.
     *         var millisSincePointerMove = Date.now() - _myPointerMoveTimestamp;
     *         var isRecent = millisSincePointerMove < myThreshold;
     *         return isRecent;
     *     },
     *     'getFocusHighlightPolicy' : function() {
     *         // Return the value of a component-specific SASS $variable, component option, or other
     *         // component-specific mechanism, either "all", "none", or "nonPointer".  SASS variables
     *         // should be pulled into JS once statically on load, not per-instance or per-focus.
     *     }
     * });
     *
     * @example <caption>Add/remove the focus classes in response to events other than focusin/focusout:</caption>
     * var self = this;
     * this._focusable({
     *     'applyHighlight': myBooleanValue,
     *     'setupHandlers': function( focusInHandler, focusOutHandler) {
     *         self._on( self.element, {
     *             // This example uses focus/blur listeners, which don't bubble, rather than the
     *             // default focusin/focusout (which bubble).  This is useful when one focusable
     *             // element is a descendant of another.
     *             focus: function( event ) {
     *                 focusInHandler($( event.currentTarget ));
     *             },
     *             blur: function( event ) {
     *                 focusOutHandler($( event.currentTarget ));
     *             }
     *         });
     *     }
     * });
     *
     * @example <caption>Alternate usage of <code class="prettyprint">setupHandlers</code>, which simply stashes the
     *   handlers so they can be called from the component's existing handlers:</caption>
     * var self = this;
     * this._focusable({
     *     'applyHighlight': myBooleanValue,
     *     'setupHandlers': function( focusInHandler, focusOutHandler) {
     *         self._focusInHandler = focusInHandler;
     *         self._focusOutHandler = focusOutHandler;
     *     }
     * });
     */
    _focusable: function _focusable(options) {
      if (!$.isPlainObject(options)) {
        // eslint-disable-next-line no-param-reassign
        options = {
          element: options
        };
      } // eslint-disable-next-line no-param-reassign


      options.component = this;
      oj.DomUtils.makeFocusable(options);
    },

    /**
     * Remove all listener references that were attached to the element.
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    _UnregisterChildNode: function _UnregisterChildNode(element) {
      if (element) {
        $(element).off(this.eventNamespace);
        var bindings = this.bindings;

        if (bindings) {
          this.bindings = $(bindings.not(element));
        }
      }
    },

    /**
     * <p>Determines whether the component is LTR or RTL.
     *
     * <p>Component responsibilities:
     *
     * <ul>
     * <li>All components must determine directionality exclusively by calling this protected superclass method.
     *     (So that any future updates to the logic can be made in this one place.)</li>
     * <li>Components that need to know the directionality must call this method at create-time
     *     and from <code class="prettyprint">refresh()</code>, and cache the value.
     * <li>Components should not call this at other times, and should instead use the cached value.  (This avoids constant DOM
     *     queries, and avoids any future issues with component reparenting (i.e. popups) if support for directional islands is added.)</li>
     * </ul>
     *
     * <p>App responsibilities:
     *
     * <ul>
     * <li>The app specifies directionality by setting the HTML <code class="prettyprint">"dir"</code> attribute on the
     *     <code class="prettyprint">&lt;html></code> node.  When omitted, the default is <code class="prettyprint">"ltr"</code>.
     *     (Per-component directionality / directional islands are not currently supported due to inadequate CSS support.)</li>
     * <li>As with any DOM change, the app must <code class="prettyprint">refresh()</code> the component if the directionality changes dynamically.
     *   (This provides a hook for component housekeeping, and allows caching.)</li>
     * </ul>
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     * @return {string} the reading direction, either <code class="prettyprint">"ltr"</code> or <code class="prettyprint">"rtl"</code>
     * @default <code class="prettyprint">"ltr"</code>
     */
    _GetReadingDirection: function _GetReadingDirection() {
      return oj.DomUtils.getReadingDirection();
    },

    /**
     * <p>Notifies the component that its subtree has been connected to the document programmatically after the component has
     * been created.
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    _NotifyAttached: function _NotifyAttached() {
      this._propertyContext = null;
    },

    /**
     * <p>Notifies the component that its subtree has been removed from the document programmatically after the component has
     * been created.
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    _NotifyDetached: function _NotifyDetached() {
      this._propertyContext = null;

      this._removeStateClasses(this.widget());
    },

    /**
     * <p>Notifies the component that its subtree is initially visible after the component has
     * been created.
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    _NotifyInitShown: function _NotifyInitShown() {},

    /**
     * <p>Notifies the component that its subtree has been made visible programmatically after the component has
     * been created.
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    _NotifyShown: function _NotifyShown() {},

    /**
     * <p>Notifies the component that its subtree has been made hidden programmatically after the component has
     * been created.
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    _NotifyHidden: function _NotifyHidden() {},

    /**
     * <p>Determines whether this component is effectively disabled, i.e. it has its 'disabled' attribute set to true
     * or it has been disabled by its ancestor component.
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     * @return {boolean} true if the component has been effectively disabled, false otherwise
     */
    _IsEffectivelyDisabled: function _IsEffectivelyDisabled() {
      return !!(this.options.disabled || this._ancestorDisabled);
    },

    /**
     * <p>Sets the ancestor-provided disabled state on this component.
     *
     * @memberof oj.baseComponent
     * @instance
     * @private
     * @param {boolean} disabled - true if this component is being disabled by its ancestor component, false otherwise
     */
    __setAncestorComponentDisabled: function __setAncestorComponentDisabled(disabled) {
      this._ancestorDisabled = disabled;
    },

    /**
     * @memberof oj.baseComponent
     * @instance
     * @private
     */
    _getTranslationSectionLoader: function _getTranslationSectionLoader() {
      var sectionNames = [];
      var self = this;
      var index = 0;

      this._traverseWidgetHierarchy(function (proto) {
        // retrive translation section name for the widget and all of its ancestors
        // Since _GetTranslationsSectionName() is a protected method, we can only call it on the widget instance.
        // For superclases, we will assume that their section names can only be their full widget name
        var name = index === 0 ? self._GetTranslationsSectionName() : proto.widgetFullName;
        index += 1;
        var section = Translations.getComponentTranslations(name);

        if (section != null && !$.isEmptyObject(section)) {
          sectionNames.push(name);
        }
      });

      var count = sectionNames.length;

      if (count > 0) {
        return function () {
          // Optimize for the most common case where superclasses do not define translations
          if (count === 1) {
            return Translations.getComponentTranslations(sectionNames[0]);
          }

          var trs = {};

          for (var i = count - 1; i >= 0; i--) {
            $.widget.extend(trs, Translations.getComponentTranslations(sectionNames[i]));
          }

          return trs;
        };
      }

      return null;
    },

    /**
     * @memberof oj.baseComponent
     * @instance
     * @private
     */
    _getDynamicPropertyContext: function _getDynamicPropertyContext() {
      if (!this._propertyContext) {
        var c = {};
        this._propertyContext = c;
        var element = this.element[0];
        c.containers = _getSpecialContainerNames(element);
        c.element = element;
        c.isCustomElement = this._IsCustomElement();
        if (c.isCustomElement) c.customElement = this._getRootElement();
      }

      return this._propertyContext;
    },

    /**
     * @memberof oj.baseComponent
     * @instance
     * @private
     */
    _setupDefaultOptions: function _setupDefaultOptions(originalDefaults, constructorOptions) {
      var options = this.options; // Load component translations

      var translationLoader = this._getTranslationSectionLoader();

      var currVal = constructorOptions[_OJ_TRANSLATIONS_OPTION];

      if (translationLoader != null && (currVal === undefined || $.isPlainObject(currVal))) {
        _defineDynamicProperty(this, undefined, constructorOptions[_OJ_TRANSLATIONS_OPTION], options, _OJ_TRANSLATIONS_OPTION, translationLoader);
      } // Load options specified with oj.Components.setDefaultOptions()


      this._loadGlobalDefaultOptions(originalDefaults, constructorOptions);
    },

    /**
     * @memberof oj.baseComponent
     * @instance
     * @private
     */
    _loadGlobalDefaultOptions: function _loadGlobalDefaultOptions(originalDefaults, constructorOptions) {
      var options = this.options;
      var widgetHierNames = []; // walk up the widget hierarchy

      this._traverseWidgetHierarchy(function (proto) {
        widgetHierNames.push(proto.widgetName);
      });

      widgetHierNames.push('default'); // get properties applicable to this component

      var defaults = oj.Components.__getDefaultOptions(widgetHierNames);

      if ($.isEmptyObject(defaults)) {
        return;
      }

      var self = this;

      var contextCallback = function contextCallback() {
        return self._getDynamicPropertyContext();
      };

      var props = Object.keys(defaults);

      for (var i = 0; i < props.length; i++) {
        var prop = props[i];
        var val = constructorOptions[prop];

        if (val === undefined || $.isPlainObject(val)) {
          var defaultValueList = defaults[prop];

          if (defaultValueList) {
            var callback = _getCompoundDynamicGetter(defaultValueList);

            if (callback) {
              _defineDynamicProperty(this, originalDefaults[prop], val, options, prop, callback, contextCallback);
            } else {
              var list = [originalDefaults[prop]].concat(defaultValueList);
              list.push(val);
              options[prop] = _mergeOptionLayers(list);
            }
          }
        }
      }
    },

    /**
     * @memberof oj.baseComponent
     * @instance
     * @private
     */
    _traverseWidgetHierarchy: function _traverseWidgetHierarchy(callback) {
      var proto = this.constructor.prototype;

      while (proto != null && proto.namespace === 'oj') {
        callback(proto);
        proto = Object.getPrototypeOf(proto);
      }
    },

    /**
     * @memberof oj.baseComponent
     * @instance
     * @private
     */
    _getRootElement: function _getRootElement() {
      return this.OuterWrapper || this.element[0];
    },

    /**
     * Determines whether the component is being rendered as a custom element.
     * @return {boolean} True if the component is being rendered as a custom element
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    _IsCustomElement: function _IsCustomElement() {
      return oj.BaseCustomElementBridge.getRegistered(this._getRootElement().tagName) != null;
    },

    /**
     * Prepares a custom renderer context object for either the JQuery or custom element syntax,
     * removing and exposing keys as needed.
     * @param {Object} context The renderer context object.
     * @return {Object} The cleaned up renderer context.
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    _FixRendererContext: function _FixRendererContext(context) {
      if (this._IsCustomElement()) {
        // Do a shallow copy to avoid setter/getters from being lost
        var contextCopy = oj.CollectionUtils.copyInto({}, context); // remove component or widget constructor references and expose element reference instead

        delete contextCopy.component;
        contextCopy.componentElement = this._getRootElement();
        return contextCopy;
      }

      return context;
    },

    /**
     * Returns a wrapper function for custom elements that converts an object
     * returned by a custom renderer into an old format supported by widgets
     * @param {Function} origRenderer Renderer function called to create custom content
     * @return {Function} A wrapper function that will used to convert result into toolkit format
     * @protected
     * @memberof oj.baseComponent
     */
    _WrapCustomElementRenderer: function _WrapCustomElementRenderer(origRenderer) {
      if (this._IsCustomElement() && typeof origRenderer === 'function') {
        var customRenderer = function customRenderer(context) {
          var obj = origRenderer(context);
          return obj && obj.insert ? obj.insert : null;
        };

        return customRenderer;
      }

      return origRenderer;
    },

    /**
     * Stores a map of writeback options that we reference during option comparison.
     * Package private method called from the CustomElementBridge.
     * @param  {Object} options The writeback options map
     * @memberof oj.baseComponent
     * @instance
     * @private
     */
    __saveWritebackOptions: function __saveWritebackOptions(options) {
      this._writebackOptions = options;
    },

    /**
     * Returns true if an option should be written back.
     * @param  {string} option The option to lookup
     * @memberof oj.baseComponent
     * @instance
     * @private
     */
    _getWritebackOption: function _getWritebackOption(option) {
      if (this._writebackOptions && this._writebackOptions[option]) {
        return true;
      }

      return false;
    },

    /**
     * Called by oj.Components.subtreeAttached and will only call _NotifyAttached
     * for non custom elements. Custom elements are notified when they are
     * attached from the DOM so oj.Components.subtreeAttached is unnecessary.
     * @memberof oj.baseComponent
     * @instance
     * @private
     */
    __handleSubtreeAttached: function __handleSubtreeAttached() {
      if (!this._IsCustomElement()) {
        this._NotifyAttached();
      }
    },

    /**
     * Called by oj.Components.subtreeAttached and will only call _NotifyDetached
     * for non custom elements. Custom elements are notified when they are
     * detached from the DOM so oj.Components.subtreeDetached is unnecessary.
     * @memberof oj.baseComponent
     * @instance
     * @private
     */
    __handleSubtreeDetached: function __handleSubtreeDetached() {
      if (!this._IsCustomElement()) {
        this._NotifyDetached();
      }
    },

    /**
     * Whether special handling is needed for connected and disconnected ops
     * @return {boolean} returns true if the component wants to suppress disconnect and connect operations that happened
     *                   in quick succession, since they can be very expensive.  Returns false otherwise, which is the default.
     * @memberof oj.baseComponent
     * @protected
     */
    _VerifyConnectedForSetup: function _VerifyConnectedForSetup() {
      return false;
    },

    /**
     * Called by the CustomElementBridge when the custom element is attached
     * to the DOM.
     * @memberof oj.baseComponent
     * @instance
     * @private
     */
    __handleConnected: function __handleConnected() {
      this._NotifyAttached();

      if (!this.__delayConnectDisconnect(_STATE_CONNECTED)) {
        this._SetupResources();
      }
    },

    /**
     * Called by the CustomElementBridge when the custom element is detached
     * from the DOM.
     * @memberof oj.baseComponent
     * @instance
     * @private
     */
    __handleDisconnected: function __handleDisconnected() {
      // note that when it is delayed, then NotifyDetached would be called before ReleaseResources
      // this is fine for all the components that will use delayed disconnect, will need to re-visit if that is not the case.
      if (!this.__delayConnectDisconnect(_STATE_DISCONNECTED)) {
        this._ReleaseResources();
      }

      this._NotifyDetached();
    },

    /**
     * Delay the call to SetupResources and ReleaseResources as part of connected and disconnected.
     * See _verifyConnectedForSetup method for details.
     * @return {boolean} true if SetupResources/ReleaseResources has been delayed, false otherwise.
     * @memberof oj.baseComponent
     * @instance
     * @private
     */
    __delayConnectDisconnect: function __delayConnectDisconnect(state) {
      if (!this._VerifyConnectedForSetup()) {
        return false;
      }

      if (this.connectedState === undefined) {
        window.queueMicrotask(function () {
          if (this.connectedState === state) {
            if (state === _STATE_CONNECTED) {
              this._SetupResources();
            } else {
              this._ReleaseResources();
            }
          }

          this.connectedState = undefined;
        }.bind(this));
      }

      this.connectedState = state;
      return true;
    },

    /**
     * Method called by the CustomElementBridge to notify the component of changes to
     * any watched attributes registered in its metadata extension._WATCHED_ATTRS property.
     * @param {string} attr The name of the watched attribute
     * @param {string} oldValue The old attribute value
     * @param {string} newValue The new attribute value
     * @memberof oj.baseComponent
     * @instance
     * @private
     */
    __handleWatchedAttribute: function __handleWatchedAttribute(attr, oldValue, newValue) {
      this._WatchedAttributeChanged(attr, oldValue, newValue);
    },

    /**
     * Method for components to override in order to handle changes to watched attributes.
     * @param {string} attr The name of the watched attribute
     * @param {string} oldValue The old attribute value
     * @param {string} newValue The new attribute value
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    // eslint-disable-next-line no-unused-vars
    _WatchedAttributeChanged: function _WatchedAttributeChanged(attr, oldValue, newValue) {},

    /**
     * Method called by the CustomElementBridge to get the element to call focus on for this custom element
     * which can be the root custom element or an HTML element like an input or select.
     * @return {Element}
     * @memberof oj.baseComponent
     * @instance
     * @private
     */
    __getFocusElement: function __getFocusElement() {
      return this.GetFocusElement();
    },

    /**
     * Returns the current focusable element for this component which can be the root custom element
     * or an HTML element like an input or select.
     * @return {Element}
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    GetFocusElement: function GetFocusElement() {
      return this.element[0];
    }
    /**
     * Under normal circumstances this class is applied automatically. It is documented here for the rare cases that an app
     * developer needs per-instance control.
     *
     * <p>The <code class="prettyprint">oj-focus-highlight</code> class applies focus styling that may not be desirable when
     * the focus results from pointer interaction (touch or mouse), but which is needed for accessibility when the focus
     * occurs by a non-pointer mechanism, for example keyboard or initial page load.
     *
     * <p>The application-level behavior for this component is controlled in the theme by the
     * <code class="prettyprint">$focusHighlightPolicy</code> SASS variable; however, note that this same variable controls
     * the focus highlight policy of many components and patterns. The values for the variable are:
     *
     * <ul>
     *   <li><code class="prettyprint">nonPointer</code>: <code class="prettyprint">oj-focus-highlight</code> is applied only
     *       when focus is not the result of pointer interaction. Most themes default to this value.</li>
     *   <li><code class="prettyprint">all</code>: <code class="prettyprint">oj-focus-highlight</code> is applied regardless
     *       of the focus mechanism.</li>
     *   <li><code class="prettyprint">none</code>: <code class="prettyprint">oj-focus-highlight</code> is never applied. This
     *       behavior is not accessible, and is intended for use when the application wishes to use its own event listener to
     *       precisely control when the class is applied (see below). The application must ensure the accessibility of the result.</li>
     * </ul>
     *
     * <p>To change the behavior on a per-instance basis, the application can set the SASS variable as desired and then use
     * event listeners to toggle this class as needed.
     *
     * @ojfragment ojFocusHighlightDoc - For use in the Styling table of components using the oj-focus-highlight class with the
     *    $focusHighlightPolicy var.  Components using that class with a component-specific mechanism instead of that $var will need
     *    different verbiage, which could be decomped to another baseComponent fragment if shareable by multiple components.
     * @memberof oj.baseComponent
     */

  }); // Remove base component from the jQuery prototype, so it could not be created
  // directly by page authors

  delete $.fn[_BASE_COMPONENT];
})(); // end of BaseComponent wrapper function
// -----------------------------------------------------------------------------
// End of baseComponent, start of other content
// -----------------------------------------------------------------------------

/**
 * <p>This method is our version of $.widget, i.e. the static initializer of a component such as ojButton.
 * It calls that method, plus does any other static init we need.
 *
 * TODO:
 * - Consider moving this method into its own file.
 * - For base param, make the type oj.baseComponent rather than Object, but need to declare that as a type first.  Review how that's done.
 *
 * @private
 * @param {string} name typically of the form "oj.ojMenu"
 * @param {Object} base NOT optional (unlike JQUI)
 * @param {Object} prototype
 * @param {boolean=} isHidden - if true, indicates that the component name should not
 * be available on jQuery prototype
 */


oj.__registerWidget = function (name, base, prototype, isHidden) {
  $.widget(name, base, prototype);

  if (isHidden) {
    var globalName = name.split('.')[1];
    delete $.fn[globalName];
  } // create single-OJ pseudo-selector for component, e.g. ":oj-menu", in addition to the ":oj-ojMenu" that $.widget() creates.
  // for private components it will begin with an underscore, e.g.,  ":_oj-radio"


  if (name.substring(0, 5) === 'oj.oj' || name.substring(0, 6) === 'oj._oj') {
    var nameArray = name.split('.'); // ["oj", "ojMenu"], ["oj", "_ojRadio"]

    var namespace = nameArray[0]; // "oj"

    var simpleName = nameArray[1]; // "ojMenu", "_ojRadio"

    var fullName = namespace + '-' + simpleName; // "oj-ojMenu", "oj-_ojRadio"

    var isPrivate = simpleName.substring(0, 1) === '_'; // if private, make the single-oj pseudo-selector start with an underscore, like this -> "_oj-radio"

    var modifiedFullName; // "oj-Menu", "_oj-Radio".  Lowercased below.

    if (isPrivate) {
      modifiedFullName = '_' + namespace + '-' + simpleName.substring(3);
    } else {
      modifiedFullName = namespace + '-' + simpleName.substring(2);
    } // Capitalization doesn't seem to matter with JQ pseudos, e.g. for the existing double-oj pseudo, both $(":oj-ojMenu") and $(":oj-ojmenu") work.
    // So, follow JQUI's pattern of using toLowerCase here, which will lowercase not only the "M' in "Menu", but also any camelcased chars after that.


    $.expr.pseudos[modifiedFullName.toLowerCase()] = function (elem) {
      return !!$.data(elem, fullName);
    };
  }
};
/**
 * @param {Object} self
 * @param {Object|undefined} originalDefaultValue
 * @param {?Object} constructorValue
 * @param {!Object} options
 * @param {string} prop
 * @param {Function} getter
 * @param {Function=} contextCallback
 * @private
 */


function _defineDynamicProperty(self, originalDefaultValue, constructorValue, options, prop, getter, contextCallback) {
  var override = constructorValue;
  var replaced = false;
  var overriddenSubkeys = {}; // eslint-disable-next-line no-param-reassign

  delete options[prop];
  Object.defineProperty(options, prop, {
    get: function get() {
      // Once the option is replaced, we no longer merge in defaults
      if (replaced) {
        return override;
      }

      if (self._settingNestedKey != null) {
        // The getter is getting called from the option() method that will be mutating the current
        // object. We need to return only the override portion in this case to avoid the defaults being
        // reapplied as an override
        return override;
      }

      var defaultVal = getter(contextCallback ? contextCallback() : prop);
      return _mergeOptionLayers([originalDefaultValue, defaultVal, override], overriddenSubkeys);
    },
    set: function set(value) {
      override = value;

      if (self._settingNestedKey != null) {
        overriddenSubkeys[self._settingNestedKey] = true;
      } else {
        // The entire option has been replaced
        replaced = true;
      }
    },
    enumerable: true
  });
}
/**
 * @ignore
 */


function _getCompoundDynamicGetter(values) {
  if (values.length === 1) {
    var val = values[0];
    return val instanceof __ojDynamicGetter ? val.getCallback() : null;
  }

  var hasGetters = false;

  for (var i = 0; i < values.length && !hasGetters; i++) {
    var value = values[i];

    if (value != null && value instanceof __ojDynamicGetter) {
      hasGetters = true;
    }
  }

  if (hasGetters) {
    var getter = function getter(context) {
      var resolvedVals = [];
      values.forEach(function (_value) {
        if (_value != null && _value instanceof __ojDynamicGetter) {
          resolvedVals.push(_value.getCallback()(context));
        } else {
          resolvedVals.push(_value);
        }
      });
      return _mergeOptionLayers(resolvedVals);
    };

    return getter;
  }

  return null;
}
/**
 * @private
 */


function _getSpecialContainerNames(element) {
  var elem = element;
  var containers = [];

  while (elem) {
    var ga = elem.getAttribute;
    var name = ga ? ga.call(elem, oj.Components._OJ_CONTAINER_ATTR) : null;

    if (name != null) {
      containers.push(name);
    }

    elem = elem.parentNode;
  }

  return containers;
}
/**
 * @private
 */


function _storeWidgetName(element, widgetName) {
  var data = element.data(_OJ_WIDGET_NAMES_DATA);

  if (!data) {
    data = [];
    element.data(_OJ_WIDGET_NAMES_DATA, data);
  }

  if (data.indexOf(widgetName) < 0) {
    data.push(widgetName);
  }
}
/**
 * @private
 */


function _removeWidgetName(element, widgetName) {
  var data = element.data(_OJ_WIDGET_NAMES_DATA);

  if (data) {
    var index = data.indexOf(widgetName);

    if (index >= 0) {
      data.splice(index, 1);

      if (data.length === 0) {
        element.removeData(_OJ_WIDGET_NAMES_DATA);
      }
    }
  }
}
/**
 * @private
 * @param {Array} values - values to merge
 * @param {Object=} overriddenSubkeys subkeys where the merging should not occur, i.e.
 * the value from corresponsing subkey on the last element of values array should win
 */


function _mergeOptionLayers(values, overriddenSubkeys) {
  var result;

  for (var i = 0; i < values.length; i++) {
    var value = values[i];

    if (value !== undefined) {
      if ($.isPlainObject(value)) {
        var input = $.isPlainObject(result) ? [result, value] : [value]; // The last object (overrides) is always fully merged in

        result = _mergeObjectsWithExclusions({}, input, i === values.length - 1 ? null : overriddenSubkeys, null);
      } else {
        result = value;
      }
    }
  }

  return result;
}
/**
 * @private
 */


function _mergeObjectsWithExclusions(target, input, ignoreSubkeys, basePath) {
  var inputLength = input.length;

  for (var inputIndex = 0; inputIndex < inputLength; inputIndex++) {
    var source = input[inputIndex];
    var keys = Object.keys(source);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var path;

      if (ignoreSubkeys == null) {
        path = null;
      } else if (basePath == null) {
        path = key;
      } else {
        path = basePath + '.' + key;
      } // Ignore all sources when the current path is registered in ignoreSubkeys


      if (ignoreSubkeys == null || !ignoreSubkeys[path]) {
        var value = source[key];

        if (value !== undefined) {
          if ($.isPlainObject(value)) {
            var params = $.isPlainObject(target[key]) ? [target[key], value] : [value]; // eslint-disable-next-line no-param-reassign

            target[key] = _mergeObjectsWithExclusions({}, params, ignoreSubkeys, path);
          } else {
            // eslint-disable-next-line no-param-reassign
            target[key] = value;
          }
        }
      }
    }
  }

  return target;
}
/**
 * @private
 */


function _returnTrue() {
  return true;
}
/**
 * Returns an object with context for the given child DOM node. This will always contain the subid for the node,
 * defined as the 'subId' property on the context object. Additional component specific information may also be included.
 *
 * For more details on returned objects, see <a href="#contextobjects-section">context objects</a>.
 *
 * @ojfragment nodeContextDoc
 * @memberof oj.baseComponent
 */

/**
 * The child DOM node
 *
 * @ojfragment nodeContextParam
 * @memberof oj.baseComponent
 */

/**
 * The context for the DOM node, or <code class="prettyprint">null</code> when none is found.
 *
 * @ojfragment nodeContextReturn
 * @memberof oj.baseComponent
 */

/**
 * // Returns {'subId': 'oj-some-sub-id', 'componentSpecificProperty': someValue, ...}
 * var context = myComponent.getContextByNode(nodeInsideElement);
 *
 * @ojfragment nodeContextExample
 * @memberof oj.baseComponent
 */

/**
 * <p>The contextMenu slot is set on the <code class="prettyprint">oj-menu</code> within this element.
 * This is used to designate the JET Menu that this component should launch as a context menu on right-click, Shift-F10, Press & Hold, or component-specific gesture.
 * If specified, the browser's native context menu will be replaced by the JET Menu specified in this slot.
 * <p>
 * The application can register a listener for the Menu's ojBeforeOpen event. The listener can cancel the launch via event.preventDefault(),
 * or it can customize the menu contents by editing the menu DOM directly, and then calling refresh() on the Menu.
 * <p>
 * To help determine whether it's appropriate to cancel the launch or customize the menu, the ojBeforeOpen listener can use component API's to determine which
 * table cell, chart item, etc., is the target of the context menu. See the JSDoc of the individual components for details.
 * <p>
 * Keep in mind that any such logic must work whether the context menu was launched via right-click, Shift-F10, Press & Hold, or component-specific touch gesture.
 *
 * @ojslot contextMenu
 * @memberof oj.baseComponent
 *
 * @ojshortdesc The contextMenu slot is set on the oj-menu instance within this element.  It designates the JET Menu to launch as a context menu.
 * @ojmaxitems 1
 *
 * @example <caption>Initialize the component with a context menu:</caption>
 * &lt;oj-some-element>
 *     &lt;-- use the contextMenu slot to designate this as the context menu for this component -->
 *     &lt;oj-menu slot="contextMenu" style="display:none" aria-label="Some element's context menu">
 * ...
 *     &lt;/oj-menu>
 * &lt;/oj-some-element>
 */

/**
 * Sets a property or a subproperty (of a complex property) and notifies the component
 * of the change, triggering a [property]Changed event.
 * The value should be of the same type as the type of the attribute mentioned in this API document.
 *
 * @function setProperty
 * @since 4.0.0
 * @param {string} property - The property name to set. Supports dot notation for subproperty access.
 * @param {any} value - The new value to set the property to.
 * @return {void}
 *
 * @expose
 * @memberof oj.baseComponent
 * @ojshortdesc Sets a property or a single subproperty for complex properties and notifies the component of the change, triggering a corresponding event.
 * @instance
 *
 * @ojtsexample <caption>Set a single subproperty of a complex property:</caption>
 * myComponent.setProperty('complexProperty.subProperty1.subProperty2', "someValue");
 */

/**
 * Retrieves the value of a property or a subproperty.
 * The return type will be the same as the type of the property as specified in this API document.
 * If the method is invoked with an incorrect property/subproperty name, it returns undefined.
 * @function getProperty
 * @since 4.0.0
 * @param {string} property - The property name to get. Supports dot notation for subproperty access.
 * @return {any}
 *
 * @expose
 * @memberof oj.baseComponent
 * @ojshortdesc Retrieves the value of a property or a subproperty.
 * @instance
 *
 * @ojtsexample <caption>Get a single subproperty of a complex property:</caption>
 * let subpropValue = myComponent.getProperty('complexProperty.subProperty1.subProperty2');
 */

/**
 * Performs a batch set of properties.
 * The type of value for each property being set must match the type of the property as specified in this
 * API document.
 * @function setProperties
 * @since 4.0.0
 * @param {Object} properties - An object containing the property and value pairs to set.
 * @return {void}
 *
 * @expose
 * @memberof oj.baseComponent
 * @ojshortdesc Performs a batch set of properties.
 * @instance
 *
 * @ojtsexample <caption>Set a batch of properties:</caption>
 * myComponent.setProperties({"prop1": "value1", "prop2.subprop": "value2", "prop3": "value3"});
 */



/* global Message:false */

/**
 * This picks a strategy for where to put each piece of information
 * that is on a component. It started out being messaging pieces: like
 * placeholder, converter hints, validator hints, error messages. In v8.0
 * we added labelEdge which could be top or inside the text field or inside
 * a non-text-field (like a radioset).
 * @param {Object} component instance
 * @protected
 * @constructor
 * @since 0.6.0
 * @ignore
 */
oj.ComponentMessaging = function (component) {
  this.Init(component);
}; // Subclass from oj.Object


oj.Object.createSubclass(oj.ComponentMessaging, oj.Object, 'oj.ComponentMessaging');
/**
 * Default strategy types supported for component messaging.
 * Think of these as places in the dom you want things.
 * Labels are the only things you put into the 'label-edge' positions,
 * so you will have only one of these at a time.
 * @memberof! oj.ComponentMessaging
 * @const
 * @protected
 * @ignore
 */

oj.ComponentMessaging._STRATEGY_TYPE = {
  NONE: 'none',
  NOTEWINDOW: 'notewindow',
  PLACEHOLDER: 'placeholder',
  INLINE: 'inline',
  LABEL_EDGE_INSIDE: 'inside',
  LABEL_EDGE_INSIDE_FORM_CNTRL: 'insideformcontrol',
  USER_ASSISTANCE_INLINE: 'userassistanceinline'
};
/**
 * Tracks the messaging strategy callback function by type, used to instantiate messaging strategies.
 * Implementations register by type.
 * @memberof! oj.ComponentMessaging
 * @const
 * @protected
 * @ignore
 */

oj.ComponentMessaging._STRATEGY_TYPE_TO_CALLBACK = {};
/**
 * Stores the constructor function callback object used to constuct a strategy object for the
 * specified type.
 *
 * @param {string} type
 * @param {Function} strategyConstructorCallback a constructor callback that can be used to constuct
 * a strategy object for the specified type
 * @ignore
 */

oj.ComponentMessaging.registerMessagingStrategy = function (type, strategyConstructorCallback) {
  if (type && typeof strategyConstructorCallback === 'function') {
    oj.ComponentMessaging._STRATEGY_TYPE_TO_CALLBACK[type] = strategyConstructorCallback;
  }
};
/**
 * Initializes the strategy based on the display options that specify the messaging artifacts that
 * will be displayed by this strategy.
 *
 * @param {Object} component widget instance
 * @memberof! oj.ComponentMessaging
 * @instance
 * @protected
 */


oj.ComponentMessaging.prototype.Init = function (component) {
  oj.ComponentMessaging.superclass.Init.call(this);
  this._component = component;
  this._activated = false; // sets up this._strategies, which is a list of what we will display in each type of
  // displayOption. E.g., 'inline': 'messages', 'notewindow': converterHint, validatorHint, etc.
  // See EditableValues displayOption attribute jsdoc for more details.

  this._initializeMessagingStrategies();
};
/**
 * Utility function that activates messaging on the component using the strategy provided.
 * @param {Object} launcher element(s) to which messaging applies
 * @param {Object} content
 * @private
 */


oj.ComponentMessaging.prototype.activate = function (launcher, contentElement, content) {
  var that = this;
  oj.Assert.assertObject(content);
  this._launcher = launcher;
  this._contentElement = contentElement;
  this._messagingContent = oj.CollectionUtils.copyInto(this._messagingContent || {}, content); // if already active, reinitialize strategies based on new messagingDisplay
  // and labelEdge preferences.

  if (!this._isActive()) {
    // for each 'messaging strategy' (e.g., inline == InlineMessagingStrategy,
    // notewindow == PopupMessagingStrategy, etc), call .activate which initializes
    // the strategy.
    $.each(this._strategies, function (i, strategy) {
      strategy.activate(that);
    });
    this._activated = true;
  } else {
    this._reactivate();
  }
};
/**
 * Utility function that updates messaging on the component for the content provided, using the
 * strategies.
 *
 * @param {Object} content
 * @private
 */
// TODO: component messaging could take the component instance


oj.ComponentMessaging.prototype.update = function (content) {
  oj.Assert.assertObject(content);
  oj.Assert.assertBoolean(this._activated);
  this._messagingContent = oj.CollectionUtils.copyInto(this._messagingContent || {}, content);

  if (this._activated) {
    $.each(this._strategies, function (i, strategy) {
      if (strategy.shouldUpdate(content)) {
        strategy.update();
      }
    });
  }
};
/**
 * Utility function that deactivates messaging on the component using the strategy provided.
 * @private
 */


oj.ComponentMessaging.prototype.deactivate = function () {
  $.each(this._strategies, function (i, strategy) {
    strategy.deactivate();
  });
  this._activated = false;
  this._component = null;
  this._launcher = null;
  this._contentElement = null;
  this._strategies = {};
};
/**
 * Utility function that closes anything that needs to be closed when oj.Components.subtreeHidden
 * is called. e.g, popup.
 * @private
 */


oj.ComponentMessaging.prototype.close = function () {
  if (this._activated) {
    $.each(this._strategies, function (i, strategy) {
      strategy.close();
    });
  }
};
/**
 * Creates a messaging strategy for the specified type, initializing it with the options provided.
 * @param {string|number} type defined by oj.ComponentMessaging._STRATEGY_TYPE. For example,
 * a strategyType of 'notewindow' creates a PopupComponentMessaging strategy. See
 * registerMessagingStrategy where we register the type and the callback to call for a given type.
 * We currently have PopupMessagingStrategy, DefaultMessagingStrategy, PlaceholderMessagingStrategy,
 * and InlineComponentStrategy.
 * e.g., In PopupComponentMessaging.js:
 *  oj.ComponentMessaging.registerMessagingStrategy(oj.ComponentMessaging._STRATEGY_TYPE.NOTEWINDOW,
 *                              oj.PopupMessagingStrategy
 * @param {Array.<string>|undefined} artifactsForType (e.g., 'messages', 'helpInstruction', 'validatorHints')
 *
 * @private
 * @instance
 * @memberof !oj.ComponentMessaging
 */


oj.ComponentMessaging.prototype._createMessagingStrategy = function (type, artifactsForType) {
  var Callback = oj.ComponentMessaging._STRATEGY_TYPE_TO_CALLBACK[type] || oj.ComponentMessaging._STRATEGY_TYPE_TO_CALLBACK[oj.ComponentMessaging._STRATEGY_TYPE.NONE]; // dynamically instantiate the strategy objects.

  return new Callback(artifactsForType);
};
/**
 * Returns the component instance or null
 *
 * @return {Object|null}
 * @private
 * @instance
 * @memberof !oj.ComponentMessaging
 */


oj.ComponentMessaging.prototype._getComponent = function () {
  return this._component || null;
};
/**
 * Returns the launcher jquery element. This is the element on the component to which messaging
 * applies.
 *
 * @return {Object|null} null if messaging is not activated.
 * @private
 * @instance
 * @memberof !oj.ComponentMessaging
 */


oj.ComponentMessaging.prototype._getLauncher = function () {
  return this._launcher || null;
};
/**
 * Returns the jquery element on the component to which aria-invalid
 * applies. This is either the launcher itself or the inputs
 * within the launcher dom.  JAWS only reads aria-invalid when it is on the input/textara/select.
 * <p>
 * In the case of radioset/checkboxset, for example, where the launcher
 * is the root dom element and the inputs are with it, we return the inputs.
 *
 * </p>
 *
 * @return {Object|null} null if launcher is null
 * @private
 * @instance
 * @memberof !oj.ComponentMessaging
 */


oj.ComponentMessaging.prototype._getContentElement = function () {
  return this._contentElement || null;
};
/**
 * Returns the last saved messagingContent object.
 *
 * @return {Object}
 * @private
 * @instance
 * @memberof !oj.ComponentMessaging
 */


oj.ComponentMessaging.prototype._getMessagingContent = function () {
  return this._messagingContent || {};
};
/**
 * Useful for on-demand messaging content, like validation hints.
 *
 * @param {Object} content
 * @private
 * @memberof !oj.ComponentMessaging
 */


oj.ComponentMessaging.prototype._setMessagingContent = function (content) {
  oj.Assert.assertObject(content);
  this._messagingContent = oj.CollectionUtils.copyInto(this._messagingContent || {}, content);
};
/**
 * Whether the component messaging is activated.
 * @return {boolean}
 * @private
 */


oj.ComponentMessaging.prototype._isActive = function () {
  return this._activated;
};
/**
 * Returns a key/value array: strategyTypes -> array of artifacts using that strategyType.
 * where artifacts is 'messages', 'converterHint', 'validatorHint', 'helpInstruction';
 * e.g.,
 * strategyToArtifacts[oj.ComponentMessaging._STRATEGY_TYPE.NOTEWINDOW] = ['messages', 'converterHints']
 * strategyToArtifacts[oj.ComponentMessaging._STRATEGY_TYPE.NONE] = ['validatorHints']
 * The types of messaging content for which displayOptions can be configured include
 * messages, converterHint, validatorHint and helpInstruction.
 * The displayOptions for each type is specified either as an array of strings or a string.
 * When an array is specified the first display option takes precedence over the second and so on,
 * so we will only have ONE display type per artifact.
 */


oj.ComponentMessaging.prototype._getResolvedMessagingDisplayOptions = function (messagingPreferences) {
  var strategyToArtifacts = {};
  var artifactStrategyTypeResolved = false;
  var options = this._component.options;
  var $messagingPreferences = {};
  var self = this; // first resolve primary display options for each artifact.
  // E.g. at the end of this loop you should have something like this
  // {messages: 'notewindow', converterHint: 'placeholder', validatorHint: 'notewindow', helpInstruction: 'none'}

  var keys = Object.keys(messagingPreferences);

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var strategyTypes = messagingPreferences[key]; // loop over array of strategyTypes preferred for artifact.
    // artifacts are 'messages', 'converterHint', 'validatorHint', 'helpInstruction'

    artifactStrategyTypeResolved = false;
    var artifact = key + ''; // we take either array or string values for displayOptions.

    if (Array.isArray(strategyTypes)) {
      for (var j = 0; j < strategyTypes.length; j++) {
        var strategyType = strategyTypes[j];

        if (!artifactStrategyTypeResolved) {
          artifactStrategyTypeResolved = self._resolveStrategyTypeForArtifact(artifact, strategyType, options, $messagingPreferences);
        }
      }
    } else if (typeof strategyTypes === 'string') {
      if (!artifactStrategyTypeResolved) {
        artifactStrategyTypeResolved = self._resolveStrategyTypeForArtifact(artifact, strategyTypes, options, $messagingPreferences);
      }
    } // if we couldn't resolve then use "none". E.g., validationHint: ['none']


    if (!artifactStrategyTypeResolved) {
      $messagingPreferences[artifact] = oj.ComponentMessaging._STRATEGY_TYPE.NONE;
    }
  } // update the label creation strategy
  // at this point, $messagingPreferences may have an Object like:
  // {converterHint:'notewindow',
  // helpInstruction:'notewindow', messages:'inline', validatorHint:'notewindow}
  // After the call to _addLabelStrategy, it might be added
  // labelEdge:'top'


  self._addLabelStrategy($messagingPreferences); // collate by strategyType -> artifact. but first reset


  $.each(oj.ComponentMessaging._STRATEGY_TYPE, function (type, name) {
    strategyToArtifacts[name] = [];
  });
  $.each($messagingPreferences, function (_artifact, _strategyType) {
    // an artifact eventually resolves to one strategyType.
    strategyToArtifacts[_strategyType].push(_artifact);
  }); // The keys to the object is the DisplayType, like inline, inside,
  // insideFormControl, none, notewindow, placeholder.
  // The artifacts are things like converterHint, label.

  return strategyToArtifacts;
};
/**
 * This function is used when the component's user assistance option should be used.
 * The component.display-options is used only to see if 'none' is specified.
 * display-options is ignored otherwise for the Redwood theme (via a theming variable).
 *
 * This function returns a key/value array: strategyTypes -> array of artifacts
 * using that strategyType. where artifacts is
 * 'messages', 'converterHint', 'validatorHint', 'helpInstruction';
 * e.g., {userAssistanceInline: ['messages', 'helpInstruction'],
 *        none: ['validationHint']
 * Note: the only strategies for inline are userAssistanceInline and none (and the label strategies)
 * The types of messaging content that can be configured include
 * messages, converterHint, validatorHint and helpInstruction.
 */


oj.ComponentMessaging.prototype._getUserAssistanceStrategyToArtifactsObj = function () {
  var strategyToArtifacts = {};
  var options = this._component.options;
  var componentDisplayOptions = options.displayOptions || {};
  var artifactPiecesToStrategyObj = {};
  var self = this; // componentDisplayOptions will be an Object like this:
  // {messages:['inline'], converterHint:['placeholder','notewindow'],
  // validatorHint:['notewindow], helpInstruction:['notewindow']
  // If we are looking at the user-assistance-density attribute on the component,
  // then all we care about from the displayOptions attribute is whether or not there
  // is a 'none' for any of these 'artifacts'. Like, is validatorHint:'none'? If so, do not
  // render the validatorHint. Otherwise render it how the user-assistance-density says to.
  //
  // first resolve primary display options for each artifact.
  // E.g. at the end of this loop you should have something like this
  // {messages: 'userassistanceinline', validatorHint:
  // 'userassistanceinline', helpInstruction: 'none'}

  var keys = Object.keys(componentDisplayOptions);

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var strategyTypes = componentDisplayOptions[key]; // loop over array of strategyTypes preferred for artifact.
    // artifacts are 'messages', 'converterHint', 'validatorHint', 'helpInstruction'

    var artifact = key + ''; // we only look at 'string' for 'none'.

    if (typeof strategyTypes === 'string' && strategyTypes === 'none') {
      artifactPiecesToStrategyObj[artifact] = oj.ComponentMessaging._STRATEGY_TYPE.NONE;
    } else {
      // put it in the user assistance inline
      artifactPiecesToStrategyObj[artifact] = oj.ComponentMessaging._STRATEGY_TYPE.USER_ASSISTANCE_INLINE;
    }
  } // update the label creation strategy
  // at this point, artifactPiecesToStrategyObj may have an Object like:
  // {converterHint:'none',
  // helpInstruction:'userassistanceinline', messages:'userassistanceinline', validatorHint:'none'}
  // After the call to _addLabelStrategy, it might be added
  // labelEdge:'top'


  self._addLabelStrategy(artifactPiecesToStrategyObj); // collate by strategyType -> artifact. but first reset


  Object.keys(oj.ComponentMessaging._STRATEGY_TYPE).forEach(function (key) {
    var value = oj.ComponentMessaging._STRATEGY_TYPE[key];
    strategyToArtifacts[value] = [];
  });
  Object.keys(artifactPiecesToStrategyObj).forEach(function (key) {
    var _strategyType = artifactPiecesToStrategyObj[key];

    strategyToArtifacts[_strategyType].push(key);
  }); // This returns an Object with all the StrategyTypes as keys and the
  // 'artifacts' as values, like {none:['validationHint'], 'userAssistanceInline':['messages', 'helpInstruction']
  // inside:['labelEdge']}

  return strategyToArtifacts;
}; // Note:
// Each LabelStrategy is self-registering., e.g., InsideFormControlLabelStrategy registers itself
// by calling oj.ComponentMessaging.registerMessagingStrategy.
// this adds the label strategy for the component by the same type.


oj.ComponentMessaging.prototype._addLabelStrategy = function ($messagingPreferences) {
  var self = this;
  var artifactKey = 'labelEdge'; // The strategyTypeLabelEdge will be one of these: oj.ComponentMessaging._STRATEGY_TYPE.LABEL_EDGE*

  var strategyTypeLabelEdge = this._component._ResolveLabelEdgeStrategyType();

  var artifactStrategyTypeResolved = self._resolveStrategyTypeForArtifact(artifactKey, strategyTypeLabelEdge, this._component.options, $messagingPreferences);

  if (!artifactStrategyTypeResolved) {
    // eslint-disable-next-line no-param-reassign
    $messagingPreferences[artifactKey] = oj.ComponentMessaging._STRATEGY_TYPE.NONE;
  }
};

oj.ComponentMessaging.prototype._resolveStrategyTypeForArtifact = function (artifact, strategyType, options, $messagingPreferences) {
  var artifactStrategyTypeResolved = false;
  var compPH = options.placeholder;

  switch (strategyType) {
    // placeholder display is special in that it's only supported on 'converterHint'.
    case oj.ComponentMessaging._STRATEGY_TYPE.PLACEHOLDER:
      if (artifact === 'converterHint') {
        // if placeholder is the first preference for converterHint, it's used under certain
        // conditions
        // if options.placeholder is not set then use 'converterHint' as the default
        // 'placeholder'
        // alternately if (options.placeholder), i.e., a custom placeholder is set, then
        // ignore the placeholder strategyType and use the next display type as the default
        // for the artifact. We may have a fallback strategyType in which case we use it,
        // otherwise we use 'none'. E.g.,
        // {'converterHint': ['placeholder', 'notewindow']} // use notewindow
        // {'converterHint': ['placeholder']}               // use none
        if (!artifactStrategyTypeResolved) {
          if (!compPH) {
            // eslint-disable-next-line no-param-reassign
            $messagingPreferences[artifact] = strategyType;
            artifactStrategyTypeResolved = true;
          }
        }
      } else {// strategyType 'placeholder' is not supported on other artifacts
        // ignore if present
        // TODO: In the future we may want to support configuring validatorHint ot helpInstruction as
        // placeholder as well.
      }

      break;
    // inline display is special in that it's only supported on 'messages'.

    case oj.ComponentMessaging._STRATEGY_TYPE.INLINE:
      if (artifact === 'messages') {
        if (!artifactStrategyTypeResolved) {
          // eslint-disable-next-line no-param-reassign
          $messagingPreferences[artifact] = strategyType;
          artifactStrategyTypeResolved = true;
        }
      } else {// strategyType 'inline' is not supported on other artifacts
        // ignore if present
      }

      break;

    case oj.ComponentMessaging._STRATEGY_TYPE.LABEL_EDGE_INSIDE:
    case oj.ComponentMessaging._STRATEGY_TYPE.LABEL_EDGE_INSIDE_FORM_CNTRL:
      if (artifact === 'labelEdge' && !artifactStrategyTypeResolved && !oj.StringUtils.isEmptyOrUndefined(options.labelHint)) {
        // eslint-disable-next-line no-param-reassign
        $messagingPreferences[artifact] = strategyType;
        artifactStrategyTypeResolved = true;
      }

      break;

    default:
      if (!artifactStrategyTypeResolved && artifact !== 'labelEdge') {
        // eslint-disable-next-line no-param-reassign
        $messagingPreferences[artifact] = strategyType;
        artifactStrategyTypeResolved = true;
      }

      break;
  }

  return artifactStrategyTypeResolved;
};
/**
 * Creates messaging strategies for the component.
 * As of v9.0 form components have a user-assistance-density attribute in addition
 * to the existing display-options. For Redwood UX we look at the user-assistance-density
 * which is efficient or compact and the app will have all its 'user assistance' (i.e., help instruction,
 * hint, messages) inline, or if compact it is in popups.
 * For bw compatibility/Alta we continue to look at display-options
 * like display-options.help-instruction that could be notewindow,
 * and for display-options.messages that could be inline, etc.
 * BOTH will look at display-options for validationHint/messages for 'none'
 * because we still want to be able to turn these off.
 * @private
 */


oj.ComponentMessaging.prototype._initializeMessagingStrategies = function () {
  var strategyToArtifacts = this._strategyToArtifacts();

  var displayInNoteWindow = strategyToArtifacts[oj.ComponentMessaging._STRATEGY_TYPE.NOTEWINDOW];
  var displayNone = strategyToArtifacts[oj.ComponentMessaging._STRATEGY_TYPE.NONE];
  var displayInPlaceholder = strategyToArtifacts[oj.ComponentMessaging._STRATEGY_TYPE.PLACEHOLDER];
  var displayInline = strategyToArtifacts[oj.ComponentMessaging._STRATEGY_TYPE.INLINE]; // these are input components

  var displayLabelEdgeInsideTextField = strategyToArtifacts[oj.ComponentMessaging._STRATEGY_TYPE.LABEL_EDGE_INSIDE]; // these are form controls that aren't inputs, like radioset

  var displayLabelEdgeInsideFormControl = strategyToArtifacts[oj.ComponentMessaging._STRATEGY_TYPE.LABEL_EDGE_INSIDE_FORM_CNTRL]; // these are for user assistance inline that is used in the Redwood theme

  var displayUserAssistanceInline = strategyToArtifacts[oj.ComponentMessaging._STRATEGY_TYPE.USER_ASSISTANCE_INLINE];
  var messagingStrategies = {};

  if (displayInNoteWindow.length > 0) {
    // displayInNoteWindow is an array of the artifacts that want to be displayed in the note window
    // e.g., 'messages', 'converterHints', etc.
    messagingStrategies[oj.ComponentMessaging._STRATEGY_TYPE.NOTEWINDOW] = this._createMessagingStrategy(oj.ComponentMessaging._STRATEGY_TYPE.NOTEWINDOW, displayInNoteWindow);
  }

  if (displayInPlaceholder.length > 0 && displayLabelEdgeInsideTextField.length === 0) {
    // displayInPlaceholder is an array of the artifacts that want to be displayed in placeholder
    // e.g., 'converterHints'
    messagingStrategies[oj.ComponentMessaging._STRATEGY_TYPE.PLACEHOLDER] = this._createMessagingStrategy(oj.ComponentMessaging._STRATEGY_TYPE.PLACEHOLDER, displayInPlaceholder);
  }

  if (displayInline.length > 0) {
    // displayInline is an array of the artifacts that want to be displayed in inline
    // e.g., 'messages'
    messagingStrategies[oj.ComponentMessaging._STRATEGY_TYPE.INLINE] = this._createMessagingStrategy(oj.ComponentMessaging._STRATEGY_TYPE.INLINE, displayInline);
  }

  if (displayUserAssistanceInline.length > 0) {
    messagingStrategies[oj.ComponentMessaging._STRATEGY_TYPE.USER_ASSISTANCE_INLINE] = this._createMessagingStrategy(oj.ComponentMessaging._STRATEGY_TYPE.USER_ASSISTANCE_INLINE, displayUserAssistanceInline);
  } // Create one of these strategies for whatever labelEdge we are using currently


  if (displayLabelEdgeInsideTextField.length > 0) {
    messagingStrategies[oj.ComponentMessaging._STRATEGY_TYPE.LABEL_EDGE_INSIDE] = this._createMessagingStrategy(oj.ComponentMessaging._STRATEGY_TYPE.LABEL_EDGE_INSIDE, displayLabelEdgeInsideTextField);
  } else if (displayLabelEdgeInsideFormControl.length > 0) {
    messagingStrategies[oj.ComponentMessaging._STRATEGY_TYPE.LABEL_EDGE_INSIDE_FORM_CNTRL] = this._createMessagingStrategy(oj.ComponentMessaging._STRATEGY_TYPE.LABEL_EDGE_INSIDE_FORM_CNTRL, displayLabelEdgeInsideFormControl);
  }

  messagingStrategies[oj.ComponentMessaging._STRATEGY_TYPE.NONE] = this._createMessagingStrategy(oj.ComponentMessaging._STRATEGY_TYPE.NONE, displayNone);
  this._strategies = messagingStrategies;
};
/**
 * Reinitializes component messaging.
 *
 * @private
 */


oj.ComponentMessaging.prototype._reactivate = function () {
  var strategyToArtifacts = this._strategyToArtifacts();

  var strategy;
  var cm = this; // for every strategyType being requested either create the messaging strategy for the type or
  // reuse existing strategy if it has already been created.

  $.each(strategyToArtifacts, function (type, artifactsForType) {
    // eslint-disable-next-line no-param-reassign
    type += ''; // coerce to avoid GCC warning

    strategy = cm._strategies[type];

    if (artifactsForType && artifactsForType.length > 0) {
      if (!strategy) {
        // create a strategy if one doesn't exist for the type
        strategy = cm._createMessagingStrategy(type, artifactsForType);
        cm._strategies[type] = strategy;
        strategy.activate(cm);
      } else if (strategy) {
        // update strategy with the latest displayOptions if already present. we don;t
        // want to remove it once activated.
        strategy.reactivate(artifactsForType);
      }
    } else if (strategy && oj.ComponentMessaging._STRATEGY_TYPE.NONE !== type) {
      // if we have no artifacts to show for a type, then remove the strategy.
      // only if its other than the DefaultMessagingStrategy as it's always needed to theme
      // component.
      strategy.deactivate();
      delete cm._strategies[type];
    }
  });
};
/**
 * get strategy to artifacts
 * we do different things depending on whether we are using displayOptions
 * or the user-assistance-density attribute.
 *
 * @private
 */


oj.ComponentMessaging.prototype._strategyToArtifacts = function () {
  var strategyToArtifacts;

  var resolvedUserAssistance = this._component._getResolvedUserAssistance();

  if (resolvedUserAssistance !== 'compact' && resolvedUserAssistance !== 'displayOptions') {
    strategyToArtifacts = this._getUserAssistanceStrategyToArtifactsObj();
  } else {
    var options = this._component.options;
    var messagingPreferences = options.displayOptions || {};

    if (resolvedUserAssistance === 'compact') {
      // for 'compact' set displayOptions.messages to notewindow.
      messagingPreferences.messages = 'notewindow';
      strategyToArtifacts = this._getResolvedMessagingDisplayOptions(messagingPreferences);
    } else {
      strategyToArtifacts = this._getResolvedMessagingDisplayOptions(messagingPreferences);
    }
  }

  return strategyToArtifacts;
};
/**
 * A base messaging strategy class that is initialized with a set of displayOptions. This object
 * also provides helper methods for its subclasses.
 *
 * @param {Array.<string>} displayOptions an array of messaging artifacts displayed.
 *
 * @constructor
 * @class oj.MessagingStrategy
 * @private
 */


oj.MessagingStrategy = function (displayOptions) {
  this.Init(displayOptions);
}; // Subclass from oj.Object


oj.Object.createSubclass(oj.MessagingStrategy, oj.Object, 'oj.MessagingStrategy');
/**
 * Initializes the strategy based on the display options that specify the messaging artifacts that
 * will be displayed by this strategy.
 *
 * @param {Array.<string>} displayOptions an array of messaging artifacts displayed.
 * @private
 */

oj.MessagingStrategy.prototype.Init = function (displayOptions) {
  oj.Assert.assertArray(displayOptions);
  oj.MessagingStrategy.superclass.Init.call(this);
  this._displayOptions = displayOptions;
};

oj.MessagingStrategy.prototype.activate = function (cm) {
  this._componentMessaging = cm;
};
/**
 * Cleans up messaging artifacts that were created on the component instance. E.g., destroys any
 * widgets it created, removes styles added etc.
 *
 * @private
 */


oj.MessagingStrategy.prototype.deactivate = function () {};
/**
 * Utility function that closes anything that needs to be closed when oj.Components.subtreeHidden
 * is called. e.g, popup.
 *
 * @private
 */


oj.MessagingStrategy.prototype.close = function () {};
/**
 * Reinitializes with the new display options and updates component messaging using the new content.
 *
 * @param {Array.<string>} newDisplayOptions
 * @private
 */


oj.MessagingStrategy.prototype.reactivate = function (newDisplayOptions) {
  this.Init(newDisplayOptions);
};
/**
 * Returns true always. Subclasses can override to ignore updates.
 *
 * @param {Object=} content the messaging content that is being updated
 * @return {boolean}
 *
 * @private
 */
// eslint-disable-next-line no-unused-vars


oj.MessagingStrategy.prototype.shouldUpdate = function (content) {
  return true;
};
/**
 * Updates component with instance using the content provided.
 *
 * @private
 */


oj.MessagingStrategy.prototype.update = function () {}; // P R O T E C T E D  M E T H O D S

/**
 * Gets the launcher element for which the messaging is applied.
 * @return {Object} the jquery element of the form element.
 * @private
 */


oj.MessagingStrategy.prototype.GetLauncher = function () {
  return this._componentMessaging._getLauncher();
};
/**
 * @return {Object} the jquery element of the form element.
 * @private
 */


oj.MessagingStrategy.prototype.GetContentElement = function () {
  return this._componentMessaging._getContentElement();
};
/**
 * Gets the component (widget).
 * @return {Object} the jet component instance
 * @private
 */


oj.MessagingStrategy.prototype.GetComponent = function () {
  return this._componentMessaging._getComponent();
};
/**
 * This is simply a flag.
 * Set to true when we get the validator hints from the component the first time.
 * Then use getHasValidatorHints to check if it is true. If so we
 * know we've already gotten the validator hints the first time and
 * won't get them from the component again.
 * @param {boolean} hasValidatorHints true if we have the validator hints
 * @private
 */


oj.MessagingStrategy.prototype.setHasValidatorHints = function (hasValidatorHints) {
  this._hasValidatorHints = hasValidatorHints;
};
/**
 * If true, it means we have already retrieved the validator hints from the
 * component.
 * @private
 * @return {boolean} true if we already have the validator hints, else false
 */


oj.MessagingStrategy.prototype.getHasValidatorHints = function () {
  return this._hasValidatorHints === true;
};
/**
 * Generates a unique id if the element doesn't have one already assigned.
 * @param {Element} element requiring an id
 * @private
 */


oj.MessagingStrategy.prototype.GenerateIdIfNeeded = function (element) {
  if (isNaN(oj.MessagingStrategy._uidCounter)) {
    oj.MessagingStrategy._uidCounter = 0;
  }

  var e = element;

  if (!e.id) {
    e.id = 'ojms_' + oj.MessagingStrategy._uidCounter;
    oj.MessagingStrategy._uidCounter += 1;
  }
};
/**
 * Returns an array of messages.
 *
 * @return {Array} of messages each an instance of oj.Message
 * @private
 */


oj.MessagingStrategy.prototype.GetMessages = function () {
  return this.GetValidityState().getMessages();
};

oj.MessagingStrategy.prototype.GetMaxSeverity = function () {
  return this.GetValidityState().getMaxSeverity();
};
/**
 * Gets the converter hint.
 *
 * @return {Array} an array of hints, each a string.
 * @private
 */


oj.MessagingStrategy.prototype.GetConverterHint = function () {
  var hints = [];

  var mc = this._getMessagingContent();

  var converterHint = mc && mc.converterHint;

  if (converterHint) {
    hints.push(converterHint);
  }

  return hints;
};
/**
 * ValidatorHints are retrieved on-demand. The first time they are requested,
 * we get them and set the mc.validatorHints.
 * @return {string} helpInstruction or ""
 * @private
 */


oj.MessagingStrategy.prototype.GetValidatorHints = function () {
  if (!this.getHasValidatorHints()) {
    this.setHasValidatorHints(true);
    var component = this.GetComponent(); // get the sync validator hints from the component, then set the messaging content.

    this._setMessagingContent(component._getValidatorHintsMC());

    component._initAsyncValidatorMessagingHint();
  } // Eventually the messagingContent will have all the validatorHints, even the async ones.
  // The async validators call componentMessaging.update(cm) when each hint Promise resolves with
  // all the validator hints it has so far, sync/async.
  // The first time through, before update, this will return the sync validator hints.
  // Every time the componentMessaging.update(cm) is called after, it will have the sync hints
  // plus any new async hints. The most common use case is to have only one validator per
  // form component but this supports multiple and sync and async.


  var mc = this._getMessagingContent();

  return mc && mc.validatorHint || [];
};
/**
 * Gets the short description.
 * @return {string} helpInstruction or ""
 * @private
 */


oj.MessagingStrategy.prototype.GetTitle = function () {
  var mc = this._getMessagingContent();

  return mc && mc.title || '';
};
/**
 * Gets the validityState, an instance of oj.ComponentValidity or null.
 * @private
 */


oj.MessagingStrategy.prototype.GetValidityState = function () {
  var mc = this._getMessagingContent();

  return mc && mc.validityState || null;
};
/**
 * Whether the strategy is displaying messages or not.
 * @return {boolean} true if strategy has messages to display
 * @private
 */


oj.MessagingStrategy.prototype.HasMessages = function () {
  var messages = this.GetMessages();
  return !!(messages && messages.length > 0);
};
/**
 * The following explains what this._displayOptions is in the following methods --
 * When the Strategy is created, like the PopupComponentMessaging strategy, it gets passed
 * in what artifacts it needs to display, like 'messages' or 'validatorHint'.
 * The default in alta is to show 'helpInstruction' and 'validatorHint' in 'notewindow'.
 * The api is displayOptions.helpInstruction = 'notewindow' and
 * displayOptions.validatorHint = 'notewindow', and this gets consolidated the other way,
 * notewindow: [helpInstruction, validatorHint], where notewindow is the PopupComponentStrategy.
 * For Redwood, we look at the user-assistance-density attribute, and by default the displayOptions
 * will be 'messages', 'helpInstruction' and 'validatorHint'.
 * 'helpInstruction', 'helpDefinition' and 'helpSource' are
 * shown if the attributes are set.
 * The user can turn off helpInstruction by not having a help instruction option.
 * The user can turn off messages and/or validationHint by setting its display-options to none, like
 * display-options.validatorHint = 'none'.
 */


oj.MessagingStrategy.prototype.ShowMessages = function () {
  return this._displayOptions.indexOf('messages') !== -1;
};

oj.MessagingStrategy.prototype.ShowConverterHint = function () {
  return this._displayOptions.indexOf('converterHint') !== -1;
};

oj.MessagingStrategy.prototype.ShowValidatorHint = function () {
  return this._displayOptions.indexOf('validatorHint') !== -1;
};

oj.MessagingStrategy.prototype.ShowTitle = function () {
  return this._displayOptions.indexOf('title') !== -1 || this._displayOptions.indexOf('helpInstruction') !== -1;
};
/**
 * Returns true if we have invalid messages; false otherwise.
 *
 * @return {boolean}
 * @private
 */


oj.MessagingStrategy.prototype.IsInvalid = function () {
  return this.GetValidityState().isInvalid();
};
/**
 * Create an id to put on the root dom element that holds the inline messaging content,
 * then add aria-describedby on the component on the appropriate dom node(s).
 * This makes it so the screen reader user knows the messaging content is connected to the launcher.
 * @memberof oj.MessagingStrategy
 * @param {Element} containerRoot
 * @instance
 * @private
 */


oj.MessagingStrategy.prototype.AddAriaDescribedByForInlineMessaging = function (containerRoot) {
  // create an id on the div holding the inline messaging.
  // add aria-describedby to the launcher to associate the launcher and the inline message
  var $contentElems = this.GetContentElement();
  oj.Assert.assertPrototype($contentElems, $);
  var containerRootId = $(containerRoot).uniqueId()[0].getAttribute('id');
  $contentElems.each(function () {
    // get ariaAttr that is on the content element(s)
    var ariaAttributeValue = this.getAttribute('aria-describedby'); // split into tokens

    var tokens = ariaAttributeValue ? ariaAttributeValue.split(/\s+/) : []; // Get index that id is in the tokens, if at all.

    var index = tokens.indexOf(containerRootId); // push id into tokens if it isn't already there

    if (index === -1) {
      tokens.push(containerRootId);
    } // join the tokens together


    var newValue = tokens.join(' ').trim();
    this.setAttribute('aria-describedby', newValue); // @HTMLUpdateOK
  });
};
/**
 * @memberof oj.MessagingStrategy
 * @param {Element} containerRoot
 * @instance
 * @private
 */


oj.MessagingStrategy.prototype.AddDescribedByToElement = function (elem, id) {
  var attr = 'described-by';
  var currentAttributeValue = elem.getAttribute(attr);
  var newAttributeValue;
  var tokens = currentAttributeValue ? currentAttributeValue.split(/\s+/) : []; // Get index that id is in the tokens, if at all.

  var index = tokens.indexOf(id); // add id if it isn't already there

  if (index === -1) {
    tokens.push(id);
  }

  newAttributeValue = tokens.join(' ').trim();
  elem.setAttribute(attr, newAttributeValue); // @HTMLUpdateOK
};
/**
 * Removes the aria-describedby from the launcher that was added by AddAriaDescribedByForInlineMessaging
 * @param {Element} containerRoot
 * @memberof oj.MessagingStrategy
 * @instance
 * @private
 */


oj.MessagingStrategy.prototype.RemoveAriaDescribedByForInlineMessaging = function (containerRoot) {
  var $contentElems = this.GetContentElement();
  oj.Assert.assertPrototype($contentElems, $);
  var containerRootId = containerRoot.getAttribute('id');
  $contentElems.each(function () {
    // get ariaAttr that is on the content element(s)
    var ariaAttributeValue = this.getAttribute('aria-describedby'); // split into tokens

    var tokens = ariaAttributeValue ? ariaAttributeValue.split(/\s+/) : []; // Get index that id is in the tokens, if at all.

    var index = tokens.indexOf(containerRootId); // remove id if it is there.

    if (index !== -1) {
      // remove that from the tokens array
      tokens.splice(index, 1);
    }

    var newValue = tokens.join(' ').trim();

    if (newValue) {
      this.setAttribute('aria-describedby', newValue); // @HTMLUpdateOK
    } else {
      this.removeAttribute('aria-describedby');
    }
  });
};
/**
 * Gets the messagingContent stored in ComponentMessaging instance
 * @return {Object}
 * @private
 */


oj.MessagingStrategy.prototype._getMessagingContent = function () {
  if (this._componentMessaging) {
    return this._componentMessaging._getMessagingContent();
  }

  return {};
};
/**
 * Gets the messagingContent stored in ComponentMessaging instance
 * @param {Object} messaging content.
 * @private
 */


oj.MessagingStrategy.prototype._setMessagingContent = function (content) {
  if (this._componentMessaging) {
    return this._componentMessaging._setMessagingContent(content);
  }

  return {};
};
/**
 * A messaging strategy that updates the component theming and accessibility attributes.
 *
 * @param {Array.<string>} displayOptions .
 * @constructor
 * @extends {oj.MessagingStrategy}
 * @private
 */


oj.DefaultMessagingStrategy = function (displayOptions) {
  this.Init(displayOptions);
};

oj.ComponentMessaging.registerMessagingStrategy(oj.ComponentMessaging._STRATEGY_TYPE.NONE, oj.DefaultMessagingStrategy); // TODO: Need to retrieve style selectors from a Style Manager

oj.DefaultMessagingStrategy._SELECTOR_STATE_INVALID = 'oj-invalid';
oj.DefaultMessagingStrategy._SELECTOR_STATE_WARNING = 'oj-warning';
oj.Object.createSubclass(oj.DefaultMessagingStrategy, oj.MessagingStrategy, 'oj.DefaultMessagingStrategy');
/**
 * Updates component theming, a11y attributes using the latest component state and its messaging
 * content.
 *
 * @private
 */

oj.DefaultMessagingStrategy.prototype.update = function () {
  oj.DefaultMessagingStrategy.superclass.update.call(this);
  var launcher = this.GetLauncher();
  var maxSeverity = this.GetMaxSeverity();
  var removeClasses = [];
  var addClasses = [];
  var invalid = false;
  var component = this.GetComponent();
  var jqRoot = component.widget();

  if (!launcher) {
    return;
  } // apply element error styling if invalid


  if (this.IsInvalid()) {
    // enable tooltip; set invalid class and aria invalid
    // TODO: oj classes should be set on the root DOM
    removeClasses.push(oj.DefaultMessagingStrategy._SELECTOR_STATE_WARNING);
    addClasses.push(oj.DefaultMessagingStrategy._SELECTOR_STATE_INVALID);
    invalid = true;
  } else if (this.HasMessages() && maxSeverity === Message.SEVERITY_LEVEL.WARNING) {
    // TODO: add warning or other severity state
    removeClasses.push(oj.DefaultMessagingStrategy._SELECTOR_STATE_INVALID);
    addClasses.push(oj.DefaultMessagingStrategy._SELECTOR_STATE_WARNING);
  } else {
    // for all other messages we remove selectors
    removeClasses.push(oj.DefaultMessagingStrategy._SELECTOR_STATE_INVALID);
    removeClasses.push(oj.DefaultMessagingStrategy._SELECTOR_STATE_WARNING);
  }

  jqRoot.removeClass(removeClasses.join(' ')).addClass(addClasses.join(' ')); // classes added to root
  // aria-invalid needs to be on an input/textarea

  this.GetContentElement().attr({
    'aria-invalid': invalid
  });
};
/**
 * Cleans up messaging artifacts that were created on the component instance. E.g., destroys any
 * widgets it created, removes styles added etc.
 *
 * @private
 */


oj.DefaultMessagingStrategy.prototype.deactivate = function () {
  var jqRoot = this.GetComponent().widget();
  jqRoot.removeClass(oj.DefaultMessagingStrategy._SELECTOR_STATE_INVALID).removeClass(oj.DefaultMessagingStrategy._SELECTOR_STATE_WARNING);
  this.GetContentElement().removeAttr('aria-invalid');
  oj.DefaultMessagingStrategy.superclass.deactivate.call(this);
};
/**
 * A messaging strategy that uses html5 placeholder (for now) to set/remove placeholder content.
 *
 * @param {Array.<string>} displayOptions an array of messaging artifacts displayed in the placeholder.
 * @constructor
 * @extends {oj.MessagingStrategy}
 * @private
 */


oj.PlaceholderMessagingStrategy = function (displayOptions) {
  this.Init(displayOptions);
};

oj.ComponentMessaging.registerMessagingStrategy(oj.ComponentMessaging._STRATEGY_TYPE.PLACEHOLDER, oj.PlaceholderMessagingStrategy); // Subclass from oj.MessagingStrategy

oj.Object.createSubclass(oj.PlaceholderMessagingStrategy, oj.MessagingStrategy, 'oj.PlaceholderMessagingStrategy');
/**
 * Initializer
 *
 * @param {Array.<string>} displayOptions an array of messaging artifacts displayed in the notewindow.
 * @private
 */

oj.PlaceholderMessagingStrategy.prototype.Init = function (displayOptions) {
  oj.PlaceholderMessagingStrategy.superclass.Init.call(this, displayOptions);
};
/**
 * Sets up a placeholder for the component instance using the converter hint.
 *
 * @param {Object} cm a reference to an instance of oj.ComponentMessaging that provides access to
 * the latest messaging content.
 *
 * @private
 */


oj.PlaceholderMessagingStrategy.prototype.activate = function (cm) {
  oj.PlaceholderMessagingStrategy.superclass.activate.call(this, cm);

  this._refreshPlaceholder();
};

oj.PlaceholderMessagingStrategy.prototype.reactivate = function (newDisplayOptions) {
  oj.PlaceholderMessagingStrategy.superclass.reactivate.call(this, newDisplayOptions);

  this._refreshPlaceholder();
};
/**
 * Returns true if the content being updated includes converterHint prop. This method is an
 * optimization because the update() method is called too often and any time any content changes.
 * The only time PlaceholderMessagingStrategy#update needs to execute is when the converter hint
 * changes.
 *
 * @param {Object=} content the messaging content that is being updated
 * @return {boolean}
 *
 * @private
 */


oj.PlaceholderMessagingStrategy.prototype.shouldUpdate = function (content) {
  return !!(content && content.converterHint !== undefined);
};

oj.PlaceholderMessagingStrategy.prototype.update = function () {
  oj.PlaceholderMessagingStrategy.superclass.update.call(this);

  this._refreshPlaceholder();
}; // a default placeholder is set on the component, and that is typically the converter hint


oj.PlaceholderMessagingStrategy.prototype._refreshPlaceholder = function () {
  var launcher = this.GetLauncher();

  if (this.ShowPlaceholderContent() && launcher) {
    var hints = this.GetConverterHint();
    var content = hints.length ? hints[0] : ''; // don't override the placeholder with the converter hint if it's empty

    if (oj.StringUtils.isEmptyOrUndefined(content)) return;
    var context = {};
    context.internalMessagingSet = true; // to indicate to component that placeholder is being
    // set from messaging module

    this.GetComponent().option({
      placeholder: content
    }, {
      _context: context
    });
  }
};

oj.PlaceholderMessagingStrategy.prototype.ShowPlaceholderContent = function () {
  // we have a placeholder to set/show if we have converterHint set.
  return this.ShowConverterHint();
};
/**
 * The ComponentValidity object represent a component's current validity state. The instance
 * provides specific methods to retrieve info such as <p>
 *  - whether the component is valid <p>
 *  - the messages currently tracked on the component.<p>
 *  - the max severity level of the messages, e.g., fatal, error etc. See oj.Message for details
 *
 * @param {boolean} valid
 * @param {Array} messages
 * @constructor
 * @private
 */


oj.ComponentValidity = function (valid, messages) {
  // TODO: provide methods that allow model implementations to instruct the elements to showMessages,
  // especially the ones marked for 'lazy' notification.
  this.Init(valid, messages);
};
/**
 * whether there are invalid messages among the list of messages.
 *
 * @param {Array} messages list of messages
 * @returns {boolean} true if we have invalid messages; false otherwise
 */


oj.ComponentValidity.isInvalid = function (messages) {
  var maxLevel = Message.getMaxSeverity(messages);

  if (maxLevel >= Message.SEVERITY_LEVEL.ERROR) {
    return true;
  }

  return false;
}; // Subclass from oj.Object


oj.Object.createSubclass(oj.ComponentValidity, oj.Object, 'oj.ComponentValidity');
/**
 * The jquery element whose validity this object describes
 * @param {boolean} valid
 * @param {Array} messages instances of oj.Message
 */

oj.ComponentValidity.prototype.Init = function (valid, messages) {
  oj.ComponentValidity.superclass.Init.call(this);

  this._initialize(valid, messages);
};
/**
 * Returns a boolean true if valid; false if element not valid
 * @returns {boolean}
 * @private
 */


oj.ComponentValidity.prototype.isInvalid = function () {
  return this._invalid;
};
/**
 * Returns an Array or messages that we are marked for immediate display or an empty array.
 * @private
 * @returns {Array}
 */


oj.ComponentValidity.prototype.getMessages = function () {
  return this._messages;
};
/**
 * Returns the max severity level.
 * @return {number}
 * @private
 */


oj.ComponentValidity.prototype.getMaxSeverity = function () {
  return this._maxSeverity;
};
/**
 * Updates the validity state for the component.
 *
 * @param {boolean} valid
 * @param {Array} messages instances of oj.Message
 * @private
 */


oj.ComponentValidity.prototype.update = function (valid, messages) {
  this._initialize(valid, messages);
};

oj.ComponentValidity.prototype._initialize = function (valid, messages) {
  this._compValid = valid;
  this._compMessages = messages;
  this._messages = this._getImmediateMessages(); // messages currently showing

  this._maxSeverity = Message.getMaxSeverity(this._messages); // max severity of messages currently showing

  this._invalid = oj.ComponentValidity.isInvalid(this._messages);
};
/**
 * Returns an array of messages that are marked for immediate display.
 *
 * @return {Array} of messages each an instance of oj.Message
 * @private
 */


oj.ComponentValidity.prototype._getImmediateMessages = function () {
  var messages = this._compMessages || [];
  var immediateMsgs = [];

  for (var index = 0; index < messages.length; index++) {
    var msg = messages[index]; // gather component messages marked for immediate display

    if (!(msg instanceof oj.ComponentMessage) || msg.canDisplay()) {
      immediateMsgs.push(msg);
    }
  }

  return immediateMsgs;
};



/**
 * JET component custom element bridge.
 *
 * This bridge ensures that JET components with child JET custom elements
 * can access child properties before the child busy state resolves.
 * This bridge does not guarantee that all properties for the child
 * will be available to the application before its busy states resolves,
 * e.g data bound attribute values.
 *
 * Applications should still wait on the element or page level
 * busy context before accessing properties or methods.
 *
 * @class
 * @ignore
 */
oj.CustomElementBridge = {};
/* global Logger:false, MetadataUtils:false */

/**
 * Prototype for the JET component custom element bridge instance
 */

oj.CustomElementBridge.proto = Object.create(oj.BaseCustomElementBridge.proto);
oj.CollectionUtils.copyInto(oj.CustomElementBridge.proto, {
  AddComponentMethods: function AddComponentMethods(proto) {
    // Add subproperty getter/setter
    // eslint-disable-next-line no-param-reassign
    proto.setProperty = function (prop, value) {
      var bridge = oj.BaseCustomElementBridge.getInstance(this);

      if (!bridge.SaveEarlyPropertySet(prop, value)) {
        if (!bridge._setEventProperty(this, prop, value) && !bridge._validateAndSetCopyProperty(this, prop, value, null)) {
          // If not an event or copy property, check to see if it's a component specific property
          var meta = oj.BaseCustomElementBridge.__GetPropertyMetadata(prop, oj.BaseCustomElementBridge.getProperties(bridge)); // For non component specific properties, just set directly on the element instead.


          if (!meta) {
            this[prop] = value;
          } else {
            oj.CustomElementBridge._getPropertyAccessor(this, prop)(value);
          }
        }
      }
    }; // eslint-disable-next-line no-param-reassign


    proto.getProperty = function (prop) {
      var bridge = oj.BaseCustomElementBridge.getInstance(this);

      var meta = oj.BaseCustomElementBridge.__GetPropertyMetadata(prop, oj.BaseCustomElementBridge.getProperties(bridge));

      var event = oj.__AttributeUtils.eventListenerPropertyToEventType(prop); // For event listeners and non component specific properties, return the property from the element.
      // Otherwise, return the widget property and let the widget handle dot notation for subproperties.


      if (event || !meta) {
        return this[prop];
      }

      var ext = meta ? meta.extension : null;

      if (ext && ext._COPY_TO_INNER_ELEM) {
        return bridge._getCopyProperty(this, prop, meta);
      }

      return oj.CustomElementBridge._getPropertyAccessor(this, prop)();
    }; // Override HTMLELement's focus/blur methods so we can call focus/blur on an inner element if needed.
    // eslint-disable-next-line no-param-reassign


    proto.focus = function () {
      var bridge = oj.BaseCustomElementBridge.getInstance(this); // If focus is called before the component has been created there
      // will be no saved widget instance yet so call the HTMLElement
      // focus instead.

      if (bridge._WIDGET_INSTANCE) {
        var focusElem = bridge._WIDGET_INSTANCE.__getFocusElement();

        if (focusElem) {
          if (focusElem !== this) {
            focusElem.focus();
          } else {
            HTMLElement.prototype.focus.call(this);
          }
        }
      } else {
        HTMLElement.prototype.focus.call(this);
      }
    }; // eslint-disable-next-line no-param-reassign


    proto.blur = function () {
      var bridge = oj.BaseCustomElementBridge.getInstance(this);

      if (bridge._WIDGET_INSTANCE) {
        var focusElem = bridge._WIDGET_INSTANCE.__getFocusElement();

        if (focusElem) {
          if (focusElem !== this) {
            focusElem.blur();
          } else {
            HTMLElement.prototype.blur.call(this);
          }
        }
      } else {
        HTMLElement.prototype.focus.call(this);
      }
    };
  },
  BatchedPropertySet: function BatchedPropertySet(elem, props) {
    var keys = Object.keys(props);
    var processedMap = {};
    var i;

    for (i = 0; i < keys.length; i++) {
      var property = keys[i];
      var value = props[property]; // exclude event proprties and transfer attributes from batch updates

      if (!this._setEventProperty(elem, property, value) && !this._validateAndSetCopyProperty(elem, property, value, null)) {
        value = this.ValidatePropertySet(elem, property, value);
        property = this.GetAliasForProperty(property);
        processedMap[property] = value;
      }
    } // Skip batched property sets if widget constructor isn't available meaning
    // the widget wasn't instantiated due to an error on creation or destroyed.


    var widgetConstructor = oj.Components.__GetWidgetConstructor(this._WIDGET_ELEM);

    if (widgetConstructor) {
      widgetConstructor('option', processedMap);
    } else {
      for (i = 0; i < keys.length; i++) {
        var key = keys[i];
        elem.setProperty(key, props[key]);
      }
    }
  },
  CreateComponent: function CreateComponent(element) {
    var innerDomFun = this._INNER_DOM_FUNCTION;
    this._WIDGET_ELEM = oj.CustomElementBridge._getWidgetElement(element, innerDomFun ? innerDomFun(element) : this._EXTENSION._INNER_ELEM); // Transfer global attributes and copy tagged properties to child element if one exists

    if (this._WIDGET_ELEM !== element) {
      var transferAttrs = this._EXTENSION._GLOBAL_TRANSFER_ATTRS || [];

      for (var i = 0; i < transferAttrs.length; i++) {
        var attr = transferAttrs[i];

        if (element.hasAttribute(attr)) {
          this._WIDGET_ELEM.setAttribute(attr, element.getAttribute(attr)); // @HTMLUpdateOK
          // Remove attribute from custom element after transfering value to inner element
          // Set a flag so we know that we're removing the attribute, not app so
          // that on attribute changed we don't remove it again


          this._removingTransfer = true;
          element.removeAttribute(attr);
        }
      }

      this._copyProperties();
    }

    oj.Components.unmarkPendingSubtreeHidden(element); // Initialize jQuery object with options and pass element as wrapper if needed

    var locator = $(this._WIDGET_ELEM);

    var widgetConstructor = $(this._WIDGET_ELEM)[this._EXTENSION._WIDGET_NAME].bind(locator);

    widgetConstructor(this._PROPS);
    this._WIDGET = widgetConstructor;
    this._WIDGET_INSTANCE = widgetConstructor('instance');

    if (this._WRITEBACK_PROPS) {
      this._WIDGET_INSTANCE.__saveWritebackOptions(this._WRITEBACK_PROPS);
    } // Setup blur/focus listeners on inner element so we can trigger on the root custom element for 


    var getFocusEventPropagator = function getFocusEventPropagator(type) {
      return function (event) {
        // Ensure that the target is the custom element, not the inner element, so create
        // a new event and dispatch on the custom element.
        element.dispatchEvent(new FocusEvent(type, {
          relatedTarget: event.relatedTarget
        }));
      };
    };

    var focusElem = this._WIDGET_INSTANCE.__getFocusElement();

    if (focusElem && focusElem !== element) {
      focusElem.addEventListener('focus', getFocusEventPropagator('focus'));
      focusElem.addEventListener('blur', getFocusEventPropagator('blur'));
    } // Set flag when we can fire property change events


    this.__READY_TO_FIRE = true; // Resolve the component busy state

    this.resolveDelayedReadyPromise();
  },
  DefineMethodCallback: function DefineMethodCallback(proto, method, methodMeta) {
    // eslint-disable-next-line no-param-reassign
    proto[method] = function () {
      var bridge = oj.BaseCustomElementBridge.getInstance(this);
      var methodName = methodMeta.internalName || method; // Pass in null as thisArg to apply since the widget constructor is prebound to the jQuery element

      return bridge._WIDGET.apply(null, [methodName].concat([].slice.call(arguments)));
    };
  },
  DefinePropertyCallback: function DefinePropertyCallback(proto, property, propertyMeta) {
    var ext = propertyMeta.extension;
    Object.defineProperty(proto, property, {
      enumerable: true,
      get: function get() {
        var bridge = oj.BaseCustomElementBridge.getInstance(this);

        if (propertyMeta._eventListener) {
          return bridge.GetEventListenerProperty(property);
        } else if (ext && ext._COPY_TO_INNER_ELEM) {
          return bridge._getCopyProperty(this, property, propertyMeta);
        }

        return oj.CustomElementBridge._getPropertyAccessor(this, property)();
      },
      set: function set(value) {
        var bridge = oj.BaseCustomElementBridge.getInstance(this); // Properties can be set before the component is created. These early
        // sets are actually saved until after component creation and played back.

        if (!bridge.SaveEarlyPropertySet(property, value)) {
          if (propertyMeta._eventListener) {
            bridge.SetEventListenerProperty(this, property, value);
          } else if (!bridge._validateAndSetCopyProperty(this, property, value, propertyMeta)) {
            // For widget based components, see if there is a default value assigned in the
            // metadata if application tries to unset the property. For composites and
            // definitional elements, this is handled in the getter since the bridge handles
            // sets/gets, but for widget based components the bridge only calls through to the
            // widget code which initializes the component to the default value (which should match
            // the metadata default)
            var flags = {};

            if (value === undefined) {
              flags = {
                _context: {
                  skipEvent: true
                }
              }; // eslint-disable-next-line no-param-reassign

              value = MetadataUtils.getDefaultValue(propertyMeta); // Usually the widget logic fires the property changed events, but in this case
              // the app has set undefined, but we're setting the default value on the widget so
              // we'll handle firing the property changed from the bridge code for this case
              // and skip the event in the widget code.

              if (bridge.__READY_TO_FIRE) {
                var previousValue = this[property];

                oj.BaseCustomElementBridge.__FirePropertyChangeEvent(this, property, undefined, previousValue, 'external');
              }
            }

            oj.CustomElementBridge._getPropertyAccessor(this, property, flags)(value);
          }
        }
      }
    });
  },
  GetAttributes: function GetAttributes(metadata) {
    var attrs = oj.BaseCustomElementBridge.getAttributes(metadata.properties);

    if (metadata.extension._GLOBAL_TRANSFER_ATTRS) {
      attrs = attrs.concat(metadata.extension._GLOBAL_TRANSFER_ATTRS);
    } // Private array based API to allow widget based components to specify any
    // additional attributes they want to get notified about, e.g. data-oj-input-id.
    // These attributes will get passed through to the widget via the
    // __handleWatchedAttribute method.


    if (metadata.extension._WATCHED_ATTRS) {
      attrs = attrs.concat(metadata.extension._WATCHED_ATTRS);
    }

    return attrs;
  },
  GetAliasForProperty: function GetAliasForProperty(property) {
    // Aliasing only supported for top level properties
    var alias = this._EXTENSION._ALIASED_PROPS;

    if (alias && alias[property]) {
      return alias[property];
    }

    return property;
  },
  InitializeElement: function InitializeElement(element) {
    // Invoke callback on the superclass
    oj.BaseCustomElementBridge.proto.InitializeElement.call(this, element);

    if (this._EXTENSION._CONTROLS_SUBTREE_HIDDEN) {
      oj.Components.markPendingSubtreeHidden(element);
    }

    oj.BaseCustomElementBridge.__InitProperties(element, this._PROPS);
  },
  HandleAttributeChanged: function HandleAttributeChanged(element, attr, oldValue, newValue) {
    var transferAttrs = this._EXTENSION._GLOBAL_TRANSFER_ATTRS;
    var bTransfer = transferAttrs && transferAttrs.indexOf(attr) !== -1;
    var watchedAttrs = this._EXTENSION._WATCHED_ATTRS;
    var bWatchedAttr = watchedAttrs && watchedAttrs.indexOf(attr) !== -1;

    if (bTransfer && this._WIDGET_ELEM) {
      if (!this._removingTransfer) {
        // When we transfer the attribute the app will not be able to remove the
        // attribute from the DOM, we will recommend binding the value if the value
        // needs to be toggled.
        this._WIDGET_ELEM.setAttribute(attr, newValue); // @HTMLUpdateOK
        // Remove attribute from custom element after transfering value to inner element
        // Set a flag so we know that we're removing the attribute, not app so
        // that on attribute changed we don't remove it again


        this._removingTransfer = true;
        element.removeAttribute(attr);
      } else if (this._removingTransfer) {
        this._removingTransfer = false;
      }
    } else if (bWatchedAttr && oldValue !== newValue && this._WIDGET_INSTANCE) {
      // Check to see if this is attribute is being watched by the component
      // in which case we will just pass this through as is without converting
      // the attribute to a property name. Components are responsible for retrieving
      // attribute values on component initialization. This method only handles changes
      // after the fact.
      this._WIDGET_INSTANCE.__handleWatchedAttribute(attr, oldValue, newValue);
    }
  },
  HandleDetached: function HandleDetached(element) {
    // Invoke callback on the superclass
    oj.BaseCustomElementBridge.proto.HandleDetached.call(this, element); // Only call __handleDisconnected if the component hasn't previously
    // been destroyed which we can check by seeing if the widget constructor is null

    if (oj.Components.__GetWidgetConstructor(this._WIDGET_ELEM) && this._WIDGET_INSTANCE) {
      this._WIDGET_INSTANCE.__handleDisconnected();
    }
  },
  HandleReattached: function HandleReattached(element) {
    // Invoke callback on the superclass
    oj.BaseCustomElementBridge.proto.HandleReattached.call(this, element);

    if (this._WIDGET_INSTANCE) {
      this._WIDGET_INSTANCE.__handleConnected();
    }
  },
  InitializeBridge: function InitializeBridge(element, descriptor) {
    // Invoke callback on the superclass
    oj.BaseCustomElementBridge.proto.InitializeBridge.call(this, element, descriptor);
    this._INNER_DOM_FUNCTION = descriptor.innerDomFunction;
    this._EXTENSION = this.METADATA.extension || {};
    this._PROPS = this._EXTENSION._INNER_ELEM || this._INNER_DOM_FUNCTION ? {
      _wrapper: element
    } : {};

    this._setupPropertyAccumulator(element, this._PROPS); // Checks metadata for copy and writeback properties


    this._processProperties();
  },
  _copyProperties: function _copyProperties() {
    // Copies properties from the bridge _PROPS before the widget is instantiated
    // removing copied props from the object
    if (this._COPY_ATTRS) {
      for (var i = 0; i < this._COPY_ATTRS.length; i++) {
        var attr = this._COPY_ATTRS[i];

        var propName = oj.__AttributeUtils.attributeToPropertyName(attr);

        if (Object.prototype.hasOwnProperty.call(this._PROPS, propName)) {
          var value = this._PROPS[propName];

          this._setCopyProperty(attr, value); // Delete the attribute we just copied from the options that we
          // instantiate the widget with


          delete this._PROPS[propName];
        }
      }
    }
  },
  _getCopyProperty: function _getCopyProperty(elem, prop, propMeta) {
    var attrName = oj.__AttributeUtils.propertyNameToAttribute(prop);

    var ext = propMeta.extension;

    if (ext._ATTRIBUTE_ONLY) {
      if (this._WIDGET_ELEM.hasAttribute(attrName)) {
        var value = this._WIDGET_ELEM.getAttribute(attrName);

        var coercedValue;

        try {
          coercedValue = oj.__AttributeUtils.coerceValue(elem, attrName, value, propMeta.type);
        } catch (ex) {
          this.throwError(elem, 'Error parsing attribute value.', ex);
        }

        return coercedValue;
      }

      return null;
    }

    return this._WIDGET_ELEM[prop];
  },
  _processProperties: function _processProperties() {
    var props = oj.BaseCustomElementBridge.getProperties(this);

    if (props) {
      var propKeys = Object.keys(props);

      for (var i = 0; i < propKeys.length; i++) {
        var propName = propKeys[i];
        var propMeta = props[propName]; // Store writeback properties on the bridge and set on widget when we instantiate it later

        if (propMeta.writeback) {
          if (!this._WRITEBACK_PROPS) {
            this._WRITEBACK_PROPS = {};
          }

          this._WRITEBACK_PROPS[propName] = true;
        } // Store properties to copy to inner element for easy lookup


        var ext = propMeta.extension;

        if (ext && ext._COPY_TO_INNER_ELEM) {
          if (!this._COPY_ATTRS) {
            this._COPY_ATTRS = [];
          }

          this._COPY_ATTRS.push(propName);
        }
      }
    }
  },
  _setCopyProperty: function _setCopyProperty(attribute, value) {
    if (value == null || value === false) {
      this._WIDGET_ELEM.removeAttribute(attribute);
    } else if (value === true) {
      this._WIDGET_ELEM.setAttribute(attribute, ''); // @HTMLUpdateOK

    } else {
      this._WIDGET_ELEM.setAttribute(attribute, value); // @HTMLUpdateOK

    }
  },
  _setupPropertyAccumulator: function _setupPropertyAccumulator(element, widgetOptions) {
    // Add an element function that will track property values until expressions are all evaluated.
    // This object will be replaced with the actual widget constructor.
    this._WIDGET = function (method, prop, value) {
      // Allow property access before widget is created for element binding and dynamic element creation
      if (method === 'option') {
        oj.BaseCustomElementBridge.__SetProperty(this.GetAliasForProperty.bind(this), widgetOptions, prop, value);

        return widgetOptions[prop];
      } // throw is eslint hack to fix consistent-return


      throw this.throwError(element, 'Cannot access methods before element is upgraded.');
    };
  },
  _validateAndSetCopyProperty: function _validateAndSetCopyProperty(elem, prop, value, propMeta) {
    // propMeta is could be null so we should retrieve it if not passed in
    var attrName = oj.__AttributeUtils.propertyNameToAttribute(prop);

    var isCopy = this._COPY_ATTRS && this._COPY_ATTRS.indexOf(attrName) !== -1; // If widget hasn't been instantiated skip setting until CreateComponent

    if (isCopy) {
      // We need to validate the value so that we don't copy an invalid value.
      // eslint-disable-next-line no-param-reassign
      value = this.ValidatePropertySet(elem, prop, value);

      if (this._WIDGET_ELEM) {
        if (!propMeta) {
          // eslint-disable-next-line no-param-reassign
          propMeta = oj.BaseCustomElementBridge.__GetPropertyMetadata(prop, oj.BaseCustomElementBridge.getProperties(this));
        }

        var previousValue = this._getCopyProperty(elem, prop, propMeta);

        this._setCopyProperty(attrName, value); // Fire a property change event for the copy properties since we don't actually pass
        // these to the widget. The widget will never update these properties themselves so
        // all updates are external.


        oj.BaseCustomElementBridge.__FirePropertyChangeEvent(elem, prop, this._getCopyProperty(elem, prop, propMeta), previousValue, 'external');
      } else {
        // Save the value until inner widget is created and we can copy them over
        this._PROPS[attrName] = value;
      }
    }

    return isCopy;
  },
  _setEventProperty: function _setEventProperty(elem, prop, value) {
    var isEvent = false;

    var event = oj.__AttributeUtils.eventListenerPropertyToEventType(prop);

    if (event) {
      // eslint-disable-next-line no-param-reassign
      elem[prop] = value;
      isEvent = true;
    }

    return isEvent;
  }
});
/** ***********************/

/* PUBLIC STATIC METHODS */

/** ***********************/

/**
 * Returns the metadata object for the given component.
 * @param  {string} tagName        The component tag name
 * @return {Object}                The component metadata object
 * @ignore
 */

oj.CustomElementBridge.getMetadata = function (tagName) {
  return oj.CustomElementBridge._METADATA_MAP[tagName.toLowerCase()];
};
/**
 * Checks whether the specified event type was declared in the metadata for this custom element
 * @param {Element} element the custom element
 * @param {string} type the event type (e.g. "beforeExpand")
 * @return {boolean} true if the event type was declared in the metadata, false otherwise
 * @ignore
 */


oj.CustomElementBridge.isKnownEvent = function (element, type) {
  var bridge = oj.BaseCustomElementBridge.getInstance(element);
  return (bridge.METADATA.events && bridge.METADATA.events[type]) != null;
};
/**
 * Checks whether the specified property was declared in the metadata for this custom element
 * @param {Element} element the custom element
 * @param {string} prop the property name (e.g. "selection")
 * @return {boolean} true if the property was declared in the metadata, false otherwise
 * @ignore
 */


oj.CustomElementBridge.isKnownProperty = function (element, prop) {
  var bridge = oj.BaseCustomElementBridge.getInstance(element);
  return (bridge.METADATA.properties && bridge.METADATA.properties[prop]) != null;
};
/**
 * Returns the custom element property for a given aliased component property which can be used
 * for converting an internal optionChange event, e.g. returning readonly for oj-switch's readOnly
 * property so we can fire a readonly-changed event instead of readOnly-changed.
 * Will return the original property if there is no aliasing.
 * @param {Element} element The custom element
 * @param {string} property The component property
 * @return {string}
 * @ignore
 */


oj.CustomElementBridge.getPropertyForAlias = function (element, property) {
  // Aliasing only supported for top level properties
  var bridge = oj.BaseCustomElementBridge.getInstance(element);
  var alias = bridge._EXTENSION._COMPONENT_TO_ELEMENT_ALIASES;

  if (alias && alias[property]) {
    return alias[property];
  }

  return property;
};
/**
 * Registers a component as a custom element.
 * @param {string} tagName The component tag name (all lower case), which should contain a dash '-' and not be a reserved tag name.
 * @param {Object} descriptor The registration descriptor. The descriptor will contain keys for metadata and other component overrides.
 * @param {Object} descriptor.metadata The JSON object containing info like the widget name, whether component has an inner element, an outer wrapper, and the component metadata.
 * @param {function(string, string, Object, function(string))} descriptor.parseFunction The function that will be called to parse attribute values.
 * Note that this function is only called for non bound attributes. The parseFunction will take the following parameters:
 * <ul>
 *  <li>{string} value: The value to parse.</li>
 *  <li>{string} name: The name of the attribute.</li>
 *  <li>{Object} meta: The metadata object for the property which can include its type, default value,
 *      and any extensions that the composite has provided on top of the required metadata.</li>
 *  <li>{function(string)} defaultParseFunction: The default parse function for the given attribute
 *      type which is used when a custom parse function isn't provided and takes as its parameters
 *      the value to parse.</li>
 * </ul>
 * @param {Element} descriptor.innerDomFunction The function that will be called to return the tag name of the inner DOM element, e.g. 'button' or 'a'
 * The innerDomFunction will take the following parameters:
 * <ul>
 *  <li>{Element} element: The component custom element.</li>
 * </ul>
 * @ignore
 */


oj.CustomElementBridge.register = function (tagName, descriptor) {
  var meta = descriptor[oj.BaseCustomElementBridge.DESC_KEY_META];
  meta = oj.BaseCustomElementBridge.__ProcessEventListeners(meta); // eslint-disable-next-line no-param-reassign

  descriptor[oj.BaseCustomElementBridge.DESC_KEY_META] = meta;
  oj.CustomElementBridge._METADATA_MAP[tagName.toLowerCase()] = meta;
  var ext = meta.extension; // Use the simple definitional element prototype if no real widget is associated with this custom element

  var proto = ext && ext._WIDGET_NAME ? oj.CustomElementBridge.proto : oj.DefinitionalElementBridge.proto; // Create component to element property alias mapping for easy optionChange lookup and stash it in the extension object

  var aliasMap = ext._ALIASED_PROPS;

  if (aliasMap) {
    ext._COMPONENT_TO_ELEMENT_ALIASES = {};
    var aliases = Object.keys(aliasMap);
    aliases.forEach(function (alias) {
      ext._COMPONENT_TO_ELEMENT_ALIASES[aliasMap[alias]] = alias;
    });
  }

  if (oj.BaseCustomElementBridge.__Register(tagName, descriptor, proto)) {
    customElements.define(tagName.toLowerCase(), proto.getClass(descriptor));
  }
};
/** ***************************/

/* NON PUBLIC STATIC METHODS */

/** ***************************/

/**
 * Returns a property accessor for setting/getting options
 * @private
 */


oj.CustomElementBridge._getPropertyAccessor = function (element, property, flags) {
  function optionAccessor(value) {
    var bridge = oj.BaseCustomElementBridge.getInstance(element); // option set case

    if (arguments.length === 1) {
      // eslint-disable-next-line no-param-reassign
      value = bridge.ValidatePropertySet(element, property, value); // eslint-disable-next-line no-param-reassign

      property = bridge.GetAliasForProperty(property);

      bridge._WIDGET('option', property, value, flags);

      return undefined;
    } // option get case
    // eslint-disable-next-line no-param-reassign


    property = bridge.GetAliasForProperty(property);
    return bridge._WIDGET('option', property);
  }

  return optionAccessor.bind(element);
};
/**
 * Returns the element that the widget constructor will be instantiated on which can be the custom element or a child element.
 * @private
 */


oj.CustomElementBridge._getWidgetElement = function (element, innerTagName) {
  // If component widget is bound to an inner child element like <ul> for <oj-list-view>,
  // create one only if the application does not provide it.
  var widgetElem = element;

  if (innerTagName) {
    var firstChild = element.firstElementChild;

    if (firstChild && firstChild.tagName.toLowerCase() === innerTagName) {
      widgetElem = firstChild;
    } else {
      widgetElem = document.createElement(innerTagName); // @HTMLUpdateOK
      // Make a copy of the custom element children before appending the inner element

      var children = [];
      var nodeList = element.childNodes;

      for (var i = 0; i < nodeList.length; i++) {
        children.push(nodeList[i]);
      }

      element.appendChild(widgetElem); // @HTMLUpdateOK
      // If we create the inner child element, check to see if there are any children
      // to move like for <oj-button> which can have a child elements that should be moved to
      // the newly created inner <button> element.

      while (children.length) {
        var child = children.shift(); // Only move default slot children to inner child element. Default slot children are those
        // that do not explictly set a slot attribute (or have one passed from a composite) or have slot=''.
        // The component will be responsible for moving all named slot children.
        // For example, it does not make sense for <oj-list-view> to move contextMenu slot to its inner <ul> element.

        if (!oj.BaseCustomElementBridge.getSlotAssignment(child)) {
          widgetElem.appendChild(child);
        }
      }
    } // add data-oj-internal attribute for automation tests


    widgetElem.setAttribute('data-oj-internal', '');
  }

  return widgetElem;
};
/**
 * Map of registered custom element names
 * @private
 */


oj.CustomElementBridge._METADATA_MAP = {};

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }


var DataProviderFeatureChecker = /*#__PURE__*/function () {
  function DataProviderFeatureChecker() {
    _classCallCheck(this, DataProviderFeatureChecker);
  }

  _createClass(DataProviderFeatureChecker, null, [{
    key: "isDataProvider",
    value: function isDataProvider(dataprovider) {
      if (dataprovider['fetchFirst']) {
        return true;
      }

      return false;
    }
  }, {
    key: "isTreeDataProvider",
    value: function isTreeDataProvider(dataprovider) {
      if (dataprovider['getChildDataProvider']) {
        return true;
      }

      return false;
    }
  }]);

  return DataProviderFeatureChecker;
}();

oj.DataProviderFeatureChecker = DataProviderFeatureChecker;



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * Utilities for getting DataProvider features.
 * @ignore
 */

/**
 * End of jsdoc
 */



/* global Logger:false, MetadataUtils:false, DefaultsUtils:false */

/**
 * A bridge for a custom element that renders using a constructor
 * function. Note that when a constructor function is provided, the new instance isn't
 * created until the CreateComponent method so property changes that occur before the
 * component instance is created will no-op.
 *
 * Components that provide a constructor function should implement the following methods:
 * createDOM - Called when the component is instantiated
 * updateDOM - Called after createDOM and when the component needs to do a full render on
 * refresh and property changes if the component is not handling them separately.
 * handlePropertyChanged - (optional) Called when properties change and should return true if
 * the component has handled the property change and does not need to do a full render. If
 * false is returned, updateDOM will be called to do a full render.
 * static getDynamicDefaults - (optional) An optional method that can return an object with
 * non JSON compatible default values or getters for properties with dynamic default values,
 * e.g. theme dependent properties. If a default for a property is also found in metadata,
 * the dynamic value will be ignored.
 *
 * When the constructor function is called, the bridge will pass a context object
 * with the following keys:
 * element - The custom element
 * props - A proxy for the element properties with setter/getter and setProperty APIs allowing the
 *         component to control writeback.
 * unique - A unique ID that the component can append to the custom element ID to generate unique IDs
 *
 * Note that components supporting the constructor function approach may eventually
 * be refactored into composites once composites support non template rendering.
 *
 * This bridge ensures that JET components with child JET custom elements
 * can access child properties before the child busy state resolves.
 * This bridge does not guarantee that all properties for the child
 * will be available to the application before its busy states resolves,
 * e.g data bound attribute values.
 *
 * Applications should still wait on the element or page level
 * busy context before accessing properties or methods.
 *
 * @class
 * @ignore
 */
oj.DefinitionalElementBridge = {};
/**
 * Prototype for the JET component definitional bridge instance
 */

oj.DefinitionalElementBridge.proto = Object.create(oj.BaseCustomElementBridge.proto);
oj.CollectionUtils.copyInto(oj.DefinitionalElementBridge.proto, {
  beforePropertyChangedEvent: function beforePropertyChangedEvent(element, property, detail) {
    // Call the renderer function so the definitional element can refresh its UI
    var changedProp = property;
    var value = detail.value;

    if (detail.subproperty) {
      changedProp = detail.subproperty.path;
      value = detail.subproperty.value;
    }

    this._partialRender(element, changedProp, value);
  },
  AddComponentMethods: function AddComponentMethods(proto) {
    // Add refresh and subproperty getter/setter methods for all definitional elements
    // eslint-disable-next-line no-param-reassign
    proto.refresh = function () {
      var bridge = oj.BaseCustomElementBridge.getInstance(this);

      bridge._fullRender(this);
    }; // eslint-disable-next-line no-param-reassign


    proto.setProperty = function (prop, value) {
      var bridge = oj.BaseCustomElementBridge.getInstance(this);

      if (!bridge.SaveEarlyPropertySet(prop, value)) {
        bridge.SetProperty(this, prop, value, this, true);
      }
    }; // eslint-disable-next-line no-param-reassign


    proto.getProperty = function (prop) {
      // 'this' is the property object we pass to the definitional element contructor to track internal property changes
      var bridge = oj.BaseCustomElementBridge.getInstance(this);
      return bridge.GetProperty(this, prop, this);
    }; // eslint-disable-next-line no-param-reassign


    proto._propsProto.setProperty = function (prop, value) {
      // 'this' is the property object we pass to the definitional element contructor to track internal property changes
      this._BRIDGE.SetProperty(this._ELEMENT, prop, value, this, false);
    }; // eslint-disable-next-line no-param-reassign


    proto._propsProto.getProperty = function (prop) {
      return this._BRIDGE.GetProperty(this, prop, this);
    };
  },
  CreateComponent: function CreateComponent(element) {
    oj.Components.unmarkPendingSubtreeHidden(element);

    if (!this._INSTANCE && this._EXTENSION._CONSTRUCTOR) {
      // We expose a similar set of properties as composites except that props is
      // not a Promise and we don't expose any slot information.
      // At the moment some definitional elements have mutation observers so they don't need
      // to rely on refresh being called to be alerted of new children so any cached slotMap
      // can become out of sync. We should add this once we build in support to auto detect
      // added/removed children to custom elements.
      var unique = oj.__AttributeUtils.getUniqueId();

      this._CONTEXT = {
        element: element,
        props: this._PROPS_PROXY,
        unique: unique
      };
      this._CONTEXT.uniqueId = element.id ? element.id : unique;
      this._INSTANCE = new this._EXTENSION._CONSTRUCTOR(this._CONTEXT); // Let the component initialize any additional DOM and then do a full render

      if (this._INSTANCE.createDOM) {
        this._INSTANCE.createDOM();
      }

      if (this._INSTANCE.updateDOM) {
        this._INSTANCE.updateDOM();
      }
    } // Set flag when we can fire property change events


    this.__READY_TO_FIRE = true; // Resolve the component busy state

    this.resolveDelayedReadyPromise();
  },
  DefineMethodCallback: function DefineMethodCallback(proto, method, methodMeta) {
    // eslint-disable-next-line no-param-reassign
    proto[method] = function () {
      var bridge = oj.BaseCustomElementBridge.getInstance(this);

      if (bridge._INSTANCE) {
        var methodName = methodMeta.internalName || method;
        return bridge._INSTANCE[methodName].apply(bridge._INSTANCE, arguments);
      }

      return undefined;
    };
  },
  DefinePropertyCallback: function DefinePropertyCallback(proto, property, propertyMeta) {
    function set(value, bOuterSet) {
      // Properties can be set before the component is created. These early
      // sets are actually saved until after component creation and played back.
      if (!this._BRIDGE.SaveEarlyPropertySet(property, value)) {
        var previousValue = this._BRIDGE._PROPS[property];

        if (!oj.BaseCustomElementBridge.__CompareOptionValues(property, propertyMeta, value, previousValue)) {
          // Skip validation for inner sets so we don't throw an error when updating readOnly writeable properties
          if (bOuterSet) {
            // eslint-disable-next-line no-param-reassign
            value = this._BRIDGE.ValidatePropertySet(this._ELEMENT, property, value);
          }

          if (propertyMeta._eventListener) {
            this._BRIDGE.SetEventListenerProperty(this._ELEMENT, property, value);

            this._BRIDGE._PROPS[property] = value;
          } else {
            this._BRIDGE._PROPS[property] = value;

            oj.BaseCustomElementBridge.__FirePropertyChangeEvent(this._ELEMENT, property, value, previousValue, bOuterSet ? 'external' : 'internal');
          }
        } else {
          Logger.info(oj.BaseCustomElementBridge.getElementInfo(this._ELEMENT) + ": Ignoring property set for property '" + property + "' with same value.");
        }
      }
    }

    function innerSet(value) {
      set.bind(this)(value, false);
    } // Called on the custom element


    function outerSet(value) {
      var bridge = oj.BaseCustomElementBridge.getInstance(this);
      set.bind(bridge._PROPS_PROXY)(value, true);
    }

    function get() {
      var value = this._BRIDGE._PROPS[property]; // If the attribute has not been set, return the default value

      if (value === undefined) {
        value = this._BRIDGE._getDefaultValue(property, propertyMeta);
        this._BRIDGE._PROPS[property] = value;
      }

      return value;
    }

    function innerGet() {
      return get.bind(this)();
    } // Called on the custom element


    function outerGet() {
      var bridge = oj.BaseCustomElementBridge.getInstance(this);
      return get.bind(bridge._PROPS_PROXY)();
    } // Don't add event listener properties for inner props


    if (!propertyMeta._derived) {
      oj.BaseCustomElementBridge.__DefineDynamicObjectProperty(proto._propsProto, property, innerGet, innerSet);
    }

    oj.BaseCustomElementBridge.__DefineDynamicObjectProperty(proto, property, outerGet, outerSet);
  },
  InitializeElement: function InitializeElement(element) {
    // Invoke callback on the superclass
    oj.BaseCustomElementBridge.proto.InitializeElement.call(this, element);

    if (this._EXTENSION._CONTROLS_SUBTREE_HIDDEN) {
      oj.Components.markPendingSubtreeHidden(element);
    }

    oj.BaseCustomElementBridge.__InitProperties(element, element);
  },
  InitializePrototype: function InitializePrototype(proto) {
    // Invoke callback on the superclass
    oj.BaseCustomElementBridge.proto.InitializePrototype.call(this, proto);
    Object.defineProperty(proto, '_propsProto', {
      value: {}
    });
  },
  InitializeBridge: function InitializeBridge(element, descriptor) {
    // Invoke callback on the superclass
    oj.BaseCustomElementBridge.proto.InitializeBridge.call(this, element, descriptor);
    this._EXTENSION = this.METADATA.extension || {}; // For tracking outer property sets

    this._PROPS = {}; // / For tracking inner property sets

    if (element._propsProto) {
      this._PROPS_PROXY = Object.create(element._propsProto);
      this._PROPS_PROXY._BRIDGE = this;
      this._PROPS_PROXY._ELEMENT = element;
    }
  },
  ShouldRemoveDisabled: function ShouldRemoveDisabled() {
    // Definitional components can opt in to have their disabled attribute removed.
    return this._EXTENSION._SHOULD_REMOVE_DISABLED === true;
  },
  // eslint-disable-next-line no-unused-vars
  _fullRender: function _fullRender(element) {
    if (this._INSTANCE && this._INSTANCE.updateDOM) {
      this._INSTANCE.updateDOM();
    }
  },
  _partialRender: function _partialRender(element, property, value) {
    if (this._INSTANCE) {
      // For partial renders, check to see if the component is handling the property change
      // or if it should do a full render
      var handlePropChangedFun = this._INSTANCE.handlePropertyChanged;
      var fullRender = !handlePropChangedFun || !handlePropChangedFun(property, value);

      if (fullRender && this._INSTANCE.updateDOM) {
        this._INSTANCE.updateDOM();
      }
    }
  },
  _getDefaultValue: function _getDefaultValue(property, propertyMeta) {
    if (this._EXTENSION._CONSTRUCTOR) {
      // The defaults object contains metadata and dynamic defaults
      var defaults = DefaultsUtils.getDefaults(this._EXTENSION._CONSTRUCTOR, this.METADATA, false);
      return defaults[property];
    }

    return MetadataUtils.getDefaultValue(propertyMeta);
  }
});

/* jslint browser: true*/



/**
 * Gesture utilities provided internally for JET components, currently only context menu gesture are available.
 * Moved from ojcomponentcore and made into static methods.
 * @ignore
 */
oj.GestureUtils = {};
/**
 * Event namespace used by context menu internal event registration.
 * Previously we got the namespace from the widget.
 */

oj.GestureUtils._EVENT_NAMESPACE = '.contextMenu';
/**
 * Utility method to tear down any artifacts created by GestureUtils.startDetectContextMenuGesture
 * @param {Element} rootNode the root element of the component
 */

oj.GestureUtils.stopDetectContextMenuGesture = function (rootNode) {
  if (rootNode._clickListener) {
    $(rootNode).off(oj.GestureUtils._EVENT_NAMESPACE).removeClass('oj-menu-context-menu-launcher')[0].removeEventListener('click', rootNode._clickListener, true); // the other 2 contextMenu timeouts don't need to be cleared here

    clearTimeout(rootNode._contextMenuPressHoldTimer); // eslint-disable-next-line no-param-reassign

    delete rootNode._clickListener; // eslint-disable-next-line no-param-reassign

    delete rootNode._contextMenuPressHoldTimer;
  }

  if (rootNode._touchStartAndMouseDownListener) {
    rootNode.removeEventListener('touchstart', rootNode._touchStartAndMouseDownListener, {
      passive: false
    }); // eslint-disable-next-line no-param-reassign

    delete rootNode._touchStartAndMouseDownListener;
  }

  if (rootNode._touchMoveListener) {
    rootNode.removeEventListener('touchmove', rootNode._touchMoveListener, {
      passive: true
    }); // eslint-disable-next-line no-param-reassign

    delete rootNode._touchMoveListener;
  }
};
/**
 * Utility method to setup context menu gesture detection on a component
 * @param {Element} rootNode the root node of the component
 * @param {function(Event, string)} callback callback to invoke on the component when context menu gesture is detected
 */


oj.GestureUtils.startDetectContextMenuGesture = function (rootNode, callback) {
  // Note: Whether or not we use Hammer to detect press-hold, this code would need to do the following things seen below:
  //
  // (1) Prevent the compatibility mousedown event from triggering Menu's clickAway logic.
  // (2) Prevent press-hold from also generating a click (unless Hammer does this automatically; I'm guessing it doesn't).
  // (3) Ensure we don't respond to *both* press-hold and contextmenu events on Android.
  //
  // So the only thing that Hammer would replace is:
  //
  // (4) Detecting the press-hold.
  //
  // Not currently using Hammer for (4), since:
  //
  // - This code predates Hammer, and was already stable after extensive iteration / fine-tuning.
  // - We use the same listeners for parts of 1-4. If moved 4 off to Hammer (separate listener), just need to ensure that
  //   we don't introduce any race conditions, etc.  (May be easy or hard, just need to look.)
  // - Hammer only wants to have one instance per DOM node, else they fight to control some things like touch-action. So
  //   a prereq for having this baseComponent logic put Hammer on components is to work out a protocol for super- and sub-
  //   classes to share the same instance and not step on each other.  Not insurmountable; just need to have the conversation.
  //   Tracked by ER 21357133, which links to detailed wiki.
  var pressHoldThreshold = oj.DomUtils.PRESS_HOLD_THRESHOLD; // launch CM at 750ms per UX spec

  var isPressHold = false; // to prevent pressHold from generating a click

  var contextMenuPressHoldTimer;
  var touchInProgress = false; // 5px is Hammer default.  (Didn't check whether they apply that separately to x and y like us, or to the hypotenuse,
  // but it's within a couple px either way -- think 3-4-5 triangle.)

  var maxAllowedMovement = 5;
  var touchPageX;
  var touchPageY;
  var doubleOpenTimer; // to prevent double open.  see usage below.

  var doubleOpenThreshold = 300; // made up this number.  TBD: Tweak as needed to make all platforms happy.

  var doubleOpenType = null; // "touchstart" or "contextmenu"

  var namespace = oj.GestureUtils._EVENT_NAMESPACE;
  var contextMenuPressHoldJustEnded = false;

  function launch(event, eventType, pressHold) {
    // ensure that pressHold doesn't result in a click.  Set this before the bailouts below.
    isPressHold = pressHold; // In Mobile Safari only, mousedown fires *after* the touchend, which causes at least 2 problems:
    // 1) CM launches after 750ms (good), then disappears when lift finger (bad), because touchend -->
    // mousedown, which calls Menu's "clikAway" mousedown listener, which dismisses Menu.
    // 2) The isPressHold logic needs to reset the isPressHold ivar on any event that can start a click,
    // including mousedown.  This problem causes the mousedown listener to incorrectly clear the ivar
    // after a pressHold, which broke the whole mechanism.
    // SOLUTION FOR 1-2:  On each launch (at 750ms), set a one-time touchend listener that will set a
    // var and clear it 50ms later.  While the var is set, both mousedown listeners can disregard the
    // mousedown.  Make the var a static var in Menu, since Menu's listener is static, and since this
    // launcher component can get/set it via an (effectively static) menu method.
    // NON-SOLUTIONS:  Cancelling touchstart or touchend, via pD() and sP(), doesn't cancel iPad's mousedown.
    // Cancelling mousedown from here doesn't work even if capture phase, since ojMenu's listener is capture phase.
    // TIMING: The following block should be before the doubleOpen bailout.

    if (isPressHold) {
      $(rootNode).one('touchend' + namespace, function () {
        var touchendMousedownThreshold = 50; // 50ms.  Make as small as possible to prevent unwanted side effects.

        contextMenuPressHoldJustEnded = true;
        setTimeout(function () {
          contextMenuPressHoldJustEnded = false;
        }, touchendMousedownThreshold);
      });
    } // On platforms like Android Chrome where long presses already fire the contextmenu event, the pressHold
    // logic causes the menu to open twice, once for the pressHold, once for the contextmenu.  There's no
    // guarantee which will happen first, but as long as they happen within doubleOpenThreshold ms
    // of each other, this logic should prevent the double open.
    // Note: Another option is a platform-specific solution where we only use pressHold for platforms that need
    // it (that don't already fire a contextmenu event for pressHold), but architectural preference is to avoid
    // platform-specific solutions if possible.


    if (doubleOpenType === 'touchstart' && event.type === 'contextmenu' || doubleOpenType === 'contextmenu' && event.type === 'touchstart' || doubleOpenType === 'keydown' && event.type === 'contextmenu') {
      // FF 60.2.2esr (32-bit) Win fires a rogue contextmenu event following the prevented keydown. What's odd is
      // preventing the keydown for shift+F10 prevents keypress but still files the contextmenu event.
      // Seems like "fallout" (behavior not yet correct) from bug https://bugzilla.mozilla.org/show_bug.cgi?id=1382199
      // For this case, prevent the native context menu within double open timeout window
      if (doubleOpenType === 'keydown' && event.type === 'contextmenu') event.preventDefault();
      doubleOpenType = null;
      clearTimeout(doubleOpenTimer);
      return;
    } // If a nested element or component already showed a JET context menu for this event, don't replace it with ours.
    // Hack: must check defaultPrevented on the nested event too, because for touchstart events on iOS7 at least, when
    // the outer component reaches this point, event is a different JQ wrapper event than the one on which the inner
    // component previously called preventDefault, although they both wrap the same native originalEvent.  The new wrapper
    // never had its isDefaultPrevented field set to the returnTrue method, so must check the nested originalEvent.
    // This never seems to happen with right-click and Shift-F10 events.  Has nothing to do with the setTimeout: the events
    // received by the rootNode.on("touchstart"...) code are different (firstWrapper==secondWrapper returns false).
    // TODO: link to JQ bug once filed.


    if (event.isDefaultPrevented && event.isDefaultPrevented() || event.originalEvent && event.originalEvent.defaultPrevented || event.defaultPrevented) {
      return;
    } // for downstream modules still dependent on originalEvent that used
    // to be added by JQuery


    if (event.type === 'touchstart' || event.type === 'touchmove') {
      // eslint-disable-next-line no-param-reassign
      event.originalEvent = event;
    }

    callback(event, eventType); // if _NotifyContextMenuGesture() (or subclass override of it) actually opened the CM, and if that launch wasn't
    // cancelled by a beforeOpen listener...

    if (event.isDefaultPrevented && event.isDefaultPrevented() || event.defaultPrevented) {
      // see double-open comments above
      if (event.type === 'touchstart' || event.type === 'contextmenu' || event.type === 'keydown') {
        doubleOpenType = event.type;
        doubleOpenTimer = setTimeout(function () {
          doubleOpenType = null;
        }, doubleOpenThreshold);
      }
    }
  } // At least some of the time, the pressHold gesture also fires a click event same as a short tap.  Prevent that here.


  var _clickListener = function _clickListener(event) {
    if (isPressHold) {
      // For Mobile Safari capture phase at least, returning false doesn't work; must use pD() and sP() explicitly.
      event.preventDefault();
      event.stopPropagation();
      isPressHold = false;
    }
  }; // eslint-disable-next-line no-param-reassign


  rootNode._clickListener = _clickListener; // Use capture phase to make sure we cancel it before any regular bubble listeners hear it.

  rootNode.addEventListener('click', _clickListener, true);

  var _touchStartAndMouseDownListener = function _touchStartAndMouseDownListener(event) {
    // for mousedown-after-touchend Mobile Safari issue explained above where __contextMenuPressHoldJustEnded is set.
    if (event.type === 'mousedown' && contextMenuPressHoldJustEnded) {
      return undefined;
    } // reset isPressHold flag for all events that can start a click.


    isPressHold = false; // start a pressHold timer on touchstart.  If not cancelled before 750ms by touchend/etc., will launch the CM.
    // isolate the context menu long tap to a single touch point.

    if (event.type === 'touchstart' && event.touches.length === 1) {
      // note starting position so touchmove handler can tell if touch moved too much
      var firstTouch = event.touches[0];
      touchPageX = firstTouch.pageX;
      touchPageY = firstTouch.pageY;
      touchInProgress = true;
      contextMenuPressHoldTimer = setTimeout(launch.bind(undefined, event, 'touch', true), pressHoldThreshold); // @HTMLUpdateOK
      // eslint-disable-next-line no-param-reassign

      rootNode._contextMenuPressHoldTimer = contextMenuPressHoldTimer;
    }

    return true;
  }; // eslint-disable-next-line no-param-reassign


  rootNode._touchStartAndMouseDownListener = _touchStartAndMouseDownListener;
  rootNode.addEventListener('touchstart', _touchStartAndMouseDownListener, {
    passive: false
  });

  var _touchMoveListener = function _touchMoveListener(event) {
    var firstTouch = event.touches[0];

    if (Math.abs(touchPageX - firstTouch.pageX) > maxAllowedMovement || Math.abs(touchPageY - firstTouch.pageY) > maxAllowedMovement) {
      touchInProgress = false;
      clearTimeout(contextMenuPressHoldTimer);
    }

    return true;
  }; // eslint-disable-next-line no-param-reassign


  rootNode._touchMoveListener = _touchMoveListener;
  rootNode.addEventListener('touchmove', _touchMoveListener, {
    passive: true
  });
  $(rootNode).on('mousedown' + namespace, _touchStartAndMouseDownListener) // if the touch moves too much, it's not a pressHold
  // if the touch ends before the 750ms is up, it's not a long enough pressHold to show the CM
  .on('touchend' + namespace + ' ' + 'touchcancel' + namespace, function () {
    touchInProgress = false;
    clearTimeout(contextMenuPressHoldTimer);
    return true;
  }).on('keydown' + namespace + ' ' + 'contextmenu' + namespace, function (event) {
    if (event.type === 'contextmenu' // right-click.  pressHold for Android but not iOS
    || event.which === 121 && event.shiftKey) {
      // Shift-F10
      var eventType;

      if (touchInProgress) {
        eventType = 'touch';
      } else if (event.type === 'keydown') {
        eventType = 'keyboard';
      } else {
        eventType = 'mouse';
      }

      launch(event, eventType, false);
    }

    return true;
  }); // Does 2 things:
  // 1) Prevents native context menu / callout from appearing in Mobile Safari.  E.g. for links, native CM has "Open in New Tab".
  // 2) In Mobile Safari and Android Chrome, prevents pressHold from selecting the text and showing the selection handles and (in Safari) the Copy/Define callout.
  // In UX discussion, we decided to prevent both of these things for all JET components for now.  If problems, can always, say, add protected method allowing
  // subclass to opt out (e.g. if they need 1 and/or 2 to work).
  // Per discussion with architects, do #2 only for touch devices, so that text selection isn't prevented on desktop.  Since #1
  // is a no-op for non-touch, we can accomplish this by omitting the entire style class, which does 1 and 2, for non-touch.
  // Per comments in scss file, the suppression of 1 and 2 has issues in old versions of Mobile Safari.

  if (oj.DomUtils.isTouchSupported()) {
    $(rootNode).addClass('oj-menu-context-menu-launcher');
  }
};



/* jslint browser: true*/

/**
 * in some OS/browser combinations you can attempt to detect high contrast mode
 * in javascript, go to the url below and look for "High Contrast"
 * https://www.w3.org/TR/2016/WD-wai-aria-practices-1.1-20160317/
 *
 * This function uses a variation of the code in the "High Contrast" section of
 * the site above to try and detect high contrast mode
 * by script, but it by no means definitively tells you whether or not you
 * are actually in high contrast mode. As discussed at the url above you
 * may need to have a user preference setting for high contrast.
 *
 * If the script is able to detect high contrast mode it sets the class
 * "oj-hicontrast" on the body tag. When "oj-high-contrast" is present
 * JET provides alternate informational images that are specially designed
 * for high contrast users.
 * @private
 */
function _ojHighContrast() {
  // using a data uri, I googled for shortest uri to get this one since
  // I don't care about the actual image, but I do want a legit image
  // otherwise I see an error in chrome and I don't want users to be
  // confused by seeing any error.
  var div = document.createElement('div');
  div.style.border = '1px solid';
  div.style.borderColor = 'red green';
  div.style.position = 'absolute';
  div.style.top = '-999px';
  div.style.backgroundImage = 'url(data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=)';
  var body = document.body;
  body.appendChild(div); // @HTMLUpdateOK safe manipulation

  var computedStyles = window.getComputedStyle(div);
  var bki = computedStyles.backgroundImage;

  if (computedStyles.borderTopColor === computedStyles.borderRightColor || bki != null && (bki === 'none' || bki === 'url (invalid-url:)')) {
    body.classList.add('oj-hicontrast');
  }

  body.removeChild(div);
}

$(document).ready(function () {
  _ojHighContrast();
});



/* jslint browser: true*/

/**
 * @export
 * @class
 * @since 1.0
 * @classdesc Common test support in JavaScript
 * @ojtsignore
 */
oj.Test = {};
/**
 * A global application flag that can be set by a test to indicate that all page startup processing is done
 * and an external automated test can begin
 * @export
 * @type {boolean}
 */

oj.Test.ready = false;
/**
 * @export
 * Return the node found given the locator
 * @param {Object|string} locator A locator which is either a JSON string (to be parsed using $.parseJSON), or an Object with the following properties:
 *                                             element: the component's selector, determined by the test author when laying out the page
 *                                             subId: the string, documented by the component, that the component expects in getNodeBySubId to locate a particular subcomponent
 *  @returns {any} the subcomponent located by the subId string passed in locator, if found.
 */

oj.Test.domNodeForLocator = function (locator) {
  var locObj = locator;

  if (oj.StringUtils.isString(locator)) {
    var locStr =
    /** @type {string} */
    locator;

    try {
      locObj = JSON.parse(locStr);
    } catch (e) {
      return null;
    }
  }

  if (locObj && locObj.element) {
    var element = $(locObj.element);

    if (element && element.length > 0) {
      delete locObj.element;
      var id =
      /** @type {Object} */
      locObj;
      return oj.Components.getNodeBySubId(element[0], id);
    }
  }

  return null;
};
/**
 * @return {number} total number of open popups
 * @export
 * @since 1.1.0
 */


oj.Test.getOpenPopupCount = function () {
  return oj.ZOrderUtils.getOpenPopupCount();
};
/**
 * Returns a jQuery set of popup root elements that are open and actively
 * managed by the popup framework.
 *
 * @return {!jQuery}
 * @export
 * @since 1.1.0
 */


oj.Test.findOpenPopups = function () {
  return oj.ZOrderUtils.findOpenPopups();
};
/**
 * Utility used for testing. Compares two jQuery singleton wappered elements
 * determining which element has the greatest stacking context.
 *
 * @export
 * @param {jQuery} el1 first element to compare
 * @param {jQuery} el2 second element to compare
 * @return {number} 0 if elements have the same stacking context;
 *                  1 if the first element has a greater stacking context;
 *                 -1 when the second element has a greater stacking context;
 * @since 1.1.0
 */


oj.Test.compareStackingContexts = function (el1, el2) {
  return oj.ZOrderUtils.compareStackingContexts(el1, el2);
};


// override jQuery's cleanData method to bypass cleanup of custom elements and composites
$.cleanData = function (orig) {
  return function (elems) {
    var nonCustomElements = [];

    for (var i = 0; i < elems.length; i++) {
      var elem = elems[i];

      if (elem == null) {
        break;
      } // Skip cleaning any elements that are custom elements or are created by a custom element


      var bSkip = false;

      var constr = oj.Components.__GetWidgetConstructor(elem);

      if (constr) {
        bSkip = constr('instance')._IsCustomElement();

        if (!bSkip) {
          var parent = oj.Components.getComponentElementByNode(elem);
          bSkip = parent && oj.BaseCustomElementBridge.getRegistered(parent.tagName);
        }
      }

      if (!bSkip) {
        nonCustomElements.push(elem);
      }
    }

    if (nonCustomElements.length > 0) {
      orig(nonCustomElements);
    }
  };
}($.cleanData);

  return oj.Components;
});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojjquery-hammer',['ojs/ojcore', 'jquery', 'hammerjs', 'ojs/ojlogger'], function(oj, $, Hammer, Logger) 
{
  "use strict";

// Forked from Version 2.0.0 of https://github.com/hammerjs/jquery.hammer.js, retrieved 2/4/2015.

/* global Hammer:false, Logger:false */
if (Hammer) {
  /** @export */
  $.fn.ojHammer = function (options) {
    switch (options) {
      // $(...).ojHammer("instance") returns the Hammer instance previously instantiated on this element via $(...).ojHammer(options), or undefined if none.
      case 'instance':
        return this.data('ojHammer');
      // $(...).ojHammer("destroy") destroys the Hammer instance and removes it from the node's data store.

      case 'destroy':
        return this.each(function () {
          var $el = $(this);
          var hammer = $el.data('ojHammer');

          if (hammer) {
            hammer.destroy();
            $el.removeData('ojHammer');
          }
        });

      default:
        // $(...).ojHammer(options) instantiates Hammer on this element, and stores it for later retrieval via $(...).ojHammer("instance")
        return this.each(function () {
          var $el = $(this);

          if (!$el.data('ojHammer')) {
            $el.data('ojHammer', new Hammer.Manager($el[0], options));
          }
        });
    }
  }; // extend the emit method to also trigger jQuery events


  Hammer.Manager.prototype.emit = function (originalEmit) {
    return function (type, data) {
      originalEmit.call(this, type, data);
      $(this.element).trigger({
        type: type,
        gesture: data
      });
    };
  }(Hammer.Manager.prototype.emit);
} else {
  Logger.warn('Hammer jQuery extension loaded without Hammer.');
}

});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojoffcanvas',['ojs/ojcore', 'jquery', 'hammerjs', 'ojs/ojcontext', 'ojs/ojthemeutils', 'ojs/ojcomponentcore', 'ojs/ojlogger', 'ojs/ojjquery-hammer', ],
/*
* @param {Object} oj 
* @param {jQuery} $
* @param {Object} Hammer
*/
function(oj, $, Hammer, Context, ThemeUtils, Components, Logger) 
{
  "use strict";


/* global Hammer, Promise, Components:false, Logger:false, ThemeUtils:false, Context:false */

/**
 * @namespace oj.OffcanvasUtils
 * @since 1.1.0
 * @export
 * @ojtsmodule
 * @hideconstructor
 *
 *
 * @classdesc
 * This class provides functions used for controlling offcanvas regions.  Offcanvas regions can be used in either static (simply displaying and hiding in response to user interactions) or responsive (using media queries to dynamically move application content between the main viewport and offcanvas regions) contexts.  The OffcanvasUtils methods can be used to directly control the display of an offcanvas region in both the static and responsive cases.
 *
 * <p>Note for performance reasons, if the Offcanvas content is expensive to render, you should wrap it in an <code class="prettyprint">oj-defer</code> element (API doc {@link oj.ojDefer}) to defer the rendering of that content.<br/>
 * See the <a href="../jetCookbook.html?component=offcanvas&demo=deferredRendering">Offcanvas - Deferred Rendering</a> demo for an example.</p>
 *
 * <h3 id="events-section">
 *   Events
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#events-section"></a>
 * </h3>
 *
 *
 * <table class="generic-table events-table">
 *   <thead>
 *     <tr>
 *       <th>Event</th>
 *       <th>Description</th>
 *       <th>Example</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td>beforeClose</td>
 *       <td>Triggered immediately before the offcanvas is closed. It can be canceled to prevent the content from closing by returning a false in the event listener.</td>
*       <td>$(".selector").on("ojbeforeclose", function(event, offcanvas) {});</td>
 *     </tr>
 *     <tr>
 *       <td>beforeOpen<br>
 *       <td>Triggered immediately before the offcanvas is open. It can be canceled to prevent the content from opening by returning a false in the event listener.</td>
*       <td>$(".selector").on("ojbeforeopen", function(event, offcanvas) {});</td>
 *     </tr>
 *     <tr>
 *       <td>close<br>
 *       <td>Triggered after the offcanvas has been closed.</td>
*       <td>$(".selector").on("ojclose", function(event, offcanvas) {});</td>
 *     </tr>
 *     <tr>
 *       <td>open<br>
 *       <td>Triggered after the offcanvas has been open (after animation completes).</td>
*       <td>$(".selector").on("ojopen", function(event, offcanvas) {});</td>
 *     </tr>
 *   </tbody>
 * </table>
 *
 * <h3 id="touch-section">
 *   Touch End User Information
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
 * </h3>
 *
 * {@ojinclude "name":"touchDoc"}
 *
 * <h3 id="keyboard-section">
 *   Keyboard End User Information
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 *
 * {@ojinclude "name":"keyboardDoc"}
 *
 */
oj.OffcanvasUtils = {}; // mapping variable definition, used in a no-require environment. Maps the oj.OffcanvasUtils object to the name used in the require callback.
// eslint-disable-next-line no-unused-vars

var OffcanvasUtils = oj.OffcanvasUtils;
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */

oj.OffcanvasUtils._DATA_EDGE_KEY = 'oj-offcanvasEdge';
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */

oj.OffcanvasUtils._DATA_OFFCANVAS_KEY = 'oj-offcanvas';
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */

oj.OffcanvasUtils._DATA_MEDIA_QUERY_KEY = 'oj-mediaQueryListener';
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */

oj.OffcanvasUtils._DATA_HAMMER_KEY = 'oj-offcanvasHammer';
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */

oj.OffcanvasUtils.SELECTOR_KEY = 'selector';
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */

oj.OffcanvasUtils.CONTENT_KEY = 'content';
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */

oj.OffcanvasUtils.EDGE_START = 'start';
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */

oj.OffcanvasUtils.EDGE_END = 'end';
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */

oj.OffcanvasUtils.EDGE_TOP = 'top';
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */

oj.OffcanvasUtils.EDGE_BOTTOM = 'bottom';
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */

oj.OffcanvasUtils.DISPLAY_MODE_KEY = 'displayMode';
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */

oj.OffcanvasUtils.DISPLAY_MODE_PUSH = 'push';
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */

oj.OffcanvasUtils.DISPLAY_MODE_OVERLAY = 'overlay';
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */

oj.OffcanvasUtils.DISPLAY_MODE_REFLOW = 'reflow';
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */

oj.OffcanvasUtils.MODALITY_KEY = 'modality';
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */

oj.OffcanvasUtils.MODALITY_NONE = 'none';
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */

oj.OffcanvasUtils.MODALITY_MODAL = 'modal';
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */

oj.OffcanvasUtils.DISMISS_HANDLER_KEY = '_dismissHandler';
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */

oj.OffcanvasUtils.OPEN_PROMISE_KEY = '_openPromise';
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */

oj.OffcanvasUtils.CLOSE_PROMISE_KEY = '_closePromise';
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */

oj.OffcanvasUtils.GLASS_PANE_KEY = '_glassPane';
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */

oj.OffcanvasUtils.SURROGATE_KEY = '_surrogate';
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */

oj.OffcanvasUtils.ANIMATE_WRAPPER_KEY = '_animateWrapper';
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */

oj.OffcanvasUtils.ANIMATE_KEY = '_animate';
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */

oj.OffcanvasUtils.SURROGATE_ATTR = 'data-oj-offcanvas-surrogate-id';
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */

oj.OffcanvasUtils.OUTER_WRAPPER_SELECTOR = 'oj-offcanvas-outer-wrapper';
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */

oj.OffcanvasUtils.OPEN_SELECTOR = 'oj-offcanvas-open';
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */

oj.OffcanvasUtils.TRANSITION_SELECTOR = 'oj-offcanvas-transition';
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */

oj.OffcanvasUtils.REFLOW_WRAPPER_SELECTOR = 'oj-offcanvas-pin';
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */

oj.OffcanvasUtils.REFLOW_TRANSITION_SELECTOR = 'oj-offcanvas-pin-transition';
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */

oj.OffcanvasUtils.GLASSPANE_SELECTOR = 'oj-offcanvas-glasspane';
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */

oj.OffcanvasUtils.GLASSPANE_DIM_SELECTOR = 'oj-offcanvas-glasspane-dim';
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */

oj.OffcanvasUtils.VETO_BEFOREOPEN_MSG = 'ojbeforeopen veto';
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */

oj.OffcanvasUtils.VETO_BEFORECLOSE_MSG = 'ojbeforeclose veto';
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */

oj.OffcanvasUtils._shiftSelector = {
  start: 'oj-offcanvas-shift-start',
  end: 'oj-offcanvas-shift-end',
  top: 'oj-offcanvas-shift-down',
  bottom: 'oj-offcanvas-shift-up'
};
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */

oj.OffcanvasUtils._drawerSelector = {
  start: 'oj-offcanvas-start',
  end: 'oj-offcanvas-end',
  top: 'oj-offcanvas-top',
  bottom: 'oj-offcanvas-bottom'
};
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */

oj.OffcanvasUtils._getDisplayMode = function (offcanvas) {
  var displayMode = offcanvas[oj.OffcanvasUtils.DISPLAY_MODE_KEY];

  if (displayMode !== oj.OffcanvasUtils.DISPLAY_MODE_OVERLAY && displayMode !== oj.OffcanvasUtils.DISPLAY_MODE_PUSH && displayMode !== oj.OffcanvasUtils.DISPLAY_MODE_REFLOW) {
    // default displayMode in iOS is push and in android and windows are overlay
    displayMode = (ThemeUtils.parseJSONFromFontFamily('oj-offcanvas-option-defaults') || {}).displayMode;
  }

  return displayMode;
};
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */


oj.OffcanvasUtils._getDrawer = function (offcanvas) {
  return $(offcanvas[oj.OffcanvasUtils.SELECTOR_KEY]);
};
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */


oj.OffcanvasUtils._isModal = function (offcanvas) {
  return offcanvas[oj.OffcanvasUtils.MODALITY_KEY] === oj.OffcanvasUtils.MODALITY_MODAL;
};
/**
 * Returns whether the drawer is currently open.
 * @memberof oj.OffcanvasUtils
 * @private
 */


oj.OffcanvasUtils._isOpen = function (drawer) {
  return drawer.hasClass(oj.OffcanvasUtils.OPEN_SELECTOR);
};
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */


oj.OffcanvasUtils._getOuterWrapper = function (drawer) {
  return drawer.closest('.' + oj.OffcanvasUtils.OUTER_WRAPPER_SELECTOR);
}; // selector
// displayMode

/**
 * @memberof oj.OffcanvasUtils
 * @private
 */


oj.OffcanvasUtils._getAnimateWrapper = function (offcanvas) {
  var drawer = oj.OffcanvasUtils._getDrawer(offcanvas);

  if (oj.OffcanvasUtils._noInnerWrapper(offcanvas) || offcanvas[oj.OffcanvasUtils.DISPLAY_MODE_KEY] === oj.OffcanvasUtils.DISPLAY_MODE_OVERLAY) {
    return drawer;
  }

  if (offcanvas[oj.OffcanvasUtils.ANIMATE_WRAPPER_KEY]) {
    return drawer.closest('.' + offcanvas[oj.OffcanvasUtils.ANIMATE_WRAPPER_KEY]);
  }

  return drawer.parent();
};
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */


oj.OffcanvasUtils._getShiftSelector = function (edge) {
  var selector = oj.OffcanvasUtils._shiftSelector[edge];

  if (!selector) {
    throw new Error('Invalid edge: ' + edge);
  }

  return selector;
};
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */


oj.OffcanvasUtils._isRTL = function () {
  return oj.DomUtils.getReadingDirection() === 'rtl';
};
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */


oj.OffcanvasUtils._setTransform = function (wrapper, transform) {
  wrapper.css({
    '-webkit-transform': transform,
    transform: transform
  });
};
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */


oj.OffcanvasUtils._getTranslationX = function (edge, width, negate) {
  var minus = edge === oj.OffcanvasUtils.EDGE_END;

  if (oj.OffcanvasUtils._isRTL() || negate) {
    minus = !minus;
  }

  return 'translate3d(' + (minus ? '-' : '') + width + ', 0, 0)';
};
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */


oj.OffcanvasUtils._setTranslationX = function (wrapper, edge, width) {
  oj.OffcanvasUtils._setTransform(wrapper, oj.OffcanvasUtils._getTranslationX(edge, width, false));
};
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */


oj.OffcanvasUtils._getTranslationY = function (edge, height) {
  var minus = edge === oj.OffcanvasUtils.EDGE_BOTTOM ? '-' : '';
  return 'translate3d(0, ' + minus + height + ', 0)';
};
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */


oj.OffcanvasUtils._setTranslationY = function (wrapper, edge, height) {
  oj.OffcanvasUtils._setTransform(wrapper, oj.OffcanvasUtils._getTranslationY(edge, height));
};
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */


oj.OffcanvasUtils._getTranslationY2 = function (height, negate) {
  var minus = negate ? '-' : '';
  return 'translate3d(0, ' + minus + height + ', 0)';
};
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */


oj.OffcanvasUtils._setAnimateClass = function (offcanvas, drawer, $main, dtranslation, mtranslation) {
  drawer.addClass(oj.OffcanvasUtils.TRANSITION_SELECTOR);

  oj.OffcanvasUtils._setTransform(drawer, dtranslation);

  $main.addClass(oj.OffcanvasUtils.TRANSITION_SELECTOR);

  oj.OffcanvasUtils._setTransform($main, mtranslation);
};
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */


oj.OffcanvasUtils._saveEdge = function (offcanvas) {
  var edge = offcanvas.edge;

  var drawer = oj.OffcanvasUtils._getDrawer(offcanvas);

  if (!edge || !edge.length) {
    if (drawer.hasClass('oj-offcanvas-start')) {
      edge = oj.OffcanvasUtils.EDGE_START;
    } else if (drawer.hasClass('oj-offcanvas-end')) {
      edge = oj.OffcanvasUtils.EDGE_END;
    } else if (drawer.hasClass('oj-offcanvas-top')) {
      edge = oj.OffcanvasUtils.EDGE_TOP;
    } else if (drawer.hasClass('oj-offcanvas-bottom')) {
      edge = oj.OffcanvasUtils.EDGE_BOTTOM;
    } else {
      // default to start edge
      edge = oj.OffcanvasUtils.EDGE_START;
    }
  }

  $.data(drawer[0], oj.OffcanvasUtils._DATA_EDGE_KEY, edge);
  return edge;
};
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */


oj.OffcanvasUtils._getEdge = function (drawer) {
  return $.data(drawer[0], oj.OffcanvasUtils._DATA_EDGE_KEY);
}; //
// selector
// edge
// displayMode

/**
 * This method is called right before open and after close animation
 * @memberof oj.OffcanvasUtils
 * @private
 */


oj.OffcanvasUtils._toggleClass = function (offcanvas, wrapper, isOpen) {
  var displayMode = offcanvas[oj.OffcanvasUtils.DISPLAY_MODE_KEY];

  var drawer = oj.OffcanvasUtils._getDrawer(offcanvas);

  var drawerClass = oj.OffcanvasUtils.OPEN_SELECTOR;
  var wrapperClass = displayMode === oj.OffcanvasUtils.DISPLAY_MODE_OVERLAY ? oj.OffcanvasUtils.TRANSITION_SELECTOR + ' oj-offcanvas-overlay' : oj.OffcanvasUtils.TRANSITION_SELECTOR; // toggle offcanvas and inner wrapper classes

  if (isOpen) {
    drawer.addClass(drawerClass);

    if (offcanvas[oj.OffcanvasUtils.ANIMATE_KEY] === undefined) {
      wrapper.addClass(wrapperClass);
    }
  } else {
    // remove oj-focus-highlight
    if (offcanvas.makeFocusable) {
      oj.DomUtils.makeFocusable({
        element: drawer,
        remove: true
      });
    } // restore the original tabindex


    var oTabIndex = offcanvas.tabindex;

    if (oTabIndex === undefined) {
      drawer.removeAttr('tabindex');
    } else {
      drawer.attr('tabindex', oTabIndex);
    }

    drawer.removeClass(drawerClass);
    wrapper.removeClass(wrapperClass);
  }
};
/**
 * Focus is automatically moved to the first item that matches the following:
 * The first element within the offcanvas with the autofocus attribute
 * The first :tabbable element inside the offcanvas
 * The offcanvas itself
 *
 * @memberof oj.OffcanvasUtils
 * @private
 */


oj.OffcanvasUtils._setFocus = function (_offcanvas) {
  var offcanvas = _offcanvas;

  var drawer = oj.OffcanvasUtils._getDrawer(offcanvas);

  var focusables = drawer.find('[autofocus]');
  var focusNode;

  if (focusables.length === 0) {
    focusables = drawer.find(':tabbable');
  }

  if (focusables.length === 0) {
    var oTabIndex = drawer.attr('tabindex');

    if (oTabIndex !== undefined) {
      // save the original tabindex
      offcanvas.tabindex = oTabIndex;
    } // set tabIndex so the div is focusable


    drawer.attr('tabindex', '-1');
    focusNode = drawer;
    oj.DomUtils.makeFocusable({
      element: drawer,
      applyHighlight: true
    });
    offcanvas.makeFocusable = true;
  } else {
    focusNode = focusables[0];
  }

  oj.FocusUtils.focusElement(focusNode);
};
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */


oj.OffcanvasUtils._isAutoDismiss = function (offcanvas) {
  return offcanvas.autoDismiss !== 'none';
};
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */


oj.OffcanvasUtils._calcTransitionTime = function ($elem) {
  var propertyArray = $elem.css('transitionProperty').split(',');
  var delayArray = $elem.css('transitionDelay').split(',');
  var durationArray = $elem.css('transitionDuration').split(',');
  var maxTime = 0;

  for (var i = 0; i < propertyArray.length; i++) {
    var duration = durationArray[i % durationArray.length];
    var durationMs = duration.indexOf('ms') > -1 ? parseFloat(duration) : parseFloat(duration) * 1000;

    if (durationMs > 0) {
      var delay = delayArray[i % delayArray.length];
      var delayMs = delay.indexOf('ms') > -1 ? parseFloat(delay) : parseFloat(delay) * 1000;
      maxTime = Math.max(maxTime, delayMs + durationMs);
    }
  }

  return maxTime + 100;
};
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */


oj.OffcanvasUtils._onTransitionEnd = function (target, handler) {
  var endEvents = 'transitionend.oc webkitTransitionEnd.oc';
  var transitionTimer;

  var listener = function listener() {
    if (transitionTimer) {
      clearTimeout(transitionTimer);
      transitionTimer = undefined;
    } // remove handler


    target.off(endEvents, listener);
    handler(target);
  }; // add transition end listener


  target.on(endEvents, listener);
  transitionTimer = setTimeout(listener, oj.OffcanvasUtils._calcTransitionTime(target));
};
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */


oj.OffcanvasUtils._closeWithCatch = function (offcanvas) {
  //  - offcanvas: error occurs when you veto the ojbeforeclose event
  oj.OffcanvasUtils.close(offcanvas).catch(function (reason) {
    Logger.warn('Offcancas close failed: ' + reason);
  });
}; // check offcanvas.autoDismiss
// update offcanvas.dismisHandler

/**
 * @memberof oj.OffcanvasUtils
 * @private
 */


oj.OffcanvasUtils._registerCloseHandler = function (_offcanvas) {
  var offcanvas = _offcanvas; // unregister the old handler if exists

  oj.OffcanvasUtils._unregisterCloseHandler(offcanvas);

  if (oj.OffcanvasUtils._isAutoDismiss(offcanvas)) {
    var drawer = oj.OffcanvasUtils._getDrawer(offcanvas); // save dismisHandler


    var dismisHandler = function dismisHandler(event) {
      var target = event.target; // Ignore mouse events on the scrollbar. FF and Chrome, raises focus events on the
      // scroll container too.

      if (oj.DomUtils.isChromeEvent(event) || event.type === 'focus' && !$(target).is(':focusable')) {
        return;
      }

      var key = $.data(drawer[0], oj.OffcanvasUtils._DATA_OFFCANVAS_KEY);

      if (key == null) {
        // offcanvas already destroyed, unregister the handler
        oj.OffcanvasUtils._unregisterCloseHandler(offcanvas);

        return;
      } // if event target is not the offcanvas dom subtrees, dismiss it


      if (!oj.DomUtils.isLogicalAncestorOrSelf(drawer[0], target)) {
        oj.OffcanvasUtils._closeWithCatch(offcanvas);
      }
    };

    offcanvas[oj.OffcanvasUtils.DISMISS_HANDLER_KEY] = dismisHandler;
    var documentElement = document.documentElement;

    if (oj.DomUtils.isTouchSupported()) {
      documentElement.addEventListener('touchstart', dismisHandler, {
        passive: true,
        capture: true
      });
    }

    documentElement.addEventListener('mousedown', dismisHandler, true);
    documentElement.addEventListener('focus', dismisHandler, true);
  } // register swipe handler


  oj.OffcanvasUtils._registerSwipeHandler(offcanvas);
}; // check offcanvas.autoDismiss
// update offcanvas.dismisHandler

/**
 * @memberof oj.OffcanvasUtils
 * @private
 */


oj.OffcanvasUtils._unregisterCloseHandler = function (_offcanvas) {
  var offcanvas = _offcanvas;
  var dismisHandler = offcanvas[oj.OffcanvasUtils.DISMISS_HANDLER_KEY];

  if (dismisHandler) {
    var documentElement = document.documentElement;

    if (oj.DomUtils.isTouchSupported()) {
      documentElement.removeEventListener('touchstart', dismisHandler, {
        passive: true,
        capture: true
      });
    }

    documentElement.removeEventListener('mousedown', dismisHandler, true);
    documentElement.removeEventListener('focus', dismisHandler, true);
    delete offcanvas[oj.OffcanvasUtils.DISMISS_HANDLER_KEY];
    offcanvas[oj.OffcanvasUtils.DISMISS_HANDLER_KEY] = null;
  } // unregister swipe handler


  oj.OffcanvasUtils._unregisterSwipeHandler(offcanvas);
};
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */


oj.OffcanvasUtils._registerSwipeHandler = function (_offcanvas) {
  if (oj.DomUtils.isTouchSupported()) {
    var offcanvas = _offcanvas;
    var selector = offcanvas[oj.OffcanvasUtils.SELECTOR_KEY];
    var drawer = $(selector);

    var edge = oj.OffcanvasUtils._getEdge(drawer);

    var swipeEvent;
    var options;
    var drawerHammer;

    if (edge === oj.OffcanvasUtils.EDGE_START && !oj.OffcanvasUtils._isRTL() || edge === oj.OffcanvasUtils.EDGE_END && oj.OffcanvasUtils._isRTL()) {
      options = {
        recognizers: [[Hammer.Swipe, {
          direction: Hammer.DIRECTION_LEFT
        }]]
      };
      swipeEvent = 'swipeleft';
    } else if (edge === oj.OffcanvasUtils.EDGE_START && oj.OffcanvasUtils._isRTL() || edge === oj.OffcanvasUtils.EDGE_END && !oj.OffcanvasUtils._isRTL()) {
      options = {
        recognizers: [[Hammer.Swipe, {
          direction: Hammer.DIRECTION_RIGHT
        }]]
      };
      swipeEvent = 'swiperight';
    } else if (edge === oj.OffcanvasUtils.EDGE_TOP) {
      options = {
        recognizers: [[Hammer.Swipe, {
          direction: Hammer.DIRECTION_UP
        }]]
      };
      swipeEvent = 'swipeup';
    } else if (edge === oj.OffcanvasUtils.EDGE_BOTTOM) {
      options = {
        recognizers: [[Hammer.Swipe, {
          direction: Hammer.DIRECTION_DOWN
        }]]
      };
      swipeEvent = 'swipedown';
    }

    drawerHammer = drawer.ojHammer(options).on(swipeEvent, function (event) {
      if (event.target === drawer[0]) {
        event.preventDefault();

        oj.OffcanvasUtils._closeWithCatch(offcanvas);
      }
    }); // keep the hammer in the offcanvas jquery data

    $.data($(selector)[0], oj.OffcanvasUtils._DATA_HAMMER_KEY, {
      event: swipeEvent,
      hammer: drawerHammer
    });
  }
};
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */


oj.OffcanvasUtils._unregisterSwipeHandler = function (offcanvas) {
  var drawer = oj.OffcanvasUtils._getDrawer(offcanvas);

  if (drawer.length > 0) {
    var dHammer = $.data(drawer[0], oj.OffcanvasUtils._DATA_HAMMER_KEY);

    if (dHammer) {
      dHammer.hammer.off(dHammer.event);
    }
  }
};
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */


oj.OffcanvasUtils._isFixed = function (drawer) {
  return oj.OffcanvasUtils._getOuterWrapper(drawer).hasClass('oj-offcanvas-page');
};
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */


oj.OffcanvasUtils._isReflow = function (offcanvas) {
  return offcanvas[oj.OffcanvasUtils.DISPLAY_MODE_KEY] === oj.OffcanvasUtils.DISPLAY_MODE_REFLOW;
};
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */


oj.OffcanvasUtils._noInnerWrapper = function (offcanvas) {
  return offcanvas[oj.OffcanvasUtils.CONTENT_KEY] || oj.OffcanvasUtils._isFixed(oj.OffcanvasUtils._getDrawer(offcanvas)) || oj.OffcanvasUtils._isReflow(offcanvas);
};
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */


oj.OffcanvasUtils._toggleOuterWrapper = function (offcanvas, drawer, test) {
  var edge = oj.OffcanvasUtils._getEdge(drawer);

  var shiftSelector = oj.OffcanvasUtils._getShiftSelector(edge);

  var outerWrapper = oj.OffcanvasUtils._getOuterWrapper(drawer);

  oj.Assert.assertPrototype(outerWrapper, $);
  var isOpen = outerWrapper.hasClass(shiftSelector);

  if (!test) {
    outerWrapper.toggleClass(shiftSelector, !isOpen);
  }

  return isOpen;
};
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */


oj.OffcanvasUtils._afterCloseHandler = function (offcanvas) {
  var wrapper = oj.OffcanvasUtils._getAnimateWrapper(offcanvas); // bail if pan to reveal is in progress


  if (wrapper.get(0).style.transform !== '') {
    return;
  } //  - customsyntax memory leak: offcanvas needs to implement _disconnected
  // unregister dismiss handler


  oj.OffcanvasUtils._unregisterCloseHandler(offcanvas);

  var drawer = oj.OffcanvasUtils._getDrawer(offcanvas);

  var isReflow = oj.OffcanvasUtils._isReflow(offcanvas); // validate offcanvas


  var curOffcanvas = null;

  try {
    curOffcanvas = $.data(drawer[0], oj.OffcanvasUtils._DATA_OFFCANVAS_KEY);
  } catch (e) {// Throw away error.
  }

  if (curOffcanvas !== offcanvas) {
    return;
  } // After animation, set display:none and remove transition class


  if (isReflow) {
    drawer.removeClass(oj.OffcanvasUtils.OPEN_SELECTOR + ' ' + oj.OffcanvasUtils.REFLOW_TRANSITION_SELECTOR);
  } else {
    oj.OffcanvasUtils._toggleClass(offcanvas, wrapper, false);
  } // Remove the glassPane if offcanvas is modal


  oj.OffcanvasUtils._removeModality(offcanvas);

  if (isReflow) {
    oj.OffcanvasUtils._getOuterWrapper(drawer).removeClass(oj.OffcanvasUtils.REFLOW_WRAPPER_SELECTOR);
  } // fire after close event


  drawer.trigger('ojclose', offcanvas); // remove data associate with the offcanvas

  $.removeData(drawer[0], oj.OffcanvasUtils._DATA_OFFCANVAS_KEY);
};
/**
 * Set whether the offcanvas is fixed inside the viewport
 * @memberof oj.OffcanvasUtils
 * @private
 */


oj.OffcanvasUtils._setVisible = function (selector, _visible, edge) {
  var drawer = $(selector);
  var visible = !!_visible; // close the offcanvas without animation if it's open

  if (visible && oj.OffcanvasUtils._isOpen(drawer)) {
    // hide offcanvas without animation
    oj.OffcanvasUtils._close(selector, false);
  } // toggle "oj-offcanvas-" + edge class


  drawer.toggleClass(oj.OffcanvasUtils._drawerSelector[edge], !visible);
};
/**
 * Setup offcanvas for the responsive layout.
 * This method adds a listener based on the media query specified in offcanvas.query.
 * When the media query matches the listener is called and offcanvas behavior is removed.
 * When the media query does not match the listener is called and off canvas behavior is added.
 *
 * @export
 * @param {Object} offcanvas An Object contains the properties in the following table.
 * @property {string} offcanvas.selector Document selector identifying the offcanvas element
 * @property {('start'|'end'|'top'|'bottom')=} offcanvas.edge the edge of the offcanvas, valid values are start, end, top, bottom. This property is optional if the offcanvas element has a "oj-offcanvas-" + <edge> class specified.
 * @property {string|null} offcanvas.query the media query determine when the offcanvas is fixed inside the viewport.
 * @return {void}
 * @memberof oj.OffcanvasUtils
 *
 * @see #tearDownResponsive
 *
 * @example <caption>Setup the offcanvas:</caption>
 *    var offcanvas = {
 *      "selector": "#startDrawer",
 *      "edge": "start",
 *      "query": oj.ResponsiveUtils.getFrameworkQuery(oj.ResponsiveUtils.FRAMEWORK_QUERY_KEY.LG_UP)
 *    };
 *
 * oj.OffcanvasUtils.setupResponsive(offcanvas);
 *
 */


oj.OffcanvasUtils.setupResponsive = function (offcanvas) {
  var mqs = offcanvas.query;

  if (mqs !== null) {
    var selector = offcanvas[oj.OffcanvasUtils.SELECTOR_KEY];
    var query = window.matchMedia(mqs); // save the edge

    var edge = oj.OffcanvasUtils._saveEdge(offcanvas);

    var mqListener = function mqListener(event) {
      // when event.matches=true fix the offcanvas inside the visible viewport.
      oj.OffcanvasUtils._setVisible(selector, event.matches, edge);
    };

    query.addListener(mqListener);

    oj.OffcanvasUtils._setVisible(selector, query.matches, edge); // keep the listener in the offcanvas jquery data


    $.data($(selector)[0], oj.OffcanvasUtils._DATA_MEDIA_QUERY_KEY, {
      mqList: query,
      mqListener: mqListener
    });
  }
};
/**
 * Removes the listener that was added in setupResponsive.  Page authors should call tearDownResponsive when the offcanvas is no longer needed.
 *
 * @export
 * @param {Object} offcanvas An Object contains the properties in the following table.
 * @property {string} offcanvas.selector Document selector identifying the offcanvas element
 * @return {void}
 * @memberof oj.OffcanvasUtils
 *
 * @see #setupResponsive
 *
 * @example <caption>TearDown the offcanvas:</caption>
 *    var offcanvas = {
 *      "selector": "#startDrawer"
 *    };
 *
 * oj.OffcanvasUtils.tearDownResponsive(offcanvas);
 *
 */


oj.OffcanvasUtils.tearDownResponsive = function (offcanvas) {
  var drawer = oj.OffcanvasUtils._getDrawer(offcanvas);

  var mql = $.data(drawer[0], oj.OffcanvasUtils._DATA_MEDIA_QUERY_KEY);

  if (mql) {
    mql.mqList.removeListener(mql.mqListener);
    $.removeData(drawer[0], oj.OffcanvasUtils._DATA_MEDIA_QUERY_KEY);
  }
};
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */


oj.OffcanvasUtils._openPush = function (offcanvas, resolve, reject, edge) {
  var drawer = oj.OffcanvasUtils._getDrawer(offcanvas);

  var $main = $(offcanvas[oj.OffcanvasUtils.CONTENT_KEY]);
  oj.Assert.assertPrototype($main, $); // since drawer and main are animated seperately,
  // only resolve true when both transitions are ended

  var pending = true;
  var size = offcanvas.size;
  var translation; // transition end handler

  var endHandler = function endHandler($elem) {
    // After animation, remove transition class
    $elem.removeClass(oj.OffcanvasUtils.TRANSITION_SELECTOR);

    if (pending) {
      pending = false;
    } else {
      //  - opening offcanvas automatically scrolls to the top
      //  - perf: fif jank: nav drawer and list view items
      // Moving the focus before animation works fine with the "start" and "top" drawers, but not
      // with the "end" and "bottom" drawers. (There may be a browser bug causing problems)
      if (edge === oj.OffcanvasUtils.EDGE_END || edge === oj.OffcanvasUtils.EDGE_BOTTOM) {
        oj.OffcanvasUtils._setFocus(offcanvas);
      } // fire after open event


      drawer.trigger('ojopen', offcanvas); //  - push and overlay demos don't work in ie11
      // register dismiss handler as late as possible because IE raises focus event
      // on the launcher that will close the offcanvas if autoDismiss is true

      oj.OffcanvasUtils._registerCloseHandler(offcanvas);

      resolve(true);
    }
  }; // set display block to get size of offcanvas


  drawer.addClass(oj.OffcanvasUtils.OPEN_SELECTOR); // set translationX or Y

  window.setTimeout(function () {
    // if size is not specified, outerWidth/outerHeight is used
    if (edge === oj.OffcanvasUtils.EDGE_START || edge === oj.OffcanvasUtils.EDGE_END) {
      if (size === undefined) {
        size = drawer.outerWidth(true) + 'px';
      } //  - offcanvas: drawer push animation is incorrect in rtl mode
      //      oj.OffcanvasUtils._setTransform(drawer,
      //                                      oj.OffcanvasUtils._getTranslationX(edge, size, true));


      translation = oj.OffcanvasUtils._getTranslationX(edge, size, false);
    } else {
      if (size === undefined) {
        size = drawer.outerHeight(true) + 'px';
      }

      oj.OffcanvasUtils._setTransform(drawer, oj.OffcanvasUtils._getTranslationY2(size, edge === oj.OffcanvasUtils.EDGE_TOP));

      translation = oj.OffcanvasUtils._getTranslationY2(size, edge !== oj.OffcanvasUtils.EDGE_TOP);
    } // before animation


    window.setTimeout(function () {
      // add transition class
      oj.OffcanvasUtils._setAnimateClass(offcanvas, drawer, $main, 'translate3d(0, 0, 0)', translation);

      oj.OffcanvasUtils._toggleOuterWrapper(offcanvas, drawer, false); // add transition end listener


      oj.OffcanvasUtils._onTransitionEnd($main, endHandler);

      oj.OffcanvasUtils._onTransitionEnd(drawer, endHandler);
    }, 0); // before animation
  }, 0); // set translationX or Y
  // insert a glassPane if offcanvas is modal

  oj.OffcanvasUtils._applyModality(offcanvas, drawer); //  - opening offcanvas automatically scrolls to the top
  //  - perf: fif jank: nav drawer and list view items
  // Moving the focus before animation works fine with the "start" and "top" drawers, but not with
  // the "end" and "bottom" drawers. (There may be a browser bug causing problems)


  if (edge === oj.OffcanvasUtils.EDGE_START || edge === oj.OffcanvasUtils.EDGE_TOP) {
    oj.OffcanvasUtils._setFocus(offcanvas);
  }
};
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */


oj.OffcanvasUtils._openOverlay = function (offcanvas, resolve, reject, edge) {
  var drawer = oj.OffcanvasUtils._getDrawer(offcanvas); // Before animation, remove display:none and add transition class


  oj.OffcanvasUtils._toggleClass(offcanvas, drawer, true);

  var size = offcanvas.size;

  if (size) {
    if (edge === oj.OffcanvasUtils.EDGE_START || edge === oj.OffcanvasUtils.EDGE_END) {
      oj.OffcanvasUtils._setTransform(drawer, oj.OffcanvasUtils._getTranslationX(edge, size, true));
    } else {
      oj.OffcanvasUtils._setTransform(drawer, oj.OffcanvasUtils._getTranslationY(edge, size));
    }
  } // show the drawer


  window.setTimeout(function () {
    oj.OffcanvasUtils._toggleOuterWrapper(offcanvas, drawer, false);
  }, 20); // chrome is fine with 0ms but FF needs ~10ms or it wont animate
  // insert a glassPane if offcanvas is modal

  oj.OffcanvasUtils._applyModality(offcanvas, drawer); //  - opening offcanvas automatically scrolls to the top
  //  - perf: fif jank: nav drawer and list view items
  // Moving the focus before animation works fine with the "start" and "top" drawers, but not with
  // the "end" and "bottom" drawers. (There may be a browser bug causing problems)


  if (edge === oj.OffcanvasUtils.EDGE_START || edge === oj.OffcanvasUtils.EDGE_TOP) {
    oj.OffcanvasUtils._setFocus(offcanvas);
  } // add transition end listener


  oj.OffcanvasUtils._onTransitionEnd(drawer, function () {
    // After animation, remove transition class
    drawer.removeClass(oj.OffcanvasUtils.TRANSITION_SELECTOR); //  - opening offcanvas automatically scrolls to the top
    //  - perf: fif jank: nav drawer and list view items
    // Moving the focus before animation works fine with the "start" and "top" drawers, but not
    // with the "end" and "bottom" drawers. (There may be a browser bug causing problems)

    if (edge === oj.OffcanvasUtils.EDGE_END || edge === oj.OffcanvasUtils.EDGE_BOTTOM) {
      oj.OffcanvasUtils._setFocus(offcanvas);
    } // fire after open event


    drawer.trigger('ojopen', offcanvas); //  - push and overlay demos don't work in ie11
    // register dismiss handler as late as possible because IE raises focus event
    // on the launcher that will close the offcanvas if autoDismiss is true

    oj.OffcanvasUtils._registerCloseHandler(offcanvas);

    resolve(true);
  });
};
/*
 * @memberof oj.OffcanvasUtils
 * @private

oj.OffcanvasUtils._openReflow = function (offcanvas, resolve, reject, edge) {
  var drawer = oj.OffcanvasUtils._getDrawer(offcanvas);
  var $main = $(offcanvas[oj.OffcanvasUtils.CONTENT_KEY]);
  oj.Assert.assertPrototype($main, $);

  var size = offcanvas.size;

  // set display block to get size of offcanvas
  drawer.addClass(oj.OffcanvasUtils.OPEN_SELECTOR);

  // set translationX
  window.setTimeout(function () {
    // if size is not specified, outerWidth is used
    if (size === undefined) {
      size = drawer.outerWidth(true) + 'px';
    }
    drawer.addClass(oj.OffcanvasUtils.REFLOW_TRANSITION_SELECTOR);

    // make the outer wrapper a flex layout
    oj.OffcanvasUtils._getOuterWrapper(drawer).addClass(oj.OffcanvasUtils.REFLOW_WRAPPER_SELECTOR);

    // clear transform only work if set style
    oj.OffcanvasUtils._setTransform(drawer, 'none');

    // animate on min-width
    window.setTimeout(function () {
      drawer.css('min-width', size);

      oj.OffcanvasUtils._toggleOuterWrapper(offcanvas, drawer, false);
    }, 10);
  }, 0);    // set translationX

  // insert a glassPane if offcanvas is modal
  oj.OffcanvasUtils._applyModality(offcanvas, drawer);

  //  - opening offcanvas automatically scrolls to the top
  //  - perf: fif jank: nav drawer and list view items
  // Moving the focus before animation works fine with the "start" and "top" drawers, but not with
  // the "end" and "bottom" drawers. (There may be a browser bug causing problems)
  if (edge === oj.OffcanvasUtils.EDGE_START || edge === oj.OffcanvasUtils.EDGE_TOP) {
    oj.OffcanvasUtils._setFocus(offcanvas);
  }

  // add transition end listener
  oj.OffcanvasUtils._onTransitionEnd(drawer,
    function () {
      // After animation, remove transition class
      drawer.removeClass(oj.OffcanvasUtils.TRANSITION_SELECTOR);

      //  - opening offcanvas automatically scrolls to the top
      //  - perf: fif jank: nav drawer and list view items
      // Moving the focus before animation works fine with the "start" and "top" drawers, but not
      // with the "end" and "bottom" drawers. (There may be a browser bug causing problems)
      if (edge === oj.OffcanvasUtils.EDGE_END || edge === oj.OffcanvasUtils.EDGE_BOTTOM) {
        oj.OffcanvasUtils._setFocus(offcanvas);
      }

      // fire after open event
      drawer.trigger('ojopen', offcanvas);

      //  - push and overlay demos don't work in ie11
      // register dismiss handler as late as possible because IE raises focus event
      // on the launcher that will close the offcanvas if autoDismiss is true
      oj.OffcanvasUtils._registerCloseHandler(offcanvas);

      resolve(true);
    });
};
 */

/**
 * @memberof oj.OffcanvasUtils
 * @private
 */


oj.OffcanvasUtils._closePush = function (offcanvas, resolve, reject, drawer, animation) {
  var $main = $(offcanvas[oj.OffcanvasUtils.CONTENT_KEY]); // since drawer and main are animated seperately,
  // only resolve true when both transitions are ended

  var pending = true; //  - issue in ojoffcanvas when used inside ojtabs

  var endHandler = function endHandler() {
    if (!pending) {
      // clear transform translation on $main
      $main.removeClass(oj.OffcanvasUtils.TRANSITION_SELECTOR);

      oj.OffcanvasUtils._setTransform($main, '');

      oj.OffcanvasUtils._afterCloseHandler(offcanvas);

      resolve(true);
    }

    pending = false;
  }; // clear transform


  oj.OffcanvasUtils._setTransform(drawer, '');

  oj.OffcanvasUtils._setTransform($main, '');

  oj.OffcanvasUtils._toggleOuterWrapper(offcanvas, drawer, false); // dim glassPane


  if (oj.OffcanvasUtils._isModal(offcanvas)) {
    offcanvas[oj.OffcanvasUtils.GLASS_PANE_KEY].removeClass(oj.OffcanvasUtils.GLASSPANE_DIM_SELECTOR);
  }

  if (animation) {
    // Before animation, add transition class
    $main.addClass(oj.OffcanvasUtils.TRANSITION_SELECTOR);
    drawer.addClass(oj.OffcanvasUtils.TRANSITION_SELECTOR); // add transition end listener

    oj.OffcanvasUtils._onTransitionEnd(drawer, endHandler);

    oj.OffcanvasUtils._onTransitionEnd($main, endHandler);
  } else {
    pending = false;
    endHandler();
  }
};
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */


oj.OffcanvasUtils._closeOverlay = function (offcanvas, resolve, reject, drawer, animation) {
  var endHandler = function endHandler() {
    oj.OffcanvasUtils._afterCloseHandler(offcanvas);

    resolve(true);
  }; // clear transform


  oj.OffcanvasUtils._toggleOuterWrapper(offcanvas, drawer, false); // dim glassPane


  if (oj.OffcanvasUtils._isModal(offcanvas)) {
    offcanvas[oj.OffcanvasUtils.GLASS_PANE_KEY].removeClass(oj.OffcanvasUtils.GLASSPANE_DIM_SELECTOR);
  }

  if (animation) {
    drawer.addClass(oj.OffcanvasUtils.TRANSITION_SELECTOR); // add transition end listener

    oj.OffcanvasUtils._onTransitionEnd(drawer, endHandler);
  } else {
    endHandler();
  }
};
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */


oj.OffcanvasUtils._openOldDrawer = function (offcanvas, resolve, reject, edge, displayMode) {
  var drawer = oj.OffcanvasUtils._getDrawer(offcanvas);

  var wrapper = oj.OffcanvasUtils._getAnimateWrapper(offcanvas);

  oj.Assert.assertPrototype(wrapper, $); // Before animation, remove display:none and add transition class

  oj.OffcanvasUtils._toggleClass(offcanvas, wrapper, true);

  var size;

  if (edge === oj.OffcanvasUtils.EDGE_START || edge === oj.OffcanvasUtils.EDGE_END) {
    // if size is missing, outerWidth is used
    size = size === undefined ? drawer.outerWidth(true) + 'px' : size; // don't set transform for oj.OffcanvasUtils.DISPLAY_MODE_OVERLAY

    if (displayMode === oj.OffcanvasUtils.DISPLAY_MODE_PUSH) {
      oj.OffcanvasUtils._setTranslationX(wrapper, edge, size);
    }
  } else {
    // if size is missing, outerHeight is used
    size = size === undefined ? drawer.outerHeight(true) + 'px' : size; // don't set transform for oj.OffcanvasUtils.DISPLAY_MODE_OVERLAY

    if (displayMode === oj.OffcanvasUtils.DISPLAY_MODE_PUSH) {
      oj.OffcanvasUtils._setTranslationY(wrapper, edge, size);
    }
  } // show the drawer


  window.setTimeout(function () {
    oj.OffcanvasUtils._toggleOuterWrapper(offcanvas, drawer, false);
  }, 10); // chrome is fine with 0ms but FF needs ~10ms or it wont animate
  // insert a glassPane if offcanvas is modal

  oj.OffcanvasUtils._applyModality(offcanvas, drawer); //  - opening offcanvas automatically scrolls to the top
  //  - perf: fif jank: nav drawer and list view items
  // Moving the focus before animation works fine with the "start" and "top" drawers, but not with
  // the "end" and "bottom" drawers. (There may be a browser bug causing problems)


  if (edge === oj.OffcanvasUtils.EDGE_START || edge === oj.OffcanvasUtils.EDGE_TOP) {
    oj.OffcanvasUtils._setFocus(offcanvas);
  } // add transition end listener


  oj.OffcanvasUtils._onTransitionEnd(wrapper, function () {
    // After animation, remove transition class
    wrapper.removeClass(oj.OffcanvasUtils.TRANSITION_SELECTOR); //  - opening offcanvas automatically scrolls to the top
    //  - perf: fif jank: nav drawer and list view items
    // Moving the focus before animation works fine with the "start" and "top" drawers, but not
    // with the "end" and "bottom" drawers. (There may be a browser bug causing problems)

    if (edge === oj.OffcanvasUtils.EDGE_END || edge === oj.OffcanvasUtils.EDGE_BOTTOM) {
      oj.OffcanvasUtils._setFocus(offcanvas);
    } // fire after open event


    drawer.trigger('ojopen', offcanvas); //  - push and overlay demos don't work in ie11
    // register dismiss handler as late as possible because IE raises focus event
    // on the launcher that will close the offcanvas if autoDismiss is true

    oj.OffcanvasUtils._registerCloseHandler(offcanvas);

    resolve(true);
  });
};
/*
 * @memberof oj.OffcanvasUtils
 * @private

oj.OffcanvasUtils._closeReflow = function (offcanvas, resolve, reject, drawer, animation) {
  var endHandler = function () {
    oj.OffcanvasUtils._afterCloseHandler(offcanvas);
    resolve(true);
  };

  // clear transform
  oj.OffcanvasUtils._toggleOuterWrapper(offcanvas, drawer, false);

  // dim glassPane
  if (oj.OffcanvasUtils._isModal(offcanvas)) {
    offcanvas[oj.OffcanvasUtils.GLASS_PANE_KEY]
      .removeClass(oj.OffcanvasUtils.GLASSPANE_DIM_SELECTOR);
  }

  if (animation) {
    // Before animation, add transition class
    drawer.addClass(oj.OffcanvasUtils.TRANSITION_SELECTOR);
    oj.OffcanvasUtils._setTransform(drawer, '');
    drawer.css('min-width', '0');

    // add transition end listener
    oj.OffcanvasUtils._onTransitionEnd(drawer, endHandler);
  } else {
    endHandler();
  }
};
 */

/**
 * @memberof oj.OffcanvasUtils
 * @private
 */


oj.OffcanvasUtils._closeOldDrawer = function (offcanvas, resolve, reject, drawer, animation) {
  var displayMode = offcanvas[oj.OffcanvasUtils.DISPLAY_MODE_KEY];

  var wrapper = oj.OffcanvasUtils._getAnimateWrapper(offcanvas);

  var endHandler = function endHandler() {
    oj.OffcanvasUtils._afterCloseHandler(offcanvas);

    resolve(true);
  }; // clear transform


  if (displayMode === oj.OffcanvasUtils.DISPLAY_MODE_PUSH) {
    oj.OffcanvasUtils._setTransform(wrapper, '');
  }

  oj.OffcanvasUtils._toggleOuterWrapper(offcanvas, drawer, false); // dim glassPane


  if (oj.OffcanvasUtils._isModal(offcanvas)) {
    offcanvas[oj.OffcanvasUtils.GLASS_PANE_KEY].removeClass(oj.OffcanvasUtils.GLASSPANE_DIM_SELECTOR);
  }

  if (animation) {
    // Before animation, add transition class
    wrapper.addClass(oj.OffcanvasUtils.TRANSITION_SELECTOR); // add transition end listener

    oj.OffcanvasUtils._onTransitionEnd(wrapper, endHandler);
  } else {
    endHandler();
  }
};
/**
 * Shows the offcanvas by sliding it into the viewport.  This method fire an ojbeforeopen event which can be vetoed by attaching a listener and returning false.  If the open is not vetoed, this method will fire an ojopen event once animation has completed.
 *
 *<p>Upon opening a offcanvas, focus is automatically moved to the first item that matches the following:</p>
 *<ol>
 *  <li>The first element within the offcanvas with the <code>autofocus</code> attribute</li>
 *  <li>The first <code>:tabbable</code> element inside the offcanvas</li>
 *  <li>The offcanvas itself</li>
 *</ol>
 *
 * @export
 * @param {Object} offcanvas An Object contains the properties in the following table.
 * @property {string} offcanvas.selector Document selector identifying the offcanvas element.
 * @property {string} offcanvas.content Document selector identifying the main content.
 * @property {('start'|'end'|'top'|'bottom')=} offcanvas.edge the edge of the offcanvas, valid values are start, end, top, bottom. This property is optional if the offcanvas element has a "oj-offcanvas-" + <edge> class specified.
 * @property {('push'|'overlay')=} offcanvas.displayMode how to show the offcanvas, valid values are push or overlay. Default: defined by theme.
 * @property {('focusLoss'|'none')=} offcanvas.autoDismiss close behavior, valid values are focusLoss and none. If autoDismiss is default(focusLoss) then any click outside the offcanvas will close it.
 * @property {string=} offcanvas.size size width or height of the offcanvas: width if edge is start or end and height if edge is to and bottom. Default to the computed width or height of the offcanvas.
 * @property {('modal'|'modeless')=} offcanvas.modality The modality of the offcanvas. Valid values are modal and modeless. Default: modeless. If the offcanvas is modal, interaction with the main content area is disabled like in a modal dialog.
 * @return {Promise.<boolean>} A promise that is resolved to boolean true when all transitions have completed. The promise is rejected if the ojbeforeopen event is vetoed.
 * @see #close
 * @see #toggle
 *
 * @memberof oj.OffcanvasUtils
 *
 * @example <caption>Slide the offcanvas into the viewport:</caption>
 *    var offcanvas = {
 *      "selector": "#startDrawer",
 *      "content": "#mainContent",
 *      "edge": "start",
 *      "displayMode": "push",
 *      "size": "200px"
 *    };
 *
 * oj.OffcanvasUtils.open(offcanvas);
 *
 */


oj.OffcanvasUtils.open = function (offcanvas) {
  var drawer = oj.OffcanvasUtils._getDrawer(offcanvas);

  var oldOffcanvas = $.data(drawer[0], oj.OffcanvasUtils._DATA_OFFCANVAS_KEY);

  if (oldOffcanvas) {
    // if we are in the middle of closing, then return the previous saved promise
    if (oldOffcanvas[oj.OffcanvasUtils.CLOSE_PROMISE_KEY]) {
      return oldOffcanvas[oj.OffcanvasUtils.CLOSE_PROMISE_KEY];
    } // if we are in the middle of opening, then return the previous saved promise


    if (oldOffcanvas[oj.OffcanvasUtils.OPEN_PROMISE_KEY]) {
      return oldOffcanvas[oj.OffcanvasUtils.OPEN_PROMISE_KEY];
    }
  }

  var resolveBusyState;
  var veto = false;
  var promise = new Promise(function (resolve, reject) {
    oj.Assert.assertPrototype(drawer, $); // save the edge

    var edge = oj.OffcanvasUtils._saveEdge(offcanvas); // fire before open event


    var event = $.Event('ojbeforeopen');
    drawer.trigger(event, offcanvas);

    if (event.result === false) {
      reject(oj.OffcanvasUtils.VETO_BEFOREOPEN_MSG);
      veto = true;
      return;
    }

    var displayMode = oj.OffcanvasUtils._getDisplayMode(offcanvas);

    var isReflow = oj.OffcanvasUtils._isReflow(offcanvas); // only support horizontal offcanvas for reflow


    if (isReflow && (edge === oj.OffcanvasUtils.EDGE_TOP || edge === oj.OffcanvasUtils.EDGE_BOTTOM)) {
      displayMode = oj.OffcanvasUtils.DISPLAY_MODE_PUSH;
    } // save a copy of offcanvas object in offcanvas jquery data


    var myOffcanvas = $.extend({}, offcanvas);
    myOffcanvas[oj.OffcanvasUtils.DISPLAY_MODE_KEY] = displayMode;
    $.data(drawer[0], oj.OffcanvasUtils._DATA_OFFCANVAS_KEY, myOffcanvas); // throw an error if CONTENT_KEY is specified and the html markup contains an inner wrapper.

    if (offcanvas[oj.OffcanvasUtils.CONTENT_KEY]) {
      if (!oj.OffcanvasUtils._noInnerWrapper(offcanvas)) {
        throw new Error("Error: Both main content selector and the inner wrapper <div class='oj-offcanvas-inner-wrapper'> are provided. Please remove the inner wrapper.");
      } // Add a busy state for the animation.  The busy state resolver will be invoked
      // when the animation is completed


      var busyContext = Context.getContext(drawer[0]).getBusyContext();
      resolveBusyState = busyContext.addBusyState({
        description: "The offcanvas selector ='" + offcanvas[oj.OffcanvasUtils.SELECTOR_KEY] + "' doing the open animation."
      });

      if (isReflow) {//        oj.OffcanvasUtils._openReflow(myOffcanvas, resolve, reject, edge);
      } else if (displayMode === oj.OffcanvasUtils.DISPLAY_MODE_PUSH) {
        oj.OffcanvasUtils._openPush(myOffcanvas, resolve, reject, edge);
      } else {
        oj.OffcanvasUtils._openOverlay(myOffcanvas, resolve, reject, edge);
      }
    } else {
      oj.OffcanvasUtils._openOldDrawer(myOffcanvas, resolve, reject, edge, displayMode);
    }
  });
  promise = promise.then(function (value) {
    if (resolveBusyState) {
      resolveBusyState();
    }

    return value;
  }, function (error) {
    if (resolveBusyState) {
      resolveBusyState();
    }

    throw error;
  }); // save away the current promise

  if (!veto) {
    var nOffcanvas = $.data(drawer[0], oj.OffcanvasUtils._DATA_OFFCANVAS_KEY);

    if (nOffcanvas) {
      nOffcanvas[oj.OffcanvasUtils.OPEN_PROMISE_KEY] = promise; // notify subtree

      Components.subtreeShown(drawer[0]);
    }
  }

  return (
    /** @type{Promise.<boolean>} */
    promise
  );
};
/**
 * Hides the offcanvas by sliding it out of the viewport.  This method fires an ojbeforeclose event which can be vetoed by attaching a listener and returning false.  If the close is not vetoed, this method will fire an ojclose event once animation has completed.
 *
 * @export
 * @param {Object} offcanvas An Object contains the properties in the following table.
 * @property {string} offcanvas.selector Document selector identifying the offcanvas element
 * @return {Promise.<boolean>} A promise that is resolved to boolean true when all transitions have completed. The promise is rejected if the ojbeforeclose event is vetoed.
 * @see #open
 * @see #toggle
 *
 * @memberof oj.OffcanvasUtils
 *
 * @example <caption>Slide the offcanvas out of the viewport:</caption>
 *    var offcanvas = {
 *      "selector": "#startDrawer"
 *    };
 *
 * oj.OffcanvasUtils.close(offcanvas);
 *
 */


oj.OffcanvasUtils.close = function (offcanvas) {
  return oj.OffcanvasUtils._close(offcanvas[oj.OffcanvasUtils.SELECTOR_KEY], offcanvas[oj.OffcanvasUtils.ANIMATE_KEY] === undefined);
};
/**
 * @memberof oj.OffcanvasUtils
 * @private
 */


oj.OffcanvasUtils._close = function (selector, animation) {
  var drawer = $(selector);
  oj.Assert.assertPrototype(drawer, $);
  var offcanvas = $.data(drawer[0], oj.OffcanvasUtils._DATA_OFFCANVAS_KEY); // if we are in the middle of closing, then return the previous saved promise

  if (offcanvas && offcanvas[oj.OffcanvasUtils.CLOSE_PROMISE_KEY]) {
    return offcanvas[oj.OffcanvasUtils.CLOSE_PROMISE_KEY];
  }

  var resolveBusyState;
  var veto = false;
  var promise = new Promise(function (resolve, reject) {
    if (oj.OffcanvasUtils._isOpen(drawer)) {
      if (selector !== offcanvas[oj.OffcanvasUtils.SELECTOR_KEY]) {
        resolve(true);
      } // if the outer wrapper doesn't have the correct shift selector, we are done


      if (!oj.OffcanvasUtils._toggleOuterWrapper(offcanvas, drawer, true)) {
        resolve(true);
      } // fire before close event


      var event = $.Event('ojbeforeclose');
      drawer.trigger(event, offcanvas);

      if (event.result === false) {
        reject(oj.OffcanvasUtils.VETO_BEFORECLOSE_MSG);
        veto = true;
        return;
      } // Add a busy state for the animation.  The busy state resolver will be invoked
      // when the animation is completed


      if (animation) {
        var busyContext = Context.getContext(drawer[0]).getBusyContext();
        resolveBusyState = busyContext.addBusyState({
          description: "The offcanvas selector ='" + offcanvas[oj.OffcanvasUtils.SELECTOR_KEY] + "' doing the close animation."
        });
      }

      var displayMode = offcanvas[oj.OffcanvasUtils.DISPLAY_MODE_KEY];

      if (offcanvas[oj.OffcanvasUtils.CONTENT_KEY]) {
        if (displayMode === oj.OffcanvasUtils.DISPLAY_MODE_PUSH) {
          oj.OffcanvasUtils._closePush(offcanvas, resolve, reject, drawer, animation);
        } else {
          oj.OffcanvasUtils._closeOverlay(offcanvas, resolve, reject, drawer, animation);
        }
      } else {
        oj.OffcanvasUtils._closeOldDrawer(offcanvas, resolve, reject, drawer, animation);
      }
    } else {
      resolve(true);
    }
  });
  promise = promise.then(function (value) {
    if (resolveBusyState) {
      resolveBusyState();
    }

    return value;
  }, function (error) {
    if (resolveBusyState) {
      resolveBusyState();
    }

    throw error;
  }); // save away the current promise

  if (!veto) {
    offcanvas = $.data(drawer[0], oj.OffcanvasUtils._DATA_OFFCANVAS_KEY);

    if (offcanvas) {
      offcanvas[oj.OffcanvasUtils.CLOSE_PROMISE_KEY] = promise; // notify subtree

      Components.subtreeHidden(drawer[0]);
    }
  }

  return (
    /** @type{Promise.<boolean>} */
    promise
  );
};
/**
 * Toggles the offcanvas in or out of the viewport.  This method simply delegates to the open or close methods as appropriate.
 *
 * @export
 * @param {Object} offcanvas An Object contains the properties in the following table.
 * @property {string} offcanvas.selector Document selector identifying the offcanvas element.
 * @property {string} offcanvas.content Document selector identifying the main content.
 * @property {('start'|'end'|'top'|'bottom')=} offcanvas.edge the edge of the offcanvas, valid values are start, end, top, bottom. This property is optional if the offcanvas element has a "oj-offcanvas-" + <edge> class specified.
 * @property {('push'|'overlay')=} offcanvas.displayMode how to show the offcanvas, valid values are push or overlay. Default: defined by theme.
 * @property {('focusLoss'|'none')=} offcanvas.autoDismiss close behavior, valid values are focusLoss and none. If autoDismiss is default(focusLoss) then any click outside the offcanvas will close it.
 * @property {string=} offcanvas.size size width or height of the offcanvas: width if edge is start or end and height if edge is to and bottom. Default to the computed width or height of the offcanvas.
 * @property {('modal'|'modeless')=} offcanvas.modality The modality of the offcanvas. Valid values are modal and modeless. Default: modeless. If the offcanvas is modal, interaction with the main content area is disabled like in a modal dialog.
 * @return {Promise.<boolean>} A promise that is resolved to boolean true when all transitions have completed
 * @see #open
 * @see #close
 *
 * @memberof oj.OffcanvasUtils
 *
 * @example <caption>Toggle the offcanvas in or out of the viewport:</caption>
 *    var offcanvas = {
 *      "selector": "#startDrawer",
 *      "edge": "start",
 *      "displayMode": "overlay"
 *    };
 *
 * oj.OffcanvasUtils.toggle(offcanvas);
 *
 */


oj.OffcanvasUtils.toggle = function (offcanvas) {
  var drawer = oj.OffcanvasUtils._getDrawer(offcanvas);

  oj.Assert.assertPrototype(drawer, $);

  if (oj.OffcanvasUtils._isOpen(drawer)) {
    return oj.OffcanvasUtils.close(offcanvas);
  }

  return oj.OffcanvasUtils.open(offcanvas);
};
/**
 * Creates an overlay div with the oj-offcanvas-glasspane selector
 * append to the end of the drawer's container
 * @param {!jQuery} drawer the drawer
 * @return {jQuery} the overlay div
 * @memberof oj.OffcanvasUtils
 * @private
 */


oj.OffcanvasUtils._addGlassPane = function (drawer) {
  var overlay = $('<div>');
  overlay.addClass(oj.OffcanvasUtils.GLASSPANE_SELECTOR);
  overlay.attr('role', 'presentation');
  overlay.attr('aria-hidden', 'true'); // append glassPane at the end

  overlay.appendTo(drawer.parent()); // @HTMLUpdateOK

  overlay.on('keydown keyup keypress mousedown mouseup mouseover mouseout click focusin focus', function (event) {
    event.stopPropagation();
    event.preventDefault();
  });
  return overlay;
};
/**
 * Creates a script element before the target layer bound to the simple jquery UI
 * surrogate component.
 *
 * @param {!jQuery} layer stacking context
 * @return {jQuery}
 * @memberof oj.OffcanvasUtils
 * @private
 */


oj.OffcanvasUtils._createSurrogate = function (layer) {
  //  - offcanvas utils use of <script>
  var surrogate = $('<span></span>').css('display', 'none').attr('aria-hidden', 'true');
  var layerId = layer.attr('id');
  var surrogateId;

  if (layerId) {
    surrogateId = [layerId, 'surrogate'].join('_');
    surrogate.attr('id', surrogateId);
  } else {
    surrogateId = surrogate.uniqueId();
  }

  surrogate.insertBefore(layer); // @HTMLUpdateOK
  // loosely associate the offcanvas to the surrogate element

  layer.attr(oj.OffcanvasUtils.SURROGATE_ATTR, surrogateId); // @HTMLUpdateOK

  return surrogate;
};
/**
 * bring the drawer to the front to keep this order:  mainContent, glassPane, drawer
 * so we don't need to use z-index
 * @memberof oj.OffcanvasUtils
 * @private
 */


oj.OffcanvasUtils._swapOrder = function (_offcanvas, drawer) {
  var offcanvas = _offcanvas; // create a surrogate in front of the mainContent to be used in _restoreOrder

  offcanvas[oj.OffcanvasUtils.SURROGATE_KEY] = oj.OffcanvasUtils._createSurrogate(drawer);
  drawer.appendTo(drawer.parent()); // @HTMLUpdateOK
};
/**
 * restore the order before _swapOrder
 * @memberof oj.OffcanvasUtils
 * @private
 */


oj.OffcanvasUtils._restoreOrder = function (offcanvas) {
  var drawer = oj.OffcanvasUtils._getDrawer(offcanvas);

  var surrogate = offcanvas[oj.OffcanvasUtils.SURROGATE_KEY];

  if (drawer && surrogate && drawer.attr(oj.OffcanvasUtils.SURROGATE_ATTR) === surrogate.attr('id')) {
    drawer.insertAfter(surrogate); // @HTMLUpdateOK
    // remove link to the surrogate element

    drawer.removeAttr(oj.OffcanvasUtils.SURROGATE_ATTR);
    surrogate.remove();
  }
};
/**
 * Apply modality
 * If offcanvas is modal, add a glasspane and keep the dom structure in the following order:
 * mainContent, glassPane and drawer so we don't need to apply z-index
 * @memberof oj.OffcanvasUtils
 * @private
 */


oj.OffcanvasUtils._applyModality = function (_offcanvas, drawer) {
  var offcanvas = _offcanvas;

  if (oj.OffcanvasUtils._isModal(offcanvas)) {
    // insert glassPane in front of the mainContent
    offcanvas[oj.OffcanvasUtils.GLASS_PANE_KEY] = oj.OffcanvasUtils._addGlassPane(drawer); // bring the drawer <div> to the front
    // to keep this order:  mainContent, glassPane, drawer

    oj.OffcanvasUtils._swapOrder(offcanvas, drawer); //  - acc: talkback reports on elements on background page whilst navdrawer open


    var $main = $(offcanvas[oj.OffcanvasUtils.CONTENT_KEY]);
    $main.attr('aria-hidden', 'true');
    window.setTimeout(function () {
      offcanvas[oj.OffcanvasUtils.GLASS_PANE_KEY].addClass(oj.OffcanvasUtils.GLASSPANE_DIM_SELECTOR);
    }, 0);
  }
};
/**
 * Remove modality
 * If offcanvas is modal, remove glasspane and restore the dom element orders
 * @memberof oj.OffcanvasUtils
 * @private
 */


oj.OffcanvasUtils._removeModality = function (offcanvas) {
  if (oj.OffcanvasUtils._isModal(offcanvas)) {
    offcanvas[oj.OffcanvasUtils.GLASS_PANE_KEY].remove(); // restore the order

    oj.OffcanvasUtils._restoreOrder(offcanvas); //  - acc: talkback reports on elements on background page whilst navdrawer open


    var $main = $(offcanvas[oj.OffcanvasUtils.CONTENT_KEY]);
    $main.removeAttr('aria-hidden');
  }
};
/**
 * Setup offcanvas for pan to reveal.
 * This method adds a touch listener to handle revealing the offcanvas as user pans on the outer wrapper.  The following events are fired by this method:
 * ojpanstart - fired when pan to reveal gesture initiated by the user.  The event includes the direction and distance of the pan.  If it is vetoed
 *              then pan to reveal is terminated
 * ojpanmove  - fired as user continues the pan gesture.  The event includes the direction and distance of the pan.
 * ojpanend   - fired when pan to reveal gesture ends.  The event includes the direction and distance of the pan.  If it is vetoed then the offcanvas
 *              will be closed.
 *
 * @export
 * @param {Object} offcanvas An Object contains the properties in the following table.
 * @property {string} offcanvas.selector Document selector identifying the offcanvas element
 * @property {('start'|'end'|'top'|'bottom')=} offcanvas.edge the edge of the offcanvas, valid values are start, end. This property is optional if the offcanvas element has a "oj-offcanvas-" + <edge> class specified.
 * @property {string=} offcanvas.size size width of the offcanvas.  Default to the computed width of the offcanvas.
 * @return {void}
 *
 * @memberof oj.OffcanvasUtils
 * @ojtsignore
 *
 * @see #tearDownPanToReveal
 *
 * @example <caption>Setup the offcanvas:</caption>
 *    var offcanvas = {
 *      "selector": "#startDrawer"
 *    };
 *
 * oj.OffcanvasUtils.setupPanToReveal(offcanvas);
 *
 */


oj.OffcanvasUtils.setupPanToReveal = function (_offcanvas) {
  var offcanvas = _offcanvas;
  var drawer;
  var size;
  var outerWrapper;
  var wrapper;
  var mOptions;
  var proceed;
  var direction;
  var ui;
  var evt;
  var delta;
  var edge;
  var endEvents;

  var _listener;

  if ($(offcanvas).attr('oj-data-pansetup') != null) {
    // already setup
    return;
  } // mark as setup


  $(offcanvas).attr('oj-data-pansetup', 'true'); // pan to reveal only works for push display mode, so enforce it

  offcanvas.displayMode = 'push';
  drawer = oj.OffcanvasUtils._getDrawer(offcanvas);
  outerWrapper = oj.OffcanvasUtils._getOuterWrapper(drawer); // use hammer for swipe

  mOptions = {
    recognizers: [[Hammer.Pan, {
      direction: Hammer.DIRECTION_HORIZONTAL
    }]]
  }; // workaround for Hammer with iOS 13 issue, see: https://github.com/hammerjs/hammer.js/issues/1237

  var agent = oj.AgentUtils.getAgentInfo();

  if (agent.os === oj.AgentUtils.OS.IOS) {
    // force Hammer to only accept TouchEvent and not PointerEvent
    mOptions.inputClass = Hammer.TouchInput;
  } // flag to signal whether pan to reveal should proceed


  proceed = false;
  $(outerWrapper).ojHammer(mOptions).on('panstart', function (event) {
    direction = null;

    switch (event.gesture.direction) {
      case Hammer.DIRECTION_LEFT:
        // diagonal case
        if (Math.abs(event.gesture.deltaY) < Math.abs(event.gesture.deltaX)) {
          direction = oj.OffcanvasUtils._isRTL() ? 'end' : 'start';
        }

        break;

      case Hammer.DIRECTION_RIGHT:
        // diagonal case
        if (Math.abs(event.gesture.deltaY) < Math.abs(event.gesture.deltaX)) {
          direction = oj.OffcanvasUtils._isRTL() ? 'start' : 'end';
        }

        break;

      default:
    }

    if (direction === null) {
      return;
    } // check for pan up/down at a certain angle which gives abnormal values


    if (event.gesture.angle < 0 && (event.gesture.deltaX < -100 || event.gesture.deltaY < -100)) {
      return;
    }

    ui = {
      direction: direction,
      distance: Math.abs(event.gesture.deltaX)
    };
    evt = $.Event('ojpanstart');
    drawer.trigger(evt, ui);

    if (!evt.isDefaultPrevented()) {
      var busyContext = Context.getContext(outerWrapper.get(0)).getBusyContext();
      busyContext.whenReady().then(function () {
        // need the size to display the canvas when release
        size = offcanvas.size;

        if (size == null) {
          size = drawer.outerWidth();
          offcanvas.size = size;
        }

        proceed = true;
      }); // make sure it's in closed state

      offcanvas._closePromise = null; // cancel any close animation transition handler

      wrapper = oj.OffcanvasUtils._getAnimateWrapper(offcanvas);
      wrapper.off('.oc'); // sets the appropriate offcanvas class

      oj.OffcanvasUtils._toggleClass(offcanvas, wrapper, true); // stop touch event from bubbling to prevent for example pull to refresh from happening


      event.gesture.srcEvent.stopPropagation(); // prevent page from scrolling

      event.gesture.srcEvent.preventDefault(); // stop bubbling

      event.stopPropagation();
    }
  }).on('panmove', function (event) {
    // don't do anything if start is vetoed
    if (!proceed) {
      return;
    }

    delta = event.gesture.deltaX;

    if (direction === 'start' && delta > 0 || direction === 'end' && delta < 0) {
      oj.OffcanvasUtils._setTranslationX(wrapper, 'start', '0px');

      return;
    }

    drawer.css('width', Math.abs(delta)); // don't do css transition animation while panning

    wrapper.removeClass(oj.OffcanvasUtils.TRANSITION_SELECTOR);

    oj.OffcanvasUtils._setTranslationX(wrapper, 'start', delta + 'px');

    ui = {
      direction: direction,
      distance: Math.abs(delta)
    };
    evt = $.Event('ojpanmove');
    drawer.trigger(evt, ui); // stop touch event from bubbling to prevent for example pull to refresh from happening

    event.gesture.srcEvent.stopPropagation(); // stop bubbling

    event.stopPropagation();
  }).on('panend', function (event) {
    // don't do anything if start is vetoed
    if (!proceed) {
      return;
    } // reset flag


    proceed = false;
    delta = Math.abs(event.gesture.deltaX);
    ui = {
      distance: delta
    };
    evt = $.Event('ojpanend');
    drawer.trigger(evt, ui); // stop bubbling

    event.stopPropagation();

    if (!evt.isDefaultPrevented()) {
      edge = offcanvas.edge;

      if (edge == null) {
        if (drawer.hasClass('oj-offcanvas-start')) {
          edge = 'start';
        } else {
          edge = 'end';
        }
      }

      oj.OffcanvasUtils._animateWrapperAndDrawer(wrapper, drawer, edge, size, offcanvas);

      $.data(drawer[0], oj.OffcanvasUtils._DATA_OFFCANVAS_KEY, offcanvas);
      $.data(drawer[0], oj.OffcanvasUtils._DATA_EDGE_KEY, edge);

      oj.OffcanvasUtils._registerCloseHandler(offcanvas);

      return;
    } // nothing to animate, still need to close the offcanvas and do clean up


    if (wrapper[0].style.transform === 'translate3d(0px, 0px, 0px)') {
      oj.OffcanvasUtils._toggleClass(offcanvas, wrapper, false);

      wrapper.removeClass(oj.OffcanvasUtils.TRANSITION_SELECTOR);
      drawer.trigger('ojclose', offcanvas);
      return;
    } // close the toolbar


    endEvents = 'transitionend webkitTransitionEnd otransitionend oTransitionEnd';

    _listener = function listener() {
      // reset offcanvas class
      oj.OffcanvasUtils._toggleClass(offcanvas, wrapper, false);

      wrapper.removeClass(oj.OffcanvasUtils.TRANSITION_SELECTOR); // remove handler

      wrapper.off(endEvents, _listener); // fire close event after completely closed

      drawer.trigger('ojclose', offcanvas);
    }; // add transition end listener


    wrapper.on(endEvents, _listener); // restore item position

    wrapper.addClass(oj.OffcanvasUtils.TRANSITION_SELECTOR);

    oj.OffcanvasUtils._setTranslationX(wrapper, 'start', '0px');
  });
}; // animate both the wrapper and drawer at the same time

/**
 * @memberof oj.OffcanvasUtils
 * @private
 */


oj.OffcanvasUtils._animateWrapperAndDrawer = function (wrapper, drawer, edge, size, offcanvas) {
  var tt = 400;
  var fps = 60;
  var ifps;
  var matrix;
  var values;
  var current;
  var first;
  var final;
  var reqId;
  var inc;
  var lastFrame;

  var _func;

  var currentFrame;
  var adjInc; // since we can't synchronize two css transitions, we'll have to do the animation ourselves using
  // requestAnimationFrame
  // make sure wrapper animation is off

  wrapper.removeClass(oj.OffcanvasUtils.TRANSITION_SELECTOR); // ideal ms per frame

  ifps = Math.round(1000 / fps);
  matrix = wrapper.css('transform');

  if (matrix === 'none') {
    // could happen if this method was called after canvas is closed
    return;
  }

  values = matrix.split('(')[1].split(')')[0].split(',');
  var agent = oj.AgentUtils.getAgentInfo(); // this is the position of translateX value (IE11 the matrix looks different)

  var index = agent.browser === 'ie' && agent.browserVersion === 11 ? 12 : 4;
  current = parseInt(values[index], 10);
  first = current; // the final size/destination

  final = edge === 'end' ? 0 - size : size; // calculate the increment needed to complete transition in 400ms with 60fps

  inc = Math.max(1, Math.abs(final - current) / (tt / ifps));
  lastFrame = new Date().getTime();

  _func = function func() {
    // check if it got interrupted by close
    if (first !== current && wrapper.get(0).style.transform === '') {
      window.cancelAnimationFrame(reqId);
      return;
    }

    currentFrame = new Date().getTime(); // see how much we'll need to compensate if fps drops below ideal

    adjInc = Math.max(inc, inc * Math.max((currentFrame - lastFrame) / ifps));
    lastFrame = currentFrame;

    if (current < final) {
      current = Math.min(final, current + adjInc);
    } else if (current > final) {
      current = Math.max(final, current - adjInc);
    }

    oj.OffcanvasUtils._setTranslationX(wrapper, edge, Math.abs(current) + 'px');

    drawer.css('width', Math.abs(current) + 'px'); // make sure to cancel the animation frame if we are done

    if (current === final) {
      window.cancelAnimationFrame(reqId);
      wrapper.addClass(oj.OffcanvasUtils.TRANSITION_SELECTOR); // fire after completely open

      drawer.trigger('ojopen', offcanvas);
    } else {
      reqId = window.requestAnimationFrame(_func);
    }
  };

  reqId = window.requestAnimationFrame(_func);
};
/**
 * Removes the listener that was added in setupPanToReveal.  Page authors should call tearDownPanToReveal when the offcanvas is no longer needed.
 *
 * @export
 * @param {Object} offcanvas An Object contains the properties in the following table.
 * @property {string} offcanvas.selector Document selector identifying the offcanvas element
 * @return {void}
 * @see #setupPanToReveal
 *
 * @memberof oj.OffcanvasUtils
 * @ojtsignore
 *
 * @example <caption>TearDown the offcanvas:</caption>
 *    var offcanvas = {
 *      "selector": "#startDrawer"
 *    };
 *
 * oj.OffcanvasUtils.tearDownPanToReveal(offcanvas);
 *
 */


oj.OffcanvasUtils.tearDownPanToReveal = function (offcanvas) {
  var drawer = oj.OffcanvasUtils._getDrawer(offcanvas);

  var outerWrapper = oj.OffcanvasUtils._getOuterWrapper(drawer); // remove all listeners


  $(outerWrapper).off('panstart panmove panend');
};
/**
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Target</th>
 *       <th>Gesture</th>
 *       <th>Action</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td>Offcanvas</td>
 *       <td><kbd>Swipe</kbd></td>
 *       <td>Close the offcanvas by swiping in the close direction.</td>
 *     </tr>
 *   </tbody>
 * </table>
 *
 * @ojfragment touchDoc - Used in touch gesture section of classdesc, and standalone gesture doc
 * @memberof oj.OffcanvasUtils
 */

/**
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Target</th>
 *       <th>Gesture</th>
 *       <th>Action</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td>Close button</td>
 *       <td><kbd>Enter</kbd></td>
 *       <td>If offcanvas has a close button, navigate to the button and press Enter to close the offcanvas.</td>
 *     </tr>
 *     <tr>
 *       <td>Outer wrapper</td>
 *       <td><kbd>Tab or Shift+Tab</kbd></td>
 *       <td>When focus is on the outer wrapper, Tab or shift+Tab moves the focus to the next or previous tab stop on the page. If autoDismiss is true, it also closes the offcanvas.</td>
 *     </tr>
 *   </tbody>
 * </table>
 *
 * @ojfragment keyboardDoc - Used in keyboard section of classdesc, and standalone gesture doc
 * @memberof oj.OffcanvasUtils
 */
// -------------------- Styling start ------------------------
// ------------------------------ oj-offcanvas-outer-wrapper ---------------------------------

/**
 * Applied to the outer most element of the offcanvas.
 * @ojstyleclass oj-offcanvas-outer-wrapper
 * @ojdisplayname Off-canvas Outer Wrapper
 * @ojstyleselector div
 * @memberof oj.OffcanvasUtils
 */
// ------------------------------ oj-offcanvas-page ---------------------------------

/**
 * Applied to the outer wrapper of the page level offcanvas.
 * @ojstyleclass oj-offcanvas-page
 * @ojdisplayname Off-canvas Page
 * @ojstyleselector .oj-offcanvas-outer-wrapper
 * @memberof oj.OffcanvasUtils
 */
// ------------------------------ oj-offcanvas-inner-wrapper ---------------------------------

/**
 * Applied to the inner wrapper of the page level offcanvas.
 * @ojstyleclass oj-offcanvas-inner-wrapper
 * @ojdisplayname Off-canvas Inner Wrapper
 * @memberof oj.OffcanvasUtils
 * @ojdeprecated [{since: "6.0.0", description: "Offcanvas inner wrapper is no longer supported."}]
 */
// ------------------------------ oj-offcanvas-overlay-shadow ---------------------------------

/**
 * Add this marker class to an overlay offcanvas to show a drop shadow when it is open.
 * @ojstyleclass oj-offcanvas-overlay-shadow
 * @ojdisplayname Off-canvas Drop Shadow
 * @ojstyleselector .oj-offcanvas-outer-wrapper > div
 * @memberof oj.OffcanvasUtils
 */
// ---------------- oj-offcanvas-edge --------------

/**
 * Specifies the default for applying the offcanvas on the given edge.
 * @ojstyleset offcanvas-edge
 * @ojdisplayname Off-canvas Edge
 * @ojstylesetitems ["offcanvas-edge.oj-offcanvas-start", "offcanvas-edge.oj-offcanvas-end", "offcanvas-edge.oj-offcanvas-top", "offcanvas-edge.oj-offcanvas-bottom"]
 * @ojstylerelation exclusive
 * @memberof oj.OffcanvasUtils
 */

/**
 * @ojstyleclass offcanvas-edge.oj-offcanvas-start
 * @ojdisplayname Off-canvas Start Edge
 * @ojshortdesc Default to applying the offcanvas to the start edge.
 * @ojstyleselector .oj-offcanvas-outer-wrapper > div
 * @memberof! oj.OffcanvasUtils
 */

/**
 * @ojstyleclass offcanvas-edge.oj-offcanvas-end
 * @ojdisplayname Off-canvas End Edge
 * @ojshortdesc Default to applying the offcanvas to the end edge.
 * @ojstyleselector .oj-offcanvas-outer-wrapper > div
 * @memberof! oj.OffcanvasUtils
 */

/**
 * @ojstyleclass offcanvas-edge.oj-offcanvas-top
 * @ojdisplayname Off-canvas Top Edge
 * @ojshortdesc Default to applying the offcanvas to the top edge.
 * @ojstyleselector .oj-offcanvas-outer-wrapper > div
 * @memberof! oj.OffcanvasUtils
 */

/**
 * @ojstyleclass offcanvas-edge.oj-offcanvas-bottom
 * @ojdisplayname Off-canvas Bottom Edge
 * @ojshortdesc Default to applying the offcanvas to the bottom edge.
 * @ojstyleselector .oj-offcanvas-outer-wrapper > div
 * @memberof! oj.OffcanvasUtils
 */
// -------------------- Styling end ------------------------

  ;return OffcanvasUtils;
});
/**
 * Licenced under the MIT License
 *
 * Copyright (c) 2010 Seznam.cz, a.s.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * @license
 */
/*
 * Internet explorer generates pointer events by default for all input types like mouse, pen or touch (finger).
 * Touchr is generating touch events only for touch type by default but it can be overwritten by
 * window.Touchr_ALLOWED_POINTER_TYPE bitmask property. It can have values:
 * 1 for touch
 * 2 for mouse
 * 4 for pen
 * and their combinations.
 */

(function(window) {
	var IE_10		= !!window.navigator.msPointerEnabled,
		// Check below can mark as IE11+ also other browsers which implements pointer events in future
		// that is not issue, because touch capability is tested in IF statement bellow.
		// Note since Edge 16/Windows 10 1709 the property 'window.navigator.pointerEnabled' is undefined.
		IE_11_PLUS	= (!!window.navigator.pointerEnabled || !!window.PointerEvent);

	// Only pointer enabled browsers without touch capability.
	if (!!window.navigator.maxTouchPoints > 0 && (IE_10 || (IE_11_PLUS && !window.TouchEvent))) {
		var document = window.document,
			POINTER_DOWN		= IE_11_PLUS ? "pointerdown"	: "MSPointerDown",
			POINTER_UP 			= IE_11_PLUS ? "pointerup"		: "MSPointerUp",
			POINTER_MOVE		= IE_11_PLUS ? "pointermove"	: "MSPointerMove",
			POINTER_CANCEL		= IE_11_PLUS ? "pointercancel"	: "MSPointerCancel",
			POINTER_TYPE_TOUCH 	= IE_11_PLUS ? "touch"	: MSPointerEvent.MSPOINTER_TYPE_TOUCH,
			POINTER_TYPE_MOUSE 	= IE_11_PLUS ? "mouse"	: MSPointerEvent.MSPOINTER_TYPE_MOUSE,
			POINTER_TYPE_PEN 	= IE_11_PLUS ? "pen"	: MSPointerEvent.MSPOINTER_TYPE_PEN, //IE11+ has also unknown type which Touchr doesn't support
			GESTURE_START		= "MSGestureStart",
			GESTURE_CHANGE		= "MSGestureChange",
			GESTURE_END			= "MSGestureEnd",
			TOUCH_ACTION		= IE_11_PLUS ? "touchAction" : "msTouchAction",
			_180_OVER_PI		= 180/Math.PI,
			// Which pointer types will be used for generating touch events: 1 - touch, 2 - mouse, 4 - pen or their combination
			ALLOWED_POINTER_TYPE = window.Touchr_ALLOWED_POINTER_TYPE || 1,
			createEvent = function (eventName, target, params) {
				var k,
					event = document.createEvent("Event");

				event.initEvent(eventName, true, true);
				for (k in params) {
					event[k] = params[k];
				}
				target.dispatchEvent(event);
			},
			/**
			 * ECMAScript 5 accessors to the rescue
			 * @see http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/
			 */
			makeSubArray = (function() {
				var MAX_SIGNED_INT_VALUE = Math.pow(2, 32) - 1,
					hasOwnProperty = Object.prototype.hasOwnProperty;

				function ToUint32(value) {
					return value >>> 0;
				}

				function getMaxIndexProperty(object) {
					var maxIndex = -1,
						isValidProperty,
						prop;

					for (prop in object) {

						isValidProperty = (
							String(ToUint32(prop)) === prop &&
								ToUint32(prop) !== MAX_SIGNED_INT_VALUE &&
								hasOwnProperty.call(object, prop));

						if (isValidProperty && prop > maxIndex) {
							maxIndex = prop;
						}
					}
					return maxIndex;
				}

				return function(methods) {
					var length = 0;
					methods = methods || { };

					methods.length = {
						get: function() {
							var maxIndexProperty = +getMaxIndexProperty(this);
							return Math.max(length, maxIndexProperty + 1);
						},
						set: function(value) {
							var constrainedValue = ToUint32(value);
							if (constrainedValue !== +value) {
								throw new RangeError();
							}
							for (var i = constrainedValue, len = this.length; i < len; i++) {
								delete this[i];
							}
							length = constrainedValue;
						}
					};
					methods.toString = {
						value: Array.prototype.join
					};
					return Object.create(Array.prototype, methods);
				};
			})(),
			// methods passed to TouchList closure method to extend Array
			touchListMethods = {
				/**
				 * Returns touch by id. This method fulfill the TouchList interface.
				 * @param {Number} id
				 * @returns {Touch}
				 */
				identifiedTouch: {
					value: function (id) {
						var length = this.length;
						while (length--) {
							if (this[length].identifier === id) return this[length];
						}
						return undefined;
					}
				},
				/**
				 * Returns touch by index. This method fulfill the TouchList interface.
				 * @param {Number} index
				 * @returns {Touch}
				 */
				item: {
					value: function (index) {
						return this[index];
					}
				},
				/**
				 * Returns touch index
				 * @param {Touch} touch
				 * @returns {Number}
				 */
				_touchIndex: {
					value: function (touch) {
						var length = this.length;
						while (length--) {
							if (this[length].pointerId == touch.pointerId) return length;
						}
						return -1;
					}
				},

				/**
				 * Add all events and convert them to touches
				 * @param {Event[]} events
				 */
				_addAll: {
					value: function(events) {
						var i = 0,
							length = events.length;

						for (; i < length; i++) {
							this._add(events[i]);
						}
					}
				},

				/**
				 * Add and MSPointer event and convert it to Touch like object
				 * @param {Event} event
				 */
				_add: {
					value: function(event) {
						var index = this._touchIndex(event);

						index = index < 0 ? this.length : index;

						//normalizing Pointer to Touch
						event.type = POINTER_MOVE;
						event.identifier = event.pointerId;
						//in DOC is mentioned that it is 0..255 but actually it returns 0..1 value
						//returns 0.5 for mouse down buttons in IE11, should it be issue?
						event.force = event.pressure;
						//default values for Touch which we cannot obtain from Pointer
						event.radiusX = event.radiusY = 1;
						event.rotationAngle = 0;

						this[index] = event;
					}
				},

				/**
				 * Removes an event from this touch list.
				 * @param {Event} event
				 */
				_remove: {
					value: function(event) {
						var index = this._touchIndex(event);

						if (index >= 0) {
							this.splice(index,1);
						}
					}
				}
			},

			/**
			 * This class store touches in an list which can be also accessible as array which is
			 * little bit bad because TouchList have to extend Array. Because we are aiming on
			 * IE10+ we can use ECMAScript5 solution.
			 * @extends Array
			 * @see http://www.w3.org/TR/2011/WD-touch-events-20110913/#touchlist-interface
			 * @see https://developer.mozilla.org/en-US/docs/DOM/TouchList
			 */
			TouchList = (function(methods) {
				return function() {
					var arr = makeSubArray(methods);
					if (arguments.length === 1) {
						arr.length = arguments[0];
					}
					else {
						arr.push.apply(arr, arguments);
					}
					return arr;
				};
			})(touchListMethods),

			/**
			 * list of all touches running during life cycle
			 * @type TouchList
			 */
			generalTouchesHolder,

			/**
			 * Storage of link between pointer {id} and original target
			 * @type Object
			 */
			pointerToTarget = {},

			/**
			 * General gesture object which fires MSGesture events whenever any associated MSPointer event changed.
			 */
			gesture = window.MSGesture ? new MSGesture() : null,

			gestureScale = 1,
			gestureRotation = 0,

			/**
			 * Storage of targets and anonymous MSPointerStart handlers for later
			 * unregistering
			 * @type Array
			 */
			attachedPointerStartMethods = [],

			/**
			 * Checks if node is some of parent children or sub-children
			 * @param {HTMLElement|Document} parent
			 * @param {HTMLElement} node
			 * @returns {Boolean}
			 */
			checkSameTarget = function (parent, node) {
				if (node) {
					if (parent === node) {
						return true;
					} else {
						return checkSameTarget(parent, node.parentNode);
					}
				} else {
					return false;
				}
			},

			/**
			 * Returns bitmask type of pointer to compare with allowed pointer types
			 * @param {Number|String} pointerType
			 * @returns {Number}
			 */
			pointerTypeToBitmask = function (pointerType) {
				if (pointerType == POINTER_TYPE_TOUCH) {
					return 1;
				} else if (pointerType == POINTER_TYPE_MOUSE) {
					return 2;
				} else {
					return 4;
				}
			},

			/**
			 * Main function which is rewriting the MSPointer event to touch event
			 * and preparing all the necessary lists of touches.
			 * @param {Event} evt
			 */
			pointerListener = function (evt) {
				var type,
					i,
					target = evt.target,
					originalTarget,
					changedTouches,
					targetTouches;

				// Skip pointers which are not allowed by users:
				if (!(pointerTypeToBitmask(evt.pointerType) & ALLOWED_POINTER_TYPE)) {
					return;
				}

				if (evt.type === POINTER_DOWN) {
					generalTouchesHolder._add(evt);
					pointerToTarget[evt.pointerId] = evt.target;

					type = "touchstart";

					// Fires MSGesture event when we have at least two pointers in our holder
					// (adding pointers to gesture object immediately fires Gesture event)
					if (gesture && generalTouchesHolder.length > 1) {
						gesture.target = evt.target;
						for (i = 0; i < generalTouchesHolder.length; i++) {
							// Adds to gesture only touches
							// It is not necessary to create separate gesture for mouse or pen pointers
							// because they cannot be present more than by 1 pointer.
							if (generalTouchesHolder[i].pointerType === POINTER_TYPE_TOUCH) {
								gesture.addPointer(generalTouchesHolder[i].pointerId);
							}
						}
					}
				}

				if (evt.type === POINTER_MOVE && generalTouchesHolder.identifiedTouch(evt.pointerId)) {
					generalTouchesHolder._add(evt);

					type = "touchmove";
				}

				//Preparation of touch lists have to be done before pointerup/MSPointerUp where we delete some information

				//Which touch fired this event, because we know that MSPointer event is fired for every
				//changed pointer than we create a list only with actual pointer
				changedTouches = document.createTouchList(evt);
				//Target touches is list of touches which started on (touchstart) on target element, they
				//are in this array even if these touches have coordinates outside target elements
				targetTouches = document.createTouchList();
				for (i = 0; i < generalTouchesHolder.length; i++) {
					//targetTouches._add(generalTouchesHolder[i]);
					//check if the pointerTarget is in the target
					if (checkSameTarget(target, pointerToTarget[generalTouchesHolder[i].identifier])) {
						targetTouches._add(generalTouchesHolder[i]);
					}
				}
				originalTarget = pointerToTarget[evt.pointerId];

				if (evt.type === POINTER_UP || evt.type === POINTER_CANCEL) {
					generalTouchesHolder._remove(evt);
					pointerToTarget[evt.pointerId] = null;

					delete pointerToTarget[evt.pointerId];
					type = "touchend";

					// Fires MSGestureEnd event when there is only one ore zero touches:
					if (gesture && generalTouchesHolder.length <= 1) {
						gesture.stop();
					}
				}

				//console.log("+", evt.type, evt.pointerType, generalTouchesHolder.length, evt.target.nodeName+"#"+evt.target.id);
				if (type && originalTarget) {
					createEvent(type, originalTarget, {touches: generalTouchesHolder, changedTouches: changedTouches, targetTouches: targetTouches});
				}
			},

			/**
			 * Main function which is rewriting the MSGesture event to gesture event.
			 * @param {Event} evt
			 */
			gestureListener = function (evt) {
				//TODO: check first, other than IE (FF?), browser which implements pointer events how to make gestures from pointers. Maybe it would be mix of pointer/gesture events.
				var type, scale, rotation;
				if (evt.type === GESTURE_START) {type = "gesturestart"}
				else if (evt.type === GESTURE_CHANGE) {type = "gesturechange"}
				else if (evt.type === GESTURE_END) {type = "gestureend"}

				// -------- SCALE ---------
				//MSGesture:
				//Scale values represent the difference in scale from the last MSGestureEvent that was fired.
				//Apple:
				//The distance between two fingers since the start of an event, as a multiplier of the initial distance. The initial value is 1.0.

				// ------- ROTATION -------
				//MSGesture:
				//Clockwise rotation of the cursor around its own major axis expressed as a value in radians from the last MSGestureEvent of the interaction.
				//Apple:
				//The delta rotation since the start of an event, in degrees, where clockwise is positive and counter-clockwise is negative. The initial value is 0.0
				if (evt.type === GESTURE_START) {
					scale = gestureScale = 1;
					rotation = gestureRotation = 0;
				} else {
					scale = gestureScale = gestureScale + (evt.scale - 1); //* evt.scale;
					rotation = gestureRotation = gestureRotation + evt.rotation * _180_OVER_PI;
				}

				createEvent(type, evt.target, {scale: scale, rotation: rotation, screenX: evt.screenX, screenY: evt.screenY});
			},

			/**
			 * This method augments event listener methods on given class to call
			 * our own method which attach/detach the MSPointer events handlers
			 * when user tries to attach touch events.
			 * @param {Function} elementClass Element class like HTMLElement or Document
			 */
			augmentEventListener = function(elementClass) {
				var customAddEventListener = attachTouchEvents,
					customRemoveEventListener = removeTouchEvents,
					oldAddEventListener = elementClass.prototype.addEventListener,
					oldRemoveEventListener = elementClass.prototype.removeEventListener;

				elementClass.prototype.addEventListener = function(type, listener, useCapture) {
					//"this" is HTML element
					if ((type.indexOf("gesture") === 0 || type.indexOf("touch") === 0)) {
						customAddEventListener.call(this, type, listener, useCapture);
					}
					oldAddEventListener.call(this, type, listener, useCapture);
				};

				elementClass.prototype.removeEventListener = function(type, listener, useCapture) {
					if ((type.indexOf("gesture") === 0 || type.indexOf("touch") === 0)) {
						customRemoveEventListener.call(this, type, listener, useCapture);
					}
					oldRemoveEventListener.call(this, type, listener, useCapture);
				};
			},
			/**
			 * This method attach event handler for MSPointer / MSGesture events when user
			 * tries to attach touch / gesture events.
			 * @param {String} type
			 * @param {Function} listener
			 * @param {Boolean} useCapture
			 */
			attachTouchEvents = function (type, listener, useCapture) {
				//element owner document or document itself
				var doc = this.nodeType == 9 ?  this : this.ownerDocument;

				// Because we are listening only on document, it is not necessary to
				// attach events on one document more times
				if (attachedPointerStartMethods.indexOf(doc) < 0) {
					//TODO: reference on node, listen on DOM removal to clean the ref?
					attachedPointerStartMethods.push(doc);
					doc.addEventListener(POINTER_DOWN, pointerListener, useCapture);
					doc.addEventListener(POINTER_MOVE, pointerListener, useCapture);
					doc.addEventListener(POINTER_UP, pointerListener, useCapture);
					doc.addEventListener(POINTER_CANCEL, pointerListener, useCapture);
					doc.addEventListener(GESTURE_START, gestureListener, useCapture);
					doc.addEventListener(GESTURE_CHANGE, gestureListener, useCapture);
					doc.addEventListener(GESTURE_END, gestureListener, useCapture);
				}

				// e.g. Document has no style
				// only touchmove event requires touch-action:none, don't set it unless it's neccessary
				// as it affects native behavior such as scrolling with pan gesture
				if (type === "touchmove" && this.style && (typeof this.style[TOUCH_ACTION] == "undefined" || !this.style[TOUCH_ACTION])) {
					this._touchActionUpdated = true;
					this.style[TOUCH_ACTION] = "none";
					// handle scrolling
					// if the element is draggable, don't scroll
					if (!this.hasAttribute("draggable")) {
						attachScrollHandler(this);
					}
				}
			},
			/**
			 * This method attach the scroll event handler.
			 * @param {Element} elem 
			 */
			attachScrollHandler = function(elem) {
				var last, scrollElem, findClosestScrollableElement, clearCachedHeight, visitedElems = [], pointerDownHandler, pointerMoveHandler, pointerUpHandler;

				/**
				 * Find the closest scrollable element from and including target
				 * @param {Element} target
				 * @return {Element}
				 */
				findClosestScrollableElement = function(target) {
					var clientHeight, scrollHeight;

					if (target == null) {
						return null;
					}

					// use cached clientHeight and scrollHeight, to minimize layout/reflow
					clientHeight = target._cachedClientHeight || target.clientHeight;
					scrollHeight = target._cachedScrollHeight || target.scrollHeight;

					target._cachedClientHeight = clientHeight;
					target._cachedScrollHeight = scrollHeight;

					// keep track of the elements visited so we could clear cached height later
					if (visitedElems.indexOf(target) === -1) {
						visitedElems.push(target);
					}

					if (!isNaN(clientHeight) && !isNaN(scrollHeight) && Math.abs(scrollHeight - clientHeight) > 1) {
						return target == document.documentElement ? document.body : target;
					}
					else {
						if (elem != target) {
							return findClosestScrollableElement(target.parentNode);
						}
						return null;
					}
				};

				/**
				 * Clear cached clientHeight and scrollHeight from visited elements
				 */
				clearCachedHeight = function() {
					for (var i=0; i<visitedElems.length; i++) {
						visitedElems[i]._cachedClientHeight = null;
						visitedElems[i]._cachedScrollHeight = null;
					}
					visitedElems.length = 0;
				};

				/**
				 * Handler for PointerDown event
				 */
				pointerDownHandler = function(event) {
					if (event.pointerType === "touch") {
						// should have been clear 
						clearCachedHeight();

						last = event.clientY;
						scrollElem = findClosestScrollableElement(event.target);
						if (scrollElem) {
							// prevent ancestors that have pointer event handler installed
							// to do any work
							event.stopPropagation();
						}
					}
				};

				/**
				 * Handler for PointerMove event
				 */
				pointerMoveHandler = function(Event) {
					var current, delta, nextScrollElem;

					if (event.pointerType === "touch") {
						if (last != undefined && scrollElem) {
							current = scrollElem.scrollTop;
							delta = last - event.clientY;
							scrollElem.scrollTop = current + delta;	

							// see if scroll min/max has been reached, scroll the next closest scrollable element
							// ignore if delta is < 1 (subpixel case)
							if (delta >= 1 && current == scrollElem.scrollTop) {
								nextScrollElem = findClosestScrollableElement(scrollElem.parentNode);								
								while (nextScrollElem) {
									current = nextScrollElem.scrollTop;
									nextScrollElem.scrollTop = current + delta;
									if (nextScrollElem === document.body || nextScrollElem.scrollTop != current) {
										break;
									}
									nextScrollElem = findClosestScrollableElement(nextScrollElem.parentNode);
								}
							}
						}
						last = event.clientY;
					}
				};

				/**
				 * Handler for PointerUp event
				 */
				pointerUpHandler = function(event) {
					clearCachedHeight();
					last = undefined;
				};

				elem.addEventListener(POINTER_DOWN, pointerDownHandler);
				elem.addEventListener(POINTER_MOVE, pointerMoveHandler); 
				elem.addEventListener(POINTER_UP, pointerUpHandler);
				elem._pointerHandlers = [pointerDownHandler, pointerMoveHandler, pointerUpHandler];
			},
			/**
			 * This method detach the scroll event handler.
			 * @param {Element} elem 
			 */
			detachScrollHandler = function(elem) {
				if (elem._pointerHandlers) {
					elem.removeEventListener(POINTER_DOWN, elem._pointerHandlers[0]);
					elem.removeEventListener(POINTER_MOVE, elem._pointerHandlers[1]);
					elem.removeEventListener(POINTER_UP, elem._pointerHandlers[2]);
					elem._pointerHandlers = undefined;
				}
			},
			/**
			 * This method detach event handler for MSPointer / MSGesture events when user
			 * tries to detach touch / gesture events.
			 * @param {String} type
			 * @param {Function} listener
			 * @param {Boolean} useCapture
			 */
			removeTouchEvents = function (type, listener, useCapture) {
				//todo: are we able to understand when all listeners are unregistered and shall be removed?
				if (type === "touchmove") {
					if (this._touchActionUpdated) {
						delete this.style[TOUCH_ACTION];
					}
					detachScrollHandler(this);
				}
			};


		/*
		 * Adding DocumentTouch interface
		 * @see http://www.w3.org/TR/2011/WD-touch-events-20110505/#idl-def-DocumentTouch
		 */

		/**
		 * Create touches list from array or touches or given touch
		 * @param {Touch[]|Touch} touches
		 * @returns {TouchList}
		 */
		document.createTouchList = function(touches) {
			var touchList = new TouchList();
			if (touches) {
				if (touches.length) {
					touchList._addAll(touches);
				} else {
					touchList._add(touches);
				}
			}
			return touchList;
		};

		/*******  Fakes which persuade other code to use touch events ********/

		/**
		 * AbstractView is class for document.defaultView === window
		 * @param {AbstractView} view
		 * @param {EventTarget} target
		 * @param {Number} identifier
		 * @param {Number} pageX
		 * @param {Number} pageY
		 * @param {Number} screenX
		 * @param {Number} screenY
		 * @return {Touch}
		 */
		document.createTouch = function(view, target, identifier, pageX, pageY, screenX, screenY) {
			return {
				identifier: identifier,
				screenX: screenX,
				screenY: screenY,
				//clientX: clientX,
				//clientY: clientY,
				pageX: pageX,
				pageY: pageY,
				target: target
			};
		};
		//Fake Modernizer touch test
		//http://modernizr.github.com/Modernizr/touch.html
		if (!window.ontouchstart) window.ontouchstart = 1;

		/*******  End of fakes ***********************************/

		generalTouchesHolder = document.createTouchList();

		// Overriding HTMLElement and HTMLDocument to hand over touch handler to MSPointer event handler
		augmentEventListener(HTMLElement);
		augmentEventListener(Document);
	}
}(window));
define("touchr", function(){});

/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojswipetoreveal',['ojs/ojcore', 'jquery', 'ojs/ojcontext', 'hammerjs', 'ojs/ojoffcanvas', 'touchr'],
/*
* @param {Object} oj 
* @param {jQuery} $
* @param {Object} Hammer
*/
function(oj, $, Context, Hammer, OffcanvasUtils) 
{
  "use strict";


/* global OffcanvasUtils:false, Context:false */

/**
 * @namespace oj.SwipeToRevealUtils
 * @ojtsmodule
 * @since 1.2.0
 * @export
 * @ojdeprecated {since: '7.0.0', description: 'Use ojSwipeActions instead.'}
 * @hideconstructor
 *
 *
 * @classdesc
 * This class provides functions for setting up and handling swipe to reveal on an offcanvas element.  The offcanvas
 * element contains contextual actions that users can perform on the element that user perform the swipe gesture on.
 * This is most commonly found in ListView where user swipes on an item to reveal contextual actions that can be done on the item.
 *
 * <h3 id="touch-section">
 *   Touch End User Information
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
 * </h3>
 *
 * {@ojinclude "name":"touchDoc"}
 *
 * <h3 id="accessibility-section">
 *   Accessibility
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#accessibility-section"></a>
 * </h3>
 *
 * <p>Application must ensure that the context menu is available and setup with the
 * equivalent menu items so that keyboard-only users can perform all the swipe actions
 * just by using the keyboard.
 */
oj.SwipeToRevealUtils = {}; // mapping variable definition, used in a no-require environment. Maps the oj.SwipeToRevealUtils object to the name used in the require callback.
// eslint-disable-next-line no-unused-vars

var SwipeToRevealUtils = oj.SwipeToRevealUtils;
/**
 * Setup listeners needed for swipe actions capability.
 *
 * @export
 * @param {Element} elem the DOM element (of the offcanvas) that hosts the swipe actions
 * @param {Object=} options the options to set for swipe actions
 * @param {number=} options.threshold the threshold that triggers default action.  If no default action is found (no item with style
 *                 "oj-swipetoreveal-default") then this value is ignored.  If percentage value is specified it will be calculated
 *                 based on the width of the element with class "oj-offcanvas-outer-wrapper".  A default value is determined if not specified.
 *                 An "ojdefaultaction" event will be fired when threshold is exceed upon release.
 * @return {void}
 *
 * @see #tearDownSwipeActions
 * @see oj.OffcanvasUtils.html#setupPanToReveal
 */

oj.SwipeToRevealUtils.setupSwipeActions = function (elem, options) {
  var drawer;
  var direction;
  var offcanvas;
  var outerWrapper;
  var threshold;
  var minimum;
  var drawerShown;
  var busyContext;
  var evt;
  var checkpoint;
  var defaultAction;
  var distance;
  drawer = $(elem); // checks if it's already registered

  if (drawer.hasClass('oj-swipetoreveal')) {
    return;
  }

  drawer.addClass('oj-swipetoreveal');
  direction = drawer.hasClass('oj-offcanvas-start') ? 'end' : 'start';
  offcanvas = {};
  offcanvas.selector = drawer;
  offcanvas._animateWrapperSelector = 'oj-offcanvas-inner-wrapper';
  OffcanvasUtils.setupPanToReveal(offcanvas);
  outerWrapper = OffcanvasUtils._getOuterWrapper(drawer); // the panning triggers a click event at the end (since we are doing translation on move, the relative position has not changed)
  // this is to prevent the click event from bubbling (to list item for example, see )

  drawerShown = false;
  outerWrapper.on('click.swipetoreveal', function (event) {
    if (drawerShown) {
      event.stopImmediatePropagation();
      drawerShown = false;
    }
  }); // However, this does not get trigger in hybrid app, see .
  // this change ensures that it always get reset

  outerWrapper._touchStartListener = function (event) {
    drawerShown = false; // prevent click event from firing when tapping on outer wrapper (like list item) while offcanvas is still open

    if (drawer.hasClass('oj-offcanvas-open') && drawer[0].offsetWidth > 0 && !drawer[0].contains(event.target)) {
      event.preventDefault();
    }
  };

  outerWrapper[0].addEventListener('touchstart', outerWrapper._touchStartListener, {
    passive: false
  });
  drawer.on('ojpanstart', function (event, ui) {
    // if the swipe direction does not match the offcanvas's edge, veto it
    if (ui.direction !== direction) {
      event.preventDefault();
    } else {
      busyContext = Context.getContext(outerWrapper.get(0)).getBusyContext();
      busyContext.whenReady().then(function () {
        // setup default style class, must be done before outerWidth is calculated
        drawer.children().addClass('oj-swipetoreveal-action').css('min-width', ''); // find if there's any default action item specified

        defaultAction = drawer.children('.oj-swipetoreveal-default').get(0); // figure out the threshold for default action and the minimum distance
        // to keep the offcanvas open

        if (minimum == null) {
          if (options != null) {
            threshold = options.threshold;
          }

          if (threshold != null) {
            threshold = parseInt(threshold, 10); // check if it's percentage value

            if (/%$/.test(options.threshold)) {
              threshold = threshold / 100 * outerWrapper.outerWidth();
            }
          } else {
            // by default it will be 55% of the outer wrapper
            threshold = outerWrapper.outerWidth() * 0.55;
          } // by default the minimum will be the lesser of the width of the offcanvas and half of the outer wrapper


          minimum = Math.min(outerWrapper.outerWidth() * 0.3, drawer.outerWidth());
        }
      }); // used to determine if it's a quick swipe

      checkpoint = new Date().getTime();
    }
  }).on('ojpanmove', function (event, ui) {
    if (!drawerShown) {
      drawer.children().css('min-width', 0);
    }

    drawerShown = true; // check if pan pass the threshold position, the default action item gets entire space.

    if (defaultAction != null) {
      if (ui.distance > threshold) {
        drawer.children().each(function () {
          if (this !== defaultAction) {
            $(this).addClass('oj-swipetoreveal-hide-when-full');
          }
        });
      } else {
        drawer.children().removeClass('oj-swipetoreveal-hide-when-full');
      }
    }
  }).on('ojpanend', function (event, ui) {
    distance = ui.distance;

    if (defaultAction != null && distance > threshold) {
      // default action
      evt = $.Event('ojdefaultaction');
      drawer.trigger(evt, offcanvas);
      event.preventDefault();
    } // if pan pass the minimum threshold position, keep the toolbar open


    if (distance < minimum) {
      // check if this is a swipe, the time should be < 200ms and the distance must be > 10px
      if (new Date().getTime() - checkpoint > 200 || distance < 10) {
        event.preventDefault();
      }
    }
  });
};
/**
 * Removes the listener that was added in setupSwipeActions.  Page authors should call tearDownSwipeActions when the content container is no longer needed.
 *
 * @export
 * @param {Element} elem the DOM element (of the offcanvas) that hosts the swipe actions
 * @return {void}
 *
 * @see #setupSwipeActions
 * @see oj.OffcanvasUtils.html#tearDownPanToReveal
 */


oj.SwipeToRevealUtils.tearDownSwipeActions = function (elem) {
  var drawer;
  var offcanvas;
  var outerWrapper;
  drawer = $(elem);
  drawer.removeClass('oj-swipetoreveal');
  offcanvas = {};
  offcanvas.selector = drawer;
  outerWrapper = OffcanvasUtils._getOuterWrapper(drawer);

  if (outerWrapper != null) {
    outerWrapper.off('.swipetoreveal');
  }

  OffcanvasUtils.tearDownPanToReveal(offcanvas); // remove touchstart listener

  outerWrapper[0].removeEventListener('touchstart', outerWrapper._touchStartListener, {
    passive: false
  });
  delete outerWrapper._touchStartListener;
}; // -------------------- Styling start ----------------------------------

/**
 * @classdesc The following CSS classes can be applied by the page author as needed.<br/>
 */
// ------------------------------ oj-swipetoreveal-more ---------------------------------

/**
 * Designed for use with an action item that tags the associated item in the host like listview item.<br/><br/>
 * Is applied to the element that represents the flag action item inside the offcanvas element.
 * @ojstyleclass oj-swipetoreveal-more
 * @ojdisplayname SwipeReveal More
 * @memberof oj.SwipeToRevealUtils
 */
// ------------------------------ oj-swipetoreveal-flag ---------------------------------

/**
 * Designed for use with an action item that shows more available actions that users can perform.<br/><br/>
 * Is applied to the oj-option element that represents the action item.
 * @ojstyleclass oj-swipetoreveal-flag
 * @ojdisplayname SwipeReveal Flag
 * @memberof oj.SwipeToRevealUtils
 */
// ------------------------------ oj-swipetoreveal-alert ---------------------------------

/**
 * Designed for use with an action item that performs an explicit action like deleting the associated listview item.<br/><br/>
 * Is applied to the element that represents the alert action item inside the offcanvas element.
 * @ojstyleclass oj-swipetoreveal-alert
 * @ojdisplayname SwipeReveal Alert
 * @memberof oj.SwipeToRevealUtils
 */
// ------------------------------ oj-swipetoreveal-default ---------------------------------

/**
 * Designed for use with an action item that should get all the space when user swipes pass the threshold distance.<br/><br/>
 * Is applied to the element that represents the default action item inside the offcanvas element.
 * @ojstyleclass oj-swipetoreveal-default
 * @ojdisplayname SwipeReveal Default
 * @memberof oj.SwipeToRevealUtils
 */
// -------------------- Styling end ------------------------

/**
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Target</th>
 *       <th>Gesture</th>
 *       <th>Action</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td>Offcanvas wrapper element</td>
 *       <td><kbd>Swipe</kbd></td>
 *       <td>Reveals the offcanvas element.  Depending on the distance relative to the target is swiped, the offcanvas will either be closed (swipe distance too short), opened, or the default action is performed (swipe distance passed the specified threshold).</td>
 *     </tr>
 *     <tr>
 *       <td>Offcanvas wrapper element</td>
 *       <td><kbd>Pan</kbd></td>
 *       <td>Reveals the offcanvas element.  If a default action is specified, the default action will get the entire space of the offcanvas after the user panned past a specified distance threshold.</td>
 *     </tr>
 *   </tbody>
 * </table>
 *
 * @ojfragment touchDoc - Used in touch gesture section of classdesc, and standalone gesture doc
 * @memberof oj.SwipeToRevealUtils
 */

  ;return oj.SwipeToRevealUtils;
});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojpulltorefresh',['ojs/ojcore', 'jquery', 'ojs/ojcontext', 'ojs/ojtranslation', 'hammerjs', 'ojs/ojjquery-hammer', 'ojs/ojcomponentcore', 'touchr'],
/*
* @param {Object} oj 
* @param {jQuery} $
* @param {Object} Hammer
*/
function(oj, $, Context, Translations, Hammer)
{
  "use strict";


/* global Hammer:false, Translations:false, Context:false */

/**
 * @namespace oj.PullToRefreshUtils
 * @since 1.2.0
 * @export
 * @hideconstructor
 *
 * @ojtsmodule
 *
 * @ojdeprecated {since: '7.0.0', description: 'Use ojRefresher instead.'}
 * @classdesc
 * This class provides functions for adding pull to refresh functionality to any container element which hosts refreshable content.
 * By default this class will generate a default panel, which consists of a refresh icon, a primary text, and a secondary text.  The application
 * can use the callback to provide their own panel.  When the release happens, the refresh function will be invoked and application should
 * use this to execute any logic required to refresh the content inside the panel.  For example, fetching new content for the ListView inside
 * the container.  The application must resolve or reject the Promise so that this class can do the necessary cleanup.
 *
 * <p>Warning: The pull to refresh gesture will not work with drag and drop enabled components. Drag and drop must be disabled in the component if
 * use of pull to refresh is needed.
 *
 * <h3 id="touch-section">
 *   Touch End User Information
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
 * </h3>
 *
 * {@ojinclude "name":"touchDoc"}
 *
 * <h3 id="keyboard-section">
 *   Keyboard End User Information
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 *
 * {@ojinclude "name":"keyboardDoc"}
 */
oj.PullToRefreshUtils = {}; // mapping variable definition, used in a no-require environment. Maps the oj.PullToRefreshUtils object to the name used in the require callback.
// eslint-disable-next-line no-unused-vars

var PullToRefreshUtils = oj.PullToRefreshUtils;
/**
 * Setup content container for pull to refresh capability.  This method adds touch listeners on the content container.  The following events are fired by this method:
 * ojpull is fired when user pulls the content container, the event contains the content element as well as the distance pulled in pixels.
 * ojrelease is fired when user releases the content container, the event contains the content element.
 * ojcomplete is fired when the refresh is done and the panel is completely closed.  The event contains the content element.
 *
 * @export
 * @param {Element} element the DOM element that hosts the content to refresh.  When the content is scrollable, the value of this parameter must be the scrollable element.
 *                  Specifically, when using this with ListView, the ListView element might not necessarily be the scrollable element, but is one of its ancestors instead.
 * @param {function():Promise.<any>} refreshFunc the function to invoke when refresh is triggered.  It must return a Promise.
 * @param {Object=} options optional values that controls aspects of pull to refresh
 * @param {number=} options.threshold the number of pixels to pull until refresh is triggered.  If not specified, a default value will be calculated based on the height of the panel consisting the refresh icon, primary text, and secondary text.
 * @param {string=} options.primaryText the primary text to display.  The primary text is usually used to describe the pull action.  If not specified then no primary text will be displayed.
 * @param {string=} options.secondaryText the secondary text to display.  The secondary text is used to add supplementary text.  If not specified then no secondary text will be displayed.
 * @return {void}
 *
 * @see #tearDownPullToRefresh
 */

oj.PullToRefreshUtils.setupPullToRefresh = function (element, refreshFunc, options) {
  var outer;
  var content;
  var panel;
  var checkTolerance;
  var threshold;
  var start;
  var height;
  var movex;
  var icon;
  var iconOffset;
  var lastIconClass;
  var title;
  var ratio;
  var iconClass;
  var mOptions;
  var isTouch;
  var type;
  isTouch = oj.DomUtils.isTouchSupported(); // make sure we are clean

  oj.PullToRefreshUtils.tearDownPullToRefresh(element);
  outer = $(document.createElement('div')).addClass('oj-pulltorefresh-outer');

  oj.PullToRefreshUtils._renderAccessibleLink(element, outer, refreshFunc, options); // create the element containing the content


  content = $(document.createElement('div')).addClass('oj-pulltorefresh-panel');
  outer.append(content); // @HTMLUpdateOK
  // prepend it to the panel

  panel = $(element);
  panel.prepend(outer); // @HTMLUpdateOK outer is created by the component

  if (isTouch) {
    type = 'touch';
  } else {
    type = 'pan';
    mOptions = {
      recognizers: [[Hammer.Pan, {
        direction: Hammer.DIRECTION_VERTICAL
      }]]
    };
    panel.ojHammer(mOptions);
  }

  panel.on(type + 'start.pulltorefresh', function (event) {
    // checks if we are still refreshing
    if ($.data(content[0], 'data-pullstart') != null) {
      return;
    } // make sure we are at the top


    if (panel[0].scrollTop === 0) {
      oj.PullToRefreshUtils._handlePull(event, content, options); // extract these info up front instead of in move


      icon = content.find('.oj-pulltorefresh-icon');

      if (icon.length > 0) {
        iconOffset = icon.parent().outerHeight(true);
      }

      if (options && !isNaN(options.threshold)) {
        threshold = parseInt(options.threshold, 10);
      }

      if (isNaN(threshold)) {
        threshold = content.outerHeight(true);
      } else {
        threshold = Math.max(0, Math.min(threshold, content.outerHeight(true)));
      } // hide it


      content.css('height', 0);
      content.removeClass('oj-pulltorefresh-transition');

      if (isTouch) {
        $.data(content[0], 'data-pullstart', event.originalEvent.touches[0].clientY);
        $.data(content[0], 'data-pullstart-horiz', event.originalEvent.touches[0].clientX);
      } else {
        $.data(content[0], 'data-pullstart', 0);
      }

      checkTolerance = true;
    }
  }).on(type + 'move.pulltorefresh', function (event) {
    // first checks whether if the pull had started
    start = $.data(content[0], 'data-pullstart');

    if (start == null) {
      return;
    } // see how far it's been pull


    height = isTouch ? event.originalEvent.touches[0].clientY - parseInt(start, 10) : event.gesture.deltaY; // wrong direction

    if (height < 0) {
      return;
    } // make sure the page doesn't scrolls


    event.preventDefault(); // checks if we are in the middle of closing the panel

    if ($.data(content[0], 'data-closing') != null) {
      return;
    } // checks if we are still in the loading stage


    if ($.data(content[0], 'data-loading') != null) {
      content.css('height', Math.max(height, threshold));
      return;
    }

    if (checkTolerance) {
      movex = isTouch ? event.originalEvent.touches[0].clientX - parseInt($.data(content[0], 'data-pullstart-horiz'), 10) : event.gesture.deltaX; // check if the intention is swipe left, if it is don't show the panel yet

      if (Math.abs(movex) > height) {
        return;
      } // we only want to check this as long as the panel is not visible yet


      checkTolerance = false;
    }

    content.css('height', height); // fire pull event

    oj.PullToRefreshUtils._fireEvent(event, 'pull', content, height);

    if (icon != null && icon.length > 0) {
      // remove last class
      lastIconClass = $.data(content[0], 'data-lasticonclass');

      if (lastIconClass != null) {
        icon.removeClass(lastIconClass);
      } // find the appropriate class


      ratio = Math.round(height / threshold * 10) * 10;

      if (ratio >= 100) {
        iconClass = 'oj-pulltorefresh-icon-full';
        title = Translations.getTranslatedString('oj-pullToRefresh.titleIconFull');
      } else {
        iconClass = 'oj-pulltorefresh-icon-' + ratio + '-percent';
        title = Translations.getTranslatedString('oj-pullToRefresh.titleIcon' + ratio + 'percent');
      }

      icon.addClass(iconClass);
      icon.attr('title', title);
      $.data(content[0], 'data-lasticonclass', iconClass); // check whether to show/hide primary/secondary text

      oj.PullToRefreshUtils._showHideDefaultText(content, height > iconOffset);
    }
  }).on(type + 'cancel.pulltorefresh', function () {
    oj.PullToRefreshUtils._cleanup(content);
  }).on(type + 'end.pulltorefresh', function (event) {
    // first checks whether if the pull had started
    start = $.data(content[0], 'data-pullstart');

    if (start == null) {
      return;
    } // checks if we are in the middle of closing the panel


    if ($.data(content[0], 'data-closing') != null) {
      return;
    } // checks if we are still in the loading stage


    if ($.data(content[0], 'data-loading') != null) {
      height = $.data(content[0], 'data-panelheight');
      content.css('height', height);
      return;
    } // less than threshold, hide panel and do nothing


    if (content.outerHeight() < threshold) {
      content.addClass('oj-pulltorefresh-transition').css('height', 0);

      oj.PullToRefreshUtils._cleanup(content);
    } else {
      oj.PullToRefreshUtils._handleRelease(event, element, content, refreshFunc);
    }
  });
};

oj.PullToRefreshUtils._handlePull = function (event, content, options) {
  var primaryText;
  var secondaryText;

  oj.PullToRefreshUtils._fireEvent(event, 'pull', content, 0);

  if (content.children().length === 0) {
    if (options) {
      primaryText = options.primaryText;
      secondaryText = options.secondaryText;
    }

    oj.PullToRefreshUtils._createDefaultContent(content, primaryText, secondaryText);
  }

  content.prev().text(oj.PullToRefreshUtils._getTranslatedString('oj-pullToRefresh.ariaRefreshingLink')); // set it back to auto so we can get the actual height

  content.css('height', 'auto');
  $.data(content[0], 'data-panelheight', content.outerHeight());
};

oj.PullToRefreshUtils._handleRelease = function (event, element, content, refreshFunc) {
  var height;
  var icon;
  var lastIconClass;
  var busyContext;
  var busyStateResolve;

  var _listener2;

  height = $.data(content[0], 'data-panelheight');
  content.addClass('oj-pulltorefresh-transition').css('height', height);

  oj.PullToRefreshUtils._fireEvent(event, 'release', content, height); // mark that we are in loading stage


  $.data(content[0], 'data-loading', true);
  icon = content.find('.oj-pulltorefresh-icon');

  if (icon.length > 0) {
    // remove last class
    lastIconClass = $.data(content[0], 'data-lasticonclass');

    if (lastIconClass != null) {
      icon.removeClass(lastIconClass);
    }

    icon.addClass('oj-pulltorefresh-icon-full');
  } // register busy state with host as the context, note you can't pull again until release is done


  busyContext = Context.getContext(element).getBusyContext();
  busyStateResolve = busyContext.addBusyState({
    description: 'PullToRefresh:handleRelease'
  });
  $.data($(element)[0], 'data-pulltorefresh-busystate', busyStateResolve);
  refreshFunc().then(function () {
    _listener2 = function listener() {
      oj.PullToRefreshUtils._fireEvent(event, 'complete', content, height); // cleanup after everything is complete


      oj.PullToRefreshUtils._cleanup(content);

      content.off('transitionend', _listener2); // clear the text, otherwise voice over will allow text to be focusable

      content.prev().text(''); // clear busy state

      oj.PullToRefreshUtils._resolveBusyState(element);
    }; // change text to complete


    content.prev().text(oj.PullToRefreshUtils._getTranslatedString('oj-pullToRefresh.ariaRefreshCompleteLink')); // hide the link

    content.prev().prev().css('position', ''); // mark that we are in the middle of closing the panel, we want this to complete without interruption

    $.data(content[0], 'data-closing', true);
    content.on('transitionend', _listener2);
    content.css('height', 0);
  }, function () {
    _listener2 = function _listener() {
      // cleanup after everything is complete
      oj.PullToRefreshUtils._cleanup(content);

      content.off('transitionend', _listener2); // clear the text, otherwise voice over will allow text to be focusable

      content.prev().text(''); // clear busy state

      oj.PullToRefreshUtils._resolveBusyState(element);
    }; // hide the link


    content.prev().prev().css('position', ''); // mark that we are in the middle of closing the panel, we want this to complete without interruption

    $.data(content[0], 'data-closing', true);
    content.on('transitionend', _listener2);
    content.css('height', 0);
  });
};
/**
 * Removes the listener that was added in setupPullToRefresh.  Page authors should call tearDownPullToRefresh when the content container is no longer needed.
 *
 * @export
 * @param {Element} element the DOM element that hosts the content to refresh
 * @return {void}
 *
 * @see #setupPullToRefresh
 */


oj.PullToRefreshUtils.tearDownPullToRefresh = function (element) {
  // remove the content panel
  $(element).children('.oj-pulltorefresh-outer').remove(); // remove all listeners

  $(element).off('.pulltorefresh'); // free up busy state if it's not done already

  oj.PullToRefreshUtils._resolveBusyState(element);
};
/**
 * Helper method to resolve busy state
 * @param {Element} element the DOM element that hosts the content to refresh
 * @private
 */


oj.PullToRefreshUtils._resolveBusyState = function (element) {
  var elem;
  var busyStateResolve;
  elem = $(element)[0];
  busyStateResolve =
  /** @type {Function} */
  $.data(elem, 'data-pulltorefresh-busystate');

  if (busyStateResolve) {
    busyStateResolve(null);
    $.removeData(elem, 'data-pulltorefresh-busystate');
  }
};
/**
 * Helper method to fire specific event
 * @private
 */


oj.PullToRefreshUtils._fireEvent = function (originalEvent, key, content, distance) {
  var event = $.Event('oj' + key);
  event.originalEvent = originalEvent;
  content.trigger(event, {
    content: content,
    distance: distance
  });
};
/**
 * Creates default content inside refresh panel if one is not provided by the app through callbacks
 * @private
 */


oj.PullToRefreshUtils._createDefaultContent = function (content, primaryText, secondaryText) {
  var icon;
  var iconContainer;
  var primary;
  var secondary;
  content.addClass('oj-pulltorefresh-content').attr('aria-hidden', 'true');
  icon = $(document.createElement('div'));
  icon.addClass('oj-icon oj-pulltorefresh-icon oj-pulltorefresh-icon-initial');
  iconContainer = $(document.createElement('div'));
  iconContainer.addClass('oj-pulltorefresh-icon-container');
  iconContainer.append(icon); // @HTMLUpdateOK

  $.data(content[0], 'data-lasticonclass', 'oj-pulltorefresh-icon-initial');
  content.append(iconContainer); // @HTMLUpdateOK

  if (primaryText != null) {
    primary = $(document.createElement('div')).addClass('oj-pulltorefresh-primary-text').text(primaryText);
    content.append(primary); // @HTMLUpdateOK
    // you can't have secondary text without primary text

    if (secondaryText != null) {
      secondary = $(document.createElement('div')).addClass('oj-pulltorefresh-secondary-text').text(secondaryText);
      content.append(secondary); // @HTMLUpdateOK
    }
  }
};
/**
 * Show/hide primary/secondary text.  We don't want to show the text until the refresh icon
 * is fully visible otherwise they will overlap.
 * @private
 */


oj.PullToRefreshUtils._showHideDefaultText = function (content, show) {
  var primaryText;
  var secondaryText;
  primaryText = content.find('.oj-pulltorefresh-primary-text');
  secondaryText = content.find('.oj-pulltorefresh-secondary-text');

  if (show) {
    if (primaryText) {
      primaryText.show();
    }

    if (secondaryText) {
      secondaryText.show();
    }
  } else {
    if (primaryText) {
      primaryText.hide();
    }

    if (secondaryText) {
      secondaryText.hide();
    }
  }
};
/**
 * Renders link to provide accessible way to refresh content
 * @private
 */


oj.PullToRefreshUtils._renderAccessibleLink = function (element, panel, refreshFunc, options) {
  var link;
  var content;
  var status;
  link = $(document.createElement('a'));
  link.text(oj.PullToRefreshUtils._getTranslatedString('oj-pullToRefresh.ariaRefreshLink'));
  link.addClass('oj-helper-hidden-accessible').attr('href', '#').focus(function () {
    // the link should be visible when tab to
    // note if removeClass("oj-helper-hidden-accessible") is used here then it would cause
    // weird behavior in Voiceover where the link will be skip immediately after focus
    link.css('position', 'static');
  }).blur(function (event) {
    // Voiceover focus would immediately cause a blur when making the link visible
    if (event.relatedTarget != null) {
      link.css('position', '');
    }
  }).click(function (event) {
    content = panel.children().last();

    oj.PullToRefreshUtils._handlePull(event, content, options);

    oj.PullToRefreshUtils._handleRelease(event, element, content, refreshFunc);
  });
  status = $(document.createElement('div'));
  status.addClass('oj-helper-hidden-accessible').attr('aria-live', 'polite');
  panel.append(link); // @HTMLUpdateOK

  panel.append(status); // @HTMLUpdateOK
};
/**
 * Get translated string given string.
 * This will select pullToRefresh translations, then Refresher translations if needed
 * @private
 */


oj.PullToRefreshUtils._getTranslatedString = function (str) {
  var translatedString = Translations.getTranslatedString(str); // if translatedString is the same, pullToRefresh translations don't exist

  if (translatedString === str) {
    var strArray = str.split('.');
    var refresherString = 'oj-ojRefresher.' + strArray[1];
    translatedString = Translations.getTranslatedString(refresherString);
  }

  return translatedString;
};
/**
 * Cleanup internals
 * @private
 */


oj.PullToRefreshUtils._cleanup = function (content) {
  var icon;
  $.removeData(content[0], 'data-pullstart');
  $.removeData(content[0], 'data-pullstart-horiz');
  $.removeData(content[0], 'data-loading');
  $.removeData(content[0], 'data-closing'); // only clear if it's the default panel, give app full control on custom content

  icon = content.find('.oj-pulltorefresh-icon');

  if (icon.length > 0) {
    content.empty();
  }
};
/**
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Target</th>
 *       <th>Gesture</th>
 *       <th>Action</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td>Pull to refresh panel element</td>
 *       <td><kbd>Pan</kbd></td>
 *       <td>Shows the pull to refresh panel as user pan downward.  Refresh action is triggered if the user pan downward over a specified threshold.</td>
 *     </tr>
 *   </tbody>
 * </table>
 *
 * @ojfragment touchDoc - Used in touch gesture section of classdesc, and standalone gesture doc
 * @memberof oj.PullToRefreshUtils
 */

/**
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Target</th>
 *       <th>Key</th>
 *       <th>Action</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td>Pull to refresh panel element</td>
 *       <td><kbd>Tab</kbd></td>
 *       <td>Shift focus to refresh action link.</td>
 *     </tr>
 *     <tr>
 *       <td>Link</td>
 *       <td><kbd>Enter</kbd></td>
 *       <td>Invoke refresh action.</td>
 *     </tr>
 *   </tbody>
 * </table>
 *
 * @ojfragment keyboardDoc - Used in keyboard section of classdesc, and standalone gesture doc
 * @memberof oj.PullToRefreshUtils
 */

  ;return oj.PullToRefreshUtils;
});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojdatacollection-common',['ojs/ojcore', 'jquery'], function(oj, $)
{
  "use strict";


/**
 * This class contains utility methods used by the data collection components (DataGrid, Listview, and Table).
 * @private
 */
var DataCollectionUtils = function DataCollectionUtils() {};
/**
 * @private
 */


DataCollectionUtils._TAB_INDEX = 'tabIndex';
/**
 * @private
 */

DataCollectionUtils._DATA_OJ_TABMOD = 'data-oj-tabmod';
/** ******************* focusable/editable element related methods *****************/

/**
 * Finds all the focusable elements in a node
 * @param {Element} node
 * @param {boolean=} skipVisibilityCheck
 * @return {Element[]} An array of all of the focusable elements in a node
 * @private
 */

DataCollectionUtils.getFocusableElementsInNode = function (node, skipVisibilityCheck) {
  var inputElems = []; // a nodes without href are not focusable

  var nodes = node.querySelectorAll("input, select, button, a[href], textarea, object, [tabIndex]:not([tabIndex='-1'])");
  var nodeCount = nodes.length; // in IE, each 'option' after 'select' elem will be counted as an input element(and cause duplicate input elems returned)
  // this will cause problem with TAB/Shift-TAB (recognizing whether to go to next cell or to tab within the current cell

  for (var i = 0; i < nodeCount; i++) {
    var elem = nodes[i];

    if (!elem.disabled && (skipVisibilityCheck || elem.style.display !== 'none')) {
      var tabIndex = parseInt(elem.getAttribute(DataCollectionUtils._TAB_INDEX), 10);

      if (isNaN(tabIndex) || tabIndex >= 0) {
        inputElems.push(elem);
      }
    }
  }

  return inputElems;
};
/**
 * Make all focusable elements within the specified element unfocusable
 * @param {Element} element
 * @param {boolean=} skipVisibilityCheck
 * @param {boolean=} excludeActiveElement
 * @return {Element[]} An array of the disabled elements
 * @private
 */


DataCollectionUtils.disableAllFocusableElements = function (element, skipVisibilityCheck, excludeActiveElement) {
  var disabledElems = []; // make all focusable elements non-focusable, since we want to manage tab stops

  var focusElems = DataCollectionUtils.getFocusableElementsInNode(element, skipVisibilityCheck);

  for (var i = 0; i < focusElems.length; i++) {
    if (!excludeActiveElement || focusElems[i] !== document.activeElement) {
      var tabIndex = parseInt(focusElems[i].getAttribute(DataCollectionUtils._TAB_INDEX), 10); // store the tabindex as an attribute

      focusElems[i].setAttribute(DataCollectionUtils._DATA_OJ_TABMOD, tabIndex); // @HTMLUpdateOK

      focusElems[i].setAttribute(DataCollectionUtils._TAB_INDEX, -1); // @HTMLUpdateOK

      disabledElems.push(focusElems[i]);
    }
  }

  return disabledElems;
};
/**
 * Enable all focusable elements within the specified element that were previously disabled
 * @param {Element} element
 * @return {Element[]} An array of the enabled elements
 * @private
 */


DataCollectionUtils.enableAllFocusableElements = function (element) {
  // make all non-focusable elements focusable again
  var focusElems = element.querySelectorAll('[' + DataCollectionUtils._DATA_OJ_TABMOD + ']');

  for (var i = 0; i < focusElems.length; i++) {
    var tabIndex = parseInt(focusElems[i].getAttribute(DataCollectionUtils._DATA_OJ_TABMOD), 10);
    focusElems[i].removeAttribute(DataCollectionUtils._DATA_OJ_TABMOD); // restore tabIndex as needed

    if (isNaN(tabIndex)) {
      focusElems[i].removeAttribute(DataCollectionUtils._TAB_INDEX);
    } else {
      focusElems[i].setAttribute(DataCollectionUtils._TAB_INDEX, tabIndex); // @HTMLUpdateOK
    }
  }

  return focusElems;
};
/**
 * Handle a tab that is pressed when in actionable mode
 * @param {Event} event the event causing the actionable tab
 * @param {Element|undefined|null} element to unset actionable
 * @returns {boolean} true if we have shifted focus within the actionable cell
 * @private
 */


DataCollectionUtils.handleActionableTab = function (event, element) {
  var focusElems = DataCollectionUtils.getFocusableElementsInNode(element);

  if (focusElems.length > 0 && event.target === focusElems[focusElems.length - 1]) {
    // recycle to first focusable element in the cell
    focusElems[0].focus();
    return true;
  } // let the tab go to the next item in the cell on its own


  return false;
};
/**
 * Handle a tab that is pressed when in actionable mode
 * @param {Event} event the event causing the actionable tab
 * @param {Element|undefined|null} element to unset actionable
 * @returns {boolean} true if we have shifted focus within the actionable cell
 * @private
 */


DataCollectionUtils.handleActionablePrevTab = function (event, element) {
  var focusElems = DataCollectionUtils.getFocusableElementsInNode(element);

  if (focusElems.length > 0 && event.target === focusElems[0]) {
    // recycle to last focusable element in the cell
    focusElems[focusElems.length - 1].focus();
    return true;
  } // let the tab go to the previous item in the cell on its own


  return false;
};
/** ******************* general collection utility methods *****************/

/**
 * Get the default scroll bar width of the given element
 * @param {Element} element the element to get the default scroll bar width of
 * @private
 */


DataCollectionUtils.getDefaultScrollBarWidth = function (element) {
  var scrollBarWidth;

  if (element && element.style) {
    // save current styling to ensure it is restored once completed
    var visibility = element.style.visibility;
    var position = element.style.position;
    var overflowY = element.style.overflowY;
    var height = element.style.height;
    var width = element.style.width;
    /* eslint-disable no-param-reassign */

    element.style.visibility = 'hidden';
    element.style.position = 'absolute';
    element.style.overflowY = 'hidden';
    element.style.height = '50px';
    element.style.width = '50px'; // since offsetWidth includes padding and borders that clientWidth does not,
    // first save the initial difference when overflow is hidden to use below

    var initialDiff = element.offsetWidth - element.clientWidth; // set overflow to 'scroll', and then find the difference in offsetWidth and clientWidth
    // compared to the initial difference found above

    element.style.overflowY = 'scroll';
    scrollBarWidth = element.offsetWidth - element.clientWidth - initialDiff;
    element.style.width = width;
    element.style.height = height;
    element.style.overflowY = overflowY;
    element.style.position = position;
    element.style.visibility = visibility;
    /* eslint-enable no-param-reassign */
  }

  return scrollBarWidth;
};
/**
 * Disables unwanted default browser styling on the element specified
 * @param {Element} element the element to disable unwanted browser styling on
 * @private
 */


DataCollectionUtils.disableDefaultBrowserStyling = function (element) {
  // attribute to disable auto links for phone numbers on ie/edge which break accessibility
  element.setAttribute('x-ms-format-detection', 'none');
};
/**
 * Merges additional styling with an element's existing styling.
 * @param {Element} element the element to apply the merged styling to
 * @param {string} initStyle the current style string of the element
 * @param {string} addedStyle the additional style string to apply to the element
 */


DataCollectionUtils.applyMergedInlineStyles = function (element, initStyle, addedStyle) {
  var addedStyleObj = DataCollectionUtils.convertStringToStyleObj(addedStyle);
  var initStyleObj = DataCollectionUtils.convertStringToStyleObj(initStyle);
  var mergedStyle = Object.assign({}, addedStyleObj, initStyleObj);
  DataCollectionUtils.applyStyleObj(element, mergedStyle);
};
/**
 * Converts an HTML inline style string to a style object whose keys represent style properties
 * and whose values represent the style values.
 * @param {string} the HTML inline style string to be converted
 * @private
 */


DataCollectionUtils.convertStringToStyleObj = function (styleString) {
  var retObj = {};

  if (styleString.split) {
    var splitArr = styleString.split(';');

    for (var i = 0; i < splitArr.length; i++) {
      var property = splitArr[i];

      if (property !== '') {
        var propArr = property.split(':');

        if (propArr.length === 2) {
          retObj[propArr[0].trim()] = propArr[1].trim();
        }
      }
    }
  }

  return retObj;
};
/**
 * Applies an object whose keys represent style properties and whose values represent the style
 * values to a given element.
 * @param {element} the element to apply the style object to
 * @param {Object} the style object to be converted
 * @private
 */


DataCollectionUtils.applyStyleObj = function (element, styleObj) {
  var stylePropArr = Object.keys(styleObj);
  var styleValArr = Object.values(styleObj);

  for (var i = 0; i < stylePropArr.length; i++) {
    /* eslint-disable no-param-reassign */
    element.style[stylePropArr[i]] = styleValArr[i];
  }
};
/** ******************* selected KeySet related methods *****************/

/**
 * Checks whether the given KeySet instances represent equivalent sets
 * @param {KeySet} keySet1 the first KeySet
 * @param {KeySet} keySet2 the second KeySet
 * @returns {boolean} true if the given KeySet instances represent equivalent sets
 * @private
 */


DataCollectionUtils.areKeySetsEqual = function (keySet1, keySet2) {
  if (keySet1 === keySet2) {
    return true;
  }

  var isAddAll = keySet1.isAddAll();

  if (isAddAll !== keySet2.isAddAll()) {
    return false;
  }

  var valueSet1;
  var valueSet2;

  if (isAddAll) {
    valueSet1 = keySet1.deletedValues();
    valueSet2 = keySet2.deletedValues();
  } else {
    valueSet1 = keySet1.values();
    valueSet2 = keySet2.values();
  }

  if (valueSet1.size !== valueSet2.size) {
    return false;
  }

  var valueIterator1 = valueSet1.values();
  var valueIterator2 = valueSet2.values();
  var result1 = valueIterator1.next();
  var result2 = valueIterator2.next();

  while (!result1.done) {
    if (!oj.KeyUtils.equals(result1.value, result2.value)) {
      return false;
    }

    result1 = valueIterator1.next();
    result2 = valueIterator2.next();
  }

  return true;
};
/** **************** keyboard event handling methods ****************** */


DataCollectionUtils.KEYBOARD_KEYS = {
  _SPACEBAR: ' ',
  _SPACEBAR_IE: 'SpaceBar',
  _SPACEBAR_CODE: 32,
  _ENTER: 'Enter',
  _ENTER_CODE: 13,
  _UP: 'ArrowUp',
  _UP_IE: 'Up',
  _UP_CODE: 38,
  _DOWN: 'ArrowDown',
  _DOWN_IE: 'Down',
  _DOWN_CODE: 40,
  _LEFT: 'ArrowLeft',
  _LEFT_IE: 'Left',
  _LEFT_CODE: 37,
  _RIGHT: 'ArrowRight',
  _RIGHT_IE: 'Right',
  _RIGHT_CODE: 39,
  _HOME: 'Home',
  _HOME_CODE: 36,
  _END: 'End',
  _END_CODE: 35,
  _TAB: 'Tab',
  _TAB_CODE: 9,
  _ESCAPE: 'Escape',
  _ESCAPE_IE: 'Esc',
  _ESCAPE_CODE: 27,
  _F2: 'F2',
  _F2_CODE: 113
};
/**
 * @private
 */

DataCollectionUtils.isEnterKeyEvent = function (eventKey) {
  return eventKey === DataCollectionUtils.KEYBOARD_KEYS._ENTER || eventKey === DataCollectionUtils.KEYBOARD_KEYS._ENTER_CODE;
};
/**
 * @private
 */


DataCollectionUtils.isSpaceBarKeyEvent = function (eventKey) {
  return eventKey === DataCollectionUtils.KEYBOARD_KEYS._SPACEBAR || eventKey === DataCollectionUtils.KEYBOARD_KEYS._SPACEBAR_IE || eventKey === DataCollectionUtils.KEYBOARD_KEYS._SPACEBAR_CODE;
};
/**
 * @private
 */


DataCollectionUtils.isEscapeKeyEvent = function (eventKey) {
  return eventKey === DataCollectionUtils.KEYBOARD_KEYS._ESCAPE || eventKey === DataCollectionUtils.KEYBOARD_KEYS._ESCAPE_IE || eventKey === DataCollectionUtils.KEYBOARD_KEYS._ESCAPE_CODE;
};
/**
 * @private
 */


DataCollectionUtils.isTabKeyEvent = function (eventKey) {
  return eventKey === DataCollectionUtils.KEYBOARD_KEYS._TAB || eventKey === DataCollectionUtils.KEYBOARD_KEYS._TAB_CODE;
};
/**
 * @private
 */


DataCollectionUtils.isF2KeyEvent = function (eventKey) {
  return eventKey === DataCollectionUtils.KEYBOARD_KEYS._F2 || eventKey === DataCollectionUtils.KEYBOARD_KEYS._F2_CODE;
};
/**
 * @private
 */


DataCollectionUtils.isHomeKeyEvent = function (eventKey) {
  return eventKey === DataCollectionUtils.KEYBOARD_KEYS._HOME || eventKey === DataCollectionUtils.KEYBOARD_KEYS._HOME_CODE;
};
/**
 * @private
 */


DataCollectionUtils.isEndKeyEvent = function (eventKey) {
  return eventKey === DataCollectionUtils.KEYBOARD_KEYS._END || eventKey === DataCollectionUtils.KEYBOARD_KEYS._END_CODE;
};
/**
 * @private
 */


DataCollectionUtils.isArrowUpKeyEvent = function (eventKey) {
  return eventKey === DataCollectionUtils.KEYBOARD_KEYS._UP || eventKey === DataCollectionUtils.KEYBOARD_KEYS._UP_IE || eventKey === DataCollectionUtils.KEYBOARD_KEYS._UP_CODE;
};
/**
 * @private
 */


DataCollectionUtils.isArrowDownKeyEvent = function (eventKey) {
  return eventKey === DataCollectionUtils.KEYBOARD_KEYS._DOWN || eventKey === DataCollectionUtils.KEYBOARD_KEYS._DOWN_IE || eventKey === DataCollectionUtils.KEYBOARD_KEYS._DOWN_CODE;
};
/**
 * @private
 */


DataCollectionUtils.isArrowLeftKeyEvent = function (eventKey) {
  return eventKey === DataCollectionUtils.KEYBOARD_KEYS._LEFT || eventKey === DataCollectionUtils.KEYBOARD_KEYS._LEFT_IE || eventKey === DataCollectionUtils.KEYBOARD_KEYS._LEFT_CODE;
};
/**
 * @private
 */


DataCollectionUtils.isArrowRightKeyEvent = function (eventKey) {
  return eventKey === DataCollectionUtils.KEYBOARD_KEYS._RIGHT || eventKey === DataCollectionUtils.KEYBOARD_KEYS._RIGHT_IE || eventKey === DataCollectionUtils.KEYBOARD_KEYS._RIGHT_CODE;
};

;return DataCollectionUtils;
});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojanimation',['ojs/ojcore', 'jquery', 'ojs/ojthemeutils', 'ojs/ojlogger', 'ojs/ojcomponentcore'], function(oj, $, ThemeUtils, Logger)
{
  "use strict";
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }



/* global Promise:false, Logger:false, ThemeUtils:false */

/**
 * Utility methods for animating elements.
 *
 * <h3 id="custom-animation-section">
 *   Customizing and Disabling Animation
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#custom-animation-section"></a>
 * </h3>
 *
 * Default animations can be customized or disabled at several levels with varying degrees of control:
 * <ol>
 *   <li>For all JET components.</li>
 *   <li>For all instances of a JET component.</li>
 *   <li>For one instance of a JET component.</li>
 * </ol>
 *
 * <h4>1. For all JET components</h4>
 *
 * <p>There are several theme variables that control the speed of animations in JET.  Applications can change their values
 * to speed up or slow down animations for all components, or to disable animations altogether by setting them to 0:</p>
 * <pre class="prettyprint"><code>$animationDurationShort: .25s !default;
 * $animationDurationMedium: .4s !default;
 * $animationDurationLong: .5s !default;
 * </code></pre>
 * <p>Note that setting them to 0 does not make the actions that invoke animations synchronous.  For example, opening a dialog is an asynchronous
 * action.  By setting the animation duration to 0 simply makes the dialog appear to open immediately.  Events related to the dialog opening
 * are still fired asynchronously, though with a much shorter delay.</p>
 *
 * <h4>2. For All Instances of a JET Component.</h4>
 *
 * <p>Default animations for JET components are defined by component-specific theme variables.  Changing the values of the theme variables for a particular component
 * will affect the default animations for all instances of that component.  These theme variables are listed in the API documentation
 * for the <code class="prettyprint">ojAnimateStart</code> event of each component.</p>
 *
 * <h4>3. For One Instance of a JET Component</h4>
 *
 * <p>Applications can customize animations triggered by actions in some components by listening for <code class="prettyprint">ojAnimateStart/ojAnimateEnd</code>
 *    events and override action specific animations.  See the documentation of individual components for support details of <code
 *    class="prettyprint">ojAnimateStart/ojAnimateEnd</code> events and the associated actions.</p>
 * <p>To customize an animation, applications first listen to <code class="prettyprint">ojAnimateStart</code> event and cancel the default animation.  Then
 *    specify the new animation in one of several ways:</p>
 * <ul>
 *   <li>Call one of the animation effect methods in oj.AnimationUtils.</li>
 *   <li>Call a 3rd-party animation function with a Javascript API, such as GreenSock, Velocity.js, etc.</li>
 *   <li>Define action-specific CSS style classes on the animated item.  When an action triggers animation, a marker class of the form "oj-animate-&lt;action&gt;"
 *       (e.g. "oj-animate-open") is added to the animated element.  After a slight delay, a second marker class of the form "oj-animate-&lt;action&gt;-active"
 *       (e.g. "oj-animate-open-active") is added.  This allows application to define CSS transition on the element.</li>
 * </ul>
 *
 * <h4>Examples</h4>
 * <br>
 * <i>Disable a default "open" animation:</i>
 * <pre class="prettyprint"><code>
 * myComponent.addEventListener( "ojAnimateStart", function( event ) {
 *   if (event.detail.action == "open") {
 *     event.preventDefault();
 *     event.detail.endCallback();
 *   }
 * });
 * </code></pre>
 * <br>
 * <i>Customize a default "open" animation with oj.AnimationUtils method:</i>
 * <pre class="prettyprint"><code>
 * myComponent.addEventListener( "ojAnimateStart", function( event ) {
 *   if (event.detail.action == "open") {
 *     event.preventDefault();
 *     oj.AnimationUtils.slideIn(event.detail.element).then(event.detail.endCallback);
 *   }
 * });
 * </code></pre>
 * <br>
 * <i>Customize a default "update" animation with CSS style classes:</i>
 * <pre class="prettyprint"><code>
 * // Cancel the default animation in the event listener
 * myComponent.addEventListener( "ojAnimateStart", function( event ) {
 *   if (event.detail.action == "update") {
 *     event.preventDefault();
 *     event.detail.endCallback();
 *   }
 * });
 *
 * </code></pre>
 *
 * <pre class="prettyprint"><code>
 * /* Define new animation in CSS
 *    Different selectors may be needed to target the CSS correctly *&#47;
 *
 * /* State to animate from is marked by oj-animate-&lt;action&gt; class *&#47;
 * .selector .oj-animate-update {
 *   color: red;
 * }
 *
 * /* State to animate to is marked by oj-animate-&lt;action&gt; and oj-animate-&lt;action&gt;-active classes *&#47;
 * .selector .oj-animate-update.oj-animate-update-active {
 *   transition: color 1s;
 *   color: black;
 * }
 * </code></pre>
 *
 * <h3 id="busy-state-section">
 *   Adding Busy State
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#busy-state-section"></a>
 * </h3>
 *
 * <p>Animations are asynchronous by nature.  Sometimes applications may need to wait for an animation to end before
 *    proceeding with other operations.  All the effect methods in oj.AnimationUtils return promises that are
 *    resolved when the animations end.</p>
 * <p>In cases where applications use the {@link oj.BusyContext} class to track the busy state of components or pages, it is
 *    up to the callers of the effect methods to add busy state to the appropriate context, which may or may not
 *    be the context that contains the element being animated.</p>
 *
 * <h4>Examples</h4>
 * <br>
 * <i>Add a busy state while an animation is in progress:</i>
 * <pre class="prettyprint"><code>
 * // Context node is usually the animated element but can also be a node for any
 * // context that wants to wait for the animation to end.
 * var contextNode = element;
 * var busyContext = oj.Context.getContext(contextNode).getBusyContext();
 * var resolveFunc = busyContext.addBusyState({"description": "Animation in progress"});
 * oj.AnimationUtils.slideOut(element).then(resolveFunc);
 * </code></pre>
 *
 * @namespace
 * @ojtsmodule
 * @since 2.1
 * @export
 */
oj.AnimationUtils = {}; // this is the variable name that the AMD module will return in the require callback (used in a no-require environment)
// eslint-disable-next-line no-unused-vars

var AnimationUtils = oj.AnimationUtils; // Return a platform-dependent property or event name from a base name

oj.AnimationUtils._getName = function (element, baseName) {
  if (!oj.AnimationUtils._nameMap) {
    oj.AnimationUtils._nameMap = {};
    var nameMap = oj.AnimationUtils._nameMap;
    var style = element.style; // Property names

    nameMap.backfaceVisibility = style.webkitBackfaceVisibility !== undefined ? 'webkitBackfaceVisibility' : 'backfaceVisibility';
    nameMap.transform = style.webkitTransform !== undefined ? 'webkitTransform' : 'transform';
    nameMap.transformOrigin = style.webkitTransformOrigin !== undefined ? 'webkitTransformOrigin' : 'transformOrigin';
    nameMap.transition = style.webkitTransition !== undefined ? 'webkitTransition' : 'transition'; // Event names

    nameMap.transitionend = style.webkitTransition !== undefined ? 'webkitTransitionEnd' : 'transitionend';
  }

  var mappedName = oj.AnimationUtils._nameMap[baseName];
  return mappedName || baseName;
};

oj.AnimationUtils._getElementStyle = function (element, baseName) {
  return element.style[oj.AnimationUtils._getName(element, baseName)];
};

oj.AnimationUtils._setElementStyle = function (element, baseName, value) {
  // eslint-disable-next-line no-param-reassign
  element.style[oj.AnimationUtils._getName(element, baseName)] = value;
};
/**
 * Main utility function for starting a css transition on an element.<br>
 * Currently this function assumes the following:<br>
 * 1. If multiple properties are animated, they all use the same delay and duration.<br>
 * All css property names should be specified in camel case.
 * @param {Element} element  the HTML element to animate
 * @param {Object} fromState  the css class and properties for setting up the starting state
 * @param {Object} toState  the css class and properties for setting up the ending state
 * @param {Object} options  the common options for the css transition or animation.  This
 *                          include 'delay', 'duration', 'timingFunction', and 'persist'.
 * @param {Array} transProps  an array of css properties being transitioned.
 * @param {Array=} persistProps  an array of css properties to persist if the persist option is set.
 *                               If this is omitted, it will be set to transProps.
 * @return {Promise|IThenable} a promise that will be resolved when the animation ends
 * @private
 */


oj.AnimationUtils._animate = function (element, fromState, toState, options, transProps, persistProps) {
  var propArray = [].concat(transProps); // eslint-disable-next-line no-unused-vars

  var doAnimate = function doAnimate(resolve, reject) {
    var endListener = function endListener(event) {
      // event.propertyName is the hyphenated name.  Entries in propArray is the
      // camel-case name without prefix.  So we drop any prefix and convert
      // event.propertyName to camel-case before finding it in propArray.
      var basePropName = event.propertyName.indexOf('-webkit-') === 0 ? event.propertyName.substr(8) : event.propertyName;
      basePropName = oj.AnimationUtils._getCamelCasePropName(basePropName);
      var idx = propArray.indexOf(basePropName);

      if (idx > -1) {
        if (propArray.length > 1) {
          propArray.splice(idx, 1);
        } else {
          resolvePromise();
        }
      }
    };

    var requestId = 0;
    var promiseResolved = false;

    function resolvePromise() {
      if (!promiseResolved) {
        if (requestId) {
          window.cancelAnimationFrame(requestId);
          requestId = 0;
        }

        element.removeEventListener(oj.AnimationUtils._getName(element, 'transitionend'), endListener);

        if (resolve) {
          resolve(true);
        }

        promiseResolved = true;
      }
    } // For css transition, specify the transition value when applying the toState
    // since we don't want to trigger the transition prematurely.


    if (toState == null) {
      // eslint-disable-next-line no-param-reassign
      toState = {};
    }

    if (toState.css == null) {
      // eslint-disable-next-line no-param-reassign
      toState.css = {};
    } // eslint-disable-next-line no-param-reassign


    toState.css.transition = oj.AnimationUtils._createTransitionValue(element, transProps, options); // Save the orignal style so that we can restore it later if needed

    var effectCount = oj.AnimationUtils._saveStyle(element, fromState, toState, options, persistProps || transProps);

    oj.AnimationUtils._applyState(element, fromState, effectCount > 1);

    element.addEventListener(oj.AnimationUtils._getName(element, 'transitionend'), endListener);
    var duration = options.duration;
    var delay = options.delay;
    var skipPromise = options._skipPromise;

    function transitionFunc() {
      requestId = 0;

      oj.AnimationUtils._applyState(element, toState, effectCount > 1);
    }

    if (fromState == null) {
      // If there is no fromState, assume that we are transitioning from the
      // current state to a new state, so just apply toState immediately.
      transitionFunc();
    } else {
      if (!options._noReflow) {
        // If the final state is the same as current state,
        // requestAnimationFrame may not trigger a transition.  Need to force
        // a reflow after applying the initial state by getting one of several
        // properties that cause reflow.
        //
        // Assign it to an export object so that Closure compiler will not remove
        // this as dead code
        oj.AnimationUtils._x = element.offsetWidth;
      } // Add the toState after a delay.  This is necessary to trigger css
      // transition.


      requestId = window.requestAnimationFrame(transitionFunc);
    }

    var totalMs = oj.AnimationUtils._getTotalTiming(duration, delay);

    if (!skipPromise) {
      // There are situations in which the transitionend event is never
      // fired (e.g. removing the transiton property or setting the display
      // property to none.)
      // Add a timeout to avoid having unresolved promise.
      setTimeout(resolvePromise, totalMs + 100);
    }
  }; // Special option to skip promise to reduce overhead.  A side effect is that
  // no clean up will be done on the element, which is fine if the element is
  // temporary


  if (options._skipPromise) {
    doAnimate(null, null);
    return null;
  }

  var promise = new Promise(doAnimate);
  return promise.then(function () {
    // Remove any temporary effect class when the promise is fulfilled.
    // Do not remove them in the endListener, since the promise fulfillment
    // callback is not in the same animation frame and occurs later than
    // the endListener.  Because any caller cleanup is done on promise
    // fulfillment, the element may flash if we remove the class too early.
    if (fromState && fromState.addClass) {
      $(element).removeClass(fromState.addClass);
    }

    if (toState && toState.addClass) {
      $(element).removeClass(toState.addClass);
    }

    oj.AnimationUtils._restoreStyle(element);
  });
}; // Save the element style from a property set


oj.AnimationUtils._saveCssValues = function (element, css, savedStyle, persistProps) {
  var cssProps = Object.keys(css);
  var hasOwnProperty = Object.prototype.hasOwnProperty;

  for (var i = 0; i < cssProps.length; i++) {
    var cssProp = cssProps[i];

    if (!hasOwnProperty.call(savedStyle, cssProp) && (!persistProps || persistProps.indexOf(cssProp) === -1)) {
      // eslint-disable-next-line no-param-reassign
      savedStyle[cssProp] = oj.AnimationUtils._getElementStyle(element, cssProp);
    }
  }
}; // Save the original element style before animating it


oj.AnimationUtils._saveStyle = function (element, fromState, toState, options, persistProps) {
  var savedStyle = element._ojSavedStyle || {};
  var fromStateCss = fromState && fromState.css ? fromState.css : {};
  var toStateCss = toState && toState.css ? toState.css : {};
  var _persistProps = persistProps;

  if (!(options && options.persist === 'all')) {
    _persistProps = null;
  }

  oj.AnimationUtils._saveCssValues(element, fromStateCss, savedStyle, _persistProps);

  oj.AnimationUtils._saveCssValues(element, toStateCss, savedStyle, _persistProps); // eslint-disable-next-line no-param-reassign


  element._ojSavedStyle = savedStyle; // Remember how many times this is called to allow composite animation

  var effectCount = element._ojEffectCount || 0;
  effectCount += 1; // eslint-disable-next-line no-param-reassign

  element._ojEffectCount = effectCount;
  return effectCount;
}; // Restore the original element style


oj.AnimationUtils._restoreStyle = function (_element) {
  var element = _element;
  var effectCount = element._ojEffectCount; // In case of composite animation, restore style when the last effect has ended

  if (effectCount > 1) {
    element._ojEffectCount = effectCount - 1;
  } else {
    var savedStyle = element._ojSavedStyle;

    if (savedStyle) {
      var props = Object.keys(savedStyle);

      for (var i = 0; i < props.length; i++) {
        var prop = props[i];

        oj.AnimationUtils._setElementStyle(element, prop, savedStyle[prop]);
      }

      delete element._ojSavedStyle;
      delete element._ojEffectCount;
    }
  }
}; // Get the corresponding camel-cased property name


oj.AnimationUtils._getCamelCasePropName = function (propName) {
  if (propName.indexOf('-') >= 0) {
    var newName = '';
    var strArray = propName.split('-');

    for (var i = 0; i < strArray.length; i++) {
      var subStr = strArray[i];

      if (subStr) {
        if (newName) {
          newName += subStr.charAt(0).toUpperCase() + subStr.slice(1);
        } else {
          // Keep the first segment in lower case
          newName = subStr;
        }
      }
    }

    return newName;
  }

  return propName;
}; // Get the corresponding hyphenated property name


oj.AnimationUtils._getHyphenatedPropName = function (propName) {
  var newName = propName.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();

  if (newName.indexOf('webkit') === 0) {
    newName = '-' + newName;
  }

  return newName;
}; // Concatenate value for style property that allows multiple values


oj.AnimationUtils._concatMultiValue = function (element, state, propName, defaultPrefix, separator) {
  if (state.css[propName]) {
    var currPropValue = oj.AnimationUtils._getElementStyle(element, propName);

    if (currPropValue && currPropValue.indexOf(defaultPrefix) !== 0) {
      // eslint-disable-next-line no-param-reassign
      state.css[propName] = currPropValue + separator + state.css[propName];
    }
  }
};

oj.AnimationUtils._splitTransform = function (transform) {
  var array = [];

  if (transform && transform !== 'none') {
    var _transform = transform;

    var index = _transform.indexOf(')');

    while (index > 0) {
      var funcExpr = _transform.substr(0, index + 1);

      array.push(funcExpr.trim());
      _transform = _transform.slice(index + 1);
      index = _transform.indexOf(')');
    }
  }

  return array;
};

oj.AnimationUtils._getTransformFuncName = function (funcExpr) {
  var index = funcExpr.indexOf('(');

  if (index >= 1) {
    return funcExpr.substr(0, index);
  }

  return funcExpr;
}; // Apply the transform style


oj.AnimationUtils._applyTransform = function (element, newTransform) {
  var oldTransform = oj.AnimationUtils._getElementStyle(element, 'transform');

  var oldTransformArray = oj.AnimationUtils._splitTransform(oldTransform);

  var newTransformArray = oj.AnimationUtils._splitTransform(newTransform);

  var extraTransformArray = [];

  for (var i = 0; i < newTransformArray.length; i++) {
    var funcName = oj.AnimationUtils._getTransformFuncName(newTransformArray[i]);

    var match = false;

    if (funcName) {
      for (var j = 0; j < oldTransformArray.length; j++) {
        // Search for funcName + '(' since some transform functions can be the
        // prefix of other functions such as translate and translateZ.
        if (oldTransformArray[j].indexOf(funcName + '(') === 0) {
          // Replace any matching old transform function with the new one
          oldTransformArray[j] = newTransformArray[i];
          match = true;
        }
      }
    } // Keep track of any new transform function that wasn't specified


    if (!match) {
      extraTransformArray.push(newTransformArray[i]);
    }
  } // Concatenate the updated transform list with newly added list


  oldTransformArray = oldTransformArray.concat(extraTransformArray); // Return the transform list as a string

  return oldTransformArray.join(' ');
};

oj.AnimationUtils._applyState = function (element, state, isComposite) {
  if (state) {
    if (state.css) {
      var transitionPropName = 'transition';
      var transformPropName = 'transform'; // For composite animation, we need to concatenate certain property values
      // instead of replacing them

      if (isComposite) {
        oj.AnimationUtils._concatMultiValue(element, state, transitionPropName, 'all', ', ');
      }

      if (state.css[transformPropName]) {
        // eslint-disable-next-line no-param-reassign
        state.css[transformPropName] = oj.AnimationUtils._applyTransform(element, state.css[transformPropName]);
      }

      var newStyle = state.css;
      var props = Object.keys(newStyle);

      for (var i = 0; i < props.length; i++) {
        var prop = props[i];

        oj.AnimationUtils._setElementStyle(element, prop, newStyle[prop]);
      }
    }

    if (state.addClass) {
      $(element).addClass(state.addClass);
    }

    if (state.removeClass) {
      $(element).removeClass(state.removeClass);
    }
  }
}; // Get a timing value in millisecond from a string such as duration and delay


oj.AnimationUtils._getTimingValue = function (timingStr) {
  var timingValue = parseFloat(timingStr);

  if (isNaN(timingValue)) {
    return 0;
  }

  return timingStr.indexOf('ms') > -1 ? timingValue : timingValue * 1000;
};

oj.AnimationUtils._getTotalTiming = function (duration, delay) {
  var durationMs = oj.AnimationUtils._getTimingValue(duration);

  if (durationMs > 0) {
    var delayMs = delay ? oj.AnimationUtils._getTimingValue(delay) : 0;
    return durationMs + delayMs;
  }

  return 0;
};

oj.AnimationUtils._calcCssTime = function (propertyStr, delayStr, durationStr) {
  var propertyArray = propertyStr.split(',');
  var delayArray = delayStr.split(',');
  var durationArray = durationStr.split(',');
  var propertyLen = propertyArray.length;
  var delayLen = delayArray.length;
  var durationLen = durationArray.length;
  var maxTime = 0;

  for (var i = 0; i < propertyLen; i++) {
    var duration = durationArray[i % durationLen];
    var delay = delayArray[i % delayLen];

    var totalMs = oj.AnimationUtils._getTotalTiming(duration, delay);

    maxTime = Math.max(maxTime, totalMs);
  }

  return maxTime;
};

oj.AnimationUtils._calcEffectTime = function (element) {
  var style = window.getComputedStyle(element);
  var propertyStr;
  var delayStr;
  var durationStr;
  propertyStr = style.animationName || style.webkitAnimationName;
  delayStr = style.animationDelay || style.webkitAnimationDelay;
  durationStr = style.animationDuration || style.webkitAnimationDuration;

  var animationTime = oj.AnimationUtils._calcCssTime(propertyStr, delayStr, durationStr);

  propertyStr = style.transitionProperty || style.webkitTransitionProperty;
  delayStr = style.transitionDelay || style.webkitTransitionDelay;
  durationStr = style.transitionDuration || style.webkitTransitionDuration;

  var transitionTime = oj.AnimationUtils._calcCssTime(propertyStr, delayStr, durationStr);

  return Math.max(animationTime, transitionTime);
}; // Fill in empty timing options from a set of source options


oj.AnimationUtils._fillEmptyOptions = function (targetOptions, sourceOptions) {
  // eslint-disable-next-line no-param-reassign
  targetOptions.delay = targetOptions.delay || sourceOptions.delay; // eslint-disable-next-line no-param-reassign

  targetOptions.duration = targetOptions.duration || sourceOptions.duration; // eslint-disable-next-line no-param-reassign

  targetOptions.timingFunction = targetOptions.timingFunction || sourceOptions.timingFunction; // eslint-disable-next-line no-param-reassign

  targetOptions.persist = targetOptions.persist || sourceOptions.persist;
}; // Trigger oj custom event


oj.AnimationUtils._triggerEvent = function (element, eventName, ui, component) {
  var defaultPrevented;

  if (component && component._trigger) {
    // _trigger() returns false if preventDefault has been called
    defaultPrevented = !component._trigger(eventName, null, ui);
  } else {
    var ojEventType = 'oj' + eventName.substr(0, 1).toUpperCase() + eventName.substr(1);
    var customEvent = new CustomEvent(ojEventType, {
      detail: ui,
      bubbles: true,
      cancelable: true
    });
    var eventTarget = component || element;

    if (eventTarget.dispatchEvent) {
      eventTarget.dispatchEvent(customEvent);
    }

    defaultPrevented = customEvent.defaultPrevented;
  }

  return defaultPrevented;
};
/**
 * Internal method for starting an animation.
 * @param {Element} element  the HTML element to animate
 * @param {string} action  a component-defined string that identifies the action starting
 *                         the animation, such as "open", "close", "add", "remove", etc.
 * @param {string|Object|Array} effects  The name of one of the effect methods
 *                        in oj.AnimationUtils, or an object that specifies the
 *                        effect method and its options, such as:
 *                        {'effect': 'fadeOut', 'endOpacity': 0.5}, or an array of the above.
 * @param {Object=} component  the component that owns the HTML element
 *                             to animate.  If this is specified and it has a
 *                             _trigger method (jQuery UI widget), animation events will
 *                             be triggered on the component via jQuery UI _trigger(),
 *                             so that listeners specified as event options will work.
 *                             If this is specified but it doesn't have a _trigger
 *                             method (HTML element), animation events will be triggered
 *                             on the component via dispatchEvent.
 *                             If this is not specified, animation events will be triggered
 *                             on the animated HTML element via dispatchEvent.
 * @return {Promise} a promise that will be resolved when the animation ends
 * @export
 * @ignore
 */


oj.AnimationUtils.startAnimation = function (element, action, effects, component) {
  // Temporary fix for callers that are passing in jQuery object
  // eslint-disable-next-line no-param-reassign
  element = $(element)[0];
  var promise = new Promise( // eslint-disable-next-line no-unused-vars
  function (resolve, reject) {
    var jelem = $(element);
    var fromMarker = 'oj-animate-' + action;
    var toMarker = fromMarker + '-active';
    var eventProcessed = false;
    var markerProcessed = false;

    var resolvePromise = function resolvePromise() {
      if (eventProcessed && markerProcessed) {
        jelem.removeClass(fromMarker);
        jelem.removeClass(toMarker);

        oj.AnimationUtils._restoreStyle(element);

        resolve(true);
        var ui = {
          action: action,
          element: element
        };

        oj.AnimationUtils._triggerEvent(element, 'animateEnd', ui, component);
      }
    };

    var eventCallback = function eventCallback() {
      eventProcessed = true;
      resolvePromise();
    };

    var markerCallback = function markerCallback() {
      markerProcessed = true;
      resolvePromise();
    }; // This will add a ref count so that the style is not restored until
    // all effects and user-defined css transitions have ended.  Otherwise
    // there may be screen flash if 'persist' !== 'all'.


    oj.AnimationUtils._saveStyle(element, null, null, null, null); // Trigger ojanimatestart event so that app can prevent default animation
    // and define custom effect in JS


    var ui = {
      action: action,
      element: element,
      endCallback: eventCallback
    };

    var defaultPrevented = oj.AnimationUtils._triggerEvent(element, 'animateStart', ui, component); // Continue animation handling if app didn't preventDefault


    if (!defaultPrevented) {
      var effectArray = [].concat(effects);
      var promiseArray = [];
      var lastOptions = {};

      for (var i = 0; i < effectArray.length; i++) {
        var animationEffect = effectArray[i];
        var effectName = '';
        var effectOptions; // Start any explicit animation effect

        if (animationEffect != null && animationEffect !== 'none') {
          if (typeof animationEffect === 'string') {
            effectName = animationEffect;
            effectOptions = {};
          } else if (_typeof(animationEffect) === 'object') {
            effectName = animationEffect.effect;
            effectOptions = $.extend({}, animationEffect);
          } // Fill in empty timing options with what was specified last


          oj.AnimationUtils._fillEmptyOptions(effectOptions, lastOptions); // Remember the last set of options


          lastOptions = $.extend({}, effectOptions);
        }

        if (effectName && oj.AnimationUtils[effectName]) {
          promiseArray.push(oj.AnimationUtils[effectName](element, effectOptions));
        }
      }

      if (promiseArray.length) {
        Promise.all(promiseArray).then(eventCallback);
      } else {
        eventCallback();
      }
    } // Add marker class so that app can define custom effect in CSS


    jelem.addClass(fromMarker);
    var requestId = window.requestAnimationFrame(function () {
      requestId = 0;
      jelem.addClass(toMarker);

      var totalMs = oj.AnimationUtils._calcEffectTime(element);

      if (totalMs > 0) {
        // Set a timeout to resolve the promise.  We can't rely on
        // transitionend event since there can be multiple transition
        // properties, or the transition is never triggered, or the transition
        // is cancelled.
        setTimeout(markerCallback, totalMs + 100);
      } else {
        markerCallback();
      }
    }); // In case we are in the background and requestAnimationFrame is not
    // called, have a timeout that cancel the request and resolve promise

    setTimeout(function () {
      if (requestId) {
        window.cancelAnimationFrame(requestId);
        requestId = 0;
        markerCallback();
      }
    }, 1000);
  });
  return promise;
};

oj.AnimationUtils._mergeOptions = function (effect, options) {
  if (oj.AnimationUtils._defaultOptions == null) {
    oj.AnimationUtils._defaultOptions = ThemeUtils.parseJSONFromFontFamily('oj-animation-effect-default-options');
  } // At the minimum, we should have a duration.  Merge any theming defaults
  // and then any user options to it.


  return $.extend({
    duration: '400ms'
  }, oj.AnimationUtils._defaultOptions ? oj.AnimationUtils._defaultOptions[effect] : null, options);
};

oj.AnimationUtils._createTransitionValue = function (element, transProps, options) {
  var transValue = '';

  if (transProps) {
    for (var i = 0; i < transProps.length; i++) {
      var propName = oj.AnimationUtils._getName(element, transProps[i]);

      var hyphenatedName = oj.AnimationUtils._getHyphenatedPropName(propName);

      transValue += (i > 0 ? ', ' : '') + hyphenatedName + ' ' + options.duration;

      if (options.timingFunction) {
        transValue += ' ' + options.timingFunction;
      }

      if (options.delay) {
        transValue += ' ' + options.delay;
      }
    }
  }

  return transValue;
};

oj.AnimationUtils._fade = function (element, _options, effect, startOpacity, endOpacity) {
  var options = oj.AnimationUtils._mergeOptions(effect, _options);

  var fromState = {
    css: {
      opacity: startOpacity
    }
  };
  var toState = {
    css: {
      opacity: endOpacity
    }
  };

  if (options) {
    if (options.startOpacity) {
      fromState.css.opacity = options.startOpacity;
    }

    if (options.endOpacity) {
      toState.css.opacity = options.endOpacity;
    }
  }

  return oj.AnimationUtils._animate(element, fromState, toState, options, ['opacity']);
};
/**
 * Animaton effect method for fading in a HTML element.
 *
 * @param {Element} element  the HTML element to animate
 * @param {Object=} options Options applicable to the specific animation effect.
 * @param {string=} options.delay  The delay from the time the animation is applied to time the
 * animation should begin. This may be specified in either seconds (by specifying s as the unit) or milliseconds
 * (by specifying ms as the unit). Default is "0s".
 * @param {string=} options.duration The duration that an animation should take to complete. This may be
 * specified in either seconds (by specifying s as the unit) or milliseconds (by specifying ms as the unit).
 * Default is "400ms".
 * @param {string=} options.timingFunction  One of the valid values for either CSS transition-timing-function or CSS
 * animation-timing-function. Default is "ease".
 * @param {string=} options.persist  Valid values are "none" and "all".  Set to "none" to remove the inline style being animated at the end of animation.
 *                                    Set to "all" to persist the inline style.  Default is "none".
 * @param {number=} options.startOpacity starting opacity. Default is 0.
 * @param {number=} options.endOpacity  ending opacity. Default is 1.
 * @return {Promise.<boolean>} a promise that will be resolved when the animation ends
 *
 * @export
 * @memberof oj.AnimationUtils
 */


oj.AnimationUtils.fadeIn = function (element, options) {
  return oj.AnimationUtils._fade(element, options, 'fadeIn', 0, 1);
};
/**
 * Animaton effect method for fading out a HTML element.
 *
 * @param {Element} element  the HTML element to animate
 * @param {Object=} options Options applicable to the specific animation effect.
 * @param {string=} options.delay  The delay from the time the animation is applied to time the
 * animation should begin. This may be specified in either seconds (by specifying s as the unit) or milliseconds
 * (by specifying ms as the unit). Default is "0s".
 * @param {string=} options.duration The duration that an animation should take to complete. This may be
 * specified in either seconds (by specifying s as the unit) or milliseconds (by specifying ms as the unit).
 * Default is "400ms".
 * @param {string=} options.timingFunction  One of the valid values for either CSS transition-timing-function or CSS
 * animation-timing-function. Default is "ease".
 * @param {string=} options.persist  Valid values are "none" and "all".  Set to "none" to remove the inline style being animated at the end of animation.
 *                                    Set to "all" to persist the inline style.  Default is "none".
 * @param {number=} options.startOpacity starting opacity. Default is 1.
 * @param {number=} options.endOpacity  ending opacity. Default is 0.
 * @return {Promise.<boolean>} a promise that will be resolved when the animation ends
 *
 * @export
 * @memberof oj.AnimationUtils
 */


oj.AnimationUtils.fadeOut = function (element, options) {
  return oj.AnimationUtils._fade(element, options, 'fadeOut', 1, 0);
};
/**
 * Animaton effect method for expanding a HTML element.
 *
 * @param {Element} element  the HTML element to animate
 * @param {Object=} options Options applicable to the specific animation effect.
 * @param {string=} options.delay  The delay from the time the animation is applied to time the
 * animation should begin. This may be specified in either seconds (by specifying s as the unit) or milliseconds
 * (by specifying ms as the unit). Default is "0s".
 * @param {string=} options.duration The duration that an animation should take to complete. This may be
 * specified in either seconds (by specifying s as the unit) or milliseconds (by specifying ms as the unit).
 * Default is "400ms".
 * @param {string=} options.timingFunction  One of the valid values for either CSS transition-timing-function or CSS
 * animation-timing-function. Default is "ease".
 * @param {string=} options.persist  Valid values are "none" and "all".  Set to "none" to remove the inline style being animated at the end of animation.
 *                                    Set to "all" to persist the inline style.  Default is "none".
 * @param {string=} options.direction direction to expand. Valid values are "height", "width", or "both". Default is "height".
 * @param {string=} options.startMaxHeight starting max-height value to expand from.  Default is "0".
 * @param {string=} options.endMaxHeight ending max-height value to expand to.  Default is natural element height.
 * @param {string=} options.startMaxWidth starting max-width value to expand from.  Default is "0".
 * @param {string=} options.endMaxWidth starting max-width value to expand to.  Default is natural element width.
 * @return {Promise.<boolean>} a promise that will be resolved when the animation ends
 *
 * @export
 * @memberof oj.AnimationUtils
 */


oj.AnimationUtils.expand = function (element, options) {
  return oj.AnimationUtils._expandCollapse(element, options, true);
};
/**
 * Animaton effect method for collapsing a HTML element.
 * <p>When using this method to hide an element, the element should not have any border
 * or padding, because border and padding are visible even if the element's height
 * is set to 0. The use of "box-sizing: border-box" style doesn't change this behavior.
 * If the element needs border and padding, create a wrapper element around it and
 * call this method on the wrapper element instead.</p>
 *
 * @param {Element} element  the HTML element to animate
 * @param {Object=} options Options applicable to the specific animation effect.
 * @param {string=} options.delay  The delay from the time the animation is applied to time the
 * animation should begin. This may be specified in either seconds (by specifying s as the unit) or milliseconds
 * (by specifying ms as the unit). Default is "0s".
 * @param {string=} options.duration The duration that an animation should take to complete. This may be
 * specified in either seconds (by specifying s as the unit) or milliseconds (by specifying ms as the unit).
 * Default is "400ms".
 * @param {string=} options.timingFunction  One of the valid values for either CSS transition-timing-function or CSS
 * animation-timing-function. Default is "ease".
 * @param {string=} options.persist  Valid values are "none" and "all".  Set to "none" to remove the inline style being animated at the end of animation.
 *                                    Set to "all" to persist the inline style.  Default is "none".
 * @param {string=} options.direction direction to collapse. Valid values are "height", "width", or "both". Default is "height".
 * @param {string=} options.startMaxHeight starting max-height value to collapse from.  Default is natural element height.
 * @param {string=} options.endMaxHeight ending max-height value to collapse to.  Default is "0".
 * @param {string=} options.startMaxWidth starting max-width value to collapse from.  Default is natural element width.
 * @param {string=} options.endMaxWidth starting max-width value to collapse to.  Default is "0".
 * @return {Promise.<boolean>} a promise that will be resolved when the animation ends
 *
 * @export
 * @memberof oj.AnimationUtils
 */


oj.AnimationUtils.collapse = function (element, options) {
  return oj.AnimationUtils._expandCollapse(element, options, false);
}; // Wrap table row content and return an array of wrapper elements to animate


oj.AnimationUtils._wrapRowContent = function (row, rowHeight) {
  var wrappers = [];
  var cell;
  var cells = row.children;
  var cellsPadding = [];
  var cellsTextAlign = [];
  var i; // Collect all the needed style before modifying the DOM.  Otherwise it
  // causes additional reflow and takes more time.
  // eslint-disable-next-line no-param-reassign

  row._ojSavedHeight = row.style.height;

  for (i = 0; i < cells.length; i++) {
    cell = cells[i];
    var cellStyle = window.getComputedStyle(cell);
    cellsPadding.push(cellStyle.padding);
    cellsTextAlign.push(cellStyle.textAlign); // Remember the inline padding style (not computed style)

    cell._ojSavedPadding = cell.style.padding;
  } // Start modifying the DOM


  for (i = 0; i < cells.length; i++) {
    cell = cells[i]; // Create the outer wrapper

    var outerWrapper = document.createElement('div');
    outerWrapper.style.overflow = 'hidden;'; // Create the inner wrapper

    var innerWrapper = document.createElement('div');
    innerWrapper.style.display = 'table-cell';
    innerWrapper.style.verticalAlign = 'middle';
    innerWrapper.style.boxSizing = 'border-box';
    innerWrapper.style.height = rowHeight;
    innerWrapper.style.padding = cellsPadding[i];
    innerWrapper.style.textAlign = cellsTextAlign[i]; // Append inner wrapper to outer wrapper

    outerWrapper.appendChild(innerWrapper); // @HTMLUpdateOK innerWrapper is constructed by component code and is not using string passed in through any APIs.
    // Transfer children of cell to inner wrapper

    while (cell.firstChild) {
      innerWrapper.appendChild(cell.firstChild); // @HTMLUpdateOK cell.firstChild is constructed by component code and is not using string passed in through any APIs.
    } // Finally append the outer wrapper back to the cell


    cell.appendChild(outerWrapper); // @HTMLUpdateOK outerWrapper is constructed by component code and is not using string passed in through any APIs.
    // Set the cell padding to 0 so that it can be completely collapsed

    cell.style.padding = '0';
    wrappers.push(outerWrapper);
  } // Set the row height to 0 so that it can be completely collapsed
  // eslint-disable-next-line no-param-reassign


  row.style.height = '0';
  return wrappers;
}; // Unwrap table row content


oj.AnimationUtils._unwrapRowContent = function (row) {
  var cells = row.children;

  for (var i = 0; i < cells.length; i++) {
    var cell = cells[i];
    var outerWrapper = cell.children[0];

    if (outerWrapper) {
      var innerWrapper = outerWrapper.children[0];

      if (innerWrapper) {
        while (innerWrapper.firstChild) {
          cell.appendChild(innerWrapper.firstChild); // @HTMLUpdateOK innerWrapper.firstChild is constructed by component code and is not using string passed in through any APIs.
        }
      } // Remove the outer wrapper will also remove the inner wrapper


      cell.removeChild(outerWrapper);
    } // Restore any inline padding style to the cell


    cell.style.padding = cell._ojSavedPadding;
    delete cell._ojSavedPadding;
  } // Restore any inline height style to the row
  // eslint-disable-next-line no-param-reassign


  row.style.height = row._ojSavedHeight; // eslint-disable-next-line no-param-reassign

  delete row._ojSavedHeight;
}; // Expand or collapse a table row


oj.AnimationUtils._expandCollapseRow = function (element, options, isExpand) {
  var promise;
  var rowHeight = element.offsetHeight + 'px';

  var wrappers = oj.AnimationUtils._wrapRowContent(element, rowHeight);

  var wrapperOptions = $.extend({}, options); // Set the known max height into the options so that each cell doesn't
  // have to recalculate it

  if (isExpand) {
    if (!wrapperOptions.endMaxHeight) {
      wrapperOptions.endMaxHeight = rowHeight;
    }
  } else if (!wrapperOptions.startMaxHeight) {
    wrapperOptions.startMaxHeight = rowHeight;
  } // Set persist option so that we don't need to restore the style after
  // animation.  The wrapper will be removed anyway.


  wrapperOptions.persist = 'all'; // Set internal _noReflow option so that we don't force reflow on Firefox.
  // New elements will naturally cause reflow.

  wrapperOptions._noReflow = true;

  if (wrappers.length) {
    // Animate all the cells
    for (var i = 0; i < wrappers.length; i++) {
      // We only need one promise/row.  Skip promise for all cells except first.
      if (i === 0) {
        wrapperOptions._skipPromise = false;
        promise = oj.AnimationUtils._expandCollapse(wrappers[i], wrapperOptions, isExpand);
      } else {
        wrapperOptions._skipPromise = true;

        oj.AnimationUtils._expandCollapse(wrappers[i], wrapperOptions, isExpand);
      }
    }
  } else {
    promise = Promise.resolve();
  }

  return promise.then(function () {
    if (options == null || options.persist !== 'all') {
      oj.AnimationUtils._unwrapRowContent(element);
    }
  });
}; // Determine the min/max width/height used for animation


oj.AnimationUtils._getSizeLimit = function (element, style, optionValue, isLower, isWidth) {
  var limitValue = optionValue;

  if (!limitValue) {
    if (isLower) {
      limitValue = '0';
    } else {
      var cssValue = isWidth ? style.maxWidth : style.maxHeight;

      if (cssValue !== 'none') {
        limitValue = cssValue;
      } else {
        limitValue = (isWidth ? element.offsetWidth : element.offsetHeight) + 'px';
      }
    }
  }

  return limitValue;
};

oj.AnimationUtils._expandCollapse = function (element, _options, isExpand) {
  // Handle the case where the element is a <tr> element.  We need to wrap the
  // content of every child <td> and animate the wrappers because the min height
  // of <tr> and <td> are limited by their contents.
  if (element && element.tagName === 'TR') {
    return oj.AnimationUtils._expandCollapseRow(element, _options, isExpand);
  }

  var options = oj.AnimationUtils._mergeOptions(isExpand ? 'expand' : 'collapse', _options);

  var fromState = {
    css: {}
  };
  var toState = {
    css: {}
  };
  var direction = options.direction || 'height';
  var fromCSS = fromState.css;
  var toStateCSS = toState.css;
  var style = window.getComputedStyle(element);
  var transProps = [];

  if (direction === 'both' || direction === 'height') {
    var startMaxHeight = oj.AnimationUtils._getSizeLimit(element, style, options.startMaxHeight, isExpand, false);

    var endMaxHeight = oj.AnimationUtils._getSizeLimit(element, style, options.endMaxHeight, !isExpand, false);

    fromCSS.maxHeight = startMaxHeight;
    toStateCSS.maxHeight = endMaxHeight;
    transProps.push('maxHeight');
  }

  if (direction === 'both' || direction === 'width') {
    var startMaxWidth = oj.AnimationUtils._getSizeLimit(element, style, options.startMaxWidth, isExpand, true);

    var endMaxWidth = oj.AnimationUtils._getSizeLimit(element, style, options.endMaxWidth, !isExpand, true);

    fromCSS.maxWidth = startMaxWidth;
    toStateCSS.maxWidth = endMaxWidth;
    transProps.push('maxWidth');
  } // expand and collapse needs overflow hidden to hide the content


  fromCSS.overflow = options.overflow ? options.overflow : 'hidden';
  var persistProps = [].concat(transProps);
  persistProps.push('overflow');
  return oj.AnimationUtils._animate(element, fromState, toState, options, transProps, persistProps);
};
/**
 * Animaton effect method for zooming in a HTML element.
 *
 * @param {Element} element  the HTML element to animate
 * @param {Object=} options Options applicable to the specific animation effect.
 * @param {string=} options.delay  The delay from the time the animation is applied to time the
 * animation should begin. This may be specified in either seconds (by specifying s as the unit) or milliseconds
 * (by specifying ms as the unit). Default is "0s".
 * @param {string=} options.duration The duration that an animation should take to complete. This may be
 * specified in either seconds (by specifying s as the unit) or milliseconds (by specifying ms as the unit).
 * Default is "400ms".
 * @param {string=} options.timingFunction  One of the valid values for either CSS transition-timing-function or CSS
 * animation-timing-function. Default is "ease".
 * @param {string=} options.persist  Valid values are "none" and "all".  Set to "none" to remove the inline style being animated at the end of animation.
 *                                    Set to "all" to persist the inline style.  Default is "none".
 * @param {string=} options.axis the axis along which to scale the element. Valid values are "x", "y", or "both". Default is "both".
 * @param {string=} options.transformOrigin set the CSS transform-origin property, which controls the anchor point for the zoom. Default is "center".
 * @return {Promise.<boolean>} a promise that will be resolved when the animation ends
 *
 * @export
 * @memberof oj.AnimationUtils
 */


oj.AnimationUtils.zoomIn = function (element, options) {
  return oj.AnimationUtils._zoom(element, options, true);
};
/**
 * Animaton effect method for zooming out a HTML element.
 *
 * @param {Element} element  the HTML element to animate
 * @param {Object=} options Options applicable to the specific animation effect.
 * @param {string=} options.delay  The delay from the time the animation is applied to time the
 * animation should begin. This may be specified in either seconds (by specifying s as the unit) or milliseconds
 * (by specifying ms as the unit). Default is "0s".
 * @param {string=} options.duration The duration that an animation should take to complete. This may be
 * specified in either seconds (by specifying s as the unit) or milliseconds (by specifying ms as the unit).
 * Default is "400ms".
 * @param {string=} options.timingFunction  One of the valid values for either CSS transition-timing-function or CSS
 * animation-timing-function. Default is "ease".
 * @param {string=} options.persist  Valid values are "none" and "all".  Set to "none" to remove the inline style being animated at the end of animation.
 *                                    Set to "all" to persist the inline style.  Default is "none".
 * @param {string=} options.axis the axis along which to scale the element. Valid values are "x", "y", or "both". Default is "both".
 * @param {string=} options.transformOrigin set the CSS transform-origin property, which controls the anchor point for the zoom. Default is "center".
 * @return {Promise.<boolean>} a promise that will be resolved when the animation ends
 *
 * @export
 * @memberof oj.AnimationUtils
 */


oj.AnimationUtils.zoomOut = function (element, options) {
  return oj.AnimationUtils._zoom(element, options, false);
};

oj.AnimationUtils._zoom = function (element, _options, isIn) {
  var options = oj.AnimationUtils._mergeOptions(isIn ? 'zoomIn' : 'zoomOut', _options);

  var fromState = {
    css: {}
  };
  var toState = {
    css: {}
  };
  var axis = options.axis || 'both';
  var scale;

  if (axis === 'both') {
    scale = 'scale';
  } else if (axis === 'x') {
    scale = 'scaleX';
  } else {
    scale = 'scaleY';
  }

  var fromCSS = fromState.css;
  var toStateCSS = toState.css;
  var transformPropName = 'transform';
  var transformOriginPropName = 'transformOrigin';
  fromCSS[transformPropName] = scale + '(' + (isIn ? 0 : 1) + ') translateZ(0)';
  toStateCSS[transformPropName] = scale + '(' + (isIn ? 1 : 0) + ') translateZ(0)';
  fromCSS[transformOriginPropName] = options.transformOrigin || 'center';
  return oj.AnimationUtils._animate(element, fromState, toState, options, [transformPropName]);
};
/**
 * Animaton effect method for sliding in a HTML element.
 *
 * @param {Element} element  the HTML element to animate
 * @param {Object=} options Options applicable to the specific animation effect.
 * @param {string=} options.delay  The delay from the time the animation is applied to time the
 * animation should begin. This may be specified in either seconds (by specifying s as the unit) or milliseconds
 * (by specifying ms as the unit). Default is "0s".
 * @param {string=} options.duration The duration that an animation should take to complete. This may be
 * specified in either seconds (by specifying s as the unit) or milliseconds (by specifying ms as the unit).
 * Default is "400ms".
 * @param {string=} options.timingFunction  One of the valid values for either CSS transition-timing-function or CSS
 * animation-timing-function. Default is "ease".
 * @param {string=} options.persist  Valid values are "none" and "all".  Set to "none" to remove the inline style being animated at the end of animation.
 *                                    Set to "all" to persist the inline style.  Default is "none".
 * @param {string=} options.direction Direction of the slide. Valid values are "left", "top", "right", "bottom", "start", and "end". Default is "start".
 *                                    This option is ignored if either offsetX or offsetY is specified.
 * @param {string=} options.offsetX The offset on the x-axis to translate from. This value must be a number followed by a unit such as "px", "em", etc.
 *                                  If moving in a horizontal direction, default to element width. Otherwise, default to "0px".
 * @param {string=} options.offsetY The offset on the y-axis to translate from. This value must be a number followed by a unit such as "px", "em", etc.
 *                                  If moving in a vertical direction, default to element height. Otherwise, default to "0px".
 * @return {Promise.<boolean>} a promise that will be resolved when the animation ends
 *
 * @export
 * @memberof oj.AnimationUtils
 */


oj.AnimationUtils.slideIn = function (element, options) {
  return oj.AnimationUtils._slide(element, options, true);
};
/**
 * Animaton effect method for sliding out a HTML element.
 *
 * @param {Element} element  the HTML element to animate
 * @param {Object=} options Options applicable to the specific animation effect.
 * @param {string=} options.delay  The delay from the time the animation is applied to time the
 * animation should begin. This may be specified in either seconds (by specifying s as the unit) or milliseconds
 * (by specifying ms as the unit). Default is "0s".
 * @param {string=} options.duration The duration that an animation should take to complete. This may be
 * specified in either seconds (by specifying s as the unit) or milliseconds (by specifying ms as the unit).
 * Default is "400ms".
 * @param {string=} options.timingFunction  One of the valid values for either CSS transition-timing-function or CSS
 * animation-timing-function. Default is "ease".
 * @param {string=} options.persist  Valid values are "none" and "all".  Set to "none" to remove the inline style being animated at the end of animation.
 *                                    Set to "all" to persist the inline style.  Default is "none".
 * @param {string=} options.direction Direction of the slide. Valid values are "left", "top", "right", "bottom", "start", and "end". Default is "start".
 *                                    This option is ignored if either offsetX or offsetY is specified.
 * @param {string=} options.offsetX The offset on the x-axis to translate to. This value must be a number followed by a unit such as "px", "em", etc.
 *                                  If moving in a horizontal direction, default to element width. Otherwise, default to "0px".
 * @param {string=} options.offsetY The offset on the y-axis to translate to. This value must be a number followed by a unit such as "px", "em", etc.
 *                                  If moving in a vertical direction, default to element height. Otherwise, default to "0px".
 * @return {Promise.<boolean>} a promise that will be resolved when the animation ends
 *
 * @export
 * @memberof oj.AnimationUtils
 */


oj.AnimationUtils.slideOut = function (element, options) {
  return oj.AnimationUtils._slide(element, options, false);
};

oj.AnimationUtils._slide = function (element, _options, isIn) {
  var options = oj.AnimationUtils._mergeOptions(isIn ? 'slideIn' : 'slideOut', _options);

  var fromState = {
    css: {}
  };
  var toState = {
    css: {}
  };
  var direction = options.direction || 'start';
  var offsetX = '0';
  var offsetY = '0';
  var fromCSS = fromState.css;
  var toStateCSS = toState.css;

  if (options.offsetX || options.offsetY) {
    if (options.offsetX) {
      offsetX = options.offsetX;
    }

    if (options.offsetY) {
      offsetY = options.offsetY;
    }
  } else {
    var isRTL = oj.DomUtils.getReadingDirection() === 'rtl';

    switch (direction) {
      case 'left':
        offsetX = (isIn ? element.offsetWidth : -element.offsetWidth) + 'px';
        break;

      case 'right':
        offsetX = (isIn ? -element.offsetWidth : element.offsetWidth) + 'px';
        break;

      case 'top':
        offsetY = (isIn ? element.offsetHeight : -element.offsetHeight) + 'px';
        break;

      case 'bottom':
        offsetY = (isIn ? -element.offsetHeight : element.offsetHeight) + 'px';
        break;

      case 'end':
        offsetX = (isIn ? -element.offsetWidth : element.offsetWidth) * (isRTL ? -1 : 1) + 'px';
        break;

      default:
        // 'start'
        offsetX = (isIn ? element.offsetWidth : -element.offsetWidth) * (isRTL ? -1 : 1) + 'px';
        break;
    }
  }

  var transformPropName = 'transform';

  if (isIn) {
    fromCSS[transformPropName] = 'translate(' + offsetX + ',' + offsetY + ') translateZ(0)';
    toStateCSS[transformPropName] = 'translate(0,0) translateZ(0)';
  } else {
    fromCSS[transformPropName] = 'translate(0,0) translateZ(0)';
    toStateCSS[transformPropName] = 'translate(' + offsetX + ',' + offsetY + ') translateZ(0)';
  }

  return oj.AnimationUtils._animate(element, fromState, toState, options, [transformPropName]);
};
/**
 * Animaton effect method for rippling a HTML element.
 *
 * @param {Element} element  the HTML element to animate
 * @param {Object=} options Options applicable to the specific animation effect.
 * @param {string=} options.delay  The delay from the time the animation is applied to time the
 * animation should begin. This may be specified in either seconds (by specifying s as the unit) or milliseconds
 * (by specifying ms as the unit). Default is "0s".
 * @param {string=} options.duration The duration that an animation should take to complete. This may be
 * specified in either seconds (by specifying s as the unit) or milliseconds (by specifying ms as the unit).
 * Default is "400ms".
 * @param {string=} options.timingFunction  One of the valid values for either CSS transition-timing-function or CSS
 * animation-timing-function. Default is "ease".
 * @param {string=} options.offsetX Horizontal offset of the ripple center, with a unit of either "px" or "%".
 *                                  If the unit is "px", it specifies the offset in pixels.
 *                                  If the unit is "%", it specifies the offset as a percentage of the element's width.
 * @param {string=} options.offsetY Vertical offset of the ripple center, with a unit of either "px" or "%".
 *                                  If the unit is "px", it specifies the offset in pixels.
 *                                  If the unit is "%", it specifies the offset as a percentage of the element's height.
 * @param {string=} options.color Color of the ripple. Default is specified in the "oj-animation-effect-ripple" CSS class.
 * @param {string=} options.diameter Diameter of the ripple, with a unit of either "px" or "%".
 *                                   If the unit is "px", it specifies the diameter in pixels.
 *                                   If the unit is "%", it specifies the diameter as a percentage of either the element's width or height, whichever is less.
 *                                   Default is specified in the "oj-animation-effect-ripple" CSS class.
 * @param {number=} options.startOpacity start opacity of the ripple. Default is specified in the "oj-animation-effect-ripple" CSS class.
 * @param {number=} options.endOpacity end opacity of the ripple. Default is 0.
 * @return {Promise.<boolean>} a promise that will be resolved when the animation ends
 *
 * @export
 * @memberof oj.AnimationUtils
 */


oj.AnimationUtils.ripple = function (element, options) {
  var _options = oj.AnimationUtils._mergeOptions('ripple', options);

  var fromState = {
    css: {}
  };
  var toState = {
    css: {}
  };
  var width = element.offsetWidth;
  var height = element.offsetHeight; // The rippler need its own container since setting overflow on the target
  // element may not work if the element has no explicit height, which can be
  // the case on buton, listitem, etc.

  var container = $('<div>').css({
    position: 'absolute',
    overflow: 'hidden'
  });
  var rippler = $("<div class='oj-animation-effect-ripple oj-animation-rippler'>"); // prepend the rippler instead of append so that it doesn't obscure other children

  var style = window.getComputedStyle(element);
  var position = style.position === 'static' ? {
    left: element.offsetLeft,
    top: element.offsetTop
  } : {
    left: 0,
    top: 0
  };
  element.insertBefore(container[0], element.firstChild); // @HTMLUpdateOK container is constructed by component code and is not using string passed in through any APIs.

  container.css({
    left: position.left + 'px',
    top: position.top + 'px',
    width: width + 'px',
    height: height + 'px'
  });
  container.prepend(rippler); // @HTMLUpdateOK rippler is constructed by component code and is not using string passed in through any APIs.

  var fromCSS = fromState.css;
  var toStateCSS = toState.css;
  var transformPropName = 'transform';

  oj.AnimationUtils._setRippleOptions(fromCSS, rippler, container, _options);

  fromCSS[transformPropName] = 'scale(0) translateZ(0)';
  fromCSS.opacity = _options.startOpacity || rippler.css('opacity');
  toStateCSS[transformPropName] = 'scale(1) translateZ(0)';
  toStateCSS.opacity = _options.endOpacity || 0; // Always persist the ripple state so that it remains invisible until removed.
  // Otherwise it may re-appear briefly on mobile Safari.

  _options.persist = 'all';
  return oj.AnimationUtils._animate(rippler[0], fromState, toState, _options, [transformPropName, 'opacity']).then(function () {
    container.remove();
  });
};

oj.AnimationUtils._setRippleOptions = function (_css, rippler, parent, options) {
  var css = _css;
  var diameter = rippler.width();
  var parentWidth = parent.width();
  var parentHeight = parent.height();

  if (options.diameter) {
    var diameterStr = options.diameter;
    var value = parseInt(diameterStr, 10);

    if (!isNaN(value)) {
      if (diameterStr.charAt(diameterStr.length - 1) === '%') {
        diameter = Math.floor(Math.min(parentWidth, parentHeight) * (value / 100));
      } else {
        diameter = value;
      }

      css.width = diameter + 'px';
      css.height = diameter + 'px';
    }
  }

  var position = parent.css('position') === 'static' ? parent.position() : {
    left: 0,
    top: 0
  };
  var offset;
  offset = oj.AnimationUtils._calcRippleOffset(options.offsetX, diameter, parentWidth, position.left);

  if (offset != null) {
    css.left = offset + 'px';
  }

  offset = oj.AnimationUtils._calcRippleOffset(options.offsetY, diameter, parentHeight, position.top);

  if (offset != null) {
    css.top = offset + 'px';
  }

  if (options.color) {
    css.backgroundColor = options.color;
  }
};

oj.AnimationUtils._calcRippleOffset = function (_offsetOption, diameter, parentSize, parentOffset) {
  var offset;
  var offsetOption = _offsetOption || '50%';
  var offsetInt = parseInt(offsetOption, 10);

  if (!isNaN(offsetInt)) {
    if (offsetOption.charAt(offsetOption.length - 1) === '%') {
      offset = parentSize * (offsetInt / 100) - diameter / 2;
    } else {
      offset = offsetInt - diameter / 2;
    } // offset should be relative to the rippler's offsetParent, which is not
    // the parent element if the parent element has static position.


    offset = Math.floor(offset + parentOffset);
  }

  return offset;
};

oj.AnimationUtils._removeRipple = function (element, _options) {
  var options = _options || {};
  var possibleEffects = {
    fadeOut: 1,
    collapse: 1,
    zoomOut: 1,
    slideOut: 1
  };
  var removeEffect = options.removeEffect || 'fadeOut';
  var rippler = $('.oj-animation-rippler', element);

  if (rippler.length === 0) {
    Logger.warn('No rippler so returning');
    return undefined;
  }

  if (!(removeEffect in possibleEffects)) {
    return rippler.remove();
  }

  return oj.AnimationUtils[removeEffect](rippler, options).then(function () {
    rippler.remove();
  });
};

oj.AnimationUtils._calcBackfaceAngle = function (angle) {
  var backfaceAngle;
  var expr = /^([+-]?\d*\.?\d*)(.*)$/;
  var matchArray = angle.match(expr);
  var amount = parseFloat(matchArray[1]);
  var unit = matchArray[2];

  switch (unit) {
    case 'deg':
      backfaceAngle = amount - 180 + unit;
      break;

    case 'grad':
      backfaceAngle = amount - 200 + unit;
      break;

    case 'rad':
      backfaceAngle = amount - 3.1416 + unit;
      break;

    case 'turn':
      backfaceAngle = amount - 0.5 + unit;
      break;

    default:
      Logger.error('Unknown angle unit in flip animation: ' + unit);
      break;
  }

  return backfaceAngle;
};

oj.AnimationUtils._flip = function (element, options, effect, startAngle, endAngle) {
  // Handle the case where the element has children to represent front and back
  // faces.  We need to flip the children instead of the parent since IE doesn't
  // support preserve-3d style, which works on other browsers.
  if (options && options.flipTarget === 'children') {
    var promises = [];
    var children = $(element).children();
    var childOptions;
    var frontOptions = $.extend({}, options);
    delete frontOptions.flipTarget;
    var backOptions = $.extend({}, frontOptions);
    backOptions.startAngle = oj.AnimationUtils._calcBackfaceAngle(options.startAngle || startAngle);
    backOptions.endAngle = oj.AnimationUtils._calcBackfaceAngle(options.endAngle || endAngle);

    for (var i = 0; i < children.length; i++) {
      childOptions = $(children[i]).hasClass('oj-animation-backface') ? backOptions : frontOptions;
      promises.push(oj.AnimationUtils._flip(children[i], childOptions, effect, startAngle, endAngle));
    }

    return Promise.all(promises);
  } // eslint-disable-next-line no-param-reassign


  options = oj.AnimationUtils._mergeOptions(effect, options);
  var fromCss = {};
  var toCss = {};
  var fromState = {
    css: fromCss
  };
  var toState = {
    css: toCss
  };
  var rotateFunc = 'rotateY(';
  var perspective = '2000px';
  var backfaceVisibility = 'hidden';
  var transformOrigin = 'center';
  var transform;

  if (options) {
    if (options.axis === 'x') {
      rotateFunc = 'rotateX(';
    }

    if (options.startAngle) {
      // eslint-disable-next-line no-param-reassign
      startAngle = options.startAngle;
    }

    if (options.endAngle) {
      // eslint-disable-next-line no-param-reassign
      endAngle = options.endAngle;
    }

    if (options.perspective) {
      perspective = options.perspective;
    }

    if (options.backfaceVisibility) {
      backfaceVisibility = options.backfaceVisibility;
    }

    if (options.transformOrigin) {
      transformOrigin = options.transformOrigin;
    }
  } // perspective() must precede rotate() in the transform value in order for it to work


  transform = 'perspective(' + perspective + ') ' + rotateFunc; // Safari still requires webkit prefix for backfaceVisibility property

  var backfaceVisPropName = 'backfaceVisibility';
  var transformPropName = 'transform';
  var transformOriginPropName = 'transformOrigin';
  fromCss[transformPropName] = transform + startAngle + ')';
  fromCss[backfaceVisPropName] = backfaceVisibility;
  fromCss[transformOriginPropName] = transformOrigin;
  toCss[transformPropName] = transform + endAngle + ')'; // backfaceVisibility and transformOrigin affects the final look of the element,
  // so they should be persisted if the persist option is set.

  return oj.AnimationUtils._animate(element, fromState, toState, options, [transformPropName], [transformPropName, backfaceVisPropName, transformOriginPropName]);
};
/**
 * Animaton effect method for rotating a HTML element into view.
 *
 * @param {Element} element  the HTML element to animate
 * @param {Object=} options Options applicable to the specific animation effect.
 * @param {string=} options.delay  The delay from the time the animation is applied to time the
 * animation should begin. This may be specified in either seconds (by specifying s as the unit) or milliseconds
 * (by specifying ms as the unit). Default is "0s".
 * @param {string=} options.duration The duration that an animation should take to complete. This may be
 * specified in either seconds (by specifying s as the unit) or milliseconds (by specifying ms as the unit).
 * Default is "400ms".
 * @param {string=} options.timingFunction  One of the valid values for either CSS transition-timing-function or CSS
 * animation-timing-function. Default is "ease".
 * @param {string=} options.persist  Valid values are "none" and "all".  Set to "none" to remove the inline style being animated at the end of animation.
 *                                    Set to "all" to persist the inline style.  Default is "none".
 * @param {string=} options.axis  The axis of the rotation. Valid values are "x" and "y". Default is "y".
 * @param {string=} options.startAngle  The starting angle of the rotation. Refer to CSS rotate() transform for valid values. Default is "-180deg", which shows the back face of the element.
 * @param {string=} options.endAngle  The ending angle of the rotation. Refer to CSS rotate() transform for valid values. Default is "0deg", which shows the front face of the element.
 * @param {string=} options.backfaceVisibility  The visibility of the back face when facing the user. Valid values are "visible" and "hidden". If set to "visible", the back face shows a
 *                                              mirrored image of the front face. If set to "hidden", the back face is invisible.  Default is "hidden".
 * @param {string=} options.perspective  The 3D perspective for the element. Default is "2000px". A smaller value makes the 3D effect more pronounced during rotation.
 * @param {string=} options.transformOrigin  The axis location for the rotation. Refer to CSS transform-origin for valid values. Default is "center".
 * @param {string=} options.flipTarget  The target for flipping.  Valid values are "element" and "children".  Default is "element".
 *                                      <p>Set to "element" to flip the element itself.</p>
 *                                      <p>Set to "children" to flip the children of the element.  This is used when the element is a card-like structure that
 *                                         has children to represent the front and back faces of a card.  The child that represents the back face must have
 *                                         the "oj-animation-backface" marker class.  Use this option instead of the "transform-style: preserve-3d" CSS style because
 *                                         some browsers do not support "transform-style".  See the cookbook for a Card Flip example of using this option.</p>
 * @return {Promise.<boolean>} a promise that will be resolved when the animation ends
 *
 * @export
 * @memberof oj.AnimationUtils
 */


oj.AnimationUtils.flipIn = function (element, options) {
  return oj.AnimationUtils._flip(element, options, 'flipIn', '-180deg', '0deg');
};
/**
 * Animaton effect method for rotating a HTML element out of view.
 *
 * @param {Element} element  the HTML element to animate
 * @param {Object=} options Options applicable to the specific animation effect.
 * @param {string=} options.delay  The delay from the time the animation is applied to time the
 * animation should begin. This may be specified in either seconds (by specifying s as the unit) or milliseconds
 * (by specifying ms as the unit). Default is "0s".
 * @param {string=} options.duration The duration that an animation should take to complete. This may be
 * specified in either seconds (by specifying s as the unit) or milliseconds (by specifying ms as the unit).
 * Default is "400ms".
 * @param {string=} options.timingFunction  One of the valid values for either CSS transition-timing-function or CSS
 * animation-timing-function. Default is "ease".
 * @param {string=} options.persist  Valid values are "none" and "all".  Set to "none" to remove the inline style being animated at the end of animation.
 *                                    Set to "all" to persist the inline style.  Default is "none".
 * @param {string=} options.axis  The axis of the rotation. Valid values are "x" and "y". Default is "y".
 * @param {string=} options.startAngle  The starting angle of the rotation. Refer to CSS rotate() transform for valid values. Default is "0deg", which shows the front face of the element.
 * @param {string=} options.endAngle  The ending angle of the rotation. Refer to CSS rotate() transform for valid values. Default is "180deg", which shows the back face of the element.
 * @param {string=} options.backfaceVisibility  The visibility of the back face when facing the user. Valid values are "visible" and "hidden". If set to "visible", the back face shows a
 *                                              mirrored image of the front face. If set to "hidden", the back face is invisible.  Default is "hidden".
 * @param {string=} options.perspective  The 3D perspective for the element. Default is "2000px". A smaller value makes the 3D effect more pronounced during rotation.
 * @param {string=} options.transformOrigin  The axis location for the rotation. Refer to CSS transform-origin for valid values. Default is "center".
 * @param {string=} options.flipTarget  The target for flipping.  Valid values are "element" and "children".  Default is "element".
 *                                      <p>Set to "element" to flip the element itself.</p>
 *                                      <p>Set to "children" to flip the children of the element.  This is used when the element is a card-like structure that
 *                                         has children to represent the front and back faces of a card.  The child that represents the back face must have
 *                                         the "oj-animation-backface" marker class.  Use this option instead of the "transform-style: preserve-3d" CSS style because
 *                                         some browsers do not support "transform-style".  See the cookbook for a Card Flip example of using this option.</p>
 * @return {Promise.<boolean>} a promise that will be resolved when the animation ends
 *
 * @export
 * @memberof oj.AnimationUtils
 */


oj.AnimationUtils.flipOut = function (element, options) {
  return oj.AnimationUtils._flip(element, options, 'flipOut', '0deg', '180deg');
};
/**
 * Animaton effect method for adding transition to a HTML element.  Caller should
 * set the new style immediately before calling this method.  This is for internal
 * use only.
 *
 * @param {Element} element  the HTML element to animate
 * @param {Object} options Options applicable to the specific animation effect.
 * @param {string=} options.delay  The delay from the time the animation is applied to time the
 * animation should begin. This may be specified in either seconds (by specifying s as the unit) or milliseconds
 * (by specifying ms as the unit). Default is "0s".
 * @param {string=} options.duration The duration that an animation should take to complete. This may be
 * specified in either seconds (by specifying s as the unit) or milliseconds (by specifying ms as the unit).
 * Default is "400ms".
 * @param {string=} options.timingFunction  One of the valid values for either CSS transition-timing-function or CSS
 * animation-timing-function. Default is "ease".
 * @param {Array} options.transitionProperties  An array of properties to transition.
 * @return {Promise|IThenable} a promise that will be resolved when the animation ends
 *
 * @export
 * @ignore
 */


oj.AnimationUtils.addTransition = function (element, options) {
  var _options = oj.AnimationUtils._mergeOptions('addTransition', options);

  return oj.AnimationUtils._animate(element, null, null, _options, _options.transitionProperties);
};

oj.AnimationUtils._createHeroParent = function () {
  var viewport = document.createElement('div');
  var body = document.body;
  body.appendChild(viewport); // @HTMLUpdateOK viewPort constructed above

  viewport.style.position = 'absolute';
  viewport.style.height = body.offsetHeight + 'px';
  viewport.style.width = body.offsetWidth + 'px';
  viewport.style.left = body.offsetLeft + 'px';
  viewport.style.top = body.offsetTop + 'px';
  viewport.style.zIndex = 2000;
  viewport.className = 'oj-animation-host-viewport';
  var host = document.createElement('div');
  host.className = 'oj-animation-host';
  viewport.appendChild(host); // @HTMLUpdateOK host is constructed above

  return host;
};

oj.AnimationUtils._removeHeroParent = function (heroParent) {
  if (heroParent) {
    var viewport = heroParent.parentNode;

    if (viewport && viewport.parentNode) {
      viewport.parentNode.removeChild(viewport);
    }
  }
};

oj.AnimationUtils._defaultHeroCreateClonedElement = function (context) {
  return context.fromElement.cloneNode(true);
};

oj.AnimationUtils._defaultHeroHideFromAndToElements = function (context) {
  var fromElement = context.fromElement;
  var toElement = context.toElement;
  fromElement.style.visibility = 'hidden';
  toElement.style.visibility = 'hidden';
};

oj.AnimationUtils._defaultHeroAnimateClonedElement = function (context) {
  return new Promise(function (resolve) {
    var heroStyle = context.clonedElement.style;
    heroStyle.transformOrigin = 'left top';
    heroStyle.transform = 'translate(0, 0) scale(1, 1)';
    requestAnimationFrame(function () {
      heroStyle.transitionDelay = context.delay;
      heroStyle.transitionDuration = context.duration;
      heroStyle.transitionTimingFunction = context.timingFunction;
      heroStyle.transitionProperty = 'transform'; // Put translate before scale because otherwise the scale factor will affect the translate value

      var transform = 'translate(' + context.translateX + 'px,' + context.translateY + 'px)';
      transform += ' scale(' + context.scaleX.toFixed(2) + ',' + context.scaleY.toFixed(2) + ')';
      heroStyle.transform = transform;

      var waitTime = oj.AnimationUtils._getTimingValue(context.delay) + oj.AnimationUtils._getTimingValue(context.duration);

      setTimeout(function () {
        resolve();
      }, waitTime);
    });
  });
};

oj.AnimationUtils._defaultHeroShowToElement = function (context) {
  var toElement = context.toElement;
  toElement.style.visibility = 'visible';
};

oj.AnimationUtils._doAnimateHero = function (fromElement, toElementSelector, resolvedOptions, toElementElapsedTime, resolve, reject) {
  var toElement = document.querySelector(toElementSelector); // Wait for toElement to appear to DOM if it is not there yet

  if (toElement == null) {
    var interval = 100;

    if (toElementElapsedTime + interval > resolvedOptions.toElementWaitTime) {
      reject('toElement not found in DOM after toElementWaitTime has expired');
    } else {
      setTimeout(function () {
        oj.AnimationUtils._doAnimateHero(fromElement, toElementSelector, resolvedOptions, toElementElapsedTime + interval, resolve, reject);
      }, interval);
    }

    return;
  }

  var fromRect = fromElement.getBoundingClientRect();
  var toRect = toElement.getBoundingClientRect();
  var translateX = toRect.left - fromRect.left;
  var translateY = toRect.top - fromRect.top;
  var scaleX = toRect.width / fromRect.width;
  var scaleY = toRect.height / fromRect.height;
  var heroContext = {
    fromElement: fromElement,
    toElement: toElement,
    clonedElement: null,
    translateX: translateX,
    translateY: translateY,
    scaleX: scaleX,
    scaleY: scaleY,
    toElementElapsedTime: toElementElapsedTime,
    delay: resolvedOptions.delay,
    duration: resolvedOptions.duration,
    timingFunction: resolvedOptions.timingFunction
  };
  var clonedElement = resolvedOptions.createClonedElement(heroContext);
  heroContext.clonedElement = clonedElement;

  var heroParent = oj.AnimationUtils._createHeroParent();

  var parentRect = heroParent.getBoundingClientRect();
  heroParent.appendChild(clonedElement);
  clonedElement.style.position = 'absolute';
  clonedElement.style.left = fromRect.left - parentRect.left + 'px';
  clonedElement.style.top = fromRect.top - parentRect.top + 'px';
  resolvedOptions.hideFromAndToElements(heroContext); // Make sure clonedElement is visible in case createClonedElement return fromElement or toElement

  clonedElement.style.visibility = 'visible';

  function _postAnimation() {
    resolvedOptions.showToElement(heroContext);

    oj.AnimationUtils._removeHeroParent(heroParent);
  }

  resolvedOptions.animateClonedElement(heroContext).then(function () {
    _postAnimation();

    resolve();
  }).catch(function (reason) {
    _postAnimation();

    reject(reason);
  });
};
/**
 * Animation effect method for animating a hero element from one location to another.
 * A hero element is an element that appears to be shared between a source location and a destination location,
 * even though there are separate source element and destination element.
 * <p>
 * The following steps are taken by this method:
 * </p>
 * <ol>
 *   <li>Create a temporary div that has a z-index higher than that of the source and destination elements.
 *   <li>Clone the source element.
 *   <li>Position the cloned element on the temporary div at the same position as the source element.
 *   <li>Hide the source and destination elements.
 *   <li>Animate the cloned element by translating and scaling its position and size towards the destination element.
 *   <li>Show the destination element.
 *   <li>Remove the temporary div together with the cloned element that is on it.
 * </ol>
 * This method provides callback parameters that can be used to override some of the steps.
 *
 * @param {Element} element The source element for the hero animation.
 * @param {Object} options Options applicable to the specific animation effect.
 * @param {string} options.toElementSelector  A CSS selector which specifies the destination element that occupies the location to animate to.
 * @param {number=} options.toElementWaitTime  The time in millisecond to wait for the destination element to become present in the DOM tree.
 * The default is 5000, which is equal to 5 seconds. No animation occurs and the promise returned by this function will be rejected if the
 * destination element is not present when toElementWaitTime expires.
 * @param {(function(AnimationUtils.HeroContext):Element)=} options.createClonedElement An optional application-provided function that returns the element used in animation.
 * <p>By default animateHero will clone the source element specified by the "fromElement" parameter. Application can override this by returning a different element.</p>
 * @param {(function(AnimationUtils.HeroContext):void)=} options.hideFromAndToElements An optional application-provided function that controls the visibility of the source and destination elements during animation.
 * <p>By default animateHero will hide both the source element and destination element while animating the cloned element.</p>
 * @param {(function(AnimationUtils.HeroContext):Promise)=} options.animateClonedElement An optional application-provided function that animates the cloned element.
 * <p>By default animateHero will move and scale the cloned element to the position and size of the destination element.</p>
 * @param {(function(AnimationUtils.HeroContext):void)=} options.showToElement An optional application-provided function that controls the visibility of the destination element after animation.
 * <p>By default animateHero will show the destination element after animation ends.</p>
 * @param {string=} options.delay  The delay from the time the animation is applied to time the
 * animation should begin. This may be specified in either seconds (by specifying s as the unit) or milliseconds
 * (by specifying ms as the unit). Default is "0s".
 * @param {string=} options.duration The duration that an animation should take to complete. This may be
 * specified in either seconds (by specifying s as the unit) or milliseconds (by specifying ms as the unit).
 * Default is "400ms".
 * @param {string=} options.timingFunction  One of the valid values for either CSS transition-timing-function or CSS
 * animation-timing-function. Default is "ease".
 * @return {Promise.<boolean>} a promise that will be resolved when the animation ends
 *
 * @export
 * @memberof oj.AnimationUtils
 */


oj.AnimationUtils.animateHero = function (element, options) {
  var fromElement = element;
  var resolvedOptions = {
    toElementWaitTime: 5000,
    createClonedElement: oj.AnimationUtils._defaultHeroCreateClonedElement,
    hideFromAndToElements: oj.AnimationUtils._defaultHeroHideFromAndToElements,
    animateClonedElement: oj.AnimationUtils._defaultHeroAnimateClonedElement,
    showToElement: oj.AnimationUtils._defaultHeroShowToElement,
    delay: '0s',
    duration: '400ms',
    timingFunction: 'ease'
  };
  var toElementElapsedTime = 0;
  Object.assign(resolvedOptions, options);
  return new Promise(function (resolve, reject) {
    if (!fromElement) {
      reject('No element specified');
    } else if (!options.toElementSelector) {
      reject('No options.toElementSelector specified');
    } else {
      oj.AnimationUtils._doAnimateHero(fromElement, options.toElementSelector, resolvedOptions, toElementElapsedTime, resolve, reject);
    }
  });
};
/**
 * All the available animation methods supported in oj.AnimationUtils
 * @typedef {Object} oj.AnimationUtils.AnimationMethods
 * @ojvalue {string} "collapse"
 * @ojvalue {string} "expand"
 * @ojvalue {string} "fadeIn"
 * @ojvalue {string} "fadeOut"
 * @ojvalue {string} "flipIn"
 * @ojvalue {string} "flipOut"
 * @ojvalue {string} "ripple"
 * @ojvalue {string} "slideIn"
 * @ojvalue {string} "slideOut"
 * @ojvalue {string} "zoomIn"
 * @ojvalue {string} "zoomOut"
 */

/**
 * The context object passed to callback functions in the animateHero method
 * @typedef {Object} oj.AnimationUtils.HeroContext
 * @property {Element} fromElement The source element
 * @property {Element} toElement The destination element
 * @property {Element|null} clonedElement The cloned element.  This property is null when createClonedElement is called.
 * It will be the value returned by createClonedElement in other callback functions.
 * @property {number} translateX The x offset of the toElement from the fromElement
 * @property {number} translateY The y offset of the toElement from the fromElement
 * @property {number} scaleX The horizontal size ratio of the toElement to the fromElement
 * @property {number} scaleY The vertical size ratio of the toElement to the fromElement
 * @property {number} toElementElapsedTime The elapsed time in millisecond that the destination element becomes present
 * in the DOM tree after animateHero is called. If desired, applications can use this information to adjust the animation.
 * For example, if the destination element takes a long time to appear, a shorter animation may be used.
 */
// --------------------------------------------------- oj.AnimationUtils Styling Start -----------------------------------------------------------
// ---------------- oj-animation-backface --------------

/**
* This is used by the "flipIn" and "flipOut" methods when the "flipTarget" option is set to "children" to flip the children of an element that represents the two faces of a card. <br/>
* The child element that represents the back face must have the "oj-animation-backface" marker class.
* @ojstyleclass oj-animation-backface
* @ojdisplayname Animation Backface
* @ojshortdesc Apply to the child element representing the back face of a card element that can be flipped. See the Help documentation for more information.
* @ojstyleselector div
* @memberof oj.AnimationUtils
*/
// --------------------------------------------------- oj.AnimationUtils Styling End -----------------------------------------------------------

  return oj.AnimationUtils;
});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojdomscroller',['ojs/ojcore-base', 'jquery'], function(oj, $)
{
  "use strict";
/* jslint browser: true*/



/* global Promise:false */

/**
 * @ignore
 * @class oj.DomScroller
 * @classdesc Adds implicit high-water mark scrolling to DOM element
 * @param {Object} element Scrollable DOM element
 * @param {Object} dataprovider dataprovider
 * @param {Object=} options Options for the DomScroller<p>
 *                  <b>asyncIterator</>the iterator for the dataprovider
 *                  <b>success</b>: a user callback called when a fetch has completed successfully after scroll to bottom. Also called with maxCount information if maxCount is reached after scroll to bottom.<br>
 *                  <b>error</b>: a user callback function called if the fetch fails. The callback is called with the failed fetch content.<br>
 *                  <b>fetchSize</b>: the fetch size. Default is 25.<br>
 *                  <b>maxCount</b>: max row count. DomScroller will not exceed this max count. Default is 500.<br>
 *                  <b>initialRowCount</b>: initial row count. DomScroller will be initialized with this row count. Default is 0.<br>
 *                  <b>fetchTrigger</b>: how close should the scroll position be relative to the maximum scroll position before a fetch is triggered. Default is 1 pixel.<br>
 * @constructor
 * @ojtsmodule
 */
var DomScroller = function DomScroller(element, dataprovider, options) {
  // eslint-disable-next-line no-param-reassign
  options = options || {};
  this._data = dataprovider;
  this._asyncIterator = options.asyncIterator;
  this._element = $(element)[0];
  this._fetchSize = options.fetchSize;
  this._fetchSize = this._fetchSize > 0 ? this._fetchSize : 25;
  this._maxCount = options.maxCount;
  this._maxCount = this._maxCount > 0 ? this._maxCount : 500;
  this._rowCount = options.initialRowCount > 0 ? options.initialRowCount : 0;
  this._successCallback = options.success;
  this._requestCallback = options.request;
  this._errorCallback = options.error;
  this._beforeFetchCallback = options.beforeFetch;
  this._handleScrollTopCallback = options.onScrollTop;
  this._localKeyValidator = options.localKeyValidator;

  this._registerDataSourceEventListeners();

  this._fetchTrigger = options.fetchTrigger;

  if (this._fetchTrigger == null || isNaN(this._fetchTrigger)) {
    this._fetchTrigger = 0;
  }

  this._initialScrollTop = this._element.scrollTop;
  this._lastFetchTrigger = 0;
  this._isScrollTriggeredByMouseWheel = false;
  $(this._getScrollEventElement()).on({
    'scroll.domscroller': function () {
      var target = this._element;

      var scrollTop = this._getScrollTop(target);

      var maxScrollTop = target.scrollHeight - target.clientHeight;

      if (maxScrollTop > 0) {
        this._handleScrollerScrollTop(scrollTop, maxScrollTop);
      }
    }.bind(this),
    'wheel.domscroller': function () {
      this._isScrollTriggeredByMouseWheel = true;
    }.bind(this),
    'mousedown.domscroller': function () {
      this._isScrollTriggeredByMouseWheel = false;
    }.bind(this)
  });
};
/**
 * Update value for fetch trigger
 */


DomScroller.prototype.setFetchTrigger = function (fetchTrigger) {
  if (fetchTrigger != null && !isNaN(fetchTrigger) && fetchTrigger >= 0) {
    this._fetchTrigger = fetchTrigger;
  }
};
/**
 * Retrieve the element where the scroll listener is registered on.
 * @private
 */


DomScroller.prototype._getScrollEventElement = function () {
  // if scroller is the body, listen for window scroll event.  This is the only way that works consistently across all browsers.
  if (this._element === document.body || this._element === document.documentElement) {
    return window;
  }

  return this._element;
};
/**
 * Helper method to calculate the offsetTop from element to ancestor
 * @param {Element} ancestor the ancestor element
 * @param {Element} element the element
 * @return {number} the distance between the specified element and ancestor
 */


DomScroller.calculateOffsetTop = function (ancestor, element) {
  var offset = 0;
  var current = element;

  while (current && current !== ancestor && $.contains(ancestor, current)) {
    offset += current.offsetTop;
    current = current.offsetParent;
  }

  return offset;
};
/**
 * Gets the scroll top of the element
 * @param {Element} element the element
 * @return {number} scroll top
 * @private
 */


DomScroller.prototype._getScrollTop = function (element) {
  var scrollTop = this._fetchTrigger;

  if (element === document.documentElement) {
    // to ensure it works across all browsers.  See https://bugs.webkit.org/show_bug.cgi?id=106133
    // for firefox we should use documentElement.scrollTop, for Chrome and IE use body.scrollTop
    // detect this by checking initial scrollTop is the same as current scrolltop, if it's the same then the scrollTop is not
    // returning the correct value and we should use body.scrollTop
    if (this._useBodyScrollTop === undefined) {
      this._useBodyScrollTop = this._initialScrollTop === element.scrollTop;
    }

    if (this._useBodyScrollTop) {
      return scrollTop + document.body.scrollTop;
    }
  }

  return scrollTop + element.scrollTop;
};
/**
 * Destroys the dom scroller, unregister any event handlers.
 * @export
 * @expose
 * @memberof! oj.DomScroller
 * @instance
 */


DomScroller.prototype.destroy = function () {
  this._unregisterDataSourceEventListeners();

  $(this._getScrollEventElement()).off('.domscroller');
};
/**
 * Check the viewport to see if a fetch needs to be done to fill it. Fetch if it does.
 * @return {Promise} Return a Promise which contains either the content of the fetch
 *                   or maxCount information if it has reached maxCount. Promise resolves to null if no fetch was done.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.DomScroller
 * @instance
 */


DomScroller.prototype.checkViewport = function () {
  if (this._asyncIterator && this._element.clientHeight > 0 && !this.isOverflow()) {
    return this._fetchMoreRows();
  }

  return Promise.resolve(null);
};
/**
 * Fetch more rows if beforeFetch callback allows it
 * @private
 */


DomScroller.prototype._doFetch = function (scrollTop) {
  var self = this;

  if (this._beforeFetchCallback(scrollTop - this._fetchTrigger)) {
    this._lastFetchTrigger = scrollTop;
    var isMouseWheel = self._isScrollTriggeredByMouseWheel;
    this._fetchPromise = this._fetchMoreRows().then(function (result) {
      if (self._successCallback) {
        // eslint-disable-next-line no-param-reassign
        result.isMouseWheel = isMouseWheel;

        self._successCallback(result);

        self._fetchPromise = null; // re-calculated on next scroll

        self._nextFetchTrigger = undefined;
      }
    }, function (reason) {
      if (self._errorCallback) {
        self._errorCallback(reason);

        self._fetchPromise = null;
        self._nextFetchTrigger = undefined;
      }
    });
  } else {
    // items not rendered yet, reset nextFetchTrigger so it gets calculated again
    this._nextFetchTrigger = undefined;
  }
};
/**
 * Handle scrollTop on scroller
 * @private
 */


DomScroller.prototype._handleScrollerScrollTop = function (scrollTop, maxScrollTop) {
  if (this._handleScrollTopCallback) {
    this._handleScrollTopCallback(scrollTop);
  }

  if (!this._fetchPromise && this._asyncIterator) {
    if (maxScrollTop !== this._lastMaxScrollTop) {
      this._nextFetchTrigger = Math.max(0, (maxScrollTop - scrollTop) / 2);
      this._lastMaxScrollTop = maxScrollTop;
    }

    if (this._nextFetchTrigger != null && scrollTop - this._lastFetchTrigger > this._nextFetchTrigger) {
      this._doFetch(scrollTop); // note beforeFetchCallback would return false if the render queue is non-empty
      // in which case we should just wait until the next idle cycle to clear the queue


      return;
    }
  }

  if (maxScrollTop - scrollTop < 1 && scrollTop > this._fetchTrigger) {
    if (this._fetchPromise) {
      // at the bottom but fetch has not return yet, in which case we will block UI via requestCallback
      if (this._asyncIterator) {
        if (this._requestCallback != null) {
          this._requestCallback();
        }
      } else if (this._errorCallback != null) {
        this._errorCallback();
      }
    } else if (this._asyncIterator) {
      // at the bottom and all items from last fetch are rendered, start a new fetch
      this._doFetch(scrollTop);
    }
  }
};
/**
 * Check whether the scroll DOM has overflowed
 * @return {boolean} true if overflowed, false otherwise
 */


DomScroller.prototype.isOverflow = function () {
  var element = this._element;
  var diff = element.scrollHeight - (element.clientHeight + this._fetchTrigger);

  if (diff === 1 && oj.AgentUtils.getAgentInfo().browser === oj.AgentUtils.BROWSER.EDGE) {
    // hitting Edge , see https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/21405284/
    // note this will only happen with non-height-bounded ListView with loadMoreOnScroll, see 
    diff = 0;
  }

  return diff > 0;
};
/**
 * Try to fetch more rows
 * @private
 */


DomScroller.prototype._fetchMoreRows = function () {
  if (!this._fetchPromise) {
    // make sure we don't exceed maxCount
    var remainingCount = this._maxCount - this._rowCount;

    if (remainingCount > 0) {
      var self = this;

      if (this._asyncIterator) {
        this._fetchPromise = this._asyncIterator.next().then(function (_result) {
          var result = _result;
          self._fetchPromise = null;

          if (result != null && result.value != null) {
            if (result.value.data.length > 0) {
              self._rowCount += result.value.data.length;

              if (remainingCount < self._fetchSize) {
                result.maxCount = self._maxCount;
                result.maxCountLimit = true;

                if (result.value.data.length > remainingCount) {
                  result.value.data = result.value.data.slice(0, remainingCount);
                  result.value.metadata = result.value.metadata.slice(0, remainingCount);

                  if (result.value.fetchParameters != null) {
                    result.value.fetchParameters.size = remainingCount;
                  }
                }
              }
            } // we have exhausted the iterator, discard so we won't attempt to fetch from it again


            if (result.done || result.maxCountLimit) {
              self._asyncIterator = null;
            }
          }

          return Promise.resolve(result);
        });
        return this._fetchPromise;
      }
    } // we need to indicate that we've hit maxCount


    this._asyncIterator = null;
    return Promise.resolve({
      maxCount: this._maxCount,
      maxCountLimit: true
    });
  }

  return this._fetchPromise;
};
/**
 * @private
 */


DomScroller.prototype._handleDataRowMutateEvent = function (event) {
  // if everything has been fetched already then we don't have to do anything also
  if (this._asyncIterator == null) {
    return;
  }

  var eventDetail;
  var indexes;
  var keys;
  var self = this;

  if (event.detail.add != null) {
    eventDetail = event.detail.add; // for add, it exists if index is in range, or before/after key is in range

    if (eventDetail.indexes != null) {
      indexes = eventDetail.indexes;
    } else if (eventDetail.addBeforeKeys != null) {
      keys = eventDetail.addBeforeKeys;
    } else if (eventDetail.afterKeys != null) {
      // deprecated but still needs to support it
      keys = eventDetail.afterKeys;
    } else {// no keys and indexes, then it's inserting to the end
      // since we already bail when there are nothing to fetch, the only
      // case is when we have not reached the end yet, in which case
      // we should not do anything since it's outside of range
    }

    this._handleDataRowAddedOrRemoved(keys, indexes, function () {
      self._rowCount += 1;
    });
  }

  if (event.detail.remove != null) {
    eventDetail = event.detail.remove; // for remove, it exists if index or key is in range

    if (eventDetail.indexes != null) {
      indexes = eventDetail.indexes;
    } else if (eventDetail.keys != null) {
      keys = eventDetail.keys;
    }

    this._handleDataRowAddedOrRemoved(keys, indexes, function () {
      self._rowCount -= 1;
    });
  }
};
/**
 * @private
 */


DomScroller.prototype._handleDataRowAddedOrRemoved = function (keys, indexes, callback) {
  if (indexes) {
    for (var i = 0; i < indexes.length; i++) {
      var rowIdx = indexes[i]; // we only care if the row is in our range

      if (rowIdx !== undefined && this._rowCount > 0 && rowIdx <= this._rowCount) {
        callback();
      }
    }
  } else if (keys) {
    var keyValidator = this._localKeyValidator;

    if (keyValidator != null) {
      // forEach works for both Array and Set
      keys.forEach(function (key) {
        if (keyValidator(key)) {
          callback();
        }
      });
    }
  }
};
/**
 * Register event listeners which need to be registered datasource.
 * @private
 */


DomScroller.prototype._registerDataSourceEventListeners = function () {
  // register the listeners on the datasource
  var data = this._data;

  if (data != null) {
    this._unregisterDataSourceEventListeners();

    this._dataProviderEventHandlers = [];

    this._dataProviderEventHandlers.push({
      eventType: 'mutate',
      eventHandler: this._handleDataRowMutateEvent.bind(this)
    });

    var i;
    var ev;

    for (i = 0; i < this._dataProviderEventHandlers.length; i++) {
      ev = data.addEventListener(this._dataProviderEventHandlers[i].eventType, this._dataProviderEventHandlers[i].eventHandler);

      if (ev) {
        this._dataProviderEventHandlers[i].eventHandler = ev;
      }
    }
  }
};
/**
 * Unregister event listeners which are registered on datasource.
 * @private
 */


DomScroller.prototype._unregisterDataSourceEventListeners = function () {
  var data = this._data; // unregister the listeners on the datasource

  if (this._dataProviderEventHandlers != null && data != null) {
    var i;

    for (i = 0; i < this._dataProviderEventHandlers.length; i++) {
      data.removeEventListener(this._dataProviderEventHandlers[i].eventType, this._dataProviderEventHandlers[i].eventHandler);
    }
  }
};

;return DomScroller;
});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojdataproviderscroller',['ojs/ojcore', 'jquery', 'require', 'ojs/ojcontext', 'ojs/ojconfig', 
        'ojs/ojcomponentcore', 'ojs/ojlogger', 'ojs/ojdatacollection-common', 
        'ojs/ojanimation', 'ojs/ojdomscroller'], 
      function(oj, $, localRequire, Context, Config, Components, Logger, 
        DataCollectionUtils, AnimationUtils, DomScroller)
{
  "use strict";


/* global Promise:false, Config:false, Context:false, AnimationUtils:false */

/**
 * Base class for IteratingDataProviderContentHandler and TreeDataProviderContentHandler
 * Handler for DataProvider generated content
 * @constructor
 * @ignore
 */
var DataProviderContentHandler = function DataProviderContentHandler(widget, root, data) {
  this.m_root = root;
  this.m_widget = widget;
  this.m_fetching = false;
  this.setDataProvider(data);
  this.Init();
}; // Subclass from oj.Object


oj.Object.createSubclass(DataProviderContentHandler, oj.Object, 'DataProviderContentHandler');
/**
 * Initializes the instance.
 * @export
 */

DataProviderContentHandler.prototype.Init = function () {
  DataProviderContentHandler.superclass.Init.call(this);
};
/**
 * Handles when the listview is shown due to for example CSS changes (inside a dialog)
 */


DataProviderContentHandler.prototype.notifyShown = function () {// by default do nothing, to be override by subclass
};
/**
 * Handles when the listview is re-attached to the DOM (ex: when a children of CCA gets re-attached from slotting)
 */


DataProviderContentHandler.prototype.notifyAttached = function () {// by default do nothing, to be override by subclass
};
/**
 * Cleanse all items under the root node
 */


DataProviderContentHandler.prototype.cleanItems = function (templateEngine, parent) {
  if (templateEngine === undefined) {
    // eslint-disable-next-line no-param-reassign
    templateEngine = this.getTemplateEngine();
  }

  if (parent === undefined) {
    // eslint-disable-next-line no-param-reassign
    parent = this.m_root;
  }

  if (templateEngine && parent) {
    var children = parent.childNodes;

    for (var i = 0; i < children.length; i++) {
      templateEngine.clean(children[i]);
    }
  }
};
/**
 * Destroy the content handler
 * @protected
 */


DataProviderContentHandler.prototype.Destroy = function (completelyDestroy) {
  // this.m_root was changed in RenderContent
  if (this.m_superRoot != null) {
    this.m_root = this.m_superRoot;
  }

  this.cleanItems();

  if (completelyDestroy) {
    $(this.m_root).empty();
  }

  this.m_widget = null;
  this.m_root = null;
  this.m_superRoot = null;
};
/**
 * Determines whether the content handler is in a ready state
 * @return {boolean} true if there's no outstanding fetch, false otherwise.
 * @protected
 */


DataProviderContentHandler.prototype.IsReady = function () {
  return !this.m_fetching;
};
/**
 * Sets any aria attributes on the root element
 * @protected
 */


DataProviderContentHandler.prototype.setRootAriaProperties = function () {
  if (this.shouldUseGridRole()) {
    this.m_root.setAttribute('role', 'grid');
  } else if (this.IsHierarchical()) {
    this.m_root.setAttribute('role', 'tree');
  } else {
    this.m_root.setAttribute('role', 'listbox');
  }
};
/**
 * Renders the content inside the list
 * @protected
 */


DataProviderContentHandler.prototype.RenderContent = function () {
  this.signalTaskStart('rendering content'); // signal method task start

  this.setRootAriaProperties();
  this.fetchRows(false);
  this.signalTaskEnd(); // signal method task end
};
/**
 * Retrieve the key given the item element
 * @param {Element} element
 * @return {Object|null}
 * @protected
 */


DataProviderContentHandler.prototype.GetKey = function (element) {
  // should be in the element
  return element.key;
};

DataProviderContentHandler.prototype.FindElementByKey = function (key) {
  var children = $(this.m_root).find('.' + this.m_widget.getItemElementStyleClass());

  for (var i = 0; i < children.length; i++) {
    var elem = children[i]; // use == for the string number compare case
    // eslint-disable-next-line eqeqeq

    if (key == this.GetKey(elem) || oj.Object.compareValues(key, this.GetKey(elem))) {
      return elem;
    }
  }

  return null;
};

DataProviderContentHandler.prototype.getDataProvider = function () {
  return this.m_dataProvider;
};
/**
 * @protected
 */


DataProviderContentHandler.prototype.setDataProvider = function (dataProvider) {
  this._removeDataSourceEventListeners();

  if (dataProvider != null) {
    this.m_handleModelMutateEventListener = this.handleModelMutateEvent.bind(this);
    this.m_handleModelRefreshEventListener = this.handleModelRefreshEvent.bind(this);
    dataProvider.addEventListener('mutate', this.m_handleModelMutateEventListener);
    dataProvider.addEventListener('refresh', this.m_handleModelRefreshEventListener);
  }

  this.m_dataProvider = dataProvider;
};
/**
 * Remove data source event listeners
 * @private
 */


DataProviderContentHandler.prototype._removeDataSourceEventListeners = function () {
  var dataProvider = this.getDataProvider();

  if (dataProvider != null) {
    dataProvider.removeEventListener('mutate', this.m_handleModelMutateEventListener);
    dataProvider.removeEventListener('refresh', this.m_handleModelRefreshEventListener); // If dataProvider is a TableDataSourceAdapter, call destroy on it also to remove its listeners

    if (oj.TableDataSourceAdapter && dataProvider instanceof oj.TableDataSourceAdapter) {
      dataProvider.destroy();
    }
  }
};
/**
 * Initiate loading of the template engine.  An error is thrown if the template engine failed to load.
 * @return {Promise} resolves to the template engine, or null if:
 *                   1) there's no need because no item template is specified
 *                   2) a renderer is present which takes precedence
 * @protected
 */


DataProviderContentHandler.prototype.loadTemplateEngine = function () {
  var self = this;

  if (this.m_widget.getItemTemplate() != null && this.m_widget._getItemRenderer() == null) {
    return new Promise(function (resolve) {
      Config.__getTemplateEngine().then(function (engine) {
        self.m_engine = engine;
        resolve(engine);
      }, function (reason) {
        throw new Error('Error loading template engine: ' + reason);
      });
    });
  }

  return Promise.resolve(null);
};
/**
 * Retrieve the template engine, returns null if it has not been loaded yet
 */


DataProviderContentHandler.prototype.getTemplateEngine = function () {
  return this.m_engine;
}; // eslint-disable-next-line no-unused-vars


DataProviderContentHandler.prototype.fetchRows = function (forceFetch) {
  this.m_widget.showStatusText();
};
/**
 * Returns the tag name of the item element.
 * @return {string} the tag name of the item element.
 * @protected
 */


DataProviderContentHandler.prototype.GetChildElementTagName = function () {
  return 'LI';
};
/**
 * Returns the insert before element given the index, or null if insert at the end.
 * @return {Element|null} the reference element.
 * @protected
 */


DataProviderContentHandler.prototype.GetReferenceNode = function (parentElement, index) {
  if (index === -1) {
    return null;
  }

  var childElements = $(parentElement).children('.' + this.m_widget.getItemElementStyleClass() + ', .' + this.m_widget.getEmptyTextStyleClass() + ', .oj-listview-temp-item');
  return index === childElements.length ? null : childElements[index];
};
/**
 * Create a list item and add it to the list
 * @param {Element|DocumentFragment} parentElement the element to add the list items to
 * @param {number} index the index of the item
 * @param {Object|null} data the data for the item
 * @param {Object} metadata the set of metadata for the item
 * @param {Object} templateEngine the template engine to process inline template
 * @param {function(Element, Object)=} callback optional callback function to invoke after item is added
 * @return {Object} contains the list item and the context object
 * @return {Object} itemMetaData the array of metadata
 * @protected
 */


DataProviderContentHandler.prototype.addItem = function (parentElement, index, data, metadata, templateEngine, callback, itemMetaData) {
  var item = document.createElement(this.GetChildElementTagName()); // @HTMLUpdateOK

  $(item).uniqueId();
  var referenceNode = this.GetReferenceNode(parentElement, index); // should be optional

  if (this.m_widget.BeforeInsertItem) {
    this.m_widget.BeforeInsertItem();
  }

  parentElement.insertBefore(item, referenceNode); // @HTMLUpdateOK

  var position = $(parentElement).children().index(item);
  return this._addOrReplaceItem(item, position, parentElement, index, data, metadata, templateEngine, callback, false, itemMetaData);
};
/**
 * Replace an existing list item in the list
 * @param {Element} item the list item to change
 * @param {number} index the index of the item
 * @param {Object|null} data the data for the item
 * @param {Object} metadata the set of metadata for the item
 * @param {Object} templateEngine the template engine to process inline template
 * @param {function(Element, Object)} callback callback function to invoke after item is added
 * @param {boolean} restoreFocus flag to restore focus on updated item
 * @protected
 */


DataProviderContentHandler.prototype.replaceItem = function (item, index, data, metadata, templateEngine, callback, restoreFocus) {
  // animate hiding of existing item first
  this.signalTaskStart('replace item'); // signal replace item animation start. Ends in _handleReplaceTransitionEnd() defined in TableDataSourceContentHandler
  // now actually replace the item

  var parentElement = item.parentNode;
  var position = $(parentElement).children().index(item);
  var newItem = document.createElement(this.GetChildElementTagName()); // @HTMLUpdateOK
  // explicit clean when inline template is used

  if (templateEngine) {
    templateEngine.clean(item);
  } // this should trigger ko.cleanNode if applicable


  $(item).replaceWith(newItem); // @HTMLUpdateOK newItem is constructed by the component and not yet manipulated by the application

  this._addOrReplaceItem(newItem, position, parentElement, index, data, metadata, templateEngine, callback, restoreFocus);
};
/**
 * Handles both add and replace item
 * @private
 */


DataProviderContentHandler.prototype._addOrReplaceItem = function (item, position, parentElement, index, data, metadata, templateEngine, callback, restoreFocus, itemMetaData) {
  if (callback == null) {
    // eslint-disable-next-line no-param-reassign
    callback = this.afterRenderItem.bind(this);
  }

  var context = this.createContext(position, data, metadata, item, itemMetaData);

  var renderer = this.m_widget._getItemRenderer();

  var templateElement = this.m_widget.getItemTemplate();
  var textWrapper;
  var isCustomizeItem = false;

  if (renderer != null) {
    // if an element is returned from the renderer and the parent of that element is null, we will append
    // the returned element to the parentElement.  If non-null, we won't do anything, assuming that the
    // rendered content has already added into the DOM somewhere.
    var content = renderer.call(this, context);

    if (content != null) {
      // allow return of document fragment from jquery create/js document.createDocumentFragment
      if (content.parentNode === null || content.parentNode instanceof DocumentFragment) {
        item.appendChild(content); // @HTMLUpdateOK
      } else if (content.parentNode != null) {// parent node exists, do nothing
      } else if (content.toString) {
        textWrapper = document.createElement('span');
        textWrapper.appendChild(document.createTextNode(content.toString())); // @HTMLUpdateOK

        item.appendChild(textWrapper); // @HTMLUpdateOK
      }
    }
  } else if (templateElement != null && templateEngine != null) {
    var componentElement = this.m_widget.GetRootElement()[0];
    var bindingContext = this.GetBindingContext(context);
    var as = this.m_widget.getAs ? this.m_widget.getAs() : null;
    var nodes = templateEngine.execute(componentElement, templateElement, bindingContext, as);
    var tagName = this.GetChildElementTagName();

    for (var i = 0; i < nodes.length; i++) {
      if (nodes[i].tagName === tagName) {
        parentElement.replaceChild(nodes[i], item);
        isCustomizeItem = true;
        break;
      } else {
        item.appendChild(nodes[i]);
      }
    }
  } else {
    textWrapper = document.createElement('span');
    textWrapper.appendChild(document.createTextNode(data == null ? '' : data.toString())); // @HTMLUpdateOK

    item.appendChild(textWrapper); // @HTMLUpdateOK
  } // get the item from root again as template replaces the item element


  var parentItem = parentElement.children ? parentElement.children[position] : this._getItemFromDocumentFragment(parentElement, position);
  context.parentElement = parentItem; // cache data and metadata in item element, this is needed for getDataForVisibleItem.

  $.data(parentItem, 'data', data);
  $.data(parentItem, 'metadata', itemMetaData); // do any post processing

  callback(parentItem, context, isCustomizeItem, restoreFocus);
  return {
    item: parentItem,
    context: context
  };
};
/**
 * In IE/Safari, DocumentFragment does not support children property
 * @private
 */


DataProviderContentHandler.prototype._getItemFromDocumentFragment = function (fragment, index) {
  var nodeIndex = 0;
  var nodes = fragment.childNodes;

  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];

    if (!node) {
      break;
    }

    if (node.nodeType === 1) {
      if (nodeIndex === index) {
        return node;
      }

      nodeIndex += 1;
    }
  }

  return null;
};
/**
 * Creates a binding context based on context object
 * To be override by different ContentHandler
 * @protected
 */


DataProviderContentHandler.prototype.GetBindingContext = function (context) {
  var current = {};
  current.data = context.data;
  current.index = context.index;
  current.key = context.key;
  current.componentElement = context.componentElement;
  return current;
};

DataProviderContentHandler.prototype.afterRenderItem = function (item, context) {
  // save the key in the element (cannot use data- here since it could be a non-string)
  // eslint-disable-next-line no-param-reassign
  item.key = context.key;
  var $item = $(item);
  $item.uniqueId(); // if there's only one element inside the item and it is focusable, set
  // the role on it instead

  var elem = this.m_widget.getSingleFocusableElement($item);

  if (this.shouldUseGridRole()) {
    if (context.leaf != null && !context.leaf) {
      // it's a group item
      $item.attr('role', 'presentation');
    } else if (this.isCardLayout()) {
      elem.attr('role', 'gridcell');
    } else {
      $item.attr('role', 'row');

      if (elem !== $item) {
        elem.attr('role', 'gridcell');
      } else {
        // we'll need to wrap content with a gridcell role
        var wrapperHTML = "<div role='gridcell' class='oj-listview-cell-element'></div>";
        var children = elem.children();

        if (children.length === 0) {
          elem.get(0).innerHTML = wrapperHTML; // @HTMLUpdateOK
        } else {
          // include comment nodes/ko virtual elements
          var cell = document.createElement('div');
          cell.setAttribute('role', 'gridcell');
          cell.className = 'oj-listview-cell-element';

          while (elem[0].firstChild) {
            // The list is LIVE so it will re-index each call
            cell.appendChild(elem[0].firstChild); // @HTMLUpdateOK
          }

          elem[0].appendChild(cell);
        }
      }
    }
  } else {
    elem.attr('role', this.IsHierarchical() ? 'treeitem' : 'option');

    if (elem !== $item) {
      $item.attr('role', 'presentation');
    }
  }

  elem.addClass(this.m_widget.getFocusedElementStyleClass()); // tag it if item is not focusable

  if (!this.isFocusable(context)) {
    $item.addClass('oj-skipfocus');
  }

  $item.addClass(this.m_widget.getItemElementStyleClass());
};
/**
 * Creates the context object containing metadata
 * @param {number} index the index
 * @param {Object} key the key
 * @param {Object} data the data
 * @param {Element} parentElem the parent element
 * @return {Object} the context object
 * @private
 */
// eslint-disable-next-line no-unused-vars


DataProviderContentHandler.prototype.getMetadata = function (index, key, data, parentElem) {
  var context = data.context;

  if (context == null) {
    context = {};
  }

  if (context.index == null) {
    context.index = index;
  }

  if (context.key == null) {
    context.key = key;
  }

  return context;
};
/**
 * Model mutate event handler.  Called on rows mutation.
 * @param {Object} event the mutate model event
 * @protected
 */


DataProviderContentHandler.prototype.handleModelMutateEvent = function (event) {
  if (this.m_root == null || !this.m_widget.isAvailable()) {
    return;
  }

  if (event.detail.remove != null) {
    this.handleModelRemoveEvent(event);
  }

  if (event.detail.add != null) {
    this.handleModelAddEvent(event);
  }

  if (event.detail.update != null) {
    this.handleModelChangeEvent(event);
  }
};
/**
 * @protected
 */
// eslint-disable-next-line no-unused-vars


DataProviderContentHandler.prototype.handleModelRefreshEvent = function (event) {};
/**
 * @private
 */


DataProviderContentHandler.prototype._pushToEventQueue = function (event) {
  if (this.m_eventQueue == null) {
    this.m_eventQueue = [];
  }

  this.m_eventQueue.push(event);
};

DataProviderContentHandler.prototype._processEventQueue = function () {
  var event;

  if (this.m_eventQueue != null && this.m_eventQueue.length > 0) {
    // see if we can find a refresh event
    for (var i = 0; i < this.m_eventQueue.length; i++) {
      event = this.m_eventQueue[i];

      if (event.type === 'refresh') {
        this.handleModelRefreshEvent(event.event); // we are done

        return;
      }
    } // we'll just need to handle one event at a time since processEventQueue will be triggered whenever an event is done processing


    event = this.m_eventQueue.shift();

    if (event.type === 'mutate') {
      this.handleModelMutateEvent(event.event);
    }
  }
};

DataProviderContentHandler.prototype._clearEventQueue = function () {
  if (this.m_eventQueue != null) {
    this.m_eventQueue.length = 0;
  }
};
/**
 * Override by ContentHandler to do the actual model insert
 * @protected
 */


DataProviderContentHandler.prototype.addItemsForModelInsert = // eslint-disable-next-line no-unused-vars
function (data, indexes, keys, parentKeys, afterKeys) {};
/**
 * @private
 */


DataProviderContentHandler.prototype.handleModelAddEvent = function (event) {
  // if listview is busy, queue it for processing later
  if (!this.IsReady()) {
    this._pushToEventQueue({
      type: event.type,
      event: event
    });

    return;
  }

  this.signalTaskStart('handling model add event'); // signal method task start
  // in card layout mode, the root is an additional element created by ListView, and that will be disassociated by ListView when
  // it is empty, re-append it to the root ul (the superRoot)

  if (this.m_superRoot && this.m_root.childNodes.length === 0) {
    this.m_superRoot.appendChild(this.m_root.parentNode);
  }

  var addEvent = event.detail.add;
  var data = addEvent.data;
  var keys = [];
  var refKeys;
  addEvent.keys.forEach(function (key) {
    keys.push(key);
  });
  var keyIter;
  var isBeforeKeys = true;

  if (addEvent.addBeforeKeys !== undefined) {
    keyIter = addEvent.addBeforeKeys;
  } else if (addEvent.afterKeys !== undefined) {
    // afterKeys is deprecated, but continue to support it until we can remove it.
    // forEach can be called on both array and set.
    keyIter = addEvent.afterKeys;
    isBeforeKeys = false;
  }

  if (keyIter) {
    refKeys = [];
    keyIter.forEach(function (key) {
      refKeys.push(key);
    });
  } // parentKeys would be undefined for non-hierarchical DataProvider


  var parentKeys = addEvent.parentKeys; // indexes could be undefined if not supported by DataProvider

  var indexes = addEvent.indexes; // metadata could be undefined if not supported by DataProvider

  var metadata = addEvent.metadata;

  if (data != null && keys != null && keys.length > 0 && data.length > 0 && keys.length === data.length && (indexes == null || indexes.length === data.length)) {
    this.addItemsForModelInsert(data, indexes, keys, parentKeys, isBeforeKeys, refKeys, metadata);
  }

  this.signalTaskEnd(); // signal method task end
};

DataProviderContentHandler.prototype.afterRenderItemForInsertEvent = function (item, context, isCustomizeItem) {
  var action = 'add';
  this.signalTaskStart('after render item from model insert event'); // signal post rendering processing start. Ends at the end of the method.

  item.setAttribute('data-oj-context', '');
  this.afterRenderItem(item, context, isCustomizeItem); // hide it before starting animation to show added item

  var elem = $(item);
  var itemStyleClass = item.className; // save it for restore later
  // eslint-disable-next-line no-param-reassign

  item._className = itemStyleClass; // eslint-disable-next-line no-param-reassign

  item.className = 'oj-listview-temp-item oj-listview-item-add-remove-transition'; // add card style class to wrapper/transforming div

  if (this.isCardLayout()) {
    // eslint-disable-next-line no-param-reassign
    item.className = item.className + ' ' + this.m_widget.getItemStyleClass();
  }

  if (!this.shouldUseGridRole()) {
    elem.children().wrapAll('<div></div>'); // @HTMLUpdateOK
  }

  var content = elem.children().first();

  if (!this.isCardLayout()) {
    content[0].className = itemStyleClass;
  } // transfer key and role for FindElementByKey lookup that might happen while animating (navlist)


  content[0].key = item.key; // transfer aria-selected for selectable checks that might happen while animating (navlist)

  if (!this.shouldUseGridRole()) {
    content.attr('role', item.getAttribute('role'));

    if (elem[0].hasAttribute('aria-selected')) {
      content.attr('aria-selected', item.getAttribute('aria-selected'));
    }
  }

  var self = this; // initially hide it to avoid blinking
  // eslint-disable-next-line no-param-reassign

  item.style.opacity = 0;
  var busyContext = Context.getContext(item).getBusyContext();
  busyContext.whenReady().then(function () {
    if (self.m_widget == null) {
      return;
    }

    self.signalTaskStart('kick off animation for insert item'); // signal add animation start. Ends in _handleAddTransitionEnd().

    var promise = self.m_widget.StartAnimation(item, action); // now show it

    promise.then(function () {
      // eslint-disable-next-line no-param-reassign
      item.style.opacity = '';
      item.removeAttribute('data-oj-context');

      self._handleAddTransitionEnd(context, item);
    });
    self.signalTaskEnd(); // signal post rendering processing end. Started at the beginning of the method.
  });
};

DataProviderContentHandler.prototype._handleAddTransitionEnd = function (context, elem) {
  // this could have been called after listview is destroyed
  // or it could have been removed immediately
  if (this.m_widget == null || elem.parentNode == null) {
    this.signalTaskEnd();
    return;
  }

  var hasFocus = elem.classList.contains('oj-focus') && elem.classList.contains('oj-focus-highlight'); // restore class name
  // eslint-disable-next-line no-param-reassign

  elem.className = elem._className;

  if (hasFocus) {
    elem.classList.add('oj-focus');
    elem.classList.add('oj-focus-highlight');
  }

  if (this.shouldUseGridRole()) {
    if (!this.isCardLayout()) {
      // eslint-disable-next-line no-param-reassign
      elem.children[0].className = 'oj-listview-cell-element';
    }
  } else {
    $(elem).children().children().unwrap();
  }

  this.m_widget.itemInsertComplete(elem, context);
  this.signalTaskEnd(); // signal add animation end. Started in afterRenderItemForInsertEvent();
};

DataProviderContentHandler.prototype.handleModelRemoveEvent = function (event) {
  var self = this;
  var keys = event.detail.remove.keys;

  if (keys == null || keys.size === 0) {
    return;
  } // if listview is busy, hold that off until later


  if (!this.IsReady()) {
    this._pushToEventQueue({
      type: event.type,
      event: event
    });

    return;
  }

  this.signalTaskStart('handling model remove event'); // signal method task start

  var promises = [];
  keys.forEach(function (key) {
    var elem = self.FindElementByKey(key);

    if (elem != null) {
      self.signalTaskStart('handling model remove event for item: ' + key); // signal removeItem start
      // item remove might have been just added (in insert animation phase)

      if (elem.parentNode.classList.contains('oj-listview-temp-item')) {
        elem = elem.parentNode;
      }

      promises.push(self._removeItem(elem));
      self.signalTaskEnd(); // signal removeItem end
    }
  }); // checks whether the removed item is selected, and adjust the value as needed

  if (this.isSelectionEnabled()) {
    var selected = this.m_widget.options.selected;
    var newSelected = selected.delete(keys); // update selection option if it did changed

    if (selected !== newSelected) {
      var selectedItems = [];

      if (newSelected.values) {
        newSelected.values().forEach(function (key) {
          selectedItems.push(self.FindElementByKey(key));
        });
      }

      this.m_widget._setSelectionOption(newSelected, null, selectedItems);
    }
  } // since the items are removed, need to clear cache


  this.m_widget.ClearCache(); // check viewport after multiple items are removed

  Promise.all(promises).then(function () {
    self.afterItemsRemoved();
  });
  this.signalTaskEnd(); // signal method task end
};
/**
 * Invoke after a set of items are removed
 * @protected
 */


DataProviderContentHandler.prototype.afterItemsRemoved = function () {};
/**
 * Remove a single item element
 * @param {jQuery|Element} elem the element to remove
 * @private
 */


DataProviderContentHandler.prototype._removeItem = function (elem) {
  var self = this;
  var action = 'remove';
  this.signalTaskStart('removing an item'); // signal method task start
  // got to do this before wrapAll since that changes activeElement

  var active = document.activeElement;
  var restoreFocus = elem.contains(active);
  var item = $(elem).get(0);
  var itemStyleClass = item.className;
  $(item).children().wrapAll("<div class='" + itemStyleClass + "'></div>"); // @HTMLUpdateOK

  item.className = 'oj-listview-item-add-remove-transition';
  item.children[0].key = elem.key;
  this.signalTaskStart('kick off animation to remove an item'); // signal remove item animation start. Ends in handleRemoveTransitionEnd()

  var promise = this.m_widget.StartAnimation(item, action); // now hide it

  promise.then(function () {
    self.handleRemoveTransitionEnd(elem, restoreFocus);
  });
  this.signalTaskEnd(); // signal method task end

  return promise;
};
/**
 * Handles when remove item animation transition ends
 * @param {Element|jQuery} elem
 * @param {boolean} restoreFocus
 * @protected
 */


DataProviderContentHandler.prototype.handleRemoveTransitionEnd = function (elem, restoreFocus) {
  // this could have been called after listview is destroyed
  if (this.m_widget == null) {
    this.signalTaskEnd();
    return;
  }

  var $elem = $(elem);
  var parent = $elem.parent(); // could happen if there is a reset right after model update, the content has already been cleared out

  if (parent.length === 0) {
    this.signalTaskEnd();
    return;
  } // invoke hook before actually removing the item


  this.m_widget.itemRemoveComplete($elem.get(0), restoreFocus); // template engine should have already been loaded

  var templateEngine = this.getTemplateEngine();

  if (templateEngine) {
    templateEngine.clean($elem.get(0));
  }

  $elem.remove(); // if it's the last item, show empty text

  if (parent.get(0).childElementCount === 0) {
    this.m_widget.renderComplete();
  } // ensure something is selected if the removed item is the last selected item
  // need to complete after the DOM element is removed


  if (this.isSelectionEnabled()) {
    this.m_widget.enforceSelectionRequired();
  } // this should focus on the current item, set by itemRemoveComplete


  if (restoreFocus) {
    this.m_root.focus();
  }

  this.signalTaskEnd(); // signal remove item animation end. Started in _removeItem()
};
/**
 * Model change event handler.  Called when a row has been changed from the underlying data.
 * @param {Object} event the model change event
 * @private
 */


DataProviderContentHandler.prototype.handleModelChangeEvent = function (event) {
  this.signalTaskStart('handling model update event'); // signal method task start

  var changeEvent = event.detail.update;
  var data = changeEvent.data;
  var keys = [];
  changeEvent.keys.forEach(function (key) {
    keys.push(key);
  }); // template engine should have already been loaded

  var templateEngine = this.getTemplateEngine();
  var restoreFocusElem; // indexes could be undefined if not supported by DataProvider

  var indexes = changeEvent.indexes;
  var firstSelectedFound = false;

  for (var i = 0; i < keys.length; i++) {
    var elem = this.FindElementByKey(keys[i]);

    if (elem != null) {
      if (restoreFocusElem === undefined && elem.contains(document.activeElement)) {
        restoreFocusElem = elem;
      }

      if (!firstSelectedFound && this.m_widget.isFirstSelectedItem(keys[i])) {
        this.m_widget.setFirstSelectedItem(keys[i], data[i]);
        firstSelectedFound = true;
      }

      this.signalTaskStart('handling model update event for item: ' + keys[i]); // signal replace item start

      var index = indexes == null ? -1 : indexes[i];
      this.replaceItem(elem, index, data[i], this.getMetadata(index, keys[i], data[i], elem.parentNode), templateEngine, this.afterRenderItemForChangeEvent.bind(this), restoreFocusElem != null);
      this.signalTaskEnd(); // signal replace item end

      if (restoreFocusElem != null) {
        restoreFocusElem = null; // doing this will ensure we don't do the check again
      }
    }
  } // since the item element will change, need to clear cache


  this.m_widget.ClearCache();
  this.signalTaskEnd(); // signal method task end
};
/**
 * @private
 */


DataProviderContentHandler.prototype.afterRenderItemForChangeEvent = function (item, context, isCustomizeItem, restoreFocus) {
  var self = this;
  var action = 'update';
  this.signalTaskStart('after render item for model change event'); // signal method task start
  // adds all neccessary wai aria role and classes

  this.afterRenderItem(item, context);
  var promise = this.m_widget.StartAnimation(item, action); // now hide it

  promise.then(function () {
    self._handleReplaceTransitionEnd(item, restoreFocus);
  });
  this.signalTaskEnd(); // signal method task end
};
/**
 * @private
 */


DataProviderContentHandler.prototype._handleReplaceTransitionEnd = function (item, restoreFocus) {
  // this could have been called after listview is destroyed
  if (this.m_widget == null) {
    this.signalTaskEnd();
    return;
  }

  $(item).removeClass('oj-listview-item-add-remove-transition');

  if (restoreFocus) {
    this.m_widget.restoreCurrentItemFocus(item);
  }

  this.signalTaskEnd(); // signal replace item animation end. Started in replaceItem() from handleModelChangeEvent() (see base class DataSourceContentHandler)
};

DataProviderContentHandler.prototype.createContext = function (index, data, metadata, elem, itemMetaData) {
  var context = {};
  context.parentElement = elem;
  context.index = index;
  context.data = data;
  context.component = this.m_widget.getWidgetConstructor();
  context.datasource = this.getDataProvider();
  context = this.m_widget._FixRendererContext(context);
  context.metadata = itemMetaData; // merge properties from metadata into cell context
  // the properties in metadata would have precedence

  var props = Object.keys(metadata);

  for (var i = 0; i < props.length; i++) {
    var prop = props[i];
    context[prop] = metadata[prop];
  }

  return context;
};

DataProviderContentHandler.prototype.isSelectionEnabled = function () {
  return this.m_widget._isSelectionEnabled();
};

DataProviderContentHandler.prototype.isFocusable = function (context) {
  return this.m_widget.getItemFocusable(context);
};

DataProviderContentHandler.prototype.isSelectable = function (context) {
  return this.m_widget.getItemSelectable(context);
};

DataProviderContentHandler.prototype.isCardLayout = function () {
  return this.m_widget.isCardLayout();
};

DataProviderContentHandler.prototype.shouldUseGridRole = function () {
  return this.m_widget.ShouldUseGridRole();
};

DataProviderContentHandler.prototype.isAsyncRendering = function () {
  return false; //    return this.m_widget.ojContext._IsCustomElement() && this.shouldUseGridRole();
};

DataProviderContentHandler.prototype.signalTaskStart = function (description) {
  if (this.m_widget) {
    // check that widget exists (e.g. not destroyed)
    this.m_widget.signalTaskStart('DataSource ContentHandler ' + description);
  }
};

DataProviderContentHandler.prototype.signalTaskEnd = function () {
  if (this.m_widget) {
    // check that widget exists (e.g. not destroyed)
    this.m_widget.signalTaskEnd();
  }
}; // Skeleton rendering related methods

/**
 * Whether skeleton is supported (current only in Redwood)
 * @protected
 */


DataProviderContentHandler.prototype.isSkeletonSupport = function () {
  return this.m_widget.isSkeletonSupport();
};
/**
 * Gets the height of the root (UL)
 * @protected
 */


DataProviderContentHandler.prototype.getRootElementHeight = function () {
  if (isNaN(this.m_height)) {
    this.m_height = this.m_widget.GetRootElement()[0].offsetHeight;
  }

  return this.m_height;
};
/**
 * Get the dimension of the default skeleton
 * @protected
 */


DataProviderContentHandler.prototype.getDefaultSkeletonDimension = function () {
  if (this.m_defaultSkeletonDim == null) {
    var root = this.m_widget.GetRootElement()[0];
    var skeleton = this.createSkeleton(true);
    skeleton.style.display = 'block';
    skeleton.style.visibility = 'hidden';
    root.appendChild(skeleton); // @HTMLUpdateOK

    var dim = {
      width: skeleton.offsetWidth,
      height: skeleton.offsetHeight
    };
    root.removeChild(skeleton);

    if (dim.height > 0 && dim.width > 0) {
      // cache the value only if it's valid
      this.m_defaultSkeletonDim = dim;
    }

    return dim;
  }

  return this.m_defaultSkeletonDim;
};
/**
 * Creates a skeleton representing a single item.
 * @protected
 */
// eslint-disable-next-line no-unused-vars


DataProviderContentHandler.prototype.createSkeleton = function (initial) {
  return this.createSkeletonItem();
};
/**
 * Creates a skeleton representing a single item.
 * @protected
 */


DataProviderContentHandler.prototype.createSkeletonItem = function () {
  var item = document.createElement('li');
  var content = document.createElement('div');
  item.className = 'oj-listview-item oj-listview-item-layout';

  if (!this.m_widget._isGridlinesVisible()) {
    item.classList.add('gridline-hidden');
  } // oj-listview-skeleton is a marker class to identify this is an item skeleton and not skeleton from other component


  content.className = 'oj-listview-cell-element oj-listview-skeleton oj-listview-skeleton-line-height oj-animation-skeleton';
  item.appendChild(content); // @HTMLUpdateOK

  return item;
};
/**
 * Do the animation of fading out the skeletons and fade in the actual content
 * Returns a Promie that resolves to false to signal not to skip post processing
 * @protected
 */


DataProviderContentHandler.prototype.animateShowContent = function (parentElem, content, shouldEmptyElem) {
  // first fade out the skeletons, if any
  // eslint-disable-next-line no-unused-vars
  return new Promise(function (resolve, reject) {
    var root = this.m_superRoot != null ? this.m_superRoot : this.m_root;
    var skeletonContainer = root.querySelector('.oj-listview-skeleton-container');

    if (skeletonContainer != null) {
      AnimationUtils.fadeOut(skeletonContainer, {
        duration: '100ms'
      }).then(function () {
        // remove skeleton
        var skeletonContainerRoot = skeletonContainer.parentNode;

        if (skeletonContainerRoot.classList.contains('oj-listview-initial-skeletons')) {
          root.removeChild(skeletonContainerRoot);
        }

        if (shouldEmptyElem) {
          $(parentElem).empty();
        }

        parentElem.appendChild(content); // @HTMLUpdateOK
        // issue, if I just start the fadeIn animation here, the animation will end immediately.
        // To workaround it, we start the fadeIn animation on a slight delay.  However, because of the
        // delay, we ended up have to set opacity to 0 to avoid the actual content from briefly showing up.
        // eslint-disable-next-line no-param-reassign

        parentElem.style.opacity = 0;
        window.requestAnimationFrame(function () {
          AnimationUtils.fadeIn(parentElem, {
            duration: '150ms',
            persist: 'all'
          });
        }); // can resolve immediately instead of waiting for fade in

        resolve(false);
      });
    } else {
      // skeleton is not supported
      if (shouldEmptyElem) {
        $(parentElem).empty();
      }

      parentElem.appendChild(content); // @HTMLUpdateOK
      // can resolve immediately instead of waiting for fade in

      resolve(false);
    }
  }.bind(this));
};



/* global Promise:false, Symbol:false, Logger:false, Context:false, DataProviderContentHandler:false, DataCollectionUtils:false DomScroller:false */

/**
 * Handler for IteratingDataProvider generated content
 * @constructor
 * @extends DataProviderContentHandler
 * @ignore
 */
var IteratingDataProviderContentHandler = function IteratingDataProviderContentHandler(widget, root, data) {
  IteratingDataProviderContentHandler.superclass.constructor.call(this, widget, root, data);
}; // Subclass from oj.DataSourceContentHandler


oj.Object.createSubclass(IteratingDataProviderContentHandler, DataProviderContentHandler, 'IteratingDataProviderContentHandler');
/**
 * Initializes the instance.
 * @protected
 */

IteratingDataProviderContentHandler.prototype.Init = function () {
  IteratingDataProviderContentHandler.superclass.Init.call(this);
};

IteratingDataProviderContentHandler.prototype.IsHierarchical = function () {
  return false;
};
/**
 * Determines whether the content handler is in a ready state
 * @return {boolean} true if there's no outstanding fetch or outstanding item in render queue, false otherwise.
 * @protected
 */


IteratingDataProviderContentHandler.prototype.IsReady = function () {
  return !this.m_fetching && this.m_idleCallback == null;
};
/**
 * Destroy the internal DomScroller if there is one.  Called when this ContentHandler is destroyed or on refresh.
 * @private
 */


IteratingDataProviderContentHandler.prototype._destroyDomScroller = function () {
  if (this.m_domScroller != null) {
    this.m_domScroller.destroy();
    this.m_domScroller = null;
  } // remove loading indicator if it still exists:


  this._removeLoadingIndicator();
};
/**
 * Destroy the content handler
 * @protected
 */


IteratingDataProviderContentHandler.prototype.Destroy = function (completelyDestroy) {
  IteratingDataProviderContentHandler.superclass.Destroy.call(this, completelyDestroy);

  this._removeDataSourceEventListeners();

  this._destroyDomScroller();

  this._cancelIdleCallback();

  this.m_loadingIndicator = null;
  this.m_viewportCheckPromise = null;
  this.m_checkViewportPromise = null;
};
/**
 * @private
 */


IteratingDataProviderContentHandler.prototype._cancelIdleCallback = function () {
  if (this.m_idleCallback != null) {
    if (!window.requestIdleCallback || !window.cancelIdleCallback) {
      window.cancelAnimationFrame(this.m_idleCallback);
    } else {
      window.cancelIdleCallback(this.m_idleCallback); // requestAnimationFrame might have been used

      window.cancelAnimationFrame(this.m_idleCallback);
    }

    this.m_idleCallback = null;
  }
};

IteratingDataProviderContentHandler.prototype.shouldHandleResize = function () {
  // we only care about the high-water mark scrolling case
  return this._isLoadMoreOnScroll();
};

IteratingDataProviderContentHandler.prototype.HandleResize = function (width, height) {
  // we only care about the high-water mark scrolling case, and if height changes
  if (!this._isLoadMoreOnScroll()) {
    return;
  }

  var currentWidth = this.m_width;
  var currentHeight = this.m_height;
  this.m_height = height;
  this.m_width = width; // reset column count so it can be re-calculated again

  this.m_colCount = undefined; // the number of skeletons needs to be adjusted because the number of columns might change

  var isCardLayout = this.isCardLayout();

  if (isCardLayout && this.isSkeletonSupport() && currentWidth !== width) {
    // adjust load more skeletons
    if (this.m_loadingIndicator != null) {
      this._adjustLoadMoreSkeletons(this._getRootElementWidth(true));
    } else {
      var container = this.m_root.querySelector('.oj-listview-skeleton-container');

      if (container != null) {
        // this must be the initial skeleton, just re-render them
        this.renderInitialSkeletons();
      }
    }
  } // check viewport if the height increased (or also width change if it's card layout)


  if (height > currentHeight || isCardLayout && width > currentWidth) {
    this.checkViewport();
  }
};
/**
 * @override
 */


IteratingDataProviderContentHandler.prototype.notifyShown = function () {
  // we only care about the high-water mark scrolling case
  if (!this._isLoadMoreOnScroll()) {
    return;
  } // for loadMoreOnScroll case, we will have to make sure the viewport is satisfied


  this.checkViewport();
};
/**
 * @override
 */


IteratingDataProviderContentHandler.prototype.notifyAttached = function () {
  // this should only be populated in high-water mark scrolling case with scroller specified
  var currentFetchTrigger = this._getFetchTrigger();

  if (currentFetchTrigger != null && this.m_domScroller != null) {
    // this should force the fetch trigger to recalculate
    var fetchTrigger = this._getFetchTrigger();

    if (currentFetchTrigger !== fetchTrigger) {
      // update fetch trigger
      this.m_domScroller.setFetchTrigger(fetchTrigger);
    } // check again whether the viewport is satisfied


    this.checkViewport();
  }
};
/**
 * Sets aria properties on root
 * @override
 */


IteratingDataProviderContentHandler.prototype.setRootAriaProperties = function () {
  IteratingDataProviderContentHandler.superclass.setRootAriaProperties.call(this); // for high-water mark scrolling, we'll need to add additional wai-aria attribute since not
  // all items are in the DOM

  var self = this;

  if (this.shouldUseGridRole() && this._isLoadMoreOnScroll()) {
    this.getDataProvider().getTotalSize().then(function (size) {
      // self.m_root may have been cleared before the getTotalSize promise resolves
      // (this happened in oj-select-single unit tests)
      if (self.m_root) {
        // if count is unknown, then use max count
        self.m_root.setAttribute('aria-rowcount', size === -1 ? self._getMaxCount() : size);
      }
    });
  }
};
/**
 * Unsets aria properties on root
 * @override
 */


IteratingDataProviderContentHandler.prototype.unsetRootAriaProperties = function () {
  IteratingDataProviderContentHandler.superclass.unsetRootAriaProperties.call(this);
  this.m_root.removeAttribute('aria-rowcount');
};
/**
 * Is loadMoreOnScroll
 * @return {boolean} true or false
 * @private
 */


IteratingDataProviderContentHandler.prototype._isLoadMoreOnScroll = function () {
  return this.m_widget.isLoadMoreOnScroll();
};
/**
 * Gets the number of items to return in each fetch
 * @return {number} the fetch size
 * @private
 */


IteratingDataProviderContentHandler.prototype._getFetchSize = function () {
  return Math.max(0, this.m_widget.options.scrollPolicyOptions.fetchSize);
};
/**
 * Gets the scroller element used in DomScroller
 * @return {Element} the scroller element
 * @private
 */


IteratingDataProviderContentHandler.prototype._getScroller = function () {
  var scroller = this.m_widget.options.scrollPolicyOptions.scroller;

  if (scroller != null) {
    // make sure it's an ancestor
    if ($.contains(scroller, this.m_root)) {
      // might as well calculate offset here
      if (this._fetchTrigger === undefined) {
        this._fetchTrigger = DomScroller.calculateOffsetTop(scroller, this.m_root) + this._getLoadingIndicatorHeight();
      }

      return scroller;
    }
  } // if not specified or not an ancestor, use the listview root element


  return this.m_widget.GetRootElement()[0];
};
/**
 * Gets the distance from maximum scroll position that triggers a fetch
 * @return {number|undefined} the distance in pixel or undefined if no scroller is specified
 * @private
 */


IteratingDataProviderContentHandler.prototype._getFetchTrigger = function () {
  if (this._fetchTrigger === undefined) {
    this._fetchTrigger = this._getLoadingIndicatorHeight();
  }

  return this._fetchTrigger;
};
/**
 * Calculates the height of the loading indicator
 * @return {number} the height of the loading indicator
 * @private
 */


IteratingDataProviderContentHandler.prototype._getLoadingIndicatorHeight = function () {
  var height;

  if (this.isSkeletonSupport()) {
    height = this.getDefaultSkeletonDimension().height;

    if (!this.isCardLayout()) {
      height *= IteratingDataProviderContentHandler.LOAD_MORE_SKELETONS_ROW_COUNT;
    }
  } else {
    var container = $(document.createElement('div'));
    container.addClass(this.m_widget.getItemStyleClass()).css({
      visibility: 'hidden',
      overflow: 'hidden',
      position: 'absolute'
    });
    var icon = $(document.createElement('div'));
    icon.addClass('oj-icon oj-listview-loading-icon');
    container.append(icon); // @HTMLUpdateOK

    $(this.m_widget.GetRootElement()).append(container); // @HTMLUpdateOK

    height = container.get(0).offsetHeight;
    container.remove();
  }

  return height;
};
/**
 * Gets the maximum number of items that can be retrieved from data source
 * @return {number} the maximum fetch count
 * @private
 */


IteratingDataProviderContentHandler.prototype._getMaxCount = function () {
  return this.m_widget.options.scrollPolicyOptions.maxCount;
};
/**
 * Adjust the dimension of the default skeleton and the content inside it
 * @private
 */


IteratingDataProviderContentHandler.prototype._adjustSkeletonCardContent = function (item, width, height) {
  // eslint-disable-next-line no-param-reassign
  item.style.width = width + 'px'; // eslint-disable-next-line no-param-reassign

  item.style.height = height + 'px';
};
/**
 * Creates a skeleton representing a single card.
 * @private
 */


IteratingDataProviderContentHandler.prototype._createSkeletonCard = function () {
  var card = document.createElement('li');
  var content = document.createElement('div');
  card.className = 'oj-listview-skeleton-card'; // oj-listview-skeleton is a marker class to identify this is an item skeleton and not skeleton from other component

  content.className = 'oj-listview-skeleton oj-listview-skeleton-card-content oj-animation-skeleton';
  card.appendChild(content); // @HTMLUpdateOK

  return card;
};
/**
 * Creates a skeleton representing a single item/card.
 * @protected
 * @override
 */


IteratingDataProviderContentHandler.prototype.createSkeleton = function (initial) {
  var defaultSkeleton;

  if (this.isCardLayout()) {
    if (initial) {
      if (this.m_defaultItemSkeleton === undefined) {
        this.m_defaultItemSkeleton = this._createSkeletonCard();
      }

      defaultSkeleton = this.m_defaultItemSkeleton;
    } else {
      if (this.m_defaultLoadMoreSkeleton === undefined) {
        var card = this._createSkeletonCard();

        var dim = this._getCardDimension();

        this._adjustSkeletonCardContent(card, dim.width, dim.height);

        this.m_defaultLoadMoreSkeleton = card;
      }

      defaultSkeleton = this.m_defaultLoadMoreSkeleton;
    }
  } else {
    if (this.m_defaultItemSkeleton === undefined) {
      this.m_defaultItemSkeleton = this.createSkeletonItem();
    }

    defaultSkeleton = this.m_defaultItemSkeleton;
  }

  return defaultSkeleton.cloneNode(true);
};
/**
 * Gets the width of the browser scrollbar
 * @private
 */


IteratingDataProviderContentHandler.prototype._getScrollbarWidth = function () {
  if (isNaN(this.m_scrollbarWidth)) {
    var root = this.m_widget.GetRootElement()[0];
    var dummy = document.createElement('div');
    root.appendChild(dummy); // @HTMLUpdateOK

    this.m_scrollbarWidth = Math.max(0, DataCollectionUtils.getDefaultScrollBarWidth(dummy));
    root.removeChild(dummy);
  }

  return this.m_scrollbarWidth;
};
/**
 * Gets the width of the root (UL)
 * @private
 */


IteratingDataProviderContentHandler.prototype._getRootElementWidth = function (excludeScrollbar) {
  if (isNaN(this.m_width)) {
    this.m_width = this.m_widget.GetRootElement()[0].offsetWidth;
  }

  return excludeScrollbar ? this.m_width - this._getScrollbarWidth() : this.m_width;
};
/**
 * Displays skeletons for initial fetch.  Invoked by the widget.
 */


IteratingDataProviderContentHandler.prototype.renderInitialSkeletons = function () {
  // empty out root element before adding skeletons
  if (this.m_superRoot) {
    this.m_root = this.m_superRoot;
    this.m_superRoot = null;
  }

  $(this.m_root).empty(); // determines how many items needed to fill the viewport

  var height = this.getRootElementHeight(); // figure out how many item/card are needed to fill the viewport
  // use floor to avoid triggering overflow

  var count = 0;
  var skeletonDimension = this.getDefaultSkeletonDimension();

  if (skeletonDimension.width > 0 && skeletonDimension.height > 0) {
    if (this.isCardLayout()) {
      var margin = this._getMargin();

      var width = this._getRootElementWidth();

      var colCount = Math.max(1, Math.floor(width / (skeletonDimension.width + margin)));
      var rowCount = Math.max(1, Math.floor(height / (skeletonDimension.height + margin)));
      count = rowCount * colCount;
    } else {
      count = Math.max(1, Math.floor(height / skeletonDimension.height));
    }
  }

  var container = document.createElement('li');
  container.setAttribute('role', 'presentation');
  container.classList.add('oj-listview-initial-skeletons');
  var list = document.createElement('ul');
  list.setAttribute('role', 'presentation');
  list.className = this.m_widget.getGroupStyleClass() + ' oj-listview-skeleton-container';

  for (var i = 0; i < count; i++) {
    list.appendChild(this.createSkeleton(true)); // @HTMLUpdateOK
  }

  container.appendChild(list); // @HTMLUpdateOK

  this.m_root.appendChild(container); // @HTMLUpdateOK
};

IteratingDataProviderContentHandler.LOAD_MORE_SKELETONS_ROW_COUNT = 3;
/**
 * Adjust the load more skeleton in the case of component resize/reattach
 * @private
 */

IteratingDataProviderContentHandler.prototype._adjustLoadMoreSkeletons = function (width) {
  var margin = this._getMargin();

  var newColCount = Math.floor(width / (this._getCardDimension().width + margin));
  var container = this.m_loadingIndicator.get(0).firstElementChild;
  var currentColCount = container.childElementCount;
  var diff = newColCount - currentColCount;

  if (diff === 0) {
    return;
  } // remove all skeletons.  note it's better to just recreate the skeletons instead of maniulate them
  // because we have to make sure the animation is synchrionize


  this.m_loadingIndicator.get(0).parentNode.removeChild(this.m_loadingIndicator.get(0));

  if (this.m_fillerSkeletons != null) {
    this.m_fillerSkeletons.parentNode.removeChild(this.m_fillerSkeletons);
  }

  this.m_loadingIndicator = null;
  this.m_fillerSkeletons = null; // repopulate the skeletons

  this._appendLoadingIndicator();
};
/**
 * Calculate what the margin is between cards
 * @private
 */


IteratingDataProviderContentHandler.prototype._getMargin = function () {
  if (this.m_margin === undefined) {
    var elem = document.createElement('li');
    elem.className = this.m_widget.getItemStyleClass();
    this.m_root.appendChild(elem); // @HTMLUpdateOK

    var style = window.getComputedStyle(elem);
    this.m_margin = parseInt(style.marginRight, 10);
    this.m_root.removeChild(elem);
  }

  return this.m_margin;
};
/**
 * Gets the dimension of a card (actual not skeleton)
 * @private
 */


IteratingDataProviderContentHandler.prototype._getCardDimension = function () {
  if (this.m_cardDim === undefined) {
    var elem = this.m_root.querySelector('.' + this.m_widget.getItemElementStyleClass());

    if (elem) {
      var dim = {
        width: elem.offsetWidth,
        height: elem.offsetHeight
      }; // don't cache the value if it's invalid

      if (dim.width > 0 && dim.height > 0) {
        this.m_cardDim = dim;
      }

      return dim;
    }
  }

  return this.m_cardDim;
};
/**
 * Renders a group of skeleton cards/items
 * @private
 */


IteratingDataProviderContentHandler.prototype._renderSkeletons = function (count) {
  var container = this.createLoadingIndicator();
  var group = document.createElement('ul');
  group.className = this.isCardLayout() ? 'oj-listview-skeleton-card-group' : 'oj-listview-group';
  container.appendChild(group); // @HTMLUpdateOK

  for (var i = 0; i < count; i++) {
    group.appendChild(this.createSkeleton(false)); // @HTMLUpdateOK
  }

  return container;
};
/**
 * Fills any empty space in the last row with skeleton cards
 * @private
 */


IteratingDataProviderContentHandler.prototype._fillEmptySpaceWithSkeletons = function () {
  // first check how many do we need
  var lastItem = this.m_root.lastElementChild;

  var cardWidth = this._getCardDimension().width;

  if (cardWidth === 0) {
    return;
  }

  var cardWidthWithMargin = cardWidth + this._getMargin();

  var width = this._getRootElementWidth(true);

  var count = Math.floor((width - lastItem.offsetLeft - cardWidthWithMargin) / cardWidthWithMargin);

  if (count > 0) {
    var container = this._renderSkeletons(count);

    this.m_root.appendChild(container); // @HTMLUpdateOK

    this.m_fillerSkeletons = container;
  }
};
/**
 * Creates the load more skeletons
 * @private
 */


IteratingDataProviderContentHandler.prototype._createLoadMoreSkeletons = function () {
  var count;

  if (this.isCardLayout()) {
    var width = this._getRootElementWidth(true);

    var cardDimension = this._getCardDimension();

    var cardWidth = cardDimension === undefined ? this.getDefaultSkeletonDimension().width : cardDimension.width;
    count = cardWidth === 0 ? 0 : Math.floor(width / (cardWidth + this._getMargin()));
  } else {
    count = IteratingDataProviderContentHandler.LOAD_MORE_SKELETONS_ROW_COUNT;
  }

  return this._renderSkeletons(count);
};
/**
 * Creates the load more indicator icon
 * @private
 */


IteratingDataProviderContentHandler.prototype._createLoadMoreIcon = function () {
  var item = $(this.createLoadingIndicator());
  item.uniqueId().attr('role', 'presentation').addClass(this.m_widget.getItemStyleClass()).addClass('oj-listview-loading-icon-container');
  var icon = $(document.createElement('div'));
  icon.addClass('oj-icon oj-listview-loading-icon');
  item.append(icon); // @HTMLUpdateOK

  return item.get(0);
};
/**
 * @return {Element} the loading indicator element
 */


IteratingDataProviderContentHandler.prototype.createLoadingIndicator = function () {
  return document.createElement('li');
};
/**
 * Add a loading indicator to the list for high-water mark scrolling scenario
 * @private
 */


IteratingDataProviderContentHandler.prototype._appendLoadingIndicator = function () {
  // check if it's already added
  if (this.m_loadingIndicator != null) {
    return;
  }

  if (this.isSkeletonSupport() && this.isCardLayout() && this._getCardDimension().width === 0) {
    var self = this;
    var busyContext = Context.getContext(this.m_root).getBusyContext();
    busyContext.whenReady().then(function () {
      self._doAppendLoadingIndicator();
    });
  } else {
    this._doAppendLoadingIndicator();
  }
};

IteratingDataProviderContentHandler.prototype._doAppendLoadingIndicator = function () {
  // for the card layout case, we might need to fill empty space in the last row with skeletons
  if (this.isSkeletonSupport() && this.isCardLayout()) {
    this._fillEmptySpaceWithSkeletons();
  }

  var loadMoreIndicator = this.isSkeletonSupport() ? this._createLoadMoreSkeletons() : this._createLoadMoreIcon();
  this.m_root.appendChild(loadMoreIndicator); // @HTMLUpdateOK

  this.m_loadingIndicator = $(loadMoreIndicator);
};
/**
 * Remove the loading indicator
 * @private
 */


IteratingDataProviderContentHandler.prototype._removeLoadingIndicator = function () {
  if (this.m_loadingIndicator != null) {
    this.m_loadingIndicator.remove();
  }

  this.m_loadingIndicator = null;

  if (this.m_fillerSkeletons != null) {
    this.m_fillerSkeletons.remove();
  }

  this.m_fillerSkeletons = null;
};
/**
 * Whether there are more items to fetch when scroll policy loadMoreOnScroll is used.
 * @return {boolean} true if there are more items to fetch, false otherwise.
 * @protected
 */


IteratingDataProviderContentHandler.prototype.hasMoreToFetch = function () {
  return this.m_loadingIndicator != null;
};
/**
 * Add required attributes to item after it is rendered by the renderer
 * @param {Element} item the item element to modify
 * @param {Object} context the item context
 * @protected
 */


IteratingDataProviderContentHandler.prototype.afterRenderItem = function (item, context, isCustomizeItem) {
  IteratingDataProviderContentHandler.superclass.afterRenderItem.call(this, item, context, isCustomizeItem);
  $(item).addClass(this.m_widget.getItemStyleClass()); // if item root (<LI>) is not specified, add a default layout class if it's supported

  if (!isCustomizeItem && this.m_widget.getItemLayoutStyleClass) {
    item.classList.add(this.m_widget.getItemLayoutStyleClass());
  }

  if (this.isSelectionEnabled() && this.isSelectable(context)) {
    this.m_widget.getFocusItem($(item)).attr('aria-selected', false);
  } // for high-water mark scrolling, we'll need to add additional wai-aria attribute since not
  // all items are in the DOM


  if (this._isLoadMoreOnScroll()) {
    $(item).attr('aria-rowindex', context.index + 1);
  }

  this.m_widget.itemRenderComplete(item, context);
};
/**
 * Callback handler max fetch count.
 * @private
 */


IteratingDataProviderContentHandler.prototype._handleScrollerMaxRowCount = function () {
  // TODO: use resource bundle
  Logger.error('max count reached');
};
/**
 * Empty out root element and create any necessary artifacts before rendering items
 * @private
 */


IteratingDataProviderContentHandler.prototype._prepareRootElement = function () {
  // reset root if it was manipulated prior
  if (this.m_superRoot) {
    $(this.m_superRoot).empty();
    this.m_root = this.m_superRoot;
    this.m_superRoot = null;
  } else {
    var skeletonContainer = this.m_root.querySelector('.oj-listview-skeleton-container');

    if (skeletonContainer == null) {
      // empty the root content if skeleton is not supported or not present.
      // if skeleton is supported, the root will be empty out when animation to hide skeletons is completed.
      $(this.m_root).empty();
    }
  }

  if (this.shouldUseGridRole() && this.isCardLayout()) {
    // in card layout, this is going to be a single row, N columns grid
    // so we'll need to wrap all <li> within a row
    var presentation = document.createElement('li');
    presentation.classList.add('oj-listview-group-container');
    var row = document.createElement('ul');
    presentation.appendChild(row); // @HTMLUpdateOK

    $(presentation).attr('role', 'presentation').css('width', '100%');
    $(row).attr('role', 'row').addClass(this.m_widget.getGroupStyleClass());
    this.m_root.appendChild(presentation); // @HTMLUpdateOK

    this.m_superRoot = this.m_root;
    this.m_root = row;
  }
};
/**
 * @private
 */


IteratingDataProviderContentHandler.prototype._setFetching = function (fetching) {
  var root = this.m_superRoot == null ? this.m_root : this.m_superRoot;
  root.setAttribute('aria-busy', fetching);
  this.m_fetching = fetching;
};
/**
 * @param {boolean} forceFetch
 * @override
 */


IteratingDataProviderContentHandler.prototype.fetchRows = function (forceFetch) {
  var offset = 0;
  this.signalTaskStart('fetching rows'); // signal method task start
  // checks if we are already fetching cells

  if (this.IsReady()) {
    var self = this;

    this._setFetching(true);

    IteratingDataProviderContentHandler.superclass.fetchRows.call(this, forceFetch); // initiate loading of template engine, note it will not load it unless a template has been specified

    var enginePromise = this.loadTemplateEngine(); // signal fetch started. Ends in fetchEnd() if successful. Otherwise, ends in the reject block of promise below right after _handleFetchError().
    // Cannot end in _handleFetchError() to be consistent with pagingTableDataSource behavior (see comment above)

    this.signalTaskStart('first fetch'); // Create a clientId symbol that uniquely identify this consumer so that
    // DataProvider which supports it can optimize resources

    this._clientId = this._clientId || Symbol();
    var options = {
      clientId: this._clientId
    }; // use fetch size if loadMoreOnScroll, otherwise specify -1 to fetch all rows

    options.size = this._isLoadMoreOnScroll() ? this._getFetchSize() : -1;
    this.m_dataProviderAsyncIterator = this.getDataProvider().fetchFirst(options)[Symbol.asyncIterator]();
    var promise = this.m_dataProviderAsyncIterator.next();
    self.fetchSize = options.size; // new helper function to be called in recursion to fetch all data.

    var helperFunction = function helperFunction(values) {
      // skip additional fetching if done, or if fetchSize is not -1.
      // if it has getPageCount method, it is a pagingTableDataSource so skip this fetch process.
      if (values[0].done || self.fetchSize !== -1 || typeof self.getDataProvider().getPageCount === 'function') {
        return values;
      }

      var nextPromise = self.m_dataProviderAsyncIterator.next();
      var fetchMoreData = nextPromise.then(function (value) {
        // eslint-disable-next-line no-param-reassign
        values[0].done = value.done; // eslint-disable-next-line no-param-reassign

        values[0].value.data = values[0].value.data.concat(value.value.data); // eslint-disable-next-line no-param-reassign

        values[0].value.metadata = values[0].value.metadata.concat(value.value.metadata);
        return helperFunction(values);
      }, function (reason) {
        self._handleFetchError(reason);

        self.signalTaskEnd(); // signal fetch stopped. Started above.
      });
      return fetchMoreData;
    };

    Promise.all([promise, enginePromise]).then(function (values) {
      return helperFunction(values);
    }, function (reason) {
      self._handleFetchError(reason);

      self.signalTaskEnd(); // signal fetch stopped. Started above.
    }).then(function (values) {
      // if not fetching, stop b/c fetch error happened earlier
      // Previous _handleFetchError will pass the reason value into
      // values for this then call, so ignore if m_fetching is false.
      if (self.m_fetching) {
        // check if content handler has been destroyed already
        if (self.m_widget == null) {
          return;
        }

        var value = values[0];
        var templateEngine = values[1];
        var dataProvider = self.getDataProvider();

        if (oj.TableDataSourceAdapter && dataProvider instanceof oj.TableDataSourceAdapter) {
          // paging control loadMore mode, offset will not be 0 after first fetch
          offset = dataProvider.offset;
        }

        if (offset === 0) {
          if (templateEngine) {
            // clean nodes generated by templateengine before
            self.cleanItems(templateEngine);
          }

          if (self.isSkeletonSupport()) {
            // should not wait to call this so that the timer gets clear
            self.m_widget.hideStatusText();
          } // empty content now that we have data


          self._prepareRootElement();
        } // append loading indicator at the end as needed


        self._handleFetchedData(value, templateEngine, offset === 0);
      }
    }, function (reason) {
      self._handleFetchError(reason);

      self.signalTaskEnd(); // signal fetch stopped. Started above.
    });
    this.signalTaskEnd(); // signal method task end

    return;
  }

  this.signalTaskEnd(); // signal method task end
};

IteratingDataProviderContentHandler.prototype._handleFetchError = function (msg) {
  // TableDataSource aren't giving me any error message
  Logger.error(msg); // turn off fetching if there is an error

  this._setFetching(false); // listview might have been destroyed before fetch error is handled


  if (this.m_widget == null) {
    Logger.info('handleFetchError: widget has already been destroyed');
    return;
  }

  if (this._isLoadMoreOnScroll()) {
    this._removeLoadingIndicator();
  }

  this.m_widget.renderComplete();
};
/**
 * Renders items when browser is idle (if not support, then fallback to requestAnimationFrame)
 * @private
 */


IteratingDataProviderContentHandler.prototype._renderItemsWhenIdle = function (data, keys, index, templateEngine, isMouseWheel, metadata) {
  var self = this;

  if (data.length === 0 || keys.length === 0) {
    window.requestAnimationFrame(function () {
      // idle callback might have been cancelled
      if (self.m_idleCallback) {
        self._appendLoadingIndicator();

        self.afterItemsInserted();
        self.signalTaskEnd(); // started in initial renderItemsWhenIdle call
      }

      self.m_idleCallback = null;
    });
    return;
  }

  function addFragmentOnRequestAnimationFrame(fragment) {
    window.requestAnimationFrame(function () {
      // need the check here since listview might have been destroyed before idleCallback is cancelled
      if (self.m_widget != null) {
        self.m_root.appendChild(fragment); // @HTMLUpdateOK
      } // schedule next idle callback until all items from the current fetch are rendered


      self._renderItemsWhenIdle(data, keys, index, templateEngine, isMouseWheel, metadata);
    });
  } // IE/Edge/Safari do not support requestIdleCallback, use requestAnimationFrame as fall back
  // also Chrome has an issue with requestIdleCallback when mouse wheel is used, see Chrome :
  // https://bugs.chromium.org/p/chromium/issues/detail?id=822269


  if (isMouseWheel || !window.requestIdleCallback || !window.cancelIdleCallback) {
    this.m_idleCallback = window.requestAnimationFrame(function () {
      var fragment = document.createDocumentFragment();
      var oneData = data.shift();
      var oneMetadata = metadata != null ? metadata.shift() : null;
      var oneKey = keys.shift();
      self.addItem(fragment, -1, oneData, self.getMetadata(index, oneKey, oneData), templateEngine, null, oneMetadata); // eslint-disable-next-line no-param-reassign

      index += 1;
      addFragmentOnRequestAnimationFrame(fragment);
    });
  } else {
    this.m_idleCallback = window.requestIdleCallback(function (idleDeadline) {
      // no need to check for whether listview has been destroyed yet since we cancel the callback on destroy
      var timeRemaining = idleDeadline.timeRemaining();
      var lastTimeTaken = 0;
      var fragment = document.createDocumentFragment();

      while (timeRemaining > lastTimeTaken) {
        if (data.length === 0 || keys.length === 0) {
          break;
        }

        var oneData = data.shift();
        var oneMetadata = metadata != null ? metadata.shift() : null;
        var oneKey = keys.shift();
        self.addItem(fragment, -1, oneData, self.getMetadata(index, oneKey, oneData), templateEngine, null, oneMetadata); // eslint-disable-next-line no-param-reassign

        index += 1;
        lastTimeTaken = timeRemaining - idleDeadline.timeRemaining();
        timeRemaining = idleDeadline.timeRemaining();
      }

      addFragmentOnRequestAnimationFrame(fragment);
    });
  }
};
/**
 * Checks whether content is overflowed
 * @private
 */


IteratingDataProviderContentHandler.prototype._isOverflow = function () {
  return this._isLoadMoreOnScroll() && this.m_domScroller && this.m_domScroller.isOverflow();
};
/**
 * Callback for handling fetch success
 * @param {Array} data the array of data
 * @param {Array} keys the array of keys
 * @param {boolean} doneOrMaxLimitReached true if there are no more data or max count limit reached, false otherwise
 * @param {Object} templateEngine the template engine to process inline template
 * @return {boolean} true if items are rendered when idle, false otherwise
 * @return {Promise} a promise that resolves to true to skip post processing, and false otherwise
 * @private
 */


IteratingDataProviderContentHandler.prototype._handleFetchSuccess = function (data, keys, doneOrMaxLimitReached, templateEngine, isMouseWheel, metadata, isInitialFetch) {
  // listview might have been destroyed before fetch success is handled
  if (this.m_widget == null) {
    return Promise.resolve(true);
  }

  var index = this.m_root.childElementCount;

  if (index > 0 && !doneOrMaxLimitReached && this._isOverflow() && this.m_widget.m_scrollPosition == null) {
    // clone the data since we are going to manipulate the array
    // just in case the DataProvider returns something that references internal structure
    this.signalTaskStart('render items during idle time'); // signal task start

    var metadataCopy = metadata != null ? metadata.slice(0) : null;

    this._renderItemsWhenIdle(data.slice(0), keys.slice(0), index, templateEngine, isMouseWheel, metadataCopy);

    return Promise.resolve(true);
  }

  var parent = document.createDocumentFragment();

  for (var i = 0; i < data.length; i++) {
    var row = data[i]; // passing -1 for opt since we know it will be inserted at the end of the parent

    this.addItem(parent, -1, row, this.getMetadata(index, keys[i], row), templateEngine, null, metadata != null ? metadata[i] : null);
    index += 1;
  }

  return this.animateShowContent(this.m_root, parent, isInitialFetch);
};
/**
 * Handles fetched data initiated by the DomScroller (scroll and fetch, or checkViewport)
 * @protected
 */


IteratingDataProviderContentHandler.prototype.handleDomScrollerFetchedData = function (result) {
  if (result != null) {
    this.signalTaskStart('handle results from DomScroller'); // signal task start
    // remove any loading indicator, which is always added to the end after fetch

    this._removeLoadingIndicator();

    if (this.IsReady()) {
      this.signalTaskStart('dummy task'); // start a dummy task to be paired with the fetchEnd() call below if no new data were fetched.
    }

    this._handleFetchedData(result, this.getTemplateEngine(), false); // will call fetchEnd(), which signals a task end. Started either in fetchRows() or in a dummy task not involving data fetch.


    if (result.value && result.value.data) {
      this.m_widget.updateStatusFetchEnd(result.value.data.length);
    } // reset cached scroll height


    this.m_widget.m_scrollHeight = null;
    this.signalTaskEnd(); // signal domscroller fetch end. Started in beforeFetch callback below

    this.signalTaskEnd(); // signal task end
  } else {
    // when there's no more data or any other unexpected cases
    this._removeLoadingIndicator();

    this.signalTaskEnd(); // signal domscroller fetch end. Started in beforeFetch callback below
  }
};
/**
 * Register the DomScroller
 * @private
 */


IteratingDataProviderContentHandler.prototype._registerDomScroller = function () {
  var self = this;
  var options = {
    fetchSize: this._getFetchSize(),
    fetchTrigger: this._getFetchTrigger(),
    maxCount: this._getMaxCount(),
    asyncIterator: this.m_dataProviderAsyncIterator,
    initialRowCount: this.m_root.childElementCount,
    success: function success(result) {
      self.handleDomScrollerFetchedData(result);

      if (self.m_root == null || result.value == null) {
        // in this case fetchEnd will not be called so we will need to clean up for signalTaskStart in scrollFetch callback
        self.signalTaskEnd();

        if (self.m_root != null) {
          // this is called as part of fetchEnd, see 
          self.m_widget.renderComplete();
        }
      }
    },
    error: this.signalTaskEnd.bind(this),
    localKeyValidator: function localKeyValidator(key) {
      if (self.m_widget) {
        return self.m_widget.FindElementByKey(key) != null;
      }

      return false;
    },
    beforeFetch: function beforeFetch() {
      self.handleBeforeFetch();
      self.m_viewportCheckPromise = null;

      if (self.m_idleCallback != null) {
        return false;
      }

      self.m_widget.updateStatusFetchStart();
      self.signalTaskStart('starts high-water mark scrolling'); // signal domscroller data fetching. Ends either in success call (m_domScrollerMaxCountFunc) or in error call (self.signalTaskEnd)

      return true;
    }
  };
  this.m_domScroller = new DomScroller(this._getScroller(), this.getDataProvider(), options);
};

IteratingDataProviderContentHandler.prototype.handleBeforeFetch = function () {};

IteratingDataProviderContentHandler.prototype._clearEventQueue = function () {
  if (this.m_eventQueue != null) {
    this.m_eventQueue.length = 0;
  }
};
/**
 * Retrieve the index of the item with the specified key
 * @private
 */


IteratingDataProviderContentHandler.prototype._getIndex = function (keys, index) {
  if (keys == null || keys.length === 0 || index >= keys.length) {
    return -1;
  }

  var key = keys[index];
  var elem = this.FindElementByKey(key);
  return elem != null ? $(this.m_root).children().index(elem) : -1;
};
/**
 * Returns the insert before element given the index, or null if insert at the end.
 * @return {Element|null} the reference element.
 * @protected
 * @override
 */


IteratingDataProviderContentHandler.prototype.GetReferenceNode = function (parentElement, index) {
  var referenceNode = IteratingDataProviderContentHandler.superclass.GetReferenceNode.call(this, parentElement, index);

  if (referenceNode == null && this.m_loadingIndicator != null) {
    return this.m_loadingIndicator.get(0);
  }

  return referenceNode;
};
/**
 * Gets the maximum index for insert event
 * @private
 */


IteratingDataProviderContentHandler.prototype._getMaxIndexForInsert = function () {
  var max = Number.MAX_VALUE; // only care about child count if there's more to fetch

  if (this._isLoadMoreOnScroll() && this.hasMoreToFetch()) {
    max = $(this.m_root).children('li.' + this.m_widget.getItemElementStyleClass()).length;
  }

  return max;
};
/**
 * Do the actual adding items to DOM based on model insert event
 * @protected
 */


IteratingDataProviderContentHandler.prototype.addItemsForModelInsert = function (data, indexes, keys, parentKeys, isBeforeKeys, refKeys, metadata) {
  // index to determine whether it's outside of range of not
  var max = this._getMaxIndexForInsert(); // template engine should have already been loaded


  var templateEngine = this.getTemplateEngine();
  var itemsInserted = 0;

  for (var i = 0; i < data.length; i++) {
    this.signalTaskStart('handling model add event for item: ' + keys[i]); // signal add item start
    // indexes takes precedence

    var index;

    if (indexes != null) {
      index = indexes[i];
    } else {
      index = this._getIndex(refKeys, i);

      if (index > -1) {
        index = isBeforeKeys ? index : index + 1;
      } else if (this._isLoadMoreOnScroll() && this.hasMoreToFetch()) {
        // if append to the end but not everything has been fetched yet
        index = max;
      }
    } // we skip any insert/append outside of range if there's still more to fetch


    if (index < max) {
      this.addItem(this.m_root, index, data[i], this.getMetadata(index, keys[i], data[i]), templateEngine, this.afterRenderItemForInsertEvent.bind(this), metadata != null ? metadata[i] : null);
      itemsInserted += 1;
    }

    this.signalTaskEnd(); // signal add item end
  } // everything is outside of range, suppress empty text


  if (data.length > 0 && itemsInserted === 0 && this.m_widget._isEmpty()) {
    var dummyElem = document.createElement('li');
    dummyElem.classList.add('oj-listview-temp-item');
    dummyElem.style.display = 'none';
    this.m_root.appendChild(dummyElem);
  }

  if (this.IsReady()) {
    this.signalTaskStart('dummy task'); // start a dummy task to be paired with the fetchEnd() call below if no new data were fetched.
  } // do whatever post fetch processing


  this.fetchEnd(false, true); // signals a task end. Started either in fetchRows() or in a dummy task not involving data fetch.
};

IteratingDataProviderContentHandler.prototype.handleModelRemoveEvent = function (event) {
  IteratingDataProviderContentHandler.superclass.handleModelRemoveEvent.call(this, event);
  var remainingItem = this.m_root.querySelector('li.' + this.m_widget.getItemElementStyleClass());

  if (remainingItem == null && this.m_loadingIndicator) {
    this.m_loadingIndicator.get(0).style.display = 'none';
  }
};
/**
 * Model refresh event handler.  Called when all rows has been removed from the underlying data.
 * @param {Object} event the model refresh event
 * @private
 */


IteratingDataProviderContentHandler.prototype.handleModelRefreshEvent = function (event) {
  if (this.m_root == null) {
    return;
  } // any outstanding idle-time rendering should immediately be stopped


  this._cancelIdleCallback(); // if listview is busy, hold that off until later, the refresh must be handled in order
  // since we don't know when the results are coming back in


  if (!this.IsReady()) {
    this._pushToEventQueue({
      type: event.type,
      event: event
    });

    return;
  }

  this.signalTaskStart('handling model reset event'); // signal method task start
  // since we are refetching everything, we should just clear out any outstanding model events

  this._clearEventQueue(); // empty everything (later) and clear cache (including KeyMap)


  this.m_widget.ClearCache(true); // it will be recreated with a new asyncIterator

  this._destroyDomScroller(); // handle scrollPositionPolicy on refresh


  if (this.m_widget.adjustScrollPositionValueOnRefresh) {
    this.m_widget.adjustScrollPositionValueOnRefresh();
  } // reset focus if needed


  this.m_widget.resetFocusBeforeRefresh(); // fetch data

  this.fetchRows(true);
  this.signalTaskEnd(); // signal method task end
};
/**
 * Handle fetched data, either from a fetch call or from a sync event
 * @param {Object} dataObj the fetched data object
 * @private
 */


IteratingDataProviderContentHandler.prototype._handleFetchedData = function (dataObj, templateEngine, isInitialFetch) {
  // this could happen if destroy comes before fetch completes (note a refresh also causes destroy)
  if (this.m_root == null || dataObj.value == null) {
    return;
  }

  var data = dataObj.value.data;
  var keys = dataObj.value.metadata.map(function (value) {
    return value.key;
  });
  var metadata = dataObj.value.metadata;

  if (data.length === keys.length) {
    this._handleFetchSuccess(data, keys, dataObj.done || dataObj.maxCountLimit, templateEngine, dataObj.isMouseWheel, metadata, isInitialFetch).then(function (skipPostProcessing) {
      var nothingInserted = keys != null && keys.length === 0;

      if (this._isLoadMoreOnScroll()) {
        if (!dataObj.done) {
          // if number of items returned is zero but result indicates it's not done
          // log it
          if (nothingInserted) {
            Logger.info('handleFetchedData: zero data returned while done flag is false');
          } // always append the loading indicator at the end except the case when max limit has been reached


          if (!skipPostProcessing && !dataObj.maxCountLimit) {
            if (this.m_domScroller == null) {
              this._registerDomScroller(); // in Safari, handleResize would not get invoked with the initial width/height
              // call getRootElementHeight method to trigger height caching


              this.getRootElementHeight();
            }

            if (!nothingInserted || this.m_domScroller.isOverflow()) {
              this._appendLoadingIndicator();
            }
          }
        }
      }

      if (dataObj.maxCountLimit) {
        this._handleScrollerMaxRowCount();
      }

      this.fetchEnd(skipPostProcessing, !nothingInserted || !dataObj.done); // disable tabbable elements once the fetched items are rendered

      this.disableAllTabbableElements();
    }.bind(this));
  }
};

IteratingDataProviderContentHandler.prototype.disableAllTabbableElements = function () {
  var lastItemIndex = this.m_root.childElementCount;

  if (this.m_root.lastElementChild && this.m_root.lastElementChild.getAttribute('role') === 'presentation') {
    lastItemIndex -= 1;
  }

  var self = this;
  var busyContext = Context.getContext(this.m_root).getBusyContext();
  busyContext.whenReady().then(function () {
    if (self.m_root != null) {
      var children = self.m_root.children;

      for (var i = lastItemIndex; i < children.length; i++) {
        self.m_widget.disableAllTabbableElements(children[i]);
      }
    }
  });
};
/**
 * Do any logic after items are inserted into the DOM
 * @private
 */


IteratingDataProviderContentHandler.prototype.afterItemsInserted = function (checkViewport) {
  if (this.m_widget) {
    this.m_widget.renderComplete(); // process any outstanding events

    this._processEventQueue(); // check viewport


    if (checkViewport) {
      if (this.m_widget.ojContext._IsCustomElement()) {
        // for custom element, content could render async so we'll need to wait for content to render completely
        // so that we have the correct height before checking viewport.  For example, we want to avoid excessive
        // fetch if the height expanded which causes overflow.  On the other hand, if the height contracted then
        // we could potentially have an underflow that requires an additional fetch.
        var self = this;
        var busyContext = Context.getContext(self.m_root).getBusyContext();
        var viewportCheckPromise = busyContext.whenReady();
        viewportCheckPromise.then(function () {
          if (self.m_viewportCheckPromise != null) {
            self.checkViewport();
          }
        });
        self.m_viewportCheckPromise = viewportCheckPromise;
      } else {
        // for widget, we'll need to keep the old behavior
        this.checkViewport();
      }
    }
  }
};
/**
 * Invoke after a set of items are removed
 * @protected
 */


IteratingDataProviderContentHandler.prototype.afterItemsRemoved = function () {
  if (this.m_widget) {
    this.checkViewport();
  }
};
/**
 * Do any logic needed after results from fetch are processed
 * @private
 */


IteratingDataProviderContentHandler.prototype.fetchEnd = function (skipPostProcessing, checkViewport) {
  // fetch is done
  this._setFetching(false);

  if (!skipPostProcessing) {
    this.afterItemsInserted(checkViewport);
  } // signal fetch end. Started in either fetchRows() or started as a dummy task whenever this
  // method is called without fetching rows first (e.g. see m_domScrollerMaxCountFunc).


  this.signalTaskEnd();
};
/**
 * Checks the viewport for card layout case
 * @private
 */


IteratingDataProviderContentHandler.prototype._checkHorizontalViewport = function () {
  if (this.isCardLayout()) {
    var items = this.m_root.children;
    var styleClass = this.m_widget.getItemElementStyleClass();
    var lastItem;

    for (var i = items.length - 1; i >= 0; i--) {
      if (items[i].classList.contains(styleClass)) {
        lastItem = items[i];
        break;
      }
    }

    if (lastItem) {
      var scroller = this._getScroller();

      var offsetHeight = scroller === this.m_root ? this.getRootElementHeight() : scroller.offsetHeight;
      var scrollTop = scroller.scrollTop;
      var offsetTop = lastItem.offsetTop;

      if (offsetTop > scrollTop && offsetTop < scrollTop + offsetHeight) {
        return this.m_domScroller._fetchMoreRows();
      }
    }
  }

  return null;
};
/**
 * Checks the viewport to see if additional fetch is needed
 * @protected
 */


IteratingDataProviderContentHandler.prototype.checkViewport = function () {
  var self = this; // if we are already in the process of fetch due to checkViewport, bail

  if (this.m_checkViewportPromise) {
    return null;
  }

  this.signalTaskStart('checking viewport'); // signal method task start
  // if loadMoreOnScroll then check if we have underflow and do a fetch if we do

  var fetchPromise;

  if (this.m_domScroller != null && this.IsReady()) {
    fetchPromise = this.m_domScroller.checkViewport();

    if (fetchPromise != null) {
      this.signalTaskStart('got promise from checking viewport'); // signal fetchPromise started. Ends in promise resolution below

      fetchPromise.then(function (result) {
        // make sure listview is not destroyed yet
        if (self.m_widget != null) {
          if (result != null) {
            self.m_checkViewportPromise = null;
            self.handleDomScrollerFetchedData(result);
          } else {
            fetchPromise = self._checkHorizontalViewport();

            if (fetchPromise != null) {
              self.signalTaskStart('got promise from checking horizontal viewport');
              fetchPromise.then(function (moreResult) {
                self.m_checkViewportPromise = null;

                if (self.m_widget != null && moreResult != null) {
                  self.handleDomScrollerFetchedData(moreResult);
                }

                self.signalTaskEnd();
              }, null);
            } else {
              self.m_checkViewportPromise = null;
            }
          }

          self.signalTaskEnd(); // signal checkViewport task end. Started above before fetchPromise resolves here;
        }
      }, null);
    }

    this.m_checkViewportPromise = fetchPromise;
  }

  this.signalTaskEnd(); // signal method task end

  return fetchPromise;
};

;return {
  'DataProviderContentHandler': DataProviderContentHandler,
  'IteratingDataProviderContentHandler': IteratingDataProviderContentHandler
};
});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojkeysetimpl',['ojs/ojcore'], function(oj)
{
  "use strict";


/* global Set:false, Symbol:false */

/**
 * Contains all the core functionalities of KeySet.
 * @param {(Set|Array)=} keys A set of keys to initialize this KeySet with.
 *
 * @ignore
 * @ojtsignore
 * @export
 * @class KeySetImpl
 * @constructor
 * @since 5.1.0
 */
// eslint-disable-next-line no-unused-vars
var KeySetImpl = function KeySetImpl(initialValues) {
  this.NOT_A_KEY = {};
  /**
   * Returns whether the specified key is contained in this set.
   * @private
   * @param {any} key the key to check whether it is contained in this set.
   * @return {boolean} true if the specified key is contained in this set, false otherwise.
   */

  this.has = function (key) {
    return this.get(key) !== this.NOT_A_KEY;
  };
  /**
   * Finds the equavalent key of the specified key within this KeySet.
   * @private
   * @param {any} keyToFind the key to find
   * @return {any} the key in the key that is equivalent to keyToFind, or NO_KEY if nothing equivalent can be found.
   */


  this.get = function (keyToFind) {
    var iterator;
    var key;
    var found = this.NOT_A_KEY;
    var self = this;

    if (this._keys.has(keyToFind)) {
      return keyToFind;
    } // if it's a primitive, then we are done also


    if (!(keyToFind === Object(keyToFind))) {
      return this.NOT_A_KEY;
    } // using iterator if it's supported since we could break at any time


    if (typeof Symbol === 'function' && typeof Set.prototype[Symbol.iterator] === 'function') {
      iterator = this._keys[Symbol.iterator]();
      key = iterator.next();

      while (!key.done) {
        if (oj.KeyUtils.equals(key.value, keyToFind)) {
          return key.value;
        }

        key = iterator.next();
      }
    } else {
      // IE11 supports forEach
      this._keys.forEach(function (_key) {
        if (found === self.NOT_A_KEY && oj.KeyUtils.equals(_key, keyToFind)) {
          found = _key;
        }
      });
    }

    return found;
  };
  /**
   * Initialize the internal Set with a set of keys.
   * @private
   * @param {Set|Array|null|undefined} keys the initial keys to create the internal Set with.
   */


  this.InitializeWithKeys = function (keys) {
    this._keys = new Set(keys);
  };

  this.InitializeWithKeys(initialValues);
};

;return KeySetImpl;
});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojkeyset',['ojs/ojcore', 'ojs/ojkeysetimpl'], function(oj, KeySetImpl)
{
  "use strict";


/* global KeySetImpl:false, Set:false */

/**
 * An immutable set of keys.
 * @class KeySet
 *
 * @classdesc The base class for KeySetImpl and AllKeySetImpl.  Represents an immutable set of keys.
 * @constructor
 * @hideconstructor
 * @abstract
 * @since 4.1.0
 * @ojsignature {target: "Type", value: "abstract class KeySet<K>", genericParameters: [{"name": "K", "description": "Type of Key"}]}
 */
var KeySet = function KeySet() {}; // Subclass from oj.Object


oj.Object.createSubclass(KeySet, oj.Object, 'KeySet'); // make it available internally

oj.KeySet = KeySet;
/**
 * Sets the internal Set object.
 *
 * @param {Set} set the internal Set object to replace with.
 * @protected
 */

KeySet.prototype.SetInternal = function (set) {
  this._keys = set;
};
/**
 * Returns a new KeySet based on this set with the specified keys included.
 *
 * @param {Set|Array} keys a set of keys to add to this KeySet.
 * @return {KeySet} a new KeySet with the specified keys included.
 * @method
 * @name add
 * @memberof KeySet
 * @instance
 * @abstract
 * @ojsignature {target: "Type", value: "(keys: Set<K>|Array<K>): KeySet<K>"}
 */

/**
 * Returns a new KeySet that signals all keys are added to this set.
 *
 * @return {KeySet} a new KeySet that signals all keys are added to this set.
 * @method
 * @name addAll
 * @memberof KeySet
 * @instance
 * @abstract
 * @ojsignature {target: "Type", value: "(): KeySet<K>"}
 */

/**
 * Returns a new KeySet based on this set with the specified keys excluded.
 *
 * @param {Set|Array} keys a set of keys to remove from this KeySet.
 * @return {KeySet} a new KeySet with the specified keys excluded.
 * @method
 * @name delete
 * @memberof KeySet
 * @instance
 * @abstract
 * @ojsignature {target: "Type", value: "(keys: Set<K>|Array<K>): KeySet<K>"}
 */

/**
 * Returns whether this set should include all keys.
 *
 * @return {boolean} true if this set should include all keys, false otherwise.
 * @method
 * @name isAddAll
 * @memberof KeySet
 * @instance
 * @abstract
 */

/**
 * Returns whether the specified key is contained in this set.
 *
 * @param {any} key the key to check whether it is contained in this set.
 * @return {boolean} true if the specified key is contained in this set, false otherwise.
 * @method
 * @name has
 * @memberof KeySet
 * @instance
 * @abstract
 * @ojsignature {target: "Type", value: "K", for: "key"}
 */

/**
 * Returns a new KeySet containing no keys.
 *
 * @return {KeySet} a new KeySet with no keys.
 * @method
 * @name clear
 * @memberof KeySet
 * @instance
 * @abstract
 * @ojsignature {target: "Type", value: "(): KeySet<K>"}
 */

/**
 * Adds or deletes a set of keys from the internal Set object.
 * @param {boolean} isAdd true if add operation, false if delete operation
 * @param {Set|Array} keys keys to add or delete
 * @return {KeySet} returns current KeySet if add or delete is not performed, or a new KeySet with the
 *                     specified keys included (add) or excluded (delete).
 * @protected
 */


KeySet.prototype.AddOrDeleteInternal = function (isAdd, keys) {
  var newSet;
  var keySet;
  newSet = isAdd ? this._add(keys) : this._remove(keys);

  if (newSet == null) {
    return this;
  }

  keySet =
  /** @type {KeySet} */
  Object.create(Object.getPrototypeOf(this));
  keySet.SetInternal(newSet);
  return keySet;
};
/**
 * Adds the specified keys to the internal Set object.
 * @param {Set|Array} keys a set of keys to add
 * @return {Set} a new Set based on this internal Set with the specified keys appended to the end, or null if nothing was added.
 * @private
 */


KeySet.prototype._add = function (keys) {
  var self = this;
  var newSet = null;
  keys.forEach(function (key) {
    // checks if it's already contained in the Set, can't use has() since it does a reference comparison
    if (key !== self.NOT_A_KEY && self.get(key) === self.NOT_A_KEY) {
      if (newSet == null) {
        newSet = self.Clone();
      }

      newSet.add(key);
    }
  });
  return newSet;
};
/**
 * Helper method to remove the specified keys from its set
 * @param {Set|Array} keys an interable set of keys to remove
 * @return {Set|null} a new Set based on this internal Set with the keys removed, or null if nothing is removed.
 * @private
 */


KeySet.prototype._remove = function (keys) {
  var self = this;
  var newSet = null;
  var keyToDelete; // first check if there's anything to remove

  if (this._keys.size === 0) {
    return null;
  }

  keys.forEach(function (key) {
    // see if we can find a equivalent key in this Set since delete does a reference comparison to find the item to delete
    keyToDelete = self.get(key);

    if (keyToDelete !== self.NOT_A_KEY) {
      if (newSet == null) {
        newSet = self.Clone();
      }

      newSet.delete(keyToDelete);
    }
  });
  return newSet;
};
/**
 * Returns the size of this Set.
 * @return {number} the size of this Set.
 * @protected
 */


KeySet.prototype.GetInternalSize = function () {
  return this._keys.size;
};
/**
 * Return a clone of the internal Set
 * @return {Set} the clone of the internal Set
 * @protected
 */


KeySet.prototype.Clone = function () {
  return new Set(this._keys);
};

KeySetImpl.call(KeySet.prototype);



/* global KeySet:false, ExpandAllKeySet:false */

/**
 * Create a new immutable KeySet containing the keys of the expanded items.
 * Use this KeySet when specifying individual keys to expand.
 *
 * @param {(Set|Array)=} keys A set of keys to initialize this KeySet with.
 *
 * @class ExpandedKeySet
 * @classdesc The ExpandedKeySet class contains a set of keys of the expanded items.  See
 * also the <a href="ObservableExpandedKeySet.html">observable</a> version of this class.
 * @extends {KeySet}
 * @constructor
 * @final
 * @since 4.1.0
 * @ojdeprecated {since: '7.0.0', description: 'Use KeySetImpl instead.'}
 * @ojsignature [{target: "Type", value: "class ExpandedKeySet<K> extends KeySet<K>", genericParameters: [{"name": "K", "description": "Type of Key"}]},
 *               {target: "Type", value: "Set<K>|Array<K>", for:"keys"}]
 * @example <caption>Creates a new ExpandedKeySet with an initial set of keys to expand:</caption>
 * require(['ojs/ojkeyset'],
 *   function(keySet) {
 *     var expandedKeySet = new keySet.ExpandedKeySet(['group1', 'group3']);
 *   }
 * );
 */
var ExpandedKeySet = function ExpandedKeySet(keys) {
  this.InitializeWithKeys(keys);
}; // Subclass from KeySet


oj.Object.createSubclass(ExpandedKeySet, KeySet, 'ExpandedKeySet'); // make it available internally

oj.ExpandedKeySet = ExpandedKeySet;
/**
 * Returns a new KeySet based on this set with the specified keys included.
 * If none of the keys specified are added then this KeySet is returned.
 *
 * @param {Set|Array} keys a set of keys to add to this KeySet.
 * @return {ExpandedKeySet} a new KeySet with the specified keys included.
 * @expose
 * @instance
 * @alias add
 * @memberof ExpandedKeySet
 * @ojsignature {target: "Type", value: "(keys: Set<K>|Array<K>): ExpandedKeySet<K>"}
 */

ExpandedKeySet.prototype.add = function (keys) {
  return (
    /** @type {!ExpandedKeySet} */
    this.AddOrDeleteInternal(true, keys)
  );
};
/**
 * Returns a new KeySet that signals all keys are added to this set.
 *
 * @return {ExpandAllKeySet} a new KeySet that signals all keys are added to this set.
 * @expose
 * @instance
 * @alias addAll
 * @memberof ExpandedKeySet
 * @ojsignature {target: "Type", value: "(): ExpandAllKeySet<K>"}
 */


ExpandedKeySet.prototype.addAll = function () {
  return new ExpandAllKeySet();
};
/**
 * Returns whether this set should include all keys.
 *
 * @return {boolean} true if this set includes all keys, false otherwise.
 * @expose
 * @instance
 * @alias isAddAll
 * @memberof ExpandedKeySet
 */


ExpandedKeySet.prototype.isAddAll = function () {
  return false;
};
/**
 * Returns a new KeySet based on this set with the specified keys excluded.
 * If none of the keys specified are deleted then this KeySet is returned.
 *
 * @param {Set|Array} keys a set of keys to remove from this KeySet.
 * @return {ExpandedKeySet} a new KeySet with the specified keys excluded.
 * @expose
 * @instance
 * @alias delete
 * @memberof ExpandedKeySet
 * @ojsignature {target: "Type", value: "(keys: Set<K>|Array<K>): ExpandedKeySet<K>"}
 */


ExpandedKeySet.prototype.delete = function (keys) {
  return (
    /** @type {!ExpandedKeySet} */
    this.AddOrDeleteInternal(false, keys)
  );
};
/**
 * Returns a new KeySet containing no keys.  If this KeySet already contains no keys then
 * the current KeySet is returned.
 *
 * @return {ExpandedKeySet} a new KeySet with no keys.
 * @expose
 * @instance
 * @alias clear
 * @memberof ExpandedKeySet
 * @ojsignature {target: "Type", value: "(): ExpandedKeySet<K>"}
 */


ExpandedKeySet.prototype.clear = function () {
  return this.GetInternalSize() === 0 ? this : new ExpandedKeySet();
};
/**
 * Returns whether the specified key is contained in this set.
 *
 * @param {any} key the key to check whether it is contained in this set.
 * @return {boolean} true if the specified key is contained in this set, false otherwise.
 * @expose
 * @instance
 * @alias has
 * @memberof ExpandedKeySet
 * @ojsignature {target: "Type", value: "K", for:"key"}
 */


ExpandedKeySet.prototype.has = function (key) {
  return this.get(key) !== this.NOT_A_KEY;
};
/**
 * Returns the keys in this KeySet in the order they are added.
 *
 * @return {Set} the keys in this KeySet in the order they are added.
 * @expose
 * @instance
 * @alias values
 * @memberof ExpandedKeySet
 * @ojsignature {target: "Type", value: "Set<K>", for:"returns"}
 */


ExpandedKeySet.prototype.values = function () {
  return this.Clone();
};



/* global KeySet:false, ExpandedKeySet:false */

/**
 * Create a new immutable KeySet containing the keys of the collapsed items.
 * Use this KeySet when expanding all keys.
 *
 *
 * @class ExpandAllKeySet
 * @classdesc The ExpandAllKeySet class represents a set with all keys expanded.
 * @extends {KeySet}
 * @constructor
 * @final
 * @since 4.1.0
 * @ojdeprecated {since: '7.0.0', description: 'Use AllKeySetImpl instead.'}
 * @ojsignature {target: "Type", value: "class ExpandAllKeySet<K> extends KeySet<K>",
 *               genericParameters: [{"name": "K", "description": "Type of Key"}]}
 * @example <caption>Creates a new ExpandAllKeySet to expand all keys</caption>
 * require(['ojs/ojkeyset'],
 *   function(keySet) {
 *     var expandAllKeySet = new keySet.ExpandAllKeySet();
 *   }
 * );
 */
var ExpandAllKeySet = function ExpandAllKeySet() {
  this.InitializeWithKeys(null);
}; // Subclass from KeySet


oj.Object.createSubclass(ExpandAllKeySet, KeySet, 'ExpandAllKeySet'); // make it available internally

oj.ExpandAllKeySet = ExpandAllKeySet;
/**
 * Returns a new KeySet with the specified keys excluded from a set of collapsed keys.
 * If the keys specified are already added then this KeySet is returned.
 *
 * @param {Set|Array} keys a set of keys to add to this KeySet.
 * @return {ExpandAllKeySet} a new KeySet with the specified keys included.
 * @expose
 * @instance
 * @alias add
 * @memberof! ExpandAllKeySet
 * @ojsignature {target: "Type", value: "(keys: Set<K>|Array<K>): ExpandAllKeySet<K>"}
 */

ExpandAllKeySet.prototype.add = function (keys) {
  // add keys on expand all = remove collapsed keys
  return (
    /** @type {!ExpandAllKeySet} */
    this.AddOrDeleteInternal(false, keys)
  );
};
/**
 * Returns a new KeySet that signals all keys are added to this set.  If this KeySet already
 * has all keys added, then this KeySet is returned.
 *
 * @return {ExpandAllKeySet} a new KeySet that signals all keys are added to this set.
 * @expose
 * @instance
 * @alias addAll
 * @memberof! ExpandAllKeySet
 * @ojsignature {target: "Type", value: "(): ExpandAllKeySet<K>"}
 */


ExpandAllKeySet.prototype.addAll = function () {
  return this.GetInternalSize() === 0 ? this : new ExpandAllKeySet();
};
/**
 * Returns whether this set should include all keys.
 *
 * @return {boolean} true if this set includes all keys, false otherwise.
 * @expose
 * @instance
 * @alias isAddAll
 * @memberof! ExpandAllKeySet
 */


ExpandAllKeySet.prototype.isAddAll = function () {
  return true;
};
/**
 * Returns a new KeySet based on this set with the specified keys included in a set of collapsed keys.
 * If the keys specified are already deleted then this KeySet is returned.
 *
 * @param {Set|Array} keys a set of keys to remove from this KeySet.
 * @return {ExpandAllKeySet} a new KeySet with the specified keys excluded.
 * @expose
 * @instance
 * @alias delete
 * @memberof! ExpandAllKeySet
 * @ojsignature {target: "Type", value: "(keys: Set<K>|Array<K>): ExpandAllKeySet<K>"}
 */


ExpandAllKeySet.prototype.delete = function (keys) {
  // remove keys on expand all = add collapsed keys
  return (
    /** @type {!ExpandAllKeySet} */
    this.AddOrDeleteInternal(true, keys)
  );
};
/**
 * Returns a new KeySet containing no keys.
 *
 * @return {ExpandedKeySet} a new KeySet with no keys.
 * @expose
 * @instance
 * @alias clear
 * @memberof! ExpandAllKeySet
 * @ojsignature {target: "Type", value: "(): ExpandedKeySet<K>"}
 */


ExpandAllKeySet.prototype.clear = function () {
  return new ExpandedKeySet();
};
/**
 * Returns whether the specified key is contained in this set.
 *
 * @param {any} key the key to check whether it is contained in this set.
 * @return {boolean} true if the specified key is contained in this set, false otherwise.
 * @expose
 * @instance
 * @alias has
 * @memberof! ExpandAllKeySet
 * @ojsignature {target: "Type", value: "K", for: "key"}
 */


ExpandAllKeySet.prototype.has = function (key) {
  return this.get(key) === this.NOT_A_KEY;
};
/**
 * Returns a set of keys of the collapsed items.
 *
 * @return {Set} the keys of the collapsed items.
 * @expose
 * @instance
 * @alias deletedValues
 * @memberof! ExpandAllKeySet
 * @ojsignature {target: "Type", value: "Set<K>", for: "returns"}
 */


ExpandAllKeySet.prototype.deletedValues = function () {
  return this.Clone();
};



/* global KeySet:false, AllKeySetImpl:false */

/**
 * Create a new immutable KeySet containing the keys of items.
 * Use this KeySet when specifying individual keys to select or expand.
 *
 * @param {(Set|Array)=} keys A set of keys to initialize this KeySet with.
 *
 * @class KeySetImpl
 * @classdesc The KeySetImpl class contains a set of keys of items.
 * @extends {KeySet}
 * @constructor
 * @final
 * @since 7.0.0
 * @ojsignature [{target: "Type", value: "class KeySetImpl<K> extends KeySet<K>", genericParameters: [{"name": "K", "description": "Type of Key"}]},
 *               {target: "Type", value: "Set<K>|Array<K>", for:"keys"}]
 * @example <caption>Creates a new KeySetImpl with an initial set of keys:</caption>
 * require(['ojs/ojkeyset'],
 *   function(keySet) {
 *     var KeySetImpl = new keySet.KeySetImpl(['item1', 'item3']);
 *   }
 * );
 */
var KeySetImpl = function KeySetImpl(keys) {
  this.InitializeWithKeys(keys);
}; // Subclass from KeySet


oj.Object.createSubclass(KeySetImpl, KeySet, 'KeySetImpl'); // make it available internally

oj.KeySetImpl = KeySetImpl;
/**
 * Returns a new KeySet based on this set with the specified keys included.
 * When a key is added to this KeySet it implies the key will become expanded (when this
 * is used for expansion) or selected (when this is used for selection).
 * If none of the keys specified are being added, then it will be a no-op and this KeySet is
 * returned.
 *
 * @param {Set|Array} keys a set of keys to add to this KeySet.
 * @return {KeySetImpl} a new KeySet with the specified keys included.
 * @expose
 * @instance
 * @alias add
 * @memberof KeySetImpl
 * @ojsignature {target: "Type", value: "(keys: Set<K>|Array<K>): KeySetImpl<K>"}
 */

KeySetImpl.prototype.add = function (keys) {
  return (
    /** @type {!KeySetImpl} */
    this.AddOrDeleteInternal(true, keys)
  );
};
/**
 * Returns a new KeySet that represents a set with all keys.  This will return a
 * AllKeySetImpl instance.
 *
 * @return {AllKeySetImpl} a new KeySet that represents a set with all keys.
 * @expose
 * @instance
 * @alias addAll
 * @memberof KeySetImpl
 * @ojsignature {target: "Type", value: "(): AllKeySetImpl<K>"}
 */


KeySetImpl.prototype.addAll = function () {
  return new AllKeySetImpl();
};
/**
 * Determines whether this is a set that represents all keys.  Since this KeySet
 * does not represent all keys, thie method will always return false.
 *
 * @return {boolean} true if this is a set that reprsents all keys, false otherwise.
 * @expose
 * @instance
 * @alias isAddAll
 * @memberof KeySetImpl
 */


KeySetImpl.prototype.isAddAll = function () {
  return false;
};
/**
 * Returns a new KeySet based on this set with the specified keys excluded.
 * When a key is removed from this KeySet it implies the key will become collapsed (when this
 * is used for expansion) or de-selected (when this is used for selection).
 * If none of the keys specified are being deleted, then this KeySet is returned.
 *
 * @param {Set|Array} keys a set of keys to remove from this KeySet.
 * @return {KeySetImpl} a new KeySet with the specified keys excluded.
 * @expose
 * @instance
 * @alias delete
 * @memberof KeySetImpl
 * @ojsignature {target: "Type", value: "(keys: Set<K>|Array<K>): KeySetImpl<K>"}
 */


KeySetImpl.prototype.delete = function (keys) {
  return (
    /** @type {!KeySetImpl} */
    this.AddOrDeleteInternal(false, keys)
  );
};
/**
 * Returns a new KeySet containing no keys.  Specifically, invoking clear will collapse all keys (
 * when this is used for expansion) or clear selection (when this is used for selection).
 * If this KeySet already contains no keys then it is a no-op and the current KeySet is returned.
 *
 * @return {KeySetImpl} a new KeySet with no keys.
 * @expose
 * @instance
 * @alias clear
 * @memberof KeySetImpl
 * @ojsignature {target: "Type", value: "(): KeySetImpl<K>"}
 */


KeySetImpl.prototype.clear = function () {
  return this.GetInternalSize() === 0 ? this : new KeySetImpl();
};
/**
 * Determines whether the specified key is in this set.
 * Specifically, this returns true if the key is expanded (when this is used for expansion)
 * or selected (when this is used for selection), and false otherwise.
 *
 * @param {any} key the key to check whether it is in this set.
 * @return {boolean} true if the specified key is in the set, false otherwise.
 * @expose
 * @instance
 * @alias has
 * @memberof KeySetImpl
 * @ojsignature {target: "Type", value: "K", for:"key"}
 */


KeySetImpl.prototype.has = function (key) {
  return this.get(key) !== this.NOT_A_KEY;
};
/**
 * Returns the keys in this KeySet in the order they are added.
 * Specifically, this returns a set of keys that are expanded (when this is used for expansion)
 * or selected (when this is used for selection).
 *
 * @return {Set} the keys in this KeySet in the order they are added.
 * @expose
 * @instance
 * @alias values
 * @memberof KeySetImpl
 * @ojsignature {target: "Type", value: "Set<K>", for:"returns"}
 */


KeySetImpl.prototype.values = function () {
  return this.Clone();
};



/* global KeySet:false, KeySetImpl:false */

/**
 * Create a new immutable KeySet that represents a set with all keys.
 * Use this KeySet to select or expand all keys.
 *
 * @class AllKeySetImpl
 * @classdesc The AllKeySetImpl class represents a set with all keys.
 * @extends {KeySet}
 * @constructor
 * @final
 * @since 7.0.0
 * @ojsignature {target: "Type", value: "class AllKeySetImpl<K> extends KeySet<K>", genericParameters: [{"name": "K", "description": "Type of Key"}]}
 * @example <caption>Creates a new AllKeySetImpl to select all keys</caption>
 * require(['ojs/ojkeyset'],
 *   function(keySet) {
 *     var AllKeySetImpl = new keySet.AllKeySetImpl();
 *   }
 * );
 */
var AllKeySetImpl = function AllKeySetImpl() {
  this.InitializeWithKeys(null);
}; // Subclass from KeySet


oj.Object.createSubclass(AllKeySetImpl, KeySet, 'AllKeySetImpl'); // make it available internally

oj.AllKeySetImpl = AllKeySetImpl;
/**
 * Returns a new KeySet with the specified keys included in the set.
 * When a key is added to this KeySet it implies the key will become expanded (when this
 * is used for expansion) or selected (when this is used for selection).
 * If the keys specified are already added then it will be a no-op and this KeySet is returned.
 *
 * @param {Set|Array} keys a set of keys to add to this KeySet.
 * @return {AllKeySetImpl} a new KeySet with the specified keys included.
 * @expose
 * @instance
 * @alias add
 * @memberof! AllKeySetImpl
 * @ojsignature {target: "Type", value: "(keys: Set<K>|Array<K>): AllKeySetImpl<K>"}
 */

AllKeySetImpl.prototype.add = function (keys) {
  // add keys on all = remove deleted keys
  return (
    /** @type {!AllKeySetImpl} */
    this.AddOrDeleteInternal(false, keys)
  );
};
/**
 * Returns a new KeySet that represents a set with all keys.  If this KeySet already is
 * a set with all keys, then this would just return itself.
 * Specifically, invoking addAll will cause all keys to be expanded (when this is used for
 * expansion) or selected (when this is used for selection).
 *
 * @return {AllKeySetImpl} a new KeySet that represents a set with all keys.
 * @expose
 * @instance
 * @alias addAll
 * @memberof! AllKeySetImpl
 * @ojsignature {target: "Type", value: "(): AllKeySetImpl<K>"}
 */


AllKeySetImpl.prototype.addAll = function () {
  return this.GetInternalSize() === 0 ? this : new AllKeySetImpl();
};
/**
 * Determines whether this is a set that represents all keys.  Since this KeySet represents
 * all keys, this method will always return true.
 *
 * @return {boolean} true if this is a set that reprsents all keys, false otherwise.
 * @expose
 * @instance
 * @alias isAddAll
 * @memberof! AllKeySetImpl
 */


AllKeySetImpl.prototype.isAddAll = function () {
  return true;
};
/**
 * Returns a new KeySet based on this set with the specified keys deleted.
 * When a key is removed from this KeySet it implies the key will become collapsed (when this
 * is used for expansion) or de-selected (when this is used for selection).
 * If the keys specified are already deleted then it will be a no-op and this KeySet is returned.
 *
 * @param {Set|Array} keys a set of keys to remove from this KeySet.
 * @return {AllKeySetImpl} a new KeySet with the specified keys excluded.
 * @expose
 * @instance
 * @alias delete
 * @memberof! AllKeySetImpl
 * @ojsignature {target: "Type", value: "(keys: Set<K>|Array<K>): AllKeySetImpl<K>"}
 */


AllKeySetImpl.prototype.delete = function (keys) {
  // remove keys on all = add to excluded keys
  return (
    /** @type {!AllKeySetImpl} */
    this.AddOrDeleteInternal(true, keys)
  );
};
/**
 * Returns a new KeySet containing no keys.  Specifically, invoking clear will collapse all keys (
 * when this is used for expansion) or clear selection (when this is used for selection).
 *
 * @return {KeySetImpl} a new KeySet with no keys.
 * @expose
 * @instance
 * @alias clear
 * @memberof! AllKeySetImpl
 * @ojsignature {target: "Type", value: "(): KeySetImpl<K>"}
 */


AllKeySetImpl.prototype.clear = function () {
  return new KeySetImpl();
};
/**
 * Determines whether the specified key is in this set.
 * Specifically, this returns true if the key is expanded (when this is used for expansion)
 * or selected (when this is used for selection), and false otherwise.
 *
 * @param {any} key the key to check whether it is in this set.
 * @return {boolean} true if the specified key is in this set, false otherwise.
 * @expose
 * @instance
 * @alias has
 * @memberof! AllKeySetImpl
 * @ojsignature {target: "Type", value: "K", for: "key"}
 */


AllKeySetImpl.prototype.has = function (key) {
  return this.get(key) === this.NOT_A_KEY;
};
/**
 * Returns a set of keys of the items that are excluded from this set.
 * Specifically, this returns a set of keys that are collapsed (when this is used for expansion)
 * or de-selected (when this is used for selection).
 *
 * @return {Set} the keys of the deleted items.
 * @expose
 * @instance
 * @alias deletedValues
 * @memberof! AllKeySetImpl
 * @ojsignature {target: "Type", value: "Set<K>", for: "returns"}
 */


AllKeySetImpl.prototype.deletedValues = function () {
  return this.Clone();
};



/* global AllKeySetImpl:false, KeySetImpl:false */

/**
 * Contains a set of utility methods for working with KeySet.
 * @class
 * @ignore
 * @tsignore
 */
var KeySetUtils = {};
/**
 * Converts a KeySet into an array
 */

KeySetUtils.toArray = function (keyset) {
  var arr;
  var set = keyset.isAddAll() ? keyset.deletedValues() : keyset.values();

  if (Array.from) {
    arr = Array.from(set);
  } else {
    // IE11 does not support Array.from
    arr = [];
    set.forEach(function (value) {
      arr.push(value);
    });
  }

  arr.inverted = keyset.isAddAll();
  return arr;
};
/**
 * Converts an array into a KeySet
 */


KeySetUtils.toKeySet = function (arr) {
  var keyset = null;

  if (arr.inverted) {
    keyset = new AllKeySetImpl();
    keyset = keyset.delete(arr);
  } else {
    keyset = new KeySetImpl();
    keyset = keyset.add(arr);
  }

  return keyset;
};

;return {
  'KeySet': KeySet,
  'ExpandedKeySet': ExpandedKeySet,
  'ExpandAllKeySet': ExpandAllKeySet,
  'KeySetImpl': KeySetImpl,
  'AllKeySetImpl': AllKeySetImpl,
  'KeySetUtils': KeySetUtils
}

});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojmap',['ojs/ojcore', 'ojs/ojkeysetimpl'],
/*
* @param {Object} oj 
* @param {Object} KeySetImpl
*/
function(oj, KeySetImpl)
{
  "use strict";


/* global KeySetImpl:false, Map:false */

/**
 * Implementation of the ES6 Map API:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map
 * that can deal with how equalities are handled when Object is used as key
 * @ignore
 * @ojtsignore
 * @export
 * @class ojMap
 * @constructor
 * @since 5.2.0
 */
var ojMap = function ojMap() {
  this._map = new Map();
  this._keyset = new KeySetImpl();
};

var _proto = ojMap.prototype;
Object.defineProperty(_proto, 'size', {
  get: function get() {
    return this._map.size;
  }
});

_proto.clear = function () {
  this._map.clear();

  this._keyset._keys.clear();
};

_proto.delete = function (key) {
  var theKey = this._keyset.get(key);

  if (theKey === this._keyset.NOT_A_KEY) {
    return false;
  }

  this._keyset._keys.delete(theKey);

  return this._map.delete(theKey);
};

_proto.forEach = function (callback) {
  this._map.forEach(callback);
};

_proto.get = function (key) {
  var theKey = this._keyset.get(key);

  return this._map.get(theKey);
};

_proto.has = function (key) {
  return this._keyset.has(key);
};

_proto.set = function (key, value) {
  var theKey = this._keyset.get(key);

  if (theKey === this._keyset.NOT_A_KEY) {
    this._keyset._keys.add(key);

    this._map.set(key, value);
  } else {
    // update value
    this._map.set(theKey, value);
  }

  return this;
};

;return ojMap;
});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojeventtarget',['ojs/ojcore'], function(oj)
{
  "use strict";
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var EventTargetMixin = /*#__PURE__*/function () {
  function EventTargetMixin() {
    _classCallCheck(this, EventTargetMixin);
  }

  _createClass(EventTargetMixin, [{
    key: "addEventListener",
    value: function addEventListener(eventType, listener) {
      if (!this._eventListeners) {
        this._eventListeners = [];
      }

      this._eventListeners.push({
        type: eventType.toLowerCase(),
        listener: listener
      });
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(eventType, listener) {
      if (this._eventListeners) {
        var i;

        for (i = this._eventListeners.length - 1; i >= 0; i--) {
          if (this._eventListeners[i]['type'] == eventType && this._eventListeners[i]['listener'] == listener) {
            this._eventListeners.splice(i, 1);
          }
        }
      }
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(evt) {
      if (this._eventListeners) {
        var i, returnValue; //clone the eventListeners to isolate mutations that may occur during dispatching events

        var eventListeners = this._eventListeners.slice(0);

        for (i = 0; i < eventListeners.length; i++) {
          var eventListener = eventListeners[i];

          if (evt && evt.type && eventListener['type'] == evt.type.toLowerCase()) {
            returnValue = eventListener['listener'].apply(this, [evt]);

            if (returnValue === false) {
              // event cancelled
              return false;
            }
          }
        }
      }

      return true;
    }
  }], [{
    key: "applyMixin",
    value: function applyMixin(derivedCtor) {
      var baseCtors = [EventTargetMixin];
      baseCtors.forEach(function (baseCtor) {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach(function (name) {
          if (name !== 'constructor') {
            derivedCtor.prototype[name] = baseCtor.prototype[name];
          }
        });
      });
    }
  }]);

  return EventTargetMixin;
}();

oj.EventTargetMixin = EventTargetMixin;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var GenericEvent = function GenericEvent(type, options) {
  _classCallCheck(this, GenericEvent);

  this.type = type;
  this.options = options;

  if (options != null) {
    this['detail'] = options['detail'];
  }
};

oj.GenericEvent = GenericEvent;

});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojdataprovider',['ojs/ojcore', 'ojs/ojeventtarget'], function(oj)
{
  "use strict";
  var GenericEvent = oj.GenericEvent;


/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * The interface for AttributeExprFilterDef
 *
 *
 * @export
 * @interface AttributeExprFilterDef
 * @since 8.0.0
 * @ojsignature {target: "Type",
 *               value: "interface AttributeExprFilterDef<D>",
 *               genericParameters: [{"name": "D", "description": "Type of Data"}]}
 */

/**
 * Property which contains an expression specifies which attribute to filter on.
 *
 * @since 8.0.0
 * @export
 * @expose
 * @memberof AttributeExprFilterDef
 * @instance
 * @name attribute
 * @type {AttributeFilterDef.AttributeExpression | string}
 * @ojtsexample <caption>Attribute filter definition which filters on DepartmentId value 10</caption>
 * {op: '$eq', attribute: 'DepartmentId', value: 10}
 */

/**
 * Operator to apply for the filter. Valid operators defined in the AttributeFilterOperator union type are the strings:
 * <ul>
 *   <li>$co The entire operator value must be a substring of the attribute value for a match.</li>
 *   <li>$eq The attribute and operator values must be identical for a match.</li>
 *   <li>$ew The entire operator value must be a substring of the attribute value matching at the end of the attribute value.  This criterion is satisfied if the two strings are identical.</li>
 *   <li>$pr If the attribute has a non-empty or non-null value, or if it contains a non-empty node for complex attributes, there is a match.</li>
 *   <li>$gt If the attribute value is greater than the operator value, there is a match.</li>
 *   <li>$ge If the attribute value is greater than or equal to the operator value, there is a match.</li>
 *   <li>$lt If the attribute value is less than the operator value, there is a match.</li>
 *   <li>$le If the attribute value is less than or equal to the operator value, there is a match.</li>
 *   <li>$ne The attribute and operator values are not identical.</li>
 *   <li>$regex If the attribute value satisfies the regular expression, there is a match.</li>
 *   <li>$sw The entire operator value must be a substring of the attribute value, starting at the beginning of the attribute value.  This criterion is satisfied if the two strings are identical.</li>
 * </ul>
 *
 *
 * @since 8.0.0
 * @export
 * @expose
 * @memberof AttributeExprFilterDef
 * @instance
 * @name op
 * @type {AttributeFilterDef.AttributeOperator}
 */

/**
 * Specifies the value to filter for.
 *
 * @since 8.0.0
 * @export
 * @expose
 * @memberof AttributeExprFilterDef
 * @instance
 * @name value
 * @type {any}
 * @ojtsexample
 * <caption>Filter definition which filters on DepartmentId value 10</caption>
 * {op: '$eq', attribute: 'DepartmentId', value: 10}
 */

/**
 * End of jsdoc
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * The interface for AttributeExprFilter
 *
 *
 * @export
 * @interface AttributeExprFilter
 * @extends AttributeExprFilterDef
 * @extends BaseDataFilter
 * @since 8.0.0
 * @ojsignature {target: "Type",
 *               value: "interface AttributeExprFilter<D> extends AttributeExprFilterDef<D>, BaseDataFilter<D>",
 *               genericParameters: [{"name": "D", "description": "Type of Data"}]}
 */

/**
 * End of jsdoc
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @export
 * @interface AttributeFilterDef
 * @since 7.0.0
 * @ojsignature {target: "Type",
 *               value: "interface AttributeFilterDef<D>",
 *               genericParameters: [{"name": "D", "description": "Type of Data"}]}
 * @classdesc Defines a kind of {@link DataFilter.FilterDef} which applies to the attributes in item data.
 */

/**
 * Operator to apply for the filter.
 * @since 7.0.0
 * @export
 * @expose
 * @memberof AttributeFilterDef
 * @instance
 * @name op
 * @type {AttributeFilterDef.AttributeOperator}
 */

/**
 * Specifies the value to filter for. Value should be an object which specifies attribute/value pairs to filter on. The op will be applied to each attribute/value pair and
 * the whole will be AND'd. For subobjects, please specify them in a nested structure.
 *
 *
 * @since 7.0.0
 * @export
 * @expose
 * @memberof AttributeFilterDef
 * @instance
 * @name value
 * @type {any}
 * @ojtsexample
 * <caption>Filter definition which filters on DepartmentId value 10</caption>
 * {op: '$eq', value: {DepartmentId: 10}}
 * @ojtsexample
 * <caption>Filter definition which filters on DepartmentId value 10 and DepartmentName is Hello</caption>
 * {op: '$eq', value: {DepartmentId: 10, DepartmentName: 'Hello'}}
 * @ojtsexample
 * <caption>Filter definition which filters on subobject Location State is California and DepartmentName is Hello</caption>
 * {op: '$eq', value: {DepartmentName: 'Hello', Location: {State: 'California'}}}
 */

/**
 * AttributeOperator enum
 * <br>
 * <p>The operators are based on the filtering spec of the RFC 7644 SCIM
 * protocol:
 * <br>
 * {@link https://tools.ietf.org/html/rfc7644#section-3.4.2|SCIM Filtering}
 * <br>
 * <p>
 *
 * @export
 * @enum {string}
 * @name AttributeOperator
 * @memberof AttributeFilterDef
 * @property {string} $co=$co The entire operator value must be a substring of the attribute value for a match.
 * @property {string} $eq=$eq The attribute and operator values must be identical for a match.
 * @property {string} $ew=$ew The entire operator value must be a substring of the attribute value matching at the end of the attribute value.  This criterion is satisfied if the two strings are identical.
 * @property {string} $pr=$pr If the attribute has a non-empty or non-null value, or if it contains a non-empty node for complex attributes, there is a match.
 * @property {string} $gt=$gt If the attribute value is greater than the operator value, there is a match.
 * @property {string} $ge=$ge If the attribute value is greater than or equal to the operator value, there is a match.
 * @property {string} $lt=$lt If the attribute value is less than the operator value, there is a match.
 * @property {string} $le=$le If the attribute value is less than or equal to the operator value, there is a match.
 * @property {string} $ne=$ne The attribute and operator values are not identical.
 * @property {string} $regex=$regex If the attribute value satisfies the regular expression, there is a match.
 * @property {string} $sw=$sw The entire operator value must be a substring of the attribute value, starting at the beginning of the attribute value.  This criterion is satisfied if the two strings are identical.
 * @since 9.0.0
 */

/**
 * AttributeExpression enum
 * <br>
 * <p>
 * Attribute expressions supported
 *
 * @export
 * @enum {string}
 * @name AttributeExpression
 * @memberof AttributeFilterDef
 * @property {string} *=* Attribute wildcard
 * @since 9.0.0
 */

/**
 * End of jsdoc
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @export
 * @interface AttributeFilter
 * @extends AttributeFilterDef
 * @extends BaseDataFilter
 * @since 7.0.0
 * @ojsignature {target: "Type",
 *               value: "interface AttributeFilter<D> extends AttributeFilterDef<D>, BaseDataFilter<D>",
 *               genericParameters: [{"name": "D", "description": "Type of Data"}]}
 * @classdesc Defines a kind of {@link DataFilter.Filter} which applies to the attributes in item data.
 */

/**
 * End of jsdoc
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @export
 * @interface CompoundFilterDef
 * @since 7.0.0
 * @ojsignature {target: "Type",
 *               value: "interface CompoundFilterDef<D>",
 *               genericParameters: [{"name": "D", "description": "Type of Data"}]}
 * @classdesc Defines a kind of {@link DataFilter.FilterDef} which applies to the compound filter definitions.
 */

/**
 * Operator to apply for the filter. Valid operators defined in the CompoundFilterOperator union type are the strings:
 * <ul>
 *   <li>$and The filters in the criteria array will be AND'd.</li>
 *   <li>$or The filters in the criteria array will be OR'd.</li>
 * </ul>
 *
 * @since 7.0.0
 * @export
 * @expose
 * @memberof CompoundFilterDef
 * @instance
 * @name op
 * @type {CompoundFilterDef.CompoundOperator}
 */

/**
 * Array of FilterDefs on which to apply the operator
 *
 *
 * @since 7.0.0
 * @export
 * @expose
 * @memberof CompoundFilterDef
 * @instance
 * @name criteria
 * @type {Array.<AttributeFilterDef | AttributeExprFilterDef | CompoundFilterDef>}
 * @ojsignature {target: "Type",
 *               value: "Array<AttributeFilterDef<D> | AttributeExprFilterDef<D> | CompoundFilterDef<D>>"}
 */

/**
 * CompoundOperator enum
 * <br>
 * <p>The operators are based on the filtering spec of the RFC 7644 SCIM
 * protocol:
 * <br>
 * {@link https://tools.ietf.org/html/rfc7644#section-3.4.2|SCIM Filtering}
 * <br>
 * <p>
 *
 * @export
 * @enum {string}
 * @name CompoundOperator
 * @memberof CompoundFilterDef
 * @property {string} $and=$and The filter is only a match if both expressions evaluate to true.
 * @property {string} $or=$or The filter is a match if either expression evaluates to true.
 * @since 5.0.0
 */

/**
 * End of jsdoc
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @export
 * @interface CompoundFilter
 * @extends CompoundFilterDef
 * @extends BaseDataFilter
 * @since 7.0.0
 * @ojsignature {target: "Type",
 *               value: "interface CompoundFilter<D> extends CompoundFilterDef<D>, BaseDataFilter<D>",
 *               genericParameters: [{"name": "D", "description": "Type of Data"}]}
 * @classdesc Defines a kind of {@link DataFilter.Filter} which applies to the compound filters.
 */

/**
 * End of jsdoc
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @export
 * @interface TextFilterDef
 * @since 8.0.0
 * @ojsignature {target: "Type",
 *               value: "interface TextFilterDef",
 *               genericParameters: [{"name": "D", "description": "Type of Data"}]}
 * @classdesc Defines a kind of {@link DataFilter.FilterDef} which applies to text filter definitions. A text filter definition
 * specifies a string which should be used for filtering and leaves it up to the DataProvider to decide which fields are filtered
 * and how the filtering happens (such as whether the filtering is an exact match or contains, etc).
 */

/**
 * Specifies the text to filter for. It is up to the DataProvider implementation to decide which attributes to
 * apply the filter to and also the exact filtering logic used, such as case insensitivity, etc. In addition, for
 * attributes which contain non-string values, the type coercion rule expected is to call toString() on that value.
 * If the value is an object which does not have a string representation then the value does not satisfy the filter.
 * @since 8.0.0
 * @export
 * @expose
 * @memberof TextFilterDef
 * @instance
 * @name text
 * @type {string}
 * @ojtsexample
 * <caption>Filter definition which filters on the text 'abc search'</caption>
 * {text: 'abc search'}
 */

/**
 * End of jsdoc
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @export
 * @interface TextFilter
 * @extends TextFilterDef
 * @extends BaseDataFilter
 * @since 8.0.0
 * @ojsignature {target: "Type",
 *               value: "interface TextFilter<D> extends TextFilterDef, BaseDataFilter<D>",
 *               genericParameters: [{"name": "D", "description": "Type of Data"}]}
 * @classdesc Defines a kind of {@link DataFilter.Filter} which applies to text filters. A text filter
 * specifies a string which should be used for filtering and leaves it up to the DataProvider to decide which fields are filtered
 * and how the filtering happens (such as whether the filtering is an exact match or contains, etc).
 */

/**
 * End of jsdoc
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * The interface for Filter
 *
 *
 * @export
 * @interface BaseDataFilter
 * @since 8.0.0
 * @ojsignature {target: "Type",
 *              value: "interface BaseDataFilter<D>",
 *              genericParameters: [{"name": "D", "description": "Type of Data"}]}
 */

/**
 * Specifies a filter function which has the same signature as the the callback
 * which is specified for the JS Array.filter():
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter
 * This function will be optionally used by the DataProvider to do local filtering.
 * This function is required by the DataProvider so that it is possible for DataProvider
 * implementations to at least do local filtering.
 *
 *
 * @since 8.0.0
 * @export
 * @expose
 * @memberof BaseDataFilter
 * @instance
 * @name filter
 * @method
 * @param {any} item The current element being processed in the array.
 * @param {number=} index The index of the current element being processed in the array.
 * @param {Array=} array The array filter was called upon.
 * @return {boolean} True if the element satisfies the filter.
 * @ojsignature {target: "Type",
 *               value: "(item: D, index?: number, array?: Array<D>): boolean;"}
 */

/**
 * @export
 * @namespace DataFilter
 * @since 8.0.0
 * @ojsignature {target: "Type",
 *              value: "namespace DataFilter"}
 * @classdesc Contains definitions for {@link DataFilter.Filter} used in {@link FetchListParameters#filterCriterion} and {@link FetchByOffsetParameters#filterCriterion}
 */

/**
 * @typedef {Object} DataFilter.FilterDef Union type of all FilterDef types.
 * @ojsignature [{target: "Type",
 *               value: "AttributeFilterDef<D> | AttributeExprFilterDef<D> | CompoundFilterDef<D> | TextFilterDef"},
 *               {target:"Type", value:"<D>", for:"genericTypeParameters"}]
 * @classdesc Union type containing {@link AttributeFilterDef}, {@link AttributeExprFilterDef}, {@link CompoundFilterDef}, and {@link TextFilterDef}
 */

/**
 * @typedef {Object} DataFilter.Filter Union type of all Filter types.
 * @ojsignature [{target: "Type",
 *               value: "AttributeFilter<D> | AttributeExprFilter<D> | CompoundFilter<D> | TextFilter<D>"},
 *               {target:"Type", value:"<D>", for:"genericTypeParameters"}]
 * @classdesc Union type containing {@link AttributeFilter}, {@link AttributeExprFilter}, {@link CompoundFilter}, and {@link TextFilter}
 */

/**
 * End of jsdoc
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @export
 * @expose
 * @interface AttributeFilterCapability
 * @since 6.1.0
 * @ojsignature {target: "Type",
 *               value: "interface AttributeFilterCapability"}
 * @classdesc Defines the properties in the attribute property used in {@link FetchCapability}
 */

/**
 * Optionally indicates what attribute expansion (as in the addition of more attributes) capability the DataProvider has.
 * The exact shape of this property are determined by the DataProvider.
 *
 * @since 6.1.0
 * @export
 * @expose
 * @memberof AttributeFilterCapability
 * @instance
 * @name expansion
 * @type {object=}
 * @ojsignature {target: "Type",
 *               value: "?object"}
 */

/**
 * Optionally indicates what capability the DataProvider has in terms of attribute ordering. By default there is no inherent
 * attribute ordering on the item data property bag. The exact shape of this property are determined by the DataProvider.
 *
 *
 * @since 6.1.0
 * @export
 * @expose
 * @memberof AttributeFilterCapability
 * @instance
 * @name ordering
 * @type {object=}
 * @ojsignature {target: "Type",
 *               value: "?object"}
 */

/**
 * Optionally indicates what capability the DataProvider has in terms of being able to specify the item data shape.
 * The exact shape of this property are determined by the DataProvider.
 *
 *
 * @since 6.1.0
 * @export
 * @expose
 * @memberof AttributeFilterCapability
 * @instance
 * @name defaultShape
 * @type {object=}
 * @ojsignature {target: "Type",
 *               value: "?object"}
 */

/**
 * End of jsdoc
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @export
 * @interface FetchCapability
 * @since 6.1.0
 * @ojsignature {target: "Type",
 *               value: "interface FetchCapability"}
 * @classdesc Defines the result from the DataProvider method {@link DataProvider#getCapability} for capability "fetchCapability"
 */

/**
 * Optional detailed attribute filter capability information
 *
 *
 * @since 6.1.0
 * @export
 * @expose
 * @memberof FetchCapability
 * @instance
 * @name attributeFilter
 * @type {AttributeFilterCapability=}
 * @ojsignature {target: "Type",
 *               value: "?AttributeFilterCapability"}
 */

/**
 * Optional detailed caching capability information
 *
 *
 * @since 9.1.0
 * @export
 * @expose
 * @memberof FetchCapability
 * @instance
 * @name caching
 * @type {string}
 * @ojsignature {target: "Type",
 *               value: "? 'all' | 'none' | 'visitedByCurrentIterator'"}
 */

/**
 * End of jsdoc
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @export
 * @interface FilterCapability
 * @since 5.0.0
 * @ojsignature {target: "Type",
 *               value: "interface FilterCapability"}
 * @classdesc Defines the result from the DataProvider method {@link DataProvider#getCapability} for capability "filter"
 */

/**
 * An array of supported filter operator strings. The filter operators may be for {@link AttributeFilter} or {@link CompoundFilter}.
 *
 *
 * @since 5.0.0
 * @export
 * @expose
 * @memberof FilterCapability
 * @instance
 * @name operators
 * @type {Array.<AttributeFilterDef.AttributeOperator | CompoundFilterDef.CompoundOperator>=}
 * @ojsignature {target: "Type",
 *               value: "?Array.<AttributeFilterDef.AttributeOperator | CompoundFilterDef.CompoundOperator>"}
 */

/**
 * An array of supported attribute expressions.
 *
 *
 * @since 5.0.0
 * @export
 * @expose
 * @memberof FilterCapability
 * @instance
 * @name attributeExpression
 * @type {Array.<AttributeFilterDef.AttributeExpression>=}
 * @ojsignature {target: "Type",
 *               value: "?Array.<AttributeFilterDef.AttributeExpression>"}
 */

/**
 * Existence of this property indicates that {@link TextFilter} is supported. The property value can be used convey more information to the caller.
 *
 *
 * @since 8.0.0
 * @export
 * @expose
 * @memberof FilterCapability
 * @instance
 * @name textFilter
 * @type {any=}
 * @ojsignature {target: "Type",
 *               value: "?any"}
 */

/**
 * End of jsdoc
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @since 4.1.0
 * @export
 * @interface FetchByKeysParameters
 * @ojsignature {target: "Type",
 *               value: "interface FetchByKeysParameters<K>",
 *               genericParameters: [{"name": "K", "description": "Type of Key"}]}
 * @classdesc Defines the parameters to the DataProvider methods {@link DataProvider#fetchByKeys} and {@link DataProvider#containsKeys}
 */

/**
 * Keys for rows to fetch
 *
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof FetchByKeysParameters
 * @instance
 * @name keys
 * @type {Set.<any>}
 * @ojsignature {target: "Type",
 *               value: "Set<K>"}
 */

/**
 * Optional string describing local or global data set to fetch. Local refers to the current fetched data whereas global is the entire data set.
 * The usage is primarily directed towards selection where a selection is on a different part of the data set than that of the local data set.
 *
 *
 * @since 7.0.0
 * @export
 * @expose
 * @memberof FetchByKeysParameters
 * @instance
 * @name scope
 * @type {FetchByKeysParameters.Scope=}
 * @ojsignature {target: "Type",
 *               value: "?FetchByKeysParameters.Scope"}
 * @ojsignature {target: "Type",
 *               value: "?'local' | 'global'"}
 */

/**
 * attributes to include in the result. If specified, then at least these set of attributes will be included in each row
 * results. If not specified then the default attributes will be included.
 *
 *
 * @since 6.1.0
 * @export
 * @expose
 * @memberof FetchByKeysParameters
 * @instance
 * @name attributes
 * @type {Array.<string | FetchAttribute>}
 * @ojsignature {target: "Type",
 *               value: "?Array<string | FetchAttribute>"}
 */

/**
 * Scope enum
 * <br>
 * <p>
 * Scope supported
 *
 * @export
 * @enum {string}
 * @name Scope
 * @memberof FetchByKeysParameters
 * @property {string} local=local Local refers to the current fetched data.
 * @property {string} global=global Global is the entire data set
 * @since 9.0.0
 */

/**
 * @since 4.1.0
 * @export
 * @interface FetchByKeysResults
 * @ojsignature {target: "Type",
 *               value: "interface FetchByKeysResults<K, D>",
 *               genericParameters: [{"name": "K", "description": "Type of Key"}, {"name": "D", "description": "Type of Data"}]}
 * @classdesc FetchByKeysResults defines the result from the DataProvider method {@link DataProvider#fetchByKeys}
 */

/**
 * The parameters used for the fetch call.
 *
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof FetchByKeysResults
 * @instance
 * @name fetchParameters
 * @type {FetchByKeysParameters}
 * @ojsignature {target: "Type",
 *               value: "FetchByKeysParameters<K>"}
 */

/**
 * Map of keys and corresponding {@link Item}. The map will only contain keys which were actually found.
 *
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof FetchByKeysResults
 * @instance
 * @name results
 * @type {Map.<*, Item>}
 * @ojsignature {target: "Type",
 *               value: "Map<K, Item<K, D>>"}
 */

/**
 * @since 4.1.0
 * @export
 * @interface ContainsKeysResults
 * @ojsignature {target: "Type",
 *               value: "interface ContainsKeysResults<K>",
 *               genericParameters: [{"name": "K", "description": "Type of Key"}]}
 * @classdesc ContainsKeysResults defines the results from the DataProvider method {@link DataProvider#containsKeys}
 */

/**
 * The parameters used for the containsKeys call.
 *
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof ContainsKeysResults
 * @instance
 * @name containsParameters
 * @type {FetchByKeysParameters}
 * @ojsignature {target: "Type",
 *               value: "FetchByKeysParameters<K>"}
 */

/**
 * Requested keys subset which are contained in the DataProvider.
 *
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof ContainsKeysResults
 * @instance
 * @name results
 * @type {Set.<any>}
 * @ojsignature {target: "Type",
 *               value: "Set<K>"}
 */

/**
 * end of jsdoc
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @since 4.1.0
 * @export
 * @interface SortCriterion
 * @ojsignature {target: "Type",
 *               value: "interface SortCriterion<D>",
 *               genericParameters: [{"name": "D", "description": "Type of Data"}]}
 * @classdesc Defines the sort criterion objects in {@link FetchListParameters#sortCriterion}
 */

/**
 * sort attribute upon which the data should be sorted.
 *
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof SortCriterion
 * @instance
 * @name attribute
 * @type {string}
 * @ojsignature {target: "Type",
 *               value: "keyof D"}
 */

/**
 * sort direction, either "ascending" or "descending".
 *
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof SortCriterion
 * @instance
 * @name direction
 * @type {string}
 */

/**
 * End of jsdoc
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 *
 * @since 4.1.0
 * @export
 * @interface DataMapping
 * @ojsignature {target: "Type",
 *               value: "interface DataMapping <K, D, Kin, Din>",
 *               genericParameters: [{"name": "K", "description": "Type of output key"}, {"name": "D", "description": "Type of output data"},
 *                    {"name": "Kin", "description": "Type of input key"}, {"name": "Din", "description": "Type of input data"}]}
 */

/**
 * Field mapping function which takes an item and returns the mapped item
 *
 *
 * @export
 * @expose
 * @memberof DataMapping
 * @instance
 * @name mapFields
 * @type {Function}
 * @ojsignature {target: "Type",
 *               value: "(item: Item<Kin, Din>) => Item<K, D>"}
 */

/**
 * Optional FilterCriterion mapping function which takes filterOperator and returns the mapped filterOperator
 *
 *
 * @export
 * @expose
 * @memberof DataMapping
 * @instance
 * @name mapFilterCriterion
 * @type {Function}
 * @ojsignature {target: "Type",
 *               value: "?(filterCriterion: DataFilter.Filter<D>) => DataFilter.Filter<Din>"}
 */

/**
 * Optional FilterCriterion unmapping function which takes a mapped filterOperator and returns the unmapped filterOperator
 *
 *
 * @export
 * @expose
 * @memberof DataMapping
 * @instance
 * @name unmapFilterCriterion
 * @type {Function}
 * @ojsignature {target: "Type",
 *               value: "?(filterCriterion: DataFilter.Filter<Din>) => DataFilter.Filter<D>"}
 */

/**
 * Optional SortCriterion mapping function which takes sortCriteria and returns the mapped sortCriteria
 *
 *
 * @export
 * @expose
 * @memberof DataMapping
 * @instance
 * @name mapSortCriteria
 * @type {Function}
 * @ojsignature {target: "Type",
 *               value: "?(sortCriteria: Array<SortCriterion<D>>) => Array<SortCriterion<Din>>"}
 */

/**
 * Optional SortCriterion unmapping function which takes mapped sortCriteria and returns the unmapped sortCriteria
 *
 *
 * @export
 * @expose
 * @memberof DataMapping
 * @instance
 * @name unmapSortCriteria
 * @type {Function}
 * @ojsignature {target: "Type",
 *               value: "?(sortCriteria: Array<SortCriterion<Din>>) => Array<SortCriterion<D>>"}
 */

/**
 * End of jsdoc
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @since 4.1.0
 * @export
 * @ojsignature {target: "Type",
 *               value: "interface FetchFunc<K, D>",
 *               genericParameters: [{"name": "K", "description": "Type of Key"}, {"name": "D", "description": "Type of Data"}]}
 * @classdesc Defines the interface for the {@link DataProvider#fetchFirst} method
 */

/**
 * @ojsignature {target: "Type",
 *               value: "(FetchListParameters?): AsyncIterable<FetchListResult<K, D>>"}
 */

/**
 * end of jsdoc
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @since 4.1.0
 * @export
 * @interface FetchListParameters
 * @ojsignature {target: "Type",
 *               value: "interface FetchListParameters<D>",
 *               genericParameters: [{"name": "D", "description": "Type of Data"}]}
 * @classdesc Defines the parameters to the DataProvider method {@link DataProvider#fetchFirst}
 */

/**
 * Optional number of rows to fetch.  If fewer than that number of rows exist, the fetch will succeed but be truncated.
 * A value of -1 will return all rows or the maximum size supported by the DataProvider.
 * If the size is not specified, then the DataProvider implementation will determine how many rows to return.
 *
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof FetchListParameters
 * @instance
 * @name size
 * @type {number=}
 * @ojsignature {target: "Type",
 *               value: "?number"}
 */

/**
 * Optional sort criteria to apply.
 *
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof FetchListParameters
 * @instance
 * @name sortCriteria
 * @type {Array.<SortCriterion>}
 * @ojsignature {target: "Type",
 *               value: "?Array<SortCriterion<D>>"}
 * @ojtsexample
 * [{attribute: 'DepartmentName', direction: 'ascending'}]
 */

/**
 * Optional filter criterion to apply. The filter criterion would be composed of a
 * supported {@link DataFilter.Filter} such as a {@link AttributeFilter}, {@link AttributeExprFilter}, {@link CompoundFilter}. {@link TextFilter}
 *
 * @ojtsexample
 * let filterDef = {op: '$or', criteria: [{op: '$eq', value: {name: 'Bob'}}, {op: '$gt', value: {level: 'Low'}}]};
 * let filter = FilterFactory.getFilter(filterDef); // create a standard filter using the filterFactory.
 * let fetchListParam = {filterCriterion: filter, size: 5};
 *
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof FetchListParameters
 * @instance
 * @name filterCriterion
 * @type {DataFilter.Filter}
 * @ojsignature {target: "Type",
 *               value: "?DataFilter.Filter<D>"}
 */

/**
 * Optional attributes to include in the result. If specified, then at least these set of attributes must be included in each row
 * in the data array in the FetchListResult. If not specified then the default attributes must be included.
 *
 *
 * @since 6.1.0
 * @export
 * @expose
 * @memberof FetchListParameters
 * @instance
 * @name attributes
 * @type {Array.<string | FetchAttribute>}
 * @ojsignature {target: "Type",
 *               value: "?Array<string | FetchAttribute>"}
 * @ojtsexample
 * ['!lastName', '@default'] // all attributes except lastName
 * @ojtsexample
 * ['!lastName', '@default', {name: 'location', attributes: ['address line 1', 'address line 2']}] // nested example
 *
 */

/**
 * Optional symbol that can uniquely identify the consumer of the DataProvider.
 *
 * Each consumer can call Symbol() to obtain a unique symbol, which can be
 * stored and reused on each subsequent call to fetchFirst. Note that Symbol()
 * returns a different unique symbol every time, so it should not be called
 * every time the consumer calls fetchFirst.
 *
 * There should only be one active iterator per clientId. All previous iterators
 * obtained with the same clientId should be considered invalid. This is used to
 * optimize resource usage in some DataProvider implementations.
 *
 *
 * @since 9.0.0
 * @export
 * @expose
 * @memberof oj.FetchListParameters
 * @instance
 * @name clientId
 * @type {symbol}
 * @ojsignature {target: "Type",
 *               value: "?symbol"}
 */

/**
 * End of jsdoc
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @since 4.1.0
 * @export
 * @interface FetchListResult
 * @ojsignature {target: "Type",
 *               value: "interface FetchListResult<K, D>",
 *               genericParameters: [{"name": "K", "description": "Type of Key"}, {"name": "D", "description": "Type of Data"}]}
 * @classdesc Defines the results from the DataProvider method {@link DataProvider#fetchFirst}.
 */

/**
 * The {@link FetchListParameters} used for the fetch call.
 * In addition, the property fetchParameters is not only the parameter passed through from fetchFirst.
 * The sortCriteria of fetchParameters is the sort criteria specified in fetchFirst parameter, it also include the implicitSort criteria specified in data provider constructor.
 * For example, if implicitSort is set in ArrayDataProvider constructor, it will be returned as part of the sortCriteria of fetchParameters.
 * The collection components, such as ojTable, will look at the sortCriteria to put appropriate sort icon on the UI rendered.
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof FetchListResult
 * @instance
 * @name fetchParameters
 * @type {FetchListParameters}
 * @ojsignature {target: "Type",
 *               value: "FetchListParameters<D>"}
 * @ojtsexample <caption>Example of retrieving sortCriteria from FetchListResult:</caption>
 * let asyncIterator = dataprovider.fetchFirst(options)[Symbol.asyncIterator]();
 * let result = await asyncIterator.next();
 * let sortCriteria = result.value.fetchParameters.sortCriteria;
 */

/**
 * Array of data for each row
 *
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof FetchListResult
 * @instance
 * @name data
 * @type {Array.<Object>}
 * @ojsignature {target: "Type",
 *               value: "D[]"}
 */

/**
 * Array of {link@ ItemMetadata} for each row
 *
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof FetchListResult
 * @instance
 * @name metadata
 * @type {Array.<ItemMetadata>}
 * @ojsignature {target: "Type",
 *               value: "Array<ItemMetadata<K>>"}
 */

/**
 * end of jsdoc
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @since 4.1.0
 * @export
 * @interface ItemMetadata
 * @ojsignature {target: "Type",
 *               value: "interface ItemMetadata<K>",
 *               genericParameters: [{"name": "K", "description": "Type of Key"}]}
 * @classdesc Defines the item metadata objects in {@link FetchListResult#metadata}.  Note that key is the only mandatory property,
 * implementations can provide additional properties as needed.
 */

/**
 * The key for the row
 *
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof ItemMetadata
 * @instance
 * @name key
 * @type {any}
 * @ojsignature {target: "Type",
 *               value: "K"}
 */

/**
 * An optional message such as error associated with the row
 *
 * @since 9.0.0
 * @export
 * @expose
 * @memberof ItemMetadata
 * @instance
 * @name message
 * @type {ItemMessage=}
 * @ojsignature {target: "Type",
 *               value: "?ItemMessage"}
 */

/**
 * End of jsdoc
 */












var AttributeFilterOperator;

(function (AttributeFilterOperator) {
  var AttributeOperator;

  (function (AttributeOperator) {
    AttributeOperator["$co"] = "$co";
    AttributeOperator["$eq"] = "$eq";
    AttributeOperator["$ew"] = "$ew";
    AttributeOperator["$pr"] = "$pr";
    AttributeOperator["$gt"] = "$gt";
    AttributeOperator["$ge"] = "$ge";
    AttributeOperator["$lt"] = "$lt";
    AttributeOperator["$le"] = "$le";
    AttributeOperator["$ne"] = "$ne";
    AttributeOperator["$regex"] = "$regex";
    AttributeOperator["$sw"] = "$sw";
  })(AttributeOperator = AttributeFilterOperator.AttributeOperator || (AttributeFilterOperator.AttributeOperator = {}));
})(AttributeFilterOperator || (AttributeFilterOperator = {}));

oj['AttributeFilterOperator'] = AttributeFilterOperator;
oj['AttributeFilterOperator']['AttributeOperator'] = AttributeFilterOperator.AttributeOperator;



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * The interface for AttributeFilterOperator
 *
 *
 * @export
 * @interface AttributeFilterOperator
 * @extends FilterOperator
 * @since 5.0.0
 * @ojsignature {target: "Type",
 *               value: "interface AttributeFilterOperator<D>",
 *               genericParameters: [{"name": "D", "description": "Type of Data"}]}
 * @ojdeprecated {since: '7.0.0', description: 'Use AttributeFilter instead.'}
 */

/**
 * Operator one of enum AttributeOperator {$co, $eq, $ew, $pr, $gt, $ge, $lt, $le, $ne, $regex, $sw}
 *
 *
 * @since 5.0.0
 * @export
 * @expose
 * @memberof AttributeFilterOperator
 * @instance
 * @name op
 * @type {AttributeFilterOperator.AttributeOperator}
 */

/**
 * Attribute
 *
 *
 * @since 5.0.0
 * @export
 * @expose
 * @memberof AttributeFilterOperator
 * @instance
 * @name attribute
 * @type {string}
 */

/**
 * Value
 *
 *
 * @since 5.0.0
 * @export
 * @expose
 * @memberof AttributeFilterOperator
 * @instance
 * @name value
 * @type {any}
 */

/**
 * AttributeOperator enum
 * <br>
 * <p>The operators are based on the filtering spec of the RFC 7644 SCIM
 * protocol:
 * <br>
 * {@link https://tools.ietf.org/html/rfc7644#section-3.4.2|SCIM Filtering}
 * <br>
 * <p>
 *
 * @export
 * @enum {string}
 * @name AttributeOperator
 * @memberof AttributeFilterOperator
 * @property {string} $co=$co The entire operator value must be a substring of the attribute value for a match.
 * @property {string} $eq=$eq The attribute and operator values must be identical for a match.
 * @property {string} $ew=$ew The entire operator value must be a substring of the attribute value matching at the end of the attribute value.  This criterion is satisfied if the two strings are identical.
 * @property {string} $pr=$pr If the attribute has a non-empty or non-null value, or if it contains a non-empty node for complex attributes, there is a match.
 * @property {string} $gt=$gt If the attribute value is greater than the operator value, there is a match.
 * @property {string} $ge=$ge If the attribute value is greater than or equal to the operator value, there is a match.
 * @property {string} $lt=$lt If the attribute value is less than the operator value, there is a match.
 * @property {string} $le=$le If the attribute value is less than or equal to the operator value, there is a match.
 * @property {string} $ne=$ne The attribute and operator values are not identical.
 * @property {string} $regex=$regex If the attribute value satisfies the regular expression, there is a match.
 * @property {string} $sw=$sw The entire operator value must be a substring of the attribute value, starting at the beginning of the attribute value.  This criterion is satisfied if the two strings are identical.
 * @since 5.0.0
 */

/**
 * End of jsdoc
 */








var CompoundFilterOperator;

(function (CompoundFilterOperator) {
  var CompoundOperator;

  (function (CompoundOperator) {
    CompoundOperator["$and"] = "$and";
    CompoundOperator["$or"] = "$or";
  })(CompoundOperator = CompoundFilterOperator.CompoundOperator || (CompoundFilterOperator.CompoundOperator = {}));
})(CompoundFilterOperator || (CompoundFilterOperator = {}));

oj['CompoundFilterOperator'] = CompoundFilterOperator;
oj['CompoundFilterOperator']['CompoundOperator'] = CompoundFilterOperator.CompoundOperator;



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * The interface for CompoundFilterOperator
 *
 *
 * @export
 * @interface CompoundFilterOperator
 * @extends FilterOperator
 * @since 5.0.0
 * @ojsignature {target: "Type",
 *               value: "interface CompoundFilterOperator<D>",
 *               genericParameters: [{"name": "D", "description": "Type of Data"}]}
 * @ojdeprecated {since: '7.0.0', description: 'Use CompoundFilter instead.'}
 */

/**
 * Operator one of enum CompoundOperator {$and, $or}
 *
 *
 * @since 5.0.0
 * @export
 * @expose
 * @memberof CompoundFilterOperator
 * @instance
 * @name op
 * @type {CompoundFilterOperator.CompoundOperator}
 */

/**
 * Array of FilterOperators on which to apply the operator
 *
 *
 * @since 5.0.0
 * @export
 * @expose
 * @memberof CompoundFilterOperator
 * @instance
 * @name criteria
 * @type {Array.<FilterOperator>}
 * @ojsignature {target: "Type",
 *               value: "Array<FilterOperator<D>>"}
 */

/**
 * CompoundOperator enum
 * <br>
 * <p>The operators are based on the filtering spec of the RFC 7644 SCIM
 * protocol:
 * <br>
 * {@link https://tools.ietf.org/html/rfc7644#section-3.4.2|SCIM Filtering}
 * <br>
 * <p>
 *
 * @export
 * @enum {string}
 * @name CompoundOperator
 * @memberof CompoundFilterOperator
 * @property {string} $and=$and The filter is only a match if both expressions evaluate to true.
 * @property {string} $or=$or The filter is a match if either expression evaluates to true.
 * @since 5.0.0
 */

/**
 * End of jsdoc
 */

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }


var DataCache = /*#__PURE__*/function () {
  function DataCache() {
    _classCallCheck(this, DataCache);

    this._handleMutationAdd = function (eventDetail) {
      var _a, _b;

      var self = this;
      var eventDetailBeforeKeys = eventDetail[DataCache._BEFOREKEYS];
      var eventDetailKeys = eventDetail[DataCache._KEYS];
      var eventDetailKeysArray = [];
      eventDetailKeys.forEach(function (key) {
        eventDetailKeysArray.push(key);
      });
      var eventDetailData = eventDetail[DataCache._DATA];
      var eventDetailMetadata = eventDetail[DataCache._METADATA];
      var eventDetailIndexes = eventDetail[DataCache._INDEXES];

      if (eventDetailKeysArray && eventDetailKeysArray.length > 0) {
        if (eventDetailIndexes) {
          eventDetailKeysArray.forEach(function (key, index) {
            self._items.splice(eventDetailIndexes[index], 0, new self.Item(eventDetailMetadata[index], eventDetailData[index]));
          });
        } else if (eventDetailBeforeKeys) {
          var eventDetailBeforeKeysClone = Object.assign([], eventDetailBeforeKeys);
          var eventDetailKeysClone = Object.assign(new Set(), eventDetail[DataCache._KEYS]);
          var eventDetailDataClone = Object.assign([], eventDetail[DataCache._DATA]);
          var eventDetailMetadataClone = Object.assign([], eventDetail[DataCache._METADATA]); // first find all the beforekeys which are not in our cache, are not null, and are not in the mutation event

          var outOfRangeKeys = [];
          var i, j, key, findKey, outOfRange;

          for (i = 0; i < eventDetailBeforeKeys.length; i++) {
            key = eventDetailBeforeKeys[i];
            outOfRange = true;

            if (key != null) {
              for (j = 0; j < eventDetailKeysArray.length; j++) {
                if (oj.Object.compareValues(eventDetailKeysArray[j], key)) {
                  outOfRange = false;
                  break;
                }
              }

              if (outOfRange) {
                for (j = 0; j < self._items.length; j++) {
                  if (oj.Object.compareValues((_b = (_a = self._items[j]) === null || _a === void 0 ? void 0 : _a.metadata) === null || _b === void 0 ? void 0 : _b.key, key)) {
                    outOfRange = false;
                    break;
                  }
                }
              }
            } else {
              outOfRange = false;
            }

            if (outOfRange) {
              outOfRangeKeys.push(key);
            }
          } // push all keys chained to the outOfRangeKeys to the array


          var keysToCheck = eventDetailBeforeKeys.length;

          while (keysToCheck > 0) {
            for (i = 0; i < eventDetailBeforeKeys.length; i++) {
              findKey = eventDetailBeforeKeys[i];

              if (outOfRangeKeys.indexOf(findKey) >= 0) {
                outOfRangeKeys.push(findKey);
                break;
              }
            }

            keysToCheck--;
          } // remove all out of range keys and their chained keys


          for (i = eventDetailBeforeKeysClone.length - 1; i >= 0; i--) {
            if (outOfRangeKeys.indexOf(eventDetailBeforeKeysClone[i]) >= 0) {
              delete eventDetailBeforeKeysClone[i];
              eventDetailKeysClone.delete(eventDetailBeforeKeysClone[i]);
              delete eventDetailDataClone[i];
              delete eventDetailMetadataClone[i];
            }
          } // insert them into our cache


          eventDetailBeforeKeysClone.forEach(function (beforeKey, beforeKeyIndex) {
            var _a, _b;

            if (beforeKey === null) {
              self._items.push(new self.Item(eventDetailMetadata[beforeKeyIndex], eventDetailData[beforeKeyIndex]));
            } else {
              for (i = 0; i < self._items.length; i++) {
                if (oj.Object.compareValues((_b = (_a = self._items[i]) === null || _a === void 0 ? void 0 : _a.metadata) === null || _b === void 0 ? void 0 : _b.key, beforeKey)) {
                  self._items.splice(i, 0, new self.Item(eventDetailMetadata[beforeKeyIndex], eventDetailData[beforeKeyIndex]));

                  break;
                }
              }
            }
          });
        } else {
          // we don't have index or beforeKeys so we need to sort to figure out where to insert the keys.
          // if there is no sort, then we don't know where the rows go so just push them in at the end.
          if (self._fetchParams && self._fetchParams.sortCriteria != null) {
            var sortCriteria = self._fetchParams.sortCriteria;

            if (sortCriteria) {
              var comparator = self._getSortComparator(sortCriteria);

              var _i, currentData, currentCompare;

              var insertedIndexes = [];
              eventDetailData.forEach(function (data, index) {
                for (_i = 0; _i < self._items.length; _i++) {
                  currentData = self._items[_i].data;
                  currentCompare = comparator(data, currentData);

                  if (currentCompare < 0) {
                    // found insertion point
                    self._items.splice(_i, 0, new self.Item(eventDetailMetadata[index], eventDetailData[index]));

                    insertedIndexes.push(index);
                    break;
                  }
                }
              }); // inserted all the rows we haven't inserted yet at the end

              eventDetailData.forEach(function (data, index) {
                if (insertedIndexes.indexOf(index) < 0) {
                  self._items.push(new self.Item(eventDetailMetadata[index], eventDetailData[index]));
                }
              });
            }
          } else {
            eventDetailData.forEach(function (data, index) {
              self._items.push(new self.Item(eventDetailMetadata[index], eventDetailData[index]));
            });
          }
        }
      }
    };

    this._handleMutationRemove = function (eventDetail) {
      var self = this;
      var eventDetailKeys = eventDetail[DataCache._KEYS];

      if (eventDetailKeys && eventDetailKeys.size > 0) {
        var i;
        eventDetailKeys.forEach(function (key) {
          for (i = self._items.length - 1; i >= 0; i--) {
            if (oj.Object.compareValues(self._items[i].metadata.key, key)) {
              self._items.splice(i, 1);

              break;
            }
          }
        });
      }
    };

    this._handleMutationUpdate = function (eventDetail) {
      var self = this;
      var eventDetailKeys = eventDetail[DataCache._KEYS];
      var eventDetailData = eventDetail[DataCache._DATA];
      var eventDetailMetadata = eventDetail[DataCache._METADATA];

      if (eventDetailData && eventDetailData.length > 0) {
        var i,
            index = 0;
        eventDetailKeys.forEach(function (key) {
          for (i = self._items.length - 1; i >= 0; i--) {
            if (oj.Object.compareValues(self._items[i].metadata.key, key)) {
              self._items.splice(i, 1, new self.Item(eventDetailMetadata[index], eventDetailData[index]));

              break;
            }
          }

          index++;
        });
      }
    };

    this.Item = /*#__PURE__*/function () {
      function _class(metadata, data) {
        _classCallCheck(this, _class);

        this.metadata = metadata;
        this.data = data;
        this[DataCache._METADATA] = metadata;
        this[DataCache._DATA] = data;
      }

      return _class;
    }();

    this.FetchByKeysResults = /*#__PURE__*/function () {
      function _class2(fetchParameters, results) {
        _classCallCheck(this, _class2);

        this.fetchParameters = fetchParameters;
        this.results = results;
        this[DataCache._FETCHPARAMETERS] = fetchParameters;
        this[DataCache._RESULTS] = results;
      }

      return _class2;
    }();

    this.FetchByOffsetResults = /*#__PURE__*/function () {
      function _class3(fetchParameters, results, done) {
        _classCallCheck(this, _class3);

        this.fetchParameters = fetchParameters;
        this.results = results;
        this.done = done;
        this[DataCache._FETCHPARAMETERS] = fetchParameters;
        this[DataCache._RESULTS] = results;
        this[DataCache._DONE] = done;
      }

      return _class3;
    }();

    this._items = [];
  }

  _createClass(DataCache, [{
    key: "addListResult",
    value: function addListResult(result) {
      var self = this;
      var items = [];
      result.value.data.forEach(function (data, index) {
        items.push(new self.Item(result.value.metadata[index], data));
      });
      this._items = this._items.concat(items);
      this._done = result.done;
    }
  }, {
    key: "getDataList",
    value: function getDataList(params, offset) {
      this._fetchParams = params;
      var fetchSize = 25;

      if (params.size != null) {
        if (params.size == -1) {
          fetchSize = this.getSize();
        } else {
          fetchSize = params.size;
        }
      }

      var items = this._items.slice(offset, offset + fetchSize);

      var data = [];
      var metadata = [];
      items.forEach(function (item) {
        data.push(item.data);
        metadata.push(item.metadata);
      });
      return {
        fetchParameters: params,
        data: data,
        metadata: metadata
      };
    }
  }, {
    key: "getDataByKeys",
    value: function getDataByKeys(params) {
      var self = this;
      var results = new Map();

      if (params && params.keys) {
        var i;
        params.keys.forEach(function (key) {
          for (i = 0; i < self._items.length; i++) {
            if (self._items[i].metadata.key == key) {
              results.set(key, self._items[i]);
              break;
            }
          }
        });
      }

      return new this.FetchByKeysResults(params, results);
    }
  }, {
    key: "getDataByOffset",
    value: function getDataByOffset(params) {
      var self = this;
      var results = [];
      var done = true;

      if (params) {
        results = self._items.slice(params.offset, params.offset + params.size);
      }

      return new this.FetchByOffsetResults(params, results, done);
    }
  }, {
    key: "processMutations",
    value: function processMutations(detail) {
      if (detail.remove != null) {
        this._handleMutationRemove(detail.remove);
      }

      if (detail.add != null) {
        this._handleMutationAdd(detail.add);
      }

      if (detail.update != null) {
        this._handleMutationUpdate(detail.update);
      }
    }
  }, {
    key: "reset",
    value: function reset() {
      this._items = [];
      this._done = false;
    }
  }, {
    key: "getSize",
    value: function getSize() {
      return this._items.length;
    }
  }, {
    key: "isDone",
    value: function isDone() {
      return this._done;
    }
  }, {
    key: "_getSortComparator",
    value: function _getSortComparator(sortCriteria) {
      var self = this;
      return function (x, y) {
        var i, direction, attribute, comparator, xval, yval;

        for (i = 0; i < sortCriteria.length; i++) {
          direction = sortCriteria[i][DataCache._DIRECTION];
          attribute = sortCriteria[i][DataCache._ATTRIBUTE];
          comparator = null;
          xval = self._getVal(x, attribute);
          yval = self._getVal(y, attribute);
          var compareResult = 0;
          var strX = typeof xval === 'string' ? xval : new String(xval).toString();
          var strY = typeof yval === 'string' ? yval : new String(yval).toString();

          if (direction == 'ascending') {
            compareResult = strX.localeCompare(strY, undefined, {
              numeric: true,
              sensitivity: 'base'
            });
          } else {
            compareResult = strY.localeCompare(strX, undefined, {
              numeric: true,
              sensitivity: 'base'
            });
          }

          if (compareResult != 0) {
            return compareResult;
          }
        }

        return 0;
      };
    }
  }, {
    key: "_getVal",
    value: function _getVal(val, attr) {
      if (typeof attr == 'string') {
        var dotIndex = attr.indexOf('.');

        if (dotIndex > 0) {
          var startAttr = attr.substring(0, dotIndex);
          var endAttr = attr.substring(dotIndex + 1);
          var subObj = val[startAttr];

          if (subObj) {
            return this._getVal(subObj, endAttr);
          }
        }
      }

      if (typeof val[attr] == 'function') {
        return val[attr]();
      }

      return val[attr];
    }
  }]);

  return DataCache;
}();

DataCache._DATA = 'data';
DataCache._METADATA = 'metadata';
DataCache._ITEMS = 'items';
DataCache._BEFOREKEYS = 'addBeforeKeys';
DataCache._KEYS = 'keys';
DataCache._INDEXES = 'indexes';
DataCache._FROM = 'from';
DataCache._OFFSET = 'offset';
DataCache._REFRESH = 'refresh';
DataCache._MUTATE = 'mutate';
DataCache._SIZE = 'size';
DataCache._FETCHPARAMETERS = 'fetchParameters';
DataCache._SORTCRITERIA = 'sortCriteria';
DataCache._DIRECTION = 'direction';
DataCache._ATTRIBUTE = 'attribute';
DataCache._VALUE = 'value';
DataCache._DONE = 'done';
DataCache._RESULTS = 'results';
DataCache._CONTAINSPARAMETERS = 'containsParameters';
DataCache._DEFAULT_SIZE = 25;
DataCache._CONTAINSKEYS = 'containsKeys';
DataCache._FETCHBYKEYS = 'fetchByKeys';
DataCache._FETCHBYOFFSET = 'fetchByOffset';
DataCache._FETCHFIRST = 'fetchFirst';
DataCache._FETCHATTRIBUTES = 'attributes';
oj['DataCache'] = DataCache;









/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 *
 * @since 4.2.0
 * @export
 * @interface DataProviderAddOperationEventDetail
 * @extends DataProviderOperationEventDetail
 * @ojsignature {target: "Type",
 *               value: "interface DataProviderAddOperationEventDetail<K, D> extends DataProviderOperationEventDetail<K, D>",
 *               genericParameters: [{"name": "K", "description": "Type of Key"}, {"name": "D", "description": "Type of Data"}]}
 */

/**
 * Optional set of keys for items located after the items involved in the operation. They are relative to after the
 * operation was completed and not the original array. If null and index not specified then insert at the end.
 *
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderAddOperationEventDetail
 * @instance
 * @name afterKeys
 * @type {Set.<any>}
 * @ojdeprecated {since: '6.0.0', description: 'Use addBeforeKeys instead.  addBeforeKeys is an Array instead of a Set.'}
 * @ojsignature {target: "Type",
 *               value: "?Set<K>"}
 */

/**
 * Optional array of keys for items located after the items involved in the operation. They are relative to after the
 * operation was completed and not the original array.If null and index not specified then insert at the end.
 *
 *
 * @since 6.0.0
 * @export
 * @expose
 * @memberof DataProviderAddOperationEventDetail
 * @instance
 * @name addBeforeKeys
 * @type {Array.<any>}
 * @ojsignature {target: "Type",
 *               value: "?K[]"}
 */

/**
 * Keys of parents for the items involved in the operation.
 * <p>If this property is undefined, the items involved in the operation have no parent.
 * This is the case for non-hierarchical DataProvider implementatons such as ArrayDataProvider.</p>
 * <p>If this property has a value, each entry in the array represents the parent key of
 * the corresponding item.  A parent key of null indicates that the item is at the root level.
 * TreeDataProvider implementations should always set this property.</p>
 *
 *
 * @since 6.0.0
 * @export
 * @expose
 * @memberof DataProviderAddOperationEventDetail
 * @instance
 * @name parentKeys
 * @type {Array.<any>}
 * @ojsignature {target: "Type",
 *               value: "?K[]"}
 */

/**
 * End of jsdoc
 */

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var DataProviderMutationEvent = /*#__PURE__*/function (_GenericEvent) {
  _inherits(DataProviderMutationEvent, _GenericEvent);

  var _super = _createSuper(DataProviderMutationEvent);

  function DataProviderMutationEvent(detail) {
    _classCallCheck(this, DataProviderMutationEvent);

    var eventOptions = {};
    eventOptions[DataProviderMutationEvent._DETAIL] = detail;
    return _super.call(this, 'mutate', eventOptions);
  }

  return DataProviderMutationEvent;
}(GenericEvent);

DataProviderMutationEvent._DETAIL = 'detail';
oj.DataProviderMutationEvent = DataProviderMutationEvent;
oj['DataProviderMutationEvent'] = DataProviderMutationEvent;



/**
 * Interface oj.DataProviderMutationEventDetail
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @since 4.2.0
 * @export
 * @interface DataProviderMutationEventDetail
 * @ojsignature {target: "Type",
 *               value: "interface DataProviderMutationEventDetail<K, D>",
 *               genericParameters: [{"name": "K", "description": "Type of Key"}, {"name": "D", "description": "Type of Data"}]}
 * @classdesc This interface defines the payload of the {@link DataProviderMutationEvent} and specifies as one atomic event all the mutation operations which
 * occurred. The keys for each operation must be disjoint from each other, e.g. for example
 * an add and remove cannot occur on the same item. In addition, any indexes specified must
 * be monotonically increasing.
 */

/**
 * Optional add operation detail
 *
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEventDetail
 * @instance
 * @name add
 * @type {DataProviderAddOperationEventDetail}
 * @ojsignature {target: "Type",
 *               value: "?DataProviderAddOperationEventDetail<K, D>"}
 */

/**
 * Optional remove operation detail
 *
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEventDetail
 * @instance
 * @name remove
 * @type {DataProviderOperationEventDetail}
 * @ojsignature {target: "Type",
 *               value: "?DataProviderOperationEventDetail<K, D>"}
 */

/**
 * Optional update operation detail
 *
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEventDetail
 * @instance
 * @name update
 * @type {DataProviderOperationEventDetail}
 * @ojsignature {target: "Type",
 *               value: "?DataProviderOperationEventDetail<K, D>"}
 */

/**
 * End of jsdoc
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 *
 * @since 4.2.0
 * @export
 * @final
 * @class DataProviderMutationEvent
 * @implements Event
 * @classdesc Mutation event dispatched by {@link DataProvider}
 * @param {DataProviderMutationEventDetail} detail the event detail
 * @ojsignature [{target: "Type",
 *               value: "class DataProviderMutationEvent<K, D> implements Event",
 *               genericParameters: [{"name": "K", "description": "Type of Key"}, {"name": "D", "description": "Type of Data"}]},
 *               {target: "Type",
 *               value: "DataProviderMutationEventDetail<K, D>",
 *               for: "detail"}]
 */

/**
 * Event detail
 *
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name detail
 * @type {DataProviderMutationEventDetail}
 * @ojsignature {target: "Type",
 *               value: "DataProviderMutationEventDetail<K, D>"}
 */

/**
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name type
 * @type {string}
 */

/**
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name bubbles
 * @type {boolean}
 */

/**
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name cancelable
 * @type {boolean}
 */

/**
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name cancelBubble
 * @type {boolean}
 */

/**
 *
 * @since 6.0.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name composed
 * @type {boolean}
 */

/**
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name currentTarget
 * @type {EventTarget}
 */

/**
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name defaultPrevented
 * @type {boolean}
 */

/**
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name eventPhase
 * @type {number}
 */

/**
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name isTrusted
 * @type {boolean}
 */

/**
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name returnValue
 * @type {boolean}
 */

/**
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name srcElement
 * @type {Element | null}
 */

/**
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name target
 * @type {EventTarget}
 */

/**
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name timeStamp
 * @type {number}
 */

/**
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name scoped
 * @type {boolean}
 */

/**
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name initEvent
 * @ojsignature {target: "Type",
 *               value: "(eventTypeArg: string, canBubbleArg: boolean, cancelableArg: boolean) => void"}
 */

/**
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name preventDefault
 * @ojsignature {target: "Type",
 *               value: "() => void"}
 */

/**
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name stopImmediatePropagation
 * @ojsignature {target: "Type",
 *               value: "() => void"}
 */

/**
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name stopPropagation
 * @ojsignature {target: "Type",
 *               value: "() => void"}
 */

/**
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name deepPath
 * @ojsignature {target: "Type",
 *               value: "() => EventTarget[]"}
 */

/**
 *
 * @since 9.0.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name composedPath
 * @ojsignature {target: "Type",
 *               value: "() => EventTarget[]"}
 */

/**
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name AT_TARGET
 * @type {number}
 */

/**
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name BUBBLING_PHASE
 * @type {number}
 */

/**
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name CAPTURING_PHASE
 * @type {number}
 */

/**
 *
 * @since 6.0.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name NONE
 * @type {number}
 */

/**
 * End of jsdoc
 */





/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 *
 * @since 4.2.0
 * @export
 * @interface DataProviderOperationEventDetail
 * @ojsignature {target: "Type",
 *               value: "interface DataProviderOperationEventDetail<K, D>",
 *               genericParameters: [{"name": "K", "description": "Type of Key"}, {"name": "D", "description": "Type of Data"}]}
 * @classdesc Defines the details for a particular operation in an {@link DataProviderMutationEventDetail}
 */

/**
 * keys of items involved in the operation
 *
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderOperationEventDetail
 * @instance
 * @name keys
 * @type {Set.<any>}
 * @ojsignature {target: "Type",
 *               value: "Set<K>"}
 */

/**
 * Optional metadata of items involved in the operation
 *
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderOperationEventDetail
 * @instance
 * @name metadata
 * @type {Array.<ItemMetadata>}
 * @ojsignature {target: "Type",
 *               value: "?Array<ItemMetadata<K>>"}
 */

/**
 * Optional data of items involved in the operation
 *
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderOperationEventDetail
 * @instance
 * @name data
 * @type {Array.<Object>}
 * @ojsignature {target: "Type",
 *               value: "?D[]"}
 */

/**
 * Optional indexes of items involved in the operation. Indices are with respect to the DataProvider
 * with only its implicit sort applied. Essentially, indices are the global indices (except for TreeDataProvider, please see
 * the note below), not the indices with respect to whatever query (which might have its own sorting or filtering)
 * fetched the items.
 *
 * <p>For 'add' operation the indexes are relative to after the
 * operation was completed and not the original dataset.</p>
 *
 * <p>For 'update' operation the indexes are relative to after the
 * operation was completed and not the original dataset.</p>
 *
 * <p>For 'remove' operation the indexes are relative to the original dataset.</p>
 *
 * <p>Note: With respect to TreeDataProvider, the index is the index at the level where the mutation occurs.
 * That is, the index of the node among its siblings.</p>
 * <p> Optimization can be achieved by specifying indexes for mutation events. </p>
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderOperationEventDetail
 * @instance
 * @name indexes
 * @type {Array.<number>}
 * @ojsignature {target: "Type",
 *               value: "?number[]"}
 * @ojtsexample <caption>Example to illustrate indexes from array mutations</caption>
 * let data = [{ id: 1, name: 'Amy Bartlet', title: 'Vice President' },
 *             { id: 2, name: 'Annett Barnes', title: 'Individual  Contributer' },
 *             { id: 3, name: 'Bobby Fisher', title: 'Individual Contributer' }];
 * let observableArray = ko.observableArray(data);
 * let dataProvider = new ArrayDataProvider(ko.observableArray(data), { keyAttributes: 'id' });
 *
 * let listener = function(event) {
 *  // Print DataProviderEventDetail
 * };
 *
 * dataProvider.addEventListener("mutate", listener);
 *
 * observableArray.push({ id: 4, name: âJohn schully', title: âManager' });
 * // Then the DataProviderOperationEventDetail will have Indexes as [3]
 *
 * observableArray.splice(2, 1, { id: 5, name: âScott Jhonson', title: âPresident' });
 * // Then the DataProviderOperationEventDetail will have Indexes as [2]
 * @ojtsexample <caption>Example to illustrate indexes with respect to ArrayTreeDataProvider</caption>
 *
 * let dataArray = [{
 *                    title: "Amy Bartlet",
 *                    id: "100"
 *                  },
 *                  {
 *                    title: "Scott Fisher",
 *                    id: "101",
 *                    children: [{
 *                                 title: "John Fisher",
 *                                 id: "102"
 *                               },
 *                               {
 *                                 title: "Bobby Fisher",
 *                                 id: "103"
 *                               }]
 *                  },
 *                  {
 *                    title: "Annett Barnes",
 *                    id: "104"
 *                  }];
 *
 * createObservableArrayTree(data: Array<any>) {
 *   let array = <any[]>[];
 *   let observableArray = ko.observableArray(array);
 *   for (let i = 0; i < data.length; i++) {
 *     let newItem = data[i];
 *     if (data[i].children) {
 *       newItem.children = this.createObservableArrayTree(data[i].children);
 *     }
 *     observableArray.push(newItem);
 *   }
 *   return observableArray;
 * }
 *
 * let observableArrayTree = createObservableArrayTree(dataArray);
 * let dataProvider = new ArrayTreeDataProvider(observableArrayTree, { keyAttributes: 'id' });
 * dataProvider.addEventListener('mutate', ((event: CustomEvent<any>) => {
 *   console.log(event.detail);
 * }) as EventListener);
 * let index = 1;
 *
 * observableArrayTree()[1].children.splice(index, 1);
 *
 * // Output will be // { 'add': null, 'remove' : { 'indexes': [1] }, 'update': null}
 * // Here the index 1 refers to the object with id '103'.
 */

/**
 * End of jsdoc
 */

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var DataProviderRefreshEvent = /*#__PURE__*/function (_GenericEvent) {
  _inherits(DataProviderRefreshEvent, _GenericEvent);

  var _super = _createSuper(DataProviderRefreshEvent);

  function DataProviderRefreshEvent() {
    _classCallCheck(this, DataProviderRefreshEvent);

    return _super.call(this, 'refresh');
  }

  return DataProviderRefreshEvent;
}(GenericEvent);

oj.DataProviderRefreshEvent = DataProviderRefreshEvent;
oj['DataProviderRefreshEvent'] = DataProviderRefreshEvent;



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @since 4.1.0
 * @export
 * @final
 * @class DataProviderRefreshEvent
 * @implements Event
 * @classdesc Refresh Event dispatched by the {@link DataProvider}. This event is fired when
 * the data has been refreshed and components need to re-fetch the data.
 * @ojsignature {target: "Type",
 *               value: "class DataProviderRefreshEvent implements Event"}
 */

/**
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name type
 * @type {string}
 */

/**
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name bubbles
 * @type {boolean}
 */

/**
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name cancelable
 * @type {boolean}
 */

/**
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name cancelBubble
 * @type {boolean}
 */

/**
 *
 * @since 6.0.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name composed
 * @type {boolean}
 */

/**
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name currentTarget
 * @type {EventTarget}
 */

/**
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name defaultPrevented
 * @type {boolean}
 */

/**
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name eventPhase
 * @type {number}
 */

/**
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name isTrusted
 * @type {boolean}
 */

/**
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name returnValue
 * @type {boolean}
 */

/**
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name srcElement
 * @type {Element | null}
 */

/**
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name target
 * @type {EventTarget}
 */

/**
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name timeStamp
 * @type {number}
 */

/**
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name scoped
 * @type {boolean}
 */

/**
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name initEvent
 * @ojsignature {target: "Type",
 *               value: "(eventTypeArg: string, canBubbleArg: boolean, cancelableArg: boolean) => void"}
 */

/**
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name preventDefault
 * @ojsignature {target: "Type",
 *               value: "() => void"}
 */

/**
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name stopImmediatePropagation
 * @ojsignature {target: "Type",
 *               value: "() => void"}
 */

/**
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name stopPropagation
 * @ojsignature {target: "Type",
 *               value: "() => void"}
 */

/**
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name deepPath
 * @ojsignature {target: "Type",
 *               value: "() => EventTarget[]"}
 */

/**
 *
 * @since 9.0.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name composedPath
 * @ojsignature {target: "Type",
 *               value: "() => EventTarget[]"}
 */

/**
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name AT_TARGET
 * @type {number}
 */

/**
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name BUBBLING_PHASE
 * @type {number}
 */

/**
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name CAPTURING_PHASE
 * @type {number}
 */

/**
 *
 * @since 6.0.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name NONE
 * @type {number}
 */

/**
 * End of jsdoc
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 *
 * @since 4.2.0
 * @export
 * @interface DataProvider
 * @extends EventTarget
 * @ojsignature {target: "Type",
 *               value: "interface DataProvider<K, D> extends EventTarget",
 *               genericParameters: [{"name": "K", "description": "Type of Key"}, {"name": "D", "description": "Type of Data"}]}
 * @classdesc
 * The DataProvider interface defines the contract by which JET components retrieve data.  By exposing this contract as an interface, we allow for a range of possible data retrieval strategies, while shielding components from dependencies on any one particular implementation choice.  For example, some DataProvider implementations may get data from a local array. Others may retrieve data from a remote endpoint.  In either case, the consuming component simply interacts with the DataProvider interface and is unaware of the of the specific data retrieval approach.
 * <p>
 * The DataProvider contract has the following characteristics:
 * <ul>
 *   <li>Asynchronous: Even in cases where data is available synchronously (eg. the data is already in a local array), the DataProvider contract provides access to the data via asynchronous APIs.  As such, consumers are able to interact with the data in a consistent manner, regardless of how the data is retrieved.</li>
 *   <li>Stateless: The DataProviderâs data retrieval APIs are inherently stateless.  Attempts to retrieve data are atomic and are not impacted by previous interactions with the DataProvider.  This avoids potential brittleness when multiple consumers are interacting with the same DataProvider instance.</li>
 *   <li>Key-based: In order to ensure reliable interactions with the data set, the DataProvider contract assumes that each data item can be accessed via a unique key.  While the index can be used as a key if no viable key is available, stable keys should be used whenever possible.</li>
 *   <li>Read only (with mutation notifications):  The base DataProvider contract does not include mutation APIs.  That is, the DataProvider contract defines APIs for reading data, not for writing data.  However, DataProvider implementations may expose their own type-specific mutation APIs, and the DataProvider contract defines an event-based mechanism for notifying consumers of data changes.</li>
 *   <li>Filterable:  When requesting data from a DataProvider, consumers are able to specify filter criteria that area used to restrict the data set to those items that match the specified criteria.</li>
 *   <li>Sortable:  When requesting data from a DataProvider, consumers are able to specify sort criteria that impact the ordering of the provided data.</li>
 * </ul>
 * <p>
 * The DataProvider contract exposes three ways for consumers to retrieve data:
 * <ul>
 *   <li>Iteration: the {@link DataProvider#fetchFirst} method returns an AsyncIterable that can be used to iterate over the entire data set.  Consumers typically use this when rendering a data set.</li>
 *   <li>By keys: the {@link DataProvider#fetchByKeys} method allows specific items to be retrieved by key.  Consumers typically use this when interacting with a subset of data (eg. for retrieving the values of the selected rows in a table component).</li>
 *   <li>By offset: the {@link DataProvider#fetchByOffset} method allows a specific block of data to be retrieved by specifying an offset and size. Consumers typically use this for paging purposes.</li>
 * </ul>
 * A related interface is {@link TreeDataProvider}, which extends DataProvider. TreeDataProviders represent hierarchical data, whereas (non-tree) DataProviders represent data sets that are single-level.
 * <p>
 * JET provides several out-of-the-box DataProvider implementations that support the most common use cases.
 * <br>
 * <h4 id="description:DataProviderImplementations" class="name">
 *   Implementations
 * </h4>
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Class</th>
 *       <th>Description</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td>
 *         {@link ArrayDataProvider}
 *       </td>
 *       <td>
 *         Basic DataProvider implementation that takes the data from an Javascript array or ko.observableArray.
 *       </td>
 *     </tr>
 *     <tr>
 *       <td>
 *         {@link ArrayTreeDataProvider}
 *       </td>
 *       <td>
 *         Basic TreeDataProvider implementation that takes the data from an Javascript array or ko.observableArray that contains "children" property for subtree data.
 *       </td>
 *     </tr>
 *     <tr>
 *       <td>
 *         {@link CollectionDataProvider}
 *       </td>
 *       <td>
 *         DataProvider implementation that takes the data from a {@link oj.Collection} object. {@link oj.Collection} is an older class that represents data usually comes from external source such as a REST.
 *       </td>
 *     </tr>
 *     <tr>
 *       <td>
 *         {@link DeferredDataProvider}
 *       </td>
 *       <td>
 *         DataProvider implementation that takes the data from a promise that resolves to another DataProvider object.
 *       </td>
 *     </tr>
 *     <tr>
 *       <td>
 *         {@link FlattenedTreeDataProviderView}
 *       </td>
 *       <td>
 *         DataProvider implementation that wraps a TreeDataProvider object and "flattens" the hierarchical data into a single level.
 *       </td>
 *     </tr>
 *     <tr>
 *       <td>
 *         {@link IndexerModelTreeDataProvider}
 *       </td>
 *       <td>
 *         TreeDataProvider implementation that takes the data from an Javascript array that contains "children" property for subtree data. This class also implements the {@link oj.IndexerModel} interface.
 *       </td>
 *     </tr>
 *     <tr>
 *       <td>
 *         {@link ListDataProviderView}
 *       </td>
 *       <td>
 *         DataProvider implementation that wraps another DataProvider, adding data manipulation functionality such as filtering, sorting and field mapping.
 *       </td>
 *     </tr>
 *     <tr>
 *       <td>
 *         {@link PagingDataProviderView}
 *       </td>
 *       <td>
 *         DataProvider implementation that wraps another DataProvider object. This class also implements the {@link oj.PagingModel} interface so that it can be used by components that support paging.
 *       </td>
 *     </tr>
 *     <tr>
 *       <td>
 *         {@link TreeDataProviderView}
 *       </td>
 *       <td>
 *         TreeDataProvider implementation that wraps another TreeDataProvider object and exposes additional APIs. This class provides field mapping functionality for the wrapped TreeDataProvider.
 *       </td>
 *     </tr>
 *   </tbody>
 * </table>
 * <h4 id="description:DataProviderClassHierarchy" class="name">
 *   Class Hierarchy
 * </h4>
 * <ul>
 *   <li><b>Interface {@link DataProvider}</b></li>
 *   <ul>
 *     <li>{@link ArrayDataProvider}</li>
 *     <li>{@link CollectionDataProvider}</li>
 *     <li>{@link DeferredDataProvider}</li>
 *     <li>{@link FlattenedTreeDataProviderView}</li>
 *     <li>{@link ListDataProviderView}</li>
 *     <li>{@link PagingDataProviderView}</li>
 *     <li><b>Interface {@link TreeDataProvider}</b></li>
 *       <ul>
 *         <li>{@link ArrayTreeDataProvider}</li>
 *         <li>{@link IndexerModelTreeDataProvider}</li>
 *         <li>{@link TreeDataProviderView}</li>
 *       </ul>
 *     </li>
 *   </ul>
 * </ul>
 * </p><p>
 *
 * <h3 id="events-section">
 *   Events
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#events-section"></a>
 * </h3>
 * Implementations can fire the following events by creating an instance of the event class and passing the event payload in the constructor.
 * <h4 id="event:DataProviderMutationEvent" class="name">
 *   {@link DataProviderMutationEvent}
 * </h4>
 * This event is fired when items have been added or removed from the data.
 * <p>
 * Event payloads should implement the {@link DataProviderMutationEventDetail} interface.
 * </p><p>
 * Consumers can add an event listener for the "mutate" event type on the DataProvider object.
 * </p>
 * <i>Example of implementation firing an DataProviderMutationEvent for removed items:</i>
 * <pre class="prettyprint"><code>let removeDetail = {data: removedDataArray,
 *                     indexes: removedIndexArray,
 *                     keys: removedKeySet,
 *                     metadata: removedMetadataArray};
 * this.dispatchEvent(new DataProviderMutationEvent({remove: removeDetail}));
 * </code></pre>
 *
 * <i>Example of consumer listening for the "mutate" event type:</i>
 * <pre class="prettyprint"><code>let listener = function(event) {
 *   if (event.detail.remove) {
 *     let removeDetail = event.detail.remove;
 *     // Handle removed items
 *   }
 * };
 * dataProvider.addEventListener("mutate", listener);
 * </code></pre>
 * <h4 id="event:DataProviderRefreshEvent" class="name">
 *   {@link DataProviderRefreshEvent}
 * </h4>
 * This event is fired when the data has been refreshed and components need to re-fetch the data.
 * <p>
 * This event contains no additional event payload.
 * </p><p>
 * Consumers can add an event listener for the "refresh" event type on the DataProvider object.
 * </p>
 * <i>Example of consumer listening for the "refresh" event type:</i>
 * <pre class="prettyprint"><code>let listener = function(event) {
 * };
 * dataProvider.addEventListener("refresh", listener);
 * </code></pre>
 * <h3 id="custom-implementations-section">
 *   Custom Implementations
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#custom-implementations-section"></a>
 * </h3>
 * Applications can also create their own implementations of the DataProvider interface and use them with JET components.  For example, an application can create a DataProvider implementation
 * that fetches data from a REST endpoint.
 * </p><p>
 * Implementation classes must implement all of the interface methods.  It should also fire the DataProvider events when appropriate, so that JET components or other consumers can respond to data change accordingly.
 * </p>
 * <p>
 * A generic implementation of {@link DataProvider#fetchByKeys} and {@link DataProvider#containsKeys} is available from {@link FetchByKeysMixin}
 * which can be used in custom implementations of DataProvider.
 * It is for convenience and may not provide the most efficient implementation for your data provider.
 * Classes that implement the DataProvider interface are encouraged to provide a more efficient implementation.
 * </p>
 */
oj.DataProvider = function () {};
/**
 * Get an asyncIterator which can be used to fetch a block of data.
 *
 *
 * @since 4.2.0
 * @param {FetchListParameters=} params fetch parameters
 * @return {AsyncIterable.<FetchListResult>} AsyncIterable with {@link FetchListResult}
 * @see {@link https://github.com/tc39/proposal-async-iteration} for further information on AsyncIterable.
 * @export
 * @expose
 * @memberof DataProvider
 * @instance
 * @method
 * @name fetchFirst
 * @ojsignature {target: "Type",
 *               value: "(parameters?: FetchListParameters<D>): AsyncIterable<FetchListResult<K, D>>"}
 * @ojtsexample <caption>Get an asyncIterator and then fetch first block of data by executing next() on the iterator. Subsequent blocks can be fetched by executing next() again.</caption>
 * let asyncIterator = dataprovider.fetchFirst(options)[Symbol.asyncIterator]();
 * let result = await asyncIterator.next();
 * let value = result.value;
 * let data = value.data;
 * let keys = value.metadata.map(function(val) {
 *   return val.key;
 * });
 * // true or false for done
 * let done = result.done;
 */

/**
 * Determines whether this DataProvider defines a certain feature.
 *
 *
 * @since 4.2.0
 * @param {string} capabilityName capability name. Defined capability names are:
 *                  "fetchByKeys", "fetchByOffset", "sort", "fetchCapability" and "filter".
 * @return {Object} capability information or null if undefined
 * <ul>
 *   <li>If capabilityName is "fetchByKeys", returns a {@link FetchByKeysCapability} object.</li>
 *   <li>If capabilityName is "fetchByOffset", returns a {@link FetchByOffsetCapability} object.</li>
 *   <li>If capabilityName is "sort", returns a {@link SortCapability} object.</li>
 *   <li>If capabilityName is "filter", returns a {@link FilterCapability} object.</li>
 *   <li>If capabilityName is "fetchCapability", returns a {@link FetchCapability} object.</li>
 * </ul>
 * @export
 * @expose
 * @memberof DataProvider
 * @instance
 * @method
 * @name getCapability
 * @ojsignature {target: "Type",
 *               value: "(capabilityName: string): any"}
 * @ojtsexample <caption>Check what kind of fetchByKeys is defined.</caption>
 * let capabilityInfo = dataprovider.getCapability('fetchByKeys');
 * if (capabilityInfo.implementation == 'iteration') {
 *   // the DataProvider supports iteration for fetchByKeys
 *   ...
 */

/**
 * Return the total number of rows in this dataprovider
 *
 *
 * @return {Promise.<number>} Returns a Promise which resolves to the total number of rows. -1 is unknown row count.
 * @export
 * @expose
 * @memberof DataProvider
 * @instance
 * @method
 * @name getTotalSize
 * @ojtsexample <caption>Get the total rows</caption>
 * let value = await dataprovider.getTotalSize();
 * if (value == -1) {
 *   // we don't know the total row count
 * } else {
 *   // the total count
 *   console.log(value);
 */

/**
 * Fetch rows by keys. The resulting key map will only contain keys which were actually found.
 *
 *
 * @since 4.2.0
 * @param {FetchByKeysParameters} parameters fetch by key parameters
 * @return {Promise.<FetchByKeysResults>} Returns Promise which resolves to {@link FetchByKeysResults}.
 * @export
 * @expose
 * @memberof DataProvider
 * @instance
 * @method
 * @name fetchByKeys
 * @ojsignature {target: "Type",
 *               value: "(parameters : FetchByKeysParameters<K>) : Promise<FetchByKeysResults<K, D>>"}
 * @ojtsexample <caption>Fetch for keys 1001 and 556</caption>
 * let fetchKeys = [1001, 556];
 * let value = await dataprovider.fetchByKeys({keys: fetchKeys});
 * // get the data for key 1001
 * console.log(value.results.get(1001).data);
 */

/**
 * Check if there are rows containing the specified keys. The resulting key map will only contain keys which were actually found.
 *
 *
 * @since 4.2.0
 * @param {FetchByKeysParameters} parameters contains by key parameters
 * @return {Promise.<ContainsKeysResults>} Returns Promise which resolves to {@link ContainsKeysResults}.
 * @export
 * @expose
 * @memberof DataProvider
 * @instance
 * @method
 * @name containsKeys
 * @ojsignature {target: "Type",
 *               value: "(parameters : FetchByKeysParameters<K>) : Promise<ContainsKeysResults<K>>"}
 * @ojtsexample <caption>Check if keys 1001 and 556 are contained</caption>
 * let containsKeys = [1001, 556];
 * let value = await dataprovider.containsKeys({keys: containsKeys});
 * let results = value['results'];
 * if (results.has(1001)) {
 *   console.log('Has key 1001');
 * } else if (results.has(556){
 *   console.log('Has key 556');
 * }
 */

/**
 * Fetch rows by offset
 * <p>
 * A generic implementation of this method is available from {@link FetchByOffsetMixin}.
 * It is for convenience and may not provide the most efficient implementation for your data provider.
 * Classes that implement the DataProvider interface are encouraged to provide a more efficient implementation.
 * </p>
 *
 *
 * @since 4.2.0
 * @param {FetchByOffsetParameters} parameters fetch by offset parameters
 * @return {Promise.<FetchByOffsetResults>} Returns Promise which resolves to {@link FetchByOffsetResults}.
 * @export
 * @expose
 * @memberof DataProvider
 * @instance
 * @method
 * @name fetchByOffset
 * @ojsignature {target: "Type",
 *               value: "(parameters: FetchByOffsetParameters<D>): Promise<FetchByOffsetResults<K, D>>"}
 * @ojtsexample <caption>Fetch by offset 5 rows starting at index 2</caption>
 * let result = await dataprovider.fetchByOffset({size: 5, offset: 2});
 * let results = result['results'];
 * let data = results.map(function(value) {
 *   return value['data'];
 * });
 * let keys = results.map(function(value) {
 *   return value['metadata']['key'];
 * });
 */

/**
 * Returns a string that indicates if this data provider is empty.  Valid values are:
 * <ul>
 * <li>"yes": this data provider is empty.</li>
 * <li>"no": this data provider is not empty.</li>
 * <li>"unknown": it is not known if this data provider is empty until a fetch is made.</li>
 * </ul>
 *
 *
 * @since 4.2.0
 * @return {"yes" | "no" | "unknown"} string that indicates if this data provider is empty
 * @export
 * @expose
 * @memberof DataProvider
 * @instance
 * @method
 * @name isEmpty
 * @ojsignature {target: "Type",
 *               value: "(): 'yes' | 'no' | 'unknown'"}
 * @ojtsexample <caption>Check if empty</caption>
 * let isEmpty = dataprovider.isEmpty();
 * console.log('DataProvider is empty: ' + isEmpty);
 */

/**
 * Return an empty Set which is optimized to store keys
 * <p>
 * Optionally provided by certain DataProvider implementations for storing
 * keys from the DataProvider in a performant fashion. Sometimes components will
 * need to temporarily store a Set of keys provided by the DataProvider, for
 * example, in the case of maintaining a Set of selected keys. Only the DataProvider
 * is aware of the internal structure of keys such as whether they are primitives, Strings,
 * or objects and how to do identity comparisons. Therefore, the DataProvider can optionally
 * provide a Set implementation which can performantly store keys surfaced by the
 * DataProvider.
 * </p>
 *
 *
 * @since 6.2.0
 * @param {Set.<any>=} initialSet Optionally specify an initial set of keys for the Set. If not specified, then return an empty Set.
 * @return {Set.<any>} Returns a Set optimized for handling keys from the DataProvider.
 * @export
 * @expose
 * @memberof DataProvider
 * @instance
 * @method
 * @name createOptimizedKeySet
 * @ojsignature {target: "Type",
 *               value: "?(initialSet?: Set<K>): Set<K>"}
 * @ojtsexample <caption>create empty key Set</caption>
 * let keySet = dataprovider.createOptimizedKeySet();
 */

/**
 * Return an empty Map which is optimized to store key value pairs
 * <p>
 * Optionally provided by certain DataProvider implementations for storing
 * key/value pairs from the DataProvider in a performant fashion. Sometimes components will
 * need to temporarily store a Map of keys provided by the DataProvider, for
 * example, in the case of maintaining a Map of selected keys. Only the DataProvider
 * is aware of the internal structure of keys such as whether they are primitives, Strings,
 * or objects and how to do identity comparisons. Therefore, the DataProvider can optionally
 * provide a Map implementation which can performantly store key/value pairs surfaced by the
 * DataProvider.
 * </p>
 *
 *
 * @since 6.2.0
 * @param {Map.<any>=} initialMap Optionally specify an initial map of key/values for the Map. If not specified, then return an empty Map.
 * @return {Map.<any>} Returns a Map optimized for handling keys from the DataProvider.
 * @export
 * @expose
 * @memberof DataProvider
 * @instance
 * @method
 * @name createOptimizedKeyMap
 * @ojsignature {target: "Type",
 *               value: "?(initialMap?: Map<K, D>): Map<K, D>"}
 * @ojtsexample <caption>create empty key Map</caption>
 * let keyMap = dataprovider.createOptimizedKeyMap();
 */

/**
 * Add a callback function to listen for a specific event type.
 *
 *
 * @export
 * @expose
 * @memberof DataProvider
 * @instance
 * @method
 * @name addEventListener
 * @param {string} eventType The event type to listen for.
 * @param {EventListener} listener The callback function that receives the event notification.
 * @ojsignature {target: "Type",
 *               value: "(eventType: string, listener: EventListener): void"}
 */

/**
 * Remove a listener previously registered with addEventListener.
 *
 *
 * @export
 * @expose
 * @memberof DataProvider
 * @instance
 * @method
 * @name removeEventListener
 * @param {string} eventType The event type that the listener was registered for.
 * @param {EventListener} listener The callback function that was registered.
 * @ojsignature {target: "Type",
 *               value: "(eventType: string, listener: EventListener): void"}
 */

/**
 * Dispatch an event and invoke any registered listeners.
 *
 *
 * @export
 * @expose
 * @memberof DataProvider
 * @instance
 * @method
 * @name dispatchEvent
 * @param {Event} event The event object to dispatch.
 * @return {boolean} Return false if a registered listener has cancelled the event. Return true otherwise.
 * @ojsignature {target: "Type",
 *               value: "(evt: Event): boolean"}
 */

/**
 * End of jsdoc
 */





/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @export
 * @interface DedupCapability
 * @since 9.1.0
 * @ojsignature {target: "Type",
 *               value: "interface DedupCapability"}
 * @classdesc Defines the result from the DataProvider method {@link DataProvider#getCapability} for capability "dedup"
 */

/**
 * Dedup type information. Type of 'global' indicates that this DataProvider globally dedups keys and will always return unique keys. Type of
 * 'iterator' indicates that this DataProvider dedups keys during fetch iteration. Type of 'none' indicates that this DataProvider does not
 * dedup keys and may return duplicate keys.
 *
 *
 * @since 9.1.0
 * @export
 * @expose
 * @memberof DedupCapability
 * @instance
 * @name type
 * @type {string}
 * @ojsignature {target: "Type",
 *               value: "'global' | 'none' | 'iterator'"}
 */

/**
 * End of jsdoc
 */





/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @export
 * @interface EventFilteringCapability
 * @since 9.1.0
 * @ojsignature {target: "Type",
 *               value: "interface EventFilteringCapability"}
 * @classdesc Defines the result from the DataProvider method {@link DataProvider#getCapability} for capability "eventFiltering"
 */

/**
 * Mutation event filtering type information for scrolling. Note that mutation event filtering is
 * only done on remove and update events, not on add events. The reason is because the properties which
 * indicate the location of an added row are optional so it is not possible to guarantee that an add is
 * not occurring inside the already iterated rowset.
 * Type of 'global' indicates that this DataProvider globally filters mutation events. Type of
 * 'iterator' indicates that this DataProvider filters events based on rows which have been fetched via
 * fetch iteration. Type of 'none' indicates that this DataProvider does not filter mutation events.
 *
 *
 * @since 9.1.0
 * @export
 * @expose
 * @memberof EventFilteringCapability
 * @instance
 * @name type
 * @type {string}
 * @ojsignature {target: "Type",
 *               value: "'global' | 'none' | 'iterator'"}
 */

/**
 * End of jsdoc
 */





/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @since 6.1.0
 * @export
 * @interface FetchAttribute
 * @ojsignature {target: "Type",
 *               value: "interface FetchAttribute"}
 * @classdesc Defines the stucture of attribute objects in {@link FetchListParameters#attributes}
 */

/**
 * The name of the attribute or sub object or related object.
 *
 *
 * @since 6.1.0
 * @export
 * @expose
 * @memberof FetchAttribute
 * @instance
 * @name name
 * @type string
 * @ojsignature {target: "Type",
 *               value: "string"}
 */

/**
 * Optional attributes property which specifies at least which attributes of the value we want to include. If not specified then the default attributes are included. If the value
 * is a primitive then this is ignored. Expressions like "!" and "@default" are also supported. @default indicates the default attributes the implementation chooses to include in the result, by default.
 * e.g. ['!lastName', '@default'] for everything except 'lastName'. For only
 * 'firstName' and 'lastName' we'd have ['firstName', 'lastName']. Order does not matter when @default is used with field exclusions "!".
 * This can be nested. e.g. ['!lastName', '@default', {name: 'location', attributes: ['address line 1', 'address line 2']}].
 * When specified attributes, exclusions and @default are all present as in  [âidâ, âfirstNameâ, â!lastNameâ, â@defaultâ, âemailâ], this means that
 * all default attributes (including 'id', 'firstName', and 'email') except for 'lastName' will be included.
 * Also, a string value for attribute is equivalent to an object value with only name. e.g.  ['lastName', 'firstName'] is the same as [{name: 'lastName'}, {name: 'firstName'}]
 *
 *
 * @since 6.1.0
 * @export
 * @expose
 * @memberof FetchAttribute
 * @instance
 * @name attributes
 * @type {Array.<string | FetchAttribute>}
 * @ojsignature {target: "Type",
 *               value: "?Array<string | FetchAttribute>"}
 */

/**
 * end of jsdoc
 */







/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @export
 * @interface FetchByKeysCapability
 * @since 4.2.0
 * @ojsignature {target: "Type",
 *               value: "interface FetchByKeysCapability<D>",
 *               genericParameters: [{"name": "D", "description": "Type of Data"}]}
 * @classdesc Defines the result to the DataProvider method {@link DataProvider#getCapability} for capability "fetchByKeys"
 */

/**
 * The type of implementation for fetchByKeys and containsKeys methods.  Possible values are:
 * <ul>
 * <li>"iteration": the implementation uses fetchFirst iteratively to find the result</li>
 * <li>"lookup": the implementation uses direct lookup to find the result</li>
 * </ul>
 *
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof FetchByKeysCapability
 * @instance
 * @name implementation
 * @type {"iteration" | "lookup"}
 */

/**
 * End of jsdoc
 */

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var FetchByKeysMixin = /*#__PURE__*/function () {
  function FetchByKeysMixin() {
    _classCallCheck(this, FetchByKeysMixin);
  }

  _createClass(FetchByKeysMixin, [{
    key: "fetchByKeys",

    /**
     * Fetch rows by keys
     */
    value: function fetchByKeys(params) {
      var fetched = 0;
      var limit = this['getIterationLimit'] ? this['getIterationLimit']() : -1;
      var options = {};
      options['size'] = 25;
      var resultMap = new Map();
      var dataProviderAsyncIterator = this['fetchFirst'](options)[Symbol.asyncIterator]();

      function _fetchNextSet(params, dataProviderAsyncIterator, resultMap) {
        return dataProviderAsyncIterator.next().then(function (result) {
          var value = result['value'];
          var data = value['data'];
          var metadata = value['metadata'];
          var keys = metadata.map(function (metadata) {
            return metadata['key'];
          });
          var foundAllKeys = true;
          params['keys'].forEach(function (findKey) {
            if (!resultMap.has(findKey)) {
              keys.map(function (key, index) {
                if (key == findKey) {
                  resultMap.set(key, {
                    metadata: metadata[index],
                    data: data[index]
                  });
                }
              });
            }

            if (!resultMap.has(findKey)) {
              foundAllKeys = false;
            }
          }); // Keep track of how many rows we have fetched

          fetched += data.length; // Keep iterating if we haven't found all keys and there are more data

          if (!foundAllKeys && !result['done']) {
            if (limit != -1 && fetched >= limit) {
              // If we have reached the limit, just return the results
              return resultMap;
            } else {
              return _fetchNextSet(params, dataProviderAsyncIterator, resultMap);
            }
          } else {
            return resultMap;
          }
        });
      }

      return _fetchNextSet(params, dataProviderAsyncIterator, resultMap).then(function (resultMap) {
        var mappedResultMap = new Map();
        resultMap.forEach(function (value, key) {
          var mappedItem = [value];
          mappedResultMap.set(key, mappedItem[0]);
        });
        return {
          fetchParameters: params,
          results: mappedResultMap
        };
      });
    }
    /**
     * Check if rows are contained by keys
     */

  }, {
    key: "containsKeys",
    value: function containsKeys(params) {
      return this.fetchByKeys(params).then(function (fetchByKeysResult) {
        var results = new Set();
        params['keys'].forEach(function (key) {
          if (fetchByKeysResult['results'].get(key) != null) {
            results.add(key);
          }
        });
        return Promise.resolve({
          containsParameters: params,
          results: results
        });
      });
    }
  }, {
    key: "getCapability",
    value: function getCapability(capabilityName) {
      if (capabilityName == 'fetchByKeys') {
        return {
          implementation: 'iteration'
        };
      }

      var cap = null;

      if (this['_ojSkipLastCapability'] !== true) {
        this['_ojSkipLastCapability'] = true; // Find the index for the very last _ojLastGetCapability

        var index = 1;

        while (this['_ojLastGetCapability' + index]) {
          ++index;
        } // Iterate through the _ojLastGetCapability(n) in reverse order


        for (--index; index > 0; index--) {
          cap = this['_ojLastGetCapability' + index](capabilityName);

          if (cap) {
            break;
          }
        }

        delete this['_ojSkipLastCapability'];
      }

      return cap;
    }
  }], [{
    key: "applyMixin",
    value: function applyMixin(derivedCtor) {
      // Save the current getCapability
      var _lastGetCapability = derivedCtor.prototype['getCapability'];
      var baseCtors = [FetchByKeysMixin];
      baseCtors.forEach(function (baseCtor) {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach(function (name) {
          if (name !== 'constructor') {
            derivedCtor.prototype[name] = baseCtor.prototype[name];
          }
        });
      });

      if (_lastGetCapability) {
        var index = 1;

        while (derivedCtor.prototype['_ojLastGetCapability' + index]) {
          ++index;
        }

        derivedCtor.prototype['_ojLastGetCapability' + index] = _lastGetCapability;
      }
    }
  }]);

  return FetchByKeysMixin;
}();

oj['FetchByKeysMixin'] = FetchByKeysMixin;
oj['FetchByKeysMixin']['applyMixin'] = FetchByKeysMixin.applyMixin;



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 *
 * @export
 * @namespace FetchByKeysMixin
 * @classdesc Mixin class to provide generic implementation of {@link DataProvider#fetchByKeys} and {@link DataProvider#containsKeys}
 * methods for the {@link DataProvider} interface.
 * <p>
 * By default, the mixin implementation will iterate through all the rows to find
 * the result.  DataProvider implementations can implement a "getIterationLimit" function
 * that returns a row limit for the iteration:<br>
 * getIterationLimit() => number
 * </p>
 * <p>
 * This class cannot be instantiated.  You can only call the static applyMixin
 * method to add the implementation to another class.
 * </p>
 * @since 4.2.0
 * @hideconstructor
 */

/**
 * Apply this mixin to another class
 *
 *
 * @param {Function} derivedCtor the constructor of an existing class
 * @export
 * @expose
 * @memberof FetchByKeysMixin
 * @method
 * @name applyMixin
 * @ojtsexample <caption>Apply the mixin in Typescript:</caption>
 * class CustomDataProvider&lt;K, D> implements DataProvider&lt;K, D> {
 *   // Add stand-in properties to satisfy the compiler
 *   containsKeys: (parameters: FetchByKeysParameters&lt;K>) => Promise&lt;ContainsKeysResults&lt;K>>;
 *   fetchByKeys: (parameters: FetchByKeysParameters&lt;K>) => Promise&lt;FetchByKeysResults&lt;K, D>>;
 *
 *   constructor() {
 *     // Constructor implementation
 *   }
 * }
 *
 * FetchByKeysMixin.applyMixin(CustomDataProvider);
 *
 * @ojtsexample <caption>Apply the mixin in Javascript:</caption>
 * function CustomDataProvider() {
 *   // Constructor implementation
 * }
 *
 * FetchByKeysMixin.applyMixin(CustomDataProvider);
 * @ojsignature {target: "Type", value: "(derivedCtor: {new(): DataProvider<any, any>}): any;"}
 */

/**
 * end of jsdoc
 */







/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @export
 * @interface FetchByOffsetCapability
 * @since 4.2.0
 * @ojsignature {target: "Type",
 *               value: "interface FetchByOffsetCapability<D>",
 *               genericParameters: [{"name": "D", "description": "Type of Data"}]}
 * @classdesc Defines the result to the DataProvider method {@link DataProvider#getCapability} for capability "fetchByOffset"
 */

/**
 * The type of implementation for fetchByOffset method.  Possible values are:
 * <ul>
 * <li>"iteration": the implementation uses fetchFirst iteratively to find the result</li>
 * <li>"randomAccess": the implementation uses random access to find the result</li>
 * </ul>
 *
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof FetchByOffsetCapability
 * @instance
 * @name implementation
 * @type {"iteration" | "randomAccess"}
 */

/**
 * End of jsdoc
 */

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var FetchByOffsetMixin = /*#__PURE__*/function () {
  function FetchByOffsetMixin() {
    _classCallCheck(this, FetchByOffsetMixin);
  }

  _createClass(FetchByOffsetMixin, [{
    key: "fetchByOffset",

    /**
     * Fetch rows by offset
     */
    value: function fetchByOffset(params) {
      var size = params && params['size'] > 0 ? params['size'] : 25;
      var sortCriteria = params ? params['sortCriteria'] : null;
      var offset = params && params['offset'] > 0 ? params['offset'] : 0;
      var fetched = 0;
      var limit = this['getIterationLimit'] ? this['getIterationLimit']() : -1;
      var done = false;
      var options = {};
      options['size'] = size;
      options['sortCriteria'] = sortCriteria;
      var resultArray = new Array();
      var dataProviderAsyncIterator = this['fetchFirst'](options)[Symbol.asyncIterator]();

      function _fetchNextSet(params, dataProviderAsyncIterator, resultArray) {
        return dataProviderAsyncIterator.next().then(function (result) {
          done = result['done'];
          var value = result['value'];
          var data = value['data'];
          var metadata = value['metadata'];
          var dataLen = data.length;

          if (offset < fetched + dataLen) {
            var start = offset <= fetched ? 0 : offset - fetched;

            for (var index = start; index < dataLen; index++) {
              if (resultArray.length == size) {
                break;
              }

              resultArray.push({
                metadata: metadata[index],
                data: data[index]
              });
            }
          }

          fetched += dataLen;

          if (resultArray.length < size && !done) {
            if (limit != -1 && fetched >= limit) {
              // If we have reached the limit, just return the results
              return resultArray;
            } else {
              return _fetchNextSet(params, dataProviderAsyncIterator, resultArray);
            }
          } else {
            return resultArray;
          }
        });
      }

      return _fetchNextSet(params, dataProviderAsyncIterator, resultArray).then(function (resultArray) {
        return {
          fetchParameters: params,
          results: resultArray,
          done: done
        };
      });
    }
  }, {
    key: "getCapability",
    value: function getCapability(capabilityName) {
      if (capabilityName == 'fetchByOffset') {
        return {
          implementation: 'iteration'
        };
      }

      var cap = null;

      if (this['_ojSkipLastCapability'] !== true) {
        this['_ojSkipLastCapability'] = true; // Find the index for the very last _ojLastGetCapability

        var index = 1;

        while (this['_ojLastGetCapability' + index]) {
          ++index;
        } // Iterate through the _ojLastGetCapability(n) in reverse order


        for (--index; index > 0; index--) {
          cap = this['_ojLastGetCapability' + index](capabilityName);

          if (cap) {
            break;
          }
        }

        delete this['_ojSkipLastCapability'];
      }

      return cap;
    }
  }], [{
    key: "applyMixin",
    value: function applyMixin(derivedCtor) {
      // Save the current getCapability
      var _lastGetCapability = derivedCtor.prototype['getCapability'];
      var baseCtors = [FetchByOffsetMixin];
      baseCtors.forEach(function (baseCtor) {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach(function (name) {
          if (name !== 'constructor') {
            derivedCtor.prototype[name] = baseCtor.prototype[name];
          }
        });
      });

      if (_lastGetCapability) {
        var index = 1;

        while (derivedCtor.prototype['_ojLastGetCapability' + index]) {
          ++index;
        }

        derivedCtor.prototype['_ojLastGetCapability' + index] = _lastGetCapability;
      }
    }
  }]);

  return FetchByOffsetMixin;
}();

oj['FetchByOffsetMixin'] = FetchByOffsetMixin;
oj['FetchByOffsetMixin']['applyMixin'] = FetchByOffsetMixin.applyMixin;



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 *
 * @export
 * @namespace FetchByOffsetMixin
 * @classdesc Mixin class to provide generic implementation of {@link DataProvider#fetchByOffset}
 * method for the {@link DataProvider} interface.
 * <p>
 * By default, the mixin implementation will iterate through all the rows to find
 * the result.  DataProvider implementations can implement a "getIterationLimit" function
 * that returns a row limit for the iteration:<br>
 * getIterationLimit() => number
 * </p>
 * <p>
 * This class cannot be instantiated.  You can only call the static applyMixin
 * method to add the implementation to another class.
 * </p>
 * @since 4.2.0
 * @hideconstructor
 */

/**
 * Apply this mixin to another class
 *
 *
 * @param {Function} derivedCtor the constructor of an existing class
 * @export
 * @expose
 * @memberof FetchByOffsetMixin
 * @method
 * @name applyMixin
 * @ojtsexample <caption>Apply the mixin in Typescript:</caption>
 * class CustomDataProvider&lt;K, D> implements DataProvider&lt;K, D> {
 *   // Add a stand-in property to satisfy the compiler
 *   fetchByOffset: (parameters: FetchByOffsetParameters&lt;D>) => Promise&lt;FetchByOffsetResults&lt;K, D>>;
 *
 *   constructor() {
 *     // Constructor implementation
 *   }
 * }
 *
 * FetchByOffsetMixin.applyMixin(CustomDataProvider);
 *
 * @ojtsexample <caption>Apply the mixin in Javascript:</caption>
 * function CustomDataProvider() {
 *   // Constructor implementation
 * }
 *
 * FetchByOffsetMixin.applyMixin(CustomDataProvider);
 * @ojsignature {target: "Type", value: "(derivedCtor: {new(): DataProvider<any, any>}): any;"}
 */

/**
 * end of jsdoc
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @since 4.1.0
 * @export
 * @interface FetchByOffsetParameters
 * @extends FetchListParameters
 * @ojsignature {target: "Type",
 *               value: "interface FetchByOffsetParameters<D> extends FetchListParameters<D>",
 *               genericParameters: [{"name": "D", "description": "Type of Data"}]}
 * @classdesc Defines the parameters to the DataProvider method {@link DataProvider#fetchByOffset}
 */

/**
 * The offset used for the fetch call.
 *
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof FetchByOffsetParameters
 * @instance
 * @name offset
 * @type {number}
 */

/**
 * attributes to include in the result. If specified, then at least these set of attributes will be included in each row
 * results. If not specified then the default attributes will be included.
 *
 *
 * @since 6.1.0
 * @export
 * @expose
 * @memberof FetchByOffsetParameters
 * @instance
 * @name attributes
 * @type {Array.<string | FetchAttribute>}
 * @ojsignature {target: "Type",
 *               value: "?Array<string | FetchAttribute>"}
 */

/**
 * @since 4.1.0
 * @export
 * @interface FetchByOffsetResults
 * @ojsignature {target: "Type",
 *               value: "interface FetchByOffsetResults<K, D>"}
 * @classdesc FetchByOffsetResults defines the result from the DataProvider method {@link DataProvider#fetchByOffset}
 */

/**
 * The parameters used for the fetch call.
 *
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof FetchByOffsetResults
 * @instance
 * @name fetchParameters
 * @type {FetchByOffsetParameters}
 * @ojsignature {target: "Type",
 *               value: "FetchByOffsetParameters<D>"}
 */

/**
 * Array of {@link Item}.
 *
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof FetchByOffsetResults
 * @instance
 * @name results
 * @type {Array.<Item>}
 * @ojsignature {target: "Type",
 *               value: "Array<Item<K, D>>"}
 */

/**
 * Indicates whether there are more items which can be fetched.
 * <p>If this is true, fetching the next block will likely return an empty array as the result.  A DataProvider can potentially make a stronger guarantee (if the DataProvider is running against an immutable repository or the DataProvider doesnât attempt to retrieve a subsequent block if the DataProvider believes it is complete).  We donât generally make the stronger guarantee since the repository may have been mutated since the previous response with done:true, such that new records would be returned.</p>
 * <p>If this is false, fetching the next block may or may not return an empty array as a result.</p>
 *
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof FetchByOffsetResults
 * @instance
 * @name done
 * @type {boolean}
 */

/**
 * end of jsdoc
 */











function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }


var FilterImpl = /*#__PURE__*/function () {
  function FilterImpl(options) {
    _classCallCheck(this, FilterImpl);

    options = options || {};
    this._textFilterAttributes = options['filterOptions'] ? options['filterOptions']['textFilterAttributes'] : null;
    var filterDef = options.filterDef;

    if (filterDef) {
      if (filterDef['op']) {
        this['op'] = filterDef['op'];

        if (filterDef['value']) {
          this['value'] = filterDef['value'];

          if (filterDef['attribute']) {
            this['attribute'] = filterDef['attribute'];
          }
        } else if (filterDef['criteria']) {
          this['criteria'] = filterDef['criteria'];
        }
      } else if (filterDef['text']) {
        this['text'] = filterDef['text'];
      }
    }
  }

  _createClass(FilterImpl, [{
    key: "filter",
    value: function filter(item, index, array) {
      return oj.FilterUtils.satisfy(FilterImpl._transformFilter(this), item);
    }
  }], [{
    key: "_transformFilter",
    value: function _transformFilter(filter) {
      var transformedExpr;

      if (filter) {
        var op = filter.op;
        var filterValue;

        if (filter['text']) {
          op = '$regex';
        } else {
          // offline has slightly different names for some operators
          if (op === '$le') {
            op = '$lte';
          } else if (op === '$ge') {
            op = '$gte';
          } else if (op === '$pr') {
            op = '$exists';
          }
        }

        if (op != '$and' && op != '$or') {
          if (filter['text']) {
            // Escape special characters without change filter['text'] which is the original filter string
            filterValue = new RegExp(filter['text'].replace(/[.*+\-?^${}()|[\]\\]/g, '\\$&'), 'i');
          } else {
            filterValue = filter.value;
          }

          transformedExpr = {};
          var attributeExpr = filter.attribute;

          if (attributeExpr) {
            var operatorExpr = {}; // need express sw and ew as regex

            if (op === '$sw' || op === '$ew' || op === '$co') {
              op = '$regex';
              filterValue = FilterImpl._fixStringExpr(op, filterValue);
            }

            operatorExpr[op] = filterValue;
            transformedExpr[attributeExpr] = operatorExpr;
          } else if (filter['text']) {
            var _operatorExpr = {};
            _operatorExpr[op] = filterValue;

            if (filter._textFilterAttributes) {
              var textFilterArray = [];

              filter._textFilterAttributes.forEach(function (field) {
                var textFilter = {};
                textFilter[field] = _operatorExpr;
                textFilterArray.push(textFilter);
              });

              transformedExpr['$or'] = textFilterArray;
            } else {
              transformedExpr['*'] = _operatorExpr;
            }
          } else {
            // the field/value combos are specified in the value itself
            var criteriaArray = [];

            FilterImpl._transformObjectExpr(filterValue, op, null, criteriaArray);

            transformedExpr['$and'] = criteriaArray;
          }
        } else {
          var _criteriaArray = [];
          filter.criteria.forEach(function (criterion) {
            _criteriaArray.push(FilterImpl._transformFilter(criterion));
          });
          transformedExpr = {};
          transformedExpr[op] = _criteriaArray;
        }
      }

      return transformedExpr;
    }
  }, {
    key: "_transformObjectExpr",
    value: function _transformObjectExpr(objectExpr, op, path, criteriaArray) {
      var self = this;
      var objectProps = Object.keys(objectExpr);

      if (objectProps.length > 0) {
        Object.keys(objectExpr).forEach(function (fieldAttribute) {
          var fieldValue = objectExpr[fieldAttribute];
          var fieldAttributePath = path ? path + '.' + fieldAttribute : fieldAttribute;

          if (!(fieldValue instanceof Object)) {
            var operatorExpr = {}; // need express co, sw and ew as regex

            if (op === '$sw' || op === '$ew' || op === '$co') {
              op = '$regex';
              fieldValue = FilterImpl._fixStringExpr(op, fieldValue);
            }

            operatorExpr[op] = fieldValue;
            var fieldExpr = {};
            fieldExpr[fieldAttributePath] = operatorExpr;
            criteriaArray.push(fieldExpr);
          } else {
            FilterImpl._transformObjectExpr(fieldValue, op, fieldAttributePath, criteriaArray);
          }
        });
      } else {
        var operatorExpr = {};
        operatorExpr[op] = objectExpr;
        var fieldExpr = {};
        fieldExpr[path] = operatorExpr;
        criteriaArray.push(fieldExpr);
      }
    }
  }, {
    key: "_fixStringExpr",
    value: function _fixStringExpr(op, value) {
      if (typeof value === 'string' || value instanceof String) {
        if (op === '$sw') {
          value = '^' + value;
        } else if (op === '$ew') {
          value = value + '$';
        }
      }

      return value;
    }
  }]);

  return FilterImpl;
}();

var FilterFactory = /*#__PURE__*/function () {
  function FilterFactory() {
    _classCallCheck(this, FilterFactory);
  }

  _createClass(FilterFactory, null, [{
    key: "getFilter",
    value: function getFilter(options) {
      return new FilterImpl(options);
    }
  }]);

  return FilterFactory;
}();

oj['FilterFactory'] = FilterFactory;



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @export
 * @class FilterFactory
 * @since 7.0.0
 * @ojsignature {target: "Type",
 *               value: "class FilterFactory<D>"}
 * @hideconstructor
 * @classdesc Provides the ability to construct filters which can be used for {@link FetchListParameters#filterCriterion}. Note is it not a requirement to use this
 * factory to construct filters based on the filter definition. Applications can construct their own filters which implement the interface {@link DataFilter.Filter}
 */

/**
 * This function is used to pass in a filter definition and returns a filter which can be used
 * with DataProviders. It essentially takes the filter definition and then adds a local filter()
 * function which is required when used for a DataProvider filterCriterion.
 *
 *
 * @since 7.0.0
 * @export
 * @expose
 * @memberof FilterFactory
 * @instance
 * @name getFilter
 * @method
 * @static
 * @param {Object} options Options for the getFilter() function
 * @param {DataFilter.FilterDef} options.filterDef The filter definition for the filter to be returned.
 * @param {any=} options.filterOptions Options for the filter such as textFilterAttributes which lists the attributes to filter on for TextFilter.
 * @return {DataFilter.Filter} Returns either an AttributeFilter, AttributeExprFilter, CompoundFilter, or TextFilter depending on whether a AttributeFilterDef or CompoundFilterDef.
 * was passed in.
 * @ojsignature {target: "Type",
 *               value: "(options: {filterDef: DataFilter.FilterDef<any>, filterOptions: any}): DataFilter.Filter<any>",
 *               genericParameters: [{"name": "D", "description": "Type of Data"}]}
 * @example
 * <caption>Get filter which filters on DepartmentId value 10 and then fetch filtered rows from the DataProvider</caption>
 * var filter = FilterFactory.getFilter({filterDef: {op: '$eq', value: {DepartmentId: 10}}};
 * var dataProviderAsyncIterator = dataprovider.fetchFirst({filterCriterion: filter})[Symbol.asyncIterator]();
 * let result = await dataProviderAsyncIterator.next();
 * ...
 **/

/**
 * End of jsdoc
 */





/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * The interface for FilterOperator
 *
 *
 * @export
 * @interface FilterOperator
 * @since 5.0.0
 * @ojsignature {target: "Type",
 *               value: "interface FilterOperator<D>",
 *               genericParameters: [{"name": "D", "description": "Type of Data"}]}
 * @ojdeprecated {since: '7.0.0', description: 'Use AttributeFilter or CompoundFilter instead.'}
 */

/**
 * The operator, either an AttributeFilterOperator.AttributeOperator or CompoundFilterOperator.CompoundOperator.
 *
 *
 * @since 5.0.0
 * @export
 * @expose
 * @memberof FilterOperator
 * @instance
 * @name op
 * @type {AttributeFilterOperator.AttributeOperator | CompoundFilterOperator.CompoundOperator}
 */

/**
 * Optional function which is used to locally filter the data.
 *
 *
 * @since 5.0.0
 * @export
 * @expose
 * @memberof FilterOperator
 * @instance
 * @name filter
 * @method
 * @param {Array} data The data to filter
 * @return {Array} filtered data
 */

/**
 * End of jsdoc
 */

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }



/* eslint-disable */

/**
 * @ignore
 * @class oj.FilterUtils
 * @constructor
 */
oj.FilterUtils = function () {
  'use strict';
  /**
    * Helper function that checks if itemData satisfies the search criteria
    * defined by selector or not. Undefined selector means everything is
    * selected.
    * @method
    * @name satisfy
    * @memberof! storageUtils
    * @static
    * @param {string} selector Rule that defines whether an object is selected
    *                          or not.
    * @param {object} itemData The value to check with.
    * @returns {boolean} true if itemData satisfies search criteria defined
    *                         by selector, and false otherwise.
    */

  function satisfy(selector, itemData) {
    if (!selector) {
      // undefined selector means select everything.
      return true;
    } else {
      var expTree = _buildExpressionTree(selector);

      return _evaluateExpressionTree(expTree, itemData);
    }
  }

  ;
  /**
   * Helper function used by {@link _satisfy} to build an expression tree
   * based on expression object for easier evaluation later.
   * @method
   * @name _buildExpressionTree
   * @memberof! storageUtils
   * @static
   * @param {object} expression The expression that used to filter an object.
   * @returns {object} The tree representation of the passed-in expression.
   */

  function _buildExpressionTree(expression) {
    var subTree;
    var itemTreeArray = [];

    for (var key in expression) {
      if (expression.hasOwnProperty(key)) {
        var value = expression[key];

        if (key.indexOf('$') === 0) {
          if (_isMultiSelector(key)) {
            if (value instanceof Array) {
              subTree = {
                operator: key,
                array: []
              };

              for (var subindex = 0; subindex < value.length; subindex++) {
                var itemTree = _buildExpressionTree(value[subindex]);

                subTree.array.push(itemTree);
              }
            } else {
              throw new Error("not a valid expression: " + expression);
            }
          } else if (_isSingleSelector(key)) {
            throw new Error("not a valid expression: " + expression);
          }
        } else if (_isLiteral(value)) {
          itemTreeArray.push({
            left: key,
            right: value,
            operator: '$eq'
          });
        } else {
          var partialTree = {
            left: key
          };

          _completePartialTree(partialTree, value);

          itemTreeArray.push(partialTree);
        }
      }
    }

    if (itemTreeArray.length > 1) {
      subTree = {
        operator: '$and',
        array: itemTreeArray
      };
    } else if (itemTreeArray.length === 1) {
      subTree = itemTreeArray[0];
    }

    return subTree;
  }

  ;
  /**
   * Helper function used by {@link _buildExpressionTree} to complete the
   * right side of an expression tree.
   * @method
   * @name _completePartialTree
   * @memberof! storageUtils
   * @static
   * @param {object} partialTree The tree representation of an expression.
   * @param {object} expression The object to evaluate the expression tree
   *                          against.
   */

  function _completePartialTree(partialTree, expression) {
    var found = false;

    for (var key in expression) {
      if (expression.hasOwnProperty(key)) {
        var value = expression[key];

        if (found || !_isSingleSelector(key)) {
          throw new Error("parsing error " + expression);
        }

        partialTree.operator = key;
        partialTree.right = value;
        found = true;
      }
    }
  }

  ;
  /**
   * Helper function used by {@link find} to apply an expression tree to
   * an object to check if this object satisfies the expression tree or not.
   * @method
   * @name _evaluateExpressionTree
   * @memberof! storageUtils
   * @tatic
   * @param {object} expTree The tree representation of an expression.
   * @param {object} itemData The object to evaluate the expression tree
   *                          against.
   * @returns {boolean} true if itemData satisfies expression tree, false
   *                    otherwise.
   */

  function _evaluateExpressionTree(expTree, itemData) {
    var operator = expTree.operator;

    if (_isMultiSelector(operator)) {
      if (expTree.left || !(expTree.array instanceof Array)) {
        throw new Error("invalid expression tree!" + expTree);
      } else {
        var result;
        var subTreeArray = expTree.array;

        for (var subIndex = 0; subIndex < subTreeArray.length; subIndex++) {
          var subResult = _evaluateExpressionTree(subTreeArray[subIndex], itemData);

          if (operator === '$or' && subResult === true) {
            return true;
          } else if (operator === '$and' && subResult === false) {
            return false;
          }

          result = subResult;
        }

        return result;
      }
    } else if (_isSingleSelector(operator)) {
      var value = expTree.right;
      var itemValue;

      if (expTree.left != '*') {
        itemValue = getValue(expTree.left, itemData);
        return _evaluateSingleSelectorExpression(operator, value, itemValue);
      } else {
        var i;
        var itemProperties = Object.keys(itemData);

        for (i = 0; i < itemProperties.length; i++) {
          itemValue = getValue(itemProperties[i], itemData);

          if (_evaluateSingleSelectorExpression(operator, value, itemValue)) {
            return true;
          }
        }

        return false;
      }
    } else {
      throw new Error("not a valid expression!" + expTree);
    }
  }

  ;
  /**
   * Helper function to evaluate a single selector expression.
   * @method
   * @name _evaluateSingleSelectorExpression
   * @memberof! storageUtils
   * @static
   * @param {string} operator The operator of an expression.
   * @param {object} value The value.
   * @param {object} itemData The object to evaluate the expression tree
   *                          against.
   * @returns {boolean} true if itemData satisfies expression, false
   *                    otherwise.
   */

  function _evaluateSingleSelectorExpression(operator, value, itemValue) {
    if (operator === '$lt') {
      var fixedTokens = _fixNullForString(itemValue, value);

      itemValue = fixedTokens[0];
      value = fixedTokens[1];
      return itemValue < value;
    } else if (operator === '$gt') {
      var fixedTokens = _fixNullForString(itemValue, value);

      itemValue = fixedTokens[0];
      value = fixedTokens[1];
      return itemValue > value;
    } else if (operator === '$lte') {
      var fixedTokens = _fixNullForString(itemValue, value);

      itemValue = fixedTokens[0];
      value = fixedTokens[1];
      return itemValue <= value;
    } else if (operator === '$gte') {
      var fixedTokens = _fixNullForString(itemValue, value);

      itemValue = fixedTokens[0];
      value = fixedTokens[1];
      return itemValue >= value;
    } else if (operator === '$eq') {
      return itemValue === value;
    } else if (operator === '$ne') {
      return itemValue !== value;
    } else if (operator === '$regex') {
      if (itemValue) {
        if (!(typeof itemValue === 'string') && !(itemValue instanceof String)) {
          if (!(itemValue instanceof Object)) {
            // primitive so coerce to a string
            itemValue = new String(itemValue);
          } else {
            // call toString() on objects. Check if it returns just the default
            // return value for toString(). If so, then we can't do anything so
            // return false
            itemValue = itemValue.toString();

            if (itemValue == '[object Object]') {
              return false;
            }
          }
        }

        var matchResult = itemValue.match(value);
        return matchResult !== null;
      }

      return false;
    } else if (operator === '$exists') {
      if (value) {
        return itemValue !== null && itemValue !== undefined;
      } else {
        return itemValue === null || itemValue === undefined;
      }
    } else {
      throw new Error("not a valid expression! " + expTree);
    }

    return false;
  }
  /**
   * Helper function that checks if the token is a multiple selector operator
   * or not.
   * @method
   * @name _isMultiSelector
   * @memberof! storageUtils
   * @static
   * @param {string} token The token to check against.
   * @returns {boolean} true if the token is the supported multiple selector
   *                    operator, false otherwise.
   */


  function _isMultiSelector(token) {
    return token === '$and' || token === '$or';
  }

  ;
  /**
   * Helper function that checks if the token is a single selector operator
   * or not.
   * @method
   * @name _isSingleSelector
   * @memberof! storageUtils
   * @static
   * @param {string} token The token to check against.
   * @returns {boolean} true if the token is the supported single selector
   *                    operator, false otherwise.
   */

  function _isSingleSelector(token) {
    return token === '$lt' || token === '$gt' || token === '$lte' || token === '$gte' || token === '$eq' || token === '$ne' || token === '$regex' || token === '$exists';
  }

  ;
  /**
   * Helper function that checks if the token is a literal or not.
   * @method
   * @name _isLiteral
   * @memberof! storageUtils
   * @static
   * @param {string} token The token to check against.
   * @returns {boolean} true if the token is a literal, false otherwise.
   */

  function _isLiteral(token) {
    return _typeof(token) !== 'object';
  }

  ;
  /**
   * Helper function that checks if the token is a string
   * @method
   * @name _isSring
   * @memberof! storageUtils
   * @static
   * @param {string} token The token to check against.
   * @returns {boolean} true if the token is a string, false otherwise.
   */

  function _isString(token) {
    return token != null && (token instanceof String || typeof token === 'string');
  }

  ;
  /**
   * Helper function that sets null literals to empty string for string comparison
   * @method
   * @name _fixNullForString
   * @memberof! storageUtils
   * @static
   * @param {string} leftToken left hand token
   * @param {string} rightToken right hand token
   * @returns {Array} Array of left and right hand tokens
   */

  function _fixNullForString(leftToken, rightToken) {
    if (_isString(leftToken) && rightToken == null) {
      rightToken = '';
    } else if (_isString(rightToken) && leftToken == null) {
      leftToken = '';
    }

    return [leftToken, rightToken];
  }

  ;
  /**
   * Helper function that retrieves the value of a property from an object.
   * The object can have nested properties, and the property name could be
   * a path to the leaf property.
   * @method
   * @name getValue
   * @memberof! storageUtils
   * @static
   * @param {string} path The chain of the property names from the root to
   *                      the leaf when the object has nested properties.
   * @param {object} itemValue The object to retrieve the property value
   *                           from.
   * @returns {object} the object that contains all the properties defined
   *                   in fieldsExpression array, the corresponding property
   *                   value is obtained from itemData.
   */

  function getValue(path, itemValue) {
    var paths = path.split('.');
    var returnValue = itemValue;

    for (var index = 0; index < paths.length; index++) {
      returnValue = returnValue[paths[index]];
    }

    return returnValue;
  }

  ;
  /**
   * Helper function that constructs an object out from value
   * based on fields.
   * @method
   * @name assembleObject
   * @param {object} value The original object to construct the return object
   *                       from.
   * @param {Array} fields An array of property names whose values
   *                       should be included in the final contructed
   *                       return object.
   * @returns {object} the object that contains all the properties defined
   *                   in fields array, the corresponding property
   *                   value is obtained from value.
   * @ignore
   */

  function assembleObject(value, fields) {
    var returnObject;

    if (!fields) {
      returnObject = value;
    } else {
      returnObject = {};

      for (var index = 0; index < fields.length; index++) {
        var currentObject = returnObject;
        var currentItemDataValue = value;
        var field = fields[index];
        var paths = field.split('.');

        for (var pathIndex = 0; pathIndex < paths.length; pathIndex++) {
          currentItemDataValue = currentItemDataValue[paths[pathIndex]];

          if (!currentObject[paths[pathIndex]] && pathIndex < paths.length - 1) {
            currentObject[paths[pathIndex]] = {};
          }

          if (pathIndex === paths.length - 1) {
            currentObject[paths[pathIndex]] = currentItemDataValue;
          } else {
            currentObject = currentObject[paths[pathIndex]];
          }
        }
      }
    }

    return returnObject;
  }

  ;
  return {
    satisfy: satisfy,
    getValue: getValue,
    assembleObject: assembleObject
  };
}();







/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * The interface for ItemMetadata.  Note that key is the only mandatory property,
 * implementations can provide additional properties as needed.
 *
 *
 * @since 9.0.0
 * @export
 * @interface ItemMessage
 * @ojsignature {target: "Type",
 *               value: "interface ItemMessage"}
 */

/**
 * Detail text of the message.
 *
 * @since 9.0.0
 * @export
 * @expose
 * @memberof ItemMessage
 * @instance
 * @name detail
 * @type {string}
 */

/**
 * Severity type or level of the message.
 *
 * @since 9.0.0
 * @export
 * @expose
 * @memberof ItemMessage
 * @instance
 * @name severity
 * @type {(ItemMessage.SEVERITY_TYPE | ItemMessage.SEVERITY_LEVEL)=}
 * @ojsignature {target: "Type",
 *               value: "?(ItemMessage.SEVERITY_TYPE | ItemMessage.SEVERITY_LEVEL)"}
 */

/**
 * Summary text of the message.
 *
 * @since 9.0.0
 * @export
 * @expose
 * @memberof ItemMessage
 * @instance
 * @name summary
 * @type {string}
 */

/**
 * The supported severity levels of the message.
 * @typedef {1 | 2 | 3 | 4 | 5} ItemMessage.SEVERITY_LEVEL
 * @ojsignature {target:"Type", value:"1 | 2 | 3 | 4 | 5"}
 * @ojvalue {number} 1 {"description": "Indicates a confirmation that an operation or task was completed. This is the lowest severity level."}
 * @ojvalue {number} 2 {"description": "Indicates information or operation messages. This has a lower severity level than warning."}
 * @ojvalue {number} 3 {"description": "Indicates an application condition or situation that might require users' attention. This has a lower severity than error."}
 * @ojvalue {number} 4 {"description": "Used when data inaccuracies occur when completing a field and that needs fixing before user can continue. This has a lower severity level than fatal."}
 * @ojvalue {number} 5 {"description": "Used when a critical application error or an unknown failure occurs. This is the highest severity level."}
 */

/**
 * The supported severity types of the message.
 * @typedef {'confirmation' | 'info' | 'warning' | 'error' | 'fatal'} ItemMessage.SEVERITY_TYPE
 * @ojsignature {target:"Type", value:"'confirmation' | 'info' | 'warning' | 'error' | 'fatal'"}
 * @ojvalue {string} "confirmation" {"description": "Indicates a confirmation that an operation or task was completed. This is the lowest severity level."}
 * @ojvalue {string} "info" {"description": "Indicates information or operation messages. This has a lower severity level than warning."}
 * @ojvalue {string} "warning" {"description": "Indicates an application condition or situation that might require users' attention. This has a lower severity than error."}
 * @ojvalue {string} "error" {"description": "Used when data inaccuracies occur when completing a field and that needs fixing before user can continue. This has a lower severity level than fatal."}
 * @ojvalue {string} "fatal" {"description": "Used when a critical application error or an unknown failure occurs. This is the highest severity level."}
 */

/**
 * End of jsdoc
 */







/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * The interface for ItemWithOptionalData
 *
 *
 * @since 9.0.0
 * @export
 * @interface ItemWithOptionalData
 * @ojsignature {target: "Type",
 *               value: "interface ItemWithOptionalData<K, D>",
 *               genericParameters: [{"name": "K", "description": "Type of Key"}, {"name": "D", "description": "Type of Data"}]}
 */

/**
 * The metadata for the item
 *
 *
 * @since 9.0.0
 * @export
 * @expose
 * @memberof ItemWithOptionalData
 * @instance
 * @name metadata
 * @type {ItemMetadata}
 * @ojsignature {target: "Type",
 *               value: "ItemMetadata<K>"}
 */

/**
 * The data for the item
 *
 *
 * @since 9.0.0
 * @export
 * @expose
 * @memberof ItemWithOptionalData
 * @instance
 * @name data
 * @type {Object}
 * @ojsignature {target: "Type",
 *               value: "?D"}
 */

/**
 * End of jsdoc
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @since 4.1.0
 * @export
 * @interface Item
 * @extends ItemWithOptionalData
 * @ojsignature {target: "Type",
 *               value: "interface Item<K, D> extends ItemWithOptionalData<K, D>",
 *               genericParameters: [{"name": "K", "description": "Type of Key"}, {"name": "D", "description": "Type of Data"}]}
 * @classdesc Defines the items returned in the Map<K, Item<K, D>> from the DataProvider method {@link DataProvider#fetchByKeys}
 */

/**
 * The metadata for the item
 *
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof Item
 * @instance
 * @name metadata
 * @type {ItemMetadata}
 * @ojsignature {target: "Type",
 *               value: "ItemMetadata<K>"}
 */

/**
 * The data for the item
 *
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof Item
 * @instance
 * @name data
 * @type {Object}
 * @ojsignature {target: "Type",
 *               value: "D"}
 */

/**
 * End of jsdoc
 */





/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * The interface for SortCapability
 *
 *
 * @export
 * @interface SortCapability
 * @since 4.2.0
 * @ojsignature {target: "Type",
 *               value: "interface SortCapability<D>",
 *               genericParameters: [{"name": "D", "description": "Type of Data"}]}
 * @classdesc Defines the result from the DataProvider method {@link DataProvider#getCapability} for capability "sort"
 */

/**
 * Number of attributes that can be sorted at the same time.  Possible values are:
 * <ul>
 * <li>"none": no sorting is supported.</li>
 * <li>"single": only one attribute can be sorted at a time.</li>
 * <li>"multiple": more than one attribute can be sorted at a time.</li>
 * </ul>
 *
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof SortCapability
 * @instance
 * @name attributes
 * @type {"none" | "single" | "multiple"}
 */

/**
 * End of jsdoc
 */








var __DataProvider = {};
__DataProvider.FetchByKeysMixin = oj.FetchByKeysMixin;
__DataProvider.FetchByOffsetMixin = oj.FetchByOffsetMixin;
__DataProvider.FilterFactory = oj.FilterFactory;
__DataProvider.DataProviderRefreshEvent = oj.DataProviderRefreshEvent;
__DataProvider.DataProviderMutationEvent = oj.DataProviderMutationEvent;
__DataProvider.AttributeFilterOperator = oj.AttributeFilterOperator;
__DataProvider.CompoundFilterOperator = oj.CompoundFilterOperator;
__DataProvider.DataCache = oj.DataCache;

  ;return __DataProvider;
});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojdataprovideradapter-base',['ojs/ojcore', 'jquery', 'ojs/ojeventtarget', 'ojs/ojdataprovider'], function(oj, $)
{
  "use strict";
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }


var DataSourceAdapter = /*#__PURE__*/function () {
  function DataSourceAdapter(dataSource) {
    _classCallCheck(this, DataSourceAdapter);

    this.dataSource = dataSource;

    this.AsyncIterable = /*#__PURE__*/function () {
      function _class(_asyncIterator) {
        _classCallCheck(this, _class);

        this._asyncIterator = _asyncIterator;

        this[Symbol.asyncIterator] = function () {
          return this._asyncIterator;
        };
      }

      return _class;
    }();

    this.AsyncIterator = /*#__PURE__*/function () {
      function _class2(_nextFunc, _params) {
        _classCallCheck(this, _class2);

        this._nextFunc = _nextFunc;
        this._params = _params;
        this._fetchFirst = true;
      }

      _createClass(_class2, [{
        key: 'next',
        value: function next() {
          var fetchFirst = this._fetchFirst;
          this._fetchFirst = false;
          return this._nextFunc(this._params, fetchFirst);
        }
      }]);

      return _class2;
    }();

    this.AsyncIteratorYieldResult = /*#__PURE__*/function () {
      function _class3(_parent, value) {
        _classCallCheck(this, _class3);

        this._parent = _parent;
        this.value = value;
        this[DataSourceAdapter._VALUE] = value;
        this[DataSourceAdapter._DONE] = false;
      }

      return _class3;
    }();

    this.AsyncIteratorReturnResult = /*#__PURE__*/function () {
      function _class4(_parent, value) {
        _classCallCheck(this, _class4);

        this._parent = _parent;
        this.value = value;
        this[DataSourceAdapter._VALUE] = value;
        this[DataSourceAdapter._DONE] = true;
      }

      return _class4;
    }();

    this.FetchListResult = /*#__PURE__*/function () {
      function _class5(_parent, fetchParameters, data, metadata) {
        _classCallCheck(this, _class5);

        this._parent = _parent;
        this.fetchParameters = fetchParameters;
        this.data = data;
        this.metadata = metadata;
        this[DataSourceAdapter._FETCHPARAMETERS] = fetchParameters;
        this[DataSourceAdapter._DATA] = data;
        this[DataSourceAdapter._METADATA] = metadata;
      }

      return _class5;
    }();

    this.ItemMetadata = /*#__PURE__*/function () {
      function _class6(_parent, key) {
        _classCallCheck(this, _class6);

        this._parent = _parent;
        this.key = key;
        this[DataSourceAdapter._KEY] = key;
      }

      return _class6;
    }();

    this.SortCriterion = /*#__PURE__*/function () {
      function _class7(_parent, attribute, direction) {
        _classCallCheck(this, _class7);

        this._parent = _parent;
        this.attribute = attribute;
        this.direction = direction;
        this[DataSourceAdapter._ATTRIBUTE] = attribute;
        this[DataSourceAdapter._DIRECTION] = direction;
      }

      return _class7;
    }();

    this.DataProviderMutationEventDetail = /*#__PURE__*/function () {
      function _class8(_parent, add, remove, update) {
        _classCallCheck(this, _class8);

        this._parent = _parent;
        this.add = add;
        this.remove = remove;
        this.update = update;
        this[DataSourceAdapter._ADD] = add;
        this[DataSourceAdapter._REMOVE] = remove;
        this[DataSourceAdapter._UPDATE] = update;
      }

      return _class8;
    }();

    this.DataProviderOperationEventDetail = /*#__PURE__*/function () {
      function _class9(_parent, keys, metadata, data, indexes) {
        _classCallCheck(this, _class9);

        this._parent = _parent;
        this.keys = keys;
        this.metadata = metadata;
        this.data = data;
        this.indexes = indexes;
        this[DataSourceAdapter._KEYS] = keys;
        this[DataSourceAdapter._METADATA] = metadata;
        this[DataSourceAdapter._DATA] = data;
        this[DataSourceAdapter._INDEXES] = indexes;
      }

      return _class9;
    }();

    this.DataProviderAddOperationEventDetail = /*#__PURE__*/function () {
      function _class10(_parent, keys, afterKeys, addBeforeKeys, parentKeys, metadata, data, indexes) {
        _classCallCheck(this, _class10);

        this._parent = _parent;
        this.keys = keys;
        this.afterKeys = afterKeys;
        this.addBeforeKeys = addBeforeKeys;
        this.parentKeys = parentKeys;
        this.metadata = metadata;
        this.data = data;
        this.indexes = indexes;
        this[DataSourceAdapter._KEYS] = keys;
        this[DataSourceAdapter._AFTERKEYS] = afterKeys;
        this[DataSourceAdapter._ADDBEFOREKEYS] = addBeforeKeys;
        this[DataSourceAdapter._METADATA] = metadata;
        this[DataSourceAdapter._DATA] = data;
        this[DataSourceAdapter._INDEXES] = indexes;
      }

      return _class10;
    }();
  }

  _createClass(DataSourceAdapter, [{
    key: "getCapability",
    value: function getCapability(capabilityName) {
      if (capabilityName == DataSourceAdapter._SORT && this.dataSource.getCapability(capabilityName) == 'full') {
        return {
          attributes: 'multiple'
        };
      } else if (capabilityName == 'fetchByKeys') {
        return {
          implementation: 'lookup'
        };
      } else if (capabilityName == 'fetchByOffset') {
        return {
          implementation: 'lookup'
        };
      }

      return null;
    }
  }, {
    key: "addListener",
    value: function addListener(eventType, eventHandler) {
      this._eventHandlerFuncs[eventType] = eventHandler.bind(this);
      this.dataSource.on(eventType, this._eventHandlerFuncs[eventType]);
    }
  }, {
    key: "removeListener",
    value: function removeListener(eventType) {
      this.dataSource.off(eventType, this._eventHandlerFuncs[eventType]);
    }
  }, {
    key: "removeAllListeners",
    value: function removeAllListeners() {
      this._eventHandlerFuncs = {};
    }
  }]);

  return DataSourceAdapter;
}();

DataSourceAdapter._SORT = 'sort';
DataSourceAdapter._DATA = 'data';
DataSourceAdapter._KEY = 'key';
DataSourceAdapter._ATTRIBUTE = 'attribute';
DataSourceAdapter._DIRECTION = 'direction';
DataSourceAdapter._VALUE = 'value';
DataSourceAdapter._DONE = 'done';
DataSourceAdapter._FETCHPARAMETERS = 'fetchParameters';
DataSourceAdapter._METADATA = 'metadata';
DataSourceAdapter._KEYS = 'keys';
DataSourceAdapter._INDEXES = 'indexes';
DataSourceAdapter._ADD = 'add';
DataSourceAdapter._REMOVE = 'remove';
DataSourceAdapter._UPDATE = 'update';
DataSourceAdapter._AFTERKEYS = 'afterKeys';
DataSourceAdapter._ADDBEFOREKEYS = 'addBeforeKeys';
oj.EventTargetMixin.applyMixin(DataSourceAdapter);

return DataSourceAdapter;
});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojdataprovideradapter',['ojs/ojcore', 'jquery', 'ojs/ojdataprovideradapter-base'], function(oj, $, DataSourceAdapter)
{
  "use strict";
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var TableDataSourceAdapter = /*#__PURE__*/function (_DataSourceAdapter) {
  _inherits(TableDataSourceAdapter, _DataSourceAdapter);

  var _super = _createSuper(TableDataSourceAdapter);

  function TableDataSourceAdapter(tableDataSource) {
    var _this;

    _classCallCheck(this, TableDataSourceAdapter);

    _this = _super.call(this, tableDataSource);
    _this.tableDataSource = tableDataSource;

    _this.FetchByKeysResults = /*#__PURE__*/function () {
      function _class(_parent, fetchParameters, results) {
        _classCallCheck(this, _class);

        this._parent = _parent;
        this.fetchParameters = fetchParameters;
        this.results = results;
        this[TableDataSourceAdapter._FETCHPARAMETERS] = fetchParameters;
        this[TableDataSourceAdapter._RESULTS] = results;
      }

      return _class;
    }();

    _this.ContainsKeysResults = /*#__PURE__*/function () {
      function _class2(_parent, containsParameters, results) {
        _classCallCheck(this, _class2);

        this._parent = _parent;
        this.containsParameters = containsParameters;
        this.results = results;
        this[TableDataSourceAdapter._CONTAINSPARAMETERS] = containsParameters;
        this[TableDataSourceAdapter._RESULTS] = results;
      }

      return _class2;
    }();

    _this.Item = /*#__PURE__*/function () {
      function _class3(_parent, metadata, data) {
        _classCallCheck(this, _class3);

        this._parent = _parent;
        this.metadata = metadata;
        this.data = data;
        this[TableDataSourceAdapter._METADATA] = metadata;
        this[TableDataSourceAdapter._DATA] = data;
      }

      return _class3;
    }();

    _this.FetchByOffsetResults = /*#__PURE__*/function () {
      function _class4(_parent, fetchParameters, results, done) {
        _classCallCheck(this, _class4);

        this._parent = _parent;
        this.fetchParameters = fetchParameters;
        this.results = results;
        this.done = done;
        this[TableDataSourceAdapter._FETCHPARAMETERS] = fetchParameters;
        this[TableDataSourceAdapter._RESULTS] = results;
        this[TableDataSourceAdapter._DONE] = done;
      }

      return _class4;
    }();

    _this.FetchListParameters = /*#__PURE__*/function () {
      function _class5(_parent, size, sortCriteria) {
        _classCallCheck(this, _class5);

        this._parent = _parent;
        this.size = size;
        this.sortCriteria = sortCriteria;
        this[TableDataSourceAdapter._SIZE] = size;
        this[TableDataSourceAdapter._SORTCRITERIA] = sortCriteria;
      }

      return _class5;
    }();

    _this._addTableDataSourceEventListeners();

    _this[TableDataSourceAdapter._OFFSET] = 0;
    _this._ignoreDataSourceEvents = new Array();
    return _this;
  }

  _createClass(TableDataSourceAdapter, [{
    key: "destroy",
    value: function destroy() {
      this._removeTableDataSourceEventListeners();
    }
  }, {
    key: "containsKeys",
    value: function containsKeys(params) {
      var self = this;
      var resultsPromiseArray = [];

      params[TableDataSourceAdapter._KEYS].forEach(function (key) {
        resultsPromiseArray.push(self.tableDataSource.get(key));
      });

      return Promise.all(resultsPromiseArray).then(function (resultsArray) {
        var results = new Set();
        resultsArray.map(function (value) {
          if (value != null) {
            results.add(value[TableDataSourceAdapter._KEY]);
          }
        });
        return Promise.resolve(new self.ContainsKeysResults(self, params, results));
      });
    }
  }, {
    key: "fetchByKeys",
    value: function fetchByKeys(params) {
      var self = this;
      var resultsPromiseArray = [];

      params[TableDataSourceAdapter._KEYS].forEach(function (key) {
        resultsPromiseArray.push(self.tableDataSource.get(key));
      });

      return Promise.all(resultsPromiseArray).then(function (resultsArray) {
        var results = new Map();
        resultsArray.map(function (value) {
          if (value != null) {
            var key = value[TableDataSourceAdapter._KEY];
            var data = value[TableDataSourceAdapter._DATA];
            results.set(key, new self.Item(self, new self.ItemMetadata(self, key), data));
          }
        });
        return Promise.resolve(new self.FetchByKeysResults(self, params, results));
      });
    }
  }, {
    key: "fetchByOffset",
    value: function fetchByOffset(params) {
      var self = this;
      var size = params != null ? params[TableDataSourceAdapter._SIZE] : -1;
      var sortCriteria = params != null ? params[TableDataSourceAdapter._SORTCRITERIA] : null;
      var offset = params != null ? params[TableDataSourceAdapter._OFFSET] > 0 ? params[TableDataSourceAdapter._OFFSET] : 0 : 0;
      var fetchParams = new this.FetchListParameters(this, size, sortCriteria);
      this._startIndex = 0;
      return this._getFetchFunc(fetchParams, offset)(fetchParams, true).then(function (iteratorResults) {
        var value = iteratorResults[TableDataSourceAdapter._VALUE];
        var done = iteratorResults[TableDataSourceAdapter._DONE];
        var data = value[TableDataSourceAdapter._DATA];

        var keys = value[TableDataSourceAdapter._METADATA].map(function (value) {
          return value[TableDataSourceAdapter._KEY];
        });

        var resultsArray = new Array();
        data.map(function (value, index) {
          resultsArray.push(new self.Item(self, new self.ItemMetadata(self, keys[index]), data[index]));
        });
        return new self.FetchByOffsetResults(self, params, resultsArray, done);
      });
    }
  }, {
    key: "fetchFirst",
    value: function fetchFirst(params) {
      if (!this._isPagingModelTableDataSource()) {
        this._startIndex = 0;
      }

      return new this.AsyncIterable(new this.AsyncIterator(this._getFetchFunc(params), params));
    }
  }, {
    key: "getCapability",
    value: function getCapability(capabilityName) {
      if (capabilityName == TableDataSourceAdapter._SORT && this.tableDataSource.getCapability(capabilityName) == 'full') {
        return {
          attributes: 'multiple'
        };
      } else if (capabilityName == 'fetchByKeys') {
        return {
          implementation: 'lookup'
        };
      } else if (capabilityName == 'fetchByOffset') {
        return {
          implementation: 'lookup'
        };
      }

      return null;
    }
  }, {
    key: "getTotalSize",
    value: function getTotalSize() {
      return Promise.resolve(this.tableDataSource.totalSize());
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this.tableDataSource.totalSize() > 0 ? 'no' : 'yes';
    } // Start PagingModel APIs

  }, {
    key: "getPage",
    value: function getPage() {
      if (this._isPagingModelTableDataSource()) {
        return this.tableDataSource.getPage();
      }

      return -1;
    }
  }, {
    key: "setPage",
    value: function setPage(value, options) {
      if (this._isPagingModelTableDataSource()) {
        return this.tableDataSource.setPage(value, options);
      }

      return Promise.reject(null);
    }
  }, {
    key: "getStartItemIndex",
    value: function getStartItemIndex() {
      if (this._isPagingModelTableDataSource()) {
        return this.tableDataSource.getStartItemIndex();
      }

      return -1;
    }
  }, {
    key: "getEndItemIndex",
    value: function getEndItemIndex() {
      if (this._isPagingModelTableDataSource()) {
        return this.tableDataSource.getEndItemIndex();
      }

      return -1;
    }
  }, {
    key: "getPageCount",
    value: function getPageCount() {
      if (this._isPagingModelTableDataSource()) {
        return this.tableDataSource.getPageCount();
      }

      return -1;
    }
  }, {
    key: "totalSize",
    value: function totalSize() {
      if (this._isPagingModelTableDataSource()) {
        return this.tableDataSource.totalSize();
      }

      return -1;
    }
  }, {
    key: "totalSizeConfidence",
    value: function totalSizeConfidence() {
      if (this._isPagingModelTableDataSource()) {
        return this.tableDataSource.totalSizeConfidence();
      }

      return null;
    } // End PagingModel APIs

    /**
     * Get the function which performs the fetch
     */

  }, {
    key: "_getFetchFunc",
    value: function _getFetchFunc(params, offset) {
      var self = this;

      if (params != null && params[TableDataSourceAdapter._SORTCRITERIA] != null) {
        var attribute = params[TableDataSourceAdapter._SORTCRITERIA][0][TableDataSourceAdapter._ATTRIBUTE];
        var direction = params[TableDataSourceAdapter._SORTCRITERIA][0][TableDataSourceAdapter._DIRECTION];
        this._ignoreSortEvent = true;

        if (!this._isPagingModelTableDataSource()) {
          this._startIndex = 0;
        }

        return function (attribute, direction) {
          return function (params, fetchFirst) {
            if (fetchFirst) {
              var sortParam = {};
              sortParam[TableDataSourceAdapter._KEY] = attribute;
              sortParam[TableDataSourceAdapter._DIRECTION] = direction;
              self[TableDataSourceAdapter._OFFSET] = 0;
              return self.tableDataSource.sort(sortParam).then(function () {
                self._ignoreSortEvent = false;
                return self._getTableDataSourceFetch(params, offset)(params);
              });
            } else {
              return self._getTableDataSourceFetch(params, offset)(params);
            }
          };
        }(attribute, direction);
      } else {
        return this._getTableDataSourceFetch(params, offset);
      }
    }
    /**
     * Get the function which invokes fetch() on TableDataSource
     */

  }, {
    key: "_getTableDataSourceFetch",
    value: function _getTableDataSourceFetch(params, offset) {
      var self = this;
      return function (params, fetchFirst) {
        var options = {};
        offset = offset > 0 ? offset : 0;

        if (self._startIndex != null) {
          options[TableDataSourceAdapter._STARTINDEX] = self._startIndex + offset;
        }

        options[TableDataSourceAdapter._PAGESIZE] = params != null && params[TableDataSourceAdapter._SIZE] > 0 ? params[TableDataSourceAdapter._SIZE] : null; // to maintain backward compatibility, Table will specify silent flag

        if (!self._isPagingModelTableDataSource() && params[TableDataSourceAdapter._SILENT]) {
          options[TableDataSourceAdapter._SILENT] = params[TableDataSourceAdapter._SILENT];
        }

        if (self.tableDataSource[TableDataSourceAdapter._SORTCRITERIA] != null && params[TableDataSourceAdapter._SORTCRITERIA] == null) {
          params[TableDataSourceAdapter._SORTCRITERIA] = [];
          var sortCriterion = new self.SortCriterion(self, self.tableDataSource[TableDataSourceAdapter._SORTCRITERIA][TableDataSourceAdapter._KEY], self.tableDataSource[TableDataSourceAdapter._SORTCRITERIA][TableDataSourceAdapter._DIRECTION]);

          params[TableDataSourceAdapter._SORTCRITERIA].push(sortCriterion);
        }

        options[TableDataSourceAdapter._FETCHTYPE] = params[TableDataSourceAdapter._FETCHTYPE];
        self._isFetching = true;
        return new Promise(function (resolve, reject) {
          self._fetchResolveFunc = resolve;
          self._fetchRejectFunc = reject;
          self._fetchParams = params;

          if (!self._requestEventTriggered) {
            // set a flag so that we can ignore request and sync events
            if (!self._isPagingModelTableDataSource() && !options[TableDataSourceAdapter._SILENT]) {
              self._ignoreDataSourceEvents.push(true);
            }

            self.tableDataSource.fetch(options).then(function (result) {
              if (!self._isPagingModelTableDataSource() && !options[TableDataSourceAdapter._SILENT]) {
                self._ignoreDataSourceEvents.pop();
              }

              if (result !== null) {
                self._isFetching = false;

                if (result === undefined) {
                  // fetch was not executed due to startFetch='disabled'
                  result = {};
                  result[TableDataSourceAdapter._KEYS] = [];
                  result[TableDataSourceAdapter._DATA] = [];
                }

                var resultMetadata = [];

                if (result[TableDataSourceAdapter._KEYS] != null) {
                  resultMetadata = result[TableDataSourceAdapter._KEYS].map(function (value) {
                    return new self.ItemMetadata(self, value);
                  });
                }

                if (self._startIndex == null) {
                  self._startIndex = 0;
                }

                var done = false;
                self._startIndex = self._startIndex + result[TableDataSourceAdapter._DATA].length;

                if (self.tableDataSource.totalSizeConfidence() == 'actual' && self.tableDataSource.totalSize() > 0 && result.startIndex + result[TableDataSourceAdapter._DATA].length >= self.tableDataSource.totalSize()) {
                  done = true;
                } else if (options[TableDataSourceAdapter._PAGESIZE] > 0 && result[TableDataSourceAdapter._DATA].length < options[TableDataSourceAdapter._PAGESIZE]) {
                  done = true;
                } else if (result[TableDataSourceAdapter._DATA].length == 0) {
                  done = true;
                }

                self._fetchResolveFunc = null;
                self._fetchParams = null;

                if (done) {
                  resolve(new self.AsyncIteratorReturnResult(self, new self.FetchListResult(self, params, result[TableDataSourceAdapter._DATA], resultMetadata)));
                } else {
                  resolve(new self.AsyncIteratorYieldResult(self, new self.FetchListResult(self, params, result[TableDataSourceAdapter._DATA], resultMetadata)));
                }
              }
            }, function (error) {
              if (!self._isPagingModelTableDataSource() && !options[TableDataSourceAdapter._SILENT]) {
                self._ignoreDataSourceEvents.pop();
              }

              reject(error);
            });
          }
        });
      };
    }
  }, {
    key: "_handleSync",
    value: function _handleSync(event) {
      var self = this; // checks for sync triggered by own fetch

      if (self._ignoreDataSourceEvents.length > 0) {
        return;
      }

      self._startIndex = null;

      if (event[TableDataSourceAdapter._STARTINDEX] > 0) {
        self._startIndex = event[TableDataSourceAdapter._STARTINDEX];
        self[TableDataSourceAdapter._OFFSET] = self._startIndex;
      }

      if (self._fetchResolveFunc && event[TableDataSourceAdapter._KEYS] != null) {
        self._isFetching = false;

        var resultMetadata = event[TableDataSourceAdapter._KEYS].map(function (value) {
          return new self.ItemMetadata(self, value);
        });

        var done = false;

        if (self.tableDataSource.totalSizeConfidence() == 'actual' && self.tableDataSource.totalSize() > 0 && self._startIndex + event[TableDataSourceAdapter._DATA].length >= self.tableDataSource.totalSize()) {
          done = true;
        }

        if (done) {
          self._fetchResolveFunc(new self.AsyncIteratorReturnResult(self, new self.FetchListResult(self, self._fetchParams, event[TableDataSourceAdapter._DATA], resultMetadata)));
        } else {
          self._fetchResolveFunc(new self.AsyncIteratorYieldResult(self, new self.FetchListResult(self, self._fetchParams, event[TableDataSourceAdapter._DATA], resultMetadata)));
        }

        self._fetchResolveFunc = null;
        self._fetchParams = null;
      } else if (!self._requestEventTriggered) {
        self.dispatchEvent(new oj.DataProviderRefreshEvent());
      }

      self._requestEventTriggered = false;
    }
  }, {
    key: "_handleAdd",
    value: function _handleAdd(event) {
      var self = this;

      var metadataArray = event[TableDataSourceAdapter._KEYS].map(function (value) {
        return new self.ItemMetadata(self, value);
      });

      var keySet = new Set();

      event[TableDataSourceAdapter._KEYS].map(function (key) {
        keySet.add(key);
      });

      var operationEventDetail = new self.DataProviderAddOperationEventDetail(self, keySet, null, null, null, metadataArray, event[TableDataSourceAdapter._DATA], event[TableDataSourceAdapter._INDEXES]);
      var mutationEventDetail = new self.DataProviderMutationEventDetail(self, operationEventDetail, null, null);
      self.dispatchEvent(new oj.DataProviderMutationEvent(mutationEventDetail));
    }
  }, {
    key: "_handleRemove",
    value: function _handleRemove(event) {
      var self = this;

      var metadataArray = event[TableDataSourceAdapter._KEYS].map(function (value) {
        return new self.ItemMetadata(self, value);
      });

      var keySet = new Set();

      event[TableDataSourceAdapter._KEYS].map(function (key) {
        keySet.add(key);
      });

      var operationEventDetail = new self.DataProviderOperationEventDetail(self, keySet, metadataArray, event[TableDataSourceAdapter._DATA], event[TableDataSourceAdapter._INDEXES]);
      var mutationEventDetail = new self.DataProviderMutationEventDetail(self, null, operationEventDetail, null);
      self.dispatchEvent(new oj.DataProviderMutationEvent(mutationEventDetail));
    }
  }, {
    key: "_handleReset",
    value: function _handleReset(event) {
      var self = this; // Dispatch a dataprovider refresh event except for the following situations:
      // 1. If a datasource request event was triggered, a dataprovider refresh event has been dispatched;
      // 2. If the datasource is a paging datasource, the pagingcontrol reset handler will indirectly trigger
      //    a datasource request event, which in turn will dispatch a dataprovider refresh event.
      //

      if (!self._requestEventTriggered && !self._isPagingModelTableDataSource()) {
        self._startIndex = 0;
        self.dispatchEvent(new oj.DataProviderRefreshEvent());
      }
    }
  }, {
    key: "_handleSort",
    value: function _handleSort(event) {
      var self = this;

      if (!self._ignoreSortEvent) {
        self._startIndex = null;
        self.dispatchEvent(new oj.DataProviderRefreshEvent());
      }
    }
  }, {
    key: "_handleChange",
    value: function _handleChange(event) {
      var self = this;

      var metadataArray = event[TableDataSourceAdapter._KEYS].map(function (value) {
        return new self.ItemMetadata(self, value);
      });

      var keySet = new Set();

      event[TableDataSourceAdapter._KEYS].map(function (key) {
        keySet.add(key);
      });

      var operationEventDetail = new self.DataProviderOperationEventDetail(self, keySet, metadataArray, event[TableDataSourceAdapter._DATA], event[TableDataSourceAdapter._INDEXES]);
      var mutationEventDetail = new self.DataProviderMutationEventDetail(self, null, null, operationEventDetail);
      self.dispatchEvent(new oj.DataProviderMutationEvent(mutationEventDetail));
    }
  }, {
    key: "_handleRefresh",
    value: function _handleRefresh(event) {
      var self = this;

      if (!self._isFetching && !self._requestEventTriggered) {
        if (event[TableDataSourceAdapter._OFFSET] != null) {
          self._startIndex = event[TableDataSourceAdapter._OFFSET];
        } else {
          self._startIndex = null;
        }

        self.dispatchEvent(new oj.DataProviderRefreshEvent());
      }

      self._requestEventTriggered = false;
    }
  }, {
    key: "_handleRequest",
    value: function _handleRequest(event) {
      var self = this; // checks for sync triggered by own fetch

      if (self._ignoreDataSourceEvents.length > 0) {
        return;
      } // to test backward compatibility we still need to be able to access Model from the oj namespace


      if (typeof oj.Model !== 'undefined' && event instanceof oj.Model) {
        // ignore request events by oj.Model. Those will be followed by row
        // mutation events anyway
        return;
      }

      if (!self._isFetching) {
        if (event[TableDataSourceAdapter._STARTINDEX] > 0 && self.getStartItemIndex() == 0) {
          self._startIndex = event[TableDataSourceAdapter._STARTINDEX];
        } // dispatch a refresh event which will trigger a the component to
        // do a fetchFirst. However, the fact that we are receiving a request
        // event means that a fetch was already done on the underlying TableDataSource.
        // So we don't need to do another fetch once a fetchFirst comes in, we can
        // just resolve with the results from the paired sync event.


        self._requestEventTriggered = true;
        self.dispatchEvent(new oj.DataProviderRefreshEvent());
      }
    }
  }, {
    key: "_handleError",
    value: function _handleError(event) {
      var self = this;

      if (self._fetchRejectFunc) {
        self._fetchRejectFunc(event);
      }

      self._isFetching = false;
      self._requestEventTriggered = false;
    }
  }, {
    key: "_handlePage",
    value: function _handlePage(event) {
      var self = this;
      self._isFetching = false;
      self._requestEventTriggered = false;
      var options = {};
      options['detail'] = event;
      self.dispatchEvent(new oj.GenericEvent(oj.PagingModel.EventType['PAGE'], options));
    }
    /**
     * Add event listeners to TableDataSource
     */

  }, {
    key: "_addTableDataSourceEventListeners",
    value: function _addTableDataSourceEventListeners() {
      this.removeAllListeners();
      this.addListener('sync', this._handleSync);
      this.addListener('add', this._handleAdd);
      this.addListener('remove', this._handleRemove);
      this.addListener('reset', this._handleReset);
      this.addListener('sort', this._handleSort);
      this.addListener('change', this._handleChange);
      this.addListener('refresh', this._handleRefresh);
      this.addListener('request', this._handleRequest);
      this.addListener('error', this._handleError);
      this.addListener('page', this._handlePage);
    }
    /**
     * Remove event listeners to TableDataSource
     */

  }, {
    key: "_removeTableDataSourceEventListeners",
    value: function _removeTableDataSourceEventListeners() {
      this.removeListener('sync');
      this.removeListener('add');
      this.removeListener('remove');
      this.removeListener('reset');
      this.removeListener('sort');
      this.removeListener('change');
      this.removeListener('refresh');
      this.removeListener('request');
      this.removeListener('error');
      this.removeListener('page');
    }
    /**
     * Check if it's a PagingModel TableDataSource
     */

  }, {
    key: "_isPagingModelTableDataSource",
    value: function _isPagingModelTableDataSource() {
      if (this.tableDataSource['getStartItemIndex'] != null) {
        return true;
      }

      return false;
    }
  }]);

  return TableDataSourceAdapter;
}(DataSourceAdapter);

TableDataSourceAdapter._STARTINDEX = 'startIndex';
TableDataSourceAdapter._SILENT = 'silent';
TableDataSourceAdapter._SORTCRITERIA = 'sortCriteria';
TableDataSourceAdapter._PAGESIZE = 'pageSize';
TableDataSourceAdapter._OFFSET = 'offset';
TableDataSourceAdapter._SIZE = 'size';
TableDataSourceAdapter._CONTAINSPARAMETERS = 'containsParameters';
TableDataSourceAdapter._RESULTS = 'results';
TableDataSourceAdapter._FETCHTYPE = 'fetchType';
oj.EventTargetMixin.applyMixin(TableDataSourceAdapter);
oj['TableDataSourceAdapter'] = TableDataSourceAdapter;
oj.TableDataSourceAdapter = TableDataSourceAdapter;

});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojlistview',['ojs/ojcore', 'jquery', 'require', 'ojs/ojdataproviderscroller', 'ojs/ojcontext', 'ojs/ojconfig', 'ojs/ojthemeutils', 'ojs/ojkeysetimpl', 'ojs/ojcomponentcore', 'ojs/ojdatacollection-common', 'ojs/ojanimation', 'ojs/ojlogger', 'ojs/ojkeyset', 'ojs/ojmap', 'ojs/ojdomscroller', 'ojs/ojdataprovideradapter'], function(oj, $, localRequire, List, Context, Config, ThemeUtils, KeySetImpl, Components, DataCollectionUtils, AnimationUtils, Logger, KeySet, KeyMap)
{
  "use strict";

var __oj_list_view_metadata = 
{
  "properties": {
    "as": {
      "type": "string",
      "value": ""
    },
    "currentItem": {
      "type": "any",
      "writeback": true
    },
    "data": {
      "type": "object"
    },
    "display": {
      "type": "string",
      "enumValues": [
        "card",
        "list"
      ],
      "value": "list"
    },
    "dnd": {
      "type": "object",
      "properties": {
        "drag": {
          "type": "object",
          "properties": {
            "items": {
              "type": "object",
              "properties": {
                "dataTypes": {
                  "type": "string|Array<string>"
                },
                "drag": {
                  "type": "function"
                },
                "dragEnd": {
                  "type": "function"
                },
                "dragStart": {
                  "type": "function"
                }
              }
            }
          }
        },
        "drop": {
          "type": "object",
          "properties": {
            "items": {
              "type": "object",
              "properties": {
                "dataTypes": {
                  "type": "string|Array<string>"
                },
                "dragEnter": {
                  "type": "function"
                },
                "dragLeave": {
                  "type": "function"
                },
                "dragOver": {
                  "type": "function"
                },
                "drop": {
                  "type": "function"
                }
              }
            }
          }
        },
        "reorder": {
          "type": "object",
          "properties": {
            "items": {
              "type": "string",
              "enumValues": [
                "disabled",
                "enabled"
              ],
              "value": "disabled"
            }
          }
        }
      }
    },
    "drillMode": {
      "type": "string",
      "enumValues": [
        "collapsible",
        "none"
      ],
      "value": "collapsible"
    },
    "expanded": {
      "type": "KeySet",
      "writeback": true
    },
    "firstSelectedItem": {
      "type": "object",
      "writeback": true,
      "readOnly": true,
      "value": {
        "key": null,
        "data": null
      }
    },
    "gridlines": {
      "type": "object",
      "properties": {
        "item": {
          "type": "string",
          "enumValues": [
            "hidden",
            "visible",
            "visibleExceptLast"
          ],
          "value": "visible"
        }
      }
    },
    "groupHeaderPosition": {
      "type": "string",
      "enumValues": [
        "static",
        "sticky"
      ],
      "value": "sticky"
    },
    "item": {
      "type": "object",
      "properties": {
        "focusable": {
          "type": "boolean|function",
          "value": true
        },
        "renderer": {
          "type": "function"
        },
        "selectable": {
          "type": "boolean|function",
          "value": true
        }
      }
    },
    "scrollPolicy": {
      "type": "string",
      "enumValues": [
        "auto",
        "loadAll",
        "loadMoreOnScroll"
      ],
      "value": "auto"
    },
    "scrollPolicyOptions": {
      "type": "Object<string, number>",
      "properties": {
        "fetchSize": {
          "type": "number",
          "value": 25
        },
        "maxCount": {
          "type": "number",
          "value": 500
        },
        "scroller": {
          "type": "Element"
        }
      }
    },
    "scrollPosition": {
      "type": "object",
      "writeback": true,
      "value": {
        "x": 0,
        "y": 0
      },
      "properties": {
        "x": {
          "type": "number"
        },
        "y": {
          "type": "number"
        },
        "index": {
          "type": "number"
        },
        "parent": {
          "type": "any"
        },
        "key": {
          "type": "any"
        },
        "offsetX": {
          "type": "number"
        },
        "offsetY": {
          "type": "number"
        }
      }
    },
    "selected": {
      "type": "KeySet",
      "writeback": true
    },
    "selection": {
      "type": "Array<any>",
      "writeback": true,
      "value": []
    },
    "selectionMode": {
      "type": "string",
      "enumValues": [
        "multiple",
        "none",
        "single"
      ],
      "value": "none"
    },
    "selectionRequired": {
      "type": "boolean",
      "value": false
    },
    "translations": {
      "type": "object",
      "value": {},
      "properties": {
        "accessibleNavigateSkipItems": {
          "type": "string"
        },
        "accessibleReorderAfterItem": {
          "type": "string"
        },
        "accessibleReorderBeforeItem": {
          "type": "string"
        },
        "accessibleReorderInsideItem": {
          "type": "string"
        },
        "accessibleReorderTouchInstructionText": {
          "type": "string"
        },
        "indexerCharacters": {
          "type": "string"
        },
        "labelCopy": {
          "type": "string"
        },
        "labelCut": {
          "type": "string"
        },
        "labelPaste": {
          "type": "string"
        },
        "labelPasteAfter": {
          "type": "string"
        },
        "labelPasteBefore": {
          "type": "string"
        },
        "msgFetchingData": {
          "type": "string"
        },
        "msgItemsAppended": {
          "type": "string"
        },
        "msgNoData": {
          "type": "string"
        }
      }
    }
  },
  "methods": {
    "refresh": {},
    "getContextByNode": {},
    "getDataForVisibleItem": {},
    "getIndexerModel": {},
    "scrollToItem": {},
    "setProperty": {},
    "getProperty": {},
    "setProperties": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "events": {
    "ojAnimateStart": {},
    "ojAnimateEnd": {},
    "ojBeforeCurrentItem": {},
    "ojBeforeExpand": {},
    "ojBeforeCollapse": {},
    "ojCollapse": {},
    "ojCopy": {},
    "ojCut": {},
    "ojExpand": {},
    "ojItemAction": {},
    "ojPaste": {},
    "ojReorder": {}
  },
  "extension": {}
};


/* global List:false, Promise:false, Symbol:false, Logger:false, Context:false, KeyMap:false, Set:false */

/**
 * Handler for TreeDataProvider generated content
 * @constructor
 * @extends oj.DataSourceContentHandler
 * @ignore
 */
oj.TreeDataProviderContentHandler = function (widget, root, data) {
  oj.TreeDataProviderContentHandler.superclass.constructor.call(this, widget, root, data);
}; // Subclass from oj.DataSourceContentHandler


oj.Object.createSubclass(oj.TreeDataProviderContentHandler, List.DataProviderContentHandler, 'oj.TreeDataProviderContentHandler'); // number of skeleton items to render for expand node

oj.TreeDataProviderContentHandler.NUM_CHILD_SKELETONS = 3;
/**
 * Initializes the instance.
 * @protected
 */

oj.TreeDataProviderContentHandler.prototype.Init = function () {
  oj.TreeDataProviderContentHandler.superclass.Init.call(this);
  this.m_childDataProviders = new KeyMap();
  this.m_fetchCalls = new Set();
};
/**
 * Determines whether the conent is hierarchical.
 * @return {boolean} returns true if content is hierarhical, false otherwise.
 * @protected
 */


oj.TreeDataProviderContentHandler.prototype.IsHierarchical = function () {
  return true;
};
/**
 * @private
 */


oj.TreeDataProviderContentHandler.prototype._getChildDataProvider = function (key) {
  if (key === null) {
    return this.getDataProvider();
  }

  var childDataProvider = this.m_childDataProviders.get(key);

  if (childDataProvider == null) {
    childDataProvider = this.getDataProvider().getChildDataProvider(key);

    if (childDataProvider) {
      this.m_childDataProviders.set(key, childDataProvider);
    }
  }

  return childDataProvider;
};
/**
 * @protected
 */


oj.TreeDataProviderContentHandler.prototype.fetchRows = function (forceFetch) {
  this.signalTaskStart('fetching rows'); // signal method task start

  oj.TreeDataProviderContentHandler.superclass.fetchRows.call(this, forceFetch);
  this.m_fetchCalls.clear();

  this._fetchChildren(null, this.m_root, null);

  this.signalTaskEnd(); // signal method task end
};
/**
 * @private
 */


oj.TreeDataProviderContentHandler.prototype._fetchChildren = function (parent, parentElem, successCallback, errorCallback) {
  var self = this;
  this.signalTaskStart('fetching children from parent: ' + parent); // signal method task start
  // initiate loading of template engine, note it will not load it unless a template has been specified

  var enginePromise = this.loadTemplateEngine(); // root node would not have expand/collapse icon

  if (parent != null) {
    var anchor = parentElem.parentNode.firstElementChild.firstElementChild.firstElementChild;

    if (anchor) {
      anchor = $(anchor);
      var collapseClass = this.m_widget.getCollapseIconStyleClass(); // switch to loading icon

      if (anchor.hasClass(collapseClass)) {
        var expandingClass = this.isSkeletonSupport() ? this.m_widget.getExpandIconStyleClass() : this.m_widget.getExpandingIconStyleClass();
        anchor.removeClass(collapseClass).addClass(expandingClass);
      }
    }
  } // no need to check ready since multiple fetch from different parents can occur at the same time


  this.m_fetching = true;

  if (parent != null) {
    this.m_fetchCalls.add(parent);
  } // Create a clientId symbol that uniquely identify this consumer so that
  // DataProvider which supports it can optimize resources


  this._clientId = this._clientId || Symbol(); // use -1 to fetch all child rows

  var options = {
    clientId: this._clientId,
    size: -1
  };
  this.signalTaskStart('first fetch');

  var dataProvider = this._getChildDataProvider(parent);

  var dataProviderAsyncIterator = dataProvider.fetchFirst(options)[Symbol.asyncIterator]();
  var promise = dataProviderAsyncIterator.next(); // new helper function to be called in recursion to fetch all data.

  var helperFunction = function helperFunction(values) {
    // skip additional fetching if done
    if (values[0].done) {
      return values;
    }

    var nextPromise = dataProviderAsyncIterator.next();
    var fetchMoreData = nextPromise.then(function (value) {
      // eslint-disable-next-line no-param-reassign
      values[0].done = value.done; // eslint-disable-next-line no-param-reassign

      values[0].value.data = values[0].value.data.concat(value.value.data); // eslint-disable-next-line no-param-reassign

      values[0].value.metadata = values[0].value.metadata.concat(value.value.metadata);
      return helperFunction(values);
    }, function (reason) {
      if (parent != null) {
        self.m_fetchCalls.delete(parent);
      }

      if (errorCallback) {
        errorCallback(reason);
      }

      self._handleFetchError(reason);

      self.signalTaskEnd(); // first fetch
    });
    return fetchMoreData;
  };

  Promise.all([promise, enginePromise]).then(function (values) {
    return helperFunction(values);
  }, function (reason) {
    self._handleFetchError(reason);

    self.signalTaskEnd(); // first fetch
  }).then(function (values) {
    // check if content handler has been destroyed already
    if (self.m_widget == null) {
      self.signalTaskEnd(); // first fetch

      return;
    }

    var value = values[0];
    var templateEngine = values[1];

    if (templateEngine) {
      // clean nodes generated by templateengine before
      self.cleanItems(templateEngine, parentElem);
    } // append loading indicator at the end as needed


    self._handleFetchSuccess(value, parent, parentElem, successCallback, templateEngine);

    self.signalTaskEnd(); // first fetch
  });
  this.signalTaskEnd(); // signal method task end
};
/**
 * Promise that is resolved when all fetchChildren calls triggered by a single fetch
 * has been completed.
 * @private
 */


oj.TreeDataProviderContentHandler.prototype._getAtomicFetchChildPromise = function () {
  var self = this; // eslint-disable-next-line no-unused-vars

  return new Promise(function (resolve, reject) {
    self.m_fetchResolve = resolve;
  });
};

oj.TreeDataProviderContentHandler.prototype._handleFetchSuccess = function (dataObj, parent, parentElem, successCallback, templateEngine) {
  var self = this; // listview might have been destroyed before fetch success is handled

  if (this.m_widget == null || dataObj.value == null) {
    return;
  }

  this.signalTaskStart('handling successful fetch'); // signal method task start
  // fetch is done

  this.m_fetching = false;

  if (parent != null) {
    this.m_fetchCalls.delete(parent);
  }

  function postProcessing() {
    if (self.m_widget) {
      // if a callback is specified (as it is in the expand case), then invoke it
      if (successCallback != null) {
        successCallback.call(null, parentElem);
      }

      self.m_widget.renderComplete(); // process any outstanding events

      self._processEventQueue();
    }
  }

  var data = dataObj.value.data;
  var keys = dataObj.value.metadata.map(function (value) {
    return value.key;
  });
  var metadata = dataObj.value.metadata;

  if (data.length === keys.length) {
    var index = 0;
    var fragment = document.createDocumentFragment();

    for (var i = 0; i < data.length; i++) {
      var row = data[i]; // passing -1 for opt since we know it will be inserted at the end of the parent

      this.addItem(fragment, -1, row, this.getMetadata(index, keys[i], row, parentElem), templateEngine, null, metadata[i]);
      index += 1;
    } // check whether we are still expanding and therefore hold off appending child nodes
    // also, we'll switch this off for NavList since it breaks the drill replace mode


    if (this.m_fetchResolve != null || !this.shouldUseGridRole()) {
      // subtree of what is currently expanding, so we should just be able to add it immediately
      // (the root is still not attached yet)
      $(parentElem).empty();
      parentElem.appendChild(fragment); // @HTMLUpdateOK

      if (!this.shouldUseGridRole()) {
        // NavList case
        postProcessing();
      } else if (successCallback != null) {
        successCallback.call(null, parentElem);
      }
    } else if (this.m_fetchCalls.size > 0) {
      this._getAtomicFetchChildPromise().then(function () {
        this.animateShowContent(parentElem, fragment, true).then(function () {
          postProcessing();
        });
      }.bind(this));
    } else {
      this.animateShowContent(parentElem, fragment, true).then(function () {
        postProcessing();
      });
    } // update aria-colspan on the gridcell representing the group header


    if (this.shouldUseGridRole() && this.isCardLayout() && parent != null && index > 0) {
      var gridcell = parentElem.parentNode.firstElementChild.firstElementChild;
      $(gridcell).attr('aria-colspan', index + 1);
    }
  } // check if there's no more outstanding fetch children calls


  if (this.m_fetchCalls.size === 0) {
    if (this.m_fetchResolve != null) {
      this.m_fetchResolve();
      this.m_fetchResolve = null;
    }
  }

  this.m_initialized = true;
  this.signalTaskEnd(); // signal method task end
};
/**
 * Creates the context object containing metadata
 * @param {Element} parent the parent element
 * @param {number} index the index
 * @param {Object} key the key
 * @param {Object} data the data
 * @return {Object} the context object
 * @private
 */


oj.TreeDataProviderContentHandler.prototype.getMetadata = function (index, key, data, parentElem) {
  var context = oj.TreeDataProviderContentHandler.superclass.getMetadata.call(this, index, key, data, parentElem);

  var childDataProvider = this._getChildDataProvider(key);

  context.leaf = childDataProvider === null; // walk up to calculate the depth

  var depth = 0;
  var curr = parentElem;

  while (curr && curr !== this.m_root) {
    curr = curr.parentElement.parentElement;
    depth += 1;
  }

  context.depth = depth;
  return context;
};
/**
 * Creates a binding context based on context object
 * To be override by different ContentHandler
 * @protected
 */


oj.TreeDataProviderContentHandler.prototype.GetBindingContext = function (context) {
  var bindingContext = oj.TreeDataProviderContentHandler.superclass.GetBindingContext.call(this, context);
  bindingContext.depth = context.depth;
  bindingContext.leaf = context.leaf;
  bindingContext.parentKey = context.parentKey;
  return bindingContext;
};

oj.TreeDataProviderContentHandler.prototype.afterRenderItem = function (item, context, isCustomizeItem) {
  this.signalTaskStart('after rendering an item'); // signal method task start

  oj.TreeDataProviderContentHandler.superclass.afterRenderItem.call(this, item, context, isCustomizeItem);
  var groupStyleClass = this.m_widget.getGroupStyleClass();
  var itemStyleClass = this.m_widget.getItemStyleClass();
  var groupItemStyleClass = this.m_widget.getGroupItemStyleClass(true);
  var groupCollapseStyleClass = this.m_widget.getGroupCollapseStyleClass();
  var collapseClass = this.m_widget.getCollapseIconStyleClass();
  var focusedStyleClass = this.m_widget.getFocusedElementStyleClass(); // eslint-disable-next-line no-param-reassign

  item = $(item);

  if (context.leaf === false) {
    item.children().wrapAll('<div></div>'); // @HTMLUpdateOK
    // collapsed by default

    if (item.hasClass(focusedStyleClass)) {
      item.removeClass(focusedStyleClass).children().first().addClass(focusedStyleClass).attr('aria-expanded', 'false');
    } else {
      item.children().first().attr('role', 'presentation').find('.' + focusedStyleClass).attr('aria-expanded', 'false');
    }

    var content = item.children().first();
    content.uniqueId().addClass(groupItemStyleClass); // add the expand icon

    if (this.m_widget.isExpandable()) {
      item.addClass('oj-collapsed');
      var icon = document.createElement('a');
      $(icon).attr('href', '#').attr('aria-labelledby', content.get(0).id).addClass('oj-component-icon oj-clickable-icon-nocontext').addClass(collapseClass);
      content.prepend(icon); // @HTMLUpdateOK
    }

    if (this.shouldUseGridRole()) {
      content.get(0).removeAttribute('aria-expanded');
      content.removeClass(focusedStyleClass);
      content.attr('role', 'row');
      content.children().wrapAll("<div role='gridcell' aria-expanded='false' class='oj-listview-cell-element " + // @HTMLUpdateOK
      focusedStyleClass + "'></div>");
    } // the yet to be expand group element


    var groupItem = document.createElement('ul');
    var role;

    if (this.shouldUseGridRole()) {
      if (this.isCardLayout()) {
        role = 'row';
      } else {
        role = 'presentation';
      }
    } else {
      role = 'group';
    }

    $(groupItem).addClass(groupStyleClass).addClass(groupCollapseStyleClass).attr('role', role);
    item.append(groupItem); // @HTMLUpdateOK
  } else if (context.leaf === true) {
    item.addClass(itemStyleClass); // if item root (<LI>) is not specified, add a default layout class

    if (!isCustomizeItem && this.m_widget.getItemLayoutStyleClass) {
      item.addClass(this.m_widget.getItemLayoutStyleClass());
    }
  }

  if (this.m_widget._isSelectionEnabled() && this.isSelectable(context)) {
    this.m_widget.getFocusItem(item).attr('aria-selected', false);
  } // callback to widget


  this.m_widget.itemRenderComplete(item[0], context);
  this.signalTaskEnd(); // signal method task end
};

oj.TreeDataProviderContentHandler.prototype._handleFetchError = function (status) {
  // listview might have been destroyed before fetch error is handled
  if (this.m_widget == null) {
    Logger.info('handleFetchError: widget has already been destroyed');
    return;
  }

  this.signalTaskStart('handling fetch error: ' + status); // signal method task start
  // TableDataSource aren't giving me any error message

  Logger.error(status);
  this.m_widget.renderComplete();
  this.signalTaskEnd(); // signal method task end
};

oj.TreeDataProviderContentHandler.prototype.Expand = function (item, successCallback) {
  this.signalTaskStart('expanding an item'); // signal method task start

  var parentKey = this.GetKey(item[0]);
  var parentElem = item.children('ul')[0];
  var showSkeletonTimeout;

  if (this.isSkeletonSupport()) {
    showSkeletonTimeout = setTimeout(function () {
      // @HTMLUpdateOK
      this._renderExpandSkeletons(parentElem);
    }.bind(this), this.m_widget._getShowStatusDelay());
  }

  this._fetchChildren(parentKey, parentElem, function (args) {
    if (showSkeletonTimeout) {
      clearTimeout(showSkeletonTimeout);
    }

    successCallback(args);
    parentElem.classList.remove('oj-listview-skeleton-container');
  }, function () {
    this._destroyExpandSkeletons(parentElem);

    this._handleFetchError();
  }.bind(this));

  this.signalTaskEnd(); // signal method task end
};

oj.TreeDataProviderContentHandler.prototype.Collapse = function (item) {
  // template engine should have already been loaded
  var templateEngine = this.getTemplateEngine();

  if (templateEngine) {
    templateEngine.clean(item.get(0));
  } // remove all children nodes


  item.empty();
};
/**
 * @protected
 */


oj.TreeDataProviderContentHandler.prototype.addItemsForModelInsert = function (data, indexes, keys, parentKeys, isBeforeKeys, refKeys, metadata) {
  // template engine should have already been loaded
  var templateEngine = this.getTemplateEngine();

  for (var i = 0; i < data.length; i++) {
    this.signalTaskStart('handling model add event for item: ' + keys[i]); // signal add item start

    var parentElem = this.m_root;

    if (parentKeys !== undefined) {
      parentElem = parentKeys[i] == null ? this.m_root : this.FindElementByKey(parentKeys[i]);

      if (parentElem && parentElem !== this.m_root) {
        // take the <ul> inside the <li>
        parentElem = parentElem.lastElementChild;
      }
    } // indexes takes precedence


    var index;

    if (indexes != null) {
      index = indexes[i];
    } else {
      index = this._getIndex(refKeys, i);

      if (index > -1) {
        index = isBeforeKeys ? index : index + 1;
      }
    }

    this.addItem(parentElem, index, data[i], this.getMetadata(index, keys[i], data[i], parentElem), templateEngine, this.afterRenderItemForInsertEvent.bind(this), metadata != null ? metadata[i] : null);
    this.signalTaskEnd(); // signal add item end
  }
};
/**
 * @protected
 */


oj.TreeDataProviderContentHandler.prototype.afterRenderItemForInsertEvent = function (item, context, isCustomizeItem) {
  if (context.leaf === false) {
    // if it's a group node, we just need to call afterRenderItem
    this.afterRenderItem(item, context, isCustomizeItem);
  } else {
    oj.TreeDataProviderContentHandler.superclass.afterRenderItemForInsertEvent.call(this, item, context, isCustomizeItem);
  }
};
/**
 * @protected
 */


oj.TreeDataProviderContentHandler.prototype.handleModelRefreshEvent = function (event) {
  if (this.m_root == null) {
    return;
  } // if listview is busy, hold that off until later, the refresh must be handled in order
  // since we don't know when the results are coming back in


  if (!this.IsReady()) {
    this._pushToEventQueue({
      type: event.type,
      event: event
    });

    return;
  }

  this.signalTaskStart('handling model refresh event'); // signal method task start
  // since we are refetching everything, we should just clear out any outstanding model events

  this._clearEventQueue(); // empty everything (later) and clear cache


  this.m_widget.ClearCache(); // clear cached child DataProviders

  this.m_childDataProviders.clear(); // reset focus if needed

  this.m_widget.resetFocusBeforeRefresh(); // fetch data

  this.fetchRows(true);
  this.signalTaskEnd(); // signal method task end
};

oj.TreeDataProviderContentHandler.prototype.renderInitialSkeletons = function () {
  // empty out root element before adding skeletons
  if (this.m_superRoot) {
    this.m_root = this.m_superRoot;
    this.m_superRoot = null;
  }

  $(this.m_root).empty(); // determines how many items needed to fill the viewport

  var height = this.getRootElementHeight();
  var skeletonDimension = this.getDefaultSkeletonDimension();
  var count = 0;

  if (skeletonDimension.width > 0 && skeletonDimension.height > 0) {
    var skeletonSetHeight = skeletonDimension.height * (1 + oj.TreeDataProviderContentHandler.NUM_CHILD_SKELETONS); // one parent + 3 children

    count = Math.ceil(height / skeletonSetHeight);
  }

  var container = document.createElement('li');
  container.setAttribute('role', 'presentation');
  container.classList.add('oj-listview-initial-skeletons');
  var list = document.createElement('ul');
  list.setAttribute('role', 'presentation');
  list.classList.add(this.m_widget.getGroupStyleClass());
  list.classList.add('oj-listview-skeleton-container');

  for (var i = 0; i < count; i++) {
    list.appendChild(this.createSkeletonItem()); // @HTMLUpdateOK

    var parent = document.createElement('li');
    var children = document.createElement('ul');
    children.classList.add('oj-listview-child-skeleton');
    parent.appendChild(children);
    children.appendChild(this.createSkeletonItem()); // @HTMLUpdateOK

    children.appendChild(this.createSkeletonItem()); // @HTMLUpdateOK

    children.appendChild(this.createSkeletonItem()); // @HTMLUpdateOK

    list.appendChild(parent);
  }

  container.appendChild(list); // @HTMLUpdateOK

  this.m_root.appendChild(container); // @HTMLUpdateOK
};

oj.TreeDataProviderContentHandler.prototype._renderExpandSkeletons = function (elem) {
  // make sure maxHeight wasn't set
  // eslint-disable-next-line no-param-reassign
  elem.style.maxHeight = 'none';

  for (var i = 0; i < oj.TreeDataProviderContentHandler.NUM_CHILD_SKELETONS; i++) {
    elem.appendChild(this.createSkeletonItem()); // @HTMLUpdateOK
  }

  elem.classList.add('oj-listview-skeleton-container');
  elem.setAttribute('data-oj-initial-height', this._getExpandSkeletonHeight(elem));
};

oj.TreeDataProviderContentHandler.prototype._destroyExpandSkeletons = function (elem) {
  $(elem).empty();
};

oj.TreeDataProviderContentHandler.prototype._getExpandSkeletonHeight = function (elem) {
  if (this.m_expandSkeletonHeight == null || this.m_expandSkeletonHeight === 0) {
    this.m_expandSkeletonHeight = elem.offsetHeight;
  }

  return this.m_expandSkeletonHeight;
};



/* global Context:false, KeyMap:false, KeySet:false, DataCollectionUtils:false */

/**
 * Handler for static HTML content
 * @constructor
 * @ignore
 */
oj.StaticContentHandler = function (widget, root) {
  this.m_widget = widget;
  this.m_root = root;
}; // Subclass from oj.Object


oj.Object.createSubclass(oj.StaticContentHandler, oj.Object, 'oj.StaticContentHandler');
/**
 * Initializes the instance.
 * @protected
 */

oj.StaticContentHandler.prototype.Init = function () {
  oj.StaticContentHandler.superclass.Init.call(this);
};
/**
 * Destroy the content handler
 * @protected
 */


oj.StaticContentHandler.prototype.Destroy = function () {
  // check if it's been destroyed or in process
  if (!this.m_root.hasAttribute('role')) {
    return;
  }

  this.restoreContent(this.m_root, 0);
  this.unsetRootAriaProperties();
};
/**
 * Determine whether the content handler is ready
 * @return {boolean} returns true there's no outstanding request, false otherwise.
 * @protected
 */


oj.StaticContentHandler.prototype.IsReady = function () {
  // static content does not fetch
  return true;
};

oj.StaticContentHandler.prototype.notifyShown = function () {// do nothing since all items are present
};

oj.StaticContentHandler.prototype.notifyAttached = function () {// do nothing since all items are present
};

oj.StaticContentHandler.prototype.RenderContent = function () {
  var root = this.m_root;

  if (this.shouldUseGridRole() && this.isCardLayout() && !this.IsHierarchical() && $(root).children('li').length > 0) {
    // in card layout, this is going to be a single row, N columns grid
    // so we'll need to wrap all <li> within a row
    $(this.m_root).children().wrapAll("<li role='presentation'><ul role='row' class='" + // @HTMLUpdateOK
    this.m_widget.getGroupStyleClass() + "'></ul></li>");
    var wrapped = $(this.m_root).children('li').first().get(0);
    wrapped.style.width = '100%';
    wrapped.classList.add('oj-listview-group-container');
    root = wrapped.firstElementChild;
  }

  this.modifyContent(root, 0);
  this.setRootAriaProperties();
  this.m_widget.renderComplete();
  var self = this;
  var busyContext = Context.getContext(root).getBusyContext();
  busyContext.whenReady().then(function () {
    if (root != null) {
      var children = $(root).find('li.' + self.m_widget.getItemElementStyleClass());

      for (var i = 0; i < children.length; i++) {
        self.m_widget.disableAllTabbableElements(children[i]);
      }
    }
  });
};

oj.StaticContentHandler.prototype.Expand = function (item, successCallback) {
  var selector = '.' + this.m_widget.getGroupStyleClass();
  var groupItem = $(item).children(selector)[0];
  $(groupItem).css('display', '');
  successCallback.call(null, groupItem);
}; // eslint-disable-next-line no-unused-vars


oj.StaticContentHandler.prototype.Collapse = function (item) {// nothing to do
};

oj.StaticContentHandler.prototype.IsHierarchical = function () {
  if (this.m_hier == null) {
    this.m_hier = $(this.m_root).children('li').children('ul').length > 0;
  }

  return this.m_hier;
};
/**
 * Restore the static content into its original format by removing all ListView specific style classes and attributes.
 * @param {Element} elem the element it is currently restoring
 * @param {number} depth the depth of the element it is currently restoring
 * @private
 */


oj.StaticContentHandler.prototype.restoreContent = function (elem, depth) {
  var groupStyleClass = this.m_widget.getGroupStyleClass();
  var groupCollapseStyleClass = this.m_widget.getGroupCollapseStyleClass();
  var groupExpandStyleClass = this.m_widget.getGroupExpandStyleClass();
  var groupItemStyleClass = this.m_widget.getGroupItemStyleClass();
  var itemStyleClass = this.m_widget.getItemStyleClass();
  var itemElementStyleClass = this.m_widget.getItemElementStyleClass();
  var itemLayoutStyleClass = null;

  if (this.m_widget.getItemLayoutStyleClass) {
    itemLayoutStyleClass = this.m_widget.getItemLayoutStyleClass();
  }

  var firstChild = elem.firstElementChild;

  if (firstChild && firstChild.classList.contains('oj-listview-group-container')) {
    $(firstChild).children().unwrap().children().unwrap();
  }

  var items = elem.children;

  for (var i = 0; i < items.length; i++) {
    var item = $(items[i]); // skip children that are not modified, this could happen if ko:foreach backed by an observable array is used to generate
    // the content, and the observable array has changed

    if (item.hasClass(itemElementStyleClass)) {
      this.unsetAriaProperties(item.get(0));

      if (item.hasClass('oj-listview-card')) {
        item.removeClass('oj-listview-card').removeClass('oj-listview-card-animated').removeClass('oj-card-initial-exit-animation');
        item[0].style.opacity = 1;
      }

      item.removeClass(itemElementStyleClass).removeClass(itemStyleClass).removeClass(itemLayoutStyleClass).removeClass(this.m_widget.getDepthStyleClass(depth)).removeClass('gridline-hidden').removeClass('oj-listview-item').removeClass('oj-listview-item-element').removeClass('oj-skipfocus').removeClass('oj-focus').removeClass('oj-hover').removeClass('oj-expanded').removeClass('oj-collapsed').removeClass('oj-selected');
      var groupItems = item.children('ul');

      if (groupItems.length > 0) {
        item.children('.' + groupItemStyleClass).children().unwrap();

        if (this.shouldUseGridRole()) {
          this.unsetGroupAriaProperties(item);
        }

        item.children('.oj-component-icon').remove();
        var groupItem = $(groupItems[0]);
        groupItem.removeClass(groupStyleClass).removeClass(groupExpandStyleClass).removeClass(groupCollapseStyleClass).removeAttr('role');
        this.restoreContent(groupItem[0], depth + 1);
      }
    }
  }
};
/**
 * Modify the static content to include ListView specific style classes and attributes.
 * @param {Element} elem the element it is currently modifying
 * @param {number} depth the depth of the element it is currently modifying
 * @private
 */


oj.StaticContentHandler.prototype.modifyContent = function (elem, depth) {
  var itemStyleClass = this.m_widget.getItemStyleClass();
  var itemElementStyleClass = this.m_widget.getItemElementStyleClass();
  var groupStyleClass = this.m_widget.getGroupStyleClass();
  var groupItemStyleClass = this.m_widget.getGroupItemStyleClass(true);
  var groupCollapseStyleClass = this.m_widget.getGroupCollapseStyleClass();
  var collapseClass = this.m_widget.getCollapseIconStyleClass();
  var focusedElementStyleClass = this.m_widget.getFocusedElementStyleClass();
  var items = elem.children;
  var expandable = this.m_widget.isExpandable();

  for (var i = 0; i < items.length; i++) {
    var item = $(items[i]);
    var context = this.createContext(item);
    this.setAriaProperties(item, context);
    item.uniqueId().addClass(itemElementStyleClass);

    if (depth > 0) {
      item.addClass(this.m_widget.getDepthStyleClass(depth));
    } // tag it if item is not focusable


    if (!this.isFocusable(context)) {
      item.addClass('oj-skipfocus');
    }

    var groupItems = item.children('ul');

    if (groupItems.length > 0) {
      this.m_hier = true;
      item.children(':not(ul)').wrapAll('<div></div>'); // @HTMLUpdateOK

      var content = item.children().first();
      content.addClass(groupItemStyleClass);
      var count = this.getItemsCount(groupItems[0]);

      if (count > 0) {
        if (item.hasClass(focusedElementStyleClass)) {
          item.removeClass(focusedElementStyleClass);
          content.addClass(focusedElementStyleClass).attr('aria-expanded', 'false');
        } else {
          content.attr('role', 'presentation');
          content.find('.' + focusedElementStyleClass).attr('aria-expanded', 'false');
        } // add the expand icon


        if (expandable) {
          item.addClass('oj-collapsed');
          content.uniqueId(); // add the expand icon

          var icon = document.createElement('a');
          $(icon).attr('href', '#').attr('role', 'button').attr('aria-labelledby', content.get(0).id).addClass('oj-component-icon oj-clickable-icon-nocontext').addClass(collapseClass);
          content.prepend(icon); // @HTMLUpdateOK
        }
      } else {
        content.addClass('oj-empty');
      }

      if (this.shouldUseGridRole()) {
        this.setGroupAriaProperties(content, count);
      }

      var groupItem = $(groupItems[0]);
      var role;

      if (this.shouldUseGridRole()) {
        if (this.isCardLayout()) {
          role = 'row';
        } else {
          role = 'presentation';
        }
      } else {
        role = 'group';
      }

      groupItem.addClass(groupStyleClass).addClass(groupCollapseStyleClass).attr('role', role).css('display', 'none');
      this.modifyContent(groupItem[0], depth + 1);
    } else {
      item.addClass(itemStyleClass);
    }

    if (this.m_widget._isSelectionEnabled() && this.isSelectable(context)) {
      this.m_widget.getFocusItem(item).attr('aria-selected', false);
    }

    this.m_widget.itemRenderComplete(item[0], context);
  }
};
/**
 * @private
 */


oj.StaticContentHandler.prototype.setRootAriaProperties = function () {
  if (this.shouldUseGridRole()) {
    this.m_root.setAttribute('role', 'grid');
  } else if (this.IsHierarchical()) {
    this.m_root.setAttribute('role', 'tree');
  } else {
    this.m_root.setAttribute('role', 'listbox');
  }
};
/**
 * @private
 */


oj.StaticContentHandler.prototype.unsetRootAriaProperties = function () {
  this.m_root.removeAttribute('role');
};
/**
 * @private
 */


oj.StaticContentHandler.prototype.getItemsCount = function (item) {
  return $(item).children('li').length;
};
/**
 * Creates the object with context information for the specified item
 * @param {jQuery} item the item to create context info object for
 * @return {Object} the context object
 * @private
 */


oj.StaticContentHandler.prototype.createContext = function (item) {
  var context = {};
  context.key = item.attr('id');
  context.parentElement = item.children().first()[0];
  context.index = item.index();
  context.data = item[0];
  context.component = this.m_widget.getWidgetConstructor();
  context = this.m_widget._FixRendererContext(context); // additional context info for hierarhical data

  if (this.IsHierarchical()) {
    context.leaf = item.children('ul').length === 0;
    var parents = item.parents('li.' + this.m_widget.getItemElementStyleClass());
    context.depth = parents.length;

    if (parents.length === 0) {
      context.parentKey = null;
    } else {
      context.parentKey = parents.first().attr('id');
    }
  }

  return context;
};
/**
 * @private
 */


oj.StaticContentHandler.prototype.setAriaProperties = function (item, context) {
  // if there's only one element inside the item and it is focusable, set
  // the role on it instead
  var elem = this.m_widget.getSingleFocusableElement(item);

  if (this.shouldUseGridRole()) {
    if (context.leaf != null && !context.leaf) {
      // it's a group item
      item.attr('role', 'presentation');

      if (elem !== item) {
        elem.attr('role', 'gridcell');
      }
    } else if (this.isCardLayout()) {
      elem.attr('role', 'gridcell');
    } else {
      item.attr('role', 'row');

      if (elem !== item) {
        elem.attr('role', 'gridcell');
      } else {
        // we'll need to wrap content with a gridcell role
        elem.children().wrapAll("<div role='gridcell' class='oj-listview-cell-element'></div>"); // @HTMLUpdateOK
      }
    }
  } else {
    elem.attr('role', this.IsHierarchical() ? 'treeitem' : 'option');

    if (elem !== item) {
      item.attr('role', 'presentation');
    }
  }

  elem.addClass(this.m_widget.getFocusedElementStyleClass());
};
/**
 * @private
 */


oj.StaticContentHandler.prototype.setGroupAriaProperties = function (group, count) {
  var focusedElementStyleClass = this.m_widget.getFocusedElementStyleClass(); // aria-expanded should be in the cell

  group.get(0).removeAttribute('aria-expanded');
  group.removeClass(focusedElementStyleClass);
  group.attr('role', 'row');
  group.children().wrapAll("<div role='gridcell' aria-expanded='false' class='oj-listview-cell-element " + // @HTMLUpdateOK
  focusedElementStyleClass + "'></div>");

  if (this.isCardLayout() && count > 1) {
    group.children().first().attr('aria-colspan', count);
  }
};
/**
 * @private
 */


oj.StaticContentHandler.prototype.unsetGroupAriaProperties = function (item) {
  item.children('div').first().children().unwrap();
};
/**
 * @private
 */


oj.StaticContentHandler.prototype.unsetAriaProperties = function (item) {
  DataCollectionUtils.enableAllFocusableElements(item);
  var groupItemStyleClass = this.m_widget.getGroupItemStyleClass(true);
  var focusedElementStyleClass = this.m_widget.getFocusedElementStyleClass();
  var firstElementChild = item.firstElementChild;
  var elem;

  if (firstElementChild && $(firstElementChild).hasClass(groupItemStyleClass)) {
    elem = $(firstElementChild).children('.' + focusedElementStyleClass).first();

    if (elem.length === 0) {
      // should not happen
      return;
    }
  } else {
    elem = this.m_widget.getSingleFocusableElement($(item));
  }

  elem.removeAttr('role');
  elem.removeAttr('aria-selected');
  elem.removeAttr('aria-expanded');
  elem.removeClass(this.m_widget.getFocusedElementStyleClass()); // need to unwrap since in non-card layout we wrap the content with a div for gridcell role

  if (this.shouldUseGridRole() && !this.isCardLayout()) {
    if (elem !== item) {
      $(item).removeAttr('role');
      elem.children().first().children().unwrap();
    } else {
      elem.children().first().children().unwrap().children().unwrap();
    }
  }
};

oj.StaticContentHandler.prototype.GetKey = function (element) {
  return $(element).attr('id');
};

oj.StaticContentHandler.prototype.FindElementByKey = function (key) {
  return document.getElementById(key);
};

oj.StaticContentHandler.prototype.isFocusable = function (context) {
  return this.m_widget.getItemFocusable(context);
};

oj.StaticContentHandler.prototype.isSelectable = function (context) {
  return this.m_widget.getItemSelectable(context);
};

oj.StaticContentHandler.prototype.isCardLayout = function () {
  return this.m_widget.isCardLayout();
};

oj.StaticContentHandler.prototype.shouldUseGridRole = function () {
  return this.m_widget.ShouldUseGridRole();
};

oj.StaticContentHandler.prototype.createKeyMap = function (initialMap) {
  var map = new KeyMap();

  if (initialMap) {
    initialMap.forEach(function (value, key) {
      map.set(key, value);
    });
    return map;
  }

  return map;
};

oj.StaticContentHandler.prototype.createKeySet = function (initialSet) {
  return new KeySet(initialSet);
};



/* global List:false, Context:false, ThemeUtils:false, Promise:false, KeySetImpl:false, Set:false, Components:false, DataCollectionUtils:false, Logger:false, KeySet:false, KeyMap:false, localRequire:false, Config:false */

/**
 * Partial Map impl, replace with ES6 Map when possible.
 * @constructor
 * @ignore
 */
oj.KeyMap = function () {};

oj.KeyMap.prototype.set = function (key, value) {
  if (this._mapKeys === undefined && this._mapValues === undefined) {
    this._mapKeys = [];
    this._mapValues = [];
  }

  var index = this._mapKeys.indexOf(key);

  if (index > -1) {
    this._mapValues.splice(index, 1, value);
  } else {
    this._mapKeys.push(key);

    this._mapValues.push(value);
  }
};

oj.KeyMap.prototype.get = function (key) {
  if (this._mapKeys && this._mapValues) {
    var index = this._mapKeys.indexOf(key);

    if (index > -1 && this._mapValues.length > index) {
      return this._mapValues[index];
    }
  }

  return null;
};

oj.KeyMap.prototype.deleteValue = function (value) {
  var current = this._mapValues.indexOf(value);

  while (current > -1) {
    this._mapValues.splice(current, 1);

    this._mapKeys.splice(current, 1);

    current = this._mapValues.indexOf(value, current);
  }
}; // mixin to inject createKeyMap and createKeySet functions to ContentHandlers


var ContentHandlerMixin = function ContentHandlerMixin() {
  this.createKeyMap = function (initialMap) {
    var map = new KeyMap();

    if (initialMap) {
      initialMap.forEach(function (value, key) {
        map.set(key, value);
      });
      return map;
    }

    return map;
  };

  this.createKeySet = function (initialSet) {
    return new KeySet(initialSet);
  };
};

ContentHandlerMixin.call(oj.StaticContentHandler.prototype);
ContentHandlerMixin.call(oj.TreeDataProviderContentHandler.prototype);
ContentHandlerMixin.call(List.IteratingDataProviderContentHandler.prototype);
/**
 * Default ExpandedKeySet class
 * Need a way to distinguish ExpandedKeySet set by application vs default one created by ListView
 * @extends {ExpandedKeySet}
 * @constructor
 * @ignore
 */

oj._ojListViewExpandedKeySet = function () {
  oj._ojListViewExpandedKeySet.superclass.constructor.call(this);
}; // Subclass from KeySet


oj.Object.createSubclass(oj._ojListViewExpandedKeySet, oj.ExpandedKeySet, 'ListViewExpandedKeySet');
/**
 * todo: create common utility class between combobox and listview
 * @private
 */

var _ListViewUtils = {
  clazz: function clazz(SuperClass, methods) {
    var constructor = function constructor() {};

    oj.Object.createSubclass(constructor, SuperClass, '');
    constructor.prototype = $.extend(constructor.prototype, methods);
    return constructor;
  }
};
/**
 * @export
 * @class oj._ojListView
 * @classdesc Listview
 * @constructor
 * @ignore
 * @private
 */

oj._ojListView = _ListViewUtils.clazz(Object,
/** @lends oj._ojListView.prototype */
{
  // constants for key codes, todo: move to ListViewUtils
  LEFT_KEY: 37,
  RIGHT_KEY: 39,
  DOWN_KEY: 40,
  UP_KEY: 38,
  TAB_KEY: 9,
  ENTER_KEY: 13,
  ESC_KEY: 27,
  F2_KEY: 113,
  SPACE_KEY: 32,
  // constants for disclosure state

  /** @protected **/
  STATE_EXPANDED: 0,

  /** @protected **/
  STATE_COLLAPSED: 1,

  /** @protected **/
  STATE_NONE: 2,
  // minimum height of an item
  MINIMUM_ITEM_HEIGHT: 20,

  /**
   * Initialize the listview at creation
   * Invoked by widget
   */
  init: function init(opts) {
    var self = this;
    this.readinessStack = [];
    this.element = opts.element;
    this.ojContext = opts.ojContext;
    this.OuterWrapper = opts.OuterWrapper;
    this.options = opts;
    this.element.uniqueId().addClass(this.GetStyleClass() + ' oj-component-initnode');

    if (this.OuterWrapper) {
      this.element[0].setAttribute('data-oj-context', '');
    }

    this.signalTaskStart('Initializing'); // Move component out of ready state; component is initializing. End in afterCreate()

    this._rootTabIndexSet = false;
    this.SetRootElementTabIndex();
    var dndContext = this.GetDnDContext(); // listens for dnd events if ListViewDndContext is defined

    if (dndContext) {
      this.m_dndContext = dndContext;

      this.ojContext._on(this.element, {
        dragstart: function dragstart(event) {
          return dndContext._handleDragStart(event);
        },
        dragenter: function dragenter(event) {
          return dndContext._handleDragEnter(event);
        },
        dragover: function dragover(event) {
          return dndContext._handleDragOver(event);
        },
        dragleave: function dragleave(event) {
          return dndContext._handleDragLeave(event);
        },
        dragend: function dragend(event) {
          // mouseup will not be invoked on drag so resetting it to false.
          self.m_preActive = false;
          return dndContext._handleDragEnd(event);
        },
        drag: function drag(event) {
          return dndContext._handleDrag(event);
        },
        drop: function drop(event) {
          // mouseup will not be invoked on drag so resetting it to false.
          self.m_preActive = false;
          return dndContext._handleDrop(event);
        }
      });
    }

    this._touchStartListener = function (event) {
      // convert to jQuery event for downstream code expecting it
      if (!event.originalEvent) {
        // eslint-disable-next-line no-param-reassign
        event = $.Event(event);
      }

      self.touchStartEvent = event;
      self.HandleMouseDownOrTouchStart(event);
    };

    if (this.ojContext._IsCustomElement()) {
      this.element[0].addEventListener('touchstart', this._touchStartListener, {
        passive: true
      });
    } else {
      this.ojContext._on(this.element, {
        touchstart: this._touchStartListener
      });
    }

    this.ojContext._on(this.element, {
      click: function click(event) {
        self.HandleMouseClick(event);
        self.touchStartEvent = null;
      },
      touchend: function touchend(event) {
        if (self.touchStartEvent && event.changedTouches.length) {
          var overElem = document.elementFromPoint(event.changedTouches[0].clientX, event.changedTouches[0].clientY);

          if (overElem !== self.touchStartEvent.target) {
            self.touchStartEvent = null;
          }
        }

        self.HandleTouchEndOrCancel(event);
      },
      touchcancel: function touchcancel(event) {
        self.touchStartEvent = null;
        self.HandleTouchEndOrCancel(event);
      },
      mousedown: function mousedown(event) {
        if (event.button === 0) {
          if (!self._recentTouch()) {
            self.HandleMouseDownOrTouchStart(event);
          }
        } else {
          // on right click we should prevent focus from shifting to first item
          self.m_preActive = true;
        }
      },
      mouseup: function mouseup(event) {
        self._handleMouseUpOrPanMove(event);

        self.m_preActive = false;
      },
      mouseout: function mouseout(event) {
        self._handleMouseOut(event);
      },
      mouseover: function mouseover(event) {
        self._handleMouseOver(event);
      },
      keydown: function keydown(event) {
        self.HandleKeyDown(event);
      },
      keyup: function keyup(event) {
        self.HandleKeyUp(event);
      },
      ojpanmove: function ojpanmove(event) {
        self._handleMouseUpOrPanMove(event);
      }
    });

    this.ojContext._on(this.ojContext.element, {
      focus: function focus(event) {
        self.HandleFocus(event);
      },
      blur: function blur(event) {
        self.HandleBlur(event);
      }
    }); // in Firefox, need to explicitly make list container not focusable otherwise first tab will focus on the list container


    if (oj.AgentUtils.getAgentInfo().browser === oj.AgentUtils.BROWSER.FIREFOX && this._isComponentFocusable()) {
      this._rootTabIndexSet = true;
      this.getListContainer().attr('tabIndex', -1);
    } // for item focus mode (aka roving focus), we'll need to use focusout handler instead
    // of blur because blur doesn't bubble


    this.ojContext._on(this.ojContext.element, {
      focusin: function focusin(event) {
        self.HandleFocus(event);
      },
      focusout: function focusout(event) {
        self.HandleFocusOut(event);
      }
    });

    this.ojContext._focusable({
      applyHighlight: self.ShouldApplyHighlight(),
      recentPointer: self.RecentPointerCallback(),
      setupHandlers: function setupHandlers(focusInHandler, focusOutHandler) {
        self._focusInHandler = focusInHandler;
        self._focusOutHandler = focusOutHandler;
      }
    });
  },

  /**
   * Whether ListView is available or offline/detached
   * Invoked by widget
   */
  isAvailable: function isAvailable() {
    return this.m_contentHandler != null;
  },

  /**
   * Initialize ContentHandler and any post processes
   * @private
   */
  _initContentHandler: function _initContentHandler() {
    this.signalTaskStart('Initialize ContentHandler'); // signal method task start

    var self = this;

    var postProcess = function postProcess(contentHandler) {
      self.m_contentHandler = contentHandler; // kick start rendering

      contentHandler.RenderContent();
      self.signalTaskEnd(); // signal method task end
      // register a resize listener

      self._registerResizeListener(self.getListContainer()[0]); // register a scroll/scrollwheel listener


      self._registerScrollHandler();
    };

    var data = this.GetOption('data');

    if (data != null) {
      this.CreateDataContentHandler(data).then(postProcess, function () {
        self.signalTaskEnd(); // signal method task end
      });
    } else {
      // remove existing no data content now before StaticContentHandler modifies content
      this._removeNoData(); // StaticContentHandler will handle cases where children are invalid or empty


      postProcess(new oj.StaticContentHandler(this, this.element[0]));
    }
  },

  /**
   * Setup resources on listview after connect
   * Invoked by widget
   */
  setupResources: function setupResources() {
    this.ojContext.document.bind('touchend.ojlistview touchcancel.ojlistview', this.HandleTouchEndOrCancel.bind(this)); // sync selection with KeySet, including the case where selection option
    // was updated after detach

    this._syncSelectionWithKeySet();

    this._initContentHandler();

    this._updateGridlines();
  },

  /**
   * Release resources held by listview after disconnect
   * Invoked by widget
   */
  releaseResources: function releaseResources() {
    this.ojContext.document.off('.ojlistview');
    this.DestroyContentHandler(true);

    this._unregisterResizeListener(this.getListContainer());

    this._unregisterScrollHandler();

    this._resetState();
  },

  /**
   * Whether the selected option is exposed at the component
   * @private
   */
  _isSelectedOptionExposed: function _isSelectedOptionExposed() {
    // currently this is override by NavList, always true for ListView
    return this.ShouldUseGridRole();
  },

  /**
   * Sync up legacy selection with KeySet during initialization
   * @private
   */
  _syncSelectionWithKeySet: function _syncSelectionWithKeySet() {
    var selection = this.GetOption('selection');
    var selected = this.GetOption('selected'); // first check if selected is specified and sync that up with selection
    // if selected option is not exposed then we don't need to sync selected with selection

    if (this._isSelectedOptionExposed() && selected && (selected.isAddAll() || selected.values && selected.values().size > 0)) {
      selection = [];

      if (selected.isAddAll()) {
        selection.inverted = true;
        selected.deletedValues().forEach(function (key) {
          selection.push(key);
        });
      } else {
        selected.values().forEach(function (key) {
          selection.push(key);
        });
      }

      this.SetOption('selection', selection, {
        _context: {
          internalSet: true
        },
        changed: true
      });
      return;
    } // now sync selected with selection


    var needsUpdate = false; // NavList do not have this property, need to initialize it

    if (selected == null) {
      selected = new oj.KeySetImpl();
      needsUpdate = true;
    } // detect if it's out of sync


    if (selection.length > 0 && selected.values && selected.values().size === 0) {
      selected = selected.add(selection);
      needsUpdate = true;
    }

    if (needsUpdate) {
      this.SetOption('selected', selected, {
        _context: {
          internalSet: true
        },
        changed: true
      });
    }
  },

  /**
   * Initialize the listview after creation
   * Invoked by widget
   */
  afterCreate: function afterCreate() {
    this._buildList();

    this.signalTaskEnd(); // resolve component initializing task. Started in init()
  },

  /**
   * @private
   */
  _isAnimateCards: function _isAnimateCards() {
    return this.isCardDisplayMode() && this.m_contentHandler && !this.m_contentHandler.IsHierarchical();
  },

  /**
   * Redraw the entire list view after having made some external modifications.
   * Invoked by widget
   */
  refresh: function refresh() {
    var cards = this.element[0].querySelectorAll('.oj-listview-card');

    if (cards.length > 0) {
      var self = this;
      this.signalTaskStart('Exit animation');

      this._applyExitAnimation(cards).then(function () {
        self._refresh();

        self.signalTaskEnd();
      });
    } else {
      this._refresh();
    }
  },

  /**
   * @private
   */
  _applyExitAnimation: function _applyExitAnimation(cards) {
    var root = this.element[0];
    return new Promise(function (resolve) {
      var listener = function listener() {
        root.removeEventListener('animationend', listener);
        resolve(true);
      };

      root.addEventListener('animationend', listener); // apply animation class

      cards.forEach(function (card) {
        // eslint-disable-next-line no-param-reassign
        card.style.animationDelay = '0ms';
        card.classList.remove('oj-actioncard-initial-entrance-animation');
        card.classList.remove('oj-actioncard-loadmore-entrance-animation');
        card.classList.add('oj-actioncard-initial-exit-animation');
      });
    });
  },

  /**
   * @private
   */
  _refresh: function _refresh() {
    // reset content, wai aria properties, and ready state
    this._resetInternal();

    this.signalTaskStart('Refresh'); // signal method task start
    // set the wai aria properties

    this.SetAriaProperties(); // recreate the content handler

    this._initContentHandler(); // update top/bottom gridlines


    this._updateGridlines(); // if active element is inside an item, we'll need to shift focus to
    // the root otherwise focus is lost when all items are removed


    this.resetFocusBeforeRefresh();
    this.signalTaskEnd(); // signal method task end
  },

  /**
   * Invoked before refresh, including DataProviderRefresh event
   */
  resetFocusBeforeRefresh: function resetFocusBeforeRefresh() {
    if (this.element[0].contains(document.activeElement)) {
      this.m_active = null;
      this.SetRootElementTabIndex();
      this.element[0].focus();
    }
  },

  /**
   * Returns a Promise that resolves when the component is ready, i.e. after data fetching, rendering, and animations complete.
   * Invoked by widget
   * @return {Promise} A Promise that resolves when the component is ready.
   */
  whenReady: function whenReady() {
    return this.readyPromise;
  },

  /**
   * Destroy the list view
   * Invoked by widget
   */
  destroy: function destroy() {
    this.element.removeClass(this.GetStyleClass() + ' oj-component-initnode');

    this._unregisterResizeListener(this.getListContainer());

    this._resetInternal(); //  - DomUtils.unwrap() will avoid unwrapping if the node is being destroyed by Knockout


    oj.DomUtils.unwrap(this.element, this.getListContainer());
  },

  /**
   * Adjust the value of scrollPosition based on the value from scrollPositionPolicy
   */
  adjustScrollPositionValueOnRefresh: function adjustScrollPositionValueOnRefresh() {
    var scrollPosition = this.GetOption('scrollPosition') == null ? {} : this.GetOption('scrollPosition');
    var selection = this.GetOption('selection');

    if (this._isSelectionEnabled() && selection.length > 0) {
      // use selection anchor if available
      if (this.m_selectionFrontier != null && this.m_selectionFrontier.length > 0) {
        scrollPosition.key = this.GetKey(this.m_selectionFrontier[0]);
      } else {
        // selection is programmatically set
        scrollPosition.key = selection[0];
      }
    } else {
      // remain at the top
      scrollPosition.y = 0;
      scrollPosition.key = null;
      scrollPosition.index = 0;
    }

    scrollPosition.x = 0;
    scrollPosition.offsetX = 0;
    scrollPosition.offsetY = 0; // explicitly set changed to false so option change will not be triggered, syncScrollPosition after rendered will
    // complete the scrollPosition value and fire the option change event

    this.SetOption('scrollPosition', scrollPosition, {
      _context: {
        internalSet: true
      },
      changed: false
    });
  },

  /**
   * Force busy state to be resolve and flush the readiness stack
   * @private
   */
  _clearBusyState: function _clearBusyState() {
    if (this.readinessStack && this.readinessStack.length > 0) {
      Logger.warn('ListView did not end with a clean state, this could happen if ListView is detached before fetch is complete.  State: ' + this.readinessStack); // this should resolve all the Promises, safe to assume the Promises should already been resolve if readinessStack is empty

      while (this.readinessStack.length > 0) {
        this.signalTaskEnd();
      }
    }
  },

  /**
   * Remove any wai-aria properties and listview specific attributes.
   * Reset anything done by the content handler.
   * @private
   */
  _resetInternal: function _resetInternal() {
    this.UnsetAriaProperties();

    this._cleanupTabbableElementProperties(this.element);

    this.DestroyContentHandler();

    this._resetState();
  },

  /**
   * Reset internal state and cache
   * @private
   */
  _resetState: function _resetState() {
    this.m_active = null;
    this.m_isExpandAll = null;
    this.m_disclosing = null;
    this.m_itemHeight = null;
    this.m_keyElemMap = null;
    this.m_clientHeight = null;
    this.m_scrollHeight = null;
    this.m_clientWidth = null;
    this.m_scrollWidth = null;
    this.m_closestParent = null;
    this.m_noDataContent = null;
    this.m_gridlinesVisible = null;
    this.m_gridlinePlaceholder = null;
    this.ClearCache();

    this._clearFocusoutTimeout();

    this._clearFocusoutBusyState(); // give dnd context a chance to clear internals


    if (this.m_dndContext != null) {
      this.m_dndContext.reset();
    }
  },

  /**
   * Called when listview root element is re-attached to DOM tree.
   * Invoke by widget
   */
  notifyAttached: function notifyAttached() {
    // make sure component is not destroyed
    if (this.m_contentHandler != null) {
      // restore scroll position as needed since some browsers reset scroll position
      this.syncScrollPosition(); // call ContentHandler in case for example fetch is needed

      this.m_contentHandler.notifyAttached();
    }
  },

  /**
   * In browsers [Chrome v35, Firefox v24.5, IE9, Safari v6.1.4], blur and mouseleave events are generated for hidden content but not detached content,
   * so for detached content only, we must use this hook to remove the focus and hover classes.
   * Invoke by widget.
   */
  notifyDetached: function notifyDetached() {
    // Remove focus/hover/active style classes when listview element got detached from document.
    // For details see related button .
    this.getListContainer().removeClass('oj-focus-ancestor');

    if (this.m_active != null) {
      $(this.m_active.elem).removeClass('oj-focus oj-focus-highlight');
    }

    if (this.m_hoverItem != null) {
      this._unhighlightElem(this.m_hoverItem, 'oj-hover');
    }
  },

  /**
   * Called when application programmatically change the css style so that the ListView becomes visible
   */
  notifyShown: function notifyShown() {
    // make sure component is not destroyed
    if (this.m_contentHandler != null) {
      // restore scroll position as needed since some browsers reset scroll position
      this.syncScrollPosition(); // call ContentHandler in case for example fetch is needed

      this.m_contentHandler.notifyShown();
    }
  },

  /**
   * Return the subcomponent node represented by the documented locator attribute values.
   * Invoked by widget
   * @param {Object} locator An Object containing at minimum a subId property
   *        whose value is a string, documented by the component, that allows
   *         the component to look up the subcomponent associated with that
   *        string.  It contains:<p>
   *        component: optional - in the future there may be more than one
   *        component contained within a page element<p>
   *        subId: the string, documented by the component, that the component
   *        expects in getNodeBySubId to locate a particular subcomponent
   * @returns {Array.<(Element|null)>|Element|null} the subcomponent located by the subId string passed
   *          in locator, if found.<p>
   */
  getNodeBySubId: function getNodeBySubId(locator) {
    var key;

    if (locator == null) {
      return this.element[0];
    }

    var subId = locator.subId;

    if (subId === 'oj-listview-disclosure' || subId === 'oj-listview-icon') {
      key = locator.key;

      if (key != null) {
        var item = this.FindElementByKey(key);

        if (item != null) {
          // this should be the anchor
          var anchor = $(item).find('.oj-clickable-icon-nocontext').first();

          if (this._isExpandCollapseIcon(anchor)) {
            return anchor.get(0);
          }
        }
      }
    } else if (subId === 'oj-listview-item') {
      key = locator.key;

      if (key != null) {
        return this.FindElementByKey(key);
      }
    } // Non-null locators have to be handled by the component subclasses


    return null;
  },

  /**
   * Returns the subId locator for the given child DOM node.
   * Invoked by widget
   * @param {!Element} node - child DOM node
   * @return {Object|null} The subId for the DOM node, or null when none is found.
   */
  getSubIdByNode: function getSubIdByNode(node) {
    // check to see if it's expand/collapse icon
    if (node != null && this._isExpandCollapseIcon(node)) {
      var item = this.FindItem(node);

      if (item != null && item.length > 0) {
        var key = this.GetKey(item[0]);

        if (key != null) {
          return {
            subId: 'oj-listview-disclosure',
            key: key
          };
        }
      }
    }

    return null;
  },

  /**
   * Returns an object with context for the given child DOM node.
   * This will always contain the subid for the node, defined as the 'subId' property on the context object.
   * Additional component specific information may also be included. For more details on returned objects, see context objects.
   * Invoked by widget
   *
   * @param {!Element} node the child DOM node
   * @returns {Object|null} the context for the DOM node, or null when none is found.
   */
  getContextByNode: function getContextByNode(node) {
    var item = this.FindItem(node);

    if (item != null && item.length > 0) {
      var key = this.GetKey(item[0]);

      if (key != null) {
        var parent = item.parent();
        var index = parent.children('.' + this.getItemElementStyleClass()).index(item);
        var context = {
          subId: 'oj-listview-item',
          key: key,
          index: index
        }; // group item should return the li

        if (parent.get(0) !== this.element.get(0)) {
          context.parent = parent.parent().get(0);
        } // check if it's a group item


        if (item.children().first().hasClass(this.getGroupItemStyleClass())) {
          context.group = true;
        } else {
          context.group = false;
        }

        return context;
      }
    }

    return null;
  },

  /**
   * Return the raw data for an item in ListView.
   * Invoked by widget
   *
   * @param {Object} context the context of the item to retrieve raw data.
   * @param {any=} context.key The key of the item.  If both index and key are specified, then key takes precedence.
   * @param {number=} context.index the index of the item relative to its parent.
   * @param {Element=} context.parent the parent node, not required if parent is the root.
   * @returns {any} data for the item.  Returns null if the item is not available locally.  Returns the item element if static HTML is used as data.
   */
  getDataForVisibleItem: function getDataForVisibleItem(context) {
    var item;
    var key = context.key; // key takes precedence

    if (key != null) {
      item = this.FindElementByKey(key);
    } // if we can't find the item with key, try to use index, if specified


    if (item == null) {
      var index = context.index;
      var parent = context.parent;

      if (parent == null) {
        // use the root element
        parent = this.element.get(0);
      } else {
        // find the appropriate group element
        parent = $(parent).children('ul.' + this.getGroupStyleClass()).first();
      }

      item = $(parent).children('li').get(index);
    }

    if (item != null && $(item).hasClass(this.getItemStyleClass())) {
      return this._getDataForItem(item);
    }

    return null;
  },

  /**
   * Retrieve data stored in dom
   * @param {Element} item
   * @return {any} data for item
   * @private
   */
  _getDataForItem: function _getDataForItem(item) {
    // if static HTML, returns the item's dom element
    if (this.GetOption('data') == null) {
      return item;
    }

    return $.data(item, 'data');
  },

  /**
   * Retrieve metadata stored in dom
   * @param {Element} item
   * @return {any} data for item
   * @private
   */
  _getMetadataForItem: function _getMetadataForItem(item) {
    return $.data(item, 'metadata');
  },

  /**
   * To be override by NavList
   * @protected
   */
  ShouldRegisterResizeListener: function ShouldRegisterResizeListener(element) {
    return element && this.m_contentHandler && this.m_contentHandler.HandleResize && this.m_contentHandler.shouldHandleResize && this.m_contentHandler.shouldHandleResize();
  },

  /**
   * Unregister event listeners for resize the container DOM element.
   * @param {Element} element  DOM element
   * @private
   */
  _unregisterResizeListener: function _unregisterResizeListener(element) {
    if (element && this._resizeHandler) {
      // remove existing listener
      oj.DomUtils.removeResizeListener(element, this._resizeHandler);
    }
  },

  /**
   * Register event listeners for resize the container DOM element.
   * @param {Element} element  DOM element
   * @private
   */
  _registerResizeListener: function _registerResizeListener(element) {
    this._unregisterResizeListener(element); // register resize listener if needed


    if (this.ShouldRegisterResizeListener(element)) {
      if (this._resizeHandler == null) {
        this._resizeHandler = this.HandleResize.bind(this);
      }

      oj.DomUtils.addResizeListener(element, this._resizeHandler);
    }
  },

  /**
   * Returns DnD Context, needed to override in navigationlist
   * @protected
   */
  GetDnDContext: function GetDnDContext() {
    // if dnd is not enabled, we should not do anything also even if ojlistviewdnd is required
    var dndOptions = this.GetOption('dnd');

    if (dndOptions === null || dndOptions.drag === null && dndOptions.drop === null && dndOptions.reorder && dndOptions.reorder.items === 'disabled') {
      return undefined;
    }

    if (typeof oj.ListViewDndContext !== 'undefined') {
      return new oj.ListViewDndContext(this);
    }

    return undefined;
  },

  /**
   * The resize handler.
   * @param {number} width the new width
   * @param {number} height the new height
   * @private
   */
  HandleResize: function HandleResize(width, height) {
    if (width > 0 && height > 0 && this.m_contentHandler != null && this.m_contentHandler.HandleResize) {
      this.m_contentHandler.HandleResize(width, height);
    }

    this.m_clientHeight = null;
    this.m_scrollHeight = null;
    this.m_clientWidth = null;
    this.m_scrollWidth = null;
  },

  /**
   * Whether focus highlight should be applied
   * @return {boolean} true if should apply focus highlight, false otherwise
   * @protected
   */
  ShouldApplyHighlight: function ShouldApplyHighlight() {
    return true;
  },

  /**
   * check Whether recent pointer acivity happened or not.
   * Only used for sliding navlist to avoid focus ring on new focusable item
   * after completing expand/collapse animation.
   * @protected
   */
  RecentPointerCallback: function RecentPointerCallback() {
    return function () {
      return false;
    };
  },

  /**
   * Whether ListView should refresh if certain option is updated
   * @param {Object} options the options to check
   * @return {boolean} true if should refresh, false otherwise
   * @protected
   */
  ShouldRefresh: function ShouldRefresh(options) {
    return options.data != null || options.drillMode != null || options.groupHeaderPosition != null || options.item != null || options.scrollPolicy != null || options.scrollPolicyOptions != null || options.gridlines != null || options.display != null;
  },

  /**
   * Returns true if value is a KeySet, false otherwise
   * @private
   */
  _isKeySet: function _isKeySet(value) {
    return value.isAddAll !== undefined && (value.values !== undefined || value.deletedValues !== undefined);
  },

  /**
   * Returns true if key is expandable, false otherwise
   * @private
   */
  _shouldExpand: function _shouldExpand(key, expanded) {
    if (this._isKeySet(expanded)) {
      return expanded.has(key);
    } else if (!this.ojContext._IsCustomElement() && expanded === 'all') {
      return true;
    } else if (Array.isArray(expanded)) {
      return expanded.indexOf(key) > -1;
    }

    return false;
  },

  /**
   * Sets multiple options
   * Invoke by widget
   * @param {Object} options the options object
   * @param {Object} flags additional flags for option
   * @return {boolean} true to refresh, false otherwise
   */
  // eslint-disable-next-line no-unused-vars
  setOptions: function setOptions(options, flags) {
    if (this.ShouldRefresh(options)) {
      // data updated, need to refresh
      return true;
    }

    if (options.expanded != null) {
      // should only apply if data is hierarchical
      // q: could expanded be change if drillMode is 'expanded'?
      if (this.m_contentHandler.IsHierarchical()) {
        // clear collapsed items var
        this._collapsedKeys = undefined;
        var expanded = options.expanded;
        this.signalTaskStart('Set expanded option'); // signal task start
        // itemRenderComplete would check expanded option to expand nodes as needed
        // however, since options has not been updated yet this will cause previous
        // expanded nodes to expand
        // an option would be to clear the expanded option to null when doing collapseAll
        // but the issue is that optionChange would be fired AND even if we can suppress
        // the optionChange event, when the actual optionChange event is fired, the
        // previousValue param would be wrong (it would be null)
        // so instead we'll use to flag so that itemRenderComplete would detect and ignore
        // the expanded option

        this._ignoreExpanded = true;

        try {
          var selector = '.' + this.getGroupItemStyleClass();
          var groupItems = this.element.find(selector);

          for (var i = 0; i < groupItems.length; i++) {
            var groupItem = groupItems[i];
            var key = this.GetKey(groupItem.parentNode);

            var expand = this._shouldExpand(key, expanded);

            if (expand) {
              this.expandKey(key, true, true, true, false);
            } else {
              this.collapseKey(key, true, true, false);
            }
          }
        } finally {
          this._ignoreExpanded = undefined;
          this.signalTaskEnd(); // signal task end
        }
      }
    }

    if (options.currentItem != null) {
      var elem = this.FindElementByKey(options.currentItem);

      if (elem != null) {
        elem = $(elem);

        if (!this.SkipFocus(elem)) {
          var active = document.activeElement; // update tab index and focus only if listview currently has focus

          if (active && this.element.get(0).contains(active)) {
            this.ActiveAndFocus(elem, null);
          } else {
            // update internal state only
            this._setActive(elem, null, true);
          }
        }
      }
    } else if (options.currentItem === null) {
      // currentItem is deliberately set to null if this case is entered; deliberately clear active element and its focus
      this.UnhighlightActive();
      this.m_active = null;
      this.SetRootElementTabIndex();
    }

    this.HandleSelectionOption(options);

    if (options.selectionMode != null) {
      // reset wai aria properties
      this.SetAriaProperties(); // update aria-selected on item

      this.UpdateItemAriaProperties(options.selectionMode);
    }

    if (options.scrollTop != null) {
      var scroller = this._getScroller();

      var pos = options.scrollTop;

      if (pos != null && !isNaN(pos)) {
        scroller.scrollTop = pos;
      }
    }

    if (options.scrollPosition != null) {
      this.syncScrollPosition(options.scrollPosition); // remove it so it doesn't trigger an option change
      // eslint-disable-next-line no-param-reassign

      delete options.scrollPosition;
    } // if reorder switch to enabled/disabled, we'll need to make sure any reorder styling classes are added/removed from focused item


    if (this._shouldDragSelectedItems() && this.m_active != null && options.dnd != null && options.dnd.reorder != null) {
      if (options.dnd.reorder.items === 'enabled') {
        this.m_dndContext._setItemDraggable(this.m_active.elem);
      } else if (options.dnd.reorder.items === 'disabled') {
        this.m_dndContext._unsetItemDraggable(this.m_active.elem);
      }
    }

    return false;
  },

  /**
   * @private
   */
  isFirstSelectedItem: function isFirstSelectedItem(key) {
    var firstSelectedData = this.GetOption('firstSelectedItem');
    return firstSelectedData && oj.KeyUtils.equals(firstSelectedData.key, key);
  },

  /**
   * @private
   */
  setFirstSelectedItem: function setFirstSelectedItem(key, data) {
    var value = {
      key: key,
      data: data
    };
    this.SetOption('firstSelectedItem', value, {
      _context: {
        originalEvent: null,
        internalSet: true
      },
      changed: true
    });
  },

  /**
   * @private
   */
  _updateFirstSelectedItem: function _updateFirstSelectedItem(selected) {
    var key;

    if (selected.isAddAll()) {
      var items = this._getItemsCache();

      for (var j = 0; j < items.length; j++) {
        var currentKey = this.m_contentHandler.GetKey(items[j]);

        if (selected.has(currentKey)) {
          key = currentKey;
          break;
        }
      }
    } else {
      key = selected.values().values().next().value;
    }

    if (key != null) {
      var data = this.getDataForVisibleItem({
        key: key
      });
      this.setFirstSelectedItem(key, data);
    }
  },

  /**
   * Set Selection option. Overriden by Navlist.
   * @param {Object} options the options object
   * @protected
   */
  HandleSelectionOption: function HandleSelectionOption(options) {
    if (options.selection != null || options.selected != null) {
      var selected = options.selected;

      if (selected != null && selected.isAddAll()) {
        var items = this._getItemsCache();

        for (var j = 0; j < items.length; j++) {
          this._applySelection(items[j], this.m_contentHandler.GetKey(items[j]));
        } // eslint-disable-next-line no-param-reassign


        options.selection = KeySet.KeySetUtils.toArray(selected);
      } else {
        var set = selected != null ? selected.values() : options.selection; // we used to filter non-selectable items, but not anymore, but we are still
        // cloning by converting iterable into array

        var newSelection = this._cloneSelection(set); // eslint-disable-next-line no-param-reassign


        options.selection = newSelection; // eslint-disable-next-line no-param-reassign

        selected = this.GetOption('selected');
        selected = selected.clear();
        selected = selected.add(newSelection); // eslint-disable-next-line no-param-reassign

        options.selected = selected; // keep selection frontier if it's part of selection

        var selectionFrontier;

        if (this.m_selectionFrontier) {
          var frontierKey = this.GetKey(this.m_selectionFrontier.get(0));
          selectionFrontier = selected.has(frontierKey) ? this.m_selectionFrontier : undefined;
        } // clear selection first


        this._clearSelection(false, selectionFrontier); // selects each key


        for (var i = 0; i < newSelection.length; i++) {
          var elem = this.FindElementByKey(newSelection[i]);

          if (elem != null) {
            this._applySelection(elem, newSelection[i]);
          }
        }
      }

      if (selected != null) {
        this._updateFirstSelectedItem(selected);
      }
    }
  },

  /**
   * Trigger an event to fire.
   * @param {string} type the type of event
   * @param {Object} event the jQuery event to fire
   * @param {Object} ui the ui param
   * @protected
   */
  Trigger: function Trigger(type, event, ui) {
    return this.ojContext._trigger(type, event, ui);
  },

  /**
   * Sets an option on the widget
   * @param {string} key the option key
   * @param {Object} value the option value
   * @param {Object=} flags any optional parameters
   * @protected
   */
  SetOption: function SetOption(key, value, flags) {
    this.ojContext.option(key, value, flags);
  },

  /**
   * Gets the value of an option from the widget
   * @param {string} key the option key
   * @return {Object} the value of the option
   * @protected
   */
  GetOption: function GetOption(key) {
    return this.ojContext.option(key);
  },

  /**
   * Compose a description for busy state
   * @param {string} description the description
   * @return {string} the busy state description
   * @private
   */
  _getBusyDescription: function _getBusyDescription(description) {
    var id = this.ojContext._IsCustomElement() ? this.GetRootElement().attr('id') : this.element.attr('id');
    return "The component identified by '" + id + "', " + description;
  },

  /**
   * Invoke whenever a task is started. Moves the component out of the ready state if necessary.
   * @param {string=} description the description of the task
   */
  signalTaskStart: function signalTaskStart(description) {
    var self = this;

    if (this.readinessStack) {
      if (this.readinessStack.length === 0) {
        this.readyPromise = new Promise(function (resolve) {
          self.readyResolve = resolve;
        }); // whenReady is deprecated in favor of page busystate (but we still need to support old syntax)

        var busyContext = Context.getContext(this.element[0]).getBusyContext();
        var options = description != null ? {
          description: this._getBusyDescription(description)
        } : {};
        self.busyStateResolve = busyContext.addBusyState(options);
      }

      this.readinessStack.push(description != null ? description : 'unknown task');
    }
  },

  /**
   * Invoke whenever a task finishes. Resolves the readyPromise if component is ready to move into ready state.
   */
  signalTaskEnd: function signalTaskEnd() {
    if (this.readinessStack && this.readinessStack.length > 0) {
      this.readinessStack.pop();

      if (this.readinessStack.length === 0) {
        this.readyResolve(null); // whenReady is deprecated in favor of page busystate (but we still need to support old syntax)

        this.busyStateResolve(null);
        this.busyStateResolve = null;
      }
    }
  },

  /**
   * Checks whether ListView is in ready state.  Called by the ContentHandler.
   * @return {boolean} true if ListView is in ready state, false otherwise
   */
  isReady: function isReady() {
    return this.busyStateResolve == null;
  },

  /**
   * Throw an error.  Do any neccessary cleanup.
   */
  throwError: function throwError(err) {
    if (this.readinessStack) {
      while (this.readinessStack.length > 0) {
        this.signalTaskEnd();
      }
    }

    throw err;
  },

  /**
   * Gets an array of items based on specified ids.
   * @param {Array} ids an array of item ids.
   * @return {Array} an array of elements matching the item ids.
   */
  getItems: function getItems(ids) {
    var self = this;
    var items = [];
    $.each(ids, function (index, value) {
      var elem = self.FindElementByKey(value);

      if (elem != null) {
        items.push(elem);
      }
    });
    return items;
  },

  /** ************************************ Core rendering ********************************/

  /**
   * Whether display option is set to 'card'.  Note this is different than isCardLayout which includes
   * the legacy way to switch to card layout mode using marker style class.
   * @private
   */
  isCardDisplayMode: function isCardDisplayMode() {
    return this.GetOption('display') === 'card';
  },

  /**
   * Whether the listview is in card layout mode
   * @return {boolean} true if it is in card layout mode, false otherwise
   */
  isCardLayout: function isCardLayout() {
    var elem = this.ojContext._IsCustomElement() ? this.GetRootElement() : this.element; // legacy marker class has precedence to ensure backward compatibility

    if (elem.hasClass('oj-listview-card-layout')) {
      return true;
    }

    return this.isCardDisplayMode();
  },

  /**
   * Whether to use grid role for ListView, to be override by NavList
   * @protected
   */
  ShouldUseGridRole: function ShouldUseGridRole() {
    return true;
  },

  /**
   * Whether to scrollPosition is supported, NavList for example do not support this
   * @protected
   */
  ShouldUpdateScrollPosition: function ShouldUpdateScrollPosition() {
    return this.ShouldUseGridRole() && this.ojContext._IsCustomElement();
  },

  /**
   * Destroy the content handler
   * @protected
   */
  DestroyContentHandler: function DestroyContentHandler(completelyDestroy) {
    if (this.m_contentHandler != null) {
      this.m_contentHandler.Destroy(completelyDestroy);
      delete this.m_contentHandler;
      this.m_contentHandler = null;
    } // ensure all busy states caused by outstanding fetch are resolved


    this._clearBusyState();
  },

  /**
   * Create the content handler based on data type
   * @return {Promise} which resolves to a ContentHandler
   * @protected
   */
  CreateDataContentHandler: function CreateDataContentHandler(data) {
    this.showStatusText();
    var contentHandler;

    if (typeof oj.TableDataSource !== 'undefined' && data instanceof oj.TableDataSource) {
      // TODO: load the adapter as needed
      contentHandler = new List.IteratingDataProviderContentHandler(this, this.element[0], new oj.TableDataSourceAdapter(data));
    } else if (typeof oj.TreeDataSource !== 'undefined' && data instanceof oj.TreeDataSource) {
      var adapterPromise = oj.__getRequirePromise('./ojtreedataprovideradapter', localRequire);

      if (!adapterPromise) {
        throw new Error('Cannot adapt a TreeDataSource if require() is not available');
      }

      var self = this;
      return adapterPromise.then(function (TreeDataSourceAdapter) {
        return new oj.TreeDataProviderContentHandler(self, self.element[0], new TreeDataSourceAdapter(data));
      });
    } else if (oj.DataProviderFeatureChecker.isTreeDataProvider(data)) {
      contentHandler = new oj.TreeDataProviderContentHandler(this, this.element[0], data);
    } else if (oj.DataProviderFeatureChecker.isDataProvider(data)) {
      contentHandler = new List.IteratingDataProviderContentHandler(this, this.element[0], data);
    } else {
      this.throwError('Invalid data or missing module');
    }

    return Promise.resolve(contentHandler);
  },

  /**
   * Update active descendant attribute
   * @param {jQuery} elem the active item element
   * @protected
   */
  UpdateActiveDescendant: function UpdateActiveDescendant(elem) {
    this.element.attr('aria-activedescendant', elem.attr('id'));
  },

  /**
   * Sets wai-aria properties on root element
   * @protected
   */
  SetAriaProperties: function SetAriaProperties() {
    if (this._isMultipleSelection()) {
      this.element.attr('aria-multiselectable', true);
    } else if (this._isSelectionEnabled()) {
      this.element.attr('aria-multiselectable', false);
    }
  },

  /**
   * Removes wai-aria properties on root element
   * @protected
   */
  UnsetAriaProperties: function UnsetAriaProperties() {
    this.element.removeAttr('aria-activedescendant').removeAttr('aria-multiselectable');
  },

  /**
   * When selectionMode option is updated, the aria-selected
   * attribute must be remove or updated
   * @param {string} selectionMode the new selection mode
   * @protected
   */
  UpdateItemAriaProperties: function UpdateItemAriaProperties(selectionMode) {
    var self = this;
    var func;

    if (selectionMode === 'none') {
      this.element.removeAttr('aria-multiselectable');

      func = function func(item) {
        self.getFocusItem(item).removeAttr('aria-selected');
      };
    } else {
      if (selectionMode === 'single') {
        this.element.attr('aria-multiselectable', false);
      } else {
        this.element.attr('aria-multiselectable', true);
      }

      func = function func(item) {
        var focusElem = self.getFocusItem(item);
        var parentElem = focusElem.parent();
        focusElem.attr('aria-selected', parentElem.hasClass('oj-selected'));
      };
    }

    var items = this._getItemsCache();

    for (var i = 0; i < items.length; i++) {
      func($(items[i]));
    }
  },

  /**
   * Build the elements inside and around the root
   * @param {Element} root the root element
   * @private
   */
  // eslint-disable-next-line no-unused-vars
  _buildList: function _buildList(root) {
    var container = this.getListContainer();
    this.SetAriaProperties();
    this.m_elementOffset = this.element.get(0).offsetTop;

    var status = this._buildStatus();

    container.append(status); // @HTMLUpdateOK

    this.m_status = status;

    var accInfo = this._buildAccInfo();

    container.append(accInfo); // @HTMLUpdateOK

    this.m_accInfo = accInfo; // touch specific instruction text for screen reader for reordering

    if (this._isTouchSupport() && this.m_dndContext != null) {
      container.append(this._buildAccInstructionText()); // @HTMLUpdateOK
    }
  },

  /**
   * Build a status bar div
   * @return {jQuery} the root of the status bar
   * @private
   */
  _buildStatus: function _buildStatus() {
    var icon = $(document.createElement('div'));
    icon.addClass('oj-icon').addClass(this.getLoadingStatusIconStyleClass());
    var root = $(document.createElement('div'));
    root.addClass(this.getStatusMessageStyleClass()).addClass(this.getStatusStyleClass()).attr({
      id: this._createSubId('status'),
      role: 'status'
    });
    root.append(icon); // @HTMLUpdateOK

    return root;
  },

  /**
   * Build the accessible text info div
   * @return {jQuery} the root of the acc info div
   * @private
   */
  _buildAccInfo: function _buildAccInfo() {
    var root = $(document.createElement('div'));
    root.addClass('oj-helper-hidden-accessible').attr({
      id: this._createSubId('info'),
      role: 'status'
    });
    return root;
  },

  /**
   * Build the accessible instruction text for touch devices
   * @return {jQuery} the root of the acc info div
   * @private
   */
  _buildAccInstructionText: function _buildAccInstructionText() {
    var root = $(document.createElement('div'));
    root.addClass('oj-helper-hidden-accessible').attr({
      id: this._createSubId('instr')
    });
    root.text(this.ojContext.getTranslatedString('accessibleReorderTouchInstructionText'));
    return root;
  },

  /**
   * Sets the accessible text info
   * @param {string} text the text to set on accessible info div
   * @private
   */
  _setAccInfoText: function _setAccInfoText(text) {
    if (text !== '' && this.m_accInfo.text() !== text) {
      this.m_accInfo.text(text);
    }
  },

  /**
   * Update role status text to reflect that it is fetching data
   * @private
   */
  updateStatusFetchStart: function updateStatusFetchStart() {
    var msg = this.ojContext.getTranslatedString('msgFetchingData');

    this._setAccInfoText(msg);
  },

  /**
   * Update role status text to reflect that fetched items are added to the end
   * @private
   */
  updateStatusFetchEnd: function updateStatusFetchEnd(count) {
    var msg = this.ojContext.getTranslatedString('msgItemsAppended', {
      count: count
    });

    this._setAccInfoText(msg);
  },

  /**
   * Whether skeletons should be shown for initial fetch.  Invoked by ContentHandler
   */
  isSkeletonSupport: function isSkeletonSupport() {
    // don't show for NavList
    if (this.ShouldUseGridRole() && this.m_contentHandler.renderInitialSkeletons) {
      var defaults = this._getOptionDefaults();

      return defaults.loadIndicator === 'skeleton';
    }

    return false;
  },

  /**
   * @private
   */
  _showLoadingIcon: function _showLoadingIcon() {
    var msg = this.ojContext.getTranslatedString('msgFetchingData');
    var container = this.getListContainer();
    this.m_status.attr('aria-label', msg).css('left', Math.max(0, container.outerWidth() / 2 - this.m_status.outerWidth() / 2)).css('top', Math.max(0, container.outerHeight() / 2 - this.m_status.outerHeight() / 2)).show(); // make sure the container is tall enough to show the indicator

    if (this.m_minHeightSet === undefined) {
      var statusHeight = this.m_status.get(0).offsetHeight;
      var containerHeight = container.get(0).offsetHeight;
      container.css('minHeight', Math.max(containerHeight, statusHeight + this.getListContainerBorderWidth()));
      this.m_minHeightSet = true;
    }
  },

  /**
   * @private
   */
  _showLoadingSkeleton: function _showLoadingSkeleton() {
    this.m_contentHandler.renderInitialSkeletons();
  },

  /**
   * Displays the 'fetching' status message
   * @private
   */
  showStatusText: function showStatusText() {
    var self = this; // it's already shown

    if (this.m_showStatusTimeout) {
      return;
    }

    this.m_showStatusTimeout = setTimeout(function () {
      // remove any empty text div
      $(document.getElementById(self._createSubId('empty'))).remove(); // listview might have already been destroyed

      if (self.m_contentHandler != null) {
        if (self.isSkeletonSupport()) {
          self._showLoadingSkeleton();
        } else {
          self._showLoadingIcon();
        }
      }

      self.m_showStatusTimeout = null;
    }, this._getShowStatusDelay());
  },

  /**
   * Retrieve the delay before showing status
   * @return {number} the delay in ms
   * @private
   */
  _getShowStatusDelay: function _getShowStatusDelay() {
    var defaultOptions = this._getOptionDefaults();

    var delay = parseInt(defaultOptions.showIndicatorDelay, 10);
    return isNaN(delay) ? 0 : delay;
  },

  /**
   * Hide the 'fetching' status message
   * @private
   */
  hideStatusText: function hideStatusText() {
    if (this.m_showStatusTimeout) {
      clearTimeout(this.m_showStatusTimeout);
      this.m_showStatusTimeout = null;
    }

    this.m_status.hide();
  },

  /**
   * Retrieves the root element
   * Invoke by widget
   * @protected
   * @return {jQuery} root element
   */
  GetRootElement: function GetRootElement() {
    return this.getListContainer();
  },

  /**
   * Retrieves the div around the root element, create one if needed.
   * @return {jQuery} the div around the root element
   */
  getListContainer: function getListContainer() {
    if (this.m_container == null) {
      this.m_container = this._createListContainer();
    }

    return this.m_container;
  },

  /**
   * Creates the div around the root element.
   * @return {jQuery} the div around the root element
   * @private
   */
  _createListContainer: function _createListContainer() {
    var listContainer;

    if (this.OuterWrapper) {
      listContainer = $(this.OuterWrapper);
    } else {
      listContainer = $(document.createElement('div'));
      this.element.parent()[0].replaceChild(listContainer[0], this.element[0]);
    }

    listContainer.addClass(this.GetContainerStyleClass()).addClass('oj-component');
    listContainer.prepend(this.element); // @HTMLUpdateOK

    return listContainer;
  },

  /**
   * If the empty text option is 'default' return default empty translated text,
   * otherwise return the emptyText set in the options
   * @return {string} the empty text
   * @private
   */
  _getEmptyText: function _getEmptyText() {
    return this.ojContext.getTranslatedString('msgNoData');
  },

  /**
   * Build an empty text div and populate it with empty text
   * @return {Element} the empty text element
   * @private
   */
  _buildEmptyText: function _buildEmptyText() {
    var emptyText = this._getEmptyText();

    var empty = document.createElement('li');
    empty.id = this._createSubId('empty');
    empty.className = this.getEmptyTextStyleClass() + ' ' + this.getEmptyTextMarkerClass();
    empty.textContent = emptyText;
    return empty;
  },

  /**
   * Determines whether the specified item is expanded
   * @param {jQuery} item the item element
   * @return {number} 0 if item is expanded, 1 if item is collapsed, 2 if item cannot be expand or collapse.
   * @protected
   */
  GetState: function GetState(item) {
    var expanded = this.getFocusItem(item).attr('aria-expanded');

    if (expanded === 'true') {
      return this.STATE_EXPANDED;
    } else if (expanded === 'false') {
      return this.STATE_COLLAPSED;
    }

    return this.STATE_NONE;
  },

  /**
   * Sets the disclosed state of the item
   * @param {jQuery} item the item element
   * @param {number} state 0 if item is expanded, 1 if item is collapsed, 2 if item cannot be expand or collapse.
   * @protected
   */
  SetState: function SetState(item, state) {
    var expandable = this.isExpandable();

    if (state === this.STATE_EXPANDED) {
      this.getFocusItem(item).attr('aria-expanded', 'true');

      if (expandable) {
        item.removeClass('oj-collapsed').addClass('oj-expanded');
      }
    } else if (state === this.STATE_COLLAPSED) {
      this.getFocusItem(item).attr('aria-expanded', 'false');

      if (expandable) {
        item.removeClass('oj-expanded').addClass('oj-collapsed');
      }
    }
  },

  /**
   * Gets the item option
   * @param {string} name the name of the option
   * @param {Object} context the context object
   * @param {boolean} resolve true evaluate if return value is a function, false otherwise
   * @return {function(Object)|Object|null} returns the item option
   * @private
   */
  _getItemOption: function _getItemOption(name, context, resolve) {
    var option = this.GetOption('item');
    var value = option[name];

    if (typeof value === 'function' && resolve) {
      return value.call(this, context);
    }

    return value;
  },

  /**
   * Gets the item.focusable option.
   * @param {Object} context the context object
   * @return {boolean} true if item.focusable option is derieved to be true, false otherwise
   */
  getItemFocusable: function getItemFocusable(context) {
    return this._getItemOption('focusable', context, true);
  },

  /**
   * Gets the item.selectable option.
   * @param {Object} context the context object
   * @return {boolean} true if item.selectable option is derieved to be true, false otherwise
   */
  getItemSelectable: function getItemSelectable(context) {
    // if it's not focusable, it's not selectable also
    return this.getItemFocusable(context) && this._getItemOption('selectable', context, true);
  },

  /**
   * Gets the item renderer
   * @return {function(Object)|null} returns the item renderer
   * @private
   */
  _getItemRenderer: function _getItemRenderer() {
    var renderer = this._getItemOption('renderer', null, false);

    if (typeof renderer !== 'function') {
      // cannot be non-function
      return null;
    }

    return this._WrapCustomElementRenderer(renderer);
  },

  /**
   * Returns the inline template element inside oj-list-view
   * @return {Element|null} the inline template element
   */
  getItemTemplate: function getItemTemplate() {
    if (this.m_template === undefined) {
      // cache the template, assuming replacing template will require refresh
      this.m_template = null;

      if (this.ojContext._IsCustomElement()) {
        var slotMap = this.GetSlotMap();
        var slot = slotMap.itemTemplate;

        if (slot && slot.length > 0 && slot[0].tagName.toLowerCase() === 'template') {
          this.m_template = slot[0];
        }
      }
    }

    return this.m_template;
  },

  /**
   * Returns the value of as option
   * @return {string}
   */
  getAs: function getAs() {
    return this.GetOption('as');
  },

  /**
   * Returns the slot map object.
   * @return {object} slot Map
   */
  GetSlotMap: function GetSlotMap() {
    return oj.BaseCustomElementBridge.getSlotMap(this.GetRootElement()[0]);
  },

  /**
   * Called by content handler once the content of an item is rendered triggered by an insert event
   * @param {Element} elem the item element
   * @param {Object} context the context object used for the item
   */
  // eslint-disable-next-line no-unused-vars
  itemInsertComplete: function itemInsertComplete(elem, context) {
    // clear cached height
    this.m_clientHeight = null;
    this.m_scrollHeight = null;
  },

  /**
   * Called by content handler once the content of an item is rendered triggered by an insert event
   */
  BeforeInsertItem: function BeforeInsertItem() {// hook for NavList
  },

  /**
   * Called by content handler once the content of an item is removed triggered by an remove event
   * @param {Element} elem the item element
   * @param {boolean} restoreFocus true if focus should be restore, false otherwise
   */
  itemRemoveComplete: function itemRemoveComplete(elem, restoreFocus) {
    // if it's the current focus item, try to focus on the next/prev item.  If there are none, then focus on the root element
    if (this.m_active != null && oj.Object.compareValues(this.m_active.key, this.GetKey(elem))) {
      // make sure we exit actionable mode, otherwise focus will be lost
      this._setActionableMode(false, true);

      var next = elem.nextElementSibling;

      if (next == null || !$(next).hasClass(this.getItemElementStyleClass())) {
        next = elem.previousElementSibling;

        if (next == null || !$(next).hasClass(this.getItemElementStyleClass())) {
          this.SetOption('currentItem', null);
        }
      }

      if (next != null && $(next).hasClass(this.getItemElementStyleClass())) {
        this.SetCurrentItem($(next), null, !restoreFocus);
      }
    } // disassociate element from key map


    if (elem != null && elem.id && this.m_keyElemMap != null) {
      this.m_keyElemMap.delete(elem.id);
    } // clear cached height


    this.m_clientHeight = null;
    this.m_scrollHeight = null;
  },

  /**
   * Called by content handler once the content of an item is rendered
   * @param {Element} elem the item element
   * @param {Object} context the context object used for the item
   */
  itemRenderComplete: function itemRenderComplete(elem, context) {
    // dnd
    if (this.m_dndContext != null) {
      this.m_dndContext.itemRenderComplete(elem);
    }

    var key = context.key; // update as selected if it is in selection, check if something already selected in single selection

    if (this._isSelectionEnabled()) {
      var selected = this.GetOption('selected');
      var selectedItems;
      var exists = selected.has(key);

      if (this.IsSelectable(elem)) {
        if (exists) {
          this._applySelection(elem, key); // if it's single selection, then bail


          if (!this._isMultipleSelection()) {
            if (selected.values().size > 1) {
              // we'll have to modify the value
              selectedItems = this.FindElementByKey(key);
              selected = selected.clear().add([key]);

              this._setSelectionOption(selected, null, selectedItems, context.data);
            }
          }
        } // if selectionRequired is set to true and selection is empty, selects the first selectable item
        // this should be run once since selection won't be empty afterwards


        if (selected.values && selected.values().size === 0 && this._isSelectionRequired()) {
          this._applySelection(elem, key); // need to pass data since 1) to avoid unneccesary lookup 2) since item is not in live dom, getDataForVisibleItem would not work


          selected = selected.clear().add([key]);

          this._setSelectionOption(selected, null, [elem], context.data);
        }
      } else if (exists && !selected.isAddAll()) {
        // the selection is invalid, remove it from selection
        selectedItems = [];
        selected = selected.delete([key]);
        selected.values().forEach(function (aKey) {
          selectedItems.push(this.FindElementByKey(aKey));
        }, this);

        this._setSelectionOption(selected, null, selectedItems);
      }
    }

    var self = this; // update if it is in expanded, ensure data is hierarchical

    if (this.m_contentHandler.IsHierarchical() && this._ignoreExpanded == null) {
      // checks if it is expandable && is collapsed
      if (this.GetState($(elem)) === this.STATE_COLLAPSED) {
        var expanded = this.GetOption('expanded'); // checks if expand all

        if (this._isExpandAll(key)) {
          // for legacy syntax, expanded is not real-time in certain cases, i.e. you
          // can have expanded='all' but some itms are collapsed
          // for custom element we don't care about collapsedKeys since KeySet is keeping track of it
          if (this.ojContext._IsCustomElement() || this._collapsedKeys == null) {
            // don't animate
            this.ExpandItem($(elem), null, false, null, false, false, false);
          }
        } else if (!this.ojContext._IsCustomElement() && Array.isArray(expanded)) {
          // legacy syntax array of expanded keys
          // checks if specified expanded
          $.each(expanded, function (_index, value) {
            // if it was explicitly collapsed
            if (value === key && (self._collapsedKeys == null || self._collapsedKeys.indexOf(value) === -1)) {
              // don't animate
              self.ExpandItem($(elem), null, false, null, false, false, false);
            }
          });
        } else if (expanded.has) {
          // KeySet case
          if (expanded.has(key)) {
            // don't animate
            this.ExpandItem($(elem), null, false, null, false, false, false);
          }
        }
      }
    } // checks if the active element has changed, this could happen in TreeDataSource, where the element gets remove when collapsed
    // or when the item updated (mutation event) is the current item


    if (this.m_active != null && key === this.m_active.key && this.m_active.elem != null && elem !== this.m_active.elem.get(0)) {
      this.m_active.elem = $(elem);
    }
  },

  /**
   * Returns the noData template element inside oj-list-view
   * @return {Element|null} the content of noData slot
   * @private
   */
  _addNoData: function _addNoData() {
    if (this.m_noDataContent == null) {
      if (this.ojContext._IsCustomElement()) {
        var slotMap = this.GetSlotMap();
        var slot = slotMap.noData;

        if (slot && slot.length > 0 && slot[0].tagName.toLowerCase() === 'template') {
          var noDataContentRoot = document.createElement('li');
          noDataContentRoot.id = this._createSubId('empty');
          noDataContentRoot.classList.add('oj-listview-no-data-container');
          noDataContentRoot.classList.add('oj-listview-no-data-item');
          var root = this.element;
          root.addClass('oj-listview-no-data-container');
          root.append(noDataContentRoot); // @HTMLUpdateOK

          var self = this;
          this.signalTaskStart('run no data template');

          Config.__getTemplateEngine().then(function (engine) {
            var nodes = engine.execute(self.GetRootElement(), slot[0], {}, null);
            nodes.forEach(function (node) {
              noDataContentRoot.appendChild(node); // @HTMLUpdateOK
            });
            self.m_noDataContent = noDataContentRoot;
            self.m_engine = engine;
            self.signalTaskEnd();
          }, function (reason) {
            self.signalTaskEnd();
            throw new Error('Error loading template engine: ' + reason);
          });

          return;
        }
      } // non-custom element or when noData slot is specified


      this.element.append(this._buildEmptyText()); // @HTMLUpdateOK
    } else {
      // cached
      this.element.addClass('oj-listview-no-data-container');
      this.element.append(this.m_noDataContent); // @HTMLUpdateOK
    }
  },

  /**
   * Remove empty element artifacts from list
   * @private
   */
  _removeNoData: function _removeNoData() {
    var elem = document.getElementById(this._createSubId('empty'));

    if (elem) {
      if (this.m_engine) {
        this.m_engine.clean(elem);
      }

      elem.parentNode.classList.remove('oj-listview-no-data-container');
      elem.parentNode.removeChild(elem);
    }
  },

  /**
   * Called by content handler once content of all items are rendered
   */
  renderComplete: function renderComplete() {
    var self = this;
    this.hideStatusText(); // remove any empty text div

    this._removeNoData(); // clear items cache


    this.m_items = null;
    this.m_groupItems = null; // if grid role and card layout and non-heirarchical and presentation div is empty, remove presentation div to clear out the element

    if (this._isEmptyGrid()) {
      this.element[0].removeChild(this.element[0].children[0]);
    } // check if it's empty


    if (this._isEmpty()) {
      this._addNoData(); // fire ready event


      this.Trigger('ready', null, {});
      return;
    } // check if current is specified


    var current = this.GetOption('currentItem');

    if (current != null) {
      var elem = this.FindElementByKey(current);

      if (elem == null) {
        // it's not valid anymore, reset current
        this.SetOption('currentItem', null);
      } else if (this.m_active == null && !this.SkipFocus($(elem))) {
        var active = document.activeElement; // update tab index and focus only if listview currently has focus

        if (active && this.element.get(0).contains(active)) {
          this.ActiveAndFocus($(elem), null);
        } else {
          // update internal state only
          this._setActive($(elem), null, true);
        }
      }
    } // if listview has focus but there's no active element, then set focusable item
    // this could happen after refresh from context menu


    if (this.getListContainer().hasClass('oj-focus-ancestor') && this.m_active == null && current == null && !this._isTouchSupport()) {
      this._initFocus();
    } // clear the scroll and fetch flag before calling syncScrollPosition


    this.m_scrollAndFetch = undefined; // update scroll position if it's not in sync, make sure we are not in the middle of scrolling

    if (!this.m_ticking || this.m_scrollPosition != null) {
      this.syncScrollPosition();
    } // validate selection as needed
    // only do the validation once for initial render/refresh


    if (this.m_keyElemMap == null && this._isSelectionEnabled() && this._isSelectionRequired()) {
      this.signalTaskStart('validating selection entries'); // take a snapshot of the value since the value is live and mutable

      var selection = this.GetOption('selection').slice(0);

      if (selection.length > 0) {
        this._validateSelection(selection).then(function (validRowKeyData) {
          // if all of the selection are invalid, then we'll need to select the first item
          // and update the selection
          if (validRowKeyData.validKeys.length === 0) {
            self._selectFirstSelectableItem();
          } else {
            self._setSelectionOption(KeySet.KeySetUtils.toKeySet(validRowKeyData.validKeys), null, null, validRowKeyData.validData[0].data);
          } // ... and fire ready event (legacy)


          self.Trigger('ready', null, {});
          self.signalTaskEnd();
        });
      }
    } // update firstSelectedItem as needed


    if (this._isSelectionEnabled()) {
      var firstSelectedItem = this.GetOption('firstSelectedItem');

      if (firstSelectedItem == null || firstSelectedItem.key == null) {
        var selected = this.GetOption('selected');

        if (selected != null) {
          this._updateFirstSelectedItem(selected);
        }
      }
    } // about gridlines for last item


    if (this.m_gridlinePlaceholder != null) {
      this.m_gridlinePlaceholder.parentNode.removeChild(this.m_gridlinePlaceholder);
    }

    if ((this.m_contentHandler.hasMoreToFetch === undefined || this.m_contentHandler.hasMoreToFetch && !this.m_contentHandler.hasMoreToFetch()) && this._shouldRenderGridlineForLastItem()) {
      var gridlinePlaceholder = document.createElement('li');
      gridlinePlaceholder.setAttribute('role', 'presentation');
      gridlinePlaceholder.className = 'oj-listview-gridline-placeholder';
      this.element[0].appendChild(gridlinePlaceholder);
      this.m_gridlinePlaceholder = gridlinePlaceholder;
    } // apply card entrance animation


    if (this._isAnimateCards()) {
      var isInitial = this.element[0].querySelector('.oj-listview-card-animated') == null;
      var delay = 0;

      var increment = this._getCardEntranceAnimationDelay();

      this.element[0].querySelectorAll('.oj-listview-card:not(.oj-listview-card-animated)').forEach(function (card) {
        // mark as animated so we can filter it next time
        card.classList.add('oj-listview-card-animated'); // eslint-disable-next-line no-param-reassign

        card.style.opacity = 0;

        if (isInitial) {
          card.classList.add('oj-actioncard-initial-entrance-animation'); // eslint-disable-next-line no-param-reassign

          card.style.animationDelay = delay + 'ms';
          delay = Math.min(1000, delay + increment);
        } else {
          card.classList.add('oj-actioncard-loadmore-entrance-animation');
        }
      });
    } // fire ready event


    this.Trigger('ready', null, {});
  },

  /**
   * Retrieve the animation delay between card entrance animation
   * @return {number} the delay in ms
   * @private
   */
  _getCardEntranceAnimationDelay: function _getCardEntranceAnimationDelay() {
    var defaultOptions = this._getOptionDefaults();

    var delay = parseInt(defaultOptions.cardAnimationDelay, 10);
    return isNaN(delay) ? 0 : delay;
  },

  /**
   * Validate keys in selection
   * @private
   */
  _validateSelection: function _validateSelection(selection) {
    var validRowKeyDataPromise = this._fetchValidRowKeyData(selection);

    if (validRowKeyDataPromise) {
      return validRowKeyDataPromise.then(function (validRowKeyData) {
        for (var i = selection.length - 1; i >= 0; i--) {
          if (validRowKeyData.validKeys.indexOf(selection[i]) === -1) {
            selection.splice(i, 1);
          }
        }

        return validRowKeyData;
      });
    }

    return Promise.resolve({
      validKeys: [],
      validData: []
    });
  },

  /**
   * Validate keys in selected
   * @private
   */
  _fetchValidRowKeyData: function _fetchValidRowKeyData(keys) {
    // need to verify keys if we have a DataProvider that supports non-iteration 'fetchByKeys'
    var dataProvider = this.m_contentHandler.getDataProvider();

    if (dataProvider && dataProvider.getCapability) {
      var capability = dataProvider.getCapability('fetchByKeys');

      if (capability && capability.implementation === 'lookup') {
        return new Promise(function (resolve) {
          dataProvider.fetchByKeys({
            keys: new Set(keys),
            scope: 'global'
          }).then(function (fetchResult) {
            var validKeys = [];
            var validData = [];
            var validKeysResult = fetchResult.results;
            validKeysResult.forEach(function (value, key) {
              validKeys.push(key);
              validData.push(value);
            });
            resolve({
              validKeys: validKeys,
              validData: validData
            });
          }, function () {
            // something bad happened, treat keys as invalid
            resolve({
              validKeys: [],
              validData: []
            });
          });
        });
      }
    } // if we can't validate, return null


    return null;
  },

  /**
   * Returns whether or not the li presentation div is present and empty.
   * @private
   * @returns {boolean} true if li presentation div is present and empty.
   */
  _isEmptyGrid: function _isEmptyGrid() {
    return this.ShouldUseGridRole() && this.isCardLayout() && !this.m_contentHandler.IsHierarchical() && this.element[0].children[0] && this.element[0].children[0].children[0].childElementCount === 0;
  },

  /**
   * @private
   */
  _setScrollY: function _setScrollY(scroller, y) {
    if (!this._skipScrollUpdate) {
      this.signalTaskStart('waiting for scroll handler');
    } // flag it so that handleScroll won't do anything


    this._skipScrollUpdate = true; // eslint-disable-next-line no-param-reassign

    scroller.scrollTop = y; // update sticky header as needed

    this._handlePinGroupHeader();
  },

  /**
   * Sets the bidi independent position of the horizontal scroll position that
   * is consistent across all browsers.
   * @private
   */
  _setScrollX: function _setScrollX(scroller, x) {
    if (!this._skipScrollUpdate) {
      this.signalTaskStart('waiting for scroll handler');
    } // flag it so that handleScroll won't do anything


    this._skipScrollUpdate = true;
    oj.DomUtils.setScrollLeft(scroller, x);
  },

  /**
   * Retrieve the bidi independent position of the horizontal scroll position that
   * is consistent across all browsers.
   * @private
   */
  _getScrollX: function _getScrollX(scroller) {
    return oj.DomUtils.getScrollLeft(scroller);
  },

  /**
   * Validate a set of keys
   * @return {Promise|null} a Promise that resolves to true if one of the keys specified is valid, false otherwise.
   *                        Returns null if it cannot validate the keys.
   * @private
   */
  _validateKeys: function _validateKeys(keys) {
    var self = this;

    for (var i = 0; i < keys.length; i++) {
      // found one of the keys in cache, we are done
      if (this.FindElementByKey(keys[i]) != null) {
        return Promise.resolve(true);
      }
    } // need to verify key if we have a DataProvider that supports FetchByKeys


    if (this.m_contentHandler instanceof List.IteratingDataProviderContentHandler) {
      var dataProvider = this.m_contentHandler.getDataProvider();

      if (dataProvider.containsKeys) {
        return new Promise(function (resolve) {
          // IE 11 does not support specifying value in constructor
          var set = new Set();
          keys.forEach(function (key) {
            set.add(key);
          });
          self.signalTaskStart('Checking for keys');
          dataProvider.containsKeys({
            keys: set
          }).then(function (value) {
            resolve(value.results.size > 0);
            self.signalTaskEnd();
          }, function () {
            // something bad happened, treat it as invalid key
            self.signalTaskEnd();
            resolve(false);
          });
        });
      }
    } // else we can't verify, so just return null and let syncScrollPosition tries to fetch
    // and find the item


    return null;
  },

  /**
   * @private
   */
  _getScrollHeight: function _getScrollHeight() {
    if (this.m_scrollHeight == null) {
      this.m_scrollHeight = this._getScroller().scrollHeight;
    }

    return this.m_scrollHeight;
  },

  /**
   * @private
   */
  _getClientHeight: function _getClientHeight() {
    if (this.m_clientHeight == null) {
      this.m_clientHeight = this._getScroller().clientHeight;
    }

    return this.m_clientHeight;
  },

  /**
   * @private
   */
  _getScrollWidth: function _getScrollWidth() {
    if (this.m_scrollWidth == null) {
      this.m_scrollWidth = this._getScroller().scrollWidth;
    }

    return this.m_scrollWidth;
  },

  /**
   * @private
   */
  _getClientWidth: function _getClientWidth() {
    if (this.m_clientWidth == null) {
      this.m_clientWidth = this._getScroller().clientWidth;
    }

    return this.m_clientWidth;
  },

  /**
   * @private
   */
  _isScrollable: function _isScrollable() {
    return this._isScrollableY() || this._isScrollableX();
  },
  _isScrollableX: function _isScrollableX() {
    return Math.abs(this._getScrollWidth() - this._getClientWidth()) > 1;
  },
  _isScrollableY: function _isScrollableY() {
    return Math.abs(this._getScrollHeight() - this._getClientHeight()) > 1;
  },

  /**
   * Synchronize the scroll position
   * @protected
   */
  syncScrollPosition: function syncScrollPosition(position, validateKey) {
    var self = this;
    var coord;
    var x;
    var y;
    var scrollTop; // we do not need to handle scrollPosition for NavList

    if (!this.ShouldUseGridRole()) {
      return;
    } // eslint-disable-next-line no-param-reassign


    validateKey = validateKey === undefined ? true : validateKey; // check if it's even scrollable, note due to sub-pixel issue, doing
    // an exact match will not work at all times

    if (!this._isScrollable()) {
      return;
    }

    if (this.ShouldUpdateScrollPosition()) {
      if (this.m_scrollPosition != null) {
        // eslint-disable-next-line no-param-reassign
        position = this.m_scrollPosition;
      } else if (position === undefined) {
        // eslint-disable-next-line no-param-reassign
        position = this.GetOption('scrollPosition');
      }

      if (validateKey && position.key != null) {
        var promise = this._validateKeys([position.key]);

        if (promise) {
          promise.then(function (valid) {
            if (self.m_contentHandler != null) {
              if (!valid) {
                // remove invalid or non-existing key
                // eslint-disable-next-line no-param-reassign
                delete position.key;
              } // try again


              self.syncScrollPosition(position, false);
            }
          });
          return;
        }
      } // figure out what the final y should be


      coord = this._getScrollCoordinates(position);
      x = coord.x;
      y = coord.y;

      if (isNaN(x) && isNaN(y)) {
        // invalid scroll position
        if (this.m_scrollPosition != null) {
          // we'll still need to report current scroll position, which could have changed because of scroll and fetch
          this.SetOption('scrollPosition', this._getCurrentScrollPosition(scrollTop), {
            _context: {
              originalEvent: null,
              internalSet: true
            }
          }); // free signalTaskStart from earlier when m_scrollPosition is saved

          this.signalTaskEnd();
          this.m_scrollPosition = null;
        }

        return;
      }
    }

    if (coord === undefined) {
      // legacy scrollTop attribute
      y = this.GetOption('scrollTop');
    }

    var scroller = this._getScroller();

    scrollTop = scroller.scrollTop; // check if only x updated

    if (!isNaN(x) && isNaN(y) || !isNaN(x) && y === scrollTop && x !== this._getScrollX(scroller, x)) {
      // if not horizontally scrollable then bail
      if (!this._isScrollableX()) {
        this._clearOutstandingScrollPosition();

        return;
      }

      this._setScrollX(scroller, x);

      var scrollPosition = this.GetOption('scrollPosition');
      x = this._getScrollX(scroller);
      var newScrollPosition = {
        x: x,
        y: scrollPosition.y,
        index: scrollPosition.index,
        key: scrollPosition.key,
        offsetX: x,
        offsetY: scrollPosition.offsetY
      };

      if (scrollPosition.parent) {
        newScrollPosition.parent = scrollPosition.parent;
      }

      this.SetOption('scrollPosition', newScrollPosition, {
        _context: {
          originalEvent: null,
          internalSet: true
        }
      });
    } else if (y !== scrollTop) {
      var scrollUpdated = false; // flag it so that handleScroll won't do anything

      if (this._isScrollableY()) {
        this._setScrollY(scroller, y);

        scrollUpdated = true;
      }

      if (!isNaN(x) && x !== this._getScrollX(scroller, x) && this._isScrollableX()) {
        this._setScrollX(scroller, x);

        scrollUpdated = true;
      } // if nothing is updated, just bail


      if (!scrollUpdated) {
        this._clearOutstandingScrollPosition();

        return;
      } // checks if further scrolling is needed


      scrollTop = scroller.scrollTop; // cannot use scrollTop === y, as browser sub-pixel could be off by < 1px

      if (Math.abs(scrollTop - y) >= 1 && this.m_contentHandler.hasMoreToFetch && this.m_contentHandler.hasMoreToFetch()) {
        if (this.m_scrollPosition == null) {
          // we don't need to signalTaskStart again if we are already in one
          this.signalTaskStart('Scroll position needs to resolve further');
        }

        this.m_scrollAndFetch = true; // yes, save the scrollPosition to set and bail

        this.m_scrollPosition = position;
        return;
      } // ok to update scrollPosition option


      this.SetOption('scrollPosition', this._getCurrentScrollPosition(scrollTop), {
        _context: {
          originalEvent: null,
          internalSet: true
        }
      });
    } else if (position && (position.key == null || isNaN(position.index))) {
      // if x and y is present, but position value is not complete, get it
      // ok to update scrollPosition option
      this.SetOption('scrollPosition', this._getCurrentScrollPosition(scrollTop), {
        _context: {
          originalEvent: null,
          internalSet: true
        }
      });
    }

    this._clearOutstandingScrollPosition();
  },

  /**
   * Clear the variable for intermediate scrollPosition (that require fetch)
   * @private
   */
  _clearOutstandingScrollPosition: function _clearOutstandingScrollPosition() {
    if (this.m_scrollPosition != null) {
      // free signalTaskStart from earlier when m_scrollPosition is saved
      this.signalTaskEnd();
      this.m_scrollPosition = null;
    }
  },

  /**
   * When an item is updated, if the item happens to be the current item and it previously has focus, then
   * we'll need to restore focus.
   * @protected
   */
  restoreCurrentItemFocus: function restoreCurrentItemFocus(elem) {
    if (this._isInViewport(elem)) {
      this._setActive($(elem), null, true);
    }
  },

  /**
   * Called by content handler to reset the state of ListView
   * @private
   */
  ClearCache: function ClearCache(clearKeyMap) {
    // clear any element dependent cache
    this.m_items = null;
    this.m_groupItems = null;

    if (clearKeyMap && this.m_keyElemMap != null) {
      this.m_keyElemMap.clear();
    }
  },

  /**
   * Determine the minimum number of items needed to fill the viewport
   * @protected
   */
  getMinimumCountForViewport: function getMinimumCountForViewport() {
    var itemHeight = this._getItemHeight();

    var clientHeight = this._getClientHeight();

    if (!isNaN(itemHeight) && itemHeight > 0) {
      var numOfItems = Math.ceil(clientHeight / itemHeight);
      return numOfItems;
    }

    return 1;
  },

  /**
   * Checks whether the specified element is within the viewport
   * @private
   */
  _isInViewport: function _isInViewport(elem) {
    var top = elem.offsetTop; // using average height is good enough to avoid offsetHeight

    var itemHeight = this._getItemHeight();

    var height = isNaN(itemHeight) ? elem.offsetHeight : itemHeight;
    var scrollPosition = this.GetOption('scrollPosition');
    var scrollTop = scrollPosition == null || isNaN(scrollPosition.y) ? 0 : scrollPosition.y;

    if (top + height < scrollTop || top > scrollTop + this._getClientHeight()) {
      return false;
    }

    return true;
  },

  /**
   * Gets a list of actions that supports animation
   * @private
   */
  _getAnimatedActions: function _getAnimatedActions() {
    return ['add', 'remove', 'update', 'expand', 'collapse'];
  },

  /**
   * Utility method to start animation
   * @param {Element} elem element to animate
   * @param {string} action the animation action
   * @param {Object=} effect optional animation effect, if not specified then it will be derived based on action
   * @return {Promise} the promise which will be resolve when animation ends
   * @protected
   */
  StartAnimation: function StartAnimation(elem, action, effect) {
    // if it's not in viewport, don't animate.  Only do this for default animations.
    // For example, do not do this optimization for NavList specific animations.
    if (this._getAnimatedActions().indexOf(action) > -1 && !this._isInViewport(elem)) {
      return Promise.resolve(null);
    }

    if (effect == null) {
      // eslint-disable-next-line no-param-reassign
      effect = this.getAnimationEffect(action);
    }

    var originalHeight;
    var originalMaxHeight;

    if (action === 'expand') {
      var initialHeight = elem.getAttribute('data-oj-initial-height');

      if (initialHeight != null && !isNaN(initialHeight)) {
        // clone it to inject additional effect options
        // eslint-disable-next-line no-param-reassign
        effect = Object.assign({}, effect); // eslint-disable-next-line no-param-reassign

        effect.startMaxHeight = initialHeight + 'px';
        var contentHeight = elem.offsetHeight; // in the shrink case (skeleton height is taller than actual content height)

        if (contentHeight < initialHeight) {
          originalMaxHeight = elem.style.maxHeight;
          originalHeight = elem.style.height; // eslint-disable-next-line no-param-reassign

          elem.style.maxHeight = 'none'; // eslint-disable-next-line no-param-reassign

          elem.style.height = initialHeight + 'px'; // eslint-disable-next-line no-param-reassign

          effect.effect = 'collapse'; // eslint-disable-next-line no-param-reassign

          effect.endMaxHeight = contentHeight + 'px';
        }

        elem.removeAttribute('data-oj-initial-height');
      }
    } // eslint-disable-next-line no-undef


    var promise = AnimationUtils.startAnimation(elem, action, effect, this.ojContext);

    if (originalHeight !== undefined) {
      promise.then(function () {
        // eslint-disable-next-line no-param-reassign
        elem.style.height = originalHeight; // eslint-disable-next-line no-param-reassign

        elem.style.maxHeight = originalMaxHeight;
      });
    }

    return promise;
  },

  /** ******************* context menu methods *****************/

  /**
   * @param {!Object} menu The JET Menu to open as a context menu.  Always non-<code class="prettyprint">null</code>.
   * @param {!Event} event What triggered the menu launch.  Always non-<code class="prettyprint">null</code>.
   * @param {string} eventType "mouse", "touch", or "keyboard".  Never <code class="prettyprint">null</code>.
   * Invoked by widget
   */
  notifyContextMenuGesture: function notifyContextMenuGesture(menu, event, eventType) {
    // first check if we are invoking on an editable or clickable element If so bail
    if (this.m_noDataContent == null && this.IsNodeEditableOrClickable($(event.target))) {
      return false;
    } // set the item right click on active


    var parent = $(event.target).closest('.' + this.getItemElementStyleClass()); // prepare the context menu that have listview specific menu items

    this.PrepareContextMenu(parent);

    if (parent.length > 0 && !this.SkipFocus($(parent[0]))) {
      this.SetCurrentItem($(parent[0]), null);
    }

    var launcher; // When user right click on disabled item(non-focusable), this.m_active
    // will not be updated to disabled item so explicitly setting the launcher from event.target.

    if (event.button === 2) {
      launcher = this._findItem($(event.target));
    } else if (this.m_active != null) {
      launcher = this.m_active.elem;
    } // if not on any item, then launcher is the root element


    if (launcher == null) {
      launcher = this.element;
    }

    var openOptions = {
      launcher: launcher,
      initialFocus: 'menu'
    };

    if (eventType === 'keyboard') {
      openOptions.position = {
        my: 'start top',
        at: 'start bottom',
        of: launcher
      };
    }

    this.ojContext._OpenContextMenu(event, eventType, openOptions);

    return undefined;
  },

  /**
   * Decorates or prepares context menu items. Navlist need overrides this to decorate remove menu item.
   * @param {jQuery} item  Item
   * @protected
   * @ignore
   */
  // eslint-disable-next-line no-unused-vars
  PrepareContextMenu: function PrepareContextMenu(item) {
    if (this.m_dndContext != null) {
      this.m_dndContext.prepareContextMenu(this.ojContext._GetContextMenu());
    }
  },

  /**
   * Override helper for NavList to override checks for whether a node is editable or clickable.
   * @param {jQuery} node  Node
   * @return {boolean} true or false
   * @protected
   */
  IsElementEditableOrClickable: function IsElementEditableOrClickable(node) {
    var nodeName = node.prop('nodeName');
    return nodeName.match(/^INPUT|SELECT|OPTION|BUTTON|^A\b|TEXTAREA/) != null;
  },

  /**
   * Return whether the node is editable or clickable.  Go up the parent node as needed.
   * @param {jQuery} node  Node
   * @return {boolean} true or false
   * @protected
   */
  IsNodeEditableOrClickable: function IsNodeEditableOrClickable(node) {
    while (node != null && node[0] !== this.element[0] && node.prop('nodeName') !== 'LI') {
      // If the node is a text node, move up the hierarchy to only operate on elements
      // (on at least the mobile platforms, the node may be a text node)
      if (node[0].nodeType === 3) {
        // 3 is Node.TEXT_NODE
        // eslint-disable-next-line no-param-reassign
        node = node.parent();
      } else {
        var tabIndex = node.attr('tabIndex'); // listview overrides the tab index, so we should check if the data-oj-tabindex is populated

        var origTabIndex = node.attr('data-oj-tabindex');

        if (tabIndex != null && tabIndex >= 0 && !node.hasClass(this.getFocusedElementStyleClass()) && !node.hasClass('oj-listview-cell-element')) {
          return true;
        } else if (this.IsElementEditableOrClickable(node)) {
          // ignore elements with tabIndex === -1
          if (tabIndex !== -1 || origTabIndex !== -1) {
            return true;
          }
        } // eslint-disable-next-line no-param-reassign


        node = node.parent();
      }
    }

    return false;
  },

  /** ******************* focusable/editable element related methods *****************/

  /**
   * Make all tabbable elements within the specified cell un-tabbable
   * @param {Element} element
   * @param {boolean=} excludeActiveElement see inline comment for details
   */
  disableAllTabbableElements: function disableAllTabbableElements(element, excludeActiveElement) {
    var elem = $(element); // if it's a group item, inspect the direct div only so it will skip all children

    if (!elem.hasClass(this.getItemStyleClass())) {
      elem = $(elem.get(0).firstElementChild);
    } // a group cell could have contained a cell element, which should be skip also


    if (elem.children().first().hasClass('oj-listview-cell-element')) {
      elem = $(elem.get(0).firstElementChild);
    } // should exclude non-visible elements, but doing a visible check here causes re-layout and since it's done
    // on every item on render, it becomes expensive.  Do the filter later in enableTabbableElements, which is only
    // triggered by entering actionable mode.


    if (elem[0]) {
      var elems = $(DataCollectionUtils.disableAllFocusableElements(elem[0], true, excludeActiveElement));
      elems.each(function () {
        $(this).removeAttr('data-first').removeAttr('data-last');
      });
    }
  },

  /**
   * Make all tabbable elements before and include current item un-tabbable
   * @param {Element} item
   * @private
   */
  _disableAllTabbableElementsBeforeItem: function _disableAllTabbableElementsBeforeItem(item) {
    var items = this._getItemsCache();

    var index = items.index(item); // if -1 it will just bail

    for (var i = 0; i <= index; i++) {
      this.disableAllTabbableElements(items[i], true);
    }
  },

  /**
   * Make all tabbable elements after and include current item un-tabbable
   * @param {Element} item
   * @private
   */
  _disableAllTabbableElementsAfterItem: function _disableAllTabbableElementsAfterItem(item) {
    var items = this._getItemsCache();

    var index = items.index(item);

    if (index === -1) {
      return;
    }

    for (var i = index; i <= items.length - 1; i++) {
      this.disableAllTabbableElements(items[i], true);
    }
  },

  /**
   * Make all previously tabbable elements within the element tabbable again
   * @param {jQuery} elem
   * @private
   */
  _enableAllTabbableElements: function _enableAllTabbableElements(elem) {
    var elems = $(DataCollectionUtils.enableAllFocusableElements(elem[0])); // mark first and last tabbable element for fast retrieval later

    elems = elems.filter(':visible');
    elems.first().attr('data-first', 'true');
    elems.last().attr('data-last', 'true');
  },

  /**
   * Cleanup any attributes added by tabbing logic
   * @param {Element} elem the element to cleanup
   * @private
   */
  _cleanupTabbableElementProperties: function _cleanupTabbableElementProperties(elem) {
    $(elem).find('[' + DataCollectionUtils._DATA_OJ_TABMOD + ']').removeAttr('tabIndex').removeAttr(DataCollectionUtils._DATA_OJ_TABMOD).removeAttr('data-first').removeAttr('data-last');
  },

  /**
   * Checks whether the element is focusable
   * @param {jQuery} item the item to check
   * @return {boolean} true if the item should not be focusable, false otherwise
   * @protected
   */
  SkipFocus: function SkipFocus(item) {
    return item.hasClass('oj-skipfocus');
  },

  /** ************************************* Event handlers *****************************/

  /**
   * Returns the focus element, or the root element if nothing inside ListView has focus
   * @return {Element} the focus element inside ListView or the root element
   * @protected
   */
  GetFocusElement: function GetFocusElement() {
    if (this.getListContainer().hasClass('oj-focus-ancestor')) {
      // find the focus item
      if (this.m_active) {
        return this.getFocusItem(this.m_active.elem)[0];
      } // empty text could have focus


      var emptyText = this.element.children('.' + this.getEmptyTextStyleClass()).first();

      if (emptyText.length > 0 && emptyText.attr('tabIndex') === 0) {
        return emptyText[0];
      }
    }

    return this.element[0];
  },

  /**
   * Determine whether the event is triggered by interaction with element inside ListView
   * Note that Firefox 48 does not support relatedTarget on blur event, see
   * _supportRelatedTargetOnBlur method
   * @param {Event} event the focus or blur event
   * @return {boolean} true if focus/blur is triggered by interaction with element within listview, false otherwise.
   * @private
   */
  _isFocusBlurTriggeredByDescendent: function _isFocusBlurTriggeredByDescendent(event) {
    if (event.relatedTarget === undefined) {
      return true;
    }

    if (event.relatedTarget == null || !$.contains(this.ojContext.element.get(0),
    /** @type {Element} */
    event.relatedTarget)) {
      return false;
    }

    return true;
  },

  /**
   * Handler for focus event
   * @param {Event} event the focus event
   * @protected
   */
  HandleFocus: function HandleFocus(event) {
    this._clearFocusoutTimeout();

    this._clearFocusoutBusyState();

    this.getListContainer().addClass('oj-focus-ancestor'); // first time tab into listview, focus on first item

    if (this.m_active == null) {
      // checks whether there's pending click to active, and the focus target is not inside any item (if it is the focus will shift to that item) or it's a unfocusable item
      var item = this._findItem($(event.target));

      if (!this.m_preActive && !this._isFocusBlurTriggeredByDescendent(event) && (item == null || this.SkipFocus(item))) {
        this._initFocus(event);
      }
    } else {
      // focus could be caused by pending click to active
      // do not do this on iOS or Android, otherwise VO/talkback will not work correctly
      // Only one exception is when ever root node gets focus we should highlight active element
      // otherwise vo doesn't follow the focus. ex: when offcanvas is opened,
      // focus will be moved to root node
      if (!this.m_preActive && event.target === this.ojContext.element[0] && !this._isFocusBlurTriggeredByDescendent(event)) {
        this.HighlightActive();

        this._focusItem(this.m_active.elem);
      } // remove tab index from root and restore tab index on focus item


      this.RemoveRootElementTabIndex();

      this._setTabIndex(this.m_active.elem);
    }
  },

  /**
   * Initialize focus by finding the first focusable item and set focus on it
   * @private
   */
  _initFocus: function _initFocus(event) {
    var items = this._getItemsCache();

    for (var i = 0; i < items.length; i++) {
      var item = $(items[i]); // make sure item can receive focus

      if (!this.SkipFocus(item)) {
        this.SetCurrentItem(item, event);
        break;
      }
    }

    if (items.length === 0) {
      // we need to focus on empty text
      var emptyText = this.element.children('.' + this.getEmptyTextStyleClass()).first();

      if (emptyText.length > 0) {
        emptyText.attr('tabIndex', 0);
        emptyText.focus();
        this.RemoveRootElementTabIndex();
      }
    }
  },

  /**
   * Handler for focus out event
   * @param {Event} event the focusout event
   * @protected
   */
  HandleFocusOut: function HandleFocusOut(event) {
    this.HandleBlur(event);
  },

  /**
   * Checks whether the browser supports relatedTarget field for blur event
   * @return {boolean} true if supported, false otherwise
   * @private
   */
  _supportRelatedTargetOnBlur: function _supportRelatedTargetOnBlur() {
    var agent = oj.AgentUtils.getAgentInfo();

    if (agent.browser === oj.AgentUtils.BROWSER.FIREFOX && parseInt(agent.browserVersion, 10) < 48) {
      return false;
    }

    return true;
  },

  /**
   * Detects whether this is a double blur event fired by IE11
   * @param {Event} event the blur event
   * @private
   */
  _isExtraBlurEvent: function _isExtraBlurEvent(event) {
    var agent = oj.AgentUtils.getAgentInfo();

    if (event.relatedTarget == null && agent.browser === oj.AgentUtils.BROWSER.IE && event.target === this.ojContext.element.get(0)) {
      return true;
    }

    return false;
  },

  /**
  * Clears any pending focusout timeout.
  * @private
  */
  _clearFocusoutTimeout: function _clearFocusoutTimeout() {
    if (this._focusoutTimeout) {
      clearTimeout(this._focusoutTimeout);
      this._focusoutTimeout = null;
    }
  },

  /**
  * Sets the 'focusout' busy state.
  * @private
  */
  _setFocusoutBusyState: function _setFocusoutBusyState() {
    if (!this._focusoutResolveFunc) {
      this._focusoutResolveFunc = this._addComponentBusyState('is handling focusout.');
    }
  },

  /**
   * Called by component to add a busy state and return the resolve function
   * to call when the busy state can be removed.
   * @param {String} msg the description of the busy state
   * @private
   */
  _addComponentBusyState: function _addComponentBusyState(msg) {
    var busyContext = Context.getContext(this.element[0]).getBusyContext();
    var options = {
      description: "The component identified by '" + this.element[0].id + "' " + msg
    };
    return busyContext.addBusyState(options);
  },

  /**
   * Clears the 'focusout' busy state.
   * @private
   */
  _clearFocusoutBusyState: function _clearFocusoutBusyState() {
    if (this._focusoutResolveFunc) {
      this._focusoutResolveFunc();

      this._focusoutResolveFunc = null;
    }
  },

  /**
   * Handler for blur event
   * @param {Event} event the blur event
   * @protected
   */
  HandleBlur: function HandleBlur(event) {
    this._clearFocusoutTimeout(); // remove focus class on blur of expand/collapse icon


    if (this._isExpandCollapseIcon(event.target)) {
      this._focusOutHandler($(event.target));
    }

    if (this._isActionableMode()) {
      this._setFocusoutBusyState(); // set timeout to stay in editable/actionable mode if focus comes back into the listview


      this._focusoutTimeout = setTimeout(function () {
        // @HTMLUpdateOK
        this._doBlur();

        this._clearFocusoutBusyState();
      }.bind(this), 100); // event.relatedTarget would be null if focus out of page
      // the other check is to make sure the blur is not caused by shifting focus within listview
    } else if (!this._isFocusBlurTriggeredByDescendent(event) && !this.m_preActive) {
      this._doBlur();
    }
  },

  /**
   * @private
   */
  _doBlur: function _doBlur() {
    if (this._isActionableMode()) {
      this._exitActionableMode();
    }

    this.getListContainer().removeClass('oj-focus-ancestor');
    this.UnhighlightActive(); // remove tab index from focus item and restore tab index on list
    // and remove any aria-labelled by set by card navigation

    if (this.m_active != null) {
      this._resetTabIndex(this.m_active.elem);

      this._removeSkipItemAriaLabel(this.m_active.elem);
    } else {
      var emptyText = this.element.children('.' + this.getEmptyTextStyleClass()).first();

      if (emptyText.length > 0) {
        emptyText.removeAttr('tabIndex');
      }
    }

    this.SetRootElementTabIndex();
  },

  /**
   * Event handler for when user exits an item in list
   * @param {Event} event mouseout event
   * @private
   */
  _handleMouseOut: function _handleMouseOut(event) {
    var item = this.FindItem(event.target);

    if (item != null) {
      this.m_hoverItem = null;

      this._unhighlightElem(item, 'oj-hover');
    }
  },

  /**
   * Event handler for when user hovers over list
   * @param {Event} event mouseover event
   * @private
   */
  _handleMouseOver: function _handleMouseOver(event) {
    // do this for real mouse enters, but not 300ms after a tap
    // skip if we are in the middle of dnd
    if (this._recentTouch() || this.m_dndContext && this.m_dndContext.isDndInProgress()) {
      return;
    }

    var item = this.FindItem(event.target);

    if (item != null && !this.SkipFocus(item)) {
      // have to remember it so we can clear it when listview is detached from DOM
      this.m_hoverItem = item;

      this._highlightElem(item, 'oj-hover');
    }
  },
  _recentTouch: function _recentTouch() {
    return Date.now() - this._lastTouch < 500; // must be at least 300 for the "300ms" delay
  },

  /**
   * Event handler for when user press down a key
   * @param {Event} event keydown event
   * @protected
   */
  HandleKeyDown: function HandleKeyDown(event) {
    if (this.isExpandable()) {
      var key = event.key || event.keyCode;

      if (key === 'ArrowLeft' || key === 'Left' || key === this.LEFT_KEY || key === 'ArrowRight' || key === 'Right' || key === this.RIGHT_KEY) {
        var current = this.m_active.elem;

        if (key === 'ArrowLeft' || key === 'Left' || key === this.LEFT_KEY) {
          if (this.GetState(current) === this.STATE_EXPANDED) {
            this.CollapseItem(current, event, true, this.m_active.key, true, true);
            return;
          }
        } else if (this.GetState(current) === this.STATE_COLLAPSED) {
          this.ExpandItem(current, event, true, this.m_active.key, true, true, true);
          return;
        }
      }
    }

    var processed = this.HandleSelectionOrActiveKeyDown(event); // dnd

    if (this.m_dndContext != null) {
      processed = processed || this.m_dndContext.HandleKeyDown(event);
    }

    if (processed === true) {
      event.preventDefault();
    }

    this.m_keyProcessed = processed;
  },

  /**
   * Event handler for whenever press up occurred
   * @param {Event} event keyup event
   * @protected
   */
  HandleKeyUp: function HandleKeyUp(event) {
    // popup process esc key on keyup so we have to stop keyup from bubbling
    var key = event.key || event.keyCode;

    if ((key === 'Escape' || key === 'Esc' || key === this.ESC_KEY) && this.m_keyProcessed) {
      event.stopPropagation();
    }

    this.m_keyProcessed = undefined;
  },

  /**
   * @private
   */
  _handleMouseUpOrPanMove: function _handleMouseUpOrPanMove(event) {
    // unhighlight item that got focus in mousedown
    if (this.m_preActiveItem) {
      this._unhighlightElem(this.m_preActiveItem, 'oj-focus');
    } // dnd


    if (this.m_dndContext != null && this.m_dragger && this.m_dragger.get(0) !== event.target) {
      this.m_dndContext._unsetDraggable(this.m_dragger);

      this.m_dragger = null;
    }
  },

  /**
   * @private
   */
  _isNodeFocusable: function _isNodeFocusable(node) {
    var focusables = ['a', 'input', 'select', 'textarea', 'button', 'object'];

    if (node === null) {
      return false;
    } else if (node.hasAttribute(DataCollectionUtils._DATA_OJ_TABMOD)) {
      return true;
    } else if (focusables.indexOf(node.tagName.toLowerCase()) > -1) {
      return true;
    } else if ($(node).hasClass(this.getItemElementStyleClass())) {
      return false;
    }

    return this._isNodeFocusable(node.parentNode);
  },

  /**
   * Event handler for when mouse down or touch start anywhere in the list
   * @param {Event} event mousedown or touchstart event
   * @protected
   */
  HandleMouseDownOrTouchStart: function HandleMouseDownOrTouchStart(event) {
    // click on item
    var target = $(event.target); // dnd

    if (this.m_dndContext != null) {
      this.m_dndContext._setDraggable(target);

      this.m_dragger = target;
    } // click on item, explicitly pass true on findItem
    // so that it will return non-null value if clickthrough disabled element is encountered


    var item = this._findItem(target, true); // we'll still need to set the flag so that the focus do not shift


    if (item != null && this._isClickthroughDisabled(item)) {
      this.m_preActive = true;
      item = null;
    }

    if (item == null || item.length === 0 || this.SkipFocus(item) || target.hasClass('oj-listview-drag-handle')) {
      // one of the following happened:
      // 1) can't find item
      // 2) item cannot be focus
      // 3) target is an oj-component
      // 4) target or one of its ancestors has the oj-clickthrough-disabled marker class
      // 5) target is the drag handle
      return;
    }

    this.m_preActive = true; // make sure listview has focus

    if (!this.getListContainer().hasClass('oj-focus-ancestor')) {
      this.getListContainer().addClass('oj-focus-ancestor');
    } // we'll need to remove focus in case the actual focus item is different


    this.m_preActiveItem = item; // apply focus

    this._highlightElem(item, 'oj-focus'); // focus on item, we need to do it on mousedown instead of click otherwise click handler will
    // steal focus from popup and causes it to close prematurely


    this._makeFocusable(item); // checks whether focus is already inside some in item, if it is don't try to steal focus away from it (combobox)
    // if target is focusable by itself, don't try to steal focus either
    // if active element is outside of the list, as in the case of things inside popup, don't try to steal focus


    if (this.element[0].contains(document.activeElement) && !item.get(0).contains(document.activeElement) && !this._isNodeFocusable(target[0])) {
      this._focusItem(item);
    } // make sure ul is not tabbable


    this.RemoveRootElementTabIndex(); // reset tab index must be done after focusing another item

    if (this.m_active != null && this.m_active.elem.get(0) !== item.get(0)) {
      this._resetTabIndex(this.m_active.elem);
    } // need this on touchend


    if (event.originalEvent.touches && event.originalEvent.touches.length > 0) {
      this.m_touchPos = {
        x: event.originalEvent.changedTouches[0].pageX,
        y: event.originalEvent.changedTouches[0].pageY
      };
    }
  },

  /**
   * Event handler for when touch end/cancel happened
   * @param {Event} event touchend or touchcancel event
   * @protected
   */
  HandleTouchEndOrCancel: function HandleTouchEndOrCancel(event) {
    var action = 'pointerUp'; // unhighlight item that got focus in touchstart

    if (this.m_preActiveItem != null) {
      this._unhighlightElem(this.m_preActiveItem, 'oj-focus'); // start ripple effect


      if (this.m_touchPos != null) {
        var offset = this.m_preActiveItem.offset(); // find where to start the ripple effect based on touch location

        var effect = this.getAnimationEffect(action);
        effect.offsetX = this.m_touchPos.x - offset.left + 'px';
        effect.offsetY = this.m_touchPos.y - offset.top + 'px';
        var groupItem = this.m_preActiveItem.children('.' + this.getGroupItemStyleClass());
        var elem;

        if (groupItem.length > 0) {
          elem =
          /** @type {Element} */
          groupItem.get(0);
        } else {
          elem =
          /** @type {Element} */
          this.getFocusItem(this.m_preActiveItem).get(0);
        } // don't apply ripple effect on the item when target is one of these controls


        var target = event.target;
        var nodes = elem.querySelectorAll("input, select, button, a, textarea, object, [tabIndex]:not([tabIndex='-1'])");

        for (var i = 0; i < nodes.length; i++) {
          if (nodes[i].contains(target)) {
            elem = target;
            break;
          }
        } // we don't really care when animation ends


        this.StartAnimation(elem, action, effect);
        this.m_touchPos = null;
      }
    } // need this so that on mouse over handler would not apply the styles if the last touch was within the last n ms


    this._lastTouch = Date.now();

    this._handleMouseOut(event);
  },

  /**
   * Enters actionable mode
   * @private
   */
  _enterActionableMode: function _enterActionableMode() {
    var current = this.m_active.elem; // in case content has been updated under the cover

    this.disableAllTabbableElements(current); // re-enable all tabbable elements

    this._enableAllTabbableElements(current); // only go into actionable mode if there is something to focus


    var first = current.find('[data-first]');

    if (first.length > 0) {
      this._setActionableMode(true);
    }
  },

  /**
   * Exits actionable mode
   * @private
   */
  _exitActionableMode: function _exitActionableMode() {
    this._setActionableMode(false); // disable all tabbable elements in the item again


    this.disableAllTabbableElements(this.m_active.elem);
  },

  /**
   * Event handler for when mouse click anywhere in the list
   * @param {Event} event mouseclick event
   * @protected
   */
  HandleMouseClick: function HandleMouseClick(event) {
    // only perform events on left mouse, (right in rtl culture)
    if (event.button === 0) {
      var collapseIconClass = this.getCollapseIconStyleClass();
      var expandIconClass = this.getExpandIconStyleClass();
      var groupItemClass = this.getGroupItemStyleClass();
      var target = $(event.target);

      if (target.hasClass(expandIconClass)) {
        this._collapse(event);

        event.preventDefault();
      } else if (target.hasClass(collapseIconClass)) {
        this._expand(event);

        event.preventDefault();
      } else {
        // click on item
        var item = this._findItem(target);

        if (item == null || item.length === 0 || this.SkipFocus(item)) {
          // one of the following happened:
          // 1) can't find item
          // 2) item cannot be focus
          // 3) target is an oj-component
          // 4) target or one of its ancestors has the oj-clickthrough-disabled marker class
          return;
        }

        if (this._isActionableMode() && this.m_active != null && this.m_active.elem.get(0) !== item.get(0)) {
          // click on item other than current focus item should exit actionable mode
          this._exitActionableMode();
        } // make sure listview has focus


        if (!this.getListContainer().hasClass('oj-focus-ancestor')) {
          this.getListContainer().addClass('oj-focus-ancestor');
        } // check if selection is enabled


        if (this._isSelectionEnabled() && this.IsSelectable(item[0])) {
          var sourceCapabilityTouch = event.originalEvent.sourceCapabilities && event.originalEvent.sourceCapabilities.firesTouchEvents;
          var isTouch = this._isTouchSupport() && (sourceCapabilityTouch || this.touchStartEvent != null && this.touchStartEvent.target === event.target);
          var processed = true;

          if (isTouch) {
            processed = this._handleTouchSelection(item, event);
          } else {
            processed = this.HandleClickSelection(item, event);
          } // if not processed, then we'll still need to make sure it's active


          if (!processed) {
            this.HandleClickActive(item, event);
          } // if user hits the padding part of item, since LI does not have tabindex anymore, item will not get focus


          if (this.ShouldUseGridRole() && event.target === item.get(0)) {
            this._focusItem(item);
          } // need to make sure every item in the selection have the draggable cursor


          if (this._shouldDragSelectedItems()) {
            this.m_dndContext.setSelectionDraggable();
          }
        } else {
          // if selection is disable, we'll still need to highlight the active item
          this.HandleClickActive(item, event);
        } // triger action event


        this._fireActionEvent(item.get(0), event); // click on input element inside item should trigger actionable mode


        if (this._isInputElement(target.get(0))) {
          this._enterActionableMode();

          return;
        } // clicking on header will expand/collapse item


        if (this.isExpandable() && target.closest('.' + groupItemClass)) {
          if (this.GetState(item) === this.STATE_COLLAPSED) {
            this._expand(event);
          } else if (this.GetState(item) === this.STATE_EXPANDED) {
            this._collapse(event);
          }
        }
      }
    }
  },

  /**
   * Fires an item action event
   * @private
   */
  _fireActionEvent: function _fireActionEvent(item, event) {
    if (this._isActionableMode()) {
      return;
    }

    var key = this.GetKey(item);

    var data = this._getDataForItem(item);

    var metadata = this._getMetadataForItem(item);

    var ui = {
      context: {
        key: key,
        data: data,
        metadata: metadata
      }
    };
    this.Trigger('itemAction', event, ui);
  },

  /**
   * Return true if Dnd is supported on selected items only.
   * @private
   * @returns {boolean}
   */
  _shouldDragSelectedItems: function _shouldDragSelectedItems() {
    return this.m_dndContext != null && !this.m_dndContext.shouldDragCurrentItem();
  },

  /** ********************************* end Event handlers *****************************/

  /** ************************************* helper methods *****************************/

  /**
   * Whether touch is supported
   * @return {boolean} true if touch is supported, false otherwise
   * @private
   */
  _isTouchSupport: function _isTouchSupport() {
    return oj.DomUtils.isTouchSupported();
  },

  /**
   * Whether it is non-window touch device (iOS or Android)
   * @return {boolean} true if it is a non-window touch device
   * @private
   */
  _isNonWindowTouch: function _isNonWindowTouch() {
    return this._isTouchSupport() && oj.AgentUtils.getAgentInfo().os !== oj.AgentUtils.OS.WINDOWS;
  },

  /**
   * Returns either the ctrl key or the command key in Mac OS
   * @param {!Object} event
   * @private
   */
  _ctrlEquivalent: function _ctrlEquivalent(event) {
    return oj.DomUtils.isMetaKeyPressed(event);
  },

  /**
   * Helper method to create subid based on the root element's id
   * @param {string} subId the id to append to the root element id
   * @return {string} the subId to append to the root element id
   * @private
   */
  _createSubId: function _createSubId(subId) {
    var id = this.element.attr('id');
    return [id, subId].join(':');
  },

  /**
   * Find the item element
   * @param {jQuery} elem
   * @return {jQuery|null}
   * @protected
   */
  FindItem: function FindItem(elem) {
    if ($(elem).hasClass(this.getGroupStyleClass())) {
      return null;
    }

    return $(elem).closest('.' + this.getItemElementStyleClass());
  },

  /**
   * Determine if click should be processed based on the element.
   * @param {jQuery} elem the element to check
   * @return {boolean} returns true if the element contains the special marker class, false otherwise.
   * @private
   */
  _isClickthroughDisabled: function _isClickthroughDisabled(elem) {
    return elem.hasClass('oj-clickthrough-disabled');
  },

  /**
   * Find the item element from target, if target contains the oj-clickthrough-disabled class then returns null.
   * @param {jQuery} target the element to check
   * @param {boolean=} retElemOnClickthroughDisabled optional, set to true to force non-null value to return when
   *                   clickthrough-disabled is encountered
   * @return {jQuery|null} the item element or null if click through is disabled for this element or one of its ancestors.
   * @private
   */
  _findItem: function _findItem(target, retElemOnClickthroughDisabled) {
    if (target.hasClass(this.getGroupStyleClass())) {
      return null;
    }

    var current = target;

    while (current.length > 0) {
      if (this._isClickthroughDisabled(current)) {
        if (retElemOnClickthroughDisabled) {
          return current;
        }

        return null;
      }

      if (current.hasClass(this.getItemElementStyleClass())) {
        return current;
      }

      current = current.parent();
    }

    return null;
  },

  /**
   * Compute the total top and bottom border width of the list container
   * @return {number} the sum of top and bottom border width of the list container
   * @private
   */
  getListContainerBorderWidth: function getListContainerBorderWidth() {
    if (this.m_borderWidth == null) {
      this.m_borderWidth = parseInt(this.getListContainer().css('border-top-width'), 10) + parseInt(this.getListContainer().css('border-bottom-width'), 10);
    }

    return this.m_borderWidth;
  },

  /**
   * Scroll as needed to make the specified item visible
   * @param {Object} item the item to make visible
   */
  scrollToItem: function scrollToItem(item) {
    var key = item.key;

    if (key == null) {
      return;
    }

    var elem = this.FindElementByKey(key);

    if (elem == null) {
      return;
    }

    if ($(elem).hasClass(this.getItemStyleClass())) {
      this._scrollToVisible(elem);
    } else {
      // group item
      var group = $(elem).children('.' + this.getGroupItemStyleClass()).first();

      this._scrollToGroupHeader(group.get(0));
    }
  },

  /**
   * Scroll as needed to make an element visible in the viewport
   * @param {Element} elem the element to make visible
   * @private
   */
  _scrollToVisible: function _scrollToVisible(elem) {
    var offset = 0;
    var top = elem.offsetTop;
    var height = elem.offsetHeight;
    var container = this.getListContainer()[0];
    var containerScrollTop = container.scrollTop;
    var containerHeight = container.offsetHeight; // if there's sticky header, make sure the elem is not behind it

    if (this.m_groupItemToPin != null) {
      var headerTop = parseInt(this.m_groupItemToPin.style.top, 10);
      var headerHeight = $(this.m_groupItemToPin).outerHeight();

      if (top <= headerTop && headerTop < top + height) {
        offset = (height + top - headerTop) / 2;
      } else if (top >= headerTop && top < headerTop + headerHeight) {
        offset = (headerTop + headerHeight - top) / 2;
      }
    } else if (this.m_closestParent != null) {
      // when native position sticky is used
      var stickyHeader = this.m_closestParent.firstElementChild;

      if (stickyHeader.classList.contains('oj-sticky')) {
        offset = stickyHeader.offsetTop + stickyHeader.offsetHeight - top;
      }
    } // if it's within viewport do nothing


    if (top >= containerScrollTop && top + height <= containerScrollTop + containerHeight) {
      if (offset > 0) {
        container.scrollTop = containerScrollTop - offset;
      }

      return;
    } // how much need to scroll to see the entire element, and to make sure the element top is always visible


    var scrollTop = Math.max(0, Math.min(top - offset, Math.abs(top + height - containerHeight)));

    if (scrollTop > containerScrollTop) {
      scrollTop += this.getListContainerBorderWidth();
    }

    container.scrollTop = scrollTop;
  },

  /**
   * Get the key associated with an item element
   * @param {Element} elem the item element to retrieve the key
   * @return {Object|null} the key associated with the item element
   * @protected
   */
  GetKey: function GetKey(elem) {
    return this.m_contentHandler.GetKey(elem);
  },

  /**
   * Get the element associated with a key
   * @param {Object} key the key to retrieve the item element
   * @return {Element|null} the item element associated with the key
   * @protected
   */
  FindElementByKey: function FindElementByKey(key) {
    if (this.m_keyElemMap != null) {
      var id = this.m_keyElemMap.get(key);

      if (id != null) {
        return document.getElementById(id);
      }
    } // ask the content handler


    if (this.m_contentHandler) {
      return this.m_contentHandler.FindElementByKey(key);
    } // this should not happen


    return null;
  },

  /**
   * Special version of array indexOf to take care of object comparison cases
   * @param {Array} arr the array
   * @param {Object} key the key to find the index for in the array
   * @return {number} the index of the key in the array, or -1 if the key does not exists in the array
   */
  GetIndexOf: function GetIndexOf(arr, key) {
    for (var i = 0; i < arr.length; i++) {
      if (key === arr[i] || oj.Object.compareValues(key, arr[i])) {
        return i;
      }
    }

    return -1;
  },

  /**
   * Checks whether element is an expand/collapse icon
   * @param {Element|jQuery} elem the element to check
   * @return {boolean} true if it's an expand/collapse icon, false otherwise
   */
  _isExpandCollapseIcon: function _isExpandCollapseIcon(elem) {
    return $(elem).hasClass(this.getExpandIconStyleClass()) || $(elem).hasClass(this.getCollapseIconStyleClass());
  },

  /**
   * Determine whether gridlines/dividers should be shown
   * @return {boolean} true if visible, false if hidden
   * @private
   */
  _isGridlinesVisible: function _isGridlinesVisible() {
    if (this.m_gridlinesVisible == null) {
      var gridlines = this.GetOption('gridlines');
      this.m_gridlinesVisible = gridlines.item !== 'hidden';
    }

    return this.m_gridlinesVisible;
  },

  /**
   * Gets the option defaults for top and bottom border/gridline
   * @private
   */
  _isTopBottomGridlinesVisible: function _isTopBottomGridlinesVisible() {
    var defaultOptions = this._getOptionDefaults();

    var defaultGridlines = defaultOptions.gridlines;

    if (defaultGridlines) {
      return {
        top: defaultGridlines.top,
        bottom: defaultGridlines.bottom
      };
    } // like NavList which doesn't have that option defaults


    return {
      top: true,
      bottom: true
    };
  },

  /**
   * Update the style class based on gridline option defaults
   * @private
   */
  _updateGridlines: function _updateGridlines() {
    var gridlines = this._isTopBottomGridlinesVisible();

    var root = this.GetRootElement()[0];
    root.classList.remove('gridline-top-hidden');
    root.classList.remove('gridline-bottom-hidden');

    if (gridlines.top === 'hidden') {
      root.classList.add('gridline-top-hidden');
    }

    if (gridlines.bottom === 'hidden') {
      root.classList.add('gridline-bottom-hidden');
    }
  },

  /**
   * Determine whether ListView needs to render a placeholder to show gridline for the last item
   * @private
   */
  _shouldRenderGridlineForLastItem: function _shouldRenderGridlineForLastItem() {
    var gridlines = this.GetOption('gridlines');

    if (gridlines != null) {
      var topBottomGridlines = this._isTopBottomGridlinesVisible();

      if (gridlines.item === 'visible' && topBottomGridlines.bottom === 'hidden') {
        return true;
      }
    }

    return false;
  },

  /** ********************************** end helper methods *****************************/

  /** ************************************* Navigation Common **************************/

  /**
   * Determine whether the key code is an arrow key
   * @param {string} key
   * @return {boolean} true if it's an arrow key, false otherwise
   * @protected
   */
  IsArrowKey: function IsArrowKey(key) {
    if (this.isCardLayout()) {
      return key === 'ArrowUp' || key === 'Up' || key === this.UP_KEY || key === 'ArrowDown' || key === 'Down' || key === this.DOWN_KEY || key === 'ArrowLeft' || key === 'Left' || key === this.LEFT_KEY || key === 'ArrowRight' || key === 'Right' || key === this.RIGHT_KEY;
    }

    return key === 'ArrowUp' || key === 'Up' || key === this.UP_KEY || key === 'ArrowDown' || key === 'Down' || key === this.DOWN_KEY;
  },

  /**
   * Retrieve the visible (flattened) items cache, create one if it is null.
   * @return {jQuery} a list of items
   * @private
   */
  _getItemsCache: function _getItemsCache() {
    if (this.m_items == null) {
      var disclosureStyleClass = this.getGroupCollapseStyleClass();
      var selector = '.' + this.getItemElementStyleClass() + ':visible';
      this.m_items = this.element.find(selector).filter(function () {
        var isGroup = $(this).parent().hasClass(disclosureStyleClass);

        if (isGroup) {
          return !$(this).parent().parent().hasClass('oj-collapsed');
        }

        return true;
      }).map(function (index, elem) {
        var parentElement = elem.parentElement;

        if (parentElement && parentElement.classList.contains('oj-animate-add')) {
          return parentElement;
        }

        return elem;
      });
    }

    return this.m_items;
  },

  /**
   * Handles when navigate to the last item
   * @param {jQuery} item the item element
   */
  _handleLastItemKeyboardFocus: function _handleLastItemKeyboardFocus(item) {
    var next = item.get(0).nextElementSibling;

    if (next == null || !$(next).hasClass(this.getItemElementStyleClass())) {
      // it could be the last element of the group, if so, make sure it's the last group
      if (this.m_contentHandler.IsHierarchical() && item.parent().hasClass(this.getGroupStyleClass())) {
        if (item.parent().parent().get(0).nextElementSibling != null) {
          // bail if it's not the last group
          return;
        }
      } // it's the last element, check scroll bar to make sure it scrolls all the way to the bottom


      var scroller = this._getScroller();

      var scrollHeight = this._getScrollHeight();

      if (scroller.scrollTop < scrollHeight) {
        scroller.scrollTop = scrollHeight;
      }
    }
  },

  /**
   * Handles arrow keys navigation on item
   * @param {string} key description
   * @param {boolean} isExtend
   * @param {Event} event the DOM event causing the arrow keys
   * @protected
   */
  HandleArrowKeys: function HandleArrowKeys(key, isExtend, event) {
    // ensure that there's no outstanding fetch requests
    if (!this.m_contentHandler.IsReady()) {
      // act as if processed to prevent page scrolling before fetch done
      return true;
    }

    var current;

    if (!isExtend || this.m_isNavigate) {
      current = this.m_active.elem;
    } else {
      current = this.m_selectionFrontier;
    } // invoke different function for handling focusing on active item depending on whether selection is enabled


    var processed = false;

    switch (key) {
      case this.UP_KEY:
      case 'Up':
      case 'ArrowUp':
        if (this.isCardLayout() && $(current).hasClass(this.getItemStyleClass())) {
          this._gotoItemAbove(current, isExtend, event);
        } else {
          this._gotoPrevItem(current, isExtend, event);
        } // according to James we should still consume the event even if list view did not perform any action


        processed = true;
        break;

      case this.DOWN_KEY:
      case 'Down':
      case 'ArrowDown':
        if (this.isCardLayout() && $(current).hasClass(this.getItemStyleClass())) {
          this._gotoItemBelow(current, isExtend, event);
        } else {
          this._gotoNextItem(current, isExtend, event);
        } // according to James we should still consume the event even if list view did not perform any action


        processed = true;
        break;

      case this.LEFT_KEY:
      case 'Left':
      case 'ArrowLeft':
      case this.RIGHT_KEY:
      case 'Right':
      case 'ArrowRight':
        if (this.isCardLayout()) {
          if (this.ojContext._GetReadingDirection() === 'rtl') {
            // eslint-disable-next-line no-param-reassign
            key = key === 'ArrowLeft' || key === 'Left' || key === this.LEFT_KEY ? 'ArrowRight' : 'ArrowLeft';
          }

          if (key === 'ArrowLeft' || key === 'Left' || key === this.LEFT_KEY) {
            this._gotoPrevItem(current, isExtend, event);
          } else {
            this._gotoNextItem(current, isExtend, event);
          }

          processed = true;
        }

        break;

      default:
        break;
    }

    return processed;
  },

  /**
   * Go to the next item in the list
   * @private
   */
  _gotoNextItem: function _gotoNextItem(current, isExtend, event) {
    var items = this._getItemsCache();

    var currentIndex = items.index(current) + 1;

    if (currentIndex < items.length) {
      var next = $(items[currentIndex]); // make sure it's focusable, otherwise find the next focusable item

      while (this.SkipFocus(next)) {
        currentIndex += 1;

        if (currentIndex === items.length) {
          return;
        }

        next = $(items[currentIndex]);
      }

      if (isExtend) {
        this._extendSelection(next, event);

        this.m_isNavigate = false;
      } else {
        this.SetCurrentItem(next, event);
        this.m_isNavigate = true;
      }

      this._handleLastItemKeyboardFocus(next);
    }
  },

  /**
   * Go to the previous item in the list
   * @private
   */
  _gotoPrevItem: function _gotoPrevItem(current, isExtend, event) {
    var items = this._getItemsCache();

    var currentIndex = items.index(current) - 1;

    if (currentIndex >= 0) {
      var prev = $(items[currentIndex]); // make sure it's focusable, otherwise find the next focusable item

      while (this.SkipFocus(prev)) {
        currentIndex -= 1;

        if (currentIndex < 0) {
          return;
        }

        prev = $(items[currentIndex]);
      }

      if (isExtend) {
        this._extendSelection(prev, event);

        this.m_isNavigate = false;
      } else {
        this.SetCurrentItem(prev, event);
        this.m_isNavigate = true;
      }
    }
  },

  /**
   * Calculate the number of the columns in this group
   * @param {jQuery} children the children iterator
   * @return {number} the number of columns
   * @private
   */
  _getColumnCount: function _getColumnCount(children) {
    var count;
    var currentOffsetTop;
    children.each(function (index) {
      var offsetTop = this.offsetTop;

      if (currentOffsetTop === undefined) {
        currentOffsetTop = offsetTop;
      } else if (currentOffsetTop !== offsetTop) {
        // on a different row, return immediately
        return false;
      }

      count = index;
      return undefined;
    });
    return count + 1;
  },

  /**
   * Inform screen reader that X number of items have been skipped during up/down arrow key navigation
   * @param {jQuery} next the item to navigate to
   * @param {number} count number of items skipped
   * @private
   */
  _updateSkipItemAriaLabel: function _updateSkipItemAriaLabel(next, count) {
    var id = this._createSubId('extra_info');

    if (this.m_skipAriaLabelText == null) {
      var root = $(document.createElement('div'));
      root.addClass('oj-helper-hidden-accessible').attr('id', id);
      this.getListContainer().append(root); // @HTMLUpdateOK

      this.m_skipAriaLabelText = root;
    }

    this.m_skipAriaLabelText.text(this.ojContext.getTranslatedString('accessibleNavigateSkipItems', {
      numSkip: count
    }));
    var focusElem = this.getFocusItem(next); // make sure it has an id for aria-labelledby

    focusElem.uniqueId().attr('aria-labelledby', id + ' ' + focusElem.prop('id'));
  },

  /**
   * Undo what _updateSkipItemAriaLabel did to active element
   * @param {jQuery} current the item to remove aria property from
   * @private
   */
  _removeSkipItemAriaLabel: function _removeSkipItemAriaLabel(current) {
    var focusElem = this.getFocusItem(current);

    if (focusElem.length > 0) {
      focusElem.get(0).removeAttribute('aria-labelledby');
    }
  },

  /**
   * Go to the item above the current item in the list
   * @private
   */
  _gotoItemAbove: function _gotoItemAbove(current, isExtend, event) {
    var above;
    var numOfItemSkip; // if it's a group, just go to the previous item (which would be the last focusable item in the previous group)

    if (!current.hasClass(this.getItemElementStyleClass())) {
      this._gotoPrevItem(current);

      return;
    }

    var parent = current.parent();
    var items = parent.children('li.' + this.getItemElementStyleClass());

    var numOfCols = this._getColumnCount(items);

    var index = items.index(current);
    var aboveIndex = index - numOfCols;

    if (aboveIndex < 0) {
      // go to header, or stop if there's no header
      if (parent.hasClass(this.getGroupStyleClass()) && parent.parent().hasClass(this.getItemElementStyleClass())) {
        above = parent.parent();
        numOfItemSkip = index;
      }
    } else {
      above = $(items.get(aboveIndex));
      numOfItemSkip = numOfCols - 1;
    }

    if (above && above.length > 0) {
      // make sure it's focusable, otherwise no-op
      if (this.SkipFocus(above)) {
        return;
      }

      if (isExtend) {
        this._extendSelection(above, event);

        this.m_isNavigate = false;
      } else {
        if (numOfItemSkip != null && numOfItemSkip > 0) {
          this._updateSkipItemAriaLabel(above, numOfItemSkip);
        }

        this.SetCurrentItem(above, event);
        this.m_isNavigate = true;
      }
    }
  },

  /**
   * Go to the item below the current item in the list
   * @private
   */
  _gotoItemBelow: function _gotoItemBelow(current, isExtend, event) {
    var below;
    var numOfItemSkip; // if it's a group, just go to the next item (which would be the first focusable item in the next group)

    if (!current.hasClass(this.getItemElementStyleClass())) {
      this._gotoNextItem(current);

      return;
    }

    var parent = current.parent();
    var items = parent.children('li.' + this.getItemElementStyleClass());

    var numOfCols = this._getColumnCount(items);

    var index = items.index(current);
    var belowIndex = index + numOfCols;

    if (belowIndex >= items.length) {
      var numOfRows = Math.ceil(items.length / numOfCols);
      numOfItemSkip = items.length - 1 - index; // if the current item is not on the last row, then go to the last item within group

      if (index < Math.max(0, (numOfRows - 1) * numOfCols)) {
        below = items.last(); // skip one less since going to an item within the same group

        numOfItemSkip -= 1;
      } else if (parent.hasClass(this.getGroupStyleClass())) {
        // go to header, or stop if there's no header
        below = parent.parent().next('li.' + this.getItemElementStyleClass());
      }
    } else {
      below = $(items.get(belowIndex));
      numOfItemSkip = numOfCols - 1;
    }

    if (below.length > 0) {
      // make sure it's focusable, otherwise no-op
      if (this.SkipFocus(below)) {
        return;
      }

      if (isExtend) {
        this._extendSelection(below, event);

        this.m_isNavigate = false;
      } else {
        if (numOfItemSkip != null && numOfItemSkip > 0) {
          this._updateSkipItemAriaLabel(below, numOfItemSkip);
        }

        this.SetCurrentItem(below, event);
        this.m_isNavigate = true;
      }

      this._handleLastItemKeyboardFocus(below);
    }
  },

  /**
   * Determine if the data grid is in actionable mode.
   * @return {boolean} true if the data grid is in actionable mode, false otherwise.
   * @private
   */
  _isActionableMode: function _isActionableMode() {
    return this.m_keyMode === 'actionable';
  },

  /**
   * Sets whether the data grid is in actionable mode
   * @param {boolean} flag true to set grid to actionable mode, false otherwise
   * @param {boolean=} skipFocus true if focus should not shift, if not defined then default to false
   * @private
   */
  _setActionableMode: function _setActionableMode(flag, skipFocus) {
    this.m_keyMode = flag ? 'actionable' : 'navigation';

    if (!flag && !skipFocus) {
      // focus should be shift back to active descendant container
      this.element[0].focus();
    }
  },

  /** ********************************** end Navigation Common **************************/

  /** ********************************** Active item ******************************/

  /**
   * Retrieve the focus element
   * @param {jQuery} item the list item
   * @return {jQuery} the focus element
   * @private
   */
  getFocusItem: function getFocusItem(item) {
    if (!item.hasClass(this.getFocusedElementStyleClass())) {
      return $(item.find('.' + this.getFocusedElementStyleClass()).first());
    }

    if (this.ShouldUseGridRole() && item.attr('role') === 'row') {
      var cell = item.children('.oj-listview-cell-element').first();
      return cell.length === 0 ? item.children().first() : cell;
    }

    return item;
  },

  /**
   * Sets the tab index attribute of the root element
   * To be change by NavList
   * @protected
   */
  SetRootElementTabIndex: function SetRootElementTabIndex() {
    if (this._isComponentFocusable()) {
      this.element.attr('tabIndex', 0);
    }
  },

  /**
   * Removes the tab index attribute of the root element
   * To be change by NavList
   * @protected
   */
  RemoveRootElementTabIndex: function RemoveRootElementTabIndex() {
    this.element.removeAttr('tabIndex');
  },

  /**
   * Whether application has mark the component as not focusable in the first place
   * @private
   */
  _isComponentFocusable: function _isComponentFocusable() {
    var root = this.ojContext._IsCustomElement() ? this.GetRootElement() : this.element;
    return this._rootTabIndexSet || parseInt(root.attr('tabIndex'), 10) !== -1;
  },

  /**
   * Sets the tab index on focus item
   * @param {jQuery} item the focus item
   * @private
   */
  _setTabIndex: function _setTabIndex(item) {
    // note that page author should not set any tabindex on the item
    if (this._isComponentFocusable()) {
      this.getFocusItem(item).attr('tabIndex', 0);
    }
  },

  /**
   * Resets the tab index set on focus item
   * @param {jQuery} item the focus item
   * @private
   */
  _resetTabIndex: function _resetTabIndex(item) {
    var removeAttr = true;

    if (item.attr('role') === 'presentation') {
      removeAttr = false;
    }

    var focusItem = this.getFocusItem(item);

    if (removeAttr) {
      focusItem.removeAttr('tabIndex');
    } else {
      focusItem.attr('tabIndex', -1);
    }
  },

  /**
   * Make an item focusable
   * @param {jQuery} item the item to focus
   * @private
   */
  _makeFocusable: function _makeFocusable(item) {
    this._setTabIndex(item);
  },

  /**
   * Determine the only focusable element inside an item, if the item does not have any or have
   * more than one focusable element, then just return the item.
   * @param {jQuery} item the list item
   * @return {jQuery} see above for what's get returned
   * @private
   */
  getSingleFocusableElement: function getSingleFocusableElement(item) {
    var selector = 'a, input, select, textarea, button';
    var childElements = item.children(selector);

    if (childElements.length === 1 && // check for only one focusbale child
    childElements.first().find(selector).length === 0) {
      // check to ensure no nested focusable elements.
      return childElements.first();
    }

    return item;
  },

  /**
   * Sets the selection option with a new value
   * @param {Object} newValue the new value for selection option
   * @param {Event|null} event the DOM event
   * @param {Element} currentElem the current item DOM element
   * @private
   */
  _setCurrentItemOption: function _setCurrentItemOption(newValue, event, currentElem) {
    var extra = {
      item: this.ojContext._IsCustomElement() ? currentElem : $(currentElem)
    };
    this.SetOption('currentItem', newValue, {
      _context: {
        originalEvent: event,
        internalSet: true,
        extraData: extra
      },
      changed: true
    });
  },

  /**
   * Sets the active item
   * @param {jQuery} item the item to set as active
   * @param {Event} event the event that triggers set active
   * @param {boolean=} skipFocus true if to skip focusing the item
   * @return {boolean} true if item becomes active, false for all other cases
   * @private
   */
  _setActive: function _setActive(item, event, skipFocus) {
    var active; // set key info

    if (item != null) {
      var elem = item[0];
      var key = this.GetKey(elem);

      if (this.m_active == null || key !== this.m_active.key) {
        // fire beforecurrentItem
        var ui = {
          key: key,
          item: item
        };

        if (this.m_active != null) {
          ui.previousKey = this.m_active.key;
          ui.previousItem = this.m_active.elem; // for touch, remove draggable when active item changed

          if (this._shouldDragSelectedItems() && this._isTouchSupport()) {
            this.m_dndContext._unsetDraggable(ui.previousItem);
          } // remove aria-labelledby set by arrow key navigation


          this._removeSkipItemAriaLabel(ui.previousItem);
        }

        var cancelled = !this.Trigger('beforeCurrentItem', event, ui);

        if (cancelled) {
          return false;
        }

        active = {
          key: key,
          elem: item
        };
        this.m_active = active; // for touch, set draggable when item becomes active

        if (this._shouldDragSelectedItems() && this._isTouchSupport()) {
          this.m_dndContext._setDraggable(item);
        } // update tab index


        if (skipFocus === undefined || !skipFocus) {
          // make item focusable
          this._makeFocusable(item); // style should be updated before currentItem change event is fired


          this.HighlightActive(); // focus on it only for non-click events or when done programmatically
          // the issue is we can't shift focus on click since it will steal focus from the popups
          // the focusing on item is done already on mousedown

          if (event == null || event.originalEvent && event.originalEvent.type !== 'click') {
            this._focusItem(item);
          } // reset tabindex of previous focus item, note this has to be done after focusing on a new item
          // because in Chrome 57, resetting tabindex on a focus item will cause a blur event
          // note also it seems this only happens when removing tabindex, if you set it to -1 this does not happen


          this.RemoveRootElementTabIndex();

          if (ui.previousItem) {
            this._resetTabIndex(ui.previousItem);
          }
        }

        return true;
      } else if (key === this.m_active.key) {
        active = {
          key: key,
          elem: item
        };
        this.m_active = active; // update tab index

        if (skipFocus === undefined || !skipFocus) {
          this._makeFocusable(item); // make sure ul is not tabbable


          this.RemoveRootElementTabIndex();
        }
      }
    } else {
      // item is null, just clears the current values
      this.m_active = null;
    }

    return false;
  },

  /**
   * Put browser focus on item (or children of item)
   * @private
   */
  _focusItem: function _focusItem(item) {
    this.getFocusItem(item).focus();
  },

  /**
   * Highlight active element
   * @protected
   */
  HighlightActive: function HighlightActive() {
    // don't highlight and focus item if ancestor does not have focus
    if (this.m_active != null && this.getListContainer().hasClass('oj-focus-ancestor')) {
      var item = this.m_active.elem;

      this._highlightElem(item, 'oj-focus');
    }
  },

  /**
   * Unhighlight the active index, and turn the active index to selected instead if selectActive is true.
   * @protected
   */
  UnhighlightActive: function UnhighlightActive() {
    if (this.m_active != null) {
      this._unhighlightElem(this.m_active.elem, 'oj-focus');
    }
  },
  HandleClickActive: function HandleClickActive(item, event) {
    // if click is triggered by target inside the active item, then do nothing
    var active = this.m_active != null ? this.m_active.elem.get(0) : null; // if it's a group, use the group header div instead otherwise active.contains check will not be valid

    if (active != null && !$(active).hasClass(this.getItemStyleClass())) {
      active = active.firstElementChild;
    }

    if (event != null && active != null && active !== event.target && active.contains(event.target)) {
      return;
    }

    this.SetCurrentItem(item, event, this.ShouldUseGridRole() ? event.target !== item.get(0) : true);
  },

  /**
   * Sets the active item and bring focus to it.  Update the currentItem option.
   * @protected
   */
  SetCurrentItem: function SetCurrentItem(item, event, skipFocus) {
    var proceed = this.ActiveAndFocus(item, event, skipFocus);

    if (proceed) {
      this._setCurrentItemOption(this.GetKey(item[0]), event, item.get(0));
    }
  },

  /**
   * Sets the active item and bring focus to it.
   * @protected
   */
  ActiveAndFocus: function ActiveAndFocus(item, event, skipFocus) {
    // make sure that it is visible
    this._scrollToVisible(item[0]); // unhighlight any previous active item


    this.UnhighlightActive(); // update active and frontier

    var proceed = this._setActive(item, event, skipFocus); // highlight active


    this.HighlightActive();
    return proceed;
  },

  /** ********************************** end Active item ******************************/

  /** *********************************** Selection ***********************************************/

  /**
   * If selection is enabled and at least one item has to be selected, then
   * make sure the first selectable item is selected in the list.
   */
  enforceSelectionRequired: function enforceSelectionRequired() {
    if (this._isSelectionEnabled() && this._isSelectionRequired()) {
      var selection = this.GetOption('selection');

      if (selection == null || selection.length === 0 && selection.inverted !== true) {
        this._selectFirstSelectableItem();
      }
    }
  },

  /**
   * Returns the first selectable item in the list.
   * @private
   */
  _getFirstSelectableItem: function _getFirstSelectableItem() {
    // currently, an item will have the aria-selected attribute defined only if it's selectable
    // so we are using that here to find all selectable items.
    var elem = this.element[0].querySelector('.oj-listview-cell-element[aria-selected]');
    return elem == null ? null : elem.parentNode;
  },

  /**
   * Selects the first selectable item
   * @private
   */
  _selectFirstSelectableItem: function _selectFirstSelectableItem() {
    var item = this._getFirstSelectableItem(); // select the item if found


    if (item) {
      var key = this.m_contentHandler.GetKey(item);

      if (key != null) {
        this._applySelection(item, key);

        var selected = this.GetOption('selected');

        this._setSelectionOption(selected.clear().add([key]), null, [item]);
      }
    }
  },

  /**
   * Check if selection enabled by options on the list
   * @return {boolean} true if selection enabled
   * @private
   */
  _isSelectionEnabled: function _isSelectionEnabled() {
    return this.GetOption('selectionMode') !== 'none';
  },

  /**
   * Check if there should be at least one item selected in the list
   * @return {boolean} true if selection is required
   * @private
   */
  _isSelectionRequired: function _isSelectionRequired() {
    return this.GetOption('selectionRequired');
  },

  /**
   * Check whether multiple selection is allowed by options on the list
   * @return {boolean} true if multiple selection enabled
   * @private
   */
  _isMultipleSelection: function _isMultipleSelection() {
    return this.GetOption('selectionMode') === 'multiple';
  },

  /**
   * Check whether the item is selectable
   * @param {Element} item the item element
   * @return {boolean} true if item is selectable
   * @protected
   */
  IsSelectable: function IsSelectable(item) {
    var focusItem = this.getFocusItem($(item)).get(0);
    return focusItem.hasAttribute('aria-selected');
  },

  /**
   * Convert selection as an iterable to an array of selection.
   * We used to remove any items that are not selectable, or if there are more than one items
   * when selectionMode is single, but not anymore.
   * @param {Array|Set} selection array of selected items
   * @return {Array} array of items
   * @private
   */
  _cloneSelection: function _cloneSelection(selection) {
    var arr = []; // Array.from is not supported in IE11 and we do not have the polyfill

    selection.forEach(function (key) {
      arr.push(key);
    });
    return arr;
  },

  /**
   * Sets the selection option with a new value
   * @param {Object} newValue the new value for selection option
   * @param {Event|null} event the DOM event
   * @param {Array.<Element>=} selectedElems an array of DOM Elements
   * @param {any=} firstSelectedItemData the data for first selected item
   * @private
   */
  _setSelectionOption: function _setSelectionOption(newValue, event, selectedElems, firstSelectedItemData) {
    var value = {
      key: null,
      data: null
    };
    var selection = KeySet.KeySetUtils.toArray(newValue); // check if the value has actually changed, based on key
    // firstSelectedItem should never be null and should always have 'key'

    var firstSelectedItem = this.GetOption('firstSelectedItem'); // NavList firstSelectedItem would be undefined

    if (firstSelectedItem != null) {
      // first condition is if new value is empty and existing item is non null
      // second condition is if new value is not empty and does not match the existing item
      if (selection.length === 0 && firstSelectedItem.key != null || !(selection[0] === firstSelectedItem.key || oj.Object.compareValues(selection[0], firstSelectedItem.key))) {
        // update firstSelectedItem also
        if (selection.length > 0) {
          value = {
            key: selection[0],
            data: firstSelectedItemData != null ? firstSelectedItemData : this.getDataForVisibleItem({
              key: selection[0]
            })
          };
        }

        this.SetOption('firstSelectedItem', value, {
          _context: {
            originalEvent: event,
            internalSet: true
          },
          changed: true
        });
      } else if (firstSelectedItem.data === undefined) {
        firstSelectedItem.data = firstSelectedItemData;
        value = {
          key: firstSelectedItem.key,
          data: firstSelectedItemData
        };
        this.SetOption('firstSelectedItem', value, {
          _context: {
            originalEvent: null,
            internalSet: true
          },
          changed: true
        });
      }
    }

    var items;

    if (this.ojContext._IsCustomElement()) {
      items = selectedElems;
    } else if (selectedElems == null) {
      items = $({});
    } else {
      items = $(selectedElems);
    }

    var extra = {
      items: items
    };
    this.SetOption('selected', newValue, {
      _context: {
        originalEvent: event,
        internalSet: true,
        extraData: extra
      },
      changed: true
    }); // update legacy selection last

    this.SetOption('selection', selection, {
      _context: {
        originalEvent: event,
        internalSet: true,
        extraData: extra
      },
      changed: true
    });
  },

  /**
   * Unhighlights the selection.  Does not change selection, focus, anchor, or frontier
   * @private
   */
  _unhighlightSelection: function _unhighlightSelection() {
    if (this.m_keyElemMap == null) {
      return;
    }

    var self = this;
    var selected = this.GetOption('selected');

    if (selected.isAddAll()) {
      var items = this._getItemsCache();

      for (var i = 0; i < items.length; i++) {
        self._unhighlightElem(items[i], 'oj-selected');
      }
    } else {
      selected.values().forEach(function (key) {
        var elem = self.FindElementByKey(key);

        if (elem != null) {
          self._unhighlightElem(elem, 'oj-selected');
        }
      });
    }
  },
  _highlightElem: function _highlightElem(elem, style) {
    this.HighlightUnhighlightElem(elem, style, true);
  },
  _unhighlightElem: function _unhighlightElem(elem, style) {
    this.HighlightUnhighlightElem(elem, style, false);
  },

  /**
   * Highlight or unhighlight an element
   * @param {jQuery|Element} elem the element the highlight or unhighlight
   * @param {string} style the style to add or remove
   * @param {boolean} highlight true if it's to highlight, false if it's to unhighlight
   * @protected
   */
  HighlightUnhighlightElem: function HighlightUnhighlightElem(elem, style, highlight) {
    var $elem = $(elem);

    if (style === 'oj-selected') {
      this.getFocusItem($elem).attr('aria-selected', highlight ? 'true' : 'false');
    } // if item is a group, the highlight should be apply to the group item element


    var group = $elem.children('.' + this.getGroupItemStyleClass());

    if (group.length > 0) {
      $elem = $(group[0]);
    }

    if (style === 'oj-focus') {
      if (highlight) {
        // don't apply focus ring on item if we are in actionable mode
        if (this.m_keyMode !== 'actionable') {
          this._focusInHandler($elem);
        }
      } else {
        this._focusOutHandler($elem);
      }
    } else if (highlight) {
      $elem.addClass(style);
    } else {
      $elem.removeClass(style);
    }
  },

  /**
   * Handles click to select multiple cells/rows
   * @param {jQuery} item the item clicked on
   * @param {Event} event the click event
   * @protected
   */
  HandleClickSelection: function HandleClickSelection(item, event) {
    // make sure that it is visible
    this._scrollToVisible(item[0]);

    var ctrlKey = this._ctrlEquivalent(event);

    var shiftKey = event.shiftKey;
    var processed = true;

    if (this._isMultipleSelection()) {
      if (!ctrlKey && !shiftKey) {
        processed = this.SelectAndFocus(item, event);
      } else if (!ctrlKey && shiftKey) {
        // active item doesn't change in this case
        processed = this._extendSelection(item, event);
      } else {
        // processed is always true in this case
        this._augmentSelectionAndFocus(item, event);
      }
    } else {
      processed = this.SelectAndFocus(item, event);
    }

    return processed;
  },

  /**
   * Handles tap to select multiple cells/rows
   * @param {jQuery} item the item clicked on
   * @param {Event} event the click event
   * @private
   */
  _handleTouchSelection: function _handleTouchSelection(item, event) {
    var processed = true;

    if (this._isMultipleSelection()) {
      if (event.shiftKey) {
        // for touch device with keyboard support
        processed = this._extendSelection(item, event);
      } else {
        // treat this as like ctrl+click
        this._augmentSelectionAndFocus(item, event);
      }
    } else {
      processed = this.SelectAndFocus(item, event);
    }

    return processed;
  },

  /**
   * Clear the current selection.
   * @param {boolean} updateOption true if the underlying selection option should be updated, false otherwise.
   * @param {jQuery=} newSelectionFrontier new value to set the selection frontier. If none specified, set to null
   * @private
   */
  _clearSelection: function _clearSelection(updateOption, newSelectionFrontier) {
    // unhighlight previous selection
    this._unhighlightSelection();

    if (updateOption) {
      // if the intend is to empty selection option, we have to make sure if
      // selectionRequired is set to true that something is selected
      if (this._isSelectionRequired()) {
        this._selectFirstSelectableItem();
      } else {
        var selected = this.GetOption('selected');
        selected = selected.clear();

        this._setSelectionOption(selected, null, null);
      }
    } // clear selection frontier also


    this.m_selectionFrontier = newSelectionFrontier === undefined ? null : newSelectionFrontier;
  },

  /**
   * Selects the focus on the specified element
   * Select and focus is an asynchronus call
   * @param {jQuery} item the item clicked on
   * @param {Event} event the click event
   * @protected
   */
  SelectAndFocus: function SelectAndFocus(item, event) {
    var key = this.GetKey(item[0]);
    var selected = this.GetOption('selected');
    var exists = selected.has(key); // check if there's only one item selected and selection is required

    if (exists && selected.values && selected.values().size === 1 && this._isSelectionRequired()) {
      return false;
    } // if it's already selected, deselect it and update options


    this._clearSelection(exists);

    if (!exists) {
      // add the elem to selection
      this._augmentSelectionAndFocus(item, event, selected.clear());
    }

    return true;
  },

  /**
   * Shift+click to extend the selection
   * @param {jQuery} item the item to extend selection to
   * @param {Event} event the key event
   * @private
   */
  _extendSelection: function _extendSelection(item, event) {
    if (this.m_active == null) {
      return false;
    } // checks if selection has changed


    var current = this.m_selectionFrontier;

    if (current === item) {
      return false;
    } // remove focus style on the item click on


    this._unhighlightElem(item, 'oj-focus');

    this._extendSelectionRange(this.m_active.elem, item, event);

    return true;
  },

  /**
   * Extend the selection
   * @param {jQuery} from the item to extend selection from
   * @param {jQuery} to the item to extend selection to
   * @param {Event} event the event that triggers extend
   * @param {boolean=} keepSelectionFrontier true if we don't want to modify the selectionFrontier
   * @private
   */
  _extendSelectionRange: function _extendSelectionRange(from, to, event, keepSelectionFrontier) {
    if (keepSelectionFrontier === true) {
      // clear selection as we'll be just re-highlight the entire range
      this._clearSelection(false, this.m_selectionFrontier);
    } else {
      this._clearSelection(false, to);
    } // highlights the items between active item and new item


    this._highlightRange(from, to, event);

    this.HighlightActive(); // make sure that it is visible

    this._scrollToVisible(to[0]);
  },

  /**
   * Highlight the specified range
   * @param {jQuery} start the start of the range
   * @param {jQuery} end the end of the range
   * @param {Event} event the event that triggers the highlight
   * @private
   */
  _highlightRange: function _highlightRange(start, end, event) {
    var from;
    var to;
    var selected = this.GetOption('selected').clear();
    var selectedItems = [];

    var items = this._getItemsCache();

    var startIndex = items.index(start);
    var endIndex = items.index(end);

    if (startIndex > endIndex) {
      from = endIndex;
      to = startIndex;
    } else {
      from = startIndex;
      to = endIndex;
    } // exclude start and include end


    for (var i = from; i <= to; i++) {
      var item = items[i];

      if (this.IsSelectable(item)) {
        var key = this.m_contentHandler.GetKey(item);

        this._applySelection(item, key);

        selected = selected.add([key]);
        selectedItems.push(item);
      }
    } // trigger the optionChange event


    this._setSelectionOption(selected, event, selectedItems);
  },

  /**
   * Apply selection to the element
   * @param {jQuery|Element} element the item to apply selection
   * @param {Object} key the key of the item
   * @private
   */
  _applySelection: function _applySelection(element, key) {
    // update map that keeps track of key->element
    if (this.m_keyElemMap == null) {
      this.m_keyElemMap = this.m_contentHandler.createKeyMap();
    }

    this.m_keyElemMap.set(key, $(element).attr('id')); // highlight selection

    this._highlightElem(element, 'oj-selected');
  },

  /**
   * Ctrl+click to add item to the current selection
   * @param {jQuery} item the item to augment selection to
   * @param {Event} event the event that triggers the selection
   * @param {KeySet=} selected the optional selection to augment, if not specified, use current selection
   * @private
   */
  _augmentSelectionAndFocus: function _augmentSelectionAndFocus(item, event, selected) {
    var active = item;
    var key = this.GetKey(item[0]);

    if (selected == null) {
      // eslint-disable-next-line no-param-reassign
      selected = this.GetOption('selected');
    } // update active only if target is not inside the active item


    var currentActive = this.m_active != null ? this.m_active.elem.get(0) : null; // if it's a group, use the group header div instead otherwise currentActive.contains check will not be valid

    if (currentActive != null && !$(currentActive).hasClass(this.getItemStyleClass())) {
      currentActive = currentActive.firstElementChild;
    }

    if (event != null && (currentActive == null || currentActive === event.target || !currentActive.contains(event.target))) {
      this.UnhighlightActive(); // update active cell and frontier

      var proceed = this._setActive(active, event);

      if (proceed) {
        // update current option
        this._setCurrentItemOption(key, event, active.get(0));
      } // highlight index


      this.HighlightActive();
    } // checks if setActive was successful


    currentActive = this.m_active != null ? this.m_active.elem.get(0) : null;

    if (currentActive == null || currentActive !== active.get(0)) {
      // update selection if it was cleared
      if (selected != null && selected.values().size === 0) {
        this._setSelectionOption(selected, event, []);
      }

      return;
    }

    if (selected.has(key)) {
      if (selected.values && selected.values().size === 1 && this._isSelectionRequired()) {
        // only one selected item and selection is required, do nothing
        return;
      } // it was selected, deselect it


      this._unhighlightElem(item, 'oj-selected'); // eslint-disable-next-line no-param-reassign


      selected = selected.delete([key]);
    } else {
      this.m_selectionFrontier = item;

      this._applySelection(item, key); // eslint-disable-next-line no-param-reassign


      selected = selected.add([key]);
    }

    var selectedItems = [];

    if (selected.values) {
      selected.values().forEach(function (aKey) {
        selectedItems.push(this.FindElementByKey(aKey));
      }, this);
    } // trigger option change


    this._setSelectionOption(selected, event, selectedItems);
  },

  /**
   * Toggle selection of an item.  If an item was selected, it deselects it.  If an item was not selected, it selects it.
   * @param {Event} event the event that triggers the selection
   * @param {boolean} keepCurrentSelection true if selecting an item would not deselect other selected items, false otherwise
   * @param {boolean} skipIfNotSelected true if an selected item should not be deselected, false otherwise
   * @protected
   */
  ToggleSelection: function ToggleSelection(event, keepCurrentSelection, skipIfNotSelected) {
    // if it's currently selected, deselect it
    var selected = this.GetOption('selected');
    var item = this.m_active.elem;
    var key = this.m_active.key;

    if (selected.has(key)) {
      // do not deselect the item if it's the last selected item and selection is required
      if (skipIfNotSelected || selected.values().size === 1 && this._isSelectionRequired()) {
        return;
      } // it was selected, deselect it


      this._unhighlightElem(item, 'oj-selected');

      selected = selected.delete([key]);

      if (selected.values().size === 0) {
        this.m_selectionFrontier = null;
      }
    } else if (this.IsSelectable(item[0])) {
      // deselect any selected items
      if (!keepCurrentSelection) {
        this._clearSelection(false);

        selected = selected.clear();
      }

      this.m_selectionFrontier = item; // select current item

      this._applySelection(item, key);

      selected = selected.add([key]);
    }

    var selectedItems = [];
    selected.values().forEach(function (aKey) {
      selectedItems.push(this.FindElementByKey(aKey));
    }, this); // trigger option change

    this._setSelectionOption(selected, event, selectedItems);
  },

  /**
   * Checks whether the element is an input element.
   * @param {Element} elem the element to check
   * @return {boolean} true if it's input, false otherwise
   * @private
   */
  _isInputElement: function _isInputElement(elem) {
    var inputRegExp = /^INPUT|SELECT|OPTION|TEXTAREA/;
    return elem.nodeName.match(inputRegExp) != null && !elem.readOnly;
  },

  /**
   * Handles key event for selection or active
   * @param {Event} event
   * @return {boolean} true if the event is processed
   * @protected
   */
  HandleSelectionOrActiveKeyDown: function HandleSelectionOrActiveKeyDown(event) {
    var ctrlKey;
    var shiftKey;
    var processed = false;
    var first; // this could happen if nothing in the list is focusable
    // or if the key is handled by a descendant already and explicitly do not want parent to handle

    if (this.m_active == null || event.isDefaultPrevented()) {
      return false;
    }

    var key = event.key || event.keyCode;
    var current = this.m_active.elem;

    if (this._isActionableMode()) {
      // Esc key goes to navigation mode
      if (key === 'Escape' || key === 'Esc' || key === this.ESC_KEY) {
        this._exitActionableMode(); // force focus back on the active cell


        this.HighlightActive();

        this._focusItem(current); // make sure active item has tabindex set


        this._setTabIndex(current);

        processed = true;
      } else if (key === 'Tab' || key === this.TAB_KEY) {
        var focusElem = this.getFocusItem(current).get(0);

        if (event.shiftKey) {
          processed = DataCollectionUtils.handleActionablePrevTab(event, focusElem);
        } else {
          processed = DataCollectionUtils.handleActionableTab(event, focusElem);
        }

        if (!event.shiftKey && processed || event.shiftKey && !processed) {
          var firstFocuasble = DataCollectionUtils.getFocusableElementsInNode(focusElem)[0];

          if (firstFocuasble && this._isExpandCollapseIcon(firstFocuasble)) {
            this._focusInHandler($(firstFocuasble));
          }
        } // otherwise don't process and let browser handles tab

      }
    } else if (key === 'F2' || key === this.F2_KEY) {
      // F2 key goes to actionable mode
      this._enterActionableMode(); // focus on first focusable item in the cell


      first = current.find('[data-first]');

      if (first.length > 0) {
        first[0].focus();

        if (this._isExpandCollapseIcon(first)) {
          this._focusInHandler(first);
        } // check if it's group item


        if (!current.hasClass(this.getItemStyleClass())) {
          current = current.children('.' + this.getGroupItemStyleClass()).first();
        }

        current.removeClass('oj-focus-highlight');
      }
    } else if ((key === ' ' || key === 'Spacebar' || key === this.SPACE_KEY) && this._isSelectionEnabled()) {
      ctrlKey = this._ctrlEquivalent(event);
      shiftKey = event.shiftKey;

      if (shiftKey && !ctrlKey && this.m_selectionFrontier != null && this._isMultipleSelection()) {
        // selects contiguous items from last selected item to current item
        this._extendSelectionRange(this.m_selectionFrontier, this.m_active.elem, event, true);
      } else {
        // toggle selection, deselect previous selected items
        this.ToggleSelection(event, ctrlKey && !shiftKey && this._isMultipleSelection(), false);
      }

      processed = true;
    } else if (key === 'Enter' || key === this.ENTER_KEY) {
      if (this._isSelectionEnabled()) {
        // selects it if it's not selected, do nothing if it's already selected
        this.ToggleSelection(event, false, true);
      }

      this._fireActionEvent(current.get(0), event);
    } else if (this.IsArrowKey(key)) {
      ctrlKey = this._ctrlEquivalent(event);
      shiftKey = event.shiftKey;

      if (!ctrlKey) {
        processed = this.HandleArrowKeys(key, shiftKey && this._isSelectionEnabled() && this._isMultipleSelection(), event);
      }
    } else if (key === 'Tab' || key === this.TAB_KEY) {
      // content could have changed, disable all elements in items before or after the active item
      if (event.shiftKey) {
        this._disableAllTabbableElementsBeforeItem(current);
      } else {
        this._disableAllTabbableElementsAfterItem(current);
      }
    }

    return processed;
  },

  /** ******************************** End Selection **********************************************/

  /** ******************************** Disclosure **********************************************/

  /**
   * Whether the group item is currently in the middle of expanding/collapsing
   * @param {Object} key the key of the group item
   * @return {boolean} true if it's expanding/collapsing, false otherwise
   * @private
   */
  _isDisclosing: function _isDisclosing(key) {
    if (key && this.m_disclosing) {
      return this.m_disclosing.indexOf(key) > -1;
    }

    return false;
  },

  /**
   * Marks a group item as currently in the middle of expanding/collapsing
   * @param {Object} key the key of the group item
   * @param {boolean} flag true or false
   * @private
   */
  _setDisclosing: function _setDisclosing(key, flag) {
    if (key == null) {
      return;
    }

    if (this.m_disclosing == null) {
      this.m_disclosing = [];
    }

    if (flag) {
      this.m_disclosing.push(key);
    } else {
      // there should be at most one entry, but just in case remove all occurrences
      var index = this.m_disclosing.indexOf(key);

      while (index > -1) {
        this.m_disclosing.splice(index, 1);
        index = this.m_disclosing.indexOf(key);
      }
    }
  },

  /**
   * Gets the option defaults
   * @private
   */
  _getOptionDefaults: function _getOptionDefaults() {
    if (this.defaultOptions == null) {
      this.defaultOptions = ThemeUtils.parseJSONFromFontFamily(this.getOptionDefaultsStyleClass());
    }

    return this.defaultOptions;
  },

  /**
   * Gets the animation effect for the specific action
   * @param {string} action the action to retrieve the effect
   * @return {Object} the animation effect for the action
   */
  getAnimationEffect: function getAnimationEffect(action) {
    var defaultOptions = this._getOptionDefaults();

    var defaultAnimations = defaultOptions.animation;
    return defaultAnimations == null ? null : defaultAnimations[action];
  },

  /**
   * Whether group items can be expand/collapse.
   * @return {boolean} true if group items can be expand/collapse, false otherwise.
   */
  isExpandable: function isExpandable() {
    return this.GetOption('drillMode') !== 'none';
  },

  /**
   * Whether ListView should expand all expandable items.
   * @param {any} key the key of the item to check
   * @return {boolean} true if expand all, false otherwise
   * @private
   */
  _isExpandAll: function _isExpandAll(key) {
    var expanded = this.GetOption('expanded'); // for legacy syntax, which supports 'auto' and 'all'
    // TODO: should add check for custom element, but can't do it until NavList also move to KeySet

    if (expanded === 'auto') {
      // if drillMode is none and no expanded state is specified, expand all
      if (!this.isExpandable()) {
        return true;
      }
    } else if (expanded === 'all') {
      return true;
    } // for custom element and also legacy syntax that uses the new KeySet"expand


    if (expanded.isAddAll) {
      // if drillMode is none and no expanded state is specified, expand all
      return !this.isExpandable() && expanded instanceof oj._ojListViewExpandedKeySet ? true : expanded.isAddAll() && expanded.has(key);
    }

    return false;
  },

  /**
   * Expand an item with specified key.
   * Invoked by widget
   * @param {Object} key the key of the group item to expand
   * @param {boolean} beforeVetoable true if beforeExpand event can be veto, false otherwise
   * @param {boolean} fireBefore true if this should trigger a beforeExpand event
   * @param {boolean} fireAfter true if this should trigger an expand event
   * @param {boolean} animate true if animate the expand operation, false otherwise
   */
  expandKey: function expandKey(key, beforeVetoable, fireBefore, fireAfter, animate) {
    var item = this.FindElementByKey(key);

    if (item != null) {
      this.ExpandItem($(item), null, animate, key, beforeVetoable, fireAfter, fireBefore);
    }
  },

  /**
   * Handle expand operation
   * @param {Event} event the event that triggers the expand
   * @private
   */
  _expand: function _expand(event) {
    var item = this.FindItem(event.target);

    if (item != null && item.length > 0) {
      this.ExpandItem(item, event, true, null, true, true, true);
    }
  },

  /**
   * Expand an item
   * @param {jQuery} item the item to expand
   * @param {Event} event the event that triggers expand.  Note that event could be null in the case where this is programmatically done by the widget
   * @param {boolean} animate true if animate the expand operation, false otherwise
   * @param {Object|null} key the key of the item, if not specified, the logic will figure it out from the item
   * @param {boolean} beforeVetoable true if beforeExpand event can be veto, false otherwise
   * @param {boolean} fireEvent true if fire expand event, false otherwise
   * @param {boolean} fireBeforeEvent true if fire beforeexpand event, false otherwise
   * @protected
   */
  ExpandItem: function ExpandItem(item, event, animate, key, beforeVetoable, fireEvent, fireBeforeEvent) {
    // checks if it's already collapsed or not collapsible at all
    if (this.GetState(item) !== this.STATE_COLLAPSED) {
      return;
    } // if key wasn't specified, find it


    if (key == null) {
      // eslint-disable-next-line no-param-reassign
      key = this.GetKey(item[0]);
    } // bail if it's in the middle of expanding/collapsing


    if (animate && this._isDisclosing(key)) {
      return;
    }

    var ui = {
      item: item,
      key: key
    };

    if (fireBeforeEvent) {
      var cancelled = !this.Trigger('beforeExpand', event, ui);

      if (cancelled && beforeVetoable) {
        return;
      }
    }

    this.signalTaskStart('Expand item: ' + key); // signal method task start

    if (animate) {
      this._setDisclosing(key, true);
    }

    this.m_contentHandler.Expand(item, function (groupItem) {
      this._expandSuccess(groupItem, animate, event, ui, fireEvent);
    }.bind(this)); // clear items cache

    this.m_items = null; // prevent item click handler to trigger

    if (event != null) {
      event.stopPropagation();
    } // update var that keeps track of collapsed items


    if (!this.ojContext._IsCustomElement() && this._collapsedKeys != null) {
      var index = this._collapsedKeys.indexOf(key);

      if (index !== -1) {
        this._collapsedKeys.splice(index, 1);
      }
    }

    this.signalTaskEnd(); // signal method task end
  },

  /**
   * @param {Element} groupItem
   * @param {boolean} animate
   * @param {Event} event
   * @param {Object} ui
   * @param {boolean} fireEvent
   * @private
   */
  _expandSuccess: function _expandSuccess(groupItem, animate, event, ui, fireEvent) {
    var self = this;
    this.signalTaskStart('Handle results from successful expand'); // signal method task start
    // save the key for use when expand complete
    // eslint-disable-next-line no-param-reassign

    groupItem.key = ui.key;
    var animationPromise = this.AnimateExpand($(groupItem), animate, event);
    var item = groupItem.parentNode;
    item = $(item); // update aria expanded

    this.SetState(item, this.STATE_EXPANDED); // update icon

    var collapseClass = this.getCollapseIconStyleClass();
    var expandClass = this.getExpandIconStyleClass();
    var expandingClass = this.getExpandingIconStyleClass();
    var groupItemStyleClass = this.getGroupItemStyleClass();
    item.children('.' + groupItemStyleClass).find('.' + collapseClass + ', .' + expandingClass).removeClass(collapseClass).removeClass(expandingClass).addClass(expandClass); // fire expand event after expand animation completes

    if (fireEvent) {
      animationPromise.then(function () {
        // update option.  As an optimization do it only when fireEvent is true since this is the
        // only time when it's not triggered by API, in which case the value is already current
        if (self.ojContext._IsCustomElement()) {
          var currValue = self.GetOption('expanded');

          if (self._isKeySet(currValue) && !currValue.has(groupItem.key)) {
            var newValue = currValue.add([groupItem.key]);
            self.SetOption('expanded', newValue, {
              _context: {
                originalEvent: event,
                internalSet: true
              },
              changed: true
            });
          }
        }

        self.Trigger('expand', event, ui);
      });
    }

    animationPromise.then(function () {
      // clear cached height
      self.m_clientHeight = null;
      self.m_scrollHeight = null;
      self.signalTaskEnd(); // signal method task end
    });
  },

  /**
   * Adjust the max height of ancestors of a group items.
   * @param {jQuery} groupItem the group item where we want to adjust its ancestors max height
   * @param {number} delta the height to increase
   * @private
   */
  _adjustAncestorsMaxHeight: function _adjustAncestorsMaxHeight(groupItem, delta) {
    groupItem.parentsUntil('ul.oj-component-initnode', 'ul.' + this.getGroupStyleClass()).each(function () {
      var maxHeight = parseInt($(this).css('maxHeight'), 10);

      if (maxHeight > 0) {
        $(this).css('maxHeight', maxHeight + delta + 'px');
      }
    });
  },

  /**
   * Animate expand operation
   * @param {jQuery} groupItem the group item that is expand (todo: not consistent with animateCollapse)
   * @param {boolean} animate true if animate expand, false otherwise
   * @param {Event} event the event that triggers expand.  Note that event could be null in the case where this is programmatically done by the widget
   * @return {Promise} A Promise that resolves when expand animation completes
   * @protected
   */
  // eslint-disable-next-line no-unused-vars
  AnimateExpand: function AnimateExpand(groupItem, animate, event) {
    var totalHeight = 0;
    var animationResolve;
    var self = this;
    var action = 'expand';
    var animationPromise = new Promise(function (resolve) {
      animationResolve = resolve;
    });

    if (animate) {
      var elem =
      /** @type {Element} */
      groupItem.get(0);
      elem.setAttribute('data-oj-context', ''); // we have to wait for the items content to finish rendering before we calculate the height

      var busyContext = Context.getContext(elem).getBusyContext();
      busyContext.whenReady().then(function () {
        if (!self.isAvailable()) {
          return;
        }

        elem.removeAttribute('data-oj-context');
        self.signalTaskStart('Animate expand of group item'); // signal task start
        // reset max height to 100% first so we can get the correct outerHeight

        groupItem.css('maxHeight', '100%');
        groupItem.children().each(function () {
          totalHeight += $(this).outerHeight(true);
        }); // for touch we'll need to re-adjust the max height of parent nodes since max height doesn't get remove

        if (self._isNonWindowTouch()) {
          self._adjustAncestorsMaxHeight(groupItem, totalHeight);
        }

        groupItem.css('maxHeight', totalHeight + 'px');
        self.signalTaskStart('Kick off expand animation'); // signal expand animation started. Ends in _handleExpandTransitionEnd()
        // now show it

        var promise = self.StartAnimation(elem, action);
        promise.then(function () {
          self._handleExpandTransitionEnd(groupItem, animationResolve);
        });
        self.signalTaskEnd(); // signal task end
      });
    } else {
      // if we are not animating, then we don't really care about setting max height
      groupItem.css('maxHeight', '');
      this.AnimateExpandComplete(groupItem);
      animationResolve(null); // resolve animationPromise
    }

    return animationPromise;
  },
  _handleExpandTransitionEnd: function _handleExpandTransitionEnd(groupItem, animationResolve) {
    // on ios removing max-height will cause double animation
    if (!this._isNonWindowTouch()) {
      groupItem.css('maxHeight', '');
    }

    this.AnimateExpandComplete(groupItem);
    animationResolve(null); // resolve animationPromise

    this.signalTaskEnd(); // signal expand animation ended. Started in this.AnimateExpand()
  },

  /**
   * Invoked when expand animation is completed.  Class who overrides AnimateExpand
   * must call this method upon finish animation.
   * @param {jQuery} groupItem the item to collapse
   * @protected
   */
  AnimateExpandComplete: function AnimateExpandComplete(groupItem) {
    groupItem.removeClass(this.getGroupCollapseStyleClass()).addClass(this.getGroupExpandStyleClass());

    this._setDisclosing(groupItem[0].key, false);
  },

  /**
   * Collapse an item with specified key.
   * Invoked by widget
   * @param {Object} key the key of the group item to collapse
   * @param {boolean} fireBefore true if this should trigger a beforeCollapse event
   * @param {boolean} fireAfter true if this should trigger a collapse event
   * @param {boolean} animate true if animate the collapse operation, false otherwise
   */
  collapseKey: function collapseKey(key, fireBefore, fireAfter, animate) {
    var item = this.FindElementByKey(key);

    if (item != null) {
      this.CollapseItem($(item), null, animate, key, fireBefore, fireAfter);
    }
  },
  _collapse: function _collapse(event) {
    var item = this.FindItem(event.target);

    if (item != null && item.length > 0) {
      this.CollapseItem(item, event, true, null, true, true);
    }
  },

  /**
   * Collapse an item
   * @param {jQuery} item the item to expand
   * @param {Event} event the event that triggers collapse.  Note that event could be null in the case where this is programmatically done by the widget
   * @param {boolean} animate true if animate the collapse operation, false otherwise
   * @param {Object|null} key the key of the item, if not specified, the logic will figure it out from the item
   * @param {boolean} beforeVetoable true if beforeCollapse event can be veto, false otherwise
   * @param {boolean} fireEvent true if fire collapse event, false otherwise
   * @protected
   */
  CollapseItem: function CollapseItem(item, event, animate, key, beforeVetoable, fireEvent) {
    var self = this; // checks if it's already collapsed or not collapsible at all

    if (this.GetState(item) !== this.STATE_EXPANDED) {
      return;
    } // fire beforeCollapse event


    if (key == null) {
      // eslint-disable-next-line no-param-reassign
      key = this.GetKey(item[0]);
    } // bail if it is in the middle of expanding/collapsing


    if (animate && this._isDisclosing(key)) {
      return;
    }

    var ui = {
      item: item,
      key: key
    };
    var cancelled = !this.Trigger('beforeCollapse', event, ui);

    if (cancelled && beforeVetoable) {
      return;
    }

    this.signalTaskStart('Collapse item: ' + key); // signal method task start

    if (animate) {
      this._setDisclosing(key, true);
    } // animate collapse


    var animationPromise = this.AnimateCollapse(item, key, animate, event); // update aria expanded

    this.SetState(item, this.STATE_COLLAPSED); // update icon

    var collapseClass = this.getCollapseIconStyleClass();
    var expandClass = this.getExpandIconStyleClass();
    item.find('.' + expandClass).first().removeClass(expandClass).addClass(collapseClass); // clear items cache

    this.m_items = null; // prevent item click handler to trigger

    if (event != null) {
      event.stopPropagation();
    } // fire collapse event after collapse animation completes


    if (fireEvent) {
      animationPromise.then(function () {
        // update option.  As an optimization do it only when event is not null since this is the
        // only time when it's not triggered by API, in which case the value is already current
        if (event != null && self.ojContext._IsCustomElement()) {
          var currValue = self.GetOption('expanded');

          if (self._isKeySet(currValue)) {
            var newValue = currValue.delete([key]);
            self.SetOption('expanded', newValue, {
              _context: {
                originalEvent: event,
                internalSet: true
              },
              changed: true
            });
          }
        }

        self.Trigger('collapse', event, ui);
      });
    } // _collapsedKeys should only be used in the legacy syntax case


    if (!this.ojContext._IsCustomElement()) {
      // keep track of collapsed item
      if (this._collapsedKeys == null) {
        this._collapsedKeys = [];
      }

      if (this._collapsedKeys.indexOf(key) === -1) {
        this._collapsedKeys.push(key);
      }
    }

    animationPromise.then(function () {
      // clear cached height
      self.m_clientHeight = null;
      self.m_scrollHeight = null;
      self.signalTaskEnd(); // signal method task end
    });
  },

  /**
   * Animate collapse operation
   * To be change by NavList
   * @param {jQuery} item the item to collapse
   * @param {Object} key the key of the group item
   * @param {boolean} animate true if animate the collapse operation, false otherwise
   * @param {Event} event the event that triggers collapse.  Note that event could be null in the case where this is programmatically done by the widget
   * @return {Promise} A Promise that resolves when collapse animation completes
   * @protected
   */
  // eslint-disable-next-line no-unused-vars
  AnimateCollapse: function AnimateCollapse(item, key, animate, event) {
    var totalHeight = 0;
    var animationResolve;
    var self = this;
    var action = 'collapse';
    var animationPromise = new Promise(function (resolve) {
      animationResolve = resolve;
    });
    var groupItem = item.children('ul').first(); // save the key for collapse animation complete

    groupItem[0].key = key;

    if (animate) {
      this.signalTaskStart('Animate collapse'); // signal task start

      groupItem.children().each(function () {
        totalHeight += $(this).outerHeight();
      });
      groupItem.css('maxHeight', totalHeight + 'px');
      var effect = this.getAnimationEffect(action); // max-height = 0 needs to stick around, especially needed for static content

      effect.persist = 'all';
      this.signalTaskStart('Kick off collapse animation'); // signal collapse animation started. Ends in _handleCollapseTransitionEnd()
      // now hide it

      var elem =
      /** @type {Element} */
      groupItem.get(0);
      var promise = this.StartAnimation(elem, action, effect);
      promise.then(function () {
        self._handleCollapseTransitionEnd(groupItem, animationResolve);
      });
      this.signalTaskEnd(); // signal task end
    } else {
      groupItem.css('maxHeight', '0px');
      this.AnimateCollapseComplete(groupItem);
      animationResolve(null); // resolve animationPromise
    }

    return animationPromise;
  },
  _handleCollapseTransitionEnd: function _handleCollapseTransitionEnd(groupItem, animationResolve) {
    this.AnimateCollapseComplete(groupItem);
    animationResolve(null); // resolve animationPromise

    this.signalTaskEnd(); // signal collapse animation ended. Started in AnimateCollapse()
  },

  /**
   * Invoked when collapse animation is completed.  Class who overrides AnimateCollapse
   * must call this method upon finish animation.
   * @param {jQuery} groupItem the item to collapse
   * @private
   */
  AnimateCollapseComplete: function AnimateCollapseComplete(groupItem) {
    groupItem.removeClass(this.getGroupExpandStyleClass()).addClass(this.getGroupCollapseStyleClass()); // ask the content handler to do the collapse operation
    // content handler might have been destroyed if animation ended after destroy is called

    if (this.m_contentHandler != null) {
      this.m_contentHandler.Collapse(groupItem);
    }

    this._setDisclosing(groupItem[0].key, false);
  },

  /**
   * Gets the keys of currently expanded items.
   * Invoke by widget
   * @return {Array} array of keys of currently expanded items.
   */
  getExpanded: function getExpanded() {
    var expanded = [];
    var self = this;

    var items = this._getItemsCache();

    items.each(function () {
      var item = $(this);

      if (self.GetState(item) === self.STATE_EXPANDED) {
        expanded.push(self.GetKey(item[0]));
      }
    });
    return expanded;
  },

  /** ******************************* End Disclosure *******************************************/

  /**
   * Returns widget constructor.  Used by ContentHandler
   */
  getWidgetConstructor: function getWidgetConstructor() {
    return Components.__GetWidgetConstructor(this.element);
  },

  /** ********************************* Style Classes *********************************************/

  /**
   * To be change by NavList
   * @return {string} the container style class
   * @protected
   */
  GetContainerStyleClass: function GetContainerStyleClass() {
    // do not set overflow to scroll for windows touch enabled devices
    if (this._isNonWindowTouch()) {
      return 'oj-listview oj-listview-container-touch';
    }

    return 'oj-listview oj-listview-container';
  },

  /**
   * To be change by NavList
   * @return {string} the main element style class
   * @protected
   */
  GetStyleClass: function GetStyleClass() {
    return 'oj-listview-element';
  },

  /**
   * To be change by NavList.  Access by ContentHandler.
   * @return {string} the list item style class
   */
  getItemStyleClass: function getItemStyleClass() {
    if (this.isCardDisplayMode()) {
      return 'oj-listview-card';
    }

    return this._isGridlinesVisible() ? 'oj-listview-item' : 'oj-listview-item gridline-hidden';
  },

  /**
   * Gets the item layout class
   */
  getItemLayoutStyleClass: function getItemLayoutStyleClass() {
    // we don't have a default layout style class for card yet
    return this.isCardLayout() ? null : 'oj-listview-item-layout';
  },

  /**
   * To be change by NavList.  Access by ContentHandler.
   * @return {string} the focused element style class
   */
  getFocusedElementStyleClass: function getFocusedElementStyleClass() {
    return 'oj-listview-focused-element';
  },

  /**
   * To be change by NavList.  Access by ContentHandler.
   * @return {string} the list item element style class
   */
  getItemElementStyleClass: function getItemElementStyleClass() {
    return 'oj-listview-item-element';
  },

  /**
   * To be change by NavList.  Access by ContentHandler.
   * @param {boolean=} includeSupplement optional flag to indicate whether to include any supplement classes
   * @return {string} the group item element style class
   */
  getGroupItemStyleClass: function getGroupItemStyleClass(includeSupplement) {
    if (includeSupplement && this._isPinGroupHeader() && this._isPositionStickySupported()) {
      return 'oj-listview-group-item oj-sticky';
    }

    return 'oj-listview-group-item';
  },

  /**
   * To be change by NavList.  Access by ContentHandler.
   * @return {string} the group element style class
   */
  getGroupStyleClass: function getGroupStyleClass() {
    return this.isCardDisplayMode() ? 'oj-listview-card-group' : 'oj-listview-group';
  },

  /**
   * To be change by NavList.  Access by ContentHandler.
   * @return {string} the group expand style class
   */
  getGroupExpandStyleClass: function getGroupExpandStyleClass() {
    return '';
  },

  /**
   * To be change by NavList.  Access by ContentHandler.
   * @return {string} the group collapse style class
   */
  getGroupCollapseStyleClass: function getGroupCollapseStyleClass() {
    return this.getGroupExpandStyleClass();
  },

  /**
   * To be change by NavList
   * @return {string} the collapse icon style class
   */
  getCollapseIconStyleClass: function getCollapseIconStyleClass() {
    return 'oj-listview-collapse-icon';
  },

  /**
   * To be change by NavList
   * @return {string} the expand icon style class
   */
  getExpandIconStyleClass: function getExpandIconStyleClass() {
    return 'oj-listview-expand-icon';
  },

  /**
   * To be change by NavList
   * @return {string} the expanding icon style class
   */
  getExpandingIconStyleClass: function getExpandingIconStyleClass() {
    return 'oj-listview-expanding-icon';
  },

  /**
   * To be change by NavList
   * @return {string} the empty text style class
   */
  getEmptyTextStyleClass: function getEmptyTextStyleClass() {
    return 'oj-listview-no-data-message';
  },

  /**
   * To be change by NavList
   * @return {string} the empty text marker class
   */
  getEmptyTextMarkerClass: function getEmptyTextMarkerClass() {
    return 'oj-listview-empty-text';
  },

  /**
   * To be change by NavList
   * @return {string} the depth style class
   */
  // eslint-disable-next-line no-unused-vars
  getDepthStyleClass: function getDepthStyleClass(depth) {
    return '';
  },

  /**
   * To be change by NavList
   * @return {string} the option defaults style class
   */
  getOptionDefaultsStyleClass: function getOptionDefaultsStyleClass() {
    return 'oj-listview-option-defaults';
  },

  /**
   * To be change by NavList
   * @return {string} Loading status icon style class
   */
  getLoadingStatusIconStyleClass: function getLoadingStatusIconStyleClass() {
    return 'oj-listview-loading-icon';
  },

  /**
   * To be change by NavList
   * @return {string} status message style class
   */
  getStatusMessageStyleClass: function getStatusMessageStyleClass() {
    return 'oj-listview-status-message';
  },

  /**
   * To be change by NavList
   * @return {string} status style class
   */
  getStatusStyleClass: function getStatusStyleClass() {
    return 'oj-listview-status';
  },

  /** ******************************* End Style Classes *******************************************/

  /** ********************************* Pin Header *********************************************/
  _isPositionStickySupported: function _isPositionStickySupported() {
    // use native position sticky support for all platforms except IE11
    var browser = oj.AgentUtils.getAgentInfo().browser;
    return browser !== oj.AgentUtils.BROWSER.IE && browser !== oj.AgentUtils.BROWSER.EDGE;
  },

  /**
   * Helper method to prevent scroll by mouse wheel causes the page to scroll because it has reached the start/end of the list
   * @param {Element} scroller the scroller
   * @param {Event} event the mouse wheel event
   * @private
   */
  _preventMouseWheelOverscroll: function _preventMouseWheelOverscroll(scroller, event) {
    var delta = event.originalEvent.deltaY; // should only be applicable to TableDataSourceContentHandler for now

    if (isNaN(delta) || this.m_contentHandler.hasMoreToFetch === undefined) {
      return;
    }

    var scrollTop = scroller.scrollTop;

    if (delta > 0) {
      // scroll down
      var scrollHeight = this._getScrollHeight();

      if (this.m_contentHandler.hasMoreToFetch() && scrollTop + this._getClientHeight() + Math.abs(delta) >= scrollHeight) {
        // eslint-disable-next-line no-param-reassign
        scroller.scrollTop = scrollHeight;
        event.preventDefault();
      }
    } else if (scrollTop > 0 && scrollTop + delta <= 0) {
      // scroll up
      // eslint-disable-next-line no-param-reassign
      scroller.scrollTop = 0;
      event.preventDefault();
    }
  },

  /**
   * Retrieve the element where the scroll listener is registered on.
   * @private
   */
  _getScrollEventElement: function _getScrollEventElement() {
    var scroller = this._getScroller(); // if scroller is the body, listen for window scroll event.  This is the only way that works consistently across all browsers.


    if (scroller === document.body || scroller === document.documentElement) {
      return window;
    }

    return scroller;
  },

  /**
   * Find the element closest to the top of the viewport
   * @param {number} currScrollTop the current scrolltop
   * @prarm {boolean} isHierData if this supports hierarchical data
   * @param {number} itemHeight the item height
   * @private
   */
  _findClosestElementToTop: function _findClosestElementToTop(currScrollTop, isHierData, itemHeight) {
    // getItemsCache returns a flat view of all expanded items
    var items = isHierData ? this._getItemsCache() : $(this._getRootNodeForItems()).children('li.' + this.getItemElementStyleClass());

    if (items == null || items.length === 0) {
      return null;
    } // if the previous scroll position is relatively close to the current one
    // we'll use the previous index as the starting point


    var index;
    var prevScrollPosition = this.GetOption('scrollPosition');

    if (Math.abs(prevScrollPosition.y - currScrollTop) < this.MINIMUM_ITEM_HEIGHT && prevScrollPosition.key != null && !isNaN(prevScrollPosition.index)) {
      if (isHierData) {
        var element = this.FindElementByKey(prevScrollPosition.key);

        if (element != null) {
          index = items.index(element);
        }
      } else {
        index = prevScrollPosition.index;
      }
    } // we'll need to approximate the index


    if (isNaN(index)) {
      index = Math.floor(currScrollTop / itemHeight);
    } // ensure estimated index is valid


    index = Math.min(Math.max(index, 0), items.length - 1); // Sanitize scrollTop values for negative values.
    // This is to address Safari negative scrollTop when scroll "bounces" at the top

    var scrollTop = Math.max(currScrollTop, 0);
    var elem = items[index];
    var offsetTop;

    if (index === 0) {
      offsetTop = 0;
    } else {
      offsetTop = elem.offsetTop;
    }

    var diff = scrollTop - offsetTop;
    var firstInGroup = {
      index: index,
      elem: elem,
      offsetTop: offsetTop,
      offset: diff
    }; // scroll position perfectly line up with the top of item (take sub-pixels into account), we are done

    if (Math.abs(diff) < 1) {
      return firstInGroup;
    } // go forward or backward to find the item, keep that fix to avoid
    // potentially going back and forth (shouldn't happen)


    var forward = diff > 0;

    if (forward) {
      index += 1;
    } else {
      index -= 1;
    }

    var found = false;

    while (!found && index >= 0 && index < items.length) {
      elem = items[index];
      offsetTop = elem.offsetTop;
      diff = Math.abs(scrollTop - offsetTop);
      found = diff < 1 || (forward ? scrollTop <= offsetTop : scrollTop >= offsetTop);

      if (found) {
        // the one closer to the top wins
        if (diff < 1 || !forward) {
          // the current one is closer
          firstInGroup = {
            index: index,
            elem: elem,
            offsetTop: offsetTop,
            offset: diff
          };
        }

        break;
      } // for card layout, we want to return the first item among items that have the same scrollTop (same row)
      // note when scrolling backward, you'll always want the last one encountered


      if (!forward || firstInGroup.offsetTop !== offsetTop) {
        firstInGroup = {
          index: index,
          elem: elem,
          offsetTop: offsetTop,
          offset: diff
        };
      }

      if (forward) {
        index += 1;
      } else {
        index -= 1;
      }
    }

    if (!found) {
      // then it's the first/last item in the group/root
      index = forward ? items.length - 1 : 0;
      firstInGroup.index = index;
      firstInGroup.elem = items[index];
    }

    return firstInGroup;
  },

  /**
   * Returns the element which is the direct parent of all item elements.  Only for non-hier data.
   * @private
   */
  _getRootNodeForItems: function _getRootNodeForItems() {
    return this.isCardLayout() ? this.element.get(0).firstElementChild.firstElementChild : this.element.get(0);
  },

  /**
   * Gets the item height. Will set it if it is NaN
   * @return {number} item height
   * @private
   */
  _getItemHeight: function _getItemHeight() {
    if (this.m_itemHeight == null) {
      var firstItem;
      var isHierData = this.m_contentHandler.IsHierarchical();

      if (isHierData) {
        // could be a group
        firstItem = this.element.children('li.' + this.getItemElementStyleClass()).first();

        if (firstItem.length > 0) {
          this.m_itemHeight = firstItem.get(0).firstElementChild.offsetHeight;
        }
      } else {
        firstItem = $(this._getRootNodeForItems()).children('li.' + this.getItemElementStyleClass()).first();

        if (firstItem.length > 0) {
          this.m_itemHeight = firstItem.get(0).offsetHeight;
        }
      }
    }

    return this.m_itemHeight;
  },

  /**
   * Returns the scroll position object containing info about current scroll position.
   * @private
   */
  _getCurrentScrollPosition: function _getCurrentScrollPosition(scrollTop) {
    var scrollPosition = {};

    var scroller = this._getScroller();

    if (scrollTop === undefined) {
      // eslint-disable-next-line no-param-reassign
      scrollTop = scroller.scrollTop;
    }

    scrollPosition.x = this._getScrollX(scroller);
    scrollPosition.y = scrollTop;
    var isHierData = this.m_contentHandler.IsHierarchical();

    var itemHeight = this._getItemHeight(); // we used the item height to approximate where to begin the search
    // for the top most item.  This var should be populated in renderComplete
    // if there's no data then we should skip


    if (!isNaN(itemHeight) && itemHeight > 0) {
      var result = this._findClosestElementToTop(scrollTop, isHierData, itemHeight);

      if (result != null) {
        var elem = result.elem;

        if (isHierData) {
          var parent = elem.parentNode;

          if (parent !== this.element.get(0)) {
            this.m_closestParent = parent.parentNode;
            scrollPosition.parent = this.GetKey(this.m_closestParent);
          }

          scrollPosition.key = this.GetKey(result.elem);
          scrollPosition.index = $(parent).children().index(elem);
        } else {
          scrollPosition.index = result.index;
          scrollPosition.key = this.GetKey(result.elem);
        }

        scrollPosition.offsetY = result.offset; // offsetX is the same as x, even when card layout is used
        // since listview wraps card on space available, there will never be a listview
        // having 2 or more columns with a horizontal scrollbar

        scrollPosition.offsetX = scrollPosition.x;
      }
    }

    return scrollPosition;
  },

  /**
   * @private
   */
  _getOffsetTop: function _getOffsetTop(elem) {
    var offsetTop = this.element.get(0).offsetTop;

    if (!isNaN(this.m_elementOffset) && this.m_elementOffset !== offsetTop) {
      return Math.max(0, elem.offsetTop - offsetTop);
    }

    return elem.offsetTop;
  },

  /**
   * Retrieve the scroll top value based on item index (optionally with parent key)
   * @private
   */
  _getScrollTopByIndex: function _getScrollTopByIndex(index, parent) {
    var parentElem;

    if (parent != null) {
      parentElem = this.FindElementByKey(parent);

      if (parentElem != null) {
        // find the ul element
        parentElem = $(parentElem).children('ul').first();
      }
    } else {
      // avoid doing offsetTop
      if (index === 0) {
        return 0;
      }

      parentElem = this.element.get(0);

      if (this.isCardLayout()) {
        parentElem = parentElem.firstElementChild.firstElementChild;
      }
    }

    if (parentElem != null) {
      var elem = $(parentElem).children('.' + this.getItemElementStyleClass())[index];

      if (elem != null) {
        return this._getOffsetTop(elem);
      }
    } // we got here because one of the following happened:
    // 1) item has not been fetched yet
    // 2) index is large than the number of items, including reaching maxCount
    // 3) parent key specified does not exists or has not been fetched yet


    if (this.m_contentHandler.hasMoreToFetch && this.m_contentHandler.hasMoreToFetch()) {
      return this._getScrollHeight();
    }

    return undefined;
  },

  /**
   * Retrieve the scroll top value based on item key
   * @private
   */
  _getScrollTopByKey: function _getScrollTopByKey(key) {
    var elem = this.FindElementByKey(key);

    if (elem != null) {
      return this._getOffsetTop(elem);
    } // we got here because one of the following happened:
    // 1) item has not been fetched yet
    // 2) key does not exists or invalid


    if (this.m_contentHandler.hasMoreToFetch && this.m_contentHandler.hasMoreToFetch()) {
      return this._getScrollHeight();
    }

    return undefined;
  },

  /**
   * Gets the scroll coordinate based on value of scrollPosition.
   * @return {Object} the coordinate to scroll to, see syncScrollPosition
   * @private
   */
  _getScrollCoordinates: function _getScrollCoordinates(scrollPosition) {
    var y;
    var x = scrollPosition.x;
    var offsetX = scrollPosition.offsetX;

    if (!isNaN(x) && !isNaN(offsetX)) {
      x += offsetX;
    } // key first


    var key = scrollPosition.key;

    if (isNaN(y) && key != null) {
      y = this._getScrollTopByKey(key);
    } // then index


    var parent = scrollPosition.parent;
    var index = scrollPosition.index;

    if (isNaN(y) && !isNaN(index)) {
      y = this._getScrollTopByIndex(index, parent);
    }

    var offsetY = scrollPosition.offsetY;

    if (!isNaN(y) && !isNaN(offsetY)) {
      y += offsetY;
    } // then pixel position last


    if (isNaN(y) && !isNaN(scrollPosition.y)) {
      y = scrollPosition.y;
    }

    return {
      x: x,
      y: y
    };
  },

  /**
   * Whether there are no items in the list
   */
  _isEmpty: function _isEmpty() {
    // can't just use childElementCount as there could be no data content or skeletons
    var root = this.element[0];
    var item = root.querySelector('li.' + this.getItemElementStyleClass());
    var tempItem = root.querySelector('li.oj-listview-temp-item');
    return item == null && tempItem == null;
  },

  /**
   * Scroll handler
   * @private
   */
  _handleScroll: function _handleScroll(event) {
    // since we are calling it from requestAnimationFrame, ListView could have been destroyed already
    // do not handle scroll for NavList, or when it is empty (could scroll due to rendering of skeletons)
    if (this.m_contentHandler == null || !this.ShouldUseGridRole() || this._isEmpty()) {
      return;
    } // update scrollPosition


    var scrollTop = this._getScroller().scrollTop;

    if (!this.ojContext._IsCustomElement()) {
      this.SetOption('scrollTop', scrollTop, {
        _context: {
          originalEvent: event,
          internalSet: true
        }
      });
    }

    if (this.ShouldUpdateScrollPosition()) {
      this.SetOption('scrollPosition', this._getCurrentScrollPosition(scrollTop), {
        _context: {
          originalEvent: event,
          internalSet: true
        }
      });
    } // handle pinning group header, does not need if position sticky is supported


    this._handlePinGroupHeader();
  },

  /**
   * Whether high-watermark scrolling is specified
   * @protected
   */
  isLoadMoreOnScroll: function isLoadMoreOnScroll() {
    // for legacy DataSource, we will maintain the behavior for 'auto'
    var scrollPolicy = this.GetOption('scrollPolicy');

    if (scrollPolicy === 'auto') {
      var data = this.GetOption('data');

      if (data != null && (typeof oj.TableDataSource !== 'undefined' && data instanceof oj.TableDataSource || typeof oj.TreeDataSource !== 'undefined' && data instanceof oj.TreeDataSource)) {
        return false;
      }
    }

    return scrollPolicy !== 'loadAll';
  },

  /**
   * Un-register scroll listener
   * @private
   */
  _unregisterScrollHandler: function _unregisterScrollHandler() {
    var scrollElem = $(this._getScrollEventElement());

    this.ojContext._off(scrollElem, 'scroll');

    if (this.ojContext._IsCustomElement()) {
      // remove wheel listener add with addEventListener
      scrollElem[0].removeEventListener('wheel', this._wheelListener, {
        passive: false
      });
      delete this._wheelListener;
    } else {
      // remove wheel listener added with jQuery
      this.ojContext._off(scrollElem, 'wheel');
    }

    return scrollElem;
  },

  /**
   * Register scroll listener
   * @private
   */
  _registerScrollHandler: function _registerScrollHandler() {
    var self = this;

    var scrollElem = this._unregisterScrollHandler();

    this.ojContext._on(scrollElem, {
      scroll: function scroll(event) {
        // throttle the event using requestAnimationFrame for performance reason
        // don't update if scroll is triggered by listview internally setting scrollLeft/scrollTop
        if (!self._skipScrollUpdate && !self.m_ticking) {
          window.requestAnimationFrame(function () {
            self._handleScroll(event);

            self.m_ticking = false;
          });
          self.m_ticking = true;
        }

        if (self._skipScrollUpdate) {
          self.signalTaskEnd();
        }

        self._skipScrollUpdate = false;
      }
    }); // only do this for high-water mark scrolling, other cases we have (and should not care) no knowledge about the scroller


    if (this.isLoadMoreOnScroll()) {
      this._wheelListener = function (event) {
        // add originalEvent for downstream code expecting it
        if (!event.originalEvent) {
          // eslint-disable-next-line no-param-reassign
          event.originalEvent = event;
        }

        self._preventMouseWheelOverscroll(self._getScroller(), event);
      };

      this._scrollElem = scrollElem;

      if (this.ojContext._IsCustomElement()) {
        this._scrollElem[0].addEventListener('wheel', this._wheelListener, {
          passive: false
        });
      } else {
        this.ojContext._on(this._scrollElem, {
          wheel: this._wheelListener
        });
      }
    }
  },

  /**
   * Whether group header should be pin
   * @return {boolean} true if group header should be pin or false otherwise
   * @private
   */
  _isPinGroupHeader: function _isPinGroupHeader() {
    return this.GetOption('groupHeaderPosition') !== 'static' && this.m_contentHandler.IsHierarchical();
  },

  /**
   * Retrieve the visible (flattened) group items cache, create one if it is null.
   * @return {jQuery} a list of group items
   * @private
   */
  _getGroupItemsCache: function _getGroupItemsCache() {
    if (this.m_groupItems == null) {
      var selector = '.' + this.getGroupItemStyleClass() + ':visible';
      this.m_groupItems = this.element.find(selector).filter(function () {
        // if it's expanded and it has children
        if (!$(this).parent().hasClass('oj-collapsed')) {
          if ($(this).next().children().length > 0) {
            return true;
          }
        }

        return false;
      });
    }

    return this.m_groupItems;
  },

  /**
   * Unpin a pinned group header
   * @param {Element} groupItem the group header element to unpin
   * @private
   */
  _unpinGroupItem: function _unpinGroupItem(groupItem) {
    $(groupItem).removeClass('oj-pinned'); // eslint-disable-next-line no-param-reassign

    groupItem.style.top = 'auto'; // eslint-disable-next-line no-param-reassign

    groupItem.style.width = 'auto';
  },

  /**
   * Gets the next group item.  This could be a group item from a different parent.
   * @param {Element} groupItem the reference group item.
   * @return {Element|null} the next group item or null if one cannot be found
   * @private
   */
  _getNextGroupItem: function _getNextGroupItem(groupItem) {
    var groupItems = this._getGroupItemsCache();

    var index = groupItems.index(groupItem);

    if (index > -1 && index < groupItems.length - 1) {
      return groupItems[index + 1];
    }

    return null;
  },

  /**
   * Pin a group header
   * @param {Element} groupItem the group header element to pin
   * @param {number} scrollTop the scrolltop position of the listview container
   * @private
   */
  _pinGroupItem: function _pinGroupItem(groupItem, scrollTop) {
    var width = groupItem.offsetWidth;
    var height = groupItem.offsetHeight;

    var next = this._getNextGroupItem(groupItem); // todo: get rid of 5


    if (next != null && next.offsetTop <= scrollTop + height + 5) {
      // eslint-disable-next-line no-param-reassign
      scrollTop -= height;
    }

    $(groupItem).addClass('oj-pinned'); // eslint-disable-next-line no-param-reassign

    groupItem.style.top = scrollTop + 'px'; // eslint-disable-next-line no-param-reassign

    groupItem.style.width = width + 'px';
  },

  /**
   * Pin the header as neccessary when user scrolls.
   * @private
   */
  _handlePinGroupHeader: function _handlePinGroupHeader() {
    var groupItemToPin; // if groupHeaderPosition is not sticky or if position:sticky is supported natively in the browser

    if (!this._isPinGroupHeader() || this._isPositionStickySupported()) {
      return;
    }

    var scroller = this._getScroller();

    var scrollTop = scroller.scrollTop; // see if we are at the top

    if (this.m_groupItemToPin != null && scrollTop === 0) {
      this._unpinGroupItem(this.m_groupItemToPin);

      this.m_groupItemToPin = null;
      return;
    } // find the group item to pin


    var groupItems = this._getGroupItemsCache();

    var pinHeaderHeight = 0;

    if (this.m_groupItemToPin != null) {
      pinHeaderHeight = this.m_groupItemToPin.offsetHeight;
    }

    for (var i = 0; i < groupItems.length; i++) {
      var groupItem = groupItems[i];

      if (this.m_groupItemToPin !== groupItem) {
        var top = groupItems[i].offsetTop;
        var bottom = top + groupItem.parentNode.offsetHeight; // if bottom half is in view but not the top half

        if (top < scrollTop && bottom > scrollTop + pinHeaderHeight) {
          groupItemToPin = groupItem;
          break;
        }
      }
    } // found the group item to pin


    if (groupItemToPin != null && groupItemToPin !== this.m_groupItemToPin) {
      // unpin the previous item
      if (this.m_groupItemToPin != null) {
        this._unpinGroupItem(this.m_groupItemToPin);
      }

      this._pinGroupItem(groupItemToPin, scrollTop);

      this.m_groupItemToPin = groupItemToPin;
    } else if (this.m_groupItemToPin != null) {
      // is the current pin header touching the next item
      var next = this._getNextGroupItem(this.m_groupItemToPin);

      if (next != null && next.offsetTop <= scrollTop + pinHeaderHeight) {
        // make sure they really touches
        this.m_groupItemToPin.style.top = next.offsetTop - pinHeaderHeight + 'px';
        return;
      }

      this.m_groupItemToPin.style.top = scrollTop + 'px';
    }
  },

  /**
   * Gets the scroller element, which is either the listview container or the scroller element
   * specified in scrollPolicyOptions
   * @return {Element} the scroller element
   * @private
   */
  _getScroller: function _getScroller() {
    var options = this.GetOption('scrollPolicyOptions');

    if (options != null) {
      var scroller = options.scroller;

      if (scroller != null) {
        return scroller;
      }
    }

    return this.getListContainer().get(0);
  },

  /**
   * Scroll to the specified group header
   * @param {Element} groupHeader the group header div element
   * @private
   */
  _scrollToGroupHeader: function _scrollToGroupHeader(groupHeader) {
    var scroller = this._getScroller();

    var currentScrollTop = scroller.scrollTop; // unpin any pinned group header first before scroll to header

    if (this.m_groupItemToPin != null) {
      this._unpinGroupItem(this.m_groupItemToPin);

      this.m_groupItemToPin = null;
    }

    var newScrollTop = groupHeader.offsetTop; // when scrolling backwards, the offsetTop is going to take position sticky into account, so it will
    // scroll to the minimum where the header is visible, and as a result all children items would not be visible

    if (this._isPinGroupHeader() && this._isPositionStickySupported() && newScrollTop < currentScrollTop) {
      newScrollTop = Math.max(0, newScrollTop - groupHeader.parentNode.offsetHeight + groupHeader.offsetHeight);
    }

    scroller.scrollTop = newScrollTop; // if it wasn't scroll (ex: already at the end), we'll have to explicitly try to see if we need to pin again

    if (currentScrollTop === scroller.scrollTop) {
      this._handlePinGroupHeader();
    } // set the first item in group current


    this._setFirstFocusableItemInGroupCurrent(groupHeader);
  },

  /**
   * Find the first focusable item within the group and make it current
   * @param {Element} groupHeader the group header
   * @private
   */
  _setFirstFocusableItemInGroupCurrent: function _setFirstFocusableItemInGroupCurrent(groupHeader) {
    var self = this;
    var items = $(groupHeader).next().children();
    items.each(function () {
      var item = $(this); // make sure item can receive focus

      if (!self.SkipFocus(item)) {
        self.SetOption('currentItem', this.key);
        return false;
      }

      return undefined;
    });
  }
  /** ******************************* End Pin Header *******************************************/

});



/* global KeySet:false, DataCollectionUtils:false, Components:false, ThemeUtils:false */

/**
 * @ojcomponent oj.ojListView
 * @augments oj.baseComponent
 * @since 1.1.0
 *
 * @ojtsimport {module: "ojdataprovider", type: "AMD", imported: ["DataProvider", "ItemMetadata"]}
 * @ojtsimport {module: "ojkeyset", type: "AMD", imported: ["KeySet"]}
 * @ojtsimport {module: "ojcommontypes", type: "AMD", importName: ["CommonTypes"]}
 * @ojsignature [{
 *                target: "Type",
 *                value: "class ojListView<K, D> extends baseComponent<ojListViewSettableProperties<K,D>>",
 *                genericParameters: [{"name": "K", "description": "Type of key of the dataprovider"}, {"name": "D", "description": "Type of data from the dataprovider"}]
 *               },
 *               {
 *                target: "Type",
 *                value: "ojListViewSettableProperties<K,D> extends baseComponentSettableProperties",
 *                for: "SettableProperties"
 *               }
 *              ]
 * @ojshortdesc A list view displays data items as a list or a grid with highly interactive features.
 * @ojrole grid
 *
 * @ojpropertylayout {propertyGroup: "common", items: ["selectionMode"]}
 * @ojpropertylayout {propertyGroup: "data", items: ["data", "selected"]}
 * @ojvbdefaultcolumns 12
 * @ojvbmincolumns 2
 *
 * @ojuxspecs ['list-view']
 *
 * @classdesc
 * <h3 id="listViewOverview-section">
 *   JET ListView Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#listViewOverview-section"></a>
 * </h3>
 *
 * <p>Description: The JET ListView enhances a HTML list element into a themable, WAI-ARIA compliant, mobile friendly component with advance interactive features.</p>
 *
 * <h3 id="data-section">
 *   Data
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#data-section"></a>
 * </h3>
 * <p>The JET ListView gets its data in three different ways.  The first way is from a DataProvider/TableDataSource.  There are several types of DataProvider/TableDataSource
 * that are available out of the box:</p>
 * <ul>
 * <li>oj.ArrayDataProvider</li>
 * <li>oj.CollectionTableDataSource</li>
 * <li>oj.PagingTableDataSource</li>
 * </ul>
 * <p>Note that TableDataSource has been deprecated, please find the equivalent DataProvider implementation.</p>
 *
 * <p><b>oj.ArrayDataProvider</b> - Use this when the underlying data is an array object or an observableArray.  In the observableArray case, ListView will automatically react
 * when items are added or removed from the array.  See the documentation for oj.ArrayDataProvider for more details on the available options.</p>
 *
 * <p><b>oj.CollectionTableDataSource</b> - Use this when oj.Collection is the model for the underlying data.  Note that the ListView will automatically react to model event from
 * the underlying oj.Collection.  See the documentation for oj.CollectionTableDataSource for more details on the available options.</p>
 *
 * <p><b>oj.PagingTableDataSource</b> - Use this when the ListView is driven by an associating ojPagingControl.  See the documentation for oj.PagingTableDataSource for more
 * details on the available options.</p>
 *
 * <p>The second way is from a TreeDataProvider/TreeDataSource.  This is typically used to display data that are logically categorized in groups.  There are several types
 * of TreeDataProvider/TreeDataSource that are available out of the box:</p>
 * <ul>
 * <li>oj.ArrayTreeDataProvider</li>
 * <li>oj.CollectionTreeDataSource</li>
 * </ul>
 *
 * <p><b>oj.ArrayTreeDataProvider</b> - Use this when the underlying data is an array object or an observableArray.  In the observableArray case, ListView will automatically react
 * when items are added or removed from the array.  See the documentation of oj.ArrayTreeDataProvider for more details on the available options.</p>
 *
 * <p><b>oj.CollectionTreeDataSource</b> - Use this when oj.Collection is the model for each group of data.  See the documentation for oj.CollectionTableDataSource
 * for more details on the available options.</p>
 *
 * <p>Finally, ListView also supports static HTML content as data.  The structure of the content can be either flat or hierarhical.</p>
 *
 * <p>A note about hierarchical data, even though ListView supports data with > 2 levels, it is not recommended because it does not render depth, for that case you should look at using ojTreeView<p>
 *
 *
 * <p>Example of flat static content</p>
 * <pre class="prettyprint">
 * <code>&lt;oj-list-view id="listView">
 *   &lt;ul>
 *     &lt;li>&lt;a id="item1" href="#">Item 1&lt;/a>&lt;/li>
 *     &lt;li>&lt;a id="item2" href="#">Item 2&lt;/a>&lt;/li>
 *     &lt;li>&lt;a id="item3" href="#">Item 3&lt;/a>&lt;/li>
 *   &lt;/ul>
 * &lt;/oj-list-view>
 * </code></pre>
 *
 * <p>Example of hierarchical static content</p>
 * <pre class="prettyprint">
 * <code>&lt;oj-list-view id="listView">
 *   &lt;ul>
 *     &lt;li>&lt;a id="group1" href="#">Group 1&lt;/a>
 *       &lt;ul>
 *         &lt;li>&lt;a id="item1-1" href="#">Item 1-1&lt;/a>&lt;/li>
 *         &lt;li>&lt;a id="item1-2" href="#">Item 1-2&lt;/a>&lt;/li>
 *       &lt;/ul>
 *     &lt;/li>
 *     &lt;li>&lt;a id="group2" href="#">Group 2&lt;/a>
 *       &lt;ul>
 *         &lt;li>&lt;a id="item2-1" href="#">Item 2-1&lt;/a>&lt;/li>
 *         &lt;li>&lt;a id="item2-2" href="#">Item 2-2&lt;/a>&lt;/li>
 *       &lt;/ul>
 *     &lt;/li>
 *   &lt;/ul>
 * &lt;/oj-list-view>
 * </code></pre>
 *
 * <h3 id="touch-section">
 *   Touch End User Information
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
 * </h3>
 *
 * {@ojinclude "name":"touchDoc"}
 *
 * <h3 id="keyboard-section">
 *   Keyboard End User Information
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 *
 * {@ojinclude "name":"keyboardDoc"}
 *
 * <h3 id="context-section">
 *   Item Context
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#context-section"></a>
 * </h3>
 *
 * <p>For all item options, developers can specify a function as the return value.  The function takes a single argument, which is an object that contains contextual information about the particular item.  This gives developers the flexibility to return different value depending on the context.</p>
 *
 * <p>The context paramter contains the following keys:</p>
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Description</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>componentElement</kbd></td>
 *       <td>A reference to the root element of ListView.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>datasource</kbd></td>
 *       <td>A reference to the data source object. (Not available for static content)</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>index</kbd></td>
 *       <td>The index of the item, where 0 is the index of the first item.  In the hierarchical case the index is relative to its parent.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>key</kbd></td>
 *       <td>The key of the item.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>data</kbd></td>
 *       <td>The data object for the item.</td>
 *     </tr>
 *      <tr>
 *       <td><kbd>metadata</kbd></td>
 *       <td>The metadata object for the item.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>parentElement</kbd></td>
 *       <td>The list item element.  The renderer can use this to directly append content.</td>
 *     </tr>
 *   </tbody>
 * </table>
 *
 * <p></p>
 * <p>If the data is hierarchical, the following additional contextual information are available:</p>
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Description</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>depth</kbd></td>
 *       <td>The depth of the item.  The depth of the first level children under the invisible root is 1.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>parentKey</kbd></td>
 *       <td>The key of the parent item.  The parent key is null for root node.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>leaf</kbd></td>
 *       <td>Whether the item is a leaf or a group item.</td>
 *     </tr>
 *   </tbody>
 * </table>
 *
 * <h3 id="accessibility-section">
 *   Accessibility
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#accessibility-section"></a>
 * </h3>
 *
 * <p>Application should specify a value for the aria-label attribute with a meaningful description of the purpose of this list.
 *
 * <p>Application must ensure that the context menu is available and setup with the
 * appropriate clipboard menu items so that keyboard-only users are able to reorder items
 * just by using the keyboard.
 *
 * <p>Note that ListView uses the grid role and follows the <a href="https://www.w3.org/TR/wai-aria-practices/examples/grid/LayoutGrids.html">Layout Grid</a> design as outlined in the <a href="https://www.w3.org/TR/wai-aria-practices/#grid">grid design pattern</a>.
 *
 *
 * <h3 id="perf-section">
 *   Performance
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#perf-section"></a>
 * </h3>
 *
 * <h4>Data Set Size</h4>
 * <p>As a rule of thumb, it's recommended that applications limit the amount of data to display.  Displaying large
 * number of items in ListView makes it hard for user to find what they are looking for, but affects the load time and
 * scrolling performance as well.  If displaying large number of items is neccessary, use a paging control with ListView
 * to limit the number of items to display at a time.  Setting <code class="prettyprint">scrollPolicy</code> to
 * 'loadMoreOnScroll' will also reduce the number of items to display initially.</p>
 *
 * <h4>Item Content</h4>
 * <p>ListView allows developers to specify arbitrary content inside its item. In order to minimize any negative effect on
 * performance, you should avoid putting a large number of heavy-weight components inside because as you add more complexity
 * to the structure, the effect will be multiplied because there can be many items in the ListView.</p>
 *
 * <h4>Expand All</h4>
 * <p>While ListView provides a convenient way to initially expand all group items in the ListView, it might have an impact
 * on the initial rendering performance since expanding each group item might cause a fetch from the server depending on
 * the TreeDataSource.  Other factors that could impact performance includes the depth of the tree, and the number of children
 * in each level.</p>
 *
 * <h3 id="animation-section">
 *   Animation
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#animation-section"></a>
 * </h3>
 *
 * <p>Applications can customize animations triggered by actions in ListView by either listening for <code class="prettyprint">animateStart/animateEnd</code>
 *    events or overriding action specific style classes on the animated item.  See the documentation of <a href="oj.AnimationUtils.html">oj.AnimationUtils</a>
 *    class for details.</p>
 *
 * <p>The following are actions and their corresponding sass variables in which applications can use to customize animation effects.
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Action</th>
 *       <th>Sass Variable</th>
 *       <th>Description</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>add</kbd></td>
 *       <td>$listViewAddAnimation</td>
 *       <td>When a new item is added to the oj.TableDataSource associated with ListView.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>remove</kbd></td>
 *       <td>$listViewRemoveAnimation</td>
 *       <td>When an existing item is removed from the oj.TableDataSource associated with ListView.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>update</kbd></td>
 *       <td>$listViewUpdateAnimation</td>
 *       <td>When an existing item is updated in the oj.TableDataSource associated with ListView.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>expand</kbd></td>
 *       <td>$listViewExpandAnimation</td>
 *       <td>When user expands a group item.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>collapse</kbd></td>
 *       <td>$listViewCollapseAnimation</td>
 *       <td>When user collapses a group item.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>pointerUp</kbd></td>
 *       <td>$listViewPointerUpAnimation</td>
 *       <td>When user finish pressing an item (on touch).</td>
 *     </tr>
 *   </tbody>
 * </table>
 */
// --------------------------------------------------- oj.ojListView Styling Start -----------------------------------------------------------
// ---------------- oj-clickthrough-disabled --------------

/**
* Use on any element inside an item where you do not want ListView to process the click event.
* @ojstyleclass oj-clickthrough-disabled
* @ojdisplayname Click Disabled
* @ojstyleselector oj-list-view, oj-list-view *
* @memberof oj.ojListView
* @ojtsexample
* &lt;oj-list-view class="oj-clickthrough-disabled">
*   &lt;!-- Content -->
* &lt;/oj-list-view>
*/
// ---------------- oj-focus-highlight --------------

/**
* Under normal circumstances this class is applied automatically.
* It is documented here for the rare cases that an app developer needs per-instance control.<br/><br/>
* The oj-focus-highlight class applies focus styling that may not be desirable when the focus results from pointer interaction (touch or mouse), but which is needed for accessibility when the focus occurs by a non-pointer mechanism, for example keyboard or initial page load.<br/><br/>
* The application-level behavior for this component is controlled in the theme by the <code class="prettyprint"><span class="pln">$focusHighlightPolicy </span></code>SASS variable; however, note that this same variable controls the focus highlight policy of many components and patterns. The values for the variable are:<br/><br/>
* <code class="prettyprint"><span class="pln">nonPointer: </span></code>oj-focus-highlight is applied only when focus is not the result of pointer interaction. Most themes default to this value.<br/>
* <code class="prettyprint"><span class="pln">all: </span></code> oj-focus-highlight is applied regardless of the focus mechanism.<br/>
* <code class="prettyprint"><span class="pln">none: </span></code> oj-focus-highlight is never applied. This behavior is not accessible, and is intended for use when the application wishes to use its own event listener to precisely control when the class is applied (see below). The application must ensure the accessibility of the result.<br/><br/>
* To change the behavior on a per-instance basis, the application can set the SASS variable as desired and then use event listeners to toggle this class as needed.<br/>
* @ojstyleclass oj-focus-highlight
* @ojdisplayname Focus Styling
* @ojshortdesc Allows per-instance control of the focus highlight policy (not typically required). See the Help documentation for more information.
* @memberof oj.ojListView
* @ojtsexample
* &lt;oj-list-view class="oj-focus-highlight">
*   &lt;!-- Content -->
* &lt;/oj-list-view>
*/
// ---------------- oj-full-width --------------

/**
* Use when ListView occupies the entire width of the page. Removes left and right borders in card-layout mode and adjust positioning of cards to improve visual experience.
* @ojstyleclass oj-full-width
* @ojdisplayname Full Width
* @memberof oj.ojListView
* @ojtsexample
* &lt;oj-list-view class="oj-full-width">
*   &lt;!-- Content -->
* &lt;/oj-list-view>
*/
// ---------------- oj-listview-card-layout --------------

/**
* Shows items as cards and lay them out in a grid.
* @ojstyleclass oj-listview-card-layout
* @ojdisplayname Card Layout
* @memberof oj.ojListView
* @ojtsexample
* &lt;oj-list-view class="oj-listview-card-layout">
*   &lt;!-- Content -->
* &lt;/oj-list-view>
*/
// ---------------- oj-listview-drag-handle --------------

/**
* Use to show a drag handle in the item to facilitate item reordering or drag and drop.
* @ojstyleclass oj-listview-drag-handle
* @ojdisplayname Drag Handle
* @ojstyleselector oj-list-view *
* @memberof oj.ojListView
* @ojtsexample
* &lt;oj-list-view>
*   &lt;template slot="itemTemplate" data-oj-as="item">
*     ...
*     &lt;div class="oj-flex-bar-end oj-sm-align-items-center">
*      &lt;div role="button" tabindex="0" class="oj-flex-item oj-listview-drag-handle">
*      &lt;/div>
*     &lt;/div>
*   &lt;/template>
* &lt;/oj-list-view>
*/
// ---------------- oj-listview-drill-icon --------------

/**
* Use to show a drill-to-detail icon in the item.
* @ojstyleclass oj-listview-drill-icon
* @ojdisplayname Drill Icon
* @ojstyleselector oj-list-view *
* @memberof oj.ojListView
* @ojtsexample
* &lt;oj-list-view class="oj-listview-card-layout">
*   &lt;template slot="itemTemplate" data-oj-as="item">
*     ...
*     &lt;div class="oj-flex-bar-end oj-sm-align-items-center">
*      &lt;div role="presentation" class="oj-flex-item oj-fwk-icon oj-listview-drill-icon">
*      &lt;/div>
*     &lt;/div>
*   &lt;/template>
* &lt;/oj-list-view>
*/
// ---------------- oj-listview-item-layout --------------

/**
* Use when the page author overrides the default styling on the item root element and wants to apply the item style on some other element.
* @ojstyleclass oj-listview-item-layout
* @ojdisplayname Item Layout
* @ojstyleselector oj-list-view *
* @memberof oj.ojListView
* @ojtsexample
* &lt;oj-list-view class="">
*   &lt;template slot="itemTemplate" data-oj-as="item">
*     &lt;div class="oj-listview-item-layout">
*     ...
*     &lt;/div>
*   &lt;/template>
* &lt;/oj-list-view>
*/
// --------------------------------------------------- oj.listView Styling End -----------------------------------------------------------
oj.__registerWidget('oj.ojListView', $.oj.baseComponent, {
  widgetEventPrefix: 'oj',
  options: {
    /**
     * An alias for the current item when referenced inside the item template. This can be especially useful
     * if oj-bind-for-each element is used inside the item template since it has its own scope of data access.
     *
     * @ojshortdesc Specifies the alias for the current item when referenced inside the item template.
     *
     * @expose
     * @public
     * @instance
     * @memberof! oj.ojListView
     * @type {string}
     * @default ''
     * @ojdeprecated {since: '6.2.0', description: 'Set the alias directly on the template element using the data-oj-as attribute instead.'}
     *
     * @example <caption>Initialize the ListView with the <code class="prettyprint">as</code> attribute specified:</caption>
     * &lt;oj-list-view as='item'>
     *   &lt;template slot='itemTemplate'>
     *     &lt;p>&lt;oj-bind-text value='[[item.data.name]]'>&lt;/oj-bind-text>&lt;/p>
     *   &lt;/template>
     * &lt;/oj-list-view>
     */
    as: '',

    /**
     * The item that currently have keyboard focus.  Note that if current item
     * is set to an item that is not available in the view (either not fetched in high-water mark scrolling case or
     * hidden inside a collapsed parent node), then the value is not applied.
     *
     * @ojshortdesc Specifies the key of the item that should have keyboard focus. See the Help documentation for more information.
     * @expose
     * @public
     * @instance
     * @memberof! oj.ojListView
     * @type {any}
     * @ojsignature {target:"Type", value:"K"}
     * @default null
     * @ojwriteback
     *
     * @example <caption>Initialize the ListView with the <code class="prettyprint">current-item</code> attribute specified:</caption>
     * &lt;oj-list-view current-item='{{myCurrentItem}}'>&lt;/oj-list-view>
     *
     * @example <caption>Get or set the <code class="prettyprint">currentItem</code> property after initialization:</caption>
     * // getter
     * var currentItemValue = myListView.currentItem;
     *
     * // setter
     * myListView.currentItem = "item2";
     */
    currentItem: null,

    /**
     * The data source for ListView.  Must be of type oj.TableDataSource, oj.TreeDataSource, oj.DataProvider
     * See the data source section in the introduction for out of the box data source types.
     * If the data attribute is not specified, the child elements are used as content.  If there's no
     * content specified, then an empty list is rendered.
     *
     * @ojshortdesc Specifies the data for the list. See the Help documentation for more information.
     * @expose
     * @memberof! oj.ojListView
     * @instance
     * @type {Object}
     * @default null
     *
     * @example <caption>Initialize the ListView with the <code class="prettyprint">data</code> attribute specified:</caption>
     * &lt;oj-list-view data='{{myDataSource}}'>&lt;/oj-list-view>
     *
     * @example <caption>Get or set the <code class="prettyprint">data</code> property after initialization:</caption>
     * // getter
     * var dataValue = myListView.data;
     *
     * // setter
     * myListView.data = myDataSource;
     * @ojsignature [{target: "Type", value: "oj.DataProvider<K, D>"},
     *               {target: "Type", value: "oj.TableDataSource|oj.TreeDataSource|oj.DataProvider", consumedBy:"js"}]
     */
    data: null,

    /**
     * Whether to display items as list items or as cards.
     *
     * @ojshortdesc Specifies how the items should be displayed.
     * @expose
     * @memberof! oj.ojListView
     * @instance
     * @type {string}
     * @default "list"
     * @ojvalue {string} "list" Display items as list item.
     * @ojvalue {string} "card" Display items as cards.
     *
     * @example <caption>Initialize the ListView with the <code class="prettyprint">display</code> attribute specified:</caption>
     * &lt;oj-list-view display='card'>&lt;/oj-list-view>
     *
     * @example <caption>Get or set the <code class="prettyprint">display</code> property after initialization:</caption>
     * // getter
     * var displayValue = myListView.display;
     *
     * // setter
     * myListView.display = 'card';
     */
    display: 'list',

    /**
     * Enable drag and drop functionality.<br><br>
     * JET provides support for HTML5 Drag and Drop events.  Please refer to {@link https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Drag_and_drop third party documentation}
     * on HTML5 Drag and Drop to learn how to use it.
     *
     * @ojshortdesc Customizes the drag and drop functionality. See the Help documentation for more information.
     * @expose
     * @memberof! oj.ojListView
     * @type {Object}
     * @instance
     */
    dnd: {
      /**
       * Enables and customizes the drag functionality.
       *
       * @ojshortdesc Customizes the drag functionality.
       * @expose
       * @alias dnd.drag
       * @memberof! oj.ojListView
       * @instance
       * @type {Object}
       * @ojsignature { target: "Type",
       *                value: "?"}
       */
      drag: null,

      /**
       * @ojshortdesc Customizes the drop functionality.
       * @expose
       * @alias dnd.drop
       * @memberof! oj.ojListView
       * @instance
       * @type {Object}
       * @ojsignature { target: "Type", value: "?"}
       */
      drop: null,

      /**
       * The reorder option contains a subset of options for reordering items.
       *
       * @ojshortdesc Customizes the item reordering functionality.
       * @expose
       * @alias dnd.reorder
       * @memberof! oj.ojListView
       * @instance
       * @type {Object}
       */
      reorder: {
        /**
         * Enable or disable reordering the items within the same listview using drag and drop.<br><br>
         * Specify 'enabled' to enable reordering.  Setting the value 'disabled' or setting the <code class="prettyprint">"dnd"</code> property
         * to <code class="prettyprint">null</code> (or omitting it), disables reordering support.
         *
         * @ojshortdesc Specify the item reordering functionality. See the Help documentation for more information.
         * @expose
         * @alias dnd.reorder.items
         * @memberof! oj.ojListView
         * @instance
         * @type {string}
         * @ojvalue {string} "enabled" Item reordering is enabled.
         * @ojvalue {string} "disabled" Item reordering is disabled.
         * @default "disabled"
         *
         * @example <caption>Initialize the ListView with the <code class="prettyprint">reorder</code> attribute specified:</caption>
         * &lt;oj-list-view dnd.reorder.items='enabled'>&lt;/oj-list-view>
         *
         * @example <caption>Get or set the <code class="prettyprint">reorder</code> property after initialization:</caption>
         * // getter
         * var reorderValue = myListView.dnd.reorder.items;
         *
         * // setter
         * myListView.dnd.reorder.items = 'enabled';
         */
        items: 'disabled'
      }
    },

    /**
     * Changes the expand and collapse operations on ListView.  If "none" is specified, then
     * the current expanded state is fixed and user cannot expand or collapse an item.
     *
     * @ojshortdesc Specifies whether expand or collapse operations are allowed.
     * @expose
     * @memberof! oj.ojListView
     * @instance
     * @type {string}
     * @default "collapsible"
     * @ojvalue {string} "collapsible" Group item can be expanded or collapsed by user.
     * @ojvalue {string} "none" The expand state of a group item cannot be changed by user.
     *
     * @example <caption>Initialize the ListView with the <code class="prettyprint">drill-mode</code> attribute specified:</caption>
     * &lt;oj-list-view drill-mode='none'>&lt;/oj-list-view>
     *
     * @example <caption>Get or set the <code class="prettyprint">drillMode</code> property after initialization:</caption>
     * // getter
     * var drillModeValue = myListView.drillMode;
     *
     * // setter
     * myListView.drillMode = 'none';
     */
    drillMode: 'collapsible',

    /**
     * Specifies the key set containing the keys of the items that should be expanded.
     *
     * Use the <a href="ExpandedKeySet.html">ExpandedKeySet</a> class to specify items to expand.
     * Use the <a href="ExpandAllKeySet.html">ExpandAllKeySet</a> class to expand all items.
     *
     * @ojshortdesc Specifies the key set containing the keys of the items that should be expanded. See the Help documentation for more information.
     * @expose
     * @memberof! oj.ojListView
     * @instance
     * @default new ExpandedKeySet();
     * @type {KeySet}
     * @ojsignature {target:"Type", value:"oj.KeySet<K>"}
     *
     * @ojwriteback
     *
     * @example <caption>Initialize the ListView with specific items expanded:</caption>
     * myListView.expanded = new ExpandedKeySet(['item1', 'item2']);
     *
     * @example <caption>Initialize the ListView with all items expanded:</caption>
     * myListView.expanded = new ExpandAllKeySet();
     */
    expanded: new oj._ojListViewExpandedKeySet(),

    /**
     * Gets the key and data of the first selected item.  The first selected item is defined as the first
     * key returned by the <a href="#selection">selection</a> property.  The value of this property contains:
     * <ul>
     * <li>key - the key of the first selected item.</li>
     * <li>data - the data of the first selected item.  If the selected item is not locally available, this will
     *        be null.  If the <a href="#data">data</a> property is not set and that static HTML element is used
     *        as data, then this will be the item element.</li>
     * </ul>
     * If no items are selected then this property will return an object with both key and data properties set to null.
     *
     * @expose
     * @ojshortdesc Specifies the key and data of the first selected item. See the Help documentation for more information.
     * @memberof! oj.ojListView
     * @instance
     * @default {'key': null, 'data': null}
     * @type {Object}
     * @ojsignature {target:"Type", value:"CommonTypes.ItemContext<K,D>", jsdocOverride:true}
     *
     * @ojwriteback
     * @readonly
     *
     * @example <caption>Get the data of the first selected item:</caption>
     * // getter
     * var firstSelectedItemValue = myListView.firstSelectedItem;
     */
    firstSelectedItem: {
      key: null,
      data: null
    },

    /**
     * The gridlines option contains a subset of options for gridlines.
     *
     * @ojshortdesc Customizes the functionality of how gridlines are shown in various parts of the list.
     * @expose
     * @memberof! oj.ojListView
     * @type {Object}
     * @instance
     */
    gridlines: {
      /**
       * Specifies whether the horizontal grid lines should be visible.  Note this attribute has no effect when ListView is in card display mode.
       * <p>The default value varies by theme and is determined as follows:
       * <ul>
       *   <li>if <code class="prettyprint">$listViewGridlinesItemOptionDefault</code> is set in the current theme as seen in the example below, then that value is the gridlines default.</li>
       *   <li>Else, the default value is <code class="prettyprint">"visible"</code>.</li>
       * </ul>
       * <p>Once a value has been set on this attribute, that value applies regardless of theme.
       *
       * @ojshortdesc Specifies whether the grid lines should be visible.
       * @expose
       * @alias gridlines.item
       * @memberof! oj.ojListView
       * @instance
       * @default "visible"
       * @type {string}
       * @ojvalue {string} "visible" The horizontal gridlines are visible.
       * @ojvalue {string} "visibleExceptLast" The horizontal gridlines are visible, except for the last item.  Note this will not have an effect for themes that renders a bottom border for the component.
       * @ojvalue {string} "hidden" The horizontal gridlines are hidden.
       *
       * @example <caption>Initialize the ListView with the <code class="prettyprint">gridlines</code> attribute specified:</caption>
       * &lt;oj-list-view gridlines.item='visible'>&lt;/oj-list-view>
       *
       * @example <caption>Get or set the <code class="prettyprint">gridlines</code> property after initialization:</caption>
       * // getter
       * var gridlinesValue = myListView.gridlines.item;
       *
       * // setter
       * myListView.gridlines.item = 'visible';
       *
       * @example <caption>Set the default in the theme (SCSS) :</caption>
       * $listViewGridlinesItemOptionDefault: hidden !default;
       */
      item: 'visible'
    },

    /**
     * Specifies how the group header should be positioned.  If "sticky" is specified, then the group header
     * is fixed at the top of the ListView as the user scrolls.
     *
     * @ojshortdesc Specifies whether group header should stick to the top as user scrolls.
     * @expose
     * @memberof! oj.ojListView
     * @instance
     * @default "sticky"
     * @type {string}
     * @ojvalue {string} "static" The group header position updates as user scrolls.
     * @ojvalue {string} "sticky" The group header is fixed at the top when user scrolls.
     *
     * @example <caption>Initialize the ListView with the <code class="prettyprint">group-header-position</code> attribute specified:</caption>
     * &lt;oj-list-view group-header-position='static'>&lt;/oj-list-view>
     *
     * @example <caption>Get or set the <code class="prettyprint">groupHeaderPosition</code> property after initialization:</caption>
     * // getter
     * var groupHeaderPositionValue = myListView.groupHeaderPosition;
     *
     * // setter
     * myListView.groupHeaderPosition = 'static';
     */
    groupHeaderPosition: 'sticky',

    /**
     * The item option contains a subset of options for items.
     *
     * @ojshortdesc Customizes the functionality of each item on the list.
     * @expose
     * @memberof! oj.ojListView
     * @type {Object}
     * @instance
     */
    item: {
      /**
       * @typedef {Object} oj.ojListView.ItemContext
       * @property {oj.DataProvider<K, D>} datasource the data source/data provider
       * @property {number} index the zero based index of the item, relative to its parent
       * @property {K} key the key of the item
       * @property {D} data the data object of the item
       * @property {oj.ItemMetadata<K>} metadata the metadata object of the item
       * @property {Element} parentElement the item DOM element
       * @property {number=} depth the depth of the item
       * @property {K=} parentKey the key of the parent item
       * @property {boolean=} leaf whether the item is a leaf
       * @ojsignature [{target:"Type", value:"<K,D>", for:"genericTypeParameters"}]
       */

      /**
       * Whether the item is focusable.  An item that is not focusable cannot be clicked on or navigated to.
       * See <a href="#context-section">itemContext</a> in the introduction to see the object passed into the focusable function.
       *
       * @ojshortdesc Specifies whether the item can receive keyboard focus. See the Help documentation for more information.
       * @expose
       * @alias item.focusable
       * @memberof! oj.ojListView
       * @instance
       * @type {boolean|function(Object):boolean}
       * @ojsignature { target: "Type",
       *                value: "?((param0: oj.ojListView.ItemContext<K,D>) => boolean)|boolean",
       *                jsdocOverride: true}
       * @default true
       *
       * @example <caption>Initialize the ListView with the <code class="prettyprint">focusable</code> attribute specified:</caption>
       * &lt;oj-list-view item.focusable='{{myFocusableFunc}}'>&lt;/oj-list-view>
       *
       * @example <caption>Get or set the <code class="prettyprint">focusable</code> property after initialization:</caption>
       * // getter
       * var focusable = myListView.item.focusable;
       *
       * // setter
       * myListView.item.focusable = myFocusableFunc;
       */
      focusable: true,

      /**
       * The renderer function that renders the content of the item. See <a href="#context-section">itemContext</a>
       * in the introduction to see the object passed into the renderer function.
       * The function should return one of the following:
       * <ul>
       *   <li>An Object with the following property:
       *     <ul><li>insert: HTMLElement | string - A string or a DOM element of the content inside the item.</li></ul>
       *   </li>
       *   <li>undefined: If the developer chooses to manipulate the list element directly, the function should return undefined.</li>
       * </ul>
       * If no renderer is specified, ListView will treat the data as a string.
       *
       * @ojshortdesc Specifies the renderer for the item. See the Help documentation for more information.
       * @expose
       * @alias item.renderer
       * @memberof! oj.ojListView
       * @instance
       * @type {null|function(Object):Object}
       * @ojsignature { target: "Type",
       *                value: "?((param0: oj.ojListView.ItemContext<K,D>) => {insert: Element|string}|undefined)|null",
       *                jsdocOverride: true}
       * @default null
       *
       * @example <caption>Initialize the ListView with the <code class="prettyprint">renderer</code> attribute specified:</caption>
       * &lt;oj-list-view item.renderer='{{myRendererFunc}}'>&lt;/oj-list-view>
       *
       * @example <caption>Get or set the <code class="prettyprint">renderer</code> property after initialization:</caption>
       * // getter
       * var renderer = myListView.item.renderer;
       *
       * // setter
       * myListView.item.renderer = myRendererFunc;
       */
      renderer: null,

      /**
       * Whether the item is selectable.  Note that if selectionMode is set to "none" this option is ignored.  In addition,
       * if focusable is set to false, then the selectable option is automatically overridden and set to false also.
       * See <a href="#context-section">itemContext</a> in the introduction to see the object passed into the selectable function.
       *
       * @ojshortdesc Specifies whether the item can be selected. See the Help documentation for more information.
       * @expose
       * @alias item.selectable
       * @memberof! oj.ojListView
       * @instance
       * @type {boolean|function(Object):boolean}
       * @ojsignature { target: "Type",
       *                value: "?((param0: oj.ojListView.ItemContext<K,D>) => boolean)|boolean",
       *                jsdocOverride: true}
       * @default true
       *
       * @example <caption>Initialize the ListView with the <code class="prettyprint">selectable</code> attribute specified:</caption>
       * &lt;oj-list-view item.selectable='{{mySelectableFunc}}'>&lt;/oj-list-view>
       *
       * @example <caption>Get or set the <code class="prettyprint">selectable</code> property after initialization:</caption>
       * // getter
       * var selectable = myListView.item.selectable;
       *
       * // setter
       * myListView.item.selectable = mySelectableFunc;
       */
      selectable: true
      /**
       * The knockout template used to render the content of the item.
       *
       * This attribute is only exposed via the <code class="prettyprint">ojComponent</code> binding, and is not a
       * component option.
       *
       * @ojbindingonly
       * @name item.template
       * @memberof! oj.ojListView
       * @instance
       * @type {string|null}
       * @default null
       *
       * @example <caption>Specify the <code class="prettyprint">template</code> when initializing ListView:</caption>
       * // set the template
       * &lt;ul id="listview" data-bind="ojComponent: {component: 'ojListView', data: dataSource, item: {template: 'my_template'}}"&gt;&lt;/ul&gt;
       */

    },

    /**
     * Specifies the mechanism used to scroll the data inside the list view. Possible values are: "auto", "loadMoreOnScroll", and "loadAll".
     * When "loadMoreOnScroll" is specified, additional data is fetched when the user scrolls to the bottom of the ListView.
     * Note that currently this option is only available when non-hierarchical DataProvider is used.
     * When "loadAll" is specified, ListView will fetch all the data when it is initially rendered.
     * If you are using Paging Control with the ListView, please note that "loadMoreOnScroll" scroll-policy is not compatible with
     * Paging Control "loadMore" mode.
     *
     * @ojshortdesc Specifies how data are fetched as user scrolls down the list.
     * @expose
     * @memberof! oj.ojListView
     * @instance
     * @type {string|null}
     * @default "auto"
     * @ojvalue {string} "auto" The behavior is determined by the component.  By default the behavior is the same as "loadMoreOnScroll" except
     *                          when legacy TableDataSource is used, in which case the behavior is the same as "loadAll".
     * @ojvalue {string} "loadAll" Fetch and render all data.
     * @ojvalue {string} "loadMoreOnScroll" Additional data is fetched when the user scrolls towards the bottom of the ListView.
     *                    <br/>Not compatible when used with Paging Control "loadMore" mode.
     *
     * @example <caption>Initialize the ListView with the <code class="prettyprint">scroll-policy</code> attribute specified:</caption>
     * &lt;oj-list-view scroll-policy='loadMoreOnScroll'>&lt;/oj-list-view>
     *
     * @example <caption>Get or set the <code class="prettyprint">scrollPolicy</code> property after initialization:</caption>
     * // getter
     * var scrollPolicyValue = myListView.scrollPolicy;
     *
     * // setter
     * myListView.scrollPolicy = 'loadMoreOnScroll';
     */
    scrollPolicy: 'auto',

    /**
     * scrollPolicy options.
     * <p>
     * The following options are supported:
     * <ul>
     *   <li>fetchSize: The number of items fetched each time when scroll to the end.</li>
     *   <li>maxCount: Maximum rows which will be displayed before fetching more rows will be stopped.</li>
     *   <li>scroller: The element which listview uses to determine the scroll position as well as the maximum scroll position where scroll to the end will trigger a fetch.  If not specified then the widget element of listview is used.</li>
     * </ul>
     * When scrollPolicy is loadMoreOnScroll, the next block of rows is fetched
     * when the user scrolls to the end of the list/scroller. The fetchSize option
     * determines how many rows are fetched in each block.
     * Note that currently this option is only available when non-hierarchical DataProvider or TableDataSource is used.
     *
     * @ojshortdesc Specifies fetch options for scrolling behaviors that trigger data fetches. See the Help documentation for more information.
     * @expose
     * @instance
     * @memberof! oj.ojListView
     * @type {Object.<string, number>|null}
     *
     * @example <caption>Initialize the ListView with the <code class="prettyprint">scroll-policy-options</code> attribute specified:</caption>
     * &lt;oj-list-view scroll-policy-options.fetch-size='30'>&lt;/oj-list-view>
     *
     * @example <caption>Get or set the <code class="prettyprint">scroll-policy-options</code> attribute after initialization:</caption>
     * // getter
     * var fetchSizeValue = myListView.scrollPolicyOptions.fetchSize;
     *
     * // setter
     * myListView.scrollPolicyOptions.fetchSize = 30;
      * @example <caption>Initialize the ListView with the <code class="prettyprint">scroll-policy-options</code> attribute specified:</caption>
     * &lt;!-- Using dot notation -->
     * &lt;oj-list-view scroll-policy-options.fetch-size='30' scroll-policy-options.max-count='1000'>&lt;/oj-list-view>
     *
     * @example <caption>Get or set the <code class="prettyprint">scrollPolicyOptions</code> property after initialization:</caption>
     * // Get one
     * var fetchSizeValue = myListView.scrollPolicyOptions.fetchSize;
     *
     * // Get all
     * var scrollPolicyOptionsValues = myListView.scrollPolicyOptions;
     *
     * // Set one, leaving the others intact
     * myListView.setProperty('scrollPolicyOptions.fetchSize', 30);
     *
     * // Set all.
     * myListView.scrollPolicyOptions = {fetchSize: 30, maxCount: 1000};
     */
    scrollPolicyOptions: {
      fetchSize: 25,
      maxCount: 500
    },

    /**
     * The current scroll position of ListView. The scroll position is updated when either the vertical or horizontal scroll position
     * (or its scroller, as specified in scrollPolicyOptions.scroller) has changed.  The value contains the x and y scroll position,
     * the index and key information of the item closest to the top of the viewport, as well as horizontal and vertical offset from the
     * position of the item to the actual scroll position.
     * <p>
     * The default value contains just the scroll position.  Once data is fetched the 'index' and 'key' sub-properties will be added.
     * If there is no data then the 'index' and 'key' sub-properties will not be available.
     * </p>
     * <p>
     * When setting the scrollPosition property, applications can change any combination of the sub-properties.
     * If multiple sub-properties are set at once they will be used in key, index, pixel order where the latter serves as hints.
     * If offsetX or offsetY are specified, they will be used to adjust the scroll position from the position where the key or index
     * of the item is located.
     * </p>
     * <p>
     * If a sparse object is set the other sub-properties will be populated and updated once ListView has scrolled to that position.
     * </p>
     * <p>
     * Also, if <a href="#scrollPolicy">scrollPolicy</a> is set to 'loadMoreOnScroll' and the scrollPosition is set to a value outside
     * of the currently rendered region, then ListView will attempt to fetch until the specified scrollPosition is satisfied or the end
     * is reached (either at max count or there's no more items to fetch), in which case the scroll position will remain at the end.
     * The only exception to this is when the key specified does not exists and a DataProvider is specified for <a href="#data">data</a>,
     * then the scroll position will not change (unless other sub-properties like index or x/y are specified as well).
     * </p>
     * Lastly, when a re-rendered is triggered by a <a href="oj.DataProviderRefreshEvent.html">refresh event</a> from the DataProvider,
     * or if the value for <a href="#data">data</a> attribute has changed, then the scrollPosition will be adjusted such that the selection
     * anchor (typically the last item selected by the user) prior to refresh will appear at the top of the viewport after refresh.  If
     * selection is disabled or if there is no selected items, then the scrollPosition will remain at the top.
     * </p>
     *
     * @ojshortdesc Specifies the current scroll position of the list. See the Help documentation for more information.
     * @expose
     * @memberof! oj.ojListView
     * @instance
     * @type {Object}
     * @default {"x": 0, "y": 0}
     * @property {number=} x the horizontal position in pixels
     * @property {number=} y the vertical position in pixels
     * @property {number=} index the zero-based index of the item.  If <a href="#scrollPolicy">scrollPolicy</a> is set to 'loadMoreOnScroll'
     * and the index is greater than maxCount set in <a href="#scrollPolicyOptions">scrollPolicyOptions</a>, then it will scroll and fetch
     * until the end of the list is reached and there's no more items to fetch.
     * @property {any=} parent the key of the parent where the index is relative to.  If not specified, then the root is assumed
     * @property {any=} key the key of the item.  If DataProvider is used for <a href="#data">data</a> and the key does not exists in the
     * DataProvider, then the value is ignored.  If DataProvider is not used then ListView will fetch and scroll until the item is found
     * or the end of the list is reached and there's no more items to fetch.
     * @property {number=} offsetX the horizontal offset in pixels relative to the item identified by key/index.
     * @property {number=} offsetY the vertical offset in pixels relative to the item identified by key/index.
     *
     * @ojsignature [{target:"Type", value:"K", for:"parent"},
     *               {target:"type", value:"K", for:"key"}]
     * @ojwriteback
     * @example <caption>Initialize the ListView with the <code class="prettyprint">scroll-position</code> attribute specified:</caption>
     * &lt;!-- Using dot notation -->
     * &lt;oj-list-view scroll-position.index='10'>&lt;/oj-list-view>
     *
     * &lt;!-- Using JSON notation -->
     * &lt;oj-list-view scroll-position='{"index": 10}'>&lt;/oj-list-view>
     *
     * @example <caption>Get or set the <code class="prettyprint">scrollPosition</code> property after initialization:</caption>
     * // Get one
     * var scrollPositionValue = myListView.scrollPosition.index;
     *
     * // Set one, leaving the others intact
     * myListView.setProperty('scrollPosition.index', 10);
     *
     * // Get all
     * var scrollPositionValues = myListView.scrollPosition;
     *
     * // Set all.  Those not listed will be lost until the scroll completes and the remaining fields are populated.
     * myListView.scrollPosition = {x: 0, y: 150};
     */
    scrollPosition: {
      x: 0,
      y: 0
    },

    /**
     * The vertical scroll position of ListView.
     *
     * @ignore
     * @expose
     * @memberof! oj.ojListView
     * @instance
     * @type {number}
     * @default 0
     *
     * @example <caption>Initialize the list view to a specific scroll position:</caption>
     * $( ".selector" ).ojListView({ "scrollTop": 100 });
     */
    scrollTop: 0,

    /**
     * The current selected items in the ListView. An empty KeySet indicates nothing is selected.
     * Note that property change event for the deprecated selection property will still be fire when
     * selected property has changed. In addition, <a href="AllKeySetImpl.html">AllKeySetImpl</a> set
     * can be used to represent select all state. In this case, the value for selection would have an
     * 'inverted' property set to true, and would contain the keys of the items that are not selected.
     *
     * @ojshortdesc Specifies the keys of the current selected items. See the Help documentation for more information.
     * @expose
     * @memberof! oj.ojListView
     * @instance
     * @default new KeySetImpl();
     * @type {KeySet}
     * @ojsignature {target:"Type", value:"oj.KeySet<K>"}
     * @ojwriteback
     * @ojeventgroup common
     *
     * @example <caption>Initialize the ListView with the <code class="prettyprint">selected</code> attribute specified:</caption>
     * &lt;oj-list-view selected='{{mySelectedItemsKeySet}}'>&lt;/oj-list-view>
     *
     * @example <caption>Get or set the <code class="prettyprint">selected</code> property after initialization:</caption>
     * // getter
     * var selectedValue = myListView.selected;
     *
     * // setter
     * myListView.selected = ['item1', 'item2', 'item3'];
     */
    selected: new oj.KeySetImpl(),

    /**
     * The current selections in the ListView. An empty array indicates nothing is selected.
     *
     * @ojshortdesc Specifies the current selections in the list. See the Help documentation for more information.
     * @expose
     * @memberof! oj.ojListView
     * @instance
     * @type {Array.<any>}
     * @ojsignature {target:"Type", value:"Array<K>"}
     * @default []
     * @ojwriteback
     * @ojdeprecated {since: '7.0.0', description: 'Use selected attribute instead.'}
     *
     * @example <caption>Initialize the ListView with the <code class="prettyprint">selection</code> attribute specified:</caption>
     * &lt;oj-list-view selection='{{mySelection}}'>&lt;/oj-list-view>
     *
     * @example <caption>Get or set the <code class="prettyprint">selection</code> property after initialization:</caption>
     * // getter
     * var selectionValue = myListView.selection;
     *
     * // setter
     * myListView.selection = ['item1', 'item2', 'item3'];
     */
    selection: [],

    /**
     * <p>The type of selection behavior that is enabled on the ListView. This attribute controls the number of selections that can be made via selection gestures at any given time.
     *
     * <p>If <code class="prettyprint">single</code> or <code class="prettyprint">multiple</code> is specified, selection gestures will be enabled, and the ListView's selection styling will be applied to all items specified by the <a href="#selection">selection</a> and <a href="#selected">selected</a> attributes.
     * If <code class="prettyprint">none</code> is specified, selection gestures will be disabled, and the ListView's selection styling will not be applied to any items specified by the <a href="#selection">selection</a> and <a href="#selected">selected</a> attributes.
     *
     * <p>Changing the value of this attribute will not affect the value of the <a href="#selection">selection</a> or <a href="#selected">selected</a> attributes.
     *
     * @ojshortdesc Specifies the selection mode.
     * @expose
     * @memberof! oj.ojListView
     * @instance
     * @type {string}
     * @default "none"
     * @ojvalue {string} "none" Selection is disabled.
     * @ojvalue {string} "single" Only a single item can be selected at a time.
     * @ojvalue {string} "multiple" Multiple items can be selected at the same time.
     *
     * @example <caption>Initialize the ListView with the <code class="prettyprint">selection-mode</code> attribute specified:</caption>
     * &lt;oj-list-view selection-mode='multiple'>&lt;/oj-list-view>
     *
     * @example <caption>Get or set the <code class="prettyprint">selectionMode</code> property after initialization:</caption>
     * // getter
     * var selectionModeValue = myListView.selectionMode;
     *
     * // setter
     * myListView.selectionMode = 'multiple';
     */
    selectionMode: 'none',

    /**
     * <p>Specifies whether selection is required on the ListView. This attribute will only take effect when selection is enabled and at least
     * one selectable item is present. When <code class="prettyprint">true</code>, the ListView will ensure that at least one valid item is
     * selected at all times. If no items are specified by the <a href="#selection">selection</a> or <a href="#selected">selected</a> attributes,
     * the first selectable item in the ListView will be added to the selection state during initial render. Additionally, selection gestures that
     * would otherwise leave the ListView with no selected items will be disabled.
     *
     * <p>When <code class="prettyprint">true</code>, the ListView will also attempt to validate all items specified by the
     * <a href="#selection">selection</a> and <a href="#selected">selected</a> attributes. If any items specified are not immediately
     * available, the ListView's underlying <a href="oj.DataProvider.html">DataProvider</a> will be queried. This will only occur if the
     * data provider supports <a href="oj.DataProvider.html#getCapability">getCapability</a>, and returns a
     * <a href="oj.FetchByKeysCapability.html#implementation">fetchByKeys capability implementation</a> of <code class="prettyprint">lookup</code>.
     * Any items that fail this validation process will be removed from the <a href="#selection">selection</a> and <a href="#selected">selected</a>
     * attributes. This guarantees that the ListView's <a href="#firstSelectedItem">firstSelectedItem</a> attribute is populated at all times.
     *
     * <p>See <a href="#selectionMode">selectionMode</a> for information on how to enable or disable selection on the ListView.
     * <p>See <a href="#item.selectable">item.selectable</a> for information on how to enable or disable selection for individual items.
     *
     * @ojshortdesc Specifies whether selection is required on the ListView.
     * @expose
     *
     * @memberof! oj.ojListView
     * @instance
     * @type {boolean}
     * @default false
     *
     * @example <caption>Initialize the ListView with the <code class="prettyprint">selection-required</code> attribute specified:</caption>
     * &lt;oj-list-view selection-required='true'>&lt;/oj-list-view>
     *
     * @example <caption>Get or set the <code class="prettyprint">selectionRequired</code> property after initialization:</caption>
     * // getter
     * var selectionRequiredValue = myListView.selectionRequired;
     *
     * // setter
     * myListView.selectionRequired = true;
     */
    selectionRequired: false,

    /**
     * Triggered when the default animation of a particular action is about to start.  The default animation can be cancelled by calling event.preventDefault.
     *
     * @ojshortdesc Triggered when the default animation of a particular action is about to start.
     * @expose
     * @event
     * @memberof oj.ojListView
     * @instance
     * @property {string} action the action that triggers the animation.<br><br>See <a href="#animation-section">animation</a> section for a list of actions.
     * @property {Element} element the target of animation.
     * @property {function():void} endCallback if the event listener calls event.preventDefault to cancel the default animation, it must call the endCallback function when it finishes its own animation handling and when any custom animation ends.
     */
    animateStart: null,

    /**
     * Triggered when the default animation of a particular action has ended. Note this event will not be triggered if application cancelled the default animation on animateStart.
     *
     * @ojshortdesc Triggered when the default animation of a particular action has ended.
     * @expose
     * @event
     * @memberof oj.ojListView
     * @instance
     * @property {string} action the action that triggered the animation.<br><br>See <a href="#animation-section">animation</a> section for a list of actions.
     * @property {Element} element the target of animation.
     */
    animateEnd: null,

    /**
     * Triggered before the current item is changed via the <code class="prettyprint">current</code> option or via the UI.
     *
     * @ojshortdesc Triggered before the current item is changed.
     * @ojcancelable
     * @expose
     * @event
     * @memberof oj.ojListView
     * @instance
     * @property {any} previousKey the key of the previous item
     * @property {Element} previousItem the previous item
     * @property {any} key the key of the new current item
     * @property {Element} item the new current item
     * @ojsignature [{target:"Type", value:"<K>", for:"genericTypeParameters"},
     *               {target:"Type", value:"K", for:"previousKey"},
     *               {target:"Type", value:"K", for:"key"}]
     */
    beforeCurrentItem: null,

    /**
     * Triggered before an item is expanded via the <code class="prettyprint">expanded</code> option,
     * the <code class="prettyprint">expand</code> method, or via the UI.
     *
     * @ojshortdesc Triggered before an item is expanded.
     * @ojcancelable
     * @expose
     * @event
     * @memberof oj.ojListView
     * @instance
     * @property {any} key the key of the item to be expanded
     * @property {Element} item the item to be expanded
     * @ojsignature [{target:"Type", value:"<K>", for:"genericTypeParameters"},
     *               {target:"Type", value:"K", for:"key"}]
     */
    beforeExpand: null,

    /**
     * Triggered before an item is collapsed via the <code class="prettyprint">expanded</code> option,
     * the <code class="prettyprint">collapse</code> method, or via the UI.
     *
     * @ojshortdesc Triggered before an item is collapsed.
     * @ojcancelable
     * @expose
     * @event
     * @memberof oj.ojListView
     * @instance
     * @property {any} key the key of the item to be collapsed
     * @property {Element} item the item to be collapsed
     * @ojsignature [{target:"Type", value:"<K>", for:"genericTypeParameters"},
     *               {target:"Type", value:"K", for:"key"}]
     */
    beforeCollapse: null,

    /**
     * Triggered after an item has been collapsed via the <code class="prettyprint">expanded</code> option or via the UI.
     * Note if the collapse is triggered by updating the expanded option, applications should avoid vetoing the beforeCollapse event.
     * In addition, due to internal optimizations, when multiple items are collapsed due to update of expanded option,
     * there is no guarantee that this event will be fired for all the collapsible items.
     *
     * @ojshortdesc Triggered after an item has been collapsed. See the Help documentation for more information.
     * @expose
     * @event
     * @memberof oj.ojListView
     * @instance
     * @property {any} key The key of the item that was just collapsed.
     * @property {Element} item The list item that was just collapsed.
     * @ojsignature [{target:"Type", value:"<K>", for:"genericTypeParameters"},
     *               {target:"Type", value:"K", for:"key"}]
     */
    collapse: null,

    /**
     * Triggered when the copy action is performed on an item via context menu or keyboard shortcut.
     *
     * @ojshortdesc Triggered when the copy action is performed on an item.
     * @expose
     * @event
     * @memberof oj.ojListView
     * @instance
     * @property {Element[]} items an array of items in which the copy action is performed on
     */
    copy: null,

    /**
     * Triggered when the cut action is performed on an item via context menu or keyboard shortcut.
     *
     * @ojshortdesc Triggered when the cut action is performed on an item.
     * @expose
     * @event
     * @memberof oj.ojListView
     * @instance
     * @property {Element[]} items an array of items in which the cut action is performed on
     */
    cut: null,

    /**
     * Triggered after an item has been expanded via the <code class="prettyprint">expanded</code> option or via the UI.
     * Note if the expand is triggered by updating the expanded option, applications should avoid vetoing the beforeExpand event.
     * In addition, due to internal optimizations, when multiple items are collapsed due to update of expanded option,
     * there is no guarantee that this event will be fired for all the expandable items.
     *
     * @ojshortdesc Triggered after an item has been expanded. See the Help documentation for more information.
     * @expose
     * @event
     * @memberof oj.ojListView
     * @instance
     * @property {any} key The key of the item that was just expanded.
     * @property {Element} item The list item that was just expanded.
     * @ojsignature [{target:"Type", value:"<K>", for:"genericTypeParameters"},
     *               {target:"Type", value:"K", for:"key"}]
     */
    expand: null,

    /**
     * Triggered when user performs an action gesture on an item while ListView is in navigation mode.  The action gestures include:
     * <ul>
     *   <li>User clicks anywhere in an item</li>
     *   <li>User taps anywhere in an item</li>
     *   <li>User pressed enter key while an item or its content has focus</li>
     * </ul>
     *
     * @ojshortdesc Triggered when user performs an action gesture on an item.
     * @expose
     * @event
     * @ojbubbles
     * @memberof oj.ojListView
     * @instance
     * @property {any} context the context information about the item where the action gesture is performed on.
     * @property {Event} originalEvent the DOM event that triggers the action.
     * @ojsignature [{target:"Type", value:"<K,D>", for:"genericTypeParameters"},
     *               {target:"Type", value:"CommonTypes.ItemContext<K,D>", for:"context", jsdocOverride:true}]
     */
    itemAction: null,

    /**
     * Triggered when the paste action is performed on an item via context menu or keyboard shortcut.
     *
     * @ojshortdesc Triggered when the paste action is performed on an item.
     * @expose
     * @event
     * @memberof oj.ojListView
     * @instance
     * @property {Element} item the element in which the paste action is performed on
     */
    paste: null,

    /**
     * Triggered after all items in the ListView has been rendered.  Note that in the high-water mark scrolling case,
     * all items means the items that are fetched so far.
     *
     * @ignore
     * @event
     * @deprecated 2.0.0 Use the <a href="#whenReady">whenReady</a> method instead.
     * @memberof oj.ojListView
     * @instance
     * @property {Event} event <code class="prettyprint">jQuery</code> event object
     * @property {Object} ui Parameters
     *
     * @example <caption>Initialize the ListView with the <code class="prettyprint">ready</code> callback specified:</caption>
     * $( ".selector" ).ojListView({
     *     "ready": function( event, ui ) {}
     * });
     *
     * @example <caption>Bind an event listener to the <code class="prettyprint">ojready</code> event:</caption>
     * $( ".selector" ).on( "ojready", function( event, ui ) {
     *     // verify that the component firing the event is a component of interest
     *     if ($(event.target).is(".mySelector")) {}
     * });
     */
    ready: null,

    /**
     * Triggered after items are reorder within listview via drag and drop or cut and paste.
     *
     * @ojshortdesc Triggered after items are reordered, whether through a drag and drop action or a cut and paste action.
     * @expose
     * @event
     * @memberof oj.ojListView
     * @instance
     * @property {Element[]} items an array of items that are moved
     * @property {string} position the drop position relative to the reference item.  Possible values are "before", "after", "inside"
     * @property {Element} reference the item where the moved items are drop on
     */
    reorder: null
  },

  /**
   * Create the listview
   * @override
   * @memberof! oj.ojListView
   * @protected
   */
  _ComponentCreate: function _ComponentCreate() {
    this._super();

    this._setup();
  },

  /**
   * Initialize the listview
   * @private
   */
  _setup: function _setup() {
    var opts = {};
    opts.element = this.element;
    opts.OuterWrapper = this.OuterWrapper;
    opts.ojContext = this; // for backward compatibility, the default for expanded for legacy syntax
    // should be the same as before

    if (!this._IsCustomElement()) {
      var expanded = this.options.expanded; // check if it's been updated by applications

      if (expanded instanceof oj._ojListViewExpandedKeySet) {
        this.options.expanded = 'auto';
      }
    }

    opts = $.extend(this.options, opts);
    this.listview = new oj._ojListView();
    this.listview.init(opts);
    DataCollectionUtils.disableDefaultBrowserStyling(this.element[0]);
  },

  /**
   * Initialize the listview after creation
   * @protected
   * @override
   * @memberof! oj.ojListView
   */
  _AfterCreate: function _AfterCreate() {
    this._super(); // inject helper function for ContentHandler and custom renderer to use


    var self = this;

    this.listview._FixRendererContext = function (context) {
      return self._FixRendererContext(context);
    };

    this.listview._WrapCustomElementRenderer = function (renderer) {
      return self._WrapCustomElementRenderer(renderer);
    };

    this.listview.afterCreate();
  },

  /**
   * Sets up resources needed by listview
   * @memberof! oj.ojListView
   * @instance
   * @override
   * @protected
   */
  _SetupResources: function _SetupResources() {
    this._super();

    this.listview.setupResources();
  },

  /**
   * Release resources held by listview
   * @memberof! oj.ojListView
   * @instance
   * @override
   * @protected
   */
  _ReleaseResources: function _ReleaseResources() {
    this._super();

    this.listview.releaseResources();
  },

  /**
   * Gets the focus element
   * @override
   * @memberof! oj.ojListView
   * @instance
   * @protected
   * @since 5.0.0
   */
  GetFocusElement: function GetFocusElement() {
    return this.listview != null ? this.listview.GetFocusElement() : this._super();
  },

  /**
   * Destroy the list view
   * @memberof! oj.ojListView
   * @private
   */
  _destroy: function _destroy() {
    this.listview.destroy();

    this._super();
  },

  /**
   * When the <a href="#contextMenu">contextMenu</a> option is set, this method is called when the user invokes the context menu via
   * the default gestures: right-click, pressHold, and <kbd>Shift-F10</kbd>.  Components should not call this method directly.
   *
   * @param {!Object} menu The JET Menu to open as a context menu.  Always non-<code class="prettyprint">null</code>.
   * @param {!Event} event What triggered the menu launch.  Always non-<code class="prettyprint">null</code>.
   * @param {string} eventType "mouse", "touch", or "keyboard".  Never <code class="prettyprint">null</code>.
   * @private
   */
  _NotifyContextMenuGesture: function _NotifyContextMenuGesture(menu, event, eventType) {
    this.listview.notifyContextMenuGesture(menu, event, eventType);
  },

  /**
   * Sets multiple options
   * @param {Object} options the options object
   * @param {Object} flags additional flags for option
   * @override
   * @private
   */
  _setOptions: function _setOptions(options, flags) {
    if (!this.listview.isAvailable()) {
      // ListView might have been detached, just update the options.  When ListView becomes available again, the update options will take effect.
      this._super(options, flags);

      return;
    }

    var needRefresh = this.listview.setOptions(options, flags); // updates the options last

    this._super(options, flags);

    if (needRefresh) {
      if (options.data) {
        this.listview.adjustScrollPositionValueOnRefresh();
      }

      this.listview.refresh();
    } else if (options.selectionRequired || options.selection || options.selectionMode) {
      // if listview is not refresh, we'll need to ensure selectionRequired is enforced if set to true
      this.listview.enforceSelectionRequired();
    }
  },

  /**
   * Sets a single option
   * @param {Object} key the key for the option
   * @param {Object} value the value for the option
   * @param {Object} flags any flags specified for the option
   * @override
   * @private
   */
  _setOption: function _setOption(key, value, flags) {
    // checks whether value is valid for the key
    var valid = true;
    var extraData;

    if (key === 'selectionMode') {
      valid = value === 'none' || value === 'single' || value === 'multiple';
    } else if (key === 'drillMode') {
      valid = value === 'collapsible' || value === 'none';
    } else if (key === 'scrollPolicy') {
      valid = value === 'auto' || value === 'loadMoreOnScroll' || value === 'loadAll';
    } else if (key === 'groupHeaderPosition') {
      valid = value === 'static' || value === 'sticky';
    } else if (key === 'firstSelectedItem') {
      // read only
      valid = false;
    } // update option if it's valid otherwise throw an error


    if (valid) {
      if (this.listview.isAvailable()) {
        // inject additional metadata for selection
        if (key === 'selection') {
          extraData = this.listview.getItems(value); // eslint-disable-next-line no-param-reassign

          flags = {
            _context: {
              extraData: {
                items: this._IsCustomElement() ? extraData : $(extraData)
              }
            }
          };
        } else if (key === 'currentItem') {
          extraData = this.listview.getItems([value])[0]; // eslint-disable-next-line no-param-reassign

          flags = {
            _context: {
              extraData: {
                items: this._IsCustomElement() ? extraData : $(extraData)
              }
            }
          };
        }
      }

      this._super(key, value, flags);
    } else {
      throw new Error('Invalid value: ' + value + ' for key: ' + key);
    }
  },

  /**
   * Invoked when application calls oj.Components.subtreeAttached.
   * @override
   * @private
   */
  _NotifyAttached: function _NotifyAttached() {
    this.listview.notifyAttached();
  },

  /**
   * In browsers [Chrome v35, Firefox v24.5, IE9, Safari v6.1.4], blur and mouseleave events are generated for hidden content but not detached content,
   * so for detached content only, we must use this hook to remove the focus and hover classes.
   * @override
   * @private
   */
  _NotifyDetached: function _NotifyDetached() {
    this.listview.notifyDetached();
  },

  /**
   * Invoked when application calls oj.Components.subtreeShown.
   * @override
   * @private
   */
  _NotifyShown: function _NotifyShown() {
    this.listview.notifyShown();
  },

  /**
   * Override to do the delay connect/disconnect
   * @memberof oj.ojListView
   * @override
   * @protected
   */
  _VerifyConnectedForSetup: function _VerifyConnectedForSetup() {
    return true;
  },

  /** ******************************* public methods **************************************/

  /**
   * Returns a jQuery object containing the root dom element of the listview.
   *
   * <p>This method does not accept any arguments.
   *
   * @ignore
   * @expose
   * @override
   * @memberof oj.ojListView
   * @instance
   * @return {jQuery} the root DOM element of list
   */
  widget: function widget() {
    return this.listview.GetRootElement();
  },

  /**
   * Redraw the entire list view after having made some external modifications.
   *
   * <p>This method does not accept any arguments.
   *
   * @ojshortdesc Redraw the entire list.
   * @expose
   * @memberof oj.ojListView
   * @return {void}
   * @instance
   *
   * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
   * myListView.refresh();
   */
  refresh: function refresh() {
    this._super();

    this.listview.refresh();
  },

  /**
   * Returns a Promise that resolves when the component is ready, i.e. after data fetching, rendering, and animations complete.
   * Note that in the high-water mark scrolling case, component is ready after data fetching, rendering, and associated animations of items fetched so far are complete.
   *
   * <p>This method does not accept any arguments.
   *
   * @ignore
   * @ojshortdesc Returns a Promise that resolves when this component becomes ready.
   * @expose
   * @memberof oj.ojListView
   * @instance
   * @return {Promise} A Promise that resolves when the component is ready.
   */
  whenReady: function whenReady() {
    return this.listview.whenReady();
  },
  // @inheritdoc
  getNodeBySubId: function getNodeBySubId(locator) {
    return this.listview.getNodeBySubId(locator);
  },
  // @inheritdoc
  getSubIdByNode: function getSubIdByNode(node) {
    return this.listview.getSubIdByNode(node);
  },

  /**
   * @typedef {Object} oj.ojListView.ContextByNode
   * @property {string} subId the sub id that represents the element
   * @property {K} key the key of the item
   * @property {number} index the zero based index of the item, relative to its parent
   * @property {Element=} parent the parent group DOM element
   * @property {boolean=} group whether the item is a group item
   * @ojsignature [{target:"Type", value:"<K>", for:"genericTypeParameters"}]
   */

  /**
   * {@ojinclude "name":"nodeContextDoc"}
   * @param {!Element} node - {@ojinclude "name":"nodeContextParam"}
   * @returns {Object|null} {@ojinclude "name":"nodeContextReturn"}
   * @ojsignature { target: "Type",
   *                value: "oj.ojListView.ContextByNode<K>|null",
   *                jsdocOverride: true,
   *                for: "returns"}
   *
   * @example {@ojinclude "name":"nodeContextExample"}
   *
   * @expose
   * @instance
   * @memberof oj.ojListView
   * @ojshortdesc Returns an object with context for the given child DOM node. See the Help documentation for more information.
   */
  getContextByNode: function getContextByNode(node) {
    return this.listview.getContextByNode(node);
  },

  /**
   * Return the raw data for an item in ListView.  The item must have been already fetched.
   * @param {Object} context The context of the item to retrieve raw data.
   * @param {any=} context.key The key of the item.  If both index and key are specified, then key takes precedence.
   * @param {number=} context.index The index of the item relative to its parent.
   * @param {Element=} context.parent The parent node, not required if parent is the root.
   * @returns {any} data of the item.  If the item is not found or not yet fetched, returns null.  Also,
   * if static HTML is used as data (data attribute is not specified), then the element for the item is returned.
   * @ojshortdesc Gets the raw data of an item.
   * @export
   * @expose
   * @memberof oj.ojListView
   * @instance
   * @example <caption>Invoke the <code class="prettyprint">getDataForVisibleItem</code> method:</caption>
   * var data = myListView.getDataForVisibleItem( {'index': 2} );
   * @ojsignature [{target:"Type", value:"K", for:"context.key"},
   *               {target:"Type", value:"D", for:"returns"}]
   */
  getDataForVisibleItem: function getDataForVisibleItem(context) {
    return this.listview.getDataForVisibleItem(context);
  },

  /**
   * Expand an item.<p>
   * Note when vetoable is set to false, beforeExpand event will still be fired but the event cannot be veto.<p>
   *
   * @ignore
   * @expose
   * @memberof oj.ojListView
   * @instance
   * @param {Object} key the key of the item to expand
   * @param {boolean} vetoable whether the event should be vetoable
   */
  expand: function expand(key, vetoable) {
    this.listview.expandKey(key, vetoable, true, true);
  },

  /**
   * Collapse an item.<p>
   * Note when vetoable is set to false, beforeCollapse event will still be fired but the event cannot be veto.<p>
   *
   * @ignore
   * @expose
   * @memberof oj.ojListView
   * @instance
   * @param {Object} key the key of the item to collapse
   * @param {boolean} vetoable whether the event should be vetoable
   */
  collapse: function collapse(key, vetoable) {
    this.listview.collapseKey(key, vetoable, true);
  },

  /**
   * Gets the key of currently expanded items.
   *
   * @ignore
   * @expose
   * @memberof oj.ojListView
   * @instance
   * @return {Array} array of keys of currently expanded items
   */
  getExpanded: function getExpanded() {
    return this.listview.getExpanded();
  },

  /**
   * Gets the IndexerModel which can be used with the ojIndexer.  The IndexerModel provided by ListView
   * by defaults returns a list of locale dependent characters.  See translations for the key used to return
   * all characters.  When a user selects a character in the ojIndexer ListView will scroll to the group
   * header (or the closest one) with the character as its prefix.
   *
   * @expose
   * @ojshortdesc Gets the IndexerModel which can be used with the ojIndexer.
   * @memberof oj.ojListView
   * @ojdeprecated {since:"3.0.0", description:'Implements your own IndexerModel or use the <a href="oj.IndexerModelTreeDataSource.html">IndexerModelTreeDataSource</a> class instead.'}
   * @instance
   * @return {Object} ListView's IndexerModel to be used with the ojIndexer
   */
  getIndexerModel: function getIndexerModel() {
    if (this.indexerModel == null && oj.ListViewIndexerModel) {
      this.indexerModel = new oj.ListViewIndexerModel(this.listview);
    }

    return this.indexerModel;
  },

  /**
   * Scrolls the list until the specified item is visible.  If the item is not yet loaded (if scrollPolicy is set to 'loadMoreOnScroll'), then no action is taken.
   *
   * @ojshortdesc Scrolls a loaded item until it is visible.
   * @param {Object} item An object with a 'key' property that identifies the item to scroll to.
   * @property {K} item.key the key of the item to scroll to.
   * @expose
   * @memberof oj.ojListView
   * @return {void}
   * @instance
   */
  scrollToItem: function scrollToItem(item) {
    this.listview.scrollToItem(item);
  },
  //* * @inheritdoc */
  _CompareOptionValues: function _CompareOptionValues(option, value1, value2) {
    switch (option) {
      case 'currentItem':
        return oj.Object.compareValues(value1, value2);

      case 'selection':
        if (value1 && value1.inverted === undefined) {
          // eslint-disable-next-line no-param-reassign
          value1.inverted = false;
        }

        if (value2 && value2.inverted === undefined) {
          // eslint-disable-next-line no-param-reassign
          value2.inverted = false;
        }

        if (value1 && value2 && value1.inverted !== value2.inverted) {
          return false;
        }

        return oj.Object.compareValues(value1, value2);

      default:
        return this._super(option, value1, value2);
    }
  } // Slots

  /**
   * <p>The <code class="prettyprint">itemTemplate</code> slot is used to specify the template for rendering each item in the list. The slot content must be a &lt;template> element.
   * The content of the template could either include the &lt;li> element, in which case that will be used as
   * the root of the item.  Or it can be just the content which excludes the &lt;li> element.</p>
   * <p>When the template is executed for each item, it will have access to the binding context containing the following properties:</p>
   * <ul>
   *   <li>$current - an object that contains information for the current item. (See [oj.ojListView.ItemTemplateContext]{@link oj.ojListView.ItemTemplateContext} or the table below for a list of properties available on $current)</li>
   *  <li>alias - if as attribute was specified, the value will be used to provide an application-named alias for $current.</li>
   * </ul>
   *
   * @ojslot itemTemplate
   * @ojshortdesc The itemTemplate slot is used to specify the template for rendering each item in the list. See the Help documentation for more information.
   * @ojmaxitems 1
   * @memberof oj.ojListView
   * @ojslotitemprops oj.ojListView.ItemTemplateContext
   *
   * @example <caption>Initialize the ListView with an inline item template specified:</caption>
   * &lt;oj-list-view>
   *   &lt;template slot='itemTemplate'>
   *     &lt;span>&lt;oj-bind-text value='[[$current.data.name]]'>&lt;/span>
   *   &lt;template>
   * &lt;/oj-list-view>
   */

  /**
   * <p>The <code class="prettyprint">noData</code> slot is used to specify the content to display when the list is empty.
   * The slot content must be a &lt;template> element.  If not specified then a default no data message will be displayed.
   *
   * @ojslot noData
   * @ojshortdesc The noData slot is used to specify the content to render when the list is empty.
   * @ojmaxitems 1
   * @memberof oj.ojListView
   *
   * @example <caption>Initialize the ListView with a noData slot specified:</caption>
   * &lt;oj-list-view>
   *   &lt;template slot='noData'>
   *     &lt;span>&lt;oj-button>Add item&lt;/span>
   *   &lt;template>
   * &lt;/oj-list-view>
   */
  // Fragments

  /**
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Target</th>
   *       <th>Gesture</th>
   *       <th>Action</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td rowspan="2">List Item</td>
   *       <td><kbd>Tap</kbd></td>
   *       <td>Focus on the item.  If <code class="prettyprint">selectionMode</code> is enabled, selects the item as well.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Press & Hold</kbd></td>
   *       <td>Display context menu</td>
   *     </tr>
   *     <tr>
   *       <td rowspan="2">Group Item</td>
   *       <td><kbd>Tap</kbd></td>
   *       <td>Expand or collapse the group item if <code class="prettyprint">drillMode</code> is set to collapsible.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Press & Hold</kbd></td>
   *       <td>Display context menu</td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   * @ojfragment touchDoc - Used in touch gesture section of classdesc, and standalone gesture doc
   * @memberof oj.ojListView
   */

  /**
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Target</th>
   *       <th>Key</th>
   *       <th>Action</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td rowspan = "20" nowrap>List Item</td>
   *       <td><kbd>F2</kbd></td>
   *       <td>Enters Actionable mode.  This enables keyboard action on elements inside the item, including navigate between focusable elements inside the item.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Esc</kbd></td>
   *       <td>Exits Actionable mode.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Tab</kbd></td>
   *       <td>When in Actionable Mode, navigates to next focusable element within the item.  If the last focusable element is reached, shift focus back to the first focusable element.
   *           When not in Actionable Mode, navigates to next focusable element on page (outside ListView).</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Shift+Tab</kbd></td>
   *       <td>When in Actionable Mode, navigates to previous focusable element within the item.  If the first focusable element is reached, shift focus back to the last focusable element.
   *           When not in Actionable Mode, navigates to previous focusable element on page (outside ListView).</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>DownArrow</kbd></td>
   *       <td>Move focus to the item below.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>UpArrow</kbd></td>
   *       <td>Move focus to the item above.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>LeftArrow</kbd></td>
   *       <td>When display in card layout, move focus to the item on the left.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>RightArrow</kbd></td>
   *       <td>When display in card layout, move focus to the item on the right.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Shift+DownArrow</kbd></td>
   *       <td>Extend the selection to the item below.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Shift+UpArrow</kbd></td>
   *       <td>Extend the selection to the item above.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Shift+LeftArrow</kbd></td>
   *       <td>When display in card layout, extend the selection to the item on the left.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Shift+RightArrow</kbd></td>
   *       <td>When display in card layout, extend the selection to the item on the right.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Shift+F10</kbd></td>
   *       <td>Launch the context menu if there is one associated with the current item.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Enter</kbd></td>
   *       <td>Selects the current item.  No op if the item is already selected.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Space</kbd></td>
   *       <td>Toggles to select and deselect the current item.  If previous items have been selected, deselects them and selects the current item.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Shift+Space</kbd></td>
   *       <td>Selects contiguous items from the last selected item to the current item.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Ctrl+Space</kbd></td>
   *       <td>Toggles to select and deselect the current item while maintaining previous selected items.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Ctrl+X</kbd></td>
   *       <td>Marks the selected items to move if dnd.reorder is enabled.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Ctrl+C</kbd></td>
   *       <td>Marks the selected items to copy if dnd.reorder is enabled.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Ctrl+V</kbd></td>
   *       <td>Paste the items that are marked to directly before the current item (or as the last item if the current item is a folder).</td>
   *     </tr>
   *     <tr>
   *       <td rowspan = "2" nowrap>Group Item</td>
   *       <td><kbd>LeftArrow</kbd></td>
   *       <td>Collapse the current item if it is expanded and is collapsible.  For non-hierarchical data, do nothing.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>RightArrow</kbd></td>
   *       <td>Expand the current item if it has children and is expandable.  For non-hierarchical data, do nothing.</td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   * @ojfragment keyboardDoc - Used in keyboard section of classdesc, and standalone gesture doc
   * @memberof oj.ojListView
   */

}); // ////////////////     SUB-IDS     //////////////////

/**
 * <p>Sub-ID for ListView's disclosure icon in group items.  See the <a href="#getNodeBySubId">getNodeBySubId</a>
 * method for details.</p>
 *
 * @ojdeprecated {since: "2.0.0", description: 'Use the <a href="#oj-listview-disclosure">oj-listview-disclosure</a> option instead.'}
 * @ojsubid oj-listview-icon
 * @memberof oj.ojListView
 *

 * @example <caption>Get the disclosure icon for the group item with key 'foo':</caption>
 * var node = myListView.getNodeBySubId( {'subId': 'oj-listview-icon', 'key': 'foo'} );
 */

/**
 * <p>Sub-ID for ListView's disclosure icon in group items.  See the <a href="#getNodeBySubId">getNodeBySubId</a>
 * method for details.</p>
 *
 * @ojsubid oj-listview-disclosure
 * @memberof oj.ojListView
 *
 * @example <caption>Get the disclosure icon for the group item with key 'foo':</caption>
 * var node = myListView.getNodeBySubId( {'subId': 'oj-listview-disclosure', 'key': 'foo'} );
 */

/**
 * <p>Context for items within ListView.</p>
 *
 * @property {number} index the zero based item index relative to its parent
 * @property {Object} key the key of the item
 * @property {Element} parent the parent group item.  Only available if item has a parent.
 * @property {boolean} group whether the item is a group.
 *
 * @ojnodecontext oj-listview-item
 * @memberof oj.ojListView
 */
// ////////////////     SUB-PROPERTIES (dnd, scrollPolicyOptions)     //////////////////

/**
 * If this object is specified, listview will initiate drag operation when the user drags on either a drag handle, which is an element with oj-listview-drag-handle class, or
 * selected items if no drag handle is set on the item.
 * @expose
 * @name dnd.drag.items
 * @ojshortdesc An object that describes drag functionality for a selected set of items. See the Help documentation for more information.
 * @memberof! oj.ojListView
 * @instance
 * @type {Object}
 */

/**
 * The MIME types to use for the dragged data in the dataTransfer object. This can be a string if there is only one
 * type, or an array of strings if multiple types are needed.<br><br>
 * For example, if selected items of employee data are being dragged, dataTypes could be "application/employees+json". Drop targets can examine the data types and decide
 * whether to accept the data. A text input may only accept "text" data type, while a chart for displaying employee data may be configured to accept the "application/employees+json" type.<br><br>
 * For each type in the array, dataTransfer.setData will be called with the specified type and the JSON version of the selected item data as the value. The selected item data
 * is an array of objects, with each object representing a model object from the underlying data source.  For example, if the underlying data is an oj.Collection, then this
 * would be a oj.Model object.  Note that when static HTML is used, then the value would be the html string of the selected item.<br><br>
 * This property is required unless the application calls setData itself in a dragStart callback function.
 * @expose
 * @name dnd.drag.items.dataTypes
 * @ojshortdesc Specifies one or more MIME types to use for the dragged data in the dataTransfer object. See the Help documentation for more information.
 * @memberof! oj.ojListView
 * @instance
 * @type {string|Array.<string>}
 * @default null
 * @ojsignature { target: "Type",
 *                value: "?"}
 */

/**
 * A callback function that receives the "dragstart" event and context information as its arguments.  The ontext information has the following properties:<br>
 * <ul>
 *   <li><code class="prettyprint">items</code>: An array of items being dragged
 *   </li>
 * </ul><br><br>
 * This function can set its own data and drag image as needed. If dataTypes is specified, event.dataTransfer is already populated with the default data when this function is invoked.
 * If dataTypes is not specified, this function must call event.dataTransfer.setData to set the data or else the drag operation will be cancelled.  In either case, the drag image is
 * set to an image of the dragged rows on the listview.
 * @expose
 * @name dnd.drag.items.dragStart
 * @ojshortdesc A callback function that receives the "dragstart" event and context information as its arguments.
 * @memberof! oj.ojListView
 * @instance
 * @type {function(Event, {items: Array.<Element>}):void}
 * @default null
 * @ojsignature { target: "Type",
  *                value: "?"}
 */

/**
 * An optional callback function that receives the "drag" event as its argument.
 * @expose
 * @name dnd.drag.items.drag
 * @memberof! oj.ojListView
 * @instance
 * @type {function(Event)}
 * @default null
 * @ojsignature { target: "Type",
 *                value: "?"}
 */

/**
 * An optional callback function that receives the "dragend" event as its argument.
 * @expose
 * @name dnd.drag.items.dragEnd
 * @memberof! oj.ojListView
 * @instance
 * @type {function(Event)}
 * @default null
 * @ojsignature { target: "Type",
 *                value: "?"}
 */

/**
 * @typedef {Object} oj.ojListView.ItemsDropContext
 * @property {Element} item the item being dropped on
 * @property {'before'|'after'|'inside'} position the drop position relative to the item being dropped on
 * @property {boolean} reorder true if the drop was a reorder in the same listview, false otherwise
 */

/**
 * @typedef {Object} oj.ojListView.ItemTemplateContext
 * @property {Element} componentElement The &lt;oj-list-view> custom element
 * @property {Object} data The data for the current item being rendered
 * @property {number} index The zero-based index of the current item
 * @property {any} key The key of the current item being rendered
 * @property {number} depth The depth of the current item (available when hierarchical data is provided) being rendered. The depth of the first level children under the invisible root is 1.
 * @property {boolean} leaf True if the current item is a leaf node (available when hierarchical data is provided).
 * @property {any} parentkey The key of the parent item (available when hierarchical data is provided). The parent key is null for root nodes.
 */

/**
 * An object that specifies callback functions to handle dropping items.
 * @expose
 * @name dnd.drop.items
 * @ojshortdesc An object that describes drop functionality for a selected set of items.
 * @memberof! oj.ojListView
 * @instance
 * @type {Object}
 */

/**
 * A data type or an array of data types this component can accept.<br><br>
 * This property is required unless dragEnter, dragOver, and drop callback functions are specified to handle the corresponding events.
 * @expose
 * @name dnd.drop.items.dataTypes
 * @ojshortdesc Specifies one or more data types that this component can accept. See the Help documentation for more information.
 * @memberof! oj.ojListView
 * @instance
 * @type {string | Array.<string>}
 * @default null
 * @ojsignature { target: "Type",
 *                value: "?"}
 */

/**
 * An optional callback function that receives the "dragenter" event and context information as its arguments.  The context information has the following properties:<br>
 * <ul>
 *   <li><code class="prettyprint">item</code>: the item being entered
 *   </li>
 * </ul><br><br>
 * This function should call <code class="prettyprint">event.preventDefault</code> to indicate the dragged data can be accepted.<br><br>
 * @expose
 * @name dnd.drop.items.dragEnter
 * @ojshortdesc An optional callback function that receives the "dragenter" event and context information as its arguments.
 * @memberof! oj.ojListView
 * @instance
 * @type {function(Event, {item: Element}):void}
 * @default null
 * @ojsignature { target: "Type",
 *                value: "?"}
 */

/**
 * An optional callback function that receives the "dragover" event and context information as its arguments.  The context information has the following properties:<br>
 * <ul>
 *   <li><code class="prettyprint">item</code>: the item being dragged over
 *   </li>
 * </ul><br><br>
 * Similar to dragEnter, this function should call <code class="prettyprint">event.preventDefault</code> to indicate the dragged data can be accepted.
 * @expose
 * @name dnd.drop.items.dragOver
 * @ojshortdesc An optional callback function that receives the "dragover" event and context information as its arguments.
 * @memberof! oj.ojListView
 * @instance
 * @type {function(Event, {item: Element}):void}
 * @default null
 * @ojsignature { target: "Type",
 *                value: "?"}
 */

/**
 * An optional callback function that receives the "dragleave" event and context information as its arguments.  The context information has the following properties:<br>
 * <ul>
 *   <li><code class="prettyprint">item</code>: the item that was last entered
 *   </li>
 * </ul><br><br>
 * @expose
 * @name dnd.drop.items.dragLeave
 * @ojshortdesc An optional callback function that receives the "dragleave" event and context information as its arguments.
 * @memberof! oj.ojListView
 * @instance
 * @type {function(Event, {item: Element}):void}
 * @default null
 * @ojsignature { target: "Type",
 *                value: "?"}
 */

/**
 * A callback function that receives the "drop" event and context information as its arguments.  The context information has the following properties:<br>
 * <ul>
 *   <li><code class="prettyprint">item</code>: the item being dropped on
 *   <li><code class="prettyprint">position</code>: the drop position relative to the item being dropped on
 *   <li><code class="prettyprint">reorder</code>: true if the drop was a reorder in the same listview, false otherwise
 *   </li>
 * </ul><br><br>
 * This function should call <code class="prettyprint">event.preventDefault</code> to indicate the dragged data is accepted.<br><br>
 * If the application needs to look at the data for the item being dropped on, it can use the getDataForVisibleItem method.
 * @expose
 * @name dnd.drop.items.drop
 * @ojshortdesc An optional callback function that receives the "drop" event and context information as its arguments.
 * @memberof! oj.ojListView
 * @instance
 * @type {function(Event, Object):void}
 * @default null
 * @ojsignature { target: "Type",
 *                value: "?((param0: Event, param1: oj.ojListView.ItemsDropContext)=> void)",
 *                jsdocOverride: true}
 */

/**
 * The number of items to fetch in each block
 * @expose
 * @name scrollPolicyOptions.fetchSize
 * @memberof! oj.ojListView
 * @instance
 * @type {number}
 * @default 25
 * @ojsignature { target: "Type",
 *                value: "?"}
 */

/**
 * The maximum total number of items to fetch
 * @expose
 * @name scrollPolicyOptions.maxCount
 * @memberof! oj.ojListView
 * @instance
 * @type {number}
 * @default 500
 * @ojsignature { target: "Type",
 *                value: "?"}
 */

/**
 * The element which listview uses to determine the scroll position as well as the maximum scroll position.  For example in a lot of mobile use cases where ListView occupies the entire screen, developers should set the scroller option to document.documentElement.
 * @expose
 * @name scrollPolicyOptions.scroller
 * @ojshortdesc The element used to determine the scroll position as well as the maximum scroll position. See the Help documentation for more information.
 * @memberof! oj.ojListView
 * @instance
 * @type {Element}
 * @default null
 * @ojsignature { target: "Type",
 *                value: "?"}
 */
// Set theme-based defaults


Components.setDefaultOptions({
  ojListView: {
    gridlines: Components.createDynamicPropertyGetter(function () {
      return {
        item: (ThemeUtils.parseJSONFromFontFamily('oj-listview-option-defaults') || {}).gridlines.item
      };
    })
  }
});



/* global __oj_list_view_metadata:false */
(function () {
  __oj_list_view_metadata.extension._WIDGET_NAME = 'ojListView';
  __oj_list_view_metadata.extension._INNER_ELEM = 'ul';
  __oj_list_view_metadata.extension._GLOBAL_TRANSFER_ATTRS = ['aria-label', 'aria-labelledby'];
  oj.CustomElementBridge.register('oj-list-view', {
    metadata: __oj_list_view_metadata
  });
})();

});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojdatasource-common',['ojs/ojcore', 'jquery'], function(oj, $)
{
  "use strict";


/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true*/

/**
 * @export
 * @class oj.DataSource
 * @extends oj.EventSource
 * @classdesc Object representing data used by table and grid components
 * @param {Object} data data supported by the components
 * @constructor
 * @final
 * @since 1.0
 * @abstract
 * @ojdeprecated {since: '5.0.0', description: 'Use DataProvider instead.'}
 * @ojtsignore
 */
oj.DataSource = function (data) {
  this.data = data;
  this.Init();
};
/**
 * Subclass from oj.Object
 * @private
 */


oj.Object.createSubclass(oj.DataSource, oj.EventSource, 'oj.DataSource');
/**
 * Initializes the instance.
 * @export
 * @memberof oj.DataSource
 * @return {undefined}
 * @ojtsignore
 */

oj.DataSource.prototype.Init = function () {
  oj.DataSource.superclass.Init.call(this);
};
/**
 * Determines whether this DataSource supports the specified feature.
 * @method
 * @name getCapability
 * @memberof oj.DataSource
 * @instance
 * @param {string} feature the feature in which its capabilities is inquired.
 * @return {string|null} the capability of the specified feature.  Returns null if the feature is not recognized.
 */



/**
 * @class oj.TreeDataSource
 * @classdesc Abstract class representing hierarchical (tree) data that can be used by different components such as [Indexer]{@link oj.ojIndexer}, [ListView]{@link oj.ojListView}, [NavigationList]{@link oj.ojNavigationList},
 * and [TreeView]{@link oj.ojTreeView}.<br><br>
 * This class is not used directly and is used as the base to implement other subclasses.  Implementations of TreeDataSource must implement all of the methods documented here.<br><br>
 * JET provides the following implementations:<br><br>
 * <table class="generic-table">
 *   <thead>
 *     <th>Subclass</th>
 *     <th>When to Use</th>
 *     <th>Use with</th>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td>{@link oj.CollectionTreeDataSource}</td>
 *       <td>When the data is available from an {@link oj.Collection} object, such as an external data source.</td>
 *       <td>ListView<br>NavigationList<br>TreeView<br></td>
 *     </tr>
 *     <tr>
 *       <td>{@link oj.IndexerModelTreeDataSource}</td>
 *       <td>When the data has a tree-like structure that is displayed in a ListView with Indexer.</td>
 *       <td>ListView (with Indexer)<br></td>
 *     </tr>
 *     <tr>
 *       <td>{@link oj.JsonTreeDataSource}</td>
 *       <td>When the data is available from an array of JSON objects that represent tree nodes.</td>
 *       <td>ListView<br>NavigationList<br>TreeView<br></td>
 *     </tr>
 *   </tbody>
 * </table>
 * <br>Refer to the documentation and demos of individual components for more information on how to use them with the TreeDataSource subclasses.</br><br>
 * In case specialized behavior is needed, new subclass can be created by using [oj.Object.createSubclass]{@link oj.Object#createSubclass}.  New subclass can be based on
 * TreeDataSource, in which case all methods must be implemented, or it can be based on an existing subclass, in which case only methods that require different behavior need
 * to be overridden.
 *
 * @param {Object} data data supported by the component
 * @export
 * @extends oj.DataSource
 * @abstract
 * @constructor
 * @final
 * @since 1.0
 * @ojdeprecated {since: '6.0.0', description: 'Use TreeDataProvider instead.'}
 * @ojtsignore
 */
oj.TreeDataSource = function (data) {
  oj.TreeDataSource.superclass.constructor.call(this, data);
};
/**
 * Subclass TreeDataSource to DataSource
 * @private
 */


oj.Object.createSubclass(oj.TreeDataSource, oj.DataSource, 'oj.TreeDataSource');
/**
 * Returns the number of children for a specified parent.  If the value returned is not >= 0 then it is automatically assumed
 * that the child count is unknown.
 * @param {any} parent the parent key.  Specify null if inquiring child count of the root.
 * @return {number} the number of children for the specified parent.
 * @method
 * @name getChildCount
 * @memberof oj.TreeDataSource
 * @instance
 */

/**
 * Fetch the children
 * @param {any} parent the parent key.  Specify null if fetching children from the root.
 * @param {Object} range information about the range, it must contain the following properties: start, count
 * @property {number} range.start the start index of the range in which the children are fetched
 * @property {number} range.count the size of the range in which the children are fetched
 * @param {Object} callbacks the callbacks to be invoke when fetch children operation is completed.  The valid callback
 *        types are "success" and "error"
 * @property {function(oj.NodeSet)} callbacks.success the callback to invoke when fetch completed successfully.
 * @property {function({status: *})=} callbacks.error the callback to invoke when fetch children failed.
 * @param {Object=} options optional parameters for this operation
 * @property {boolean=} options.queueOnly true if this fetch request is to be queued and not execute yet.  The implementation must maintain
 *        the order of the fetch operations.  When queueOnly is false/null/undefined, any queued fetch operations are then
 *        flushed and executed in the order they are queued.  This flag is ignored if the datasource does not support batching
 * @return {void}
 * @method
 * @name fetchChildren
 * @memberof oj.TreeDataSource
 * @instance
 */

/**
 * Fetch all children and their children recursively from a specified parent.
 * @param {any} parent the parent key.  Specify null to fetch everything from the root (i.e. expand all)
 * @param {Object} callbacks the callbacks to be invoke when fetch children operation is completed.  The valid callback
 *        types are "success" and "error"
 * @property {function(oj.NodeSet)} callbacks.success the callback to invoke when fetch completed successfully.
 * @property {function({status: *})=} callbacks.error the callback to invoke when fetch children failed.
 * @param {Object=} options optional parameters for this operation
 * @property {number=} options.start the index related to parent in which to begin fetching descendants from.  If this is not specified, then value zero will be used
 * @property {number=} options.maxCount the maximum number of children to fetch.  If a non-positive number is specified, then the value is ignored and
 *        there is no maximum fetch count
 * @return {void}
 * @method
 * @name fetchDescendants
 * @memberof oj.TreeDataSource
 * @instance
 */

/**
 * Performs a sort operation on the tree data.
 * @param {Object} criteria the sort criteria.  It must contain the following properties: key, direction
 * @property {any} criteria.key the key identifying the attribute (column) to sort on
 * @property {'ascending'|'descending'|'none'} criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
 * @param {Object} callbacks callbacks for the sort operation
 * @property {function():void} callbacks.success the callback to invoke when the sort completed successfully
 * @property {function({status: *})=} callbacks.error the callback to invoke when sort failed.
 * @return {void}
 * @method
 * @name sort
 * @memberof oj.TreeDataSource
 * @instance
 */

/**
 * Returns the current sort criteria of the tree data.
 * @return {Object} the current sort criteria.  It should contain the following properties: key, direction where
 *         criteria.key the key identifying the attribute (column) to sort on.  Value is null if it's not sorted.
 *         criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
 * @ojsignature {target: "Type",
 *               value: "{key: any, direction: 'ascending'|'descending'|'none'}",
 *               for: "returns"}
 * @method
 * @name getSortCriteria
 * @memberof oj.TreeDataSource
 * @instance
 */

/**
 * Moves a row from one location to another (different position within the same parent or a completely different parent)
 * @param {any} rowToMove the key of the row to move
 * @param {any} referenceRow the key of the reference row which combined with position are used to determine
 *        the destination of where the row should moved to.
 * @param {number|string} position The position of the moved row relative to the reference row.
 *        This can be a string: "before", "after", "inside", "first", "last", or the zero based index to position
 *        the element at a specific point among the reference row's current children.
 * @param {Object} callbacks the callbacks for the move function
 * @property {function():void} callbacks.success the callback to invoke when the move completed successfully
 * @property {function({status: *})=} callbacks.error the callback to invoke when move failed.
 * @return {void}
 * @method
 * @name move
 * @memberof oj.TreeDataSource
 * @instance
 */

/**
 * Checks whether a move operation is valid.
 * @param {any} rowToMove the key of the row to move
 * @param {any} referenceRow the key of the reference row which combined with position are used to determine
 *        the destination of where the row should moved to.
 * @param {number|string} position The position of the moved row relative to the reference row.
 *        This can be a string: "before", "after", "inside", "first", "last", or the zero based index to position
 *        the element at a specific point among the reference row's current children.
 * @return {string} returns "valid" if the move is valid, "invalid" otherwise.
 * @ojsignature {target: "Type",
 *               value: "'valid'|'invalid'",
 *               for: "returns"}
 * @method
 * @name moveOK
 * @memberof oj.TreeDataSource
 * @instance
 */

/**
 * Determines whether this TreeDataSource supports the specified feature.
 * @param {string} feature the feature in which its capabilities is inquired.  Currently the valid features "sort",
 *        "move", "fetchDescendants", "batchFetch"
 * @return {string|null} the name of the feature.  Returns null if the feature is not recognized.
 *         For "sort", the valid return values are: "default", "none".
 *         For "fetchDescendants", the valid return values are: "enable", "disable", "suboptimal".
 *         For "move", the valid return values are: "default", "none".
 *         For "batchFetch", the valid return values are: "enable", "disable".
 * @method
 * @name getCapability
 * @memberof oj.TreeDataSource
 * @instance
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @export
 * @class oj.TableDataSource
 * @abstract
 * @classdesc Abstract class representing tabular data that can be used by different components such as [ListView]{@link oj.ojListView}, [NavigationList]{@link oj.ojNavigationList},
 * [PagingControl]{@link oj.ojPagingControl}, [TabBar]{@link oj.ojTabBar}, and [Table]{@link oj.ojTable}.<br><br>
 * This class is not used directly and is used as the base to implement other subclasses.  Implementations of TableDataSource must implement all of the methods documented here.<br><br>
 * JET provides the following implementations:<br><br>
 * <table class="generic-table">
 *   <thead>
 *     <th>Subclass</th>
 *     <th>When to Use</th>
 *     <th>Use with</th>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td>{@link oj.ArrayTableDataSource}</td>
 *       <td>When the data is available from an array.</td>
 *       <td>ListView<br>NavigationList<br>TabBar<br>Table<br></td>
 *     </tr>
 *     <tr>
 *       <td>{@link oj.CollectionTableDataSource}</td>
 *       <td>When the data is available from an {@link oj.Collection} object, such as an external data source.</td>
 *       <td>ListView<br>NavigationList<br>TabBar<br>Table<br></td>
 *     </tr>
 *     <tr>
 *       <td>{@link oj.FlattenedTreeTableDataSource}</td>
 *       <td>When the data has a tree-like structure that is displayed in a Table with RowExpander.</td>
 *       <td>Table (with RowExpander)<br></td>
 *     </tr>
 *     <tr>
 *       <td>{@link oj.PagingTableDataSource}</td>
 *       <td>When paging functionality is needed on top of other TableDataSource implementations.</td>
 *       <td>ListView<br>PagingControl<br>Table<br></td>
 *     </tr>
 *   </tbody>
 * </table>
 * <br>Refer to the documentation and demos of individual components for more information on how to use them with the TableDataSource subclasses.</br><br>
 * In case specialized behavior is needed, new subclass can be created by using [oj.Object.createSubclass]{@link oj.Object#createSubclass}.  New subclass can be based on
 * TableDataSource, in which case all methods must be implemented, or it can be based on an existing subclass, in which case only methods that require different behavior need
 * to be overridden.
 *
 * @extends oj.DataSource
 * @param {Object} data data supported by the components
 * @param {Object=} options Options for the TableDataSource
 * @constructor
 * @final
 * @since 1.0
 * @ojdeprecated {since: '5.0.0', description: 'Use DataProvider instead.'}
 * @ojtsignore
 */
oj.TableDataSource = function (data, options) {
  if (this.constructor === oj.TableDataSource) {
    // This should only be called by the constructors of the subclasses. If you need
    // to initialize a new TableDataSource then call the constructors of the subclasses such
    // as oj.ArrayTableDataSource or oj.CollectionTableDataSource.
    var errSummary = oj.TableDataSource._LOGGER_MSG._ERR_TABLE_DATASOURCE_INSTANTIATED_SUMMARY;
    var errDetail = oj.TableDataSource._LOGGER_MSG._ERR_TABLE_DATASOURCE_INSTANTIATED_DETAIL;
    throw new Error(errSummary + '\n' + errDetail);
  } // Initialize


  this.data = data;
  this.options = options;
  this.isFetching = false;
  this._startIndex = 0;
  this.Init();
};
/**
 * Subclass from oj.DataSource
 * @private
 */


oj.Object.createSubclass(oj.TableDataSource, oj.DataSource, 'oj.TableDataSource');
/**
 * Initializes the instance.
 * @memberof oj.TableDataSource
 * @instance
 * @override
 * @protected
 */

oj.TableDataSource.prototype.Init = function () {
  oj.TableDataSource.superclass.Init.call(this);
};
/**
 * @export
 * @expose
 * @memberof oj.TableDataSource
 * @desc The sort criteria. Whenever sort() is called with the criteria parameter, that value is copied to this
 * property. If sort() is called with empty sort criteria then the criteria set in this property is used.
 *
 * @type {Object}
 * @property {any} criteria.key The key that identifies which field to sort
 * @property {'ascending'|'descending'|'none'} criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
 */


oj.TableDataSource.prototype.sortCriteria = null;
/**
 * Return the row data found at the given index.
 *
 * @param {number} index Index for which to return the row data.
 * @param {Object=} options Options to control the at.
 * @return {Promise.<null|oj.TableDataSource.RowData>} Promise resolves to a compound object which has the structure below. If the index is out of range, Promise resolves to null.<p>
 * <table>
 * <tbody>
 * <tr><td><b>data</b></td><td>The raw row data</td></tr>
 * <tr><td><b>index</b></td><td>The index for the row</td></tr>
 * <tr><td><b>key</b></td><td>The key value for the row</td></tr>
 * </tbody>
 * </table>
 * @method
 * @name at
 * @memberof oj.TableDataSource
 * @instance
 */

/**
 * Fetch the row data.
 * @param {Object=} options Options to control fetch
 * @property {number} [options.startIndex] The index at which to start fetching records.
 * @property {boolean} [options.silent] If set, do not fire a sync event.
 * @return {Promise.<null|oj.TableDataSource.RowDatas>} Promise object resolves to a compound object which contains an array of row data objects, an array of ids, and the startIndex triggering done when complete.<p>
 *         The structure of the resolved compound object is:<p>
 * <table>
 * <tbody>
 * <tr><td><b>data</b></td><td>An array of raw row data</td></tr>
 * <tr><td><b>keys</b></td><td>An array of key values for the rows</td></tr>
 * <tr><td><b>startIndex</b></td><td>The startIndex for the returned set of rows</td></tr>
 * </tbody>
 * </table>
 * @method
 * @name fetch
 * @memberof oj.TableDataSource
 * @instance
 */

/**
 * Return the first row data whose id value is the given id
 * @param {string} id ID for which to return the row data, if found.
 * @param {Object=} options Options to control the get.
 * @return {Promise.<null|oj.TableDataSource.RowData>} Promise which resolves to a compound object which has the structure below where the id matches the given id. If none are found, resolves to null.<p>
 * <table>
 * <tbody>
 * <tr><td><b>data</b></td><td>The raw row data</td></tr>
 * <tr><td><b>index</b></td><td>The index for the row</td></tr>
 * <tr><td><b>key</b></td><td>The key value for the row</td></tr>
 * </tbody>
 * </table>
 * @method
 * @name get
 * @memberof oj.TableDataSource
 * @instance
 */

/**
 * Determines whether this TableDataSource supports certain feature.
 * @param {string} feature the feature in which its capabilities is inquired.  Currently the only valid feature is "sort".
 * @return {string|null} the name of the feature.  For "sort", the valid return values are: "full", "none".
 *         Returns null if the feature is not recognized.
 * @memberof oj.TableDataSource
 * @instance
 * @method
 * @name getCapability
 */

/**
 * Performs a sort on the data source. Null criteria clears the existing sort.
 * @param {Object} [criteria] the sort criteria.
 * @property {any} criteria.key The key that identifies which field to sort
 * @property {'ascending'|'descending'|'none'} criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
 * @return {Promise.<null>} promise object triggering done when complete.
 * @method
 * @name sort
 * @memberof oj.TableDataSource
 * @instance
 */

/**
 * Return the total size of data available, including server side if not local.
 * @returns {number} total size of data
 * @method
 * @name totalSize
 * @memberof oj.TableDataSource
 * @instance
 */

/**
 * Returns the confidence for the totalSize value.
 * @return {string} "actual" if the totalSize is the time of the fetch is an exact number
 *                  "estimate" if the totalSize is an estimate
 *                  "atLeast" if the totalSize is at least a certain number
 *                  "unknown" if the totalSize is unknown
 * @ojsignature {target: "Type", for: "returns", value: "'actual'|'estimate'|'atLeast'|'unknown'"}
 * @export
 * @expose
 * @memberof oj.TableDataSource
 * @instance
 */

oj.TableDataSource.prototype.totalSizeConfidence = function () {
  return 'actual';
};
/**
* Row Data returned by methods like, at/get.
* @typedef {Object} oj.TableDataSource.RowData
* @property {Object} data The raw row data.
* @property {number} index The index for the row.
* @property {any} key The key value for the row.
*/

/**
* Row Datas returned by fetch method.
* @typedef {Object} oj.TableDataSource.RowDatas
* @property {Array.<Object>} data An array of raw row data.
* @property {Array.<any>} keys An array of key values for the rows.
* @property {number} startIndex The startIndex for the returned set of rows.
*/

/**
 * Events which are published by TableDataSource. Any custom TableDataSource
 * implementation must publish the corresponding events.
 * @export
 * Event types
 * @enum {string}
 * @memberof oj.TableDataSource
 */


oj.TableDataSource.EventType = {
  /** Triggered when a Row has been added to a TableDataSource<p>
   * The event payload contains:<p>
   * <table cellspacing="0" style="border-collapse: collapse;">
   * <tbody>
   * <tr><td><b>data</b></td><td>An array of raw row data</td></tr>
   * <tr><td><b>keys</b></td><td>An array of key values for the rows</td></tr>
   * <tr><td><b>indexes</b></td><td>An array of index values for the rows in post-insert sorted order</td></tr>
   * </tbody>
   * </table>
   */
  ADD: 'add',

  /** Triggered when a Row has been removed from a TableDataSource<p>
   * The event payload contains:<p>
   * <table cellspacing="0" style="border-collapse: collapse;">
   * <tbody>
   * <tr><td><b>data</b></td><td>An array of raw row data</td></tr>
   * <tr><td><b>keys</b></td><td>An array of key values for the rows</td></tr>
   * <tr><td><b>indexes</b></td><td>An array of index values for the rows in pre-remove sorted order</td></tr>
   * </tbody>
   * </table>
   */
  REMOVE: 'remove',

  /** Triggered when a TableDataSource has been reset */
  RESET: 'reset',

  /** Triggered when a TableDataSource has been refreshed */
  REFRESH: 'refresh',

  /** Triggered when a TableDataSource has been sorted<p>
   * The event payload contains:<p>
   * <table cellspacing="0" style="border-collapse: collapse;">
   * <tbody>
   * <tr><td><b>header</b></td><td>the key of the header which was sorted on</td></tr>
   * <tr><td><b>direction</b></td><td>the direction of the sort ascending/descending</td></tr>
   * </tbody>
   * </table>
   */
  SORT: 'sort',

  /** Triggered when a Row's attributes have been changed<p>
   * The event payload contains:<p>
   * <table cellspacing="0" style="border-collapse: collapse;">
   * <tbody>
   * <tr><td><b>data</b></td><td>An array of raw row data</td></tr>
   * <tr><td><b>keys</b></td><td>An array of key values for the rows</td></tr>
   * <tr><td><b>indexes</b></td><td>An array of index values for the rows</td></tr>
   * </tbody>
   * </table>
   */
  CHANGE: 'change',

  /** Triggered when a TableDataSource has sent a fetch request. It is expected that
   * a component using TableDataSource will go into a busy state upon receiving
   * this event.
   * The event payload contains:<p>
   * <table cellspacing="0" style="border-collapse: collapse;">
   * <tbody>
   * <tr><td><b>startIndex</b></td><td>The start index at which the fetch was invoked</td></tr>
   * </tbody>
   * </table>
   */
  REQUEST: 'request',

  /** Triggered when a TableDataSource has been updated by a fetch. It is expected that
   * a component using TableDataSource will exit busy state upon completion of rendering
   * after receiving this event.<p>
   * The event payload contains:<p>
   * <table cellspacing="0" style="border-collapse: collapse;">
   * <tbody>
   * <tr><td><b>data</b></td><td>An array of raw row data</td></tr>
   * <tr><td><b>keys</b></td><td>An array of key values for the rows</td></tr>
   * <tr><td><b>startIndex</b></td><td>The start index at which the fetch occurred</td></tr>
   * </tbody>
   * </table>
   */
  SYNC: 'sync',

  /** Triggered when an error occurred on the TableDataSource */
  ERROR: 'error'
};
/**
 * @private
 */

oj.TableDataSource._LOGGER_MSG = {
  _ERR_TABLE_DATASOURCE_INSTANTIATED_SUMMARY: 'oj.TableDataSource constructor called.',
  _ERR_TABLE_DATASOURCE_INSTANTIATED_DETAIL: 'Please do not instantiate oj.TableDataSource. Please use one of the subclasses instead such as oj.ArrayTableDataSource or oj.CollectionTableDataSource.',
  _ERR_DATA_INVALID_TYPE_SUMMARY: 'Invalid data type.',
  _ERR_DATA_INVALID_TYPE_DETAIL: 'Please specify the appropriate data type.'
};



/**
 * @class oj.DataGridDataSource
 * @classdesc The base class for DataGridDataSource.<br>
 * DataGridDataSource implementations must implement all of the functions documented here.
 * @export
 * @extends oj.DataSource
 * @constructor
 * @final
 * @since 1.0
 * @ojtsignore
 */
oj.DataGridDataSource = function (data) {
  // oj.DataSource would calls Init
  oj.DataGridDataSource.superclass.constructor.call(this, data);
};
/**
 * Subclass DataGridDataSource to DataSource
 * @private
 */


oj.Object.createSubclass(oj.DataGridDataSource, oj.DataSource, 'oj.DataGridDataSource');
/**
 * Returns the total number of rows or columns.  If the value return is not >= 0 then it is automatically assumed
 * that the total count is unknown.
 * @param {string} axis the axis in which we inquire for the total count.  Valid values are "row" and "column".
 * @return {number} the total number of rows/columns.
 * @method
 * @name getCount
 * @memberof oj.DataGridDataSource
 * @instance
 */

/**
 * Returns whether the total count returned in getCount function is an actual or an estimate.
 * @param {string} axis the axis in which we inquire whether the total count is an estimate.  Valid values are
 *        "row" and "column".
 * @return {string} "exact" if the count returned in getCount function is the actual count, "estimate" if the
 *         count returned in getCount function is an estimate.  The default value is "exact".
 * @method
 * @name getCountPrecision
 * @memberof oj.DataGridDataSource
 * @instance
 */

/**
 * Fetch a range of headers from the data source.
 * @export
 * @method
 * @name fetchHeaders
 * @memberof oj.DataGridDataSource
 * @instance
 * @param {Object} headerRange information about the header range, it must contain the following properties:
 *        axis, start, count.
 * @property {string} headerRange.axis the axis of the header that are fetched.  Valid values are "row" and "column".
 * @property {number} headerRange.start the start index of the range in which the header data are fetched.
 * @property {number} headerRange.count the size of the range in which the header data are fetched.
 * @param {Object} callbacks the callbacks to be invoke when fetch headers operation is completed.
 * @property {function({startHeaderSet: Object}, {headerRange: Object}, {endHeaderSet: Object}):undefined} callbacks.success the callback to invoke when fetch headers completed successfully.
 *        The function takes three parameters: HeaderSet object representing start headers, headerRange object passed into the original fetchHeaders call,
 *        and a HeaderSet object representing the end headers along the axis.
 * @property {function({status: Object}):undefined} callbacks.error the callback to invoke when fetch cells failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.
 * @property {Object=} callbackObjects.success
 * @property {Object=} callbackObjects.error
 * @return {undefined}
 */

/**
 * Fetch a range of cells from the data source.
 * @method
 * @name fetchCells
 * @memberof oj.DataGridDataSource
 * @instance
 * @param {Array.<Object>} cellRanges Information about the cell range.  A cell range is defined by an array
 *        of range info for each axis, where each range contains three properties: axis, start, count.
 * @property {string} cellRanges.axis the axis associated with this range where cells are fetched.  Valid
 *        values are "row" and "column".
 * @property {number} cellRanges.start the start index of the range for this axis in which the cells are fetched.
 * @property {number} cellRanges.count the size of the range for this axis in which the cells are fetched.
 * @param {Object} callbacks the callbacks to be invoke when fetch cells operation is completed.
 * @property {function({cellSet: Object}, {cellRanges: Array.<Object>}):undefined} callbacks.success the callback to invoke when fetch cells completed successfully.
 * @property {function({status: Object}):undefined} callbacks.error the callback to invoke when fetch cells failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.
 * @property {Object=} callbackObjects.success
 * @property {Object=} callbackObjects.error
 * @return {undefined}
 */

/**
 * Returns the keys based on the indexes.
 * @method
 * @name keys
 * @memberof oj.DataGridDataSource
 * @instance
 * @param {Object} indexes the index for each axis
 * @property {number|null} indexes.row the index for the row axis
 * @property {number|null} indexes.column the index for the column axis
 * @return {Promise.<Object>} a Promise object which when resolved returns an object containing the keys for each axis
 */

/**
 * Returns the row and column index based on the keys.
 * @method
 * @name indexes
 * @memberof oj.DataGridDataSource
 * @instance
 * @param {Object} keys the key for each axis
 * @property {any} keys.row the key for the row axis
 * @property {any} keys.column the key for the column axis
 * @return {Promise.<Object>} a Promise object which when resolved returns an object containing the index for each axis
 */

/**
 * Performs a sort on the data source.
 * @method
 * @name sort
 * @memberof oj.DataGridDataSource
 * @instance
 * @param {Object|null} criteria the sort criteria.
 * @property {string} criteria.axis The axis in which the sort is performed, valid values are "row", "column"
 * @property {any} criteria.key The key that identifies which header to sort
 * @property {string} criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
 * @param {Object=} callbacks the callbacks to be invoke upon completion of the sort operation.
 * @property {function():undefined=} callbacks.success the callback to invoke when the sort completed successfully.
 * @property {function({status: Object}):undefined=} callbacks.error the callback to invoke when sort failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.
 * @property {Object=} callbackObjects.success
 * @property {Object=} callbackObjects.error
 * @return {undefined}
 */

/**
 * Moves a row from one location to another.
 * @method
 * @name move
 * @memberof oj.DataGridDataSource
 * @instance
 * @param {any} rowToMove the key of the row to move
 * @param {any} referenceRow the key of the reference row which combined with position are used to determine
 *        the destination of where the row should moved to.
 * @param {string} position The position of the moved row relative to the reference row.
 *        Valid values are: "before", "after"
 * @param {Object=} callbacks the callbacks to be invoke upon completion of the move operation.
 * @property {function():undefined=} callbacks.success the callback to invoke when the sort completed successfully.
 * @property {function({status: Object}):undefined=} callbacks.error the callback to invoke when sort failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.
 * @property {Object=} callbackObjects.success
 * @property {Object=} callbackObjects.error
 * @return {undefined}
 */

/**
 * Checks whether a move operation is valid.
 * @param {any} rowToMove the key of the row to move
 * @param {any} referenceRow the key of the reference row which combined with position are used to determine
 *        the destination of where the row should moved to.
 * @param {string} position the position of the moved row relative to the reference row.
 * @return {string} returns "valid" if the move is valid, "invalid" otherwise.
 * @method
 * @name moveOK
 * @memberof oj.DataGridDataSource
 * @instance
 */

/**
 * Determines whether this DataGridDataSource supports certain feature.
 * @method
 * @name getCapability
 * @memberof oj.DataGridDataSource
 * @instance
 * @param {string} feature the feature in which its capabilities is inquired.  Currently the only valid feature is "sort".
 * @return {string|null} the name of the feature.  For "sort", the valid return values are: "full", "none", "row", "column".
 *         For "move", the valid return values are: "row", "none".
 *         Returns null if the feature is not recognized.
 */



/**
 * @class oj.DiagramDataSource
 * @classdesc Base class for Diagram DataSource.  Implementations must implement all of the functions documented here.
 * @param {Object} data data required by the DiagramDataSource implementation
 * @export
 * @extends oj.DataSource
 * @constructor
 * @final
 * @since 3.0
 * @ojtsignore
 */
oj.DiagramDataSource = function (data) {
  oj.DiagramDataSource.superclass.constructor.call(this, data);
};
/**
 * Subclass DiagramDataSource to DataSource
 * @private
 */


oj.Object.createSubclass(oj.DiagramDataSource, oj.DataSource, 'oj.DiagramDataSource');
/**
 * Object that defines diagram node. The object might also have additional custom properties that can be
 * mapped to node styles (see {@link oj.ojDiagram#nodeProperties})
 * or used during Diagram layout (see {@link oj.DvtDiagramLayoutContextNode#getData}).
 * @typedef {Object} NodeObject
 * @memberof oj.DiagramDataSource
 * @property {string} id Node id
 * @property {Array.<string>=} categories An optional array of additional category strings corresponding to the node.
 * @property {string=} label The label for the node. If the string contains new line characters, a multi-line label will be rendered.
 * @property {Array.<Object>=} nodes An array of objects with properties for the child nodes.
 *                     Set value to null to indicate leaf node, if child nodes could be fetched on container disclosure.
 *                     Set value to 'undefined' to indicate potential child nodes, if the child nodes should be fetched on container disclosure.
 * @property {string=} selectable Specifies whether or not the node will be selectable. Acceptable values are 'off' and 'auto'. Default value is 'auto'
 * @property {string=} draggable  Specifies whether or not the node will be draggable. Acceptable values are 'off' and 'auto'. Default value is 'auto'
 * @property {string=} shortDesc  The description of the node. This is used for accessibility and also for customizing the tooltip text.
 */

/**
 * Object that defines diagram link. The object might also have additional custom properties that can be
 * mapped to link styles (see {@link oj.ojDiagram#linkProperties})
 * or used during Diagram layout (see {@link oj.DvtDiagramLayoutContextLink#getData}).
 * @typedef {Object} LinkObject
 * @memberof oj.DiagramDataSource
 * @property {string} id Link id
 * @property {string} startNode Start node id.
 * @property {string} endNode End node id.
 * @property {Array.<string>=} categories An optional array of additional category strings corresponding to the link.
 * @property {string=} label The label for the link. If the string contains new line characters, a multi-line label will be rendered.
 * @property {string=} selectable Specifies whether or not the node will be selectable. Acceptable values are 'off' and 'auto'. Default value is 'auto'
 * @property {string=} shortDesc  The description of the node. This is used for accessibility and also for customizing the tooltip text.
 */

/**
 * Returns child data for the given parent.
 * The data include all immediate child nodes along with links whose endpoints
 * both descend from the current parent node.
 * If all the links are available upfront, they can be returned as part of the
 * top-level data (since all nodes descend from the diagram root).
 * If lazy-fetching links is desirable, the most
 * optimal way to return links is as part of the data of the
 * nearest common ancestor of the link's endpoints.
 *
 * @param {Object|null} parentData An object that contains data for the parent node. See {@link oj.DiagramDataSource.NodeObject} section.
 *                     If parentData is null, the method retrieves data for top level nodes.
 * @return {Promise} Promise resolves to a component object with the following structure:<p>
 * <table>
 * <tbody>
 * <tr><td><b>nodes</b></td><td>An array of objects for the child nodes for the given parent.
 *              See {@link oj.DiagramDataSource.NodeObject} section.</td></tr>
 * <tr><td><b>links</b></td><td>An array of objects for the links for the given parent.
 *              See {@link oj.DiagramDataSource.LinkObject} section.</td></tr>
 * </tbody>
 * </table>
 * @method
 * @name getData
 * @memberof oj.DiagramDataSource
 * @instance
 */

/**
 * Retrieves number of child nodes
 * @param {Object} nodeData A data object for the node in question.
 *                          See {@link oj.DiagramDataSource.NodeObject} section.
 * @return {number} Number of child nodes if child count is available.
 *                  The method returns 0 for leaf nodes.
 *                  The method returns -1 if the child count is unknown
 *                  (e.g. if the children have not been fetched).
 * @method
 * @name getChildCount
 * @memberof oj.DiagramDataSource
 * @instance
 */

/**
 * Indicates whether the specified object contains links
 * that should be discovered in order to display promoted links.
 *
 * @param {Object} nodeData A data object for the container node in question.
 *                          See {@link oj.DiagramDataSource.NodeObject} section
 * @return {string} the valid values are "connected", "disjoint", "unknown"
 * @method
 * @name getDescendantsConnectivity
 * @memberof oj.DiagramDataSource
 * @instance
 */

/**
* @export
* Event types
* @enum {string}
* @memberof oj.DiagramDataSource
*/

oj.DiagramDataSource.EventType = {
  /**
   * Triggered when nodes or links are added to DiagramDataSource.<p>
   * The event payload contains.<p>
   *
   * <table cellspacing="0" style="border-collapse: collapse;">
   * <tbody>
   * <tr><td><b>data</b></td><td>Object</td><td>An object with the following properties:
   *  <ul>
   *    <li>nodes: An array of node objects. See {@link oj.DiagramDataSource.NodeObject} section.</li>
   *    <li>links: An array of link objects. See {@link oj.DiagramDataSource.LinkObject} section.</li>
   *  </ul>
   * </td></tr>
   * <tr><td><b>parentId</b></td><td>string</td><td>parent id for nodes and links</td></tr>
   * <tr><td><b>index</b></td><td>number</td><td>An index where the nodes should be added</td></tr>
   * </tbody>
   * </table>
   */
  ADD: 'add',

  /**
   * Triggered when nodes or links are removed from DiagramDataSource.
   * The event payload contains:<p>
   *
   * <table cellspacing="0" style="border-collapse: collapse;">
   * <tbody>
   * <tr><td><b>data</b></td><td>Object</td><td>An object with the following properties:
   *  <ul>
   *    <li>nodes: An array of node objects. See {@link oj.DiagramDataSource.NodeObject} section.</li>
   *    <li>links: An array of link objects. See {@link oj.DiagramDataSource.LinkObject} section.</li>
   *  </ul>
   * </td></tr>
   * <tr><td><b>parentId</b></td><td>string</td><td>parent id for nodes and links</td></tr>
   * </tbody>
   * </table>
   */
  REMOVE: 'remove',

  /**
   * Triggered when nodes or links are removed from DiagramDataSource.
   * The event payload contains:<p>
   *
   * <table cellspacing="0" style="border-collapse: collapse;">
   * <tbody>
   * <tr><td><b>data</b></td><td>Object</td><td>An object with the following properties:
   *  <ul>
   *    <li>nodes: An array of node objects. See {@link oj.DiagramDataSource.NodeObject} section.</li>
   *    <li>links: An array of link objects. See {@link oj.DiagramDataSource.LinkObject} section.</li>
   *  </ul>
   * </td></tr>
   * </tbody>
   * </table>
   */
  CHANGE: 'change'
};


// Define a mapping variable that maps the return value of the module to the name used in the callback function of a require call.
var DataSourceCommon = {};
DataSourceCommon.DataGridDataSource = oj.DataGridDataSource;

  return DataSourceCommon;
});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojarraytabledatasource',['ojs/ojcore', 'ojs/ojtranslation', 'jquery', 'ojs/ojlogger', 'ojs/ojdatasource-common'], function(oj, Translations, $, Logger)
{
  "use strict";


/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* global Promise:false, Logger:false, Translations:false */

/* jslint browser: true,devel:true*/

/**
 * @export
 * @class oj.ArrayTableDataSource
 * @since 1.0
 * @ojtsignore
 * @extends oj.TableDataSource
 * @classdesc Object representing data available from an array.  This data source can be used by [ListView]{@link oj.ojListView}, [NavigationList]{@link oj.ojNavigationList},
 *            [TabBar]{@link oj.ojTabBar}, and [Table]{@link oj.ojTable}.<br><br>
 *            See the <a href="../jetCookbook.html?component=table&demo=basicTable">Table - Base Table</a> demo for an example.<br><br>
 *            Refer to {@link oj.TableDataSource} for other data sources that represent tabular data.
 * @param {Array|Object|function():Array} data data supported by the components
 *                                      <p>This can be either an Array, or a Knockout observableArray.</p>
 *                                      <p>Each array element should be an object representing one row of data, with the property names and values corresponding to column names and values.
 *                                         Array of primitive values such as ["Apple", "Orange"] is not currently supported.</p>
 * @param {Object|null} [options] Options for the TableDataSource
 * @param {string} [options.idAttribute] The column that contains the row key.
 *                 If this is not specified, all the values in a row are used as the key.
 * @param {"enabled"|"disabled"} [options.startFetch] Control whether to start initial fetch when the TableDataSource is bound to a component.  Valid values are:<br><br>
 *                                    <b>"enabled"</b> (default) - Start initial fetch automatically when the TableDataSource is bound to a component.<br>
 *                                    <b>"disabled"</b> - Do not start initial fetch automatically.  Application will call the <a href="#fetch">fetch()</a> method to
 *                                                        start the first fetch.
 * @ojdeprecated {since: '5.0.0', description: 'Use ArrayDataProvider instead.'}
 * @ojsignature {target: "Type",
 *               value: "KnockoutObservableArray<object>|Array<object>",
 *               for: "data"}
 * @constructor
 * @final
 * @ojtsignore
 * @example
 * // First initialize an array
 * var deptArray = [{DepartmentId: 10, DepartmentName: 'Administration', LocationId: 200},
 *                  {DepartmentId: 20, DepartmentName: 'Marketing', LocationId: 200},
 *                  {DepartmentId: 30, DepartmentName: 'Purchasing', LocationId: 200}];
 *
 * // Then create an ArrayTableDataSource object with the array
 * var dataSource = new oj.ArrayTableDataSource(deptArray, {idAttribute: 'DepartmentId'});
 */
oj.ArrayTableDataSource = function (data, options) {
  // Initialize
  this.data = data || {}; // This was put in to keep closure happy...

  if (!(data instanceof Array) && !this._isObservableArray(data)) {
    // we only support Array or ko.observableArray.
    var errSummary = oj.TableDataSource._LOGGER_MSG._ERR_DATA_INVALID_TYPE_SUMMARY;
    var errDetail = oj.TableDataSource._LOGGER_MSG._ERR_DATA_INVALID_TYPE_DETAIL;
    throw new Error(errSummary + '\n' + errDetail);
  }

  if (options == null || options.idAttribute == null) {
    Logger.info(oj.ArrayTableDataSource._LOGGER_MSG._INFO_ARRAY_TABLE_DATASOURCE_IDATTR);
  }

  oj.ArrayTableDataSource.superclass.constructor.call(this, data, options);
  this._eventHandlers = [];
  this._rows = {};

  if (data != null) {
    this._idAttribute = null;

    if (options != null && options.idAttribute != null) {
      this._idAttribute = options.idAttribute;
    }
  }

  if (options != null && (options.startFetch === 'enabled' || options.startFetch == null) || options == null) {
    this._startFetchEnabled = true;
  }
}; // Subclass from oj.DataSource


oj.Object.createSubclass(oj.ArrayTableDataSource, oj.TableDataSource, 'oj.ArrayTableDataSource');
/**
 * @export
 * @desc If set to a function(row1, row2), then this function is called comparing raw row data (see the
 * JavaScript array.sort() for details)
 * @memberof oj.ArrayTableDataSource
 * @type {null|string|Function}
 * @ojsignature {target: "Type",
 *               value: "null|string|((param0: object, param1?: object)=> number|string|object)"}
 */

oj.ArrayTableDataSource.prototype.comparator = null;
/**
 * @export
 *
 * @type {Object}
 * @property {any} criteria.key The key that identifies which field to sort
 * @property {'ascending'|'descending'|'none'} criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
 *
 * @desc The sort criteria. Whenever sort() is called with the criteria parameter, that value is copied to this
 * property. If sort() is called with empty sort criteria then the criteria set in this property is used.
 * @memberof oj.ArrayTableDataSource
 */

oj.ArrayTableDataSource.prototype.sortCriteria = null;
/**
 * Initializes the instance.
 * @memberof oj.ArrayTableDataSource
 * @instance
 * @override
 * @protected
 */

oj.ArrayTableDataSource.prototype.Init = function () {
  oj.ArrayTableDataSource.superclass.Init.call(this);
};
/**
 * Add a row (or array of rows) to the end
 *
 * @param {Object|Array.<Object>} m Row object data (or array of rows) to add. These should be sets of attribute/values.
 * @param {Object=} options
 * @param {boolean} [options.silent] if set, do not fire an add event<p>
 * @param {number|Array.<number>} [options.at] splice the new row at the value given (at:index). If an array of rows then this should be an array of indexes <p>
 * @return {Promise} Promise object resolves to a compound object which contains an array of row data objects, an array of keys, and an array of indexes which were added triggering done when complete.<p>
 *         The structure of the resolved compound object is:<p>
 * <table>
 * <tbody>
 * <tr><td><b>data</b></td><td>An array of raw row data</td></tr>
 * <tr><td><b>keys</b></td><td>An array of key values for the rows</td></tr>
 * <tr><td><b>indexes</b></td><td>An array of index values for the rows</td></tr>
 * </tbody>
 * </table>
 * @ojsignature {target:"Type",
 *               value: "Promise<null|oj.ArrayTableDataSource.RowDatas>",
 *               for: "returns",
 *               jsdocOverride: true}
 * @export
 * @expose
 * @memberof oj.ArrayTableDataSource
 * @instance
 */


oj.ArrayTableDataSource.prototype.add = function (m, options) {
  // eslint-disable-next-line no-param-reassign
  options = options || {};

  this._checkDataLoaded();

  var index = options.at;
  return this._addToRowSet(m, index, options);
};
/**
 * Return the row data found at the given index.
 *
 * @param {number} index Index for which to return the row data.
 * @param {Object=} options Options to control the at.
 * @return {Promise} Promise resolves to a compound object which has the structure below. If the index is out of range, Promise resolves to null.<p>
 * <table>
 * <tbody>
 * <tr><td><b>data</b></td><td>The raw row data</td></tr>
 * <tr><td><b>index</b></td><td>The index for the row</td></tr>
 * <tr><td><b>key</b></td><td>The key value for the row</td></tr>
 * </tbody>
 * </table>
 * @ojsignature {target:"Type",
 *               value: "Promise<null|oj.TableDataSource.RowData>",
 *               for: "returns",
 *               jsdocOverride: true}
 * @export
 * @expose
 * @memberof oj.ArrayTableDataSource
 * @instance
 */
// eslint-disable-next-line no-unused-vars


oj.ArrayTableDataSource.prototype.at = function (index, options) {
  this._checkDataLoaded();

  var row;

  if (index < 0 || index >= this._rows.data.length) {
    row = null;
  } else {
    row = {
      data: this._rows.data[index],
      index: index,
      key: this._getId(this._rows.data[index])
    };
  }

  return new Promise(function (resolve) {
    resolve(row);
  });
};
/**
 * Change a row (or array of rows), if found.
 * @param {Object|Array.<Object>} m Row object data (or array of rows) to change. These should be sets of attribute/values.
 * @param {Object=} options
 * @param {boolean} [options.silent] if set, do not fire an add event<p>
 * @return {Promise} Promise object resolves to a compound object which contains an array of row data objects, an array of keys, and an array of indexes which were changed triggering done when complete.<p>
 *          The structure of the resolved compound object is:<p>
 * <table>
 * <tbody>
 * <tr><td><b>data</b></td><td>An array of raw row data</td></tr>
 * <tr><td><b>keys</b></td><td>An array of key values for the rows</td></tr>
 * <tr><td><b>indexes</b></td><td>An array of index values for the rows</td></tr>
 * </tbody>
 * </table>
 * @ojsignature {target:"Type",
 *               value: "Promise<null|oj.ArrayTableDataSource.RowDatas>",
 *               for: "returns",
 *               jsdocOverride: true}
 * @export
 * @expose
 * @memberof oj.ArrayTableDataSource
 * @instance
 */


oj.ArrayTableDataSource.prototype.change = function (m, options) {
  // eslint-disable-next-line no-param-reassign
  options = options || {};

  this._checkDataLoaded();

  var silent = options.silent;
  var rowArray = {};
  rowArray.data = [];
  rowArray.keys = [];
  rowArray.indexes = [];

  if (!(m instanceof Array)) {
    // eslint-disable-next-line no-param-reassign
    m = [m];
  }

  for (var i = 0; i < m.length; i++) {
    var row = m[i];

    if (row != null) {
      var key = this._getId(row);

      var changedRow = this._getInternal(key, false);

      rowArray.data.push(this._wrapWritableValue(row));
      rowArray.keys.push(key);
      rowArray.indexes.push(changedRow.index);
      this._rows.data[changedRow.index] = row;
    }
  }

  if (!silent && rowArray.data.length > 0) {
    oj.TableDataSource.superclass.handleEvent.call(this, oj.TableDataSource.EventType.CHANGE, rowArray);
  }

  return Promise.resolve(rowArray);
};
/**
 * Fetch the row data.
 * @param {Object=} options Options to control fetch
 * @param {number} [options.startIndex] The index at which to start fetching records.
 * @param {boolean} [options.silent] If set, do not fire a sync event.
 * @return {Promise} Promise object resolves to a compound object which contains an array of row data objects, an array of ids, and the startIndex triggering done when complete.<p>
 *      The structure of the resolved compound object is:<p>
 * <table>
 * <tbody>
 * <tr><td><b>data</b></td><td>An array of raw row data</td></tr>
 * <tr><td><b>keys</b></td><td>An array of key values for the rows</td></tr>
 * <tr><td><b>startIndex</b></td><td>The startIndex for the returned set of rows</td></tr>
 * </tbody>
 * </table>
 * @ojsignature {target:"Type",
 *               value: "Promise<null|oj.TableDataSource.RowDatas>",
 *               for: "returns",
 *               jsdocOverride: true}
 * @export
 * @expose
 * @memberof oj.ArrayTableDataSource
 * @instance
 */


oj.ArrayTableDataSource.prototype.fetch = function (options) {
  // eslint-disable-next-line no-param-reassign
  options = options || {};
  var fetchType = options.fetchType;

  if (fetchType === 'init' && !this._startFetchEnabled) {
    return Promise.resolve();
  }

  return this._fetchInternal(options);
};
/**
 * Return the first row data whose id value is the given id
 * @param {string} id ID for which to return the row data, if found.
 * @param {Object=} options Options to control the get.
 * @return {Promise} Promise which resolves to a compound object which has the structure below where the id matches the given id. If none are found, resolves to null.<p>
 * <table>
 * <tbody>
 * <tr><td><b>data</b></td><td>The raw row data</td></tr>
 * <tr><td><b>index</b></td><td>The index for the row</td></tr>
 * <tr><td><b>key</b></td><td>The key value for the row</td></tr>
 * </tbody>
 * </table>
 * @ojsignature {target:"Type",
 *               value: "Promise<null|oj.TableDataSource.RowData>",
 *               for: "returns",
 *               jsdocOverride: true}
 * @export
 * @expose
 * @memberof oj.ArrayTableDataSource
 * @instance
 */
// eslint-disable-next-line no-unused-vars


oj.ArrayTableDataSource.prototype.get = function (id, options) {
  this._checkDataLoaded();

  return Promise.resolve(this._getInternal(id, true));
};
/**
 * Determines whether this TableDataSource supports certain feature.
 * @param {string} feature the feature in which its capabilities is inquired.  Currently the only valid feature is "sort".
 * @return {string|null} the name of the feature.  For "sort", the valid return values are: "full", "none".
 *         Returns null if the feature is not recognized.
 * @export
 * @expose
 * @memberof oj.ArrayTableDataSource
 * @instance
 */
// eslint-disable-next-line no-unused-vars


oj.ArrayTableDataSource.prototype.getCapability = function (feature) {
  return 'full';
};
/**
 * Remove a row (or array of rows), if found.
 * @param {Object|Array.<Object>}  m Row object data (or array of rows) to remove. These should be sets of attribute/values.
 * @param {Object=} options
 * @param {boolean} [options.silent] if set, do not fire a remove event
 * @return {Promise} Promise object resolves to a compound object which contains an array of row data objects, an array of keys, and an array of indexes which were removed triggering done when complete.<p>
 *      The structure of the resolved compound object is:<p>
 * <table>
 * <tbody>
 * <tr><td><b>data</b></td><td>An array of raw row data</td></tr>
 * <tr><td><b>keys</b></td><td>An array of key values for the rows</td></tr>
 * <tr><td><b>indexes</b></td><td>An array of index values for the rows</td></tr>
 * </tbody>
 * </table>
 * @ojsignature {target:"Type",
 *               value: "Promise<null|oj.ArrayTableDataSource.RowDatas>",
 *               for: "returns",
 *               jsdocOverride: true}
 * @export
 * @expose
 * @memberof oj.ArrayTableDataSource
 * @instance
 */


oj.ArrayTableDataSource.prototype.remove = function (m, options) {
  // eslint-disable-next-line no-param-reassign
  options = options || {};

  this._checkDataLoaded();

  return this._removeInternal(m, options);
};
/**
 * Remove and replace the entire list of rows with a new set of rows, if provided. Otherwise, empty the datasource. The next fetch
 * call will re-populate the datasource with the original array data. To empty out the data, call reset with an empty array.
 * @param {Array.<Object>=} data Array of row objects with which to replace the data.
 * @param {Object=} options user options, passed to event
 * @return {Promise.<void>} promise object triggering done when complete.
 * @export
 * @expose
 * @memberof oj.ArrayTableDataSource
 * @instance
 */


oj.ArrayTableDataSource.prototype.reset = function (data, options) {
  // eslint-disable-next-line no-param-reassign
  options = options || {}; // eslint-disable-next-line no-param-reassign

  options.previousRows = this._rows;
  var silent = options.silent;

  if (data != null) {
    this.data = data;
  }

  this._rows = {};
  this._totalSize = 0; // clear any change subscription even if no new data is provided
  // a new subscription will be created on the next data fetch

  if (this._arrayChangeSubscription) {
    this._arrayChangeSubscription.dispose();

    this._arrayChangeSubscription = null;
  }

  if (!silent) {
    oj.TableDataSource.superclass.handleEvent.call(this, oj.TableDataSource.EventType.RESET, null);
  }

  return Promise.resolve();
};
/**
 * Performs a sort on the data source.
 * @param {Object|null} [criteria] the sort criteria.
 * @param {any} criteria.key The key that identifies which field to sort
 * @param {'ascending'|'descending'|'none'} criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
 * @return {Promise.<null>} promise object triggering done when complete.
 * @export
 * @expose
 * @memberof oj.ArrayTableDataSource
 * @instance
 */


oj.ArrayTableDataSource.prototype.sort = function (criteria) {
  if (criteria == null) {
    // eslint-disable-next-line no-param-reassign
    criteria = this.sortCriteria;
  } else {
    this.sortCriteria = criteria;
  } // eslint-disable-next-line no-param-reassign


  criteria = criteria || {};

  this._checkDataLoaded();

  var self = this;
  return new Promise(function (resolve) {
    var comparator = self._getComparator();

    self._rows.data.sort(function (a, b) {
      return oj.ArrayTableDataSource._sortFunc(a, b, comparator, self);
    });

    self._sorted = true;
    var result = {
      header: criteria.key,
      direction: criteria.direction
    };
    oj.TableDataSource.superclass.handleEvent.call(self, oj.TableDataSource.EventType.SORT, result);
    resolve(result);
  });
};
/**
 * Return the total size of data available, including server side if not local.
 * @returns {number} total size of data
 * @export
 * @expose
 * @memberof oj.ArrayTableDataSource
 * @instance
 */


oj.ArrayTableDataSource.prototype.totalSize = function () {
  this._checkDataLoaded();

  return this._totalSize;
};

oj.ArrayTableDataSource.prototype._addToRowSet = function (m, index, options) {
  // eslint-disable-next-line no-param-reassign
  options = options || {};
  var silent = options.silent;
  var rowArray = {};
  rowArray.data = [];
  rowArray.keys = [];
  rowArray.indexes = [];

  if (!(m instanceof Array)) {
    // eslint-disable-next-line no-param-reassign
    m = [m];
  }

  if (index != null && !(index instanceof Array)) {
    // eslint-disable-next-line no-param-reassign
    index = [index];
  }

  for (var i = 0; i < m.length; i++) {
    var row = m[i];

    if (row != null) {
      var key = this._getId(row);

      rowArray.data.push(this._wrapWritableValue(row));
      rowArray.keys.push(key);

      if (this._sorted === true && this._rows.data.length > 0) {
        var self = this;

        for (var j = 0; j < this._rows.data.length; j++) {
          if (oj.ArrayTableDataSource._sortFunc(row, this._rows.data[j], self._getComparator(), self) < 0) {
            this._rows.data.splice(j, 0, row);

            rowArray.indexes.push(j);
            break;
          } else if (j === this._rows.data.length - 1) {
            this._rows.data.push(row);

            rowArray.indexes.push(j + 1);
            break;
          }
        }
      } else if (index == null) {
        this._rows.data.push(row);

        rowArray.indexes.push(this._rows.data.length - 1);
      } else {
        this._rows.data.splice(index[i], 0, row);

        rowArray.indexes.push(index[i]);
      }

      this._totalSize += 1;

      this._realignRowIndices();
    }
  }

  if (!silent && rowArray.data.length > 0) {
    oj.TableDataSource.superclass.handleEvent.call(this, oj.TableDataSource.EventType.ADD, rowArray);
  }

  return Promise.resolve(rowArray);
};

oj.ArrayTableDataSource.prototype._checkDataLoaded = function () {
  if (!this._isDataLoaded()) {
    var dataArray = [];

    if (this.data instanceof Array) {
      dataArray = this.data;
    } else if (this._isObservableArray(this.data)) {
      dataArray =
      /** @type {Function} */
      this.data.peek();

      this._subscribeObservableArray(this.data);
    }

    this._rows = this._getRowArray(dataArray);
    this._totalSize = dataArray.length;
  }
};

oj.ArrayTableDataSource.prototype._isDataLoaded = function () {
  if (this._rows == null || this._rows.data == null) {
    return false;
  }

  return true;
};

oj.ArrayTableDataSource.prototype._fetchInternal = function (options) {
  // eslint-disable-next-line no-param-reassign
  options = options || {};

  this._startFetch(options);

  this._checkDataLoaded();

  var pageSize;
  var rowArray;
  var keyArray;
  var endIndex;

  try {
    pageSize = options.pageSize > 0 ? options.pageSize : -1;

    if (!this._startIndex) {
      this._startIndex = 0;
    }

    this._startIndex = options.startIndex == null ? this._startIndex : options.startIndex;
    endIndex = oj.ArrayTableDataSource._getEndIndex(this._rows, this._startIndex, pageSize);
    rowArray = [];
    keyArray = [];

    for (var i = this._startIndex; i <= endIndex; i++) {
      var key = this._getId(this._rows.data[i]);

      var wrappedRow = this._wrapWritableValue(this._rows.data[i]);

      rowArray[i - this._startIndex] = wrappedRow;
      keyArray[i - this._startIndex] = key;
    }
  } catch (err) {
    this._endFetch(options, null, err);

    return Promise.reject(err);
  }

  if (endIndex < this._startIndex) {
    // this means we have no more rows at the startIndex. So adjust our
    // startIndex down to indicate the last row
    this._startIndex = endIndex + 1;
  } // eslint-disable-next-line no-param-reassign


  options.pageSize = pageSize; // eslint-disable-next-line no-param-reassign

  options.startIndex = this._startIndex; // eslint-disable-next-line no-param-reassign

  options.refresh = true;
  var result = {
    data: rowArray,
    keys: keyArray,
    startIndex: this._startIndex
  };

  this._endFetch(options, result, null);

  return Promise.resolve(result);
};

oj.ArrayTableDataSource.prototype._getInternal = function (id, wrap) {
  var result = null;

  for (var i = 0; i < this._rows.data.length; i++) {
    var row = this._rows.data[i];
    var wrappedRow;

    if (row !== undefined) {
      var key = this._getId(row);

      if ($.isArray(key) && $.isArray(id)) {
        if (key.length === id.length) {
          var equal = true;

          for (var j = 0; j < id.length; j++) {
            if (key[j] !== id[j]) {
              equal = false;
              break;
            }
          }

          if (equal) {
            if (wrap) {
              wrappedRow = this._wrapWritableValue(row);
              result = {
                data: wrappedRow,
                key: key,
                index: this._rows.indexes[i]
              };
            } else {
              result = {
                data: row,
                key: key,
                index: this._rows.indexes[i]
              };
            }

            break;
          }
        }
      } else if (key === id) {
        if (wrap) {
          wrappedRow = this._wrapWritableValue(row);
          result = {
            data: wrappedRow,
            key: key,
            index: this._rows.indexes[i]
          };
        } else {
          result = {
            data: row,
            key: key,
            index: this._rows.indexes[i]
          };
        }

        break;
      }
    }
  }

  return result;
};

oj.ArrayTableDataSource.prototype._getComparator = function () {
  var comparator = this.comparator;

  if (comparator == null) {
    var key = this.sortCriteria.key;
    var direction = this.sortCriteria.direction;

    if (direction === 'ascending') {
      comparator = function comparator(row) {
        if ($.isFunction(row[key])) {
          return row[key]();
        }

        return row[key];
      };
    } else if (direction === 'descending') {
      comparator = function comparator(rowA, rowB) {
        var a;
        var b;

        if ($.isFunction(rowA[key])) {
          a = rowA[key]();
          b = rowB[key]();
        } else {
          a = rowA[key];
          b = rowB[key];
        }

        if (a === b) {
          return 0;
        }

        return a > b ? -1 : 1;
      };
    }
  }

  return comparator;
}; // Realign all the indices of the rows (after sort for example)


oj.ArrayTableDataSource.prototype._realignRowIndices = function () {
  for (var i = 0; i < this._rows.data.length; i++) {
    this._rows.indexes[i] = i;
  }
};

oj.ArrayTableDataSource.prototype._removeInternal = function (m, options) {
  var i;
  var self = this; // eslint-disable-next-line no-param-reassign

  options = options || {};
  var silent = options.silent;
  var rowArray = {};
  rowArray.data = [];
  rowArray.keys = [];
  rowArray.indexes = [];

  if (!(m instanceof Array)) {
    // eslint-disable-next-line no-param-reassign
    m = [m];
  }

  var sortedRowArray = [];

  for (i = 0; i < m.length; i++) {
    var row = m[i];

    if (row != null) {
      var key = this._getId(row);

      var deletedRow = this._getInternal(key, false);

      if (deletedRow != null) {
        sortedRowArray.push({
          data: deletedRow.data,
          key: deletedRow.key,
          index: deletedRow.index
        });
      }
    }
  }

  sortedRowArray.sort(function (a, b) {
    return a.index - b.index;
  });

  for (i = 0; i < sortedRowArray.length; i++) {
    rowArray.data.push(sortedRowArray[i].data);
    rowArray.keys.push(sortedRowArray[i].key);
    rowArray.indexes.push(sortedRowArray[i].index);
  }

  for (i = rowArray.indexes.length - 1; i >= 0; i--) {
    this._rows.data.splice(rowArray.indexes[i], 1);

    this._rows.indexes.splice(rowArray.indexes[i], 1);

    this._totalSize -= 1;
  }

  this._realignRowIndices();

  if (!silent && rowArray.data.length > 0) {
    oj.TableDataSource.superclass.handleEvent.call(self, oj.TableDataSource.EventType.REMOVE, rowArray);
  }

  return Promise.resolve(rowArray);
};

oj.ArrayTableDataSource.prototype._setRow = function (index, row) {
  this._rows[index] = row; // eslint-disable-next-line no-param-reassign

  row.index = index;
};
/**
 * Indicate starting fetch
 * @param {Object} options
 * @private
 * @memberof oj.ArrayTableDataSource
 */


oj.ArrayTableDataSource.prototype._startFetch = function (options) {
  if (!options.silent) {
    oj.TableDataSource.superclass.handleEvent.call(this, oj.TableDataSource.EventType.REQUEST, {
      startIndex: options.startIndex
    });
  }
};
/**
 * Indicate ending fetch
 * @param {Object} options
 * @param {Object} result Result object
 * @param {Object} error Error
 * @private
 * @memberof oj.ArrayTableDataSource
 */


oj.ArrayTableDataSource.prototype._endFetch = function (options, result, error) {
  if (error != null) {
    oj.TableDataSource.superclass.handleEvent.call(this, oj.TableDataSource.EventType.ERROR, error);
  } else if (!options.silent) {
    oj.TableDataSource.superclass.handleEvent.call(this, oj.TableDataSource.EventType.SYNC, result);
  }
};

oj.ArrayTableDataSource.prototype._handleRowChange = function (event) {
  // eslint-disable-next-line no-param-reassign
  event.startIndex = this._startIndex;
  oj.TableDataSource.superclass.handleEvent.call(this, oj.TableDataSource.EventType.CHANGE, event);
};

oj.ArrayTableDataSource._compareKeys = function (keyA, keyB, direction) {
  if (direction === 'descending') {
    if (keyA < keyB) {
      return 1;
    }

    if (keyB < keyA) {
      return -1;
    }
  } else {
    if (keyA > keyB) {
      return 1;
    }

    if (keyB > keyA) {
      return -1;
    }
  }

  return 0;
};

oj.ArrayTableDataSource._getEndIndex = function (rows, startIndex, pageSize) {
  var endIndex = rows.data.length - 1;

  if (pageSize > 0) {
    endIndex = startIndex + pageSize - 1;
    endIndex = endIndex > rows.data.length - 1 ? rows.data.length - 1 : endIndex;
  }

  return endIndex;
};

oj.ArrayTableDataSource._getKey = function (val, attr) {
  if (typeof val[attr] === 'function') {
    return val[attr]();
  }

  return val[attr];
};

oj.ArrayTableDataSource.prototype._getRowArray = function (values) {
  var endIndex = values.length - 1;
  var rowArray = {};
  rowArray.data = [];
  rowArray.indexes = [];
  this._attributes = null;

  for (var i = 0; i <= endIndex; i++) {
    var clonedRowValues = {};
    var rowValues = values[i];

    if (rowValues) {
      var props = Object.keys(rowValues);

      for (var j = 0; j < props.length; j++) {
        var prop = props[j];
        clonedRowValues[prop] = rowValues[prop];

        if (i === 0) {
          if (this._attributes == null) {
            this._attributes = [];
          }

          this._attributes.push(prop);
        }
      }
    } else {
      clonedRowValues = null;
    }

    rowArray.data[i] = clonedRowValues;
    rowArray.indexes[i] = i;
  }

  return rowArray;
};

oj.ArrayTableDataSource.prototype._getId = function (row) {
  var id;

  var idAttribute = this._getIdAttr(row);

  var errDetail;

  if (row == null) {
    return null;
  }

  if ($.isArray(idAttribute)) {
    var i;
    id = [];

    for (i = 0; i < idAttribute.length; i++) {
      if (idAttribute[i] in row) {
        id[i] = oj.ArrayTableDataSource._getKey(row, idAttribute[i]);
      } else {
        errDetail = Translations.applyParameters(oj.ArrayTableDataSource._LOGGER_MSG._ERR_ARRAY_TABLE_DATASOURCE_IDATTR_NOT_IN_ROW, [idAttribute[i]]);
        throw new Error(errDetail);
      }
    }
  } else if (idAttribute in row) {
    id = oj.ArrayTableDataSource._getKey(row, idAttribute);
  } else {
    errDetail = Translations.applyParameters(oj.ArrayTableDataSource._LOGGER_MSG._ERR_ARRAY_TABLE_DATASOURCE_IDATTR_NOT_IN_ROW, [idAttribute]);
    throw new Error(errDetail);
  }

  return id;
};

oj.ArrayTableDataSource.prototype._getIdAttr = function (row) {
  if (this._idAttribute != null) {
    return this._idAttribute;
  }

  if (this._attributes == null) {
    this._attributes = [];
    var props = Object.keys(row);

    for (var i = 0; i < props.length; i++) {
      var prop = props[i];

      this._attributes.push(prop);
    }
  }

  if (Object.prototype.hasOwnProperty.call(this._attributes, 'id')) {
    return 'id';
  }

  return this._attributes;
};

oj.ArrayTableDataSource._sortFunc = function (a, b, comparator, self) {
  var keyA;
  var keyB;
  var i;
  var retVal;
  var direction = self.sortCriteria.direction;

  if ($.isFunction(comparator)) {
    // How many args?
    if (comparator.length === 1) {
      // "sortBy" comparator option
      keyA = comparator.call(self, a);
      keyB = comparator.call(self, b);
      var attrs1 = oj.StringUtils.isString(keyA) ? keyA.split(',') : [keyA];
      var attrs2 = oj.StringUtils.isString(keyB) ? keyB.split(',') : [keyB];

      for (i = 0; i < attrs1.length; i++) {
        retVal = oj.ArrayTableDataSource._compareKeys(attrs1[i], attrs2[i], direction);

        if (retVal !== 0) {
          return retVal;
        }
      }

      return 0;
    } // "sort" comparator option


    return comparator.call(self, a, b);
  } // String option


  if (oj.StringUtils.isString(comparator)) {
    var attrs = comparator.split(',');

    for (i = 0; i < attrs.length; i++) {
      keyA = oj.ArrayTableDataSource._getKey(a, attrs[i]);
      keyB = oj.ArrayTableDataSource._getKey(b, attrs[i]);
      retVal = oj.ArrayTableDataSource._compareKeys(keyA, keyB, direction);

      if (retVal !== 0) {
        return retVal;
      }
    }
  }

  return 0;
};

oj.ArrayTableDataSource.prototype._subscribeObservableArray = function (data) {
  if (!(data instanceof Array)) {
    var self = this; // subscribe to observableArray arrayChange event to get individual updates

    this._arrayChangeSubscription =
    /** @type {{subscribe: Function}} */
    data.subscribe(function (changes) {
      var updatedIndexes = [];
      var removeDuplicate = [];
      var i;
      var j;
      var index;
      var status;

      for (i = 0; i < changes.length; i++) {
        index = changes[i].index;
        status = changes[i].status;

        for (j = 0; j < changes.length; j++) {
          if (j !== i && index === changes[j].index && status !== changes[j].status && updatedIndexes.indexOf(i) < 0 && removeDuplicate.indexOf(i) < 0) {
            if (status === 'deleted') {
              removeDuplicate.push(i);
              updatedIndexes.push(j);
            } else {
              removeDuplicate.push(j);
              updatedIndexes.push(i);
            }
          }
        }
      }

      var rowArray = [];

      for (i = 0; i < changes.length; i++) {
        if (updatedIndexes.indexOf(i) >= 0) {
          var key = self._getId(self._rows.data[changes[i].index]);

          var updatedKey = self._getId(changes[i].value);

          if (updatedKey != null && !oj.Object.compareValues(updatedKey, key)) {
            self._rows.data[changes[i].index] = changes[i].value;
          }

          rowArray.push(changes[i].value);
        }
      }

      self.change(rowArray, null);
      rowArray = [];
      var indexArray = [];

      for (i = 0; i < changes.length; i++) {
        if (updatedIndexes.indexOf(i) < 0 && removeDuplicate.indexOf(i) < 0 && changes[i].status === 'deleted') {
          rowArray.push(changes[i].value);
        }
      }

      self.remove(rowArray, null);
      rowArray = [];
      indexArray = [];

      for (i = 0; i < changes.length; i++) {
        if (updatedIndexes.indexOf(i) < 0 && removeDuplicate.indexOf(i) < 0 && changes[i].status === 'added') {
          rowArray.push(changes[i].value);
          indexArray.push(changes[i].index);
        }
      }

      self.add(rowArray, {
        at: indexArray
      });
    }, null, 'arrayChange');
  }
};

oj.ArrayTableDataSource.prototype._wrapWritableValue = function (m) {
  var returnObj = {};

  if (m) {
    var props = Object.keys(m);

    for (var i = 0; i < props.length; i++) {
      oj.ArrayTableDataSource._defineProperty(returnObj, m, props[i]);
    }
  } else {
    return null;
  }

  return returnObj;
}; // To check for observableArray, we can't do instanceof check because it's
// a function. So we just check if it contains a subscribe function.


oj.ArrayTableDataSource.prototype._isObservableArray = function (obj) {
  return typeof obj === 'function' && typeof obj.subscribe === 'function';
};

oj.ArrayTableDataSource._defineProperty = function (row, m, prop) {
  Object.defineProperty(row, prop, {
    get: function get() {
      return m[prop];
    },
    set: function set(newValue) {
      // eslint-disable-next-line no-param-reassign
      m[prop] = newValue;
    },
    enumerable: true
  });
};

oj.ArrayTableDataSource._LOGGER_MSG = {
  _INFO_ARRAY_TABLE_DATASOURCE_IDATTR: "idAttribute option has not been specified. Will default to using 'id' if the field exists. If not, will use all the fields.",
  _ERR_ARRAY_TABLE_DATASOURCE_IDATTR_NOT_IN_ROW: 'Specified idAttribute {0} not in row data. Please ensure all specified idAttribute fields are in the row data or do not specify idAttribute and all fields will be used as id.'
};
/**
 * Shape of Data Info returned by methods like, add/change/remove.
 * @typedef {Object} oj.ArrayTableDataSource.RowDatas
 * @property {Array.<Object>} data An array of raw row data.
 * @property {Array.<any>} keys An array of key values for the rows.
 * @property {Array.<number>} indexes An array of index values for the rows.
 */

});

define("rjs_bundles/listBundle_es5", function(){});
