/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojlogger',[], function()
{
  "use strict";


/* jslint browser: true*/

/**
 * @namespace
 * @name oj.Logger
 * @hideconstructor
 * @ojtsmodule
 * @since 1.0.0
 *
 * @classdesc
 * <h3>JET Logger</h3>
 *
 * <p>Logger object writes into the native browser console or a custom writer, if a custom writer is set as an option.
 * To use a custom writer, implement the following writer methods: log(), info(), warn(), error()
 *
 * <p>When any of the logging methods is called, it compares the requested log level with the value of a log level option
 * and logs the message if the log level is sufficient.
 *
 * <p>If the logging options are changed at a later point, the Logger will use the modified options for the subsequent log operations.
 *
 * <p>All the logging methods support string formatting, accept variable number of arguments and accept a function as a parameter.
 * When a callback function is specified as a parameter the function will be called if the log level is sufficient.
 *
 * <h3> Usage : </h3>
 * <pre class="prettyprint">
 * <code>
 * //optional calls, see defaults
 * oj.Logger.option("level",  oj.Logger.LEVEL_INFO);
 * oj.Logger.option("writer",  customWriter);  //an object that implements the following methods: log(), info(), warn(), error()
 *
 * // logging a message
 * oj.Logger.info("My log level is %d", oj.Logger.option("level"));  // string formatting
 * oj.Logger.warn("Beware of bugs", "in the above code");            // multiple parameters
 *
 * // using a callback function as a parameter
 * oj.Logger.info(function(){
 *    var foo = "This ";
 *    var bar = "is ";
 *    var zing = "a function";
 *    return foo + bar + zing;
 * });
 * </code></pre>
 *
 * @desc oj.Logger cannot be instantiated
 * @export
 */
var Logger = {};
/**
 * Log level none
 * @const
 * @export
 * @type {number}
 * @memberof oj.Logger
 * @alias LEVEL_NONE
 */

Logger.LEVEL_NONE = 0;
/**
 * Log level error
 * @const
 * @type {number}
 * @export
 * @memberof oj.Logger
 * @alias LEVEL_ERROR
 */

Logger.LEVEL_ERROR = 1;
/**
 * Log level warning
 * @const
 * @type {number}
 * @export
 * @memberof oj.Logger
 * @alias LEVEL_WARN
 */

Logger.LEVEL_WARN = 2;
/**
 * Log level info
 * @const
 * @type {number}
 * @export
 * @memberof oj.Logger
 * @alias LEVEL_INFO
 */

Logger.LEVEL_INFO = 3;
/**
 * Log level - general message
 * @const
 * @type {number}
 * @export
 * @memberof oj.Logger
 * @alias LEVEL_LOG
 */

Logger.LEVEL_LOG = 4;
/* private constants*/

Logger._METHOD_ERROR = 'error';
Logger._METHOD_WARN = 'warn';
Logger._METHOD_INFO = 'info';
Logger._METHOD_LOG = 'log';
Logger._defaultOptions = {
  level: Logger.LEVEL_ERROR,
  writer: null
};
Logger._options = Logger._defaultOptions;
/* public members*/

/**
 * Writes an error message.
 * @param {any=} message A function that returns the message to be logged, a string containing zero or more substitution strings, or an object to be logged.
 *                      See examples in the overview section above.
 * @param {...any} optionalParams Objects with which to replace substitution strings within messages or simply additional objects to be logged.
 * @return {void}
 * @export
 * @memberof oj.Logger
 * @method error
 * @since 1.0.0
 * @ojsignature {target: "Type", for: "optionalParams", value: "any[]"}
 */
// eslint-disable-next-line no-unused-vars

Logger.error = function (message, optionalParams) {
  Logger._write(Logger.LEVEL_ERROR, Logger._METHOD_ERROR, arguments);
};
/**
 * Writes an informational  message.
 * @param {any=} message A function that returns the message to be logged, a string containing zero or more substitution strings, or an object to be logged.
 *                      See examples in the overview section above.
 * @param {...any} optionalParams Objects with which to replace substitution strings within messages or simply additional objects to be logged.
 * @return {void}
 * @export
 * @memberof oj.Logger
 * @method info
 * @since 1.0.0
 * @ojsignature {target: "Type", for: "optionalParams", value: "any[]"}
 */
// eslint-disable-next-line no-unused-vars


Logger.info = function (message, optionalParams) {
  Logger._write(Logger.LEVEL_INFO, Logger._METHOD_INFO, arguments);
};
/**
 * Writes a warning message.
 * @param {any=} message A function that returns the message to be logged, a string containing zero or more substitution strings, or an object to be logged.
 *                      See examples in the overview section above.
 * @param {...any} optionalParams Objects with which to replace substitution strings within messages or simply additional objects to be logged.
 * @export
 * @return {void}
 * @memberof oj.Logger
 * @method warn
 * @since 1.0.0
 * @ojsignature {target: "Type", for: "optionalParams", value: "any[]"}
 */
// eslint-disable-next-line no-unused-vars


Logger.warn = function (message, optionalParams) {
  Logger._write(Logger.LEVEL_WARN, Logger._METHOD_WARN, arguments);
};
/**
 * Writes a general message.
 * @param {any=} message A function that returns the message to be logged, a string containing zero or more substitution strings, or an object to be logged.
 *                      See examples in the overview section above.
 * @param {...any} optionalParams Objects with which to replace substitution strings within messages or simply additional objects to be logged.
 * @return {void}
 * @export
 * @memberof oj.Logger
 * @method log
 * @since 1.0.0
 * @ojsignature {target: "Type", for: "optionalParams", value: "any[]"}
 */
// eslint-disable-next-line no-unused-vars


Logger.log = function (message, optionalParams) {
  Logger._write(Logger.LEVEL_LOG, Logger._METHOD_LOG, arguments);
};
/**
 * Method for setting and getting logger option/options
 * <p>Sets/gets logger configuration - level and/or writer. Accepts variable number of arguments.
 * <p><h5>Defaults:</h5>
 * Default level: oj.Logger.LEVEL_ERROR<br/>
 * Default writer: null; writes to the console
 * <p><h5>Usages:</h5>
 * <i>oj.Logger.option(optionName)</i> gets the value associated the the specified optionName<br/>
 * <i>oj.Logger.option()</i> gets an object containing key/value pairs representing the logger options hash<br/>
 * <i>oj.Logger.option(optionName, value)</i> sets  the option value associated with optionName<br/>
 * <i>oj.Logger.option(options)</i> sets  one or more options for the logger
 *
 * @example <caption>Overriding default options</caption>
 * oj.Logger.option("level",  oj.Logger.LEVEL_INFO);
 * oj.Logger.option("writer",  customWriter);  //an object that implements the following methods: log(), info(), warn(), error()
 *
 * @param {Object|string} [key]
 * @param {any} [value]
 * @return {any}
 * @export
 * @memberof oj.Logger
 * @method option
 * @since 1.0.0
 * @ojsignature {target: "Type", for: "key", value: "'level'|'writer'|{level?: any, writer?: any}"}
 */


Logger.option = function (key, value) {
  // getters
  var ret = {};
  var i;
  var keys;

  if (arguments.length === 0) {
    keys = Object.keys(Logger._options);

    for (i = 0; i < keys.length; i++) {
      ret[keys[i]] = Logger._options[keys[i]];
    }

    return ret;
  }

  if (typeof key === 'string' && value === undefined) {
    return Logger._options[key] === undefined ? null : Logger._options[key];
  } // setters


  if (typeof key === 'string') {
    Logger._options[key] = value;
  } else {
    // case when all options are set in one call
    var options = key;
    keys = Object.keys(options);

    for (i = 0; i < keys.length; i++) {
      Logger.option(keys[i], options[keys[i]]);
    }
  }

  return undefined;
};
/* private members*/

/*
 * Helper method - calls a specified method on the available writer (console or custom)
 * if the logging level is sufficient
 */


Logger._write = function (level, method, args) {
  if (Logger.option('level') < level) {
    return;
  }

  var writer = Logger._getWriter();

  if (writer != null) {
    if (args.length === 1 && args[0] instanceof Function) {
      var msg = args[0](); // eslint-disable-next-line no-param-reassign

      args = [msg];
    }

    if (writer[method] && writer[method].apply) {
      writer[method].apply(writer, args);
    } else if (writer[method]) {
      writer[method] = Function.prototype.bind.call(writer[method], writer);

      Logger._write(level, method, args);
    }
  }
};
/*
 * Helper method - returns available writer (console or custom)
 */


Logger._getWriter = function () {
  var writer = null;

  if (Logger.option('writer')) {
    writer = Logger.option('writer');
  } else if (typeof window !== 'undefined' && window.console !== undefined) {
    writer = window.console;
  }

  return writer;
};

;return Logger;
});
define('corejs',['module'], function(module) {
/**
 * core-js 2.6.5
 * https://github.com/zloirock/core-js
 * License: http://rock.mit-license.org
 * Â© 2019 Denis Pushkarev
 */
!function(__e, __g, undefined){
'use strict';
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 129);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var core = __webpack_require__(26);
var hide = __webpack_require__(11);
var redefine = __webpack_require__(12);
var ctx = __webpack_require__(18);
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(4);
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),
/* 2 */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(47)('wks');
var uid = __webpack_require__(33);
var Symbol = __webpack_require__(2).Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(20);
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(3)(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(1);
var IE8_DOM_DEFINE = __webpack_require__(93);
var toPrimitive = __webpack_require__(22);
var dP = Object.defineProperty;

exports.f = __webpack_require__(7) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(23);
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),
/* 10 */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(8);
var createDesc = __webpack_require__(32);
module.exports = __webpack_require__(7) ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var hide = __webpack_require__(11);
var has = __webpack_require__(14);
var SRC = __webpack_require__(33)('src');
var $toString = __webpack_require__(131);
var TO_STRING = 'toString';
var TPL = ('' + $toString).split(TO_STRING);

__webpack_require__(26).inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var fails = __webpack_require__(3);
var defined = __webpack_require__(23);
var quot = /"/g;
// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
var createHTML = function (string, tag, attribute, value) {
  var S = String(defined(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};
module.exports = function (NAME, exec) {
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function () {
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};


/***/ }),
/* 14 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(48);
var defined = __webpack_require__(23);
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__(49);
var createDesc = __webpack_require__(32);
var toIObject = __webpack_require__(15);
var toPrimitive = __webpack_require__(22);
var has = __webpack_require__(14);
var IE8_DOM_DEFINE = __webpack_require__(93);
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(7) ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(14);
var toObject = __webpack_require__(9);
var IE_PROTO = __webpack_require__(68)('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(10);
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),
/* 19 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),
/* 20 */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {



var fails = __webpack_require__(3);

module.exports = function (method, arg) {
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call
    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);
  });
};


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(4);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),
/* 23 */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(0);
var core = __webpack_require__(26);
var fails = __webpack_require__(3);
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = __webpack_require__(18);
var IObject = __webpack_require__(48);
var toObject = __webpack_require__(9);
var toLength = __webpack_require__(6);
var asc = __webpack_require__(84);
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};


/***/ }),
/* 26 */
/***/ (function(module, exports) {

var core = module.exports = { version: '2.6.5' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {



if (__webpack_require__(7)) {
  var LIBRARY = __webpack_require__(29);
  var global = __webpack_require__(2);
  var fails = __webpack_require__(3);
  var $export = __webpack_require__(0);
  var $typed = __webpack_require__(62);
  var $buffer = __webpack_require__(92);
  var ctx = __webpack_require__(18);
  var anInstance = __webpack_require__(39);
  var propertyDesc = __webpack_require__(32);
  var hide = __webpack_require__(11);
  var redefineAll = __webpack_require__(41);
  var toInteger = __webpack_require__(20);
  var toLength = __webpack_require__(6);
  var toIndex = __webpack_require__(122);
  var toAbsoluteIndex = __webpack_require__(35);
  var toPrimitive = __webpack_require__(22);
  var has = __webpack_require__(14);
  var classof = __webpack_require__(44);
  var isObject = __webpack_require__(4);
  var toObject = __webpack_require__(9);
  var isArrayIter = __webpack_require__(81);
  var create = __webpack_require__(36);
  var getPrototypeOf = __webpack_require__(17);
  var gOPN = __webpack_require__(37).f;
  var getIterFn = __webpack_require__(83);
  var uid = __webpack_require__(33);
  var wks = __webpack_require__(5);
  var createArrayMethod = __webpack_require__(25);
  var createArrayIncludes = __webpack_require__(52);
  var speciesConstructor = __webpack_require__(51);
  var ArrayIterators = __webpack_require__(86);
  var Iterators = __webpack_require__(46);
  var $iterDetect = __webpack_require__(57);
  var setSpecies = __webpack_require__(38);
  var arrayFill = __webpack_require__(85);
  var arrayCopyWithin = __webpack_require__(110);
  var $DP = __webpack_require__(8);
  var $GOPD = __webpack_require__(16);
  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';

  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function (it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function (it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function (C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    } return new C(length);
  };

  var speciesFromList = function (O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);
    while (length > index) result[index] = list[index++];
    return result;
  };

  var addGetter = function (it, key, internal) {
    dP(it, key, { get: function () { return this._d[internal]; } });
  };

  var $from = function from(source /* , mapfn, thisArg */) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;
    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      } O = values;
    }
    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var $of = function of(/* ...items */) {
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);
    while (length > index) result[index] = arguments[index++];
    return result;
  };

  // iOS Safari 6.x fails here
  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start /* , end */) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn /* , thisArg */) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn /* , thisArg */) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
        arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate /* , thisArg */) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate /* , thisArg */) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn /* , thisArg */) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement /* , fromIndex */) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement /* , fromIndex */) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) { // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn /* , thisArg */) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;
      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      } return that;
    },
    some: function some(callbackfn /* , thisArg */) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
        O.buffer,
        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)
      );
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /* , offset */) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);
    while (index < len) this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function (target, key) {
    return isObject(target)
      && target[TYPED_ARRAY]
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true))
      ? propertyDesc(2, target[key])
      : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true))
      && isObject(desc)
      && has(desc, 'value')
      && !has(desc, 'get')
      && !has(desc, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !desc.configurable
      && (!has(desc, 'writable') || desc.writable)
      && (!has(desc, 'enumerable') || desc.enumerable)
    ) {
      target[key] = desc.value;
      return target;
    } return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () { arrayToString.call({}); })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function () { /* noop */ },
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function () { return this[TYPED_ARRAY]; }
  });

  // eslint-disable-next-line max-statements
  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
    var getter = function (that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };
    var setter = function (that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };
    var addElement = function (that, index) {
      dP(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }
        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new
      new TypedArray(null); // eslint-disable-line no-new
      new TypedArray(1.5); // eslint-disable-line no-new
      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass;
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
        if (!isObject(data)) return new Base(toIndex(data));
        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined
            ? new Base(data, toOffset($offset, BYTES), $length)
            : $offset !== undefined
              ? new Base(data, toOffset($offset, BYTES))
              : new Base(data);
        }
        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }
    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator
      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function () { return NAME; }
      });
    }

    O[NAME] = TypedArray;

    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });

    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {
      from: $from,
      of: $of
    });

    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

    $export($export.P, NAME, proto);

    setSpecies(NAME);

    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, { slice: $slice });

    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, { toLocaleString: $toLocaleString });

    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () { /* empty */ };


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

var Map = __webpack_require__(116);
var $export = __webpack_require__(0);
var shared = __webpack_require__(47)('metadata');
var store = shared.store || (shared.store = new (__webpack_require__(119))());

var getOrCreateMetadataMap = function (target, targetKey, create) {
  var targetMetadata = store.get(target);
  if (!targetMetadata) {
    if (!create) return undefined;
    store.set(target, targetMetadata = new Map());
  }
  var keyMetadata = targetMetadata.get(targetKey);
  if (!keyMetadata) {
    if (!create) return undefined;
    targetMetadata.set(targetKey, keyMetadata = new Map());
  } return keyMetadata;
};
var ordinaryHasOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
};
var ordinaryGetOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
};
var ordinaryDefineOwnMetadata = function (MetadataKey, MetadataValue, O, P) {
  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
};
var ordinaryOwnMetadataKeys = function (target, targetKey) {
  var metadataMap = getOrCreateMetadataMap(target, targetKey, false);
  var keys = [];
  if (metadataMap) metadataMap.forEach(function (_, key) { keys.push(key); });
  return keys;
};
var toMetaKey = function (it) {
  return it === undefined || typeof it == 'symbol' ? it : String(it);
};
var exp = function (O) {
  $export($export.S, 'Reflect', O);
};

module.exports = {
  store: store,
  map: getOrCreateMetadataMap,
  has: ordinaryHasOwnMetadata,
  get: ordinaryGetOwnMetadata,
  set: ordinaryDefineOwnMetadata,
  keys: ordinaryOwnMetadataKeys,
  key: toMetaKey,
  exp: exp
};


/***/ }),
/* 29 */
/***/ (function(module, exports) {

module.exports = false;


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__(33)('meta');
var isObject = __webpack_require__(4);
var has = __webpack_require__(14);
var setDesc = __webpack_require__(8).f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__(3)(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = __webpack_require__(5)('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__(11)(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};


/***/ }),
/* 32 */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),
/* 33 */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(95);
var enumBugKeys = __webpack_require__(69);

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(20);
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(1);
var dPs = __webpack_require__(96);
var enumBugKeys = __webpack_require__(69);
var IE_PROTO = __webpack_require__(68)('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(66)('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(70).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__(95);
var hiddenKeys = __webpack_require__(69).concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {



var global = __webpack_require__(2);
var dP = __webpack_require__(8);
var DESCRIPTORS = __webpack_require__(7);
var SPECIES = __webpack_require__(5)('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};


/***/ }),
/* 39 */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(18);
var call = __webpack_require__(108);
var isArrayIter = __webpack_require__(81);
var anObject = __webpack_require__(1);
var toLength = __webpack_require__(6);
var getIterFn = __webpack_require__(83);
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

var redefine = __webpack_require__(12);
module.exports = function (target, src, safe) {
  for (var key in src) redefine(target, key, src[key], safe);
  return target;
};


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(4);
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(8).f;
var has = __webpack_require__(14);
var TAG = __webpack_require__(5)('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(19);
var TAG = __webpack_require__(5)('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var defined = __webpack_require__(23);
var fails = __webpack_require__(3);
var spaces = __webpack_require__(73);
var space = '[' + spaces + ']';
var non = '\u200b\u0085';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function (KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;


/***/ }),
/* 46 */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(26);
var global = __webpack_require__(2);
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__(29) ? 'pure' : 'global',
  copyright: 'Â© 2019 Denis Pushkarev (zloirock.ru)'
});


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(19);
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),
/* 49 */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {



// 21.2.5.3 get RegExp.prototype.flags
var anObject = __webpack_require__(1);
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__(1);
var aFunction = __webpack_require__(10);
var SPECIES = __webpack_require__(5)('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(15);
var toLength = __webpack_require__(6);
var toAbsoluteIndex = __webpack_require__(35);
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),
/* 53 */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(19);
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(20);
var defined = __webpack_require__(23);
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.8 IsRegExp(argument)
var isObject = __webpack_require__(4);
var cof = __webpack_require__(19);
var MATCH = __webpack_require__(5)('match');
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__(5)('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {




var classof = __webpack_require__(44);
var builtinExec = RegExp.prototype.exec;

 // `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec
module.exports = function (R, S) {
  var exec = R.exec;
  if (typeof exec === 'function') {
    var result = exec.call(R, S);
    if (typeof result !== 'object') {
      throw new TypeError('RegExp exec method returned something other than an Object or null');
    }
    return result;
  }
  if (classof(R) !== 'RegExp') {
    throw new TypeError('RegExp#exec called on incompatible receiver');
  }
  return builtinExec.call(R, S);
};


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {



__webpack_require__(112);
var redefine = __webpack_require__(12);
var hide = __webpack_require__(11);
var fails = __webpack_require__(3);
var defined = __webpack_require__(23);
var wks = __webpack_require__(5);
var regexpExec = __webpack_require__(87);

var SPECIES = wks('species');

var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  return ''.replace(re, '$<a>') !== '7';
});

var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = (function () {
  // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function () { return originalExec.apply(this, arguments); };
  var result = 'ab'.split(re);
  return result.length === 2 && result[0] === 'a' && result[1] === 'b';
})();

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);

  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;
    re.exec = function () { execCalled = true; return null; };
    if (KEY === 'split') {
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES] = function () { return re; };
    }
    re[SYMBOL]('');
    return !execCalled;
  }) : undefined;

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) ||
    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
  ) {
    var nativeRegExpMethod = /./[SYMBOL];
    var fns = exec(
      defined,
      SYMBOL,
      ''[KEY],
      function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
        if (regexp.exec === regexpExec) {
          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
            // The native String method already delegates to @@method (this
            // polyfilled function), leasing to infinite recursion.
            // We avoid it by directly calling the native @@method method.
            return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
          }
          return { done: true, value: nativeMethod.call(str, regexp, arg2) };
        }
        return { done: false };
      }
    );
    var strfn = fns[0];
    var rxfn = fns[1];

    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return rxfn.call(string, this); }
    );
  }
};


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var navigator = global.navigator;

module.exports = navigator && navigator.userAgent || '';


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {



var global = __webpack_require__(2);
var $export = __webpack_require__(0);
var redefine = __webpack_require__(12);
var redefineAll = __webpack_require__(41);
var meta = __webpack_require__(30);
var forOf = __webpack_require__(40);
var anInstance = __webpack_require__(39);
var isObject = __webpack_require__(4);
var fails = __webpack_require__(3);
var $iterDetect = __webpack_require__(57);
var setToStringTag = __webpack_require__(43);
var inheritIfRequired = __webpack_require__(72);

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  var fixMethod = function (KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY,
      KEY == 'delete' ? function (a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a) {
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }
        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  };
  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
    // weak collections should not contains .clear method
    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var hide = __webpack_require__(11);
var uid = __webpack_require__(33);
var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;

var TypedArrayConstructors = (
  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
).split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {



// Forced replacement prototype accessors methods
module.exports = __webpack_require__(29) || !__webpack_require__(3)(function () {
  var K = Math.random();
  // In FF throws only define methods
  // eslint-disable-next-line no-undef, no-useless-call
  __defineSetter__.call(null, K, function () { /* empty */ });
  delete __webpack_require__(2)[K];
});


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {



// https://tc39.github.io/proposal-setmap-offrom/
var $export = __webpack_require__(0);

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { of: function of() {
    var length = arguments.length;
    var A = new Array(length);
    while (length--) A[length] = arguments[length];
    return new this(A);
  } });
};


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {



// https://tc39.github.io/proposal-setmap-offrom/
var $export = __webpack_require__(0);
var aFunction = __webpack_require__(10);
var ctx = __webpack_require__(18);
var forOf = __webpack_require__(40);

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
    var mapFn = arguments[1];
    var mapping, A, n, cb;
    aFunction(this);
    mapping = mapFn !== undefined;
    if (mapping) aFunction(mapFn);
    if (source == undefined) return new this();
    A = [];
    if (mapping) {
      n = 0;
      cb = ctx(mapFn, arguments[2], 2);
      forOf(source, false, function (nextItem) {
        A.push(cb(nextItem, n++));
      });
    } else {
      forOf(source, false, A.push, A);
    }
    return new this(A);
  } });
};


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(4);
var document = __webpack_require__(2).document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var core = __webpack_require__(26);
var LIBRARY = __webpack_require__(29);
var wksExt = __webpack_require__(94);
var defineProperty = __webpack_require__(8).f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(47)('keys');
var uid = __webpack_require__(33);
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),
/* 69 */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(2).document;
module.exports = document && document.documentElement;


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __webpack_require__(4);
var anObject = __webpack_require__(1);
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = __webpack_require__(18)(Function.call, __webpack_require__(16).f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(4);
var setPrototypeOf = __webpack_require__(71).set;
module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  } return that;
};


/***/ }),
/* 73 */
/***/ (function(module, exports) {

module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {



var toInteger = __webpack_require__(20);
var defined = __webpack_require__(23);

module.exports = function repeat(count) {
  var str = String(defined(this));
  var res = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;
  return res;
};


/***/ }),
/* 75 */
/***/ (function(module, exports) {

// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};


/***/ }),
/* 76 */
/***/ (function(module, exports) {

// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = (!$expm1
  // Old FF bug
  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
  // Tor Browser bug
  || $expm1(-2e-17) != -2e-17
) ? function expm1(x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

// helper for String#{startsWith, endsWith, includes}
var isRegExp = __webpack_require__(56);
var defined = __webpack_require__(23);

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

var MATCH = __webpack_require__(5)('match');
module.exports = function (KEY) {
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) { /* empty */ }
  } return true;
};


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {



var LIBRARY = __webpack_require__(29);
var $export = __webpack_require__(0);
var redefine = __webpack_require__(12);
var hide = __webpack_require__(11);
var Iterators = __webpack_require__(46);
var $iterCreate = __webpack_require__(80);
var setToStringTag = __webpack_require__(43);
var getPrototypeOf = __webpack_require__(17);
var ITERATOR = __webpack_require__(5)('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {



var create = __webpack_require__(36);
var descriptor = __webpack_require__(32);
var setToStringTag = __webpack_require__(43);
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(11)(IteratorPrototype, __webpack_require__(5)('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(46);
var ITERATOR = __webpack_require__(5)('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {



var $defineProperty = __webpack_require__(8);
var createDesc = __webpack_require__(32);

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(44);
var ITERATOR = __webpack_require__(5)('iterator');
var Iterators = __webpack_require__(46);
module.exports = __webpack_require__(26).getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__(213);

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {


// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)

var toObject = __webpack_require__(9);
var toAbsoluteIndex = __webpack_require__(35);
var toLength = __webpack_require__(6);
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {



var addToUnscopables = __webpack_require__(31);
var step = __webpack_require__(111);
var Iterators = __webpack_require__(46);
var toIObject = __webpack_require__(15);

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(79)(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {




var regexpFlags = __webpack_require__(50);

var nativeExec = RegExp.prototype.exec;
// This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.
var nativeReplace = String.prototype.replace;

var patchedExec = nativeExec;

var LAST_INDEX = 'lastIndex';

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/,
      re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
})();

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re));
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];

    match = nativeExec.call(re, str);

    if (UPDATES_LAST_INDEX_WRONG && match) {
      re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      // eslint-disable-next-line no-loop-func
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

module.exports = patchedExec;


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {



var at = __webpack_require__(55)(true);

 // `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex
module.exports = function (S, index, unicode) {
  return index + (unicode ? at(S, index).length : 1);
};


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(18);
var invoke = __webpack_require__(101);
var html = __webpack_require__(70);
var cel = __webpack_require__(66);
var global = __webpack_require__(2);
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (__webpack_require__(19)(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var macrotask = __webpack_require__(89).set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__(19)(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {



// 25.4.1.5 NewPromiseCapability(C)
var aFunction = __webpack_require__(10);

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {



var global = __webpack_require__(2);
var DESCRIPTORS = __webpack_require__(7);
var LIBRARY = __webpack_require__(29);
var $typed = __webpack_require__(62);
var hide = __webpack_require__(11);
var redefineAll = __webpack_require__(41);
var fails = __webpack_require__(3);
var anInstance = __webpack_require__(39);
var toInteger = __webpack_require__(20);
var toLength = __webpack_require__(6);
var toIndex = __webpack_require__(122);
var gOPN = __webpack_require__(37).f;
var dP = __webpack_require__(8).f;
var arrayFill = __webpack_require__(85);
var setToStringTag = __webpack_require__(43);
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError;
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
function packIEEE754(value, mLen, nBytes) {
  var buffer = new Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value);
  // eslint-disable-next-line no-self-compare
  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);
    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
  buffer[--i] |= s * 128;
  return buffer;
}
function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;
  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  } return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}
function packI8(it) {
  return [it & 0xff];
}
function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}
function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}
function packF64(it) {
  return packIEEE754(it, 52, 8);
}
function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}
function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);
  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    this._b = arrayFill.call(new Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    $ArrayBuffer(1);
  }) || !fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new
    new $ArrayBuffer(1.5); // eslint-disable-line no-new
    new $ArrayBuffer(NaN); // eslint-disable-line no-new
    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new BaseBuffer(toIndex(length));
    };
    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
    }
    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(7) && !__webpack_require__(3)(function () {
  return Object.defineProperty(__webpack_require__(66)('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(5);


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(14);
var toIObject = __webpack_require__(15);
var arrayIndexOf = __webpack_require__(52)(false);
var IE_PROTO = __webpack_require__(68)('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(8);
var anObject = __webpack_require__(1);
var getKeys = __webpack_require__(34);

module.exports = __webpack_require__(7) ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(15);
var gOPN = __webpack_require__(37).f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {



// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = __webpack_require__(34);
var gOPS = __webpack_require__(53);
var pIE = __webpack_require__(49);
var toObject = __webpack_require__(9);
var IObject = __webpack_require__(48);
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__(3)(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;


/***/ }),
/* 99 */
/***/ (function(module, exports) {

// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {



var aFunction = __webpack_require__(10);
var isObject = __webpack_require__(4);
var invoke = __webpack_require__(101);
var arraySlice = [].slice;
var factories = {};

var construct = function (F, len, args) {
  if (!(len in factories)) {
    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';
    // eslint-disable-next-line no-new-func
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  } return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction(this);
  var partArgs = arraySlice.call(arguments, 1);
  var bound = function (/* args... */) {
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
  return bound;
};


/***/ }),
/* 101 */
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

var cof = __webpack_require__(19);
module.exports = function (it, msg) {
  if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);
  return +it;
};


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var isObject = __webpack_require__(4);
var floor = Math.floor;
module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

var $parseFloat = __webpack_require__(2).parseFloat;
var $trim = __webpack_require__(45).trim;

module.exports = 1 / $parseFloat(__webpack_require__(73) + '-0') !== -Infinity ? function parseFloat(str) {
  var string = $trim(String(str), 3);
  var result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

var $parseInt = __webpack_require__(2).parseInt;
var $trim = __webpack_require__(45).trim;
var ws = __webpack_require__(73);
var hex = /^[-+]?0[xX]/;

module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
  var string = $trim(String(str), 3);
  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
} : $parseInt;


/***/ }),
/* 106 */
/***/ (function(module, exports) {

// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x) {
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.16 Math.fround(x)
var sign = __webpack_require__(75);
var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);

var roundTiesToEven = function (n) {
  return n + 1 / EPSILON - 1 / EPSILON;
};

module.exports = Math.fround || function fround(x) {
  var $abs = Math.abs(x);
  var $sign = sign(x);
  var a, result;
  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
  a = (1 + EPSILON32 / EPSILON) * $abs;
  result = a - (a - $abs);
  // eslint-disable-next-line no-self-compare
  if (result > MAX32 || result != result) return $sign * Infinity;
  return $sign * result;
};


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(1);
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__(10);
var toObject = __webpack_require__(9);
var IObject = __webpack_require__(48);
var toLength = __webpack_require__(6);

module.exports = function (that, callbackfn, aLen, memo, isRight) {
  aFunction(callbackfn);
  var O = toObject(that);
  var self = IObject(O);
  var length = toLength(O.length);
  var index = isRight ? length - 1 : 0;
  var i = isRight ? -1 : 1;
  if (aLen < 2) for (;;) {
    if (index in self) {
      memo = self[index];
      index += i;
      break;
    }
    index += i;
    if (isRight ? index < 0 : length <= index) {
      throw TypeError('Reduce of empty array with no initial value');
    }
  }
  for (;isRight ? index >= 0 : length > index; index += i) if (index in self) {
    memo = callbackfn(memo, self[index], index, O);
  }
  return memo;
};


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {


// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)

var toObject = __webpack_require__(9);
var toAbsoluteIndex = __webpack_require__(35);
var toLength = __webpack_require__(6);

module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else delete O[to];
    to += inc;
    from += inc;
  } return O;
};


/***/ }),
/* 111 */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {



var regexpExec = __webpack_require__(87);
__webpack_require__(0)({
  target: 'RegExp',
  proto: true,
  forced: regexpExec !== /./.exec
}, {
  exec: regexpExec
});


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

// 21.2.5.3 get RegExp.prototype.flags()
if (__webpack_require__(7) && /./g.flags != 'g') __webpack_require__(8).f(RegExp.prototype, 'flags', {
  configurable: true,
  get: __webpack_require__(50)
});


/***/ }),
/* 114 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(1);
var isObject = __webpack_require__(4);
var newPromiseCapability = __webpack_require__(91);

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {



var strong = __webpack_require__(117);
var validate = __webpack_require__(42);
var MAP = 'Map';

// 23.1 Map Objects
module.exports = __webpack_require__(61)(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {



var dP = __webpack_require__(8).f;
var create = __webpack_require__(36);
var redefineAll = __webpack_require__(41);
var ctx = __webpack_require__(18);
var anInstance = __webpack_require__(39);
var forOf = __webpack_require__(40);
var $iterDefine = __webpack_require__(79);
var step = __webpack_require__(111);
var setSpecies = __webpack_require__(38);
var DESCRIPTORS = __webpack_require__(7);
var fastKey = __webpack_require__(30).fastKey;
var validate = __webpack_require__(42);
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {



var strong = __webpack_require__(117);
var validate = __webpack_require__(42);
var SET = 'Set';

// 23.2 Set Objects
module.exports = __webpack_require__(61)(SET, function (get) {
  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {



var global = __webpack_require__(2);
var each = __webpack_require__(25)(0);
var redefine = __webpack_require__(12);
var meta = __webpack_require__(30);
var assign = __webpack_require__(98);
var weak = __webpack_require__(120);
var isObject = __webpack_require__(4);
var validate = __webpack_require__(42);
var NATIVE_WEAK_MAP = __webpack_require__(42);
var IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global;
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = __webpack_require__(61)(WEAK_MAP, wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if (NATIVE_WEAK_MAP && IS_IE11) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {



var redefineAll = __webpack_require__(41);
var getWeak = __webpack_require__(30).getWeak;
var anObject = __webpack_require__(1);
var isObject = __webpack_require__(4);
var anInstance = __webpack_require__(39);
var forOf = __webpack_require__(40);
var createArrayMethod = __webpack_require__(25);
var $has = __webpack_require__(14);
var validate = __webpack_require__(42);
var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function () {
  this.a = [];
};
var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;      // collection type
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

// all object keys, includes non-enumerable and symbols
var gOPN = __webpack_require__(37);
var gOPS = __webpack_require__(53);
var anObject = __webpack_require__(1);
var Reflect = __webpack_require__(2).Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = __webpack_require__(20);
var toLength = __webpack_require__(6);
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {



// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
var isArray = __webpack_require__(54);
var isObject = __webpack_require__(4);
var toLength = __webpack_require__(6);
var ctx = __webpack_require__(18);
var IS_CONCAT_SPREADABLE = __webpack_require__(5)('isConcatSpreadable');

function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;
  var element, spreadable;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

      spreadable = false;
      if (isObject(element)) {
        spreadable = element[IS_CONCAT_SPREADABLE];
        spreadable = spreadable !== undefined ? !!spreadable : isArray(element);
      }

      if (spreadable && depth > 0) {
        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1fffffffffffff) throw TypeError();
        target[targetIndex] = element;
      }

      targetIndex++;
    }
    sourceIndex++;
  }
  return targetIndex;
}

module.exports = flattenIntoArray;


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-string-pad-start-end
var toLength = __webpack_require__(6);
var repeat = __webpack_require__(74);
var defined = __webpack_require__(23);

module.exports = function (that, maxLength, fillString, left) {
  var S = String(defined(that));
  var stringLength = S.length;
  var fillStr = fillString === undefined ? ' ' : String(fillString);
  var intMaxLength = toLength(maxLength);
  if (intMaxLength <= stringLength || fillStr == '') return S;
  var fillLen = intMaxLength - stringLength;
  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

var getKeys = __webpack_require__(34);
var toIObject = __webpack_require__(15);
var isEnum = __webpack_require__(49).f;
module.exports = function (isEntries) {
  return function (it) {
    var O = toIObject(it);
    var keys = getKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) if (isEnum.call(O, key = keys[i++])) {
      result.push(isEntries ? [key, O[key]] : O[key]);
    } return result;
  };
};


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = __webpack_require__(44);
var from = __webpack_require__(127);
module.exports = function (NAME) {
  return function toJSON() {
    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

var forOf = __webpack_require__(40);

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};


/***/ }),
/* 128 */
/***/ (function(module, exports) {

// https://rwaldron.github.io/proposal-math-extensions/
module.exports = Math.scale || function scale(x, inLow, inHigh, outLow, outHigh) {
  if (
    arguments.length === 0
      // eslint-disable-next-line no-self-compare
      || x != x
      // eslint-disable-next-line no-self-compare
      || inLow != inLow
      // eslint-disable-next-line no-self-compare
      || inHigh != inHigh
      // eslint-disable-next-line no-self-compare
      || outLow != outLow
      // eslint-disable-next-line no-self-compare
      || outHigh != outHigh
  ) return NaN;
  if (x === Infinity || x === -Infinity) return x;
  return (x - inLow) * (outHigh - outLow) / (inHigh - inLow) + outLow;
};


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(130);
__webpack_require__(133);
__webpack_require__(134);
__webpack_require__(135);
__webpack_require__(136);
__webpack_require__(137);
__webpack_require__(138);
__webpack_require__(139);
__webpack_require__(140);
__webpack_require__(141);
__webpack_require__(142);
__webpack_require__(143);
__webpack_require__(144);
__webpack_require__(145);
__webpack_require__(146);
__webpack_require__(147);
__webpack_require__(148);
__webpack_require__(149);
__webpack_require__(150);
__webpack_require__(151);
__webpack_require__(152);
__webpack_require__(153);
__webpack_require__(154);
__webpack_require__(155);
__webpack_require__(156);
__webpack_require__(157);
__webpack_require__(158);
__webpack_require__(159);
__webpack_require__(160);
__webpack_require__(161);
__webpack_require__(162);
__webpack_require__(163);
__webpack_require__(164);
__webpack_require__(165);
__webpack_require__(166);
__webpack_require__(167);
__webpack_require__(168);
__webpack_require__(169);
__webpack_require__(170);
__webpack_require__(171);
__webpack_require__(172);
__webpack_require__(173);
__webpack_require__(174);
__webpack_require__(175);
__webpack_require__(176);
__webpack_require__(177);
__webpack_require__(178);
__webpack_require__(179);
__webpack_require__(180);
__webpack_require__(181);
__webpack_require__(182);
__webpack_require__(183);
__webpack_require__(184);
__webpack_require__(185);
__webpack_require__(186);
__webpack_require__(187);
__webpack_require__(188);
__webpack_require__(189);
__webpack_require__(190);
__webpack_require__(191);
__webpack_require__(192);
__webpack_require__(193);
__webpack_require__(194);
__webpack_require__(195);
__webpack_require__(196);
__webpack_require__(197);
__webpack_require__(198);
__webpack_require__(199);
__webpack_require__(200);
__webpack_require__(201);
__webpack_require__(202);
__webpack_require__(203);
__webpack_require__(204);
__webpack_require__(205);
__webpack_require__(206);
__webpack_require__(207);
__webpack_require__(208);
__webpack_require__(209);
__webpack_require__(210);
__webpack_require__(211);
__webpack_require__(212);
__webpack_require__(214);
__webpack_require__(215);
__webpack_require__(216);
__webpack_require__(217);
__webpack_require__(218);
__webpack_require__(219);
__webpack_require__(220);
__webpack_require__(221);
__webpack_require__(222);
__webpack_require__(223);
__webpack_require__(224);
__webpack_require__(225);
__webpack_require__(86);
__webpack_require__(226);
__webpack_require__(227);
__webpack_require__(112);
__webpack_require__(228);
__webpack_require__(113);
__webpack_require__(229);
__webpack_require__(230);
__webpack_require__(231);
__webpack_require__(232);
__webpack_require__(233);
__webpack_require__(116);
__webpack_require__(118);
__webpack_require__(119);
__webpack_require__(234);
__webpack_require__(235);
__webpack_require__(236);
__webpack_require__(237);
__webpack_require__(238);
__webpack_require__(239);
__webpack_require__(240);
__webpack_require__(241);
__webpack_require__(242);
__webpack_require__(243);
__webpack_require__(244);
__webpack_require__(245);
__webpack_require__(246);
__webpack_require__(247);
__webpack_require__(248);
__webpack_require__(249);
__webpack_require__(250);
__webpack_require__(251);
__webpack_require__(253);
__webpack_require__(254);
__webpack_require__(256);
__webpack_require__(257);
__webpack_require__(258);
__webpack_require__(259);
__webpack_require__(260);
__webpack_require__(261);
__webpack_require__(262);
__webpack_require__(263);
__webpack_require__(264);
__webpack_require__(265);
__webpack_require__(266);
__webpack_require__(267);
__webpack_require__(268);
__webpack_require__(269);
__webpack_require__(270);
__webpack_require__(271);
__webpack_require__(272);
__webpack_require__(273);
__webpack_require__(274);
__webpack_require__(275);
__webpack_require__(276);
__webpack_require__(277);
__webpack_require__(278);
__webpack_require__(279);
__webpack_require__(280);
__webpack_require__(281);
__webpack_require__(282);
__webpack_require__(283);
__webpack_require__(284);
__webpack_require__(285);
__webpack_require__(286);
__webpack_require__(287);
__webpack_require__(288);
__webpack_require__(289);
__webpack_require__(290);
__webpack_require__(291);
__webpack_require__(292);
__webpack_require__(293);
__webpack_require__(294);
__webpack_require__(295);
__webpack_require__(296);
__webpack_require__(297);
__webpack_require__(298);
__webpack_require__(299);
__webpack_require__(300);
__webpack_require__(301);
__webpack_require__(302);
__webpack_require__(303);
__webpack_require__(304);
__webpack_require__(305);
__webpack_require__(306);
__webpack_require__(307);
__webpack_require__(308);
__webpack_require__(309);
__webpack_require__(310);
__webpack_require__(311);
__webpack_require__(312);
__webpack_require__(313);
__webpack_require__(314);
__webpack_require__(315);
__webpack_require__(316);
__webpack_require__(317);
__webpack_require__(318);
__webpack_require__(319);
__webpack_require__(320);
__webpack_require__(321);
__webpack_require__(322);
__webpack_require__(323);
__webpack_require__(324);
module.exports = __webpack_require__(325);


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {



// ECMAScript 6 symbols shim
var global = __webpack_require__(2);
var has = __webpack_require__(14);
var DESCRIPTORS = __webpack_require__(7);
var $export = __webpack_require__(0);
var redefine = __webpack_require__(12);
var META = __webpack_require__(30).KEY;
var $fails = __webpack_require__(3);
var shared = __webpack_require__(47);
var setToStringTag = __webpack_require__(43);
var uid = __webpack_require__(33);
var wks = __webpack_require__(5);
var wksExt = __webpack_require__(94);
var wksDefine = __webpack_require__(67);
var enumKeys = __webpack_require__(132);
var isArray = __webpack_require__(54);
var anObject = __webpack_require__(1);
var isObject = __webpack_require__(4);
var toIObject = __webpack_require__(15);
var toPrimitive = __webpack_require__(22);
var createDesc = __webpack_require__(32);
var _create = __webpack_require__(36);
var gOPNExt = __webpack_require__(97);
var $GOPD = __webpack_require__(16);
var $DP = __webpack_require__(8);
var $keys = __webpack_require__(34);
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__(37).f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(49).f = $propertyIsEnumerable;
  __webpack_require__(53).f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__(29)) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(11)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(47)('native-function-to-string', Function.toString);


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(34);
var gOPS = __webpack_require__(53);
var pIE = __webpack_require__(49);
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__(7), 'Object', { defineProperty: __webpack_require__(8).f });


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !__webpack_require__(7), 'Object', { defineProperties: __webpack_require__(96) });


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = __webpack_require__(15);
var $getOwnPropertyDescriptor = __webpack_require__(16).f;

__webpack_require__(24)('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: __webpack_require__(36) });


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = __webpack_require__(9);
var $getPrototypeOf = __webpack_require__(17);

__webpack_require__(24)('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__(9);
var $keys = __webpack_require__(34);

__webpack_require__(24)('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 Object.getOwnPropertyNames(O)
__webpack_require__(24)('getOwnPropertyNames', function () {
  return __webpack_require__(97).f;
});


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.5 Object.freeze(O)
var isObject = __webpack_require__(4);
var meta = __webpack_require__(30).onFreeze;

__webpack_require__(24)('freeze', function ($freeze) {
  return function freeze(it) {
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.17 Object.seal(O)
var isObject = __webpack_require__(4);
var meta = __webpack_require__(30).onFreeze;

__webpack_require__(24)('seal', function ($seal) {
  return function seal(it) {
    return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.15 Object.preventExtensions(O)
var isObject = __webpack_require__(4);
var meta = __webpack_require__(30).onFreeze;

__webpack_require__(24)('preventExtensions', function ($preventExtensions) {
  return function preventExtensions(it) {
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.12 Object.isFrozen(O)
var isObject = __webpack_require__(4);

__webpack_require__(24)('isFrozen', function ($isFrozen) {
  return function isFrozen(it) {
    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.13 Object.isSealed(O)
var isObject = __webpack_require__(4);

__webpack_require__(24)('isSealed', function ($isSealed) {
  return function isSealed(it) {
    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.11 Object.isExtensible(O)
var isObject = __webpack_require__(4);

__webpack_require__(24)('isExtensible', function ($isExtensible) {
  return function isExtensible(it) {
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(0);

$export($export.S + $export.F, 'Object', { assign: __webpack_require__(98) });


/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.10 Object.is(value1, value2)
var $export = __webpack_require__(0);
$export($export.S, 'Object', { is: __webpack_require__(99) });


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__(0);
$export($export.S, 'Object', { setPrototypeOf: __webpack_require__(71).set });


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {



// 19.1.3.6 Object.prototype.toString()
var classof = __webpack_require__(44);
var test = {};
test[__webpack_require__(5)('toStringTag')] = 'z';
if (test + '' != '[object z]') {
  __webpack_require__(12)(Object.prototype, 'toString', function toString() {
    return '[object ' + classof(this) + ']';
  }, true);
}


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = __webpack_require__(0);

$export($export.P, 'Function', { bind: __webpack_require__(100) });


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(8).f;
var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// 19.2.4.2 name
NAME in FProto || __webpack_require__(7) && dP(FProto, NAME, {
  configurable: true,
  get: function () {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});


/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {



var isObject = __webpack_require__(4);
var getPrototypeOf = __webpack_require__(17);
var HAS_INSTANCE = __webpack_require__(5)('hasInstance');
var FunctionProto = Function.prototype;
// 19.2.3.6 Function.prototype[@@hasInstance](V)
if (!(HAS_INSTANCE in FunctionProto)) __webpack_require__(8).f(FunctionProto, HAS_INSTANCE, { value: function (O) {
  if (typeof this != 'function' || !isObject(O)) return false;
  if (!isObject(this.prototype)) return O instanceof this;
  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
  while (O = getPrototypeOf(O)) if (this.prototype === O) return true;
  return false;
} });


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {



var global = __webpack_require__(2);
var has = __webpack_require__(14);
var cof = __webpack_require__(19);
var inheritIfRequired = __webpack_require__(72);
var toPrimitive = __webpack_require__(22);
var fails = __webpack_require__(3);
var gOPN = __webpack_require__(37).f;
var gOPD = __webpack_require__(16).f;
var dP = __webpack_require__(8).f;
var $trim = __webpack_require__(45).trim;
var NUMBER = 'Number';
var $Number = global[NUMBER];
var Base = $Number;
var proto = $Number.prototype;
// Opera ~12 has broken Object#toString
var BROKEN_COF = cof(__webpack_require__(36)(proto)) == NUMBER;
var TRIM = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber = function (argument) {
  var it = toPrimitive(argument, false);
  if (typeof it == 'string' && it.length > 2) {
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0);
    var third, radix, maxCode;
    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
        default: return +it;
      }
      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
  $Number = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var that = this;
    return that instanceof $Number
      // check on 1..constructor(foo) case
      && (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER)
        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for (var keys = __webpack_require__(7) ? gOPN(Base) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES6 (in case, if modules with ES6 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (has(Base, key = keys[j]) && !has($Number, key)) {
      dP($Number, key, gOPD(Base, key));
    }
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  __webpack_require__(12)(global, NUMBER, $Number);
}


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {



var $export = __webpack_require__(0);
var toInteger = __webpack_require__(20);
var aNumberValue = __webpack_require__(102);
var repeat = __webpack_require__(74);
var $toFixed = 1.0.toFixed;
var floor = Math.floor;
var data = [0, 0, 0, 0, 0, 0];
var ERROR = 'Number.toFixed: incorrect invocation!';
var ZERO = '0';

var multiply = function (n, c) {
  var i = -1;
  var c2 = c;
  while (++i < 6) {
    c2 += n * data[i];
    data[i] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};
var divide = function (n) {
  var i = 6;
  var c = 0;
  while (--i >= 0) {
    c += data[i];
    data[i] = floor(c / n);
    c = (c % n) * 1e7;
  }
};
var numToString = function () {
  var i = 6;
  var s = '';
  while (--i >= 0) {
    if (s !== '' || i === 0 || data[i] !== 0) {
      var t = String(data[i]);
      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
    }
  } return s;
};
var pow = function (x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};
var log = function (x) {
  var n = 0;
  var x2 = x;
  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }
  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  } return n;
};

$export($export.P + $export.F * (!!$toFixed && (
  0.00008.toFixed(3) !== '0.000' ||
  0.9.toFixed(0) !== '1' ||
  1.255.toFixed(2) !== '1.25' ||
  1000000000000000128.0.toFixed(0) !== '1000000000000000128'
) || !__webpack_require__(3)(function () {
  // V8 ~ Android 4.3-
  $toFixed.call({});
})), 'Number', {
  toFixed: function toFixed(fractionDigits) {
    var x = aNumberValue(this, ERROR);
    var f = toInteger(fractionDigits);
    var s = '';
    var m = ZERO;
    var e, z, j, k;
    if (f < 0 || f > 20) throw RangeError(ERROR);
    // eslint-disable-next-line no-self-compare
    if (x != x) return 'NaN';
    if (x <= -1e21 || x >= 1e21) return String(x);
    if (x < 0) {
      s = '-';
      x = -x;
    }
    if (x > 1e-21) {
      e = log(x * pow(2, 69, 1)) - 69;
      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if (e > 0) {
        multiply(0, z);
        j = f;
        while (j >= 7) {
          multiply(1e7, 0);
          j -= 7;
        }
        multiply(pow(10, j, 1), 0);
        j = e - 1;
        while (j >= 23) {
          divide(1 << 23);
          j -= 23;
        }
        divide(1 << j);
        multiply(1, 1);
        divide(2);
        m = numToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        m = numToString() + repeat.call(ZERO, f);
      }
    }
    if (f > 0) {
      k = m.length;
      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
    } else {
      m = s + m;
    } return m;
  }
});


/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {



var $export = __webpack_require__(0);
var $fails = __webpack_require__(3);
var aNumberValue = __webpack_require__(102);
var $toPrecision = 1.0.toPrecision;

$export($export.P + $export.F * ($fails(function () {
  // IE7-
  return $toPrecision.call(1, undefined) !== '1';
}) || !$fails(function () {
  // V8 ~ Android 4.3-
  $toPrecision.call({});
})), 'Number', {
  toPrecision: function toPrecision(precision) {
    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
  }
});


/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.1 Number.EPSILON
var $export = __webpack_require__(0);

$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.2 Number.isFinite(number)
var $export = __webpack_require__(0);
var _isFinite = __webpack_require__(2).isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it) {
    return typeof it == 'number' && _isFinite(it);
  }
});


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var $export = __webpack_require__(0);

$export($export.S, 'Number', { isInteger: __webpack_require__(103) });


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.4 Number.isNaN(number)
var $export = __webpack_require__(0);

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.5 Number.isSafeInteger(number)
var $export = __webpack_require__(0);
var isInteger = __webpack_require__(103);
var abs = Math.abs;

$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number) {
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = __webpack_require__(0);

$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = __webpack_require__(0);

$export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var $parseFloat = __webpack_require__(104);
// 20.1.2.12 Number.parseFloat(string)
$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', { parseFloat: $parseFloat });


/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var $parseInt = __webpack_require__(105);
// 20.1.2.13 Number.parseInt(string, radix)
$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', { parseInt: $parseInt });


/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var $parseInt = __webpack_require__(105);
// 18.2.5 parseInt(string, radix)
$export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt });


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var $parseFloat = __webpack_require__(104);
// 18.2.4 parseFloat(string)
$export($export.G + $export.F * (parseFloat != $parseFloat), { parseFloat: $parseFloat });


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.3 Math.acosh(x)
var $export = __webpack_require__(0);
var log1p = __webpack_require__(106);
var sqrt = Math.sqrt;
var $acosh = Math.acosh;

$export($export.S + $export.F * !($acosh
  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
  && Math.floor($acosh(Number.MAX_VALUE)) == 710
  // Tor Browser bug: Math.acosh(Infinity) -> NaN
  && $acosh(Infinity) == Infinity
), 'Math', {
  acosh: function acosh(x) {
    return (x = +x) < 1 ? NaN : x > 94906265.62425156
      ? Math.log(x) + Math.LN2
      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.5 Math.asinh(x)
var $export = __webpack_require__(0);
var $asinh = Math.asinh;

function asinh(x) {
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
}

// Tor Browser bug: Math.asinh(0) -> -0
$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.7 Math.atanh(x)
var $export = __webpack_require__(0);
var $atanh = Math.atanh;

// Tor Browser bug: Math.atanh(-0) -> 0
$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x) {
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});


/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.9 Math.cbrt(x)
var $export = __webpack_require__(0);
var sign = __webpack_require__(75);

$export($export.S, 'Math', {
  cbrt: function cbrt(x) {
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});


/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.11 Math.clz32(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  clz32: function clz32(x) {
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.12 Math.cosh(x)
var $export = __webpack_require__(0);
var exp = Math.exp;

$export($export.S, 'Math', {
  cosh: function cosh(x) {
    return (exp(x = +x) + exp(-x)) / 2;
  }
});


/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.14 Math.expm1(x)
var $export = __webpack_require__(0);
var $expm1 = __webpack_require__(76);

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 });


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.16 Math.fround(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', { fround: __webpack_require__(107) });


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.17 Math.hypot([value1[, value2[, â¦ ]]])
var $export = __webpack_require__(0);
var abs = Math.abs;

$export($export.S, 'Math', {
  hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;
    while (i < aLen) {
      arg = abs(arguments[i++]);
      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else sum += arg;
    }
    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.18 Math.imul(x, y)
var $export = __webpack_require__(0);
var $imul = Math.imul;

// some WebKit versions fails with big numbers, some has wrong arity
$export($export.S + $export.F * __webpack_require__(3)(function () {
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y) {
    var UINT16 = 0xffff;
    var xn = +x;
    var yn = +y;
    var xl = UINT16 & xn;
    var yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.21 Math.log10(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  log10: function log10(x) {
    return Math.log(x) * Math.LOG10E;
  }
});


/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.20 Math.log1p(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', { log1p: __webpack_require__(106) });


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.22 Math.log2(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  log2: function log2(x) {
    return Math.log(x) / Math.LN2;
  }
});


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.28 Math.sign(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', { sign: __webpack_require__(75) });


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.30 Math.sinh(x)
var $export = __webpack_require__(0);
var expm1 = __webpack_require__(76);
var exp = Math.exp;

// V8 near Chromium 38 has a problem with very small numbers
$export($export.S + $export.F * __webpack_require__(3)(function () {
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x) {
    return Math.abs(x = +x) < 1
      ? (expm1(x) - expm1(-x)) / 2
      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.33 Math.tanh(x)
var $export = __webpack_require__(0);
var expm1 = __webpack_require__(76);
var exp = Math.exp;

$export($export.S, 'Math', {
  tanh: function tanh(x) {
    var a = expm1(x = +x);
    var b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.34 Math.trunc(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  trunc: function trunc(it) {
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var toAbsoluteIndex = __webpack_require__(35);
var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars
    var res = [];
    var aLen = arguments.length;
    var i = 0;
    var code;
    while (aLen > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      );
    } return res.join('');
  }
});


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var toIObject = __webpack_require__(15);
var toLength = __webpack_require__(6);

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite) {
    var tpl = toIObject(callSite.raw);
    var len = toLength(tpl.length);
    var aLen = arguments.length;
    var res = [];
    var i = 0;
    while (len > i) {
      res.push(String(tpl[i++]));
      if (i < aLen) res.push(String(arguments[i]));
    } return res.join('');
  }
});


/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {



// 21.1.3.25 String.prototype.trim()
__webpack_require__(45)('trim', function ($trim) {
  return function trim() {
    return $trim(this, 3);
  };
});


/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {



var $export = __webpack_require__(0);
var $at = __webpack_require__(55)(false);
$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos) {
    return $at(this, pos);
  }
});


/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {


// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])

var $export = __webpack_require__(0);
var toLength = __webpack_require__(6);
var context = __webpack_require__(77);
var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];

$export($export.P + $export.F * __webpack_require__(78)(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString /* , endPosition = @length */) {
    var that = context(this, searchString, ENDS_WITH);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    var search = String(searchString);
    return $endsWith
      ? $endsWith.call(that, search, end)
      : that.slice(end - search.length, end) === search;
  }
});


/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {


// 21.1.3.7 String.prototype.includes(searchString, position = 0)

var $export = __webpack_require__(0);
var context = __webpack_require__(77);
var INCLUDES = 'includes';

$export($export.P + $export.F * __webpack_require__(78)(INCLUDES), 'String', {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~context(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: __webpack_require__(74)
});


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {


// 21.1.3.18 String.prototype.startsWith(searchString [, position ])

var $export = __webpack_require__(0);
var toLength = __webpack_require__(6);
var context = __webpack_require__(77);
var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];

$export($export.P + $export.F * __webpack_require__(78)(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith
      ? $startsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {



var $at = __webpack_require__(55)(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(79)(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {



// B.2.3.2 String.prototype.anchor(name)
__webpack_require__(13)('anchor', function (createHTML) {
  return function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  };
});


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {



// B.2.3.3 String.prototype.big()
__webpack_require__(13)('big', function (createHTML) {
  return function big() {
    return createHTML(this, 'big', '', '');
  };
});


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {



// B.2.3.4 String.prototype.blink()
__webpack_require__(13)('blink', function (createHTML) {
  return function blink() {
    return createHTML(this, 'blink', '', '');
  };
});


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {



// B.2.3.5 String.prototype.bold()
__webpack_require__(13)('bold', function (createHTML) {
  return function bold() {
    return createHTML(this, 'b', '', '');
  };
});


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {



// B.2.3.6 String.prototype.fixed()
__webpack_require__(13)('fixed', function (createHTML) {
  return function fixed() {
    return createHTML(this, 'tt', '', '');
  };
});


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {



// B.2.3.7 String.prototype.fontcolor(color)
__webpack_require__(13)('fontcolor', function (createHTML) {
  return function fontcolor(color) {
    return createHTML(this, 'font', 'color', color);
  };
});


/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {



// B.2.3.8 String.prototype.fontsize(size)
__webpack_require__(13)('fontsize', function (createHTML) {
  return function fontsize(size) {
    return createHTML(this, 'font', 'size', size);
  };
});


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {



// B.2.3.9 String.prototype.italics()
__webpack_require__(13)('italics', function (createHTML) {
  return function italics() {
    return createHTML(this, 'i', '', '');
  };
});


/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {



// B.2.3.10 String.prototype.link(url)
__webpack_require__(13)('link', function (createHTML) {
  return function link(url) {
    return createHTML(this, 'a', 'href', url);
  };
});


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {



// B.2.3.11 String.prototype.small()
__webpack_require__(13)('small', function (createHTML) {
  return function small() {
    return createHTML(this, 'small', '', '');
  };
});


/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {



// B.2.3.12 String.prototype.strike()
__webpack_require__(13)('strike', function (createHTML) {
  return function strike() {
    return createHTML(this, 'strike', '', '');
  };
});


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {



// B.2.3.13 String.prototype.sub()
__webpack_require__(13)('sub', function (createHTML) {
  return function sub() {
    return createHTML(this, 'sub', '', '');
  };
});


/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {



// B.2.3.14 String.prototype.sup()
__webpack_require__(13)('sup', function (createHTML) {
  return function sup() {
    return createHTML(this, 'sup', '', '');
  };
});


/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = __webpack_require__(0);

$export($export.S, 'Array', { isArray: __webpack_require__(54) });


/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {



var ctx = __webpack_require__(18);
var $export = __webpack_require__(0);
var toObject = __webpack_require__(9);
var call = __webpack_require__(108);
var isArrayIter = __webpack_require__(81);
var toLength = __webpack_require__(6);
var createProperty = __webpack_require__(82);
var getIterFn = __webpack_require__(83);

$export($export.S + $export.F * !__webpack_require__(57)(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {



var $export = __webpack_require__(0);
var createProperty = __webpack_require__(82);

// WebKit Array.of isn't generic
$export($export.S + $export.F * __webpack_require__(3)(function () {
  function F() { /* empty */ }
  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of(/* ...args */) {
    var index = 0;
    var aLen = arguments.length;
    var result = new (typeof this == 'function' ? this : Array)(aLen);
    while (aLen > index) createProperty(result, index, arguments[index++]);
    result.length = aLen;
    return result;
  }
});


/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {



// 22.1.3.13 Array.prototype.join(separator)
var $export = __webpack_require__(0);
var toIObject = __webpack_require__(15);
var arrayJoin = [].join;

// fallback for not array-like strings
$export($export.P + $export.F * (__webpack_require__(48) != Object || !__webpack_require__(21)(arrayJoin)), 'Array', {
  join: function join(separator) {
    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
  }
});


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {



var $export = __webpack_require__(0);
var html = __webpack_require__(70);
var cof = __webpack_require__(19);
var toAbsoluteIndex = __webpack_require__(35);
var toLength = __webpack_require__(6);
var arraySlice = [].slice;

// fallback for not array-like ES3 strings and DOM objects
$export($export.P + $export.F * __webpack_require__(3)(function () {
  if (html) arraySlice.call(html);
}), 'Array', {
  slice: function slice(begin, end) {
    var len = toLength(this.length);
    var klass = cof(this);
    end = end === undefined ? len : end;
    if (klass == 'Array') return arraySlice.call(this, begin, end);
    var start = toAbsoluteIndex(begin, len);
    var upTo = toAbsoluteIndex(end, len);
    var size = toLength(upTo - start);
    var cloned = new Array(size);
    var i = 0;
    for (; i < size; i++) cloned[i] = klass == 'String'
      ? this.charAt(start + i)
      : this[start + i];
    return cloned;
  }
});


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {



var $export = __webpack_require__(0);
var aFunction = __webpack_require__(10);
var toObject = __webpack_require__(9);
var fails = __webpack_require__(3);
var $sort = [].sort;
var test = [1, 2, 3];

$export($export.P + $export.F * (fails(function () {
  // IE8-
  test.sort(undefined);
}) || !fails(function () {
  // V8 bug
  test.sort(null);
  // Old WebKit
}) || !__webpack_require__(21)($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn) {
    return comparefn === undefined
      ? $sort.call(toObject(this))
      : $sort.call(toObject(this), aFunction(comparefn));
  }
});


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {



var $export = __webpack_require__(0);
var $forEach = __webpack_require__(25)(0);
var STRICT = __webpack_require__(21)([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn /* , thisArg */) {
    return $forEach(this, callbackfn, arguments[1]);
  }
});


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(4);
var isArray = __webpack_require__(54);
var SPECIES = __webpack_require__(5)('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};


/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {



var $export = __webpack_require__(0);
var $map = __webpack_require__(25)(1);

$export($export.P + $export.F * !__webpack_require__(21)([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments[1]);
  }
});


/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {



var $export = __webpack_require__(0);
var $filter = __webpack_require__(25)(2);

$export($export.P + $export.F * !__webpack_require__(21)([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments[1]);
  }
});


/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {



var $export = __webpack_require__(0);
var $some = __webpack_require__(25)(3);

$export($export.P + $export.F * !__webpack_require__(21)([].some, true), 'Array', {
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn /* , thisArg */) {
    return $some(this, callbackfn, arguments[1]);
  }
});


/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {



var $export = __webpack_require__(0);
var $every = __webpack_require__(25)(4);

$export($export.P + $export.F * !__webpack_require__(21)([].every, true), 'Array', {
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn /* , thisArg */) {
    return $every(this, callbackfn, arguments[1]);
  }
});


/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {



var $export = __webpack_require__(0);
var $reduce = __webpack_require__(109);

$export($export.P + $export.F * !__webpack_require__(21)([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});


/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {



var $export = __webpack_require__(0);
var $reduce = __webpack_require__(109);

$export($export.P + $export.F * !__webpack_require__(21)([].reduceRight, true), 'Array', {
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: function reduceRight(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
  }
});


/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {



var $export = __webpack_require__(0);
var $indexOf = __webpack_require__(52)(false);
var $native = [].indexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(21)($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? $native.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments[1]);
  }
});


/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {



var $export = __webpack_require__(0);
var toIObject = __webpack_require__(15);
var toInteger = __webpack_require__(20);
var toLength = __webpack_require__(6);
var $native = [].lastIndexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(21)($native)), 'Array', {
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
    // convert -0 to +0
    if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
    var O = toIObject(this);
    var length = toLength(O.length);
    var index = length - 1;
    if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
    if (index < 0) index = length + index;
    for (;index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0;
    return -1;
  }
});


/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = __webpack_require__(0);

$export($export.P, 'Array', { copyWithin: __webpack_require__(110) });

__webpack_require__(31)('copyWithin');


/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = __webpack_require__(0);

$export($export.P, 'Array', { fill: __webpack_require__(85) });

__webpack_require__(31)('fill');


/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {



// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = __webpack_require__(0);
var $find = __webpack_require__(25)(5);
var KEY = 'find';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__webpack_require__(31)(KEY);


/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {



// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var $export = __webpack_require__(0);
var $find = __webpack_require__(25)(6);
var KEY = 'findIndex';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__webpack_require__(31)(KEY);


/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(38)('Array');


/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var inheritIfRequired = __webpack_require__(72);
var dP = __webpack_require__(8).f;
var gOPN = __webpack_require__(37).f;
var isRegExp = __webpack_require__(56);
var $flags = __webpack_require__(50);
var $RegExp = global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;
// "new" creates a new object, old webkit buggy here
var CORRECT_NEW = new $RegExp(re1) !== re1;

if (__webpack_require__(7) && (!CORRECT_NEW || __webpack_require__(3)(function () {
  re2[__webpack_require__(5)('match')] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
    var tiRE = this instanceof $RegExp;
    var piRE = isRegExp(p);
    var fiU = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
      : inheritIfRequired(CORRECT_NEW
        ? new Base(piRE && !fiU ? p.source : p, f)
        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
      , tiRE ? this : proto, $RegExp);
  };
  var proxy = function (key) {
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function () { return Base[key]; },
      set: function (it) { Base[key] = it; }
    });
  };
  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);
  proto.constructor = $RegExp;
  $RegExp.prototype = proto;
  __webpack_require__(12)(global, 'RegExp', $RegExp);
}

__webpack_require__(38)('RegExp');


/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {



__webpack_require__(113);
var anObject = __webpack_require__(1);
var $flags = __webpack_require__(50);
var DESCRIPTORS = __webpack_require__(7);
var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function (fn) {
  __webpack_require__(12)(RegExp.prototype, TO_STRING, fn, true);
};

// 21.2.5.14 RegExp.prototype.toString()
if (__webpack_require__(3)(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {
  define(function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/',
      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  });
// FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}


/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {




var anObject = __webpack_require__(1);
var toLength = __webpack_require__(6);
var advanceStringIndex = __webpack_require__(88);
var regExpExec = __webpack_require__(58);

// @@match logic
__webpack_require__(59)('match', 1, function (defined, MATCH, $match, maybeCallNative) {
  return [
    // `String.prototype.match` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.match
    function match(regexp) {
      var O = defined(this);
      var fn = regexp == undefined ? undefined : regexp[MATCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
    },
    // `RegExp.prototype[@@match]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
    function (regexp) {
      var res = maybeCallNative($match, regexp, this);
      if (res.done) return res.value;
      var rx = anObject(regexp);
      var S = String(this);
      if (!rx.global) return regExpExec(rx, S);
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
      var A = [];
      var n = 0;
      var result;
      while ((result = regExpExec(rx, S)) !== null) {
        var matchStr = String(result[0]);
        A[n] = matchStr;
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
        n++;
      }
      return n === 0 ? null : A;
    }
  ];
});


/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {




var anObject = __webpack_require__(1);
var toObject = __webpack_require__(9);
var toLength = __webpack_require__(6);
var toInteger = __webpack_require__(20);
var advanceStringIndex = __webpack_require__(88);
var regExpExec = __webpack_require__(58);
var max = Math.max;
var min = Math.min;
var floor = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
};

// @@replace logic
__webpack_require__(59)('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {
  return [
    // `String.prototype.replace` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.replace
    function replace(searchValue, replaceValue) {
      var O = defined(this);
      var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
      return fn !== undefined
        ? fn.call(searchValue, O, replaceValue)
        : $replace.call(String(O), searchValue, replaceValue);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
    function (regexp, replaceValue) {
      var res = maybeCallNative($replace, regexp, this, replaceValue);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var functionalReplace = typeof replaceValue === 'function';
      if (!functionalReplace) replaceValue = String(replaceValue);
      var global = rx.global;
      if (global) {
        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }
      var results = [];
      while (true) {
        var result = regExpExec(rx, S);
        if (result === null) break;
        results.push(result);
        if (!global) break;
        var matchStr = String(result[0]);
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      }
      var accumulatedResult = '';
      var nextSourcePosition = 0;
      for (var i = 0; i < results.length; i++) {
        result = results[i];
        var matched = String(result[0]);
        var position = max(min(toInteger(result.index), S.length), 0);
        var captures = [];
        // NOTE: This is equivalent to
        //   captures = result.slice(1).map(maybeToString)
        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = [matched].concat(captures, position, S);
          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
          var replacement = String(replaceValue.apply(undefined, replacerArgs));
        } else {
          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
        }
        if (position >= nextSourcePosition) {
          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
          nextSourcePosition = position + matched.length;
        }
      }
      return accumulatedResult + S.slice(nextSourcePosition);
    }
  ];

    // https://tc39.github.io/ecma262/#sec-getsubstitution
  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
    if (namedCaptures !== undefined) {
      namedCaptures = toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }
    return $replace.call(replacement, symbols, function (match, ch) {
      var capture;
      switch (ch.charAt(0)) {
        case '$': return '$';
        case '&': return matched;
        case '`': return str.slice(0, position);
        case "'": return str.slice(tailPos);
        case '<':
          capture = namedCaptures[ch.slice(1, -1)];
          break;
        default: // \d\d?
          var n = +ch;
          if (n === 0) return match;
          if (n > m) {
            var f = floor(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return match;
          }
          capture = captures[n - 1];
      }
      return capture === undefined ? '' : capture;
    });
  }
});


/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {




var anObject = __webpack_require__(1);
var sameValue = __webpack_require__(99);
var regExpExec = __webpack_require__(58);

// @@search logic
__webpack_require__(59)('search', 1, function (defined, SEARCH, $search, maybeCallNative) {
  return [
    // `String.prototype.search` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.search
    function search(regexp) {
      var O = defined(this);
      var fn = regexp == undefined ? undefined : regexp[SEARCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
    },
    // `RegExp.prototype[@@search]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
    function (regexp) {
      var res = maybeCallNative($search, regexp, this);
      if (res.done) return res.value;
      var rx = anObject(regexp);
      var S = String(this);
      var previousLastIndex = rx.lastIndex;
      if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
      var result = regExpExec(rx, S);
      if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
      return result === null ? -1 : result.index;
    }
  ];
});


/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {




var isRegExp = __webpack_require__(56);
var anObject = __webpack_require__(1);
var speciesConstructor = __webpack_require__(51);
var advanceStringIndex = __webpack_require__(88);
var toLength = __webpack_require__(6);
var callRegExpExec = __webpack_require__(58);
var regexpExec = __webpack_require__(87);
var fails = __webpack_require__(3);
var $min = Math.min;
var $push = [].push;
var $SPLIT = 'split';
var LENGTH = 'length';
var LAST_INDEX = 'lastIndex';
var MAX_UINT32 = 0xffffffff;

// babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
var SUPPORTS_Y = !fails(function () { RegExp(MAX_UINT32, 'y'); });

// @@split logic
__webpack_require__(59)('split', 2, function (defined, SPLIT, $split, maybeCallNative) {
  var internalSplit;
  if (
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function (separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return [];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) return $split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? MAX_UINT32 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;
      while (match = regexpExec.call(separatorCopy, string)) {
        lastIndex = separatorCopy[LAST_INDEX];
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }
        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    internalSplit = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : $split.call(this, separator, limit);
    };
  } else {
    internalSplit = $split;
  }

  return [
    // `String.prototype.split` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.split
    function split(separator, limit) {
      var O = defined(this);
      var splitter = separator == undefined ? undefined : separator[SPLIT];
      return splitter !== undefined
        ? splitter.call(separator, O, limit)
        : internalSplit.call(String(O), separator, limit);
    },
    // `RegExp.prototype[@@split]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
    //
    // NOTE: This cannot be properly polyfilled in engines that don't support
    // the 'y' flag.
    function (regexp, limit) {
      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== $split);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var C = speciesConstructor(rx, RegExp);

      var unicodeMatching = rx.unicode;
      var flags = (rx.ignoreCase ? 'i' : '') +
                  (rx.multiline ? 'm' : '') +
                  (rx.unicode ? 'u' : '') +
                  (SUPPORTS_Y ? 'y' : 'g');

      // ^(? + rx + ) is needed, in combination with some S slicing, to
      // simulate the 'y' flag.
      var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
      var p = 0;
      var q = 0;
      var A = [];
      while (q < S.length) {
        splitter.lastIndex = SUPPORTS_Y ? q : 0;
        var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
        var e;
        if (
          z === null ||
          (e = $min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p
        ) {
          q = advanceStringIndex(S, q, unicodeMatching);
        } else {
          A.push(S.slice(p, q));
          if (A.length === lim) return A;
          for (var i = 1; i <= z.length - 1; i++) {
            A.push(z[i]);
            if (A.length === lim) return A;
          }
          q = p = e;
        }
      }
      A.push(S.slice(p));
      return A;
    }
  ];
});


/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {



var LIBRARY = __webpack_require__(29);
var global = __webpack_require__(2);
var ctx = __webpack_require__(18);
var classof = __webpack_require__(44);
var $export = __webpack_require__(0);
var isObject = __webpack_require__(4);
var aFunction = __webpack_require__(10);
var anInstance = __webpack_require__(39);
var forOf = __webpack_require__(40);
var speciesConstructor = __webpack_require__(51);
var task = __webpack_require__(89).set;
var microtask = __webpack_require__(90)();
var newPromiseCapabilityModule = __webpack_require__(91);
var perform = __webpack_require__(114);
var userAgent = __webpack_require__(60);
var promiseResolve = __webpack_require__(115);
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[__webpack_require__(5)('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function')
      && promise.then(empty) instanceof FakePromise
      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // we can't detect it synchronously, so just check versions
      && v8.indexOf('6.6') !== 0
      && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // may throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = __webpack_require__(41)($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
__webpack_require__(43)($Promise, PROMISE);
__webpack_require__(38)(PROMISE);
Wrapper = __webpack_require__(26)[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(57)(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});


/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {



var weak = __webpack_require__(120);
var validate = __webpack_require__(42);
var WEAK_SET = 'WeakSet';

// 23.4 WeakSet Objects
__webpack_require__(61)(WEAK_SET, function (get) {
  return function WeakSet() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value) {
    return weak.def(validate(this, WEAK_SET), value, true);
  }
}, weak, false, true);


/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export = __webpack_require__(0);
var aFunction = __webpack_require__(10);
var anObject = __webpack_require__(1);
var rApply = (__webpack_require__(2).Reflect || {}).apply;
var fApply = Function.apply;
// MS Edge argumentsList argument is optional
$export($export.S + $export.F * !__webpack_require__(3)(function () {
  rApply(function () { /* empty */ });
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList) {
    var T = aFunction(target);
    var L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});


/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export = __webpack_require__(0);
var create = __webpack_require__(36);
var aFunction = __webpack_require__(10);
var anObject = __webpack_require__(1);
var isObject = __webpack_require__(4);
var fails = __webpack_require__(3);
var bind = __webpack_require__(100);
var rConstruct = (__webpack_require__(2).Reflect || {}).construct;

// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(rConstruct(function () { /* empty */ }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  rConstruct(function () { /* empty */ });
});

$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args /* , newTarget */) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});


/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP = __webpack_require__(8);
var $export = __webpack_require__(0);
var anObject = __webpack_require__(1);
var toPrimitive = __webpack_require__(22);

// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
$export($export.S + $export.F * __webpack_require__(3)(function () {
  // eslint-disable-next-line no-undef
  Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 });
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes) {
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);
    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch (e) {
      return false;
    }
  }
});


/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export = __webpack_require__(0);
var gOPD = __webpack_require__(16).f;
var anObject = __webpack_require__(1);

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey) {
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});


/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {



// 26.1.5 Reflect.enumerate(target)
var $export = __webpack_require__(0);
var anObject = __webpack_require__(1);
var Enumerate = function (iterated) {
  this._t = anObject(iterated); // target
  this._i = 0;                  // next index
  var keys = this._k = [];      // keys
  var key;
  for (key in iterated) keys.push(key);
};
__webpack_require__(80)(Enumerate, 'Object', function () {
  var that = this;
  var keys = that._k;
  var key;
  do {
    if (that._i >= keys.length) return { value: undefined, done: true };
  } while (!((key = keys[that._i++]) in that._t));
  return { value: key, done: false };
});

$export($export.S, 'Reflect', {
  enumerate: function enumerate(target) {
    return new Enumerate(target);
  }
});


/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD = __webpack_require__(16);
var getPrototypeOf = __webpack_require__(17);
var has = __webpack_require__(14);
var $export = __webpack_require__(0);
var isObject = __webpack_require__(4);
var anObject = __webpack_require__(1);

function get(target, propertyKey /* , receiver */) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var desc, proto;
  if (anObject(target) === receiver) return target[propertyKey];
  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value')
    ? desc.value
    : desc.get !== undefined
      ? desc.get.call(receiver)
      : undefined;
  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', { get: get });


/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD = __webpack_require__(16);
var $export = __webpack_require__(0);
var anObject = __webpack_require__(1);

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
    return gOPD.f(anObject(target), propertyKey);
  }
});


/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.8 Reflect.getPrototypeOf(target)
var $export = __webpack_require__(0);
var getProto = __webpack_require__(17);
var anObject = __webpack_require__(1);

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target) {
    return getProto(anObject(target));
  }
});


/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.9 Reflect.has(target, propertyKey)
var $export = __webpack_require__(0);

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey) {
    return propertyKey in target;
  }
});


/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.10 Reflect.isExtensible(target)
var $export = __webpack_require__(0);
var anObject = __webpack_require__(1);
var $isExtensible = Object.isExtensible;

$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target) {
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});


/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.11 Reflect.ownKeys(target)
var $export = __webpack_require__(0);

$export($export.S, 'Reflect', { ownKeys: __webpack_require__(121) });


/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.12 Reflect.preventExtensions(target)
var $export = __webpack_require__(0);
var anObject = __webpack_require__(1);
var $preventExtensions = Object.preventExtensions;

$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target) {
    anObject(target);
    try {
      if ($preventExtensions) $preventExtensions(target);
      return true;
    } catch (e) {
      return false;
    }
  }
});


/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP = __webpack_require__(8);
var gOPD = __webpack_require__(16);
var getPrototypeOf = __webpack_require__(17);
var has = __webpack_require__(14);
var $export = __webpack_require__(0);
var createDesc = __webpack_require__(32);
var anObject = __webpack_require__(1);
var isObject = __webpack_require__(4);

function set(target, propertyKey, V /* , receiver */) {
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDesc = gOPD.f(anObject(target), propertyKey);
  var existingDescriptor, proto;
  if (!ownDesc) {
    if (isObject(proto = getPrototypeOf(target))) {
      return set(proto, propertyKey, V, receiver);
    }
    ownDesc = createDesc(0);
  }
  if (has(ownDesc, 'value')) {
    if (ownDesc.writable === false || !isObject(receiver)) return false;
    if (existingDescriptor = gOPD.f(receiver, propertyKey)) {
      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
      existingDescriptor.value = V;
      dP.f(receiver, propertyKey, existingDescriptor);
    } else dP.f(receiver, propertyKey, createDesc(0, V));
    return true;
  }
  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', { set: set });


/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export = __webpack_require__(0);
var setProto = __webpack_require__(71);

if (setProto) $export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto) {
    setProto.check(target, proto);
    try {
      setProto.set(target, proto);
      return true;
    } catch (e) {
      return false;
    }
  }
});


/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = __webpack_require__(0);

$export($export.S, 'Date', { now: function () { return new Date().getTime(); } });


/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {



var $export = __webpack_require__(0);
var toObject = __webpack_require__(9);
var toPrimitive = __webpack_require__(22);

$export($export.P + $export.F * __webpack_require__(3)(function () {
  return new Date(NaN).toJSON() !== null
    || Date.prototype.toJSON.call({ toISOString: function () { return 1; } }) !== 1;
}), 'Date', {
  // eslint-disable-next-line no-unused-vars
  toJSON: function toJSON(key) {
    var O = toObject(this);
    var pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});


/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var $export = __webpack_require__(0);
var toISOString = __webpack_require__(252);

// PhantomJS / old WebKit has a broken implementations
$export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {
  toISOString: toISOString
});


/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {



// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var fails = __webpack_require__(3);
var getTime = Date.prototype.getTime;
var $toISOString = Date.prototype.toISOString;

var lz = function (num) {
  return num > 9 ? num : '0' + num;
};

// PhantomJS / old WebKit has a broken implementations
module.exports = (fails(function () {
  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
}) || !fails(function () {
  $toISOString.call(new Date(NaN));
})) ? function toISOString() {
  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
  var d = this;
  var y = d.getUTCFullYear();
  var m = d.getUTCMilliseconds();
  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
    '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
    'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
    ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
} : $toISOString;


/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

var DateProto = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var $toString = DateProto[TO_STRING];
var getTime = DateProto.getTime;
if (new Date(NaN) + '' != INVALID_DATE) {
  __webpack_require__(12)(DateProto, TO_STRING, function toString() {
    var value = getTime.call(this);
    // eslint-disable-next-line no-self-compare
    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}


/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

var TO_PRIMITIVE = __webpack_require__(5)('toPrimitive');
var proto = Date.prototype;

if (!(TO_PRIMITIVE in proto)) __webpack_require__(11)(proto, TO_PRIMITIVE, __webpack_require__(255));


/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {



var anObject = __webpack_require__(1);
var toPrimitive = __webpack_require__(22);
var NUMBER = 'number';

module.exports = function (hint) {
  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};


/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {



var $export = __webpack_require__(0);
var $typed = __webpack_require__(62);
var buffer = __webpack_require__(92);
var anObject = __webpack_require__(1);
var toAbsoluteIndex = __webpack_require__(35);
var toLength = __webpack_require__(6);
var isObject = __webpack_require__(4);
var ArrayBuffer = __webpack_require__(2).ArrayBuffer;
var speciesConstructor = __webpack_require__(51);
var $ArrayBuffer = buffer.ArrayBuffer;
var $DataView = buffer.DataView;
var $isView = $typed.ABV && ArrayBuffer.isView;
var $slice = $ArrayBuffer.prototype.slice;
var VIEW = $typed.VIEW;
var ARRAY_BUFFER = 'ArrayBuffer';

$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });

$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it) {
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});

$export($export.P + $export.U + $export.F * __webpack_require__(3)(function () {
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end) {
    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix
    var len = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, len);
    var fin = toAbsoluteIndex(end === undefined ? len : end, len);
    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(fin - first));
    var viewS = new $DataView(this);
    var viewT = new $DataView(result);
    var index = 0;
    while (first < fin) {
      viewT.setUint8(index++, viewS.getUint8(first++));
    } return result;
  }
});

__webpack_require__(38)(ARRAY_BUFFER);


/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
$export($export.G + $export.W + $export.F * !__webpack_require__(62).ABV, {
  DataView: __webpack_require__(92).DataView
});


/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(27)('Int8', 1, function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(27)('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(27)('Uint8', 1, function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);


/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(27)('Int16', 2, function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(27)('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(27)('Int32', 4, function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(27)('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(27)('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(27)('Float64', 8, function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {



// https://github.com/tc39/Array.prototype.includes
var $export = __webpack_require__(0);
var $includes = __webpack_require__(52)(true);

$export($export.P, 'Array', {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__(31)('includes');


/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {



// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap
var $export = __webpack_require__(0);
var flattenIntoArray = __webpack_require__(123);
var toObject = __webpack_require__(9);
var toLength = __webpack_require__(6);
var aFunction = __webpack_require__(10);
var arraySpeciesCreate = __webpack_require__(84);

$export($export.P, 'Array', {
  flatMap: function flatMap(callbackfn /* , thisArg */) {
    var O = toObject(this);
    var sourceLen, A;
    aFunction(callbackfn);
    sourceLen = toLength(O.length);
    A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
    return A;
  }
});

__webpack_require__(31)('flatMap');


/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {



// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatten
var $export = __webpack_require__(0);
var flattenIntoArray = __webpack_require__(123);
var toObject = __webpack_require__(9);
var toLength = __webpack_require__(6);
var toInteger = __webpack_require__(20);
var arraySpeciesCreate = __webpack_require__(84);

$export($export.P, 'Array', {
  flatten: function flatten(/* depthArg = 1 */) {
    var depthArg = arguments[0];
    var O = toObject(this);
    var sourceLen = toLength(O.length);
    var A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
    return A;
  }
});

__webpack_require__(31)('flatten');


/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {



// https://github.com/mathiasbynens/String.prototype.at
var $export = __webpack_require__(0);
var $at = __webpack_require__(55)(true);

$export($export.P, 'String', {
  at: function at(pos) {
    return $at(this, pos);
  }
});


/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {



// https://github.com/tc39/proposal-string-pad-start-end
var $export = __webpack_require__(0);
var $pad = __webpack_require__(124);
var userAgent = __webpack_require__(60);

// https://github.com/zloirock/core-js/issues/280
var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);

$export($export.P + $export.F * WEBKIT_BUG, 'String', {
  padStart: function padStart(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});


/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {



// https://github.com/tc39/proposal-string-pad-start-end
var $export = __webpack_require__(0);
var $pad = __webpack_require__(124);
var userAgent = __webpack_require__(60);

// https://github.com/zloirock/core-js/issues/280
var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);

$export($export.P + $export.F * WEBKIT_BUG, 'String', {
  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});


/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {



// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
__webpack_require__(45)('trimLeft', function ($trim) {
  return function trimLeft() {
    return $trim(this, 1);
  };
}, 'trimStart');


/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {



// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
__webpack_require__(45)('trimRight', function ($trim) {
  return function trimRight() {
    return $trim(this, 2);
  };
}, 'trimEnd');


/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {



// https://tc39.github.io/String.prototype.matchAll/
var $export = __webpack_require__(0);
var defined = __webpack_require__(23);
var toLength = __webpack_require__(6);
var isRegExp = __webpack_require__(56);
var getFlags = __webpack_require__(50);
var RegExpProto = RegExp.prototype;

var $RegExpStringIterator = function (regexp, string) {
  this._r = regexp;
  this._s = string;
};

__webpack_require__(80)($RegExpStringIterator, 'RegExp String', function next() {
  var match = this._r.exec(this._s);
  return { value: match, done: match === null };
});

$export($export.P, 'String', {
  matchAll: function matchAll(regexp) {
    defined(this);
    if (!isRegExp(regexp)) throw TypeError(regexp + ' is not a regexp!');
    var S = String(this);
    var flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp);
    var rx = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
    rx.lastIndex = toLength(regexp.lastIndex);
    return new $RegExpStringIterator(rx, S);
  }
});


/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(67)('asyncIterator');


/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(67)('observable');


/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export = __webpack_require__(0);
var ownKeys = __webpack_require__(121);
var toIObject = __webpack_require__(15);
var gOPD = __webpack_require__(16);
var createProperty = __webpack_require__(82);

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIObject(object);
    var getDesc = gOPD.f;
    var keys = ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;
    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) createProperty(result, key, desc);
    }
    return result;
  }
});


/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(0);
var $values = __webpack_require__(125)(false);

$export($export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  }
});


/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(0);
var $entries = __webpack_require__(125)(true);

$export($export.S, 'Object', {
  entries: function entries(it) {
    return $entries(it);
  }
});


/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {



var $export = __webpack_require__(0);
var toObject = __webpack_require__(9);
var aFunction = __webpack_require__(10);
var $defineProperty = __webpack_require__(8);

// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
__webpack_require__(7) && $export($export.P + __webpack_require__(63), 'Object', {
  __defineGetter__: function __defineGetter__(P, getter) {
    $defineProperty.f(toObject(this), P, { get: aFunction(getter), enumerable: true, configurable: true });
  }
});


/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {



var $export = __webpack_require__(0);
var toObject = __webpack_require__(9);
var aFunction = __webpack_require__(10);
var $defineProperty = __webpack_require__(8);

// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
__webpack_require__(7) && $export($export.P + __webpack_require__(63), 'Object', {
  __defineSetter__: function __defineSetter__(P, setter) {
    $defineProperty.f(toObject(this), P, { set: aFunction(setter), enumerable: true, configurable: true });
  }
});


/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {



var $export = __webpack_require__(0);
var toObject = __webpack_require__(9);
var toPrimitive = __webpack_require__(22);
var getPrototypeOf = __webpack_require__(17);
var getOwnPropertyDescriptor = __webpack_require__(16).f;

// B.2.2.4 Object.prototype.__lookupGetter__(P)
__webpack_require__(7) && $export($export.P + __webpack_require__(63), 'Object', {
  __lookupGetter__: function __lookupGetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;
    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.get;
    } while (O = getPrototypeOf(O));
  }
});


/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {



var $export = __webpack_require__(0);
var toObject = __webpack_require__(9);
var toPrimitive = __webpack_require__(22);
var getPrototypeOf = __webpack_require__(17);
var getOwnPropertyDescriptor = __webpack_require__(16).f;

// B.2.2.5 Object.prototype.__lookupSetter__(P)
__webpack_require__(7) && $export($export.P + __webpack_require__(63), 'Object', {
  __lookupSetter__: function __lookupSetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;
    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.set;
    } while (O = getPrototypeOf(O));
  }
});


/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = __webpack_require__(0);

$export($export.P + $export.R, 'Map', { toJSON: __webpack_require__(126)('Map') });


/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = __webpack_require__(0);

$export($export.P + $export.R, 'Set', { toJSON: __webpack_require__(126)('Set') });


/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
__webpack_require__(64)('Map');


/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
__webpack_require__(64)('Set');


/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
__webpack_require__(64)('WeakMap');


/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of
__webpack_require__(64)('WeakSet');


/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
__webpack_require__(65)('Map');


/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
__webpack_require__(65)('Set');


/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
__webpack_require__(65)('WeakMap');


/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from
__webpack_require__(65)('WeakSet');


/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-global
var $export = __webpack_require__(0);

$export($export.G, { global: __webpack_require__(2) });


/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-global
var $export = __webpack_require__(0);

$export($export.S, 'System', { global: __webpack_require__(2) });


/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/ljharb/proposal-is-error
var $export = __webpack_require__(0);
var cof = __webpack_require__(19);

$export($export.S, 'Error', {
  isError: function isError(it) {
    return cof(it) === 'Error';
  }
});


/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  clamp: function clamp(x, lower, upper) {
    return Math.min(upper, Math.max(lower, x));
  }
});


/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);

$export($export.S, 'Math', { DEG_PER_RAD: Math.PI / 180 });


/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);
var RAD_PER_DEG = 180 / Math.PI;

$export($export.S, 'Math', {
  degrees: function degrees(radians) {
    return radians * RAD_PER_DEG;
  }
});


/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);
var scale = __webpack_require__(128);
var fround = __webpack_require__(107);

$export($export.S, 'Math', {
  fscale: function fscale(x, inLow, inHigh, outLow, outHigh) {
    return fround(scale(x, inLow, inHigh, outLow, outHigh));
  }
});


/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  iaddh: function iaddh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
  }
});


/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  isubh: function isubh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
  }
});


/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  imulh: function imulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >> 16;
    var v1 = $v >> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
  }
});


/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);

$export($export.S, 'Math', { RAD_PER_DEG: 180 / Math.PI });


/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);
var DEG_PER_RAD = Math.PI / 180;

$export($export.S, 'Math', {
  radians: function radians(degrees) {
    return degrees * DEG_PER_RAD;
  }
});


/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);

$export($export.S, 'Math', { scale: __webpack_require__(128) });


/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  umulh: function umulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >>> 16;
    var v1 = $v >>> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
  }
});


/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

// http://jfbastien.github.io/papers/Math.signbit.html
var $export = __webpack_require__(0);

$export($export.S, 'Math', { signbit: function signbit(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) != x ? x : x == 0 ? 1 / x == Infinity : x > 0;
} });


/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {


// https://github.com/tc39/proposal-promise-finally

var $export = __webpack_require__(0);
var core = __webpack_require__(26);
var global = __webpack_require__(2);
var speciesConstructor = __webpack_require__(51);
var promiseResolve = __webpack_require__(115);

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });


/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {



// https://github.com/tc39/proposal-promise-try
var $export = __webpack_require__(0);
var newPromiseCapability = __webpack_require__(91);
var perform = __webpack_require__(114);

$export($export.S, 'Promise', { 'try': function (callbackfn) {
  var promiseCapability = newPromiseCapability.f(this);
  var result = perform(callbackfn);
  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
  return promiseCapability.promise;
} });


/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(28);
var anObject = __webpack_require__(1);
var toMetaKey = metadata.key;
var ordinaryDefineOwnMetadata = metadata.set;

metadata.exp({ defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) {
  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
} });


/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(28);
var anObject = __webpack_require__(1);
var toMetaKey = metadata.key;
var getOrCreateMetadataMap = metadata.map;
var store = metadata.store;

metadata.exp({ deleteMetadata: function deleteMetadata(metadataKey, target /* , targetKey */) {
  var targetKey = arguments.length < 3 ? undefined : toMetaKey(arguments[2]);
  var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
  if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;
  if (metadataMap.size) return true;
  var targetMetadata = store.get(target);
  targetMetadata['delete'](targetKey);
  return !!targetMetadata.size || store['delete'](target);
} });


/***/ }),
/* 314 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(28);
var anObject = __webpack_require__(1);
var getPrototypeOf = __webpack_require__(17);
var ordinaryHasOwnMetadata = metadata.has;
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

var ordinaryGetMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P);
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
};

metadata.exp({ getMetadata: function getMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });


/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

var Set = __webpack_require__(118);
var from = __webpack_require__(127);
var metadata = __webpack_require__(28);
var anObject = __webpack_require__(1);
var getPrototypeOf = __webpack_require__(17);
var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

var ordinaryMetadataKeys = function (O, P) {
  var oKeys = ordinaryOwnMetadataKeys(O, P);
  var parent = getPrototypeOf(O);
  if (parent === null) return oKeys;
  var pKeys = ordinaryMetadataKeys(parent, P);
  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
};

metadata.exp({ getMetadataKeys: function getMetadataKeys(target /* , targetKey */) {
  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
} });


/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(28);
var anObject = __webpack_require__(1);
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

metadata.exp({ getOwnMetadata: function getOwnMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryGetOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });


/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(28);
var anObject = __webpack_require__(1);
var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

metadata.exp({ getOwnMetadataKeys: function getOwnMetadataKeys(target /* , targetKey */) {
  return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
} });


/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(28);
var anObject = __webpack_require__(1);
var getPrototypeOf = __webpack_require__(17);
var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

var ordinaryHasMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return true;
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
};

metadata.exp({ hasMetadata: function hasMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });


/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(28);
var anObject = __webpack_require__(1);
var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

metadata.exp({ hasOwnMetadata: function hasOwnMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryHasOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });


/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

var $metadata = __webpack_require__(28);
var anObject = __webpack_require__(1);
var aFunction = __webpack_require__(10);
var toMetaKey = $metadata.key;
var ordinaryDefineOwnMetadata = $metadata.set;

$metadata.exp({ metadata: function metadata(metadataKey, metadataValue) {
  return function decorator(target, targetKey) {
    ordinaryDefineOwnMetadata(
      metadataKey, metadataValue,
      (targetKey !== undefined ? anObject : aFunction)(target),
      toMetaKey(targetKey)
    );
  };
} });


/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
var $export = __webpack_require__(0);
var microtask = __webpack_require__(90)();
var process = __webpack_require__(2).process;
var isNode = __webpack_require__(19)(process) == 'process';

$export($export.G, {
  asap: function asap(fn) {
    var domain = isNode && process.domain;
    microtask(domain ? domain.bind(fn) : fn);
  }
});


/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {



// https://github.com/zenparsing/es-observable
var $export = __webpack_require__(0);
var global = __webpack_require__(2);
var core = __webpack_require__(26);
var microtask = __webpack_require__(90)();
var OBSERVABLE = __webpack_require__(5)('observable');
var aFunction = __webpack_require__(10);
var anObject = __webpack_require__(1);
var anInstance = __webpack_require__(39);
var redefineAll = __webpack_require__(41);
var hide = __webpack_require__(11);
var forOf = __webpack_require__(40);
var RETURN = forOf.RETURN;

var getMethod = function (fn) {
  return fn == null ? undefined : aFunction(fn);
};

var cleanupSubscription = function (subscription) {
  var cleanup = subscription._c;
  if (cleanup) {
    subscription._c = undefined;
    cleanup();
  }
};

var subscriptionClosed = function (subscription) {
  return subscription._o === undefined;
};

var closeSubscription = function (subscription) {
  if (!subscriptionClosed(subscription)) {
    subscription._o = undefined;
    cleanupSubscription(subscription);
  }
};

var Subscription = function (observer, subscriber) {
  anObject(observer);
  this._c = undefined;
  this._o = observer;
  observer = new SubscriptionObserver(this);
  try {
    var cleanup = subscriber(observer);
    var subscription = cleanup;
    if (cleanup != null) {
      if (typeof cleanup.unsubscribe === 'function') cleanup = function () { subscription.unsubscribe(); };
      else aFunction(cleanup);
      this._c = cleanup;
    }
  } catch (e) {
    observer.error(e);
    return;
  } if (subscriptionClosed(this)) cleanupSubscription(this);
};

Subscription.prototype = redefineAll({}, {
  unsubscribe: function unsubscribe() { closeSubscription(this); }
});

var SubscriptionObserver = function (subscription) {
  this._s = subscription;
};

SubscriptionObserver.prototype = redefineAll({}, {
  next: function next(value) {
    var subscription = this._s;
    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      try {
        var m = getMethod(observer.next);
        if (m) return m.call(observer, value);
      } catch (e) {
        try {
          closeSubscription(subscription);
        } finally {
          throw e;
        }
      }
    }
  },
  error: function error(value) {
    var subscription = this._s;
    if (subscriptionClosed(subscription)) throw value;
    var observer = subscription._o;
    subscription._o = undefined;
    try {
      var m = getMethod(observer.error);
      if (!m) throw value;
      value = m.call(observer, value);
    } catch (e) {
      try {
        cleanupSubscription(subscription);
      } finally {
        throw e;
      }
    } cleanupSubscription(subscription);
    return value;
  },
  complete: function complete(value) {
    var subscription = this._s;
    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      subscription._o = undefined;
      try {
        var m = getMethod(observer.complete);
        value = m ? m.call(observer, value) : undefined;
      } catch (e) {
        try {
          cleanupSubscription(subscription);
        } finally {
          throw e;
        }
      } cleanupSubscription(subscription);
      return value;
    }
  }
});

var $Observable = function Observable(subscriber) {
  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
};

redefineAll($Observable.prototype, {
  subscribe: function subscribe(observer) {
    return new Subscription(observer, this._f);
  },
  forEach: function forEach(fn) {
    var that = this;
    return new (core.Promise || global.Promise)(function (resolve, reject) {
      aFunction(fn);
      var subscription = that.subscribe({
        next: function (value) {
          try {
            return fn(value);
          } catch (e) {
            reject(e);
            subscription.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
    });
  }
});

redefineAll($Observable, {
  from: function from(x) {
    var C = typeof this === 'function' ? this : $Observable;
    var method = getMethod(anObject(x)[OBSERVABLE]);
    if (method) {
      var observable = anObject(method.call(x));
      return observable.constructor === C ? observable : new C(function (observer) {
        return observable.subscribe(observer);
      });
    }
    return new C(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          try {
            if (forOf(x, false, function (it) {
              observer.next(it);
              if (done) return RETURN;
            }) === RETURN) return;
          } catch (e) {
            if (done) throw e;
            observer.error(e);
            return;
          } observer.complete();
        }
      });
      return function () { done = true; };
    });
  },
  of: function of() {
    for (var i = 0, l = arguments.length, items = new Array(l); i < l;) items[i] = arguments[i++];
    return new (typeof this === 'function' ? this : $Observable)(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          for (var j = 0; j < items.length; ++j) {
            observer.next(items[j]);
            if (done) return;
          } observer.complete();
        }
      });
      return function () { done = true; };
    });
  }
});

hide($Observable.prototype, OBSERVABLE, function () { return this; });

$export($export.G, { Observable: $Observable });

__webpack_require__(38)('Observable');


/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var $task = __webpack_require__(89);
$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});


/***/ }),
/* 324 */
/***/ (function(module, exports, __webpack_require__) {

var $iterators = __webpack_require__(86);
var getKeys = __webpack_require__(34);
var redefine = __webpack_require__(12);
var global = __webpack_require__(2);
var hide = __webpack_require__(11);
var Iterators = __webpack_require__(46);
var wks = __webpack_require__(5);
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}


/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

// ie9- setTimeout & setInterval additional parameters fix
var global = __webpack_require__(2);
var $export = __webpack_require__(0);
var userAgent = __webpack_require__(60);
var slice = [].slice;
var MSIE = /MSIE .\./.test(userAgent); // <- dirty ie9- check
var wrap = function (set) {
  return function (fn, time /* , ...args */) {
    var boundArgs = arguments.length > 2;
    var args = boundArgs ? slice.call(arguments, 2) : false;
    return set(boundArgs ? function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
    } : fn, time);
  };
};
$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout: wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});


/***/ })
/******/ ]);
// CommonJS export
if (typeof module != 'undefined' && module.exports) module.exports = __e;
// RequireJS export
else if (typeof define == 'function' && define.amd) define(function () { return __e; });
// Export to global object
else __g.core = __e;
}(1, 1);
});

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var regeneratorRuntime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
  (typeof module === "object" && module.exports) ? module.exports : {}
));

define("regenerator-runtime", function(){});

/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */



  define('polyfills', ['corejs', 'regenerator-runtime']);

  define('promise', ['polyfills'], function () {
    Promise.polyfill = function () {};
    return Promise;
  });

define('ojs/ojcore-base',['require', 'ojs/ojlogger', 'polyfills'], function(require, Logger)
{
  "use strict";



/* jslint browser: true*/

/**
 * Defines the oj namespace
 */

/**
 * @private
 */
var _scope = {}; //  - check if the window object is available
// Note that the 'typeof' check  is required

if (typeof window !== 'undefined') {
  _scope = window; // eslint-disable-next-line no-restricted-globals
} else if (typeof self !== 'undefined') {
  // eslint-disable-next-line no-restricted-globals
  _scope = self;
}
/**
 * @private
 */


var _oldVal = _scope.oj; // eslint-disable-next-line no-unused-vars

var oj = {
  /**
   * @global
   * @member {string} version JET version numberr
   */
  version: '9.1.0',

  /**
   * @global
   * @member {string} revision JET source code revision number
   */
  revision: '2020-08-05_19-00-35',
  // This function is only meant to be used outside the library, so quoting the name
  // to avoid renaming is appropriate
  noConflict: function noConflict() {
    _scope.oj = _oldVal;
  },

  /**
   * Adds a property to the "oj" namespace. This is used by ES6 modules to set
   * legacy exported objects onto the import "oj" namespace, since modifying the
   * original imported object isn't allowed under ES6.
   * @param {string} name The property name, such as "PopupService"
   * @param {object} value The value to set for the property
   * @private
   */
  _registerLegacyNamespaceProp: function _registerLegacyNamespaceProp(name, value) {
    this[name] = value;
  }
};
_scope.oj = oj;

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }



/* global _scope:false */

/* jslint browser: true*/

/**
 * Assertion utilities.
 * The container is expected to have already initialized the oj.Assert Object before this
 * code is executed and initialized the oj.Assert.DEBUG flag/
 * @class
 * @export
 * @ignore
 */
oj.Assert = {};
/**
 * @private
 */

var _DEBUG = 'DEBUG';
/**
 * Forces DEBUG to be set to true
 * @export
 * @memberof oj.Assert
 */

oj.Assert.forceDebug = function () {
  oj.Assert[_DEBUG] = true;
};
/**
 * Forces DEBUG to be set to false
 * @export
 * @memberof oj.Assert
 */


oj.Assert.clearDebug = function () {
  oj.Assert[_DEBUG] = false;
};
/**
 * Determines whether oj.Assert is running in debug mode
 * @return {boolean} true for debug mode, false otherwise
 * @export
 * @memberof oj.Assert
 */


oj.Assert.isDebug = function () {
  return oj.Assert[_DEBUG] === true;
};
/**
 * Asserts that a condition is true.  If the condition does not
 * evaluate to true, an exception is thrown with the optional message
 * and reason
 * @param {boolean} condition condition to test
 * @param {string=} message message to display
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assert = function (condition, message) {
  if (oj.Assert[_DEBUG] && !condition) {
    var myMessage = message || '';

    if (arguments.length > 2) {
      myMessage += '(';

      for (var i = 2; i < arguments.length; i += 1) {
        myMessage += arguments[i];
      }

      myMessage += ')';
    }

    oj.Assert.assertionFailed(myMessage, 1);
  }
};
/**
 * Convenience function for asserting when an abstact function is called
 * @export
 * @memberof oj.Assert
 */


oj.Assert.failedInAbstractFunction = function () {
  if (oj.Assert[_DEBUG]) {
    oj.Assert.assertionFailed('Abstract function called', 1);
  }
};
/**
 * Asserts that the the target object has the same prototype as the example
 * type
 * @param {Object} target description
 * @param {Function} theConstructor
 * @param {string=} reason
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertPrototype = function (target, theConstructor, reason) {
  if (oj.Assert[_DEBUG]) {
    var thePrototype = theConstructor.prototype;

    if (target != null) {
      oj.Assert.assertType(theConstructor, 'function', null, 1, false);
      var isPrototypeOf = Object.prototype.isPrototypeOf;

      if (!isPrototypeOf.call(thePrototype, target)) {
        oj.Assert.assertionFailed("object '" + target + "' doesn't match prototype " + thePrototype, 1, reason);
      }
    } else {
      oj.Assert.assertionFailed("null object doesn't match prototype " + thePrototype, 1, reason);
    }
  }
};
/**
 * Asserts that the the target object has the same prototype as the example
 * type or is null.
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertPrototypeOrNull = function (target, theConstructor, reason) {
  if (oj.Assert[_DEBUG] && target != null) {
    oj.Assert.assertType(theConstructor, 'function', null, 1, false);
    var thePrototype = theConstructor.prototype;
    var isPrototypeOf = Object.prototype.isPrototypeOf;

    if (!isPrototypeOf.call(thePrototype, target)) {
      oj.Assert.assertionFailed("object '" + target + "' doesn't match prototype " + thePrototype, 1, reason);
    }
  }
};
/**
 * Asserts that the the target object has the same prototype as the example
 * types
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertPrototypes = function (target, instanceOne, instanceTwo, reason) {
  if (oj.Assert[_DEBUG]) {
    var thePrototype = instanceOne.prototype;
    var thePrototypeTwo = instanceTwo.prototype;
    var isPrototypeOf = Object.prototype.isPrototypeOf;

    if (!(isPrototypeOf.call(thePrototype, target) || isPrototypeOf.call(thePrototypeTwo, target))) {
      oj.Assert.assertionFailed("object '" + target + "' doesn't match prototype " + thePrototype + ' or ' + thePrototypeTwo, 1, reason);
    }
  }
};
/**
 * Asserts that the target is a DOM Node or Null
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertDomNodeOrNull = function (target, depth) {
  if (oj.Assert[_DEBUG] && target) {
    if (target.nodeType === undefined) {
      oj.Assert.assertionFailed(target + ' is not a DOM Node', depth + 1);
    }
  }
};
/**
 * Asserts that the target is a DOM Node
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertDomNode = function (target, depth) {
  if (oj.Assert[_DEBUG]) {
    if (!target || target.nodeType === undefined) {
      oj.Assert.assertionFailed(target + ' is not a DOM Node', depth + 1);
    }
  }
};
/**
 * Asserts that the target is a DOM Element and optionally has the specified
 * element name
 * @param {Object} target target object
 * @param {string=} nodeName name of the element
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertDomElement = function (target, nodeName) {
  if (oj.Assert[_DEBUG]) {
    oj.Assert.assertDomNode(target, 1);

    if (target.nodeType !== 1) {
      oj.Assert.assertionFailed(target + ' is not a DOM Element', 1);
    } else if (nodeName && target.nodeName !== nodeName) {
      oj.Assert.assertionFailed(target + ' is not a ' + nodeName + ' Element', 1);
    }
  }
};
/**
 * Asserts that the target is a DOM Element and optionally has the specified
 * element name
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertDomElementOrNull = function (target, nodeName) {
  if (oj.Assert[_DEBUG] && target != null) {
    oj.Assert.assertDomNode(target, 1);

    if (target.nodeType !== 1) {
      oj.Assert.assertionFailed(target + ' is not a DOM Element', 1);
    } else if (nodeName && target.nodeName !== nodeName) {
      oj.Assert.assertionFailed(target + ' is not a ' + nodeName + ' Element', 1);
    }
  }
};
/**
 * Asserts that the target object has the typeof specified
 *
 * @param {Object|null|string|undefined} target
 * @param {string} type typeof type that statisfies this condition
 * @param {string|undefined|null} prefix
 * @param {number} depth stack depth to skip when printing stack traces
 * @param {boolean} nullOK true if a null value satisfies this condition
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertType = function (target, type, prefix, depth, nullOK) {
  if (oj.Assert[_DEBUG]) {
    // either the target is null and null is OK, or the target better
    // be of the correct type
    var targetType = _typeof(target);

    if (!(target == null && nullOK || targetType === type)) {
      var message = target + ' is not of type ' + type;

      if (prefix) {
        message = prefix + message;
      }

      if (!depth) {
        // eslint-disable-next-line no-param-reassign
        depth = 0;
      }

      oj.Assert.assertionFailed(message, depth + 1);
    }
  }
};
/**
 * Asserts that the target is an Object
 * @param {Object} target description
 * @param {string=} prefix
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertObject = function (target, prefix) {
  if (oj.Assert[_DEBUG]) {
    oj.Assert.assertType(target, 'object', prefix, 1, false);
  }
};
/**
 * Asserts that the target is an Object or null
 * @param {Object} target description
 * @param {string=} prefix
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertObjectOrNull = function (target, prefix) {
  if (oj.Assert[_DEBUG]) {
    oj.Assert.assertType(target, 'object', prefix, 1, true);
  }
};
/**
 * Asserts that the target is a non-empty String
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertNonEmptyString = function (target, prefix) {
  if (oj.Assert[_DEBUG]) {
    oj.Assert.assertType(target, 'string', prefix, 1, false);
    oj.Assert.assert(target.length > 0, 'empty string');
  }
};
/**
 * Asserts that the target is a String
 * @param target target object
 * @param {string=} prefix prefix string
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertString = function (target, prefix) {
  if (oj.Assert[_DEBUG]) {
    oj.Assert.assertType(target, 'string', prefix, 1, false);
  }
};
/**
 * Asserts that the target is a String or null
 * @param {string|null|undefined|Object} target target object
 * @param {string=} prefix prefix string
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertStringOrNull = function (target, prefix) {
  if (oj.Assert[_DEBUG]) {
    oj.Assert.assertType(target, 'string', prefix, 1, true);
  }
};
/**
 * Asserts that the target is a Function
 * @param {Object} target target object
 * @param {string=} prefix prefix string
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertFunction = function (target, prefix) {
  if (oj.Assert[_DEBUG]) {
    oj.Assert.assertType(target, 'function', prefix, 1, false);
  }
};
/**
 * Asserts that the target is a Function or null
 * @param {Object} target target object
 * @param {string=} prefix prefix
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertFunctionOrNull = function (target, prefix) {
  if (oj.Assert[_DEBUG]) {
    oj.Assert.assertType(target, 'function', prefix, 1, true);
  }
};
/**
 * Asserts that the target is a boolean
 * @param {Object} target description
 * @param {string=} prefix
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertBoolean = function (target, prefix) {
  if (oj.Assert[_DEBUG]) {
    oj.Assert.assertType(target, 'boolean', prefix, 1, false);
  }
};
/**
 * Asserts that the target is a number
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertNumber = function (target, prefix) {
  if (oj.Assert[_DEBUG]) {
    oj.Assert.assertType(target, 'number', prefix, 1, false);
  }
};
/**
 * Asserts that the target is a number or Null
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertNumberOrNull = function (target, prefix) {
  if (oj.Assert[_DEBUG]) {
    oj.Assert.assertType(target, 'number', prefix, 1, true);
  }
};
/**
 * Asserts that the target object is an Array
 * @param {Object} target target object
 * @param {string=} message optional message
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertArray = function (target, message) {
  if (oj.Assert[_DEBUG]) {
    if (!Array.isArray(target)) {
      if (message === undefined) {
        // eslint-disable-next-line no-param-reassign
        message = target + ' is not an array';
      }

      oj.Assert.assertionFailed(message, 1);
    }
  }
};
/**
 * Asserts that the target object is an Array or null
 * @param {Object} target target object
 * @param {string=} message optional message
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertArrayOrNull = function (target, message) {
  if (oj.Assert[_DEBUG] && target != null) {
    if (!Array.isArray(target)) {
      if (message === undefined) {
        // eslint-disable-next-line no-param-reassign
        message = target + ' is not an array';
      }

      oj.Assert.assertionFailed(message, 1);
    }
  }
};
/**
 * Asserts that the target object is not either a number, or convertible to a number
 * @param {Object} target target object
 * @param {string=} message optional message
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertNonNumeric = function (target, message) {
  if (oj.Assert[_DEBUG]) {
    if (!isNaN(target)) {
      if (message === undefined) {
        // eslint-disable-next-line no-param-reassign
        message = target + ' is convertible to a number';
      }

      oj.Assert.assertionFailed(message, 1);
    }
  }
};
/**
 * Asserts that the target object is either a number, or convertible to a number
 * @param {Object} target target object
 * @param {string=} message optional message
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertNumeric = function (target, message) {
  if (oj.Assert[_DEBUG]) {
    if (isNaN(target)) {
      if (message === undefined) {
        // eslint-disable-next-line no-param-reassign
        message = target + ' is not convertible to a number';
      }

      oj.Assert.assertionFailed(message, 1);
    }
  }
};
/**
 * Asserts that value String is in the Set
 * @param {Object} value value to check
 * @param {Object} set set to check
 * @param {string=} message optional message
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertInSet = function (value, set, message) {
  if (value == null || set[value.toString()] === undefined) {
    if (message === undefined) {
      var keyString = ' is not in set: {';
      var keys = Object.keys(set);

      for (var k = 0; k < keys.length; k++) {
        var key = keys[k];
        keyString += key;
        keyString += ',';
      }

      keyString += '}'; // eslint-disable-next-line no-param-reassign

      message = value + keyString;
    }

    oj.Assert.assertionFailed(message, 1);
  }
};
/**
 * Base assertion failure support that supports specifying the stack skipping
 * level
 * @param {string} message Message to display
 * @param {number} skipLevel assertion level
 * @param {string=} reason reason to display
 * @export
 * @memberof oj.Assert
 */


oj.Assert.assertionFailed = function (message, skipLevel, reason) {
  if (!skipLevel) {
    // eslint-disable-next-line no-param-reassign
    skipLevel = 0;
  }

  var errorMessage = 'Assertion';

  if (reason) {
    errorMessage += ' (' + reason + ')';
  }

  errorMessage += ' failed: ';

  if (message !== undefined) {
    errorMessage += message;
  }

  var error = new Error(errorMessage);
  throw error;
};
/**
 * @private
 * @memberof oj.Assert
 */


var _assertSetting = _scope.__oj_Assert_DEBUG;

if (_assertSetting !== undefined) {
  oj.Assert[_DEBUG] = _assertSetting;
}

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Utilities for working with collections
 * @export
 */
oj.CollectionUtils = {};
/**
 * Copies all of the properties of source into the target and returns the target
 *
 * @param {Object} target - target collection
 * @param {Object} source - source collection
 * @param {function(string)=} keyConverter a callback for converting the key
 * @param {boolean=} recurse - true if this method should recurse into plain Javascript object properties
 * @param {number=} maxRecursionDepth - the maximum depth of the recursion into plain Javascript object properties
 * @return target collection
 * @export
 * @memberof! oj.CollectionUtils
 */

oj.CollectionUtils.copyInto = function (target, source, keyConverter, recurse, maxRecursionDepth) {
  return oj.CollectionUtils._copyIntoImpl(target, source, keyConverter, recurse, maxRecursionDepth, 0);
};
/**
 * A simpler alternative to copyInto()
 * @param {Object} target - target collection
 * @param Array{Object} - one or more sources to merge into the target
 * @ignore
 */


oj.CollectionUtils.mergeDeep = function (target) {
  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    sources[_key - 1] = arguments[_key];
  }

  if (!sources.length) return target;
  var isPlain = oj.CollectionUtils.isPlainObject;
  var merge = oj.CollectionUtils.mergeDeep;
  var source = sources.shift();

  if (isPlain(target) && isPlain(source)) {
    Object.keys(source).forEach(function (key) {
      if (isPlain(source[key])) {
        if (!target[key]) Object.assign(target, _defineProperty({}, key, {}));
        merge(target[key], source[key]);
      } else {
        Object.assign(target, _defineProperty({}, key, source[key]));
      }
    });
  }

  return merge.apply(void 0, [target].concat(sources));
};
/**
 * Checks whether the object is a direct instance of Object
 * @param {Object} obj - object to test
 *
 * @return {boolean} true if the object is a direct instance of Object, false otherwise
 * @export
 * @memberof! oj.CollectionUtils
 */


oj.CollectionUtils.isPlainObject = function (obj) {
  if (obj !== null && _typeof(obj) === 'object') {
    try {
      var hasOwnProperty = Object.prototype.hasOwnProperty;

      if (obj.constructor && hasOwnProperty.call(obj.constructor.prototype, 'isPrototypeOf')) {
        return true;
      }
    } catch (e) {// Ignore errors
    }
  }

  return false;
};
/**
 * @private
 * @memberof! oj.CollectionUtils
 */


oj.CollectionUtils._copyIntoImpl = function (target, source, keyConverter, recurse, maxRecursionDepth, currentLevel) {
  var targetKey;

  if (maxRecursionDepth === undefined || maxRecursionDepth === null) {
    // eslint-disable-next-line no-param-reassign
    maxRecursionDepth = Number.MAX_VALUE;
  }

  if (target && source && target !== source) {
    var keys = Object.keys(source);

    for (var i = 0; i < keys.length; i++) {
      var k = keys[i]; // allow the key mapping to be overridden

      if (keyConverter) {
        targetKey = keyConverter(k);
      } else {
        targetKey = k;
      }

      var sourceVal = source[k];
      var recursed = false;

      if (recurse && currentLevel < maxRecursionDepth) {
        var targetVal = target[targetKey];

        if (oj.CollectionUtils.isPlainObject(sourceVal) && (targetVal == null || oj.CollectionUtils.isPlainObject(targetVal))) {
          recursed = true; // eslint-disable-next-line no-param-reassign

          target[targetKey] = targetVal || {};

          oj.CollectionUtils._copyIntoImpl(target[targetKey], sourceVal, keyConverter, true, maxRecursionDepth, currentLevel + 1);
        }
      }

      if (!recursed) {
        // eslint-disable-next-line no-param-reassign
        target[targetKey] = sourceVal;
      }
    }
  }

  return target;
};

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }



/* jslint browser: true*/

/* global define: false, Promise:false*/

/**
 * Base class of all OJET Objects.
 * <p>
 * To create a subclass of another oj.Object, use oj.Object.createSubclass.
 * The subclass can specify class-level initialization by implementing an
 * <code>InitClass()</code> method on its constructor.  <code>InitClass</code>
 * is guaranteed to be called only once per class.  Further, a class'
 * <code>InitClass</code> method is guranteed to be called only after its
 * superclass' class initialization has been called.  When <code>InitClass</code>
 * is called, <code>this</code> is the class' constructor.  This allows class
 * initialization implementations to be shared in some cases.
 * </p>
 */

/**
 * @constructor oj.Object
 * @final
 * @ojtsignore
 * @since 1.0
 * @export
 */
oj.Object = function () {
  this.Init();
};

oj.Object.superclass = null;
/**
 * @private
 */

oj.Object._typeName = 'oj.Object'; // regular expressicloneon for stripping out the name of a function

/**
 * @private
 */

oj.Object._GET_FUNCTION_NAME_REGEXP = /function\s+([\w$][\w$\d]*)\s*\(/; // oj.Object._TRIM_REGEXP = /(^\s*)|(\s*$)/g; this.replace(/(^\s*)|(\s*$)/g, "");

oj.Object.prototype = {};
oj.Object.prototype.constructor = oj.Object;
/**
 * Creates a subclass of a baseClass
 * @method createSubclass
 * @memberof oj.Object
 * @param {Object} extendingClass The class to extend from the base class
 * @param {Object} baseClass class to make the superclass of extendingClass
 * @param {string=} typeName to use for new class.  If not specified, the typeName will be extracted from the
 * baseClass's function if possible
 * @return {void}
 * @export
 */

oj.Object.createSubclass = function (extendingClass, baseClass, typeName) {
  // optional name to name this class
  oj.Assert.assertFunction(extendingClass);
  oj.Assert.assertFunctionOrNull(baseClass);
  oj.Assert.assertStringOrNull(typeName);

  if (baseClass === undefined) {
    // assume oj.Object
    // eslint-disable-next-line no-param-reassign
    baseClass = oj.Object;
  }

  oj.Assert.assert(extendingClass !== baseClass, "Class can't extend itself"); // use a temporary constructor to get our superclass as our prototype
  // without out having to initialize the superclass

  /**
   * @private
   * @constructor
   */

  var TempConstructor = oj.Object._tempSubclassConstructor;
  TempConstructor.prototype = baseClass.prototype; // eslint-disable-next-line no-param-reassign

  extendingClass.prototype = new TempConstructor(); // eslint-disable-next-line no-param-reassign

  extendingClass.prototype.constructor = extendingClass; // eslint-disable-next-line no-param-reassign

  extendingClass.superclass = baseClass.prototype;

  if (typeName) {
    // eslint-disable-next-line no-param-reassign
    extendingClass._typeName = typeName;
  }
};
/**
 * Copies properties from the source object to the prototype of the target class
 * Only properties 'owned' by the source object will be copied, i.e. the properties
 * from the source object's prototype chain will not be included.
 * To copy properties from another class with methods defined on the prototype, pass
 * otherClass.prototype as the source.
 * @method copyPropertiesForClass
 * @memberof oj.Object
 * @param {Object} targetClass - the function whose prototype will be used a
 * copy target
 * @param {Object} source - object whose properties will be copied
 * @return {void}
 * @export
 */


oj.Object.copyPropertiesForClass = function (targetClass, source) {
  oj.Assert.assertFunction(targetClass);
  oj.Assert.assert(source != null, 'source object cannot be null');
  var props = Object.keys(source);

  for (var i = 0; i < props.length; i++) {
    var prop = props[i]; // eslint-disable-next-line no-param-reassign

    targetClass.prototype[prop] = source[prop];
  }
};
/**
 * @private
 */


oj.Object._tempSubclassConstructor = function () {};
/**
 * Returns the class object for the instance
 * @method getClass
 * @memberof oj.Object
 * @instance
 * @param {Object=} otherInstance - if specified, the instance whose type
 * should be returned. Otherwise the type of this instance will be returned
 * @return {Object} the class object for the instance
 * @final
 * @export
 */


oj.Object.prototype.getClass = function (otherInstance) {
  if (otherInstance === undefined) {
    // eslint-disable-next-line no-param-reassign
    otherInstance = this;
  } else if (otherInstance === null) {
    return null;
  }

  return otherInstance.constructor;
};
/**
 * Returns a clone of this object.  The default implementation is a shallow
 * copy.  Subclassers can override this method to implement a deep copy.
 * @method clone
 * @memberof oj.Object
 * @instance
 * @return {Object} a clone of this object
 * @export
 */


oj.Object.prototype.clone = function () {
  var clone = new this.constructor();
  oj.CollectionUtils.copyInto(clone, this);
  return clone;
};
/**
 * @export
 * @method toString
 * @memberof oj.Object
 * @instance
 * @return {string}
 */


oj.Object.prototype.toString = function () {
  return this.toDebugString();
};
/**
 * @export
 * @method toDebugString
 * @memberof oj.Object
 * @instance
 * @return {string}
 */


oj.Object.prototype.toDebugString = function () {
  return this.getTypeName() + ' Object';
};
/**
 * Returns the type name for a class derived from oj.Object
 * @method getTypeName
 * @memberof oj.Object
 * @instance
 * @param {Object|null} clazz Class to get the name of
 * @return {string} name of the Class
 * @export
 */


oj.Object.getTypeName = function (clazz) {
  oj.Assert.assertFunction(clazz);
  var typeName = clazz._typeName;

  if (typeName == null) {
    var constructorText = clazz.toString();

    var matches = oj.Object._GET_FUNCTION_NAME_REGEXP.exec(constructorText);

    if (matches) {
      typeName = matches[1];
    } else {
      typeName = 'anonymous';
    } // cache the result on the function
    // eslint-disable-next-line no-param-reassign


    clazz._typeName = typeName;
  }

  return typeName;
};
/**
 * Returns the type name for this instance
 * @method getTypeName
 * @memberof oj.Object
 * @return {string} name of the Class
 * @final
 * @export
 */


oj.Object.prototype.getTypeName = function () {
  return oj.Object.getTypeName(this.constructor);
};
/**
 * Initializes the instance.  Subclasses of oj.Object must call
 * their superclass' Init
 * @export
 * @method Init
 * @return {void}
 * @memberof oj.Object
 * @instance
 */


oj.Object.prototype.Init = function () {
  if (oj.Assert.isDebug()) {
    oj.Assert.assert(this.getTypeName, 'Not an oj.Object');
  } // do any class initialization.  This code is duplicated from
  // oj.Object.ensureClassInitialization()


  var currClass = this.constructor;

  if (!currClass._initialized) {
    oj.Object._initClasses(currClass);
  }
};
/**
 * Ensures that a class is initialized.  Although class initialization occurs
 * by default the first time that an instance of a class is created, classes that
 * use static factory methods to create their instances may
 * still need to ensure that their class has been initialized when the factory
 * method is called.
 *
 * @method ensureClassInitialization
 * @memberof oj.Object
 * @param {Object} clazz The class to ensure initialization of
 * @return {void}
 * @export
 */


oj.Object.ensureClassInitialization = function (clazz) {
  oj.Assert.assertFunction(clazz);

  if (!clazz._initialized) {
    oj.Object._initClasses(clazz);
  }
};
/**
 * Indicates whether some other oj.Object is "equal to" this one.
 * Method is equivalent to java ".equals()" method.
 * @method equals
 * @memberof oj.Object
 * @instance
 * @param {Object} object - comparison target
 * @return {boolean} true if if the comparison target is equal to this object, false otherwise
 * @export
 */


oj.Object.prototype.equals = function (object) {
  return this === object;
};
/**
 * Binds the supplied callback function to an object
 * @method createCallback
 * @memberof oj.Object
 * @param {!Object} obj - object that will be available to the supplied callback
 * function as 'this'
 * @param {!Object} func - the original callback
 * @return {function()} a function that will be invoking the original callback with
 * 'this' object assigned to obj
 * @ojsignature {target: "Type", for: "returns", value: "()=>any"}
 * @export
 */


oj.Object.createCallback = function (obj, func) {
  oj.Assert.assertFunction(func); // All browsers supported by JET support bind() method

  return func.bind(obj);
};
/**
 * @private
 */


oj.Object._initClasses = function (currClass) {
  if (oj.Assert.isDebug()) {
    oj.Assert.assertFunction(currClass);
    oj.Assert.assert(!currClass._initialized);
  } // eslint-disable-next-line no-param-reassign


  currClass._initialized = true;
  var superclass = currClass.superclass; // initialize the superclass if necessary

  if (superclass) {
    var superclassConstructor = superclass.constructor;

    if (superclassConstructor && !superclassConstructor._initialized) {
      oj.Object._initClasses(superclassConstructor);
    }
  } // if the class has an initialization function, call it


  var InitClassFunc = currClass.InitClass;

  if (InitClassFunc) {
    InitClassFunc.call(currClass);
  }
};
/**
 * Compares 2 values using strict equality except for the case of
 * <ol>
 *   <li> Array [order matters]; will traverse through the arrays and compare oj.Object.compareValues(array[i], array2[i]) </li>
 *   <li> Instances that support valueOf [i.e. Boolean, String, Number, Date, and etc] will be compared by usage of that function </li>
 * </ol>
 * @param {any} obj1 The first value to compare.
 * @param {any} obj2 The second value to compare.
 * @return {boolean}
 * @public
 * @export
 * @method compareValues
 * @memberof oj.Object
 */


oj.Object.compareValues = function (obj1, obj2) {
  if (obj1 === obj2) {
    return true;
  }

  var obj1Type = _typeof(obj1);

  var obj2Type = _typeof(obj2);

  if (obj1Type !== obj2Type) {
    // of different type so consider them unequal
    return false;
  } // At this point means the types are equal
  // note that if the operand is an array or a null then typeof is an object
  // check if either is null and if so return false [i.e. case where one might be a null and another an object]
  // and one wishes to avoid the null pointer in the following checks. Note that null === null has been already tested


  if (obj1 === null || obj2 === null) {
    return false;
  } // now check for constructor since I think by here one has ruled out primitive values and if the constructors
  // aren't equal then return false


  if (obj1.constructor === obj2.constructor) {
    // these are special cases and will need to be modded on a need to have basis
    if (Array.isArray(obj1)) {
      return oj.Object._compareArrayValues(obj1, obj2);
    } else if (obj1.constructor === Object) {
      // for now invoke innerEquals and in the future if there are issues then resolve them
      return oj.Object.__innerEquals(obj1, obj2);
    } else if (obj1.valueOf && typeof obj1.valueOf === 'function') {
      // test cases for Boolean, String, Number, Date
      // Note if some future JavaScript constructors
      // do not impl it then it's their fault
      return obj1.valueOf() === obj2.valueOf();
    }
  }

  return false;
};

oj.Object._compareArrayValues = function (array1, array2) {
  if (array1.length !== array2.length) {
    return false;
  }

  for (var i = 0, j = array1.length; i < j; i++) {
    // recurse on each of the values, order does matter for our case since do not wish to search
    // for the value [expensive]
    if (!oj.Object.compareValues(array1[i], array2[i])) {
      return false;
    }
  }

  return true;
}; // Comparion of two Objects containing id and or index properties.
// Note: it returns false if one is an id and other is an index
// if ids are the same, index will be ignored if there is only one is provided


oj.Object._compareIdIndexObject = function (obj1, obj2) {
  if (typeof obj1 === 'number' && typeof obj2 === 'number' || typeof obj1 === 'string' && typeof obj2 === 'string') {
    return obj1 === obj2;
  }

  if (_typeof(obj1) === 'object' && _typeof(obj2) === 'object') {
    if (obj1.id && obj2.id) {
      if (obj1.id !== obj2.id) {
        return false;
      }

      if (obj1.index && obj2.index) {
        return obj1.index === obj2.index;
      }

      return true;
    } else if (obj1.index && obj2.index) {
      return obj1.index === obj2.index;
    }
  }

  return false;
}; // Comparion of two arrays containing ids, indexes, or objects where each object has id,
// index or both properties.
// order needn't be same but no duplicates


oj.Object._compareArrayIdIndexObject = function (array1, array2) {
  // null and [] are equals
  if (!array1) {
    return !array2 || array2.length === 0;
  }

  if (!array2) {
    return !array1 || array1.length === 0;
  }

  if (array1.length !== array2.length) {
    return false;
  }

  for (var i = 0; i < array1.length; i++) {
    var found = false;

    for (var j = 0; j < array2.length; j++) {
      if (oj.Object._compareIdIndexObject(array1[i], array2[j])) {
        found = true;
        break;
      }
    }

    if (!found) {
      return false;
    }
  }

  return true;
};

oj.Object.__innerEquals = function (obj1, obj2) {
  if (obj1 === obj2) {
    return true;
  }

  if (!(obj1 instanceof Object) || !(obj2 instanceof Object)) {
    return false;
  }

  if (obj1.constructor !== obj2.constructor) {
    return false;
  }

  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var props1 = Object.keys(obj1);
  var prop;
  var i;

  for (i = 0; i < props1.length; i++) {
    prop = props1[i];

    if (hasOwnProperty.call(obj1, prop)) {
      if (!hasOwnProperty.call(obj2, prop)) {
        return false;
      }

      if (obj1[prop] !== obj2[prop]) {
        if (_typeof(obj1[prop]) !== 'object') {
          return false;
        }

        if (!oj.Object.__innerEquals(obj1[prop], obj2[prop])) {
          return false;
        }
      }
    }
  }

  var props2 = Object.keys(obj2);

  for (i = 0; i < props2.length; i++) {
    prop = props2[i];

    if (hasOwnProperty.call(obj2, prop) && !hasOwnProperty.call(obj1, prop)) {
      return false;
    }
  }

  if (props1.length === 0 && props2.length === 0) {
    // we are dealing with objects that have no properties like Number or Date.
    return JSON.stringify(obj1) === JSON.stringify(obj2);
  }

  return true;
};
/**
 * @method isEmpty
 * @return {boolean}
 * @memberof oj.Object
 */


oj.Object.isEmpty = function (object) {
  var prop; // Test if an object is empty

  if (object === undefined || object === null) {
    return true;
  }

  for (prop in object) {
    // eslint-disable-line no-restricted-syntax
    if (object.hasOwnProperty(prop)) {
      // eslint-disable-line no-prototype-builtins
      return false;
    }
  }

  return true;
};
/**
 * @private
 * @return  {boolean} true if AMD Loader (such as Require.js) is present,
 *                    false otherwise
 */


oj.__isAmdLoaderPresent = function () {
  return typeof define === 'function' && define.amd;
};
/**
 * Loads a file using require if AMD loader is present, otherwise returns null
 * If loading multiple files then use multiple calls to this and Promise.all
 * @private
 * @param {string} module sting of the module to load
 * @param {function} requireFunc what to use as the require function, if not specified require will be used
 * @returns {Promise|null} returns null if no AMD loader
 */


oj.__getRequirePromise = function (module, requireFunc) {
  if (oj.__isAmdLoaderPresent()) {
    return new Promise(function (resolve, reject) {
      requireFunc([module], resolve, reject);
    });
  }

  return null;
};



/**
 * String utilities.
 * @class oj.StringUtils
 * @export
 * @ignore
 */
oj.StringUtils = {};
oj.StringUtils._TRIM_ALL_RE = /^\s*|\s*$/g;
/**
 * Returns true if the value is null or if the trimmed value is of zero length.
 *
 * @param {Object|string|null} value
 * @returns {boolean} true if the string or Object (e.g., Array) is of zero length.
 * @export
 * @memberof oj.StringUtils
 */

oj.StringUtils.isEmpty = function (value) {
  if (value === null) {
    return true;
  }

  var trimValue = oj.StringUtils.trim(value);
  return trimValue.length === 0;
};
/**
 * Returns true if the value is null, undefined or if the trimmed value is of zero length.
 *
 * @param {Object|string|null=} value
 * @returns {boolean} true if the string or Object (e.g., Array) is of zero length.
 * @export
 * @memberof oj.StringUtils
 */


oj.StringUtils.isEmptyOrUndefined = function (value) {
  if (value === undefined || oj.StringUtils.isEmpty(value)) {
    return true;
  }

  return false;
};
/**
 * Test if an object is a string (either a string constant or a string object)
 * @param {Object|string|null} obj object to test
 * @return {boolean} true if a string constant or string object
 * @export
 * @memberof oj.StringUtils
 */


oj.StringUtils.isString = function (obj) {
  return obj !== null && (typeof obj === 'string' || obj instanceof String);
};
/**
 * Remove leading and trailing whitespace
 * @param {Object|string|null} data to trim
 * @return {Object|string|null}
 * @export
 * @memberof oj.StringUtils
 */


oj.StringUtils.trim = function (data) {
  if (oj.StringUtils.isString(data)) {
    return data.replace(oj.StringUtils._TRIM_ALL_RE, '');
  }

  return data;
};
/**
 * Port of the Java String.hashCode method.
 * http://erlycoder.com/49/javascript-hash-functions-to-convert-string-into-integer-hash-
 *
 * @param {string} str
 * @returns {number}
 * @public
 * @memberof oj.StringUtils
 */


oj.StringUtils.hashCode = function (str) {
  var hash = 0;

  if (str.length === 0) {
    return hash;
  }

  for (var i = 0; i < str.length; i++) {
    var c = str.charCodeAt(i); // eslint-disable-next-line no-bitwise

    hash = (hash << 5) - hash + c; // eslint-disable-next-line no-bitwise

    hash &= hash;
  }

  return hash;
}; // Polyfills for IE11


(function () {
  // String.startsWith requires for IE11
  if (!String.prototype.startsWith) {
    // eslint-disable-next-line no-extend-native
    String.prototype.startsWith = function (searchString, position) {
      // eslint-disable-next-line no-param-reassign
      position = position || 0;
      return this.substr(position, searchString.length) === searchString;
    };
  } // String.endsWith requires for IE11


  if (!String.prototype.endsWith) {
    // eslint-disable-next-line no-extend-native
    String.prototype.endsWith = function (searchString, position) {
      var subjectString = this.toString();

      if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {
        // eslint-disable-next-line no-param-reassign
        position = subjectString.length;
      } // eslint-disable-next-line no-param-reassign


      position -= searchString.length;
      var lastIndex = subjectString.lastIndexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    };
  }
})();



/**
 * This list should be kept in sync with typings/jsx-interfaces.d.ts
 *
 * This list provides a map of global property to attribute names
 * where the attribute name is used for both key and value if no property
 * exists. We start with the list of global attributes found here:
 * https://html.spec.whatwg.org/multipage/dom.html#global-attributes
 * and check those against the Element and HTMLElement specs to determine
 * the property name if different:
 * https://dom.spec.whatwg.org/#interface-element
 * https://html.spec.whatwg.org/multipage/dom.html#htmlelement
 * This list is not exhaustive of all Element and HTMLElement properties.
 * @ignore
 */
// eslint-disable-next-line no-unused-vars
var _GLOBAL_PROPS = {
  accessKey: 'accesskey',
  autocapitalize: 'autocapitalize',
  autofocus: 'autofocus',
  class: 'class',
  // We support class instead of className for JSX
  contentEditable: 'contenteditable',
  dir: 'dir',
  draggable: 'draggable',
  enterKeyHint: 'enterkeyhint',
  hidden: 'hidden',
  id: 'id',
  inputMode: 'inputmode',
  is: 'is',
  itemid: 'itemid',
  itemprop: 'itemprop',
  itemref: 'itemref',
  itemscope: 'itemscope',
  itemtype: 'itemtype',
  lang: 'lang',
  nonce: 'nonce',
  role: 'role',
  slot: 'slot',
  spellcheck: 'spellcheck',
  style: 'style',
  tabIndex: 'tabindex',
  title: 'title',
  translate: 'translate'
};
/**
 * This map includes property to attribute names for
 * all native HTML elements where the two differ.
 * This list should only be manually populated for attributes belonging to
 * *subclasses* of HTMLElement.
 * @ignore
 */
// eslint-disable-next-line no-unused-vars

var _NATIVE_PROPS = {
  acceptCharset: 'accept-charset',
  allowFullscreen: 'allowfullscreen',
  allowPaymentRequest: 'allowpaymentrequest',
  colSpan: 'colspan',
  crossOrigin: 'crossorigin',
  dateTime: 'datetime',
  dirName: 'dirname',
  encoding: 'enctype',
  formAction: 'formaction',
  formEnctype: 'formenctype',
  formMethod: 'formmethod',
  formNoValidate: 'formnovalidate',
  formTarget: 'formtarget',
  for: 'for',
  // We support for instead of htmlFor for JSX
  httpEquiv: 'http-equiv',
  imageSizes: 'imagesizes',
  imageSrcset: 'imagesrcset',
  inputMode: 'inputmode',
  isMap: 'ismap',
  maxLength: 'maxlength',
  minLength: 'minlength',
  noModule: 'nomodule',
  noValidate: 'novalidate',
  readOnly: 'readonly',
  referrerPolicy: 'referrerpolicy',
  rowSpan: 'rowspan',
  useMap: 'usemap'
};



/* jslint browser: true*/

/**
 * @ojtsignore
 * @class oj.AgentUtils
 * @classdesc Utilities for qualifying the user agent string.
 * @public
 * @ignore
 */
oj.AgentUtils = function () {};
/**
 * Identity of the target browser.
 * @enum {string}
 * @public
 * @memberof oj.AgentUtils
 */


oj.AgentUtils.BROWSER = {
  IE: 'ie',
  FIREFOX: 'firefox',
  SAFARI: 'safari',
  CHROME: 'chrome',
  EDGE: 'edge',
  EDGE_CHROMIUM: 'edge-chromium',
  UNKNOWN: 'unknown'
};
/**
 * Browser layout engine identity.
 * @enum {string}
 * @public
 * @memberof oj.AgentUtils
 */

oj.AgentUtils.ENGINE = {
  TRIDENT: 'trident',
  WEBKIT: 'webkit',
  GECKO: 'gecko',
  BLINK: 'blink',
  EDGE_HTML: 'edgehtml',
  UNKNOWN: 'unknown'
};
/**
 * Operating system identity.
 * @enum {string}
 * @public
 * @memberof oj.AgentUtils
 */

oj.AgentUtils.OS = {
  WINDOWS: 'Windows',
  SOLARIS: 'Solaris',
  MAC: 'Mac',
  UNKNOWN: 'Unknown',
  ANDROID: 'Android',
  IOS: 'IOS',
  WINDOWSPHONE: 'WindowsPhone',
  LINUX: 'Linux'
};
/**
 * Device type identity.
 * @enum {string}
 * @public
 * @memberof oj.AgentUtils
 */

oj.AgentUtils.DEVICETYPE = {
  PHONE: 'phone',
  TABLET: 'tablet',
  OTHERS: 'others'
};
/**
 * Parses the browser user agent string determining what browser and layout engine
 * is being used.
 *
 * @param {Object|null|string=} userAgent a specific agent string but defaults to navigator userAgent if not provided
 * @return {{os: oj.AgentUtils.OS, browser: oj.AgentUtils.BROWSER, browserVersion: number, deviceType: oj.AgentUtils.DEVICETYPE,
 *          engine: oj.AgentUtils.ENGINE, engineVersion: number, hashCode: number}}
 * @public
 * @memberof oj.AgentUtils
 */

oj.AgentUtils.getAgentInfo = function (userAgent) {
  if (oj.StringUtils.isEmptyOrUndefined(userAgent)) {
    // eslint-disable-next-line no-param-reassign
    userAgent = navigator.userAgent;
  } // eslint-disable-next-line no-param-reassign


  userAgent = userAgent.toLowerCase();
  /** @type {number} */

  var hashCode = oj.StringUtils.hashCode(userAgent);
  var currAgentInfo = oj.AgentUtils._currAgentInfo;

  if (currAgentInfo && currAgentInfo.hashCode === hashCode) {
    return {
      os: currAgentInfo.os,
      browser: currAgentInfo.browser,
      browserVersion: currAgentInfo.browserVersion,
      deviceType: currAgentInfo.deviceType,
      engine: currAgentInfo.engine,
      engineVersion: currAgentInfo.engineVersion,
      hashCode: currAgentInfo.hashCode
    };
  }
  /** @type {oj.AgentUtils.OS} */


  var os = oj.AgentUtils.OS.UNKNOWN;
  /** @type {oj.AgentUtils.BROWSER} */

  var browser = oj.AgentUtils.BROWSER.UNKNOWN;
  /** @type {number} */

  var browserVersion = 0;
  /** @type {oj.AgentUtils.DEVICETYPE} */

  var deviceType = oj.AgentUtils.DEVICETYPE.OTHERS;
  /** @type {oj.AgentUtils.ENGINE} */

  var engine = oj.AgentUtils.ENGINE.UNKNOWN;
  /** @type {number} */

  var engineVersion = 0;

  if (userAgent.indexOf('iphone') > -1 || userAgent.indexOf('ipad') > -1) {
    os = oj.AgentUtils.OS.IOS;
  } else if (userAgent.indexOf('mac') > -1) {
    os = oj.AgentUtils.OS.MAC;
  } else if (userAgent.indexOf('sunos') > -1) {
    os = oj.AgentUtils.OS.SOLARIS;
  } else if (userAgent.indexOf('android') > -1) {
    os = oj.AgentUtils.OS.ANDROID;
  } else if (userAgent.indexOf('linux') > -1) {
    os = oj.AgentUtils.OS.LINUX;
  } else if (userAgent.indexOf('windows phone') > -1) {
    os = oj.AgentUtils.OS.WINDOWSPHONE;
  } else if (userAgent.indexOf('win') > -1) {
    os = oj.AgentUtils.OS.WINDOWS;
  }

  if (os === oj.AgentUtils.OS.ANDROID) {
    // This works for Chrome, Firefox, and Edge on Android, even though only Chrome is officially supported.
    // This also works for Edge on Windows 10 Mobile, which announces itself as android-compatible user agent.
    deviceType = userAgent.indexOf('mobile') > -1 ? oj.AgentUtils.DEVICETYPE.PHONE : oj.AgentUtils.DEVICETYPE.TABLET;
  } else if (os === oj.AgentUtils.OS.IOS) {
    // This works for Safari, Chrome, Firefox, and Edge on iOS, even though only Safari is officially supported.
    deviceType = userAgent.indexOf('iphone') > -1 ? oj.AgentUtils.DEVICETYPE.PHONE : oj.AgentUtils.DEVICETYPE.TABLET;
  }

  if (userAgent.indexOf('msie') > -1) {
    browser = oj.AgentUtils.BROWSER.IE;
    browserVersion = oj.AgentUtils._parseFloatVersion(userAgent, /msie (\d+[.]\d+)/);

    if (userAgent.indexOf('trident')) {
      engine = oj.AgentUtils.ENGINE.TRIDENT;
      engineVersion = oj.AgentUtils._parseFloatVersion(userAgent, /trident\/(\d+[.]\d+)/);
    }
  } else if (userAgent.indexOf('trident') > -1) {
    browser = oj.AgentUtils.BROWSER.IE;
    browserVersion = oj.AgentUtils._parseFloatVersion(userAgent, /rv:(\d+[.]\d+)/);

    if (userAgent.indexOf('trident')) {
      engine = oj.AgentUtils.ENGINE.TRIDENT;
      engineVersion = oj.AgentUtils._parseFloatVersion(userAgent, /trident\/(\d+[.]\d+)/);
    }
  } else if (userAgent.indexOf('edge') > -1) {
    browser = oj.AgentUtils.BROWSER.EDGE;
    engineVersion = oj.AgentUtils._parseFloatVersion(userAgent, /edge\/(\d+[.]\d+)/);
    browserVersion = engineVersion;
    engine = oj.AgentUtils.ENGINE.EDGE_HTML;
  } else if (userAgent.indexOf('edg') > -1) {
    browser = oj.AgentUtils.BROWSER.EDGE_CHROMIUM;
    browserVersion = oj.AgentUtils._parseFloatVersion(userAgent, /edg\/(\d+[.]\d+)/);
    engine = oj.AgentUtils.ENGINE.BLINK;
    engineVersion = browserVersion;
  } else if (userAgent.indexOf('chrome') > -1) {
    browser = oj.AgentUtils.BROWSER.CHROME;
    browserVersion = oj.AgentUtils._parseFloatVersion(userAgent, /chrome\/(\d+[.]\d+)/);

    if (browserVersion >= 28) {
      engine = oj.AgentUtils.ENGINE.BLINK;
      engineVersion = browserVersion;
    } else {
      engine = oj.AgentUtils.ENGINE.WEBKIT;
      engineVersion = oj.AgentUtils._parseFloatVersion(userAgent, /applewebkit\/(\d+[.]\d+)/);
    }
  } else if (userAgent.indexOf('safari') > -1) {
    browser = oj.AgentUtils.BROWSER.SAFARI;
    browserVersion = oj.AgentUtils._parseFloatVersion(userAgent, /version\/(\d+[.]\d+)/);
    engine = oj.AgentUtils.ENGINE.WEBKIT;
    engineVersion = oj.AgentUtils._parseFloatVersion(userAgent, /applewebkit\/(\d+[.]\d+)/);
  } else if (userAgent.indexOf('firefox') > -1) {
    browser = oj.AgentUtils.BROWSER.FIREFOX;
    browserVersion = oj.AgentUtils._parseFloatVersion(userAgent, /rv:(\d+[.]\d+)/);
    engine = oj.AgentUtils.ENGINE.GECKO;
    engineVersion = oj.AgentUtils._parseFloatVersion(userAgent, /gecko\/(\d+)/);
  }

  currAgentInfo = {
    hashCode: hashCode,
    os: os,
    browser: browser,
    browserVersion: browserVersion,
    deviceType: deviceType,
    engine: engine,
    engineVersion: engineVersion
  };
  oj.AgentUtils._currAgentInfo = currAgentInfo;
  return {
    os: currAgentInfo.os,
    browser: currAgentInfo.browser,
    browserVersion: currAgentInfo.browserVersion,
    deviceType: currAgentInfo.deviceType,
    engine: currAgentInfo.engine,
    engineVersion: currAgentInfo.engineVersion,
    hashCode: currAgentInfo.hashCode
  };
};
/**
 * @param {string!} userAgent
 * @param {RegExp!} versionNumberPattern
 * @return {number}
 * @private
 * @memberof oj.AgentUtils
 */


oj.AgentUtils._parseFloatVersion = function (userAgent, versionNumberPattern) {
  var matches = userAgent.match(versionNumberPattern);

  if (matches) {
    var versionString = matches[1];

    if (versionString) {
      return parseFloat(versionString);
    }
  }

  return 0;
};



/* global _GLOBAL_PROPS:false,_NATIVE_PROPS:false */
(function () {
  // Checks that a string either starts with 'array' or contains '|array'
  var _ARRAY_TYPE_EXP = /(^array)|(\|array)/; // Checks that a string either starts with 'object' or contains '|object'

  var _OBJ_TYPE_EXP = /(^object)|(\|object)/;
  var _ARRAY_VALUE_EXP = /^\s*\[[^]*\]\s*$/;
  var _OBJ_VALUE_EXP = /^\s*\{[^]*\}\s*$/; // Check for {{..}} and [[..]] at the beginning of strings to avoid matching
  // any usages mid string

  var _ATTR_EXP = /^(?:\{\{)([^]+)(?:\}\})$/;
  var _ATTR_EXP_RO = /^(?:\[\[)([^]+)(?:\]\])$/;
  /**
   * This map includes attribute to property names for
   * all global attributes where the two differ.
   * @ignore
   */

  var _GLOBAL_ATTRS = {};
  Object.keys(_GLOBAL_PROPS).forEach(function (prop) {
    var attr = _GLOBAL_PROPS[prop];

    if (prop !== attr) {
      _GLOBAL_ATTRS[attr] = prop;
      _NATIVE_PROPS[prop] = attr;
    }
  });
  /**
   * @ignore
   * @private
   */

  oj.__AttributeUtils = {};
  /**
   * @ignore
   * @return {{expr: (null|string), downstreamOnly: boolean}}
   * @private
   */

  oj.__AttributeUtils.getExpressionInfo = function (attrValue) {
    var info = {};

    if (attrValue) {
      var trimmedVal = attrValue.trim();

      var exp = _ATTR_EXP.exec(trimmedVal);

      exp = exp ? exp[1] : null;

      if (!exp) {
        info.downstreamOnly = true;
        exp = _ATTR_EXP_RO.exec(trimmedVal);
        exp = exp ? exp[1] : null;
      }

      info.expr = exp;
    }

    return info;
  };
  /**
   * @ignore
   * @param {string} attr attribute name
   * @return {string} property name
   * @private
   */


  oj.__AttributeUtils.attributeToPropertyName = function (attr) {
    return attr.toLowerCase().replace(/-(.)/g, function (match, group1) {
      return group1.toUpperCase();
    });
  };
  /**
   * @ignore
   * @param {string} name property name
   * @return {string} attribute name
   * @private
   */


  oj.__AttributeUtils.propertyNameToAttribute = function (name) {
    return name.replace(/([A-Z])/g, function (match) {
      return "-".concat(match.toLowerCase());
    });
  };
  /**
   * @ignore
   * @param {string} type event type (e.g. ojBeforeExpand)
   * @return {string} event listener property name (e.g. onOjBeforeExpand)
   * @private
   */


  oj.__AttributeUtils.eventTypeToEventListenerProperty = function (type) {
    return 'on' + type.substr(0, 1).toUpperCase() + type.substr(1);
  };
  /**
   * @ignore
   * @param {string} property event listener property name (e.g. onOjBeforeExpand)
   * @return {string|null} event type (e.g. ojBeforeExpand)
   * @private
   */


  oj.__AttributeUtils.eventListenerPropertyToEventType = function (property) {
    if (/^on[A-Z]/.test(property)) {
      return property.substr(2, 1).toLowerCase() + property.substr(3);
    }

    return null;
  };
  /**
   * @ignore
   * @param {string} name property name (e.g. expanded)
   * @return {string} change event type (e.g. expandedChanged)
   * @private
   */


  oj.__AttributeUtils.propertyNameToChangeEventType = function (name) {
    return name + 'Changed';
  };
  /**
   * @ignore
   * @param {string} trigger event trigger (e.g. beforeExpand)
   * @return {string} event type (e.g. ojBeforeExpand)
   * @private
   */


  oj.__AttributeUtils.eventTriggerToEventType = function (trigger) {
    return 'oj' + trigger.substr(0, 1).toUpperCase() + trigger.substr(1);
  };
  /**
   * Parses attribute values to the specified metadata type. Throws
   * an error if the value cannot be parsed to the metadata type
   * or if no type was provided.
   * @ignore
   * @param {Element} elem The element whose value we are parsing
   * @param {string} attr attribute
   * @param {string} value attribute value
   * @param {string} type property type
   * @return {any} coerced value
   * @private
   */


  oj.__AttributeUtils.coerceValue = function (elem, attr, value, type) {
    var tagName = elem.tagName.toLowerCase();

    if (!type) {
      throw new Error("Unable to parse ".concat(attr, "='").concat(value, "' for ").concat(tagName, " with id '").concat(elem.id, "'.         This attribute only supports data bound values. Check the API doc for supported types"));
    } // We only support primitive types and JSON objects for coerced properties.
    // Generally, we support parsing of a single type except for Object|string or Array|string cases
    // defined in metadata.


    var typeLwr = type.toLowerCase(); // The below checks ignore the couble {{}} [[]] cases since expression checking occurs
    // before attribute value coercion
    // Tests to see if the value starts and ends with matched [...] ignoring whitespace

    var isValueArray = _ARRAY_VALUE_EXP.test(value); // Tests to see if the value starts and ends with matched {...} ignoring whitespace


    var isValueObj = _OBJ_VALUE_EXP.test(value);

    if (_ARRAY_TYPE_EXP.test(typeLwr) && isValueArray || _OBJ_TYPE_EXP.test(typeLwr) && isValueObj || typeLwr === 'any' && (isValueArray || isValueObj)) {
      try {
        return JSON.parse(value);
      } catch (ex) {
        throw new Error("Unable to parse ".concat(attr, "='").concat(value, "' for ").concat(tagName, " with id '").concat(elem.id, "'           to a JSON Object. Check the value for correct JSON syntax, e.g. double quoted strings. ").concat(ex));
      }
    } else if (typeLwr === 'boolean') {
      return oj.__AttributeUtils.coerceBooleanValue(elem, attr, value, type);
    } else if (typeLwr === 'number') {
      if (!isNaN(value)) {
        return Number(value);
      }
    } else if (typeLwr === 'any') {
      // The any type will return a string if not matched as an object or array in first check
      return value;
    } else {
      var typeAr = typeLwr.split('|').filter(function (item) {
        return item.trim() === 'string';
      });

      if (typeAr.length > 0) {
        return value;
      }
    }

    throw new Error("Unable to parse ".concat(attr, "='").concat(value, "' for ").concat(tagName, " with id '").concat(elem.id, "'       to a ").concat(type, "."));
  };
  /**
   * Parses boolean attribute values. Throws
   * an error if the value cannot be parsed.
   * @ignore
   * @param {Element} elem The element whose value we are parsing
   * @param {string} attr attribute
   * @param {string} value attribute value
   * @param {string} type property type
   * @return {boolean} coerced value
   * @private
   */


  oj.__AttributeUtils.coerceBooleanValue = function (elem, attr, value, type) {
    // Boolean attributes are considered true if the attribute is:
    // 1) Set to the empty string
    // 2) Present in the DOM without a value assignment
    // 3) Set to the 'true' string
    // 4) Set to the case-insensitive attribute name
    // Boolean values are considered false if set to the false string.
    // An error is thrown for all other values and the attribute value will not be set.
    if (value == null || value === 'true' || value === '' || value.toLowerCase() === attr) {
      return true;
    } else if (value === 'false') {
      return false;
    }

    throw new Error('Unable to parse ' + attr + "='" + value + "' for " + elem + ' with id ' + elem.id + ' to a ' + type + '.');
  };
  /**
  * Returns true if the given property name maps to a global attribute.
  * For global attributes with no property getter, this method will check
  * the attribute name and handle data- and aria- dash cases.
  * @param {string} prop The property name to check
  * @return {boolean}
  * @private
  * @ignore
  */


  oj.__AttributeUtils.isGlobalOrData = function (prop) {
    // TODO: watch out for performance of hasOwnProperty given how often we expect isGlobal to be called
    return Object.prototype.hasOwnProperty.call(_GLOBAL_PROPS, prop) || prop.startsWith('data-') || prop.startsWith('aria-');
  };
  /**
   * This method assumes that the given property name has already been confirmed to
   * be global and will return the attribute syntax or the original value which could be
   * the global attribute name that does not have a property equivalent, e.g.
   * data- or aria-.
   * @ignore
   * @param {string} prop The property name to check
   * @return {string}
   * @private
   */


  oj.__AttributeUtils.getGlobalAttrForProp = function (prop) {
    return _GLOBAL_PROPS[prop] || prop;
  };
  /**
   * This method assumes that the given attribute name has already been confirmed
   * to be global and will return the attribute syntax or the original value which could be
   * the global attribute name that does not have a property equivalent, e.g.
   * data- or aria-.
   * @ignore
   * @param {string} attr The attribute name to check
   * @return {string}
   * @private
   */


  oj.__AttributeUtils.getGlobalPropForAttr = function (attr) {
    return _GLOBAL_ATTRS[attr] || attr;
  };
  /**
   * This method assumes that the given attribute name has already been confirmed
   * to be come from a native HTML element and will return the attribute name if
   * different from the property name for any native HTML element or the original value.
   * @ignore
   * @param {string} prop The property name to check
   * @return {string}
   * @private
   */


  oj.__AttributeUtils.getNativeAttr = function (prop) {
    return _NATIVE_PROPS[prop] || prop;
  };

  var _UNIQUE_INCR = 0;
  var _UNIQUE = '_ojcustomelem';
  /**
   * Returns either the passed id or a unique string that can be used for
   * a custom element id.
   * @ignore
   * @param {string} id
   * @return {string}
   * @private
   */

  oj.__AttributeUtils.getUniqueId = function (id) {
    if (id) {
      return id;
    }

    var ret = _UNIQUE + _UNIQUE_INCR;
    _UNIQUE_INCR += 1;
    return ret;
  };
})();



/* global Promise:false Map:false */

/**
 * NOTE: When adding a new polyfill, please include a description of what the
 * polyfill is for, the source and any copyright info, along with the browsers
 * it is needed for.
 */
(function () {
  if (typeof window === 'undefined') {
    return;
  } // polyfill for Element.closest()


  if (window.Element && !Element.prototype.closest) {
    Element.prototype.closest = function (s) {
      var matches = (this.document || this.ownerDocument).querySelectorAll(s);
      var i;
      var el = this;

      do {
        // eslint-disable-line no-cond-assign
        i = matches.length;

        while (--i >= 0 && matches.item(i) !== el) {} // eslint-disable-line no-plusplus, no-empty

      } while (i < 0 && (el = el.parentElement)); // eslint-disable-line no-cond-assign


      return el;
    };
  }
})();

(function () {
  // Polyfill for addEventListener & removeEventListener in browsers
  // that do not support an options object. The polyfilled methods accept
  // an options object, extract the capture option and pass it on as useCapture

  /**
  * Detect if options object is supported by checking if
  * browser looks for passive option. Code taken from
  * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
  * under "Safely detecting option support"
  * @ignore
  * @return {boolean} true if option object is supported,
  * false otherwise
  */
  function browserSupportsOptionObject() {
    var supportsOptionsObject = false;

    try {
      var opts = Object.defineProperty({}, 'passive', {
        get: function get() {
          supportsOptionsObject = true;
        }
      });
      window.addEventListener('testPassive', null, opts);
      window.removeEventListener('testPassive', null, opts); // eslint-disable-next-line no-empty
    } catch (e) {}

    return supportsOptionsObject;
  }
  /**
   * If option is object, extract capture and pass on
   * as useCapture. Otherwise simply pass on useCapture
   * @ignore
   * @param {Object|boolean} option option object or useCapture
   * @return {boolean} value for useCapture
  */


  function getCaptureOption(option) {
    if (typeof option === 'boolean') {
      return option;
    }

    return option ? option.capture : false;
  }
  /**
   * Helper for creating polyfilled addEventListener
   * or removeEventListener
   * @ignore
   * @param {Function} native addEventlister or
   * removeEventListener
   * @return {Function} polyfilled addEventListenr or
   * removeEventListener that accepts either options
   * object or useCapture.
  */


  function polyfill(native) {
    /**
     * @ignore
     * @param {string} event
     * @param {Function} handler
     * @param {Object|boolean} option options object or useCapture
    */
    return function (event, handler, option) {
      return native.call(this, event, handler, getCaptureOption(option));
    };
  }

  if (typeof window !== 'undefined' && !browserSupportsOptionObject()) {
    var nativePrototype;

    if (window.EventTarget) {
      // modern browsers define addEventListener and
      // removeEventListener on EventTarget
      nativePrototype = EventTarget.prototype;
    } else if (window.Node) {
      // IE defines addEventListener and removeEventListener
      // on Node
      nativePrototype = Node.prototype;
    }

    if (nativePrototype) {
      nativePrototype.addEventListener = polyfill(nativePrototype.addEventListener);
      nativePrototype.removeEventListener = polyfill(nativePrototype.removeEventListener);
    }
  }
})();

(function () {
  /**
   * @license
   * Code taken from
   * https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/queueMicrotask
   * under "When queueMicrotask() isn't available".
   * @ignore
   */
  if (typeof window !== 'undefined' && typeof window.queueMicrotask !== 'function') {
    // check for window being undefined for WebWorker cases
    window.queueMicrotask = function (callback) {
      Promise.resolve().then(callback).catch(function (e) {
        setTimeout(function () {
          throw e;
        });
      });
    };
  }
})();
/* The custom element (webcomponents) support requires the native CustomEvent
 * object.  This polyfill provides CustomEvent implementation for browsers that
 * don't support it yet.
 */


(function () {
  if (typeof window === 'undefined') {
    return;
  } // defaultPrevented is broken in IE.
  // https://connect.microsoft.com/IE/feedback/details/790389/event-defaultprevented-returns-false-after-preventdefault-was-called


  var workingDefaultPrevented = function () {
    var e = document.createEvent('Event');
    e.initEvent('foo', true, true);
    e.preventDefault();
    return e.defaultPrevented;
  }();

  if (!workingDefaultPrevented) {
    var origPreventDefault = Event.prototype.preventDefault;

    Event.prototype.preventDefault = function () {
      if (!this.cancelable) {
        return;
      }

      origPreventDefault.call(this);
      Object.defineProperty(this, 'defaultPrevented', {
        get: function get() {
          return true;
        },
        configurable: true
      });
    };
  }

  if (typeof window.CustomEvent === 'function') {
    return;
  }

  function CustomEvent(event, params) {
    // eslint-disable-next-line no-param-reassign
    params = params || {
      bubbles: false,
      cancelable: false,
      detail: undefined
    };
    var evt = document.createEvent('CustomEvent');
    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
    return evt;
  }

  CustomEvent.prototype = Object.getPrototypeOf(new CustomEvent('bogusEvent'));
  window.CustomEvent = CustomEvent;
})();
/**
 * Polyfill FocusEvent constructor for IE.
 */


(function () {
  if (typeof window === 'undefined' || typeof window.FocusEvent === 'function') {
    return;
  } // Note that since we can only use initEvent, we don't have a way to
  // polyfill the optional param to specify a relatedTarget for the FocusEvent.


  function FocusEvent(type) {
    var evt = document.createEvent('FocusEvent');
    evt.initEvent(type, false, false);
    return evt;
  }

  FocusEvent.prototype = Object.getPrototypeOf(new FocusEvent('focus'));
  window.FocusEvent = FocusEvent;
})();
/* This polyfill implements a proposed Microsoft standard [1] for effective yielding.
 * With the setImmediate global function, developers can yield control flow to the
 * user agent before running script.  The yield is similar to the setTimeout function
 * in that it is evaluated in the macrotask queue.  However, the setTimeout often has
 * a minimum delay and is also subject to long delays when the browser is placed in the
 * background.  The setImmediate function implemented by this polyfill invokes the
 * callback in the "next-tick" after the current macrotask queue has been exhausted.
 *
 * [1] https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html
 *
 * The strategy for the polyfill implementation uses the window.postMessage API for
 * creating a context for calling the target function evaulated as a macrotask. This
 * plugin will not work in a webworker where the window object doesn't exist.
 */


(function () {
  if (typeof window === 'undefined' || window.setImmediate || !window.postMessage) {
    return;
  }

  var _setImmediateMap;

  var _setImmediateCounter;

  function _nextId() {
    if (isNaN(_setImmediateCounter)) {
      _setImmediateCounter = 0;
    }

    _setImmediateCounter += 1;
    return _setImmediateCounter;
  } // postMessage "message" event listener for the setImmediate impl


  function _nextTickHandler(event) {
    var data = event.data;

    if (!data || data.message !== 'oj-setImmediate') {
      return;
    }

    var id = data.id;

    var entry = _setImmediateMap.get(id);

    clearImmediateImpl(id);

    if (entry) {
      var callback = entry.callback;
      var args = entry.args;
      callback.apply(window, args);
    }
  }

  function setImmediateImpl() {
    var callback = arguments[0];
    var slice = Array.prototype.slice;
    var args = slice.call(arguments, 1);
    oj.Assert.assertFunction(callback);

    var id = _nextId();

    if (!_setImmediateMap) {
      _setImmediateMap = new Map();
    }

    _setImmediateMap.set(id, {
      callback: callback,
      args: args
    });

    if (_setImmediateMap.size === 1) {
      window.addEventListener('message', _nextTickHandler);
    }

    window.postMessage({
      id: id,
      message: 'oj-setImmediate'
    }, '*');
    return id;
  }

  function clearImmediateImpl(id) {
    if (!_setImmediateMap) {
      return;
    }

    _setImmediateMap.delete(id);

    if (_setImmediateMap.size < 1) {
      window.removeEventListener('message', _nextTickHandler);
      _setImmediateMap = null;
    }
  }

  window.setImmediate = setImmediateImpl;
  window.clearImmediate = clearImmediateImpl;
})();

(function () {
  if (typeof window === 'undefined') {
    return;
  }

  if (window.Symbol) {
    if (!window.Symbol.asyncIterator) {
      window.Symbol.asyncIterator = 'asyncIterator';
    }

    if (!window.Symbol.iterator) {
      window.Symbol.iterator = 'iterator';
    }
  } else {
    window.Symbol = {};
    window.Symbol.asyncIterator = 'asyncIterator';
    window.Symbol.iterator = 'iterator';
  }
})();

(function () {
  if (typeof window === 'undefined') {
    return;
  }

  if (new window.Set([0]).size === 0) {
    var NativeSet = window.Set; // eslint-disable-next-line no-inner-declarations

    function _Set(iterable) {
      var set = new NativeSet();

      if (iterable) {
        iterable.forEach(set.add, set);
      }

      return set;
    }

    _Set.prototype = NativeSet.prototype; // eslint-disable-next-line no-extend-native

    _Set.prototype.constructor = _Set;
    window.Set = _Set;
  }
})();

(function () {
  if (typeof window === 'undefined') {
    return;
  } // IE11 supports Array.forEach


  if (window.NodeList && !NodeList.prototype.forEach) {
    NodeList.prototype.forEach = Array.prototype.forEach;
  }

  if (window.DOMTokenList && !DOMTokenList.prototype.forEach) {
    DOMTokenList.prototype.forEach = Array.prototype.forEach;
  }
})();
/**
 * Node.isConnected polyfill for IE and EdgeHTML
 * 2020-02-04
 * By Eli Grey, https://eligrey.com
 * Public domain.
 * From: https://developer.mozilla.org/en-US/docs/Web/API/Node/isConnected
 */


(function () {
  if (typeof window === 'undefined' || window.Node === 'undefined') {
    return;
  }

  if (!('isConnected' in Node.prototype)) {
    Object.defineProperty(Node.prototype, 'isConnected', {
      get: function get() {
        return !this.ownerDocument || // eslint-disable-next-line no-bitwise
        !(this.ownerDocument.compareDocumentPosition(this) & this.DOCUMENT_POSITION_DISCONNECTED);
      }
    });
  }
})();



/* global Set:false */

/**
 * Element utilities.
 * @class oj.ElementUtils
 * @ignore
 */
oj.ElementUtils = {
  /**
   * Custom element name check
   * @param {String} localName Element name
   * @return {boolean}
   * @ignore
   */
  isValidCustomElementName: function isValidCustomElementName(localName) {
    var reservedTagList = new Set(['annotation-xml', 'color-profile', 'font-face', 'font-face-src', 'font-face-uri', 'font-face-format', 'font-face-name', 'missing-glyph']);
    var reserved = reservedTagList.has(localName);
    var validForm = /^[a-z][.0-9_a-z]*-[-.0-9_a-z]*$/.test(localName);
    return !reserved && validForm && !localName.startsWith('oj-bind-', 0);
  }
};



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true*/

/**
 * @export
 * @class oj.EventSource
 * @classdesc Object which supports subscribing to and firing events
 * @constructor
 * @final
 * @since 1.1
 * @ojdeprecated {since: '5.0.0', description: 'Use DataProvider instead.'}
 */
oj.EventSource = function () {
  this.Init();
}; // Subclass from oj.Object


oj.Object.createSubclass(oj.EventSource, oj.Object, 'oj.EventSource');
/**
 * Initializes the instance.
 * @export
 */

oj.EventSource.prototype.Init = function () {
  this._eventHandlers = [];
  oj.EventSource.superclass.Init.call(this);
};
/**
 * Attach an event handler.
 * <p>Application can call this if it wants to be notified of an event.  It can call the <code class="prettyprint">off</code> method to detach the handler when it no longer wants to be notified.</p>
 * @param {string} eventType eventType
 * @param {function(Object)} eventHandler event handler function
 * @return {void}
 * @memberof oj.EventSource
 * @export
 */


oj.EventSource.prototype.on = function (eventType, eventHandler) {
  var foundEventHandler = false;

  for (var i = 0; i < this._eventHandlers.length; i++) {
    if (this._eventHandlers[i].eventType === eventType && this._eventHandlers[i].eventHandlerFunc === eventHandler) {
      foundEventHandler = true;
      break;
    }
  }

  if (!foundEventHandler) {
    this._eventHandlers.push({
      eventType: eventType,
      eventHandlerFunc: eventHandler
    });
  }
};
/**
 * Detach an event handler.
 * <p>Application can call this if it no longer wants to be notified of an event that it has attached an handler to using the <code class="prettyprint">on</code> method.</p>
 * @param {string} eventType eventType
 * @param {function(Object)} eventHandler event handler function
 * @return {void}
 * @memberof oj.EventSource
 * @export
 */


oj.EventSource.prototype.off = function (eventType, eventHandler) {
  for (var i = this._eventHandlers.length - 1; i >= 0; i--) {
    if (this._eventHandlers[i].eventType === eventType && this._eventHandlers[i].eventHandlerFunc === eventHandler) {
      this._eventHandlers.splice(i, 1);

      break;
    }
  }
};
/**
 * Handle the event
 * @param {string} eventType  event type
 * @param {Object} event  event
 * @return {boolean} Returns false if event is cancelled
 * @memberof oj.EventSource
 * @export
 */
// eslint-disable-next-line no-unused-vars


oj.EventSource.prototype.handleEvent = function (eventType, event) {
  var returnValue;

  for (var i = 0; i < this._eventHandlers.length; i++) {
    var eventHandler = this._eventHandlers[i];

    if (eventHandler.eventType === eventType) {
      returnValue = eventHandler.eventHandlerFunc.apply(this, Array.prototype.slice.call(arguments).slice(1));

      if (returnValue === false) {
        // event cancelled
        return false;
      }
    }
  }

  return true;
};



/**
 * Key utilities.
 * @class oj.KeyUtils
 * @export
 * @ignore
 */
oj.KeyUtils = {};
/**
 * Determine whether the two keys specified are considered equal.
 *
 * @param {any} key1 first key to compare
 * @param {any} key2 second key to compare
 * @returns {boolean} true if the keys are considered the same, false otherwise.
 * @export
 * @memberof oj.KeyUtils
 */

oj.KeyUtils.equals = function (key1, key2) {
  // algorithm for key equality:
  // if the keys are of type primitive, then do === comparison
  // if the keys are object, then do deep comparison of properties
  // for now, this is the same as compareValues, but this allows us to diverge in the future
  // ex: generate hash with key and compare hash value instead
  return oj.Object.compareValues(key1, key2);
};



/* global _scope:false, Logger:false */

/**
 * @private
 */
var _checkpointManagerDelegate = _scope.__ojCheckpointManager;
/**
 * Global Checkpoint Manager Instance
 * @const
 * @export
 * @ignore
 */

oj.CHECKPOINT_MANAGER = {};
/**
 * Starts a checkpoint
 * @param {!string} name - the name of the checkpoint
 * @param {string=} description - optional description of the checkpoint
 * @export
 * @memberof! oj.CHECKPOINT_MANAGER
 */

oj.CHECKPOINT_MANAGER.startCheckpoint = function (name, description) {
  if (_checkpointManagerDelegate) {
    _checkpointManagerDelegate.startCheckpoint(name, description);
  }
};
/**
 * Ends a checkpoint
 * @param {!string} name - the name of the checkpoint
 * @export
 * @memberof! oj.CHECKPOINT_MANAGER
 */


oj.CHECKPOINT_MANAGER.endCheckpoint = function (name) {
  if (_checkpointManagerDelegate) {
    _checkpointManagerDelegate.endCheckpoint(name);
  }
};
/**
 * Retrieves a checkpoint record for a given name
 * @param {!string} name - the name of the checkpoint
 * @return {undefined|{start: number, end: number, duration: number, name: {string}, description: (string|undefined)}}
 * @export
 * @memberof! oj.CHECKPOINT_MANAGER
 */


oj.CHECKPOINT_MANAGER.getRecord = function (name) {
  return _checkpointManagerDelegate ? _checkpointManagerDelegate.getRecord(name) : undefined;
};
/**
 * Retrieves all checkpoint records matching a regular expression
 * @param {!RegExp} regexp - regular expression to match.
 * @return Array.{{start: number, end: number, duration: number, name: {string}, description: (string|undefined)}}
 * @export
 * @memberof! oj.CHECKPOINT_MANAGER
 */


oj.CHECKPOINT_MANAGER.matchRecords = function (regexp) {
  return _checkpointManagerDelegate ? _checkpointManagerDelegate.matchRecords(regexp) : [];
};
/**
 * Dumps matched records into oj.Logger
 * @param {!RegExp} regexp - regular expression for the records to dump.
 * @export
 * @memberof! oj.CHECKPOINT_MANAGER
 */


oj.CHECKPOINT_MANAGER.dump = function (regexp) {
  Logger.info(function () {
    var logMsg = 'Checkpoint Records:';
    var records = oj.CHECKPOINT_MANAGER.matchRecords(regexp);

    for (var i = 0; i < records.length; i++) {
      var record = records[i];
      logMsg = logMsg + '\n' + record.name;
      var desc = record.description;

      if (desc != null) {
        logMsg = logMsg + ' (' + desc + ')';
      }

      logMsg += ':\n';
      logMsg = logMsg + 'start: ' + record.start + '\tduration: ' + record.duration;
    }

    return logMsg;
  });
};

;return oj;
});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojcontext',['ojs/ojcore-base', 'ojs/ojlogger' ], function(oj, Logger)
{
  "use strict";


/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* global Promise:false, Map:false, Logger:false */

/**
 * <p>The purpose of the BusyContext API is to accommodate sequential dependencies of asynchronous
 * operations. A common use cases defining the API is for automation testing (qunit and webdriver).
 * Automation test developers can use this API to wait until components finish animation effects
 * or data fetch before trying to interact with components. The BusyContext is not limited to
 * test automation developers usages. It is also needed by page developers for waiting on run-time
 * operation readiness.</p>
 *
 * The Busy Context API will wait until busy states have resolved or a timeout period has elapsed.
 * There are several primary wait scenarios:
 * <ol>
 *   <li>Component creation and page bindings applied.</li>
 *   <li>Components that implement animation effects.</li>
 *   <li>Components that must fetch data from a REST endpoint.</li>
 *   <li>General wait conditions that are not specific to the Jet framework. The customer might
 *       choose to register some busy condition associated with application domain logic such
 *       as REST endpoints.</li>
 *   <li>Wait until the bootstrap of the page has completed - jet libraries loaded via requireJS.</li>
 * </ol>
 *
 * <p>The first step for waiting on a busy context is to determine what conditions are of interest
 *   to wait on. The granularity of a busy context can be scoped for the entirety of the page or
 *   for a specific DOM element. Busy contexts have hierarchical dependencies mirroring the
 *   document's DOM structure with the root being the page context. Depending on the particular
 *   scenario, developers might need to target one of the following busy context scopes:</p>
 * <ul>
 *   <li>Scoped for the Page - Automation test developers will more commonly choose the page busy
 *     context. This context represents the page as a whole. Automation developers commonly need
 *     to wait until the page is fully loaded before starting automation. More commonly, automation
 *     developers are interesting in testing the functionality of an application having multiple
 *     JET components versus just a single component.
 *
 *     <pre class="prettyprint">
 *     <code>
 *     var busyContext = oj.Context.getPageContext().getBusyContext();
 *     </code></pre>
 *
 *   </li>
 *   <li>Scoped for the nearest DOM Element - Application developers sometime need a mechanism to
 *     wait until a specific component operation has complete. For example, it might be desirable
 *     to wait until a component has been created and bindings applied before setting a property or
 *     calling a method on the component. Another scenario, waiting for a popup to finish
 *     open or close animation before initiating the next action in their application flow.
 *     For this problem space developers would need to obtain a busy context scoped for a DOM node.
 *     The "data-oj-context" marker attribute is used to define a busy context for a dom subtree.
 *
 *     <pre class="prettyprint">
 *     <code>
 *     <!-- subtree assigned a marker 'data-oj-context' attribute -->
 *     &lt;div id="mycontext" data-oj-context&gt;
 *        ...
 *        &lt;!-- JET content --&gt;
 *        ...
 *     &lt;/div&gt;
 *
 *     var node = document.querySelector("#mycontext");
 *     var busyContext = oj.Context.getContext(node).getBusyContext();
 *     busyContext.whenReady().then(function ()
 *     {
 *       var component = document.querySelector("#myInput");
 *       component.value = "foo";
 *       component.validate().then(function (isValid)
 *       {
 *         if (!isValid)
 *           component.value = "foobar";
 *       });
 *     });
 *     </code></pre>
 *
 *   </li>
 * </ul>
 *
 * The BusyContext API utilizes {@link Logger.LEVEL_LOG} to log detail busy state activity.
 * <pre class="prettyprint">
 * <code>
 *  Logger.option("level", Logger.LEVEL_LOG);
 * </code></pre>
 *
 * <b>This constructor should never be invoked by the application code directly.</b>
 * @hideconstructor
 * @param {Element=} hostNode DOM element associated with this busy context
 * @export
 * @constructor oj.BusyContext
 * @ojtsmodule
 * @ojtsnoexport
 * @ojtsexportastype Context
 * @since 2.1.0
 * @classdesc Framework service for querying the busy state of components on the page.
 */
oj.BusyContext = function (hostNode) {
  this.Init(hostNode);
};

oj.Object.createSubclass(oj.BusyContext, oj.Object, 'oj.BusyContext');
/**
 * see oj.BusyContext#setDefaultTimeout
 * @type {number}
 * @ignore
 * @private
 */

oj.BusyContext._defaultTimeout = Number.NaN;
/**
 * Sets a default for the optional <code>timeout</code> argument of the {@link oj.BusyContext#whenReady}
 * for all BusyContext instances. The default value will be implicitly used if a timeout argument is not
 * provided.
 *
 * @export
 * @see oj.BusyContext#whenReady
 * @since 3.1.0
 * @memberof oj.BusyContext
 * @method setDefaultTimeout
 * @param {number} timeout in milliseconds
 * @ojdeprecated {since: '6.0.0', description: 'Use oj.Context.setBusyContextDefaultTimeout instead.'}
 * @return {undefined}
 */

oj.BusyContext.setDefaultTimeout = function (timeout) {
  if (!isNaN(timeout)) {
    oj.BusyContext._defaultTimeout = timeout;
  }
};
/**
 * @param {Element=} hostNode DOM element associated with this busy context
 * @instance
 * @protected
 */


oj.BusyContext.prototype.Init = function (hostNode) {
  oj.BusyContext.superclass.Init.call(this);
  this._hostNode = hostNode;
  /**
   * Busy states cache.
   *
   * @type {?}
   * @ignore
   * @private
   */

  this._statesMap = new Map();
  /**
   * Coordinates resolution of the master when ready promise with one or more slave
   * when ready promises having a timeout period.
   *
   * @type {Object}
   * @ignore
   * @private
   */

  this._mediator = {
    /**
     * Returns a master primise that will resolve when all busy states have been resolved.
     *
     * @returns {Promise}
     * @ignore
     * @private
     */
    getMasterWhenReadyPromise: function getMasterWhenReadyPromise() {
      if (!this._masterWhenReadyPromise) {
        this._masterWhenReadyPromise = new Promise(this._captureWhenReadyPromiseResolver.bind(this));
      }

      return this._masterWhenReadyPromise;
    },

    /**
     * Triggers resolution of the master promise and clears all timeouts associated with slave
     * when ready promises.
     *
     * @returns {void}
     * @ignore
     * @private
     */
    resolveMasterWhenReadyPromise: function resolveMasterWhenReadyPromise() {
      if (this._masterWhenReadyPromiseResolver) {
        this._masterWhenReadyPromiseResolver(true);
      }

      this._masterWhenReadyPromise = null;
      this._masterWhenReadyPromiseResolver = null;
      this._masterWhenReadyPromiseRejecter = null;
    },

    /**
     * Triggers rejections of the master promise.
     * @param {Object=} error
     * @returns {void}
     * @ignore
     * @private
     */
    rejectMasterWhenReadyPromise: function rejectMasterWhenReadyPromise(error) {
      if (this._masterWhenReadyPromiseRejecter) {
        this._masterWhenReadyPromiseRejecter(error);
      }

      this._masterWhenReadyPromise = null;
      this._masterWhenReadyPromiseRejecter = null;
      this._masterWhenReadyPromiseResolver = null;
    },

    /**
     * Returns a promise that will resolve when the master promise resolves or reject when
     * the slave timeout promise rejects.
     *
     * @param {Promise} master
     * @param {Function} generateErrorCallback
     * @param {number} timeout
     * @returns {Promise}
     * @ignore
     * @private
     */
    getSlaveTimeoutPromise: function getSlaveTimeoutPromise(master, generateErrorCallback, timeout) {
      var timer;
      var slaveTimeoutPromise = new Promise(function (resolve, reject) {
        timer = window.setTimeout(function () {
          reject(generateErrorCallback());
        }, timeout);
      });

      this._slaveTimeoutPromiseTimers.push(timer); // When the master promise is resolved, all timers may be cleared


      return Promise.race([master, slaveTimeoutPromise]).then(this._clearAllSlaveTimeouts.bind(this));
    },

    /**
     * @private
     * @ignore
     * @return {Promise} resolves on the next-tick using setImmediate.
     */
    getNextTickPromise: function getNextTickPromise() {
      if (!this._nextTickPromise) {
        this._nextTickPromise = new Promise(function (resolve) {
          window.setImmediate(function () {
            this._nextTickPromise = null;
            resolve(true);
          }.bind(this));
        }.bind(this));
      }

      return this._nextTickPromise;
    },

    /**
     * Clears all window timeout timeers that are slave when ready promises.
     *
     * @returns {boolean}
     * @ignore
     * @private
     */
    _clearAllSlaveTimeouts: function _clearAllSlaveTimeouts() {
      var slaveTimeoutPromiseTimers = this._slaveTimeoutPromiseTimers;
      this._slaveTimeoutPromiseTimers = [];

      for (var i = 0; i < slaveTimeoutPromiseTimers.length; i++) {
        window.clearTimeout(slaveTimeoutPromiseTimers[i]);
      }

      return true;
    },

    /**
     * Promise executor function passed as the single master promise constructor.  Captures the
     * promise resolve callback function.  The resolve promise function will be called when all the
     * busy states have been removed.
     *
     * @param {Function} resolve
     * @param {Function} reject
     * @returns {void}
     * @ignore
     * @private
     */
    // eslint-disable-next-line no-unused-vars
    _captureWhenReadyPromiseResolver: function _captureWhenReadyPromiseResolver(resolve, reject) {
      this._masterWhenReadyPromiseResolver = resolve;
      this._masterWhenReadyPromiseRejecter = reject;
    },

    /**
     * Array of setTimeout timers that should be cancled when the busy state resolves.
     *
     * @type {Array.<number>}
     * @ignore
     * @private
     */
    _slaveTimeoutPromiseTimers: []
    /**
     * The master when ready promise that will resovle when all busy states resolve.
     *
     * @type {Promise|undefined}
     * @ignore
     * @private
     */
    // _masterWhenReadyPromise : undefined,

    /**
     * The resolve function of the masterWhenReadyPromise.
     *
     * @type {Function|undefined}
     * @ignore
     * @private
     */
    // _masterWhenReadyPromiseResolver : undefined,

    /**
    * The reject function of the masterWhenReadyPromise.
    *
    * @type {Function|undefined}
    * @ignore
    * @private
    */
    // _masterWhenReadyPromiseRejecter : undefined,

    /**
     * Promise evaluated next-tick.
     *
     * @type {Promise|undefined}
     * @ignore
     * @private
     */
    // _nextTickPromise : undefined

  };
};
/**
 * Logs the current registered busy states ordered acceding by the order they were added.
 * The cost of compiling the list is only made if the logger level is Logger.LEVEL_LOG.
 * @param {?} statesMap busy states
 * @returns {void}
 * @private
 */


oj.BusyContext._log = function (statesMap) {
  if (Logger.option('level') !== Logger.LEVEL_LOG) {
    return;
  }

  Logger.log('>> Busy states: %d', statesMap.size);

  var busyStates = oj.BusyContext._values(statesMap);

  if (busyStates.length > 0) {
    Logger.log(busyStates.join('\n'));
  }
};
/**
 * @param {?} statesMap busy states
 * @return {Array.<oj.BusyState>} Returns an array of busy states entries from the states map
 * @private
 */


oj.BusyContext._values = function (statesMap) {
  var busyStates = [];
  statesMap.forEach(function (value) {
    busyStates.push(value);
  });
  return busyStates;
};
/**
 * <p>Called by components or services performing a task that should be considered
 * in the overall busy state of the page. An example would be animation or fetching data.</p>
 *
 * Caveats:
 * <ul>
 *   <li>Busy context dependency relationships are determined at the point the first busy state
 *       is added.  If the DOM node is re-parented after a busy context was added, the context will
 *       maintain dependencies with any parent DOM contexts.</li>
 *   <li>The application logic creating busy states is responsible for ensuring these busy states
 *       are resolved. Busy states added internally by JET are automatically accounted for.
 *       The busy states added by the application logic must manage a reference to the resolve
 *       function associated with a busy state and it must be called to release the busy state.</li>
 * </ul>
 *
 * <pre class="prettyprint">
 * <code>// apply the marker attribute to the element
 * &lt;div id="context1" data-oj-context ... &gt;&lt;/&gt;
 * ...
 * ...
 * var context1 = document.querySelector("#context1");
 *
 * // obtain a busy context scoped for the target node
 * var busyContext1 = oj.Context.getContext(context1).getBusyContext();
 * // add a busy state to the target context
 * var options = {"description": "#context1 fetching data"};
 * var resolve = busyContext1.addBusyState(options);
 * ...
 * ...  // perform asynchronous operation that needs guarded by a busy state
 * ...
 * // resolve the busy state after the operation completes
 * resolve();
 * </code></pre>
 *
 * @since 2.1.0
 * @export
 * @memberof oj.BusyContext
 * @instance
 * @method addBusyState
 * @param {Object} options object that describes the busy state being registered.<br/>
 * @param {Object|function():string} options.description
 *         description: Option additional information of what is registering a busy state. Added to
 *                      logging and handling rejected status. Can be supplied as a Object or a
 *                      function.  If the type is an object the toString function needs to be
 *                      implemented.
 * @ojsignature [{target: "Type",
 *                value: "{
 *                         toString: ()=>string;
 *                         [propName: string]: any;
 *                       } | (() => string) | string",
 *                for: "options.description"}]
 * @returns {function():void} resolve function called by the registrant when the busy state completes.
 *                     The resultant function will throw an error if the busy state is no longer
 *                     registered.
 */


oj.BusyContext.prototype.addBusyState = function (options) {
  Logger.log("BusyContext.addBusyState: start scope='%s'", this._getDebugScope());
  var statesMap = this._statesMap;
  /** @type {oj.BusyState} */

  var busyState = new oj.BusyState(options[oj.BusyContext._DESCRIPTION]);
  Logger.log('>> ' + busyState);
  statesMap.set(busyState.id, busyState);

  this._addBusyStateToParent();

  Logger.log("BusyContext.addBusyState: end scope='%s'", this._getDebugScope());
  return this._removeBusyState.bind(this, busyState);
};
/**
 * Logs all active busy states to the {@link oj.Logger} at {Logger.LEVEL_INFO}.
 * <pre class="prettyprint">
 * <code>
 *  Logger.option("level", Logger.LEVEL_INFO);
 *  oj.Context.getPageContext().getBusyContext().dump("before popup open");
 * </code></pre>
 *
 * @export
 * @since 3.1.0
 * @memberof oj.BusyContext
 * @instance
 * @method dump
 * @param {string=} message optional text used to further denote a debugging point
 * @return {undefined}
 */


oj.BusyContext.prototype.dump = function (message) {
  Logger.info("BusyContext.dump: start scope='%s' %s", this._getDebugScope(), message || '');
  var statesMap = this._statesMap;
  Logger.info('>> Busy states: %d', statesMap.size);

  var busyStates = oj.BusyContext._values(statesMap);

  if (busyStates.length > 0) {
    Logger.info(busyStates.join('\n'));
  }

  Logger.info("BusyContext.dump: start scope='%s' %s", this._getDebugScope(), message || '');
};
/**
 * Returns an array of states representing the active busy states managed by the instance.
 *
 * @export
 * @since 3.1.0
 * @method getBusyStates
 * @memberof oj.BusyContext
 * @instance
 * @return {Array.<{id:string, description:string}>} active busy states managed by the context
 *         instance
 */


oj.BusyContext.prototype.getBusyStates = function () {
  var statesMap = this._statesMap;
  /** @type {?} */

  var busyStates = oj.BusyContext._values(statesMap);

  return busyStates;
};
/**
 * Forces all busy states per context instance to release.
 * Use with discretion - last course of action.
 *
 * @since 3.1.0
 * @method clear
 * @memberof oj.BusyContext
 * @instance
 * @export
 * @return {undefined}
 */


oj.BusyContext.prototype.clear = function () {
  Logger.log("BusyContext.clear: start scope='%s'", this._getDebugScope());
  var statesMap = this._statesMap;

  var busyStates = oj.BusyContext._values(statesMap);

  for (var i = 0; i < busyStates.length; i++) {
    /** @type {?} **/
    var busyState = busyStates[i];

    try {
      this._removeBusyState(busyState);
    } catch (e) {
      Logger.log('BusyContext.clear: %o', e);
    }

    Object.defineProperty(busyState, oj.BusyContext._OJ_RIP, {
      value: true,
      enumerable: false
    });
  }

  Logger.log("BusyContext.clear: end scope='%s'", this._getDebugScope());
};
/**
 * <p>Returns a Promise that will resolve when all registered busy states have completed or a maximum
 * timeout period has elapsed. The promise will be rejected if all the busy states are not resolved
 * within the timeout period. The busyness of the whenReady promsie is evaluated in the next-tick
 * of resolving a busy state.</p>
 *
 * "next-tick" is at the macrotask level. "whenReady" is waiting for the microtask queue to be exhausted,
 * yielding control flow to the user agent, before resolving busyness.
 *
 * @see oj.BusyContext#applicationBootstrapComplete
 * @since 2.1.0
 * @export
 * @memberof oj.BusyContext
 * @instance
 * @method whenReady
 * @param {number=} timeout "optional" maximum period in milliseconds the resultant promise
 *        will wait. Also see {@link oj.BusyContext.setDefaultTimeout}.
 * @returns {Promise.<boolean|Error>}
 */


oj.BusyContext.prototype.whenReady = function (timeout) {
  var debugScope = this._getDebugScope();

  Logger.log("BusyContext.whenReady: start, scope='%s', timeout=%d", debugScope, timeout);
  /** @type {?} */

  var statesMap = this._statesMap;
  var mediator = this._mediator;
  var nextTickPromise = mediator.getNextTickPromise();

  var bootstrapPromise = oj.BusyContext._BOOTSTRAP_MEDIATOR.whenReady();

  var promise = Promise.all([nextTickPromise, bootstrapPromise]).then(function () {
    Logger.log('BusyContext.whenReady: bootstrap mediator ready scope=%s', debugScope);

    try {
      // Since we are executing this code on 'next tick', it is safe to flush any JET throttled updates.
      // Doing so will allow us to take into account any busy states added in response to the pending updates
      oj.BusyContext._deliverThrottledUpdates();
    } catch (e) {
      Logger.error('Fatal exception delivering binding updates: %o', e);
      throw e;
    }

    if (statesMap.size === 0 && !this._waitingOnNextTickBusynessEval) {
      // no busy states, promise resolves immediately
      Logger.log('BusyContext.whenReady: resolved no busy states scope=%s', debugScope);
      return true;
    }

    Logger.log('BusyContext.whenReady: busy states returning master scope=%s', debugScope);
    return mediator.getMasterWhenReadyPromise();
  }.bind(this)); // if a timeout argument is not provided, check the default timeout

  if (isNaN(timeout) && !isNaN(oj.BusyContext._defaultTimeout)) {
    // eslint-disable-next-line no-param-reassign
    timeout = oj.BusyContext._defaultTimeout;
  }

  if (!isNaN(timeout)) {
    var handleTimeout = function handleTimeout() {
      var error;
      var expiredText = 'whenReady timeout of ' + timeout + 'ms expired ';

      oj.BusyContext._log(statesMap);

      var busyStates = oj.BusyContext._values(statesMap);

      if (!oj.BusyContext._BOOTSTRAP_MEDIATOR.isReady()) {
        error = new Error(expiredText + 'while the application is loading.' + ' Busy state enabled by setting the "window.oj_whenReady = true;" global variable.' + ' Application bootstrap busy state is released by calling' + ' "oj.Context.getPageContext().getBusyContext().applicationBootstrapComplete();".');
      } else {
        error = new Error(expiredText + 'with the following busy states: ' + busyStates.join(', '));
      }

      error.busyStates = busyStates;
      Logger.log("BusyContext.whenReady: rejected scope='%s'\n%s", debugScope, error.message);
      return error;
    };

    promise = mediator.getSlaveTimeoutPromise(promise, handleTimeout, timeout);
  }

  Logger.log("BusyContext.whenReady: end scope='%s'", this._getDebugScope());
  return promise;
};
/**
 * <p>Describes the busyness of the context. The busyness is evaluated in the "next-tick" of a busy
 * state being resolved, meaning the number of busy states doesn't necessarily equate to readiness.
 * The readiness is in sync with the {@link oj.BusyContext#whenReady} resultant promise resolution.</p>
 *
 * @see oj.BusyContext#getBusyStates
 * @since 2.1.0
 * @export
 * @memberof oj.BusyContext
 * @instance
 * @method isReady
 * @returns {boolean} <code>true</code> if the context is not busy
 */


oj.BusyContext.prototype.isReady = function () {
  Logger.log("BusyContext.isReady: start scope='%s'", this._getDebugScope());
  var rtn = false;

  if (oj.BusyContext._BOOTSTRAP_MEDIATOR.isReady() && !this._waitingOnNextTickBusynessEval) {
    var statesMap = this._statesMap;
    rtn = statesMap.size === 0;

    oj.BusyContext._log(statesMap);
  }

  Logger.log("BusyContext.isReady: end scope='%s'", this._getDebugScope());
  return rtn;
};
/**
 * @private
 * @param {oj.BusyState} busyState added busy state
 * @returns {void}
 * @throws {Error} Busy state has already been resolved
 */


oj.BusyContext.prototype._removeBusyState = function (busyState) {
  var debugScope = this._getDebugScope();

  Logger.log("BusyContext._removeBusyState: start scope='%s'", debugScope); // The BusyState object is passed here instead of just the generated id to provide a more
  // descriptive message when the busy state is removed twice. The description (if provided) of
  // the busy state will be captured in the error message.

  var statesMap = this._statesMap;

  if (busyState[oj.BusyContext._OJ_RIP]) {
    Logger.log('Busy state has been forcefully resolved via clear:\n' + busyState);
    return;
  } else if (!statesMap.delete(busyState.id)) {
    // quoted to make the closure compiler happy
    throw new Error('Busy state has already been resolved:\n' + busyState);
  }

  Logger.log('BusyContext._removeBusyState: resolving busy state:\n' + busyState);

  if (statesMap.size === 0 && !this._waitingOnNextTickBusynessEval) {
    // no more busy states; evaluate busyness in the next tick
    this._waitingOnNextTickBusynessEval = true;
    window.setImmediate(this._evalBusyness.bind(this));
  }

  Logger.log("BusyContext._removeBusyState: end scope='%s'", debugScope);
};
/**
 * Evaluates the busyness of the context.
 * @private
 */


oj.BusyContext.prototype._evalBusyness = function () {
  var debugScope = this._getDebugScope();

  Logger.log("BusyContext._evalBusyness: begin scope='%s'", debugScope);

  try {
    // Since we are executing this code on 'next tick', it is safe to flush any JET throttled updates.
    // Doing so will allow us to take into account any busy states added in response to the pending updates
    oj.BusyContext._deliverThrottledUpdates();
  } catch (e) {
    Logger.error('Fatal exception delivering binding updates: %o', e);

    this._mediator.rejectMasterWhenReadyPromise(e);

    this._waitingOnNextTickBusynessEval = false;
    return;
  }

  var statesMap = this._statesMap;
  var mediator = this._mediator; // "appears" the Edge promise invokes the resolve callback immediately after
  // resolving versus waiting next micro tick.  Toggle the flag here so if
  // isReady() is called from the promise resolve callback, it returns true.

  this._waitingOnNextTickBusynessEval = false;

  if (statesMap.size === 0) {
    Logger.log('BusyContext._evalBusyness: resolving whenReady promises');
    mediator.resolveMasterWhenReadyPromise();

    this._resolveBusyStateForParent();
  } else {
    oj.BusyContext._log(statesMap);
  }

  Logger.log("BusyContext._evalBusyness: end scope='%s'", debugScope);
};
/**
 * <p>This function should be invoke by application domain logic to indicate all application
 * libraries are loaded and bootstrap processes complete.  The assumed strategy is that the
 * application will set a single global variable "oj_whenReady" from a inline script from the
 * document header section indicating the {@link oj.BusyContext#whenReady}
 * should {@link oj.BusyContext#addBusyState} until the application determines its bootstrap
 * sequence has completed.</p>
 *
 * Inline Script Example:
 * <pre class="prettyprint">
 * <code>
 * &lt;head&gt;
 *   &lt;script type=&quot;text/javascript&quot;&gt;
 *     // The "oj_whenReady" global variable enables a strategy that the busy context whenReady,
 *     // will implicitly add a busy state, until the application calls applicationBootstrapComplete
 *     // on the busy state context.
 *     window["oj_whenReady"] = true;
 *   &lt;/script&gt;
 * ...
 * ...
 * </code></pre>
 *
 * Requirejs callback Example:
 * <pre class="prettyprint">
 * <code>
 * require(['knockout', 'jquery', 'app', 'ojs/ojknockout', 'ojs/ojselectcombobox' ...],
 *   function(ko, $, app)
 *   {
 *     // release the application bootstrap busy state
 *     oj.Context.getPageContext().getBusyContext().applicationBootstrapComplete();
 *     ...
 *     ...
 *   });
 * </code></pre>
 *
 * @since 3.2.0
 * @export
 * @memberof oj.BusyContext
 * @instance
 * @method applicationBootstrapComplete
 * @returns {undefined}
 */


oj.BusyContext.prototype.applicationBootstrapComplete = function () {
  var debugScope = this._getDebugScope();

  Logger.log("BusyContext.applicationBootstrapComplete: begin scope='%s'", debugScope);

  oj.BusyContext._BOOTSTRAP_MEDIATOR.notifyComplete();

  Logger.log("BusyContext.applicationBootstrapComplete: end scope='%s'", debugScope);
};
/**
 * @ignore
 * @private
 * @return {oj.BusyContext} returns the nearest parent context
 */


oj.BusyContext.prototype._getParentBusyContext = function () {
  if (this._hostNode) {
    var parentContext = oj.Context.getContext(oj.Context.getParentElement(this._hostNode));

    if (parentContext) {
      return parentContext.getBusyContext();
    }
  }

  return null;
};
/**
 * Links a child context to its parent by registering a busy state with the parent
 * that will recursively register with its parent.
 *
 * @ignore
 * @private
 */


oj.BusyContext.prototype._addBusyStateToParent = function () {
  if (!this._parentNotified) {
    this._parentNotified = true;

    var parentContext = this._getParentBusyContext();

    if (parentContext) {
      var opts = {};
      opts[oj.BusyContext._DESCRIPTION] = this._getCompoundDescription.bind(this);
      this._parentResolveCallback = parentContext.addBusyState(opts);
    }
  }
};
/**
 * Resolves the busy state linking a child context with its parent.
 *
 * @ignore
 * @private
 */


oj.BusyContext.prototype._resolveBusyStateForParent = function () {
  this._parentNotified = false;

  if (this._parentResolveCallback) {
    this._parentResolveCallback();

    this._parentResolveCallback = null;
  }
};
/**
 * @private
 * @ignore
 * @return {string} description of all active busy states held by the context.
 */


oj.BusyContext.prototype._getCompoundDescription = function () {
  var busyStates = oj.BusyContext._values(this._statesMap);

  return '[' + busyStates.join(', ') + ']';
};
/**
 * @private
 * @ignore
 * @return {string} context debug scope
 */


oj.BusyContext.prototype._getDebugScope = function () {
  function toSelector(node) {
    var selector = 'undefined';

    if (node) {
      if (node.id && node.id.length > 0) {
        selector = '#' + node.id;
      } else {
        selector = node.nodeName;

        if (node.hasAttribute('data-oj-context')) {
          selector += '[data-oj-context]';
        }

        var clazz = node.getAttribute('class');

        if (clazz) {
          selector += '.' + clazz.split(' ').join('.');
        }
      }
    }

    return selector;
  }

  if (!this._debugScope) {
    if (this._hostNode) {
      this._debugScope = toSelector(this._hostNode.parentElement) + ' > ' + toSelector(this._hostNode);
    } else {
      this._debugScope = 'page';
    }
  }

  return this._debugScope;
};
/**
 * @since 3.1.0
 * @override
 * @memberof oj.BusyContext
 * @instance
 * @method toString
 * @returns {string} returns the value of the object as a string
 */


oj.BusyContext.prototype.toString = function () {
  var msg = 'Busy Context: [scope=';
  msg += this._getDebugScope();
  msg += ' states=' + this._getCompoundDescription() + ']';
  return msg;
};
/**
 * @ignore
 * @private
 */


oj.BusyContext._deliverThrottledUpdates = function () {
  // Dynamically check for the presence of ojs/ojknockout
  if (oj.ComponentBinding) {
    oj.ComponentBinding.deliverChanges();
  }
};
/**
 * @private
 * @ignore
 * @const
 * attribute name describing a busystate
 * @type {string}
 */


oj.BusyContext._DESCRIPTION = 'description';
/**
 * @ignore
 * @private
 * @constant
 * {@link oj.BusyState} property name indicating the instance is dead
 * @type {string}
 */

oj.BusyContext._OJ_RIP = '__ojRip';
/**
 * @ojtsignore
 * @private
 * @ignore
 */

oj.BusyContext._BOOTSTRAP_MEDIATOR = new
/** @constructor */
function () {
  var _tracking;

  var _readyPromise;

  var _resolveCallback;

  if (typeof window !== 'undefined') {
    _tracking = window.oj_whenReady;
  }

  this.whenReady = function () {
    if (_readyPromise) {
      return _readyPromise;
    }

    if (!_tracking) {
      _readyPromise = Promise.resolve(true);
    } else {
      _readyPromise = new Promise(function (resolve) {
        _resolveCallback = resolve;
      });
    }

    return _readyPromise;
  };

  this.isReady = function () {
    return !_tracking;
  };

  this.notifyComplete = function () {
    if (_resolveCallback) {
      // resovle the promise in the next-tick.
      window.setImmediate(function () {
        _tracking = false;

        _resolveCallback(true);

        _resolveCallback = null;
      });
    } else {
      _tracking = false;
    }
  };
}();



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/**
 * Internally used by the {@link oj.BusyContext} to track a components state
 * while it is performing a task such as animation or fetching data.
 *
 * @hideconstructor
 * @ignore
 * @protected
 * @constructor
 * @param {Function|Object|undefined} description of the component and cause
 *        of the busy state
 */
oj.BusyState = function (description) {
  /**
   * @ignore
   * @private
   * @type {?}
   */
  this._description = description;
  /**
   * @ignore
   * @private
   * @type {number}
   */

  this._addedWaitTs = oj.BusyState._getTs();
  /**
   * @ignore
   * @private
   * @type {string}
   */

  this._id = this._addedWaitTs.toString(36) + '_' + Math.random().toString(36); // @RandomNumberOK -
  // random number concatinated to the current timestamp is used for a unique id for a local Map
  // key. This random number is not used use as a cryptography key.
};

Object.defineProperties(oj.BusyState.prototype, {
  /**
   * Identifies the usage instance of a busy state.
   * @memberof oj.BusyState
   * @instance
   * @property {!string} id
   */
  id: {
    get: function get() {
      return this._id;
    },
    enumerable: true
  },

  /**
   * Further definition of the busy state instance.
   * @memberof oj.BusyState
   * @instance
   * @property {?string} description
   */
  description: {
    get: function get() {
      if (this._description) {
        if (this._description instanceof Function) {
          return this._description();
        }

        return this._description.toString();
      }

      return undefined;
    },
    enumerable: true
  }
});
/**
 * @override
 * @returns {string} returns the value of the object as a string
 */

oj.BusyState.prototype.toString = function () {
  var buff = 'Busy state: [description=';
  var description = this.description;

  if (description !== null) {
    buff += description;
  }

  var elapsed = oj.BusyState._getTs() - this._addedWaitTs;

  buff += ', elapsed=' + elapsed + ']';
  return buff;
};
/**
 * @private
 * @returns {number} current date represented by a number
 */


oj.BusyState._getTs = function () {
  // Safari V9.1.1 doesn't yet support performance.now
  return window.performance ? window.performance.now() : new Date().getTime();
};



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/**
 * <b>The constructor should never be invoked by an application directly</b>. Use
 * {@link oj.Context.getPageContext} and {@link oj.Context.getContext} APIs to
 * retrieve an instance of the context.
 * @param {Element=} node DOM node where the context should be created
 * @export
 * @hideconstructor
 * @ojtsmodule
 * @constructor oj.Context
 * @since 2.1.0
 * @classdesc This is a general purpose context. Initially it only exposes the BusyContext
 * that keeps track of components that are currently animating or fetching data.
 * In the future this context might be expanded for other purposes.
 */
var Context = function Context(node) {
  this.Init(node);
};

oj.Object.createSubclass(Context, oj.Object, 'oj.Context');
/**
 * @method Init
 * @param {Element=} node DOM node where the context should be created
 * @instance
 * @memberof oj.Context
 * @instance
 * @protected
 */

Context.prototype.Init = function (node) {
  Context.superclass.Init.call(this);
  this._node = node;
};
/**
 * Returns the closest enclosing JET context for a node.
 * Any DOM element may be designated by the page author as a host of JET context.
 * The designation must be expressed in HTML markup by specifying the "data-oj-context"
 * attribute on the host element:

 * <pre class="prettyprint">
 * &lt;div data-oj-context>&lt;div>
 * </pre>
 *
 * <p>This method will walk up the element hierarchy starting with the source node to
 * find an element that has the data-oj-context attribute. If no such element is found,
 * the page context will be returned.</p>
 *
 * If the JET context is established on a particular element, the {@link oj.BusyContext}
 * associated with that context will be tracking busy states for that element and
 * its subtree
 *
 * @see oj.BusyContext for code examples
 * @method getContext
 * @memberof oj.Context
 * @param {Element} node DOM element whose enclosing context will be provided
 * @return {oj.Context} context object scoped per the target node
 * @since 2.2.0
 * @export
 */


Context.getContext = function (node) {
  while (node) {
    var context = node[Context._OJ_CONTEXT_INSTANCE];

    if (context) {
      return context;
    }

    if (node.hasAttribute(Context._OJ_CONTEXT_ATTRIBUTE)) {
      context = new Context(node);
      Object.defineProperty(node, Context._OJ_CONTEXT_INSTANCE, {
        value: context
      });
      return context;
    } // eslint-disable-next-line no-param-reassign


    node = Context.getParentElement(node);
  }

  return Context.getPageContext();
};
/**
 * Static factory method that returns the page context.
 * @see oj.BusyContext for code examples
 * @export
 * @since 2.1.0
 * @method getPageContext
 * @return {oj.Context} context scoped for the page
 * @memberof oj.Context
 */


Context.getPageContext = function () {
  if (!Context._pageContext) {
    Context._pageContext = new Context();
  }

  return Context._pageContext;
};
/**
 * @see oj.BusyContext for code examples
 * @since 2.1.0
 * @export
 * @method getBusyContext
 * @memberof oj.Context
 * @instance
 * @returns {oj.BusyContext} busy state context
 */


Context.prototype.getBusyContext = function () {
  if (!this._busyContext) {
    this._busyContext = new oj.BusyContext(this._node);
  }

  return this._busyContext;
};
/**
 * Sets a default for the optional <code>timeout</code> argument of the {@link oj.BusyContext#whenReady}
 * for all BusyContext instances. The default value will be implicitly used if a timeout argument is not
 * provided.
 *
 * @see oj.BusyContext#whenReady
 * @since 6.0.0
 * @memberof oj.Context
 * @method setBusyContextDefaultTimeout
 * @param {number} timeout in milliseconds
 */


Context.setBusyContextDefaultTimeout = function (timeout) {
  oj.BusyContext.setDefaultTimeout(timeout);
};
/**
 * @ignore
 * @private
 * @constant
 * Element marker attribute defining a context
 * @type {string}
 */


Context._OJ_CONTEXT_ATTRIBUTE = 'data-oj-context';
/**
 * @ignore
 * @private
 * @constant
 * Element property name for a context
 * @type {string}
 */

Context._OJ_CONTEXT_INSTANCE = '__ojContextInstance';
/**
 * @ignore
 * @private
 * @constant
 * attribute identifying an open popup
 * @type {string}
 */

Context._OJ_SURROGATE_ATTR = 'data-oj-surrogate-id';
/**
 * @ignore
 * @public
 * @param {Element} element target
 * @return {Element} the logical parent of an element accounting for open popups
 * @memberof oj.Context
 */

Context.getParentElement = function (element) {
  // @see oj.ZOrderUtils._SURROGATE_ATTR in "ojpopupcore/PopupService.js" for the details on how
  // this attribute is used by the popup service. The constant was re-declared to simplify module
  // dependencies.
  if (element && element.hasAttribute(Context._OJ_SURROGATE_ATTR)) {
    var surrogate = document.getElementById(element.getAttribute(Context._OJ_SURROGATE_ATTR));

    if (surrogate) {
      return surrogate.parentElement;
    }
  }

  return element.parentElement;
};

;return Context;
});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * @license RequireJS i18n 2.0.2 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/requirejs/i18n for details
 */
!function(){"use strict";var e=/(^.*(^|\/)nls(\/|$))([^/]*)\/?([^/]*)/;function n(e,n,o,a,r,t,l){if(n[e]||(e=e.replace(/^zh-(Hans|Hant)-([^-]+)$/,"zh-$2")),n[e]){if(o.push(e),!0===n[e]||1===n[e]){var u=l?l+e:e;a.push(r+u+"/"+t)}return!0}return!1}function o(e){return"object"==typeof e}function a(e,n){for(var r=Object.keys(n),t=0;t<r.length;t++){var l=r[t];null==e[l]?e[l]=n[l]:o(n[l])&&o(e[l])&&a(e[l],n[l])}}define('ojL10n',["module"],function(o){var r=o.config?o.config():{};return{version:"2.0.1+",load:function(o,t,l,u){var c;(u=u||{}).locale&&(r.locale=u.locale);var i,f,s,v,g,h,p,d,y,m,L,O=e.exec(o),_=O[1],b=O[5],j=[],H={},k="";O[5]?(c=(_=O[1])+b,i=O[4]):(c=o,b=O[4],i=r.locale,"undefined"!=typeof document?(i||(i=u.isBuild?"root":document.documentElement.lang)||(i=void 0===navigator?"root":navigator.systemLanguage||navigator.language||navigator.userLanguage||"root"),r.locale=i):i="root"),f=function(e){var n,o=e.toLowerCase().split(/-|_/),a=[o[0]],r=1;for(n=1;n<o.length;n++){var t=o[n],l=t.length;if(1===l)break;switch(r){case 1:if(r=2,4===l){a.push(t.charAt(0).toUpperCase()+t.slice(1));break}case 2:r=3,a.push(t.toUpperCase());break;default:a.push(t)}}return function(e){if(!("zh"!==e[0]||e.length>1&&4===e[1].length)){var n="Hans",o=e.length>1?e[1]:null;"TW"!==o&&"MO"!==o&&"HK"!==o||(n="Hant"),e.splice(1,0,n)}}(a),a}(i),v=r.noOverlay,g=r.defaultNoOverlayLocale;var x=r.localePrefix;for((y=r.merge)&&(h=y[_+b])&&(O=e.exec(h),p=O[1],d=O[4]),m=[],s=0;s<f.length;s++)k+=(k?"-":"")+f[s],m.push(k);u.isBuild?(j.push(c),h&&j.push(h),t(j,function(){l()})):("query"===r.includeLocale&&(c=t.toUrl(c+".js"),c+=(-1===c.indexOf("?")?"?":"&")+"loc="+i),L=[c],h&&L.push(h),t(L,function(e,o){var r=[],u=function(e,o,a){for(var t=v||!0===e.__noOverlay,l=g||e.__defaultNoOverlayLocale,u=!1,c=m.length-1;c>=0&&(!u||!t);c--)u=n(m[c],e,r,j,o,a,x);var i=1===m.length&&"root"===m[0];t&&(i||!u)&&l&&n(l,e,r,j,o,a,x),i||n("root",e,r,j,o,a,x)};u(e,_,b);var c=r.length;o&&u(o,p,d),t(j,function(){var n=function(e,n,o,l,u){for(var c=n;c<o&&r[c];c++){var i=r[c],f=x?x+i:i,s=e[i];!0!==s&&1!==s||(s=t(l+f+"/"+u)),a(H,s||{})}};n(o,c,r.length,p,d),n(e,0,c,_,b),H._ojLocale_=f.join("-"),l(H)})}))}}})}();
define('ojtranslations/nls/ojtranslations',{root:{"oj-message":{fatal:"Fatal",error:"Error",warning:"Warning",info:"Info",confirmation:"Confirmation","compact-type-summary":"{0}: {1}"},"oj-converter":{summary:"Value is not in the expected format.",detail:"Enter a value in the expected format.","plural-separator":", ",hint:{summary:"Example: {exampleValue}",detail:"Enter a value in this format: '{exampleValue}'.","detail-plural":"Enter a value in these formats: '{exampleValue}'."},optionHint:{detail:"An accepted value for option '{propertyName}' is '{propertyValueValid}'.","detail-plural":"Accepted values for option '{propertyName}' are '{propertyValueValid}'."},optionTypesMismatch:{summary:"A value for the option '{requiredPropertyName}' is required when the option '{propertyName}' is set to '{propertyValue}'."},optionTypeInvalid:{summary:"A value of the expected type was not provided for option '{propertyName}'."},optionOutOfRange:{summary:"Value {propertyValue} is out of range for the option '{propertyName}'."},optionValueInvalid:{summary:"An invalid value '{propertyValue}' was specified for the option '{propertyName}'."},number:{decimalFormatMismatch:{summary:"The provided value is not in the expected number format."},shortLongUnsupportedParse:{summary:"'short' and 'long' are not supported for converter parsing.",detail:"Change component to readonly. readonly fields do not call the converter's parse function."},currencyFormatMismatch:{summary:"The provided value is not in the expected currency format."},percentFormatMismatch:{summary:"The provided value is not in the expected percent format."},invalidNumberFormat:{summary:"The provided value is not a valid number.",detail:"Please provide valid number."}},color:{invalidFormat:{summary:"Invalid color format.",detail:"Invalid color format option specification."},invalidSyntax:{summary:"Invalid color specification.",detail:"Enter a color value that conforms to the CSS3 standard."}},datetime:{datetimeOutOfRange:{summary:"Value '{value}' is out of range for the '{propertyName}'.",detail:"Enter a value between '{minValue}' and '{maxValue}'.",hour:"hour",minute:"minute",second:"second",millisec:"millisec",month:"month",day:"day",year:"year","month name":"month name",weekday:"weekday"},dateFormatMismatch:{summary:"The provided value is not in the expected date format."},invalidTimeZoneID:{summary:"Invalid timezone id {timeZoneID} provided."},nonExistingTime:{summary:"The input time does not exist because it falls during the transition to daylight saving time."},missingTimeZoneData:{summary:"TimeZone data is missing. Please call require 'ojs/ojtimezonedata' in order to load the TimeZone data."},timeFormatMismatch:{summary:"The provided value is not in the expected time format."},datetimeFormatMismatch:{summary:"The provided value is not in the expected date and time format."},dateToWeekdayMismatch:{summary:"Day '{date}' does not fall on a '{weekday}'.",detail:"Enter a weekday that corresponds with the date."},invalidISOString:{invalidRangeSummary:"The value '{value}' is out of range for the '{propertyName}' field in the ISO 8601 string '{isoStr}'.",summary:"The provided '{isoStr}' is not a valid ISO 8601 string.",detail:"Please provide valid ISO 8601 string."}}},"oj-validator":{length:{hint:{min:"Enter {min} or more characters.",max:"Enter {max} or fewer characters.",inRange:"Enter {min} to {max} characters.",exact:"Enter {length} characters."},messageDetail:{tooShort:"Enter {min} or more characters.",tooLong:"Enter no more than {max} characters."},messageSummary:{tooShort:"There are too few characters.",tooLong:"There are too many characters."}},range:{number:{hint:{min:"Enter a number greater than or equal to {min}.",max:"Enter a number less than or equal to {max}.",inRange:"Enter a number between {min} and {max}.",exact:"Enter the number {num}."},messageDetail:{rangeUnderflow:"Enter {min} or a higher number.",rangeOverflow:"Enter {max} or a lower number.",exact:"Enter the number {num}."},messageSummary:{rangeUnderflow:"The number is too low.",rangeOverflow:"The number is too high."}},datetime:{hint:{min:"Enter a date and time on or after {min}.",max:"Enter a date and time on or before {max}.",inRange:"Enter a date and time between {min} and {max}."},messageDetail:{rangeUnderflow:"Enter a date on or after {min}.",rangeOverflow:"Enter a date on or before {max}."},messageSummary:{rangeUnderflow:"Date and time is earlier than the minimum date and time.",rangeOverflow:"Date and time is later than the maximum date and time."}},date:{hint:{min:"Enter a date on or after {min}.",max:"Enter a date on or before {max}.",inRange:"Enter a date between {min} and {max}."},messageDetail:{rangeUnderflow:"Enter a date on or after {min}.",rangeOverflow:"Enter a date on or before {max}."},messageSummary:{rangeUnderflow:"Date is earlier than the minimum date.",rangeOverflow:"Date is later than the maximum date."}},time:{hint:{min:"Enter a time on or after {min}.",max:"Enter a time on or before {max}.",inRange:"Enter a time between {min} and {max}."},messageDetail:{rangeUnderflow:"Enter a time at or after {min}.",rangeOverflow:"Enter a time at or before {max}."},messageSummary:{rangeUnderflow:"Time is earlier than the minimum time.",rangeOverflow:"Time is later than the maximum time."}}},restriction:{date:{messageSummary:"Date {value} is of a disabled entry.",messageDetail:"The date you selected isn't available. Try another date."}},regExp:{summary:"Format is incorrect.",detail:"Enter allowable values described in this regular expression: '{pattern}'."},required:{summary:"Value is required.",detail:"Enter a value."}},"oj-ojEditableValue":{loading:"Loading",requiredText:"Required"},"oj-ojInputDate":{done:"Done",cancel:"Cancel",prevText:"Previous",nextText:"Next",currentText:"Today",weekHeader:"Wk",tooltipCalendar:"Select Date.",tooltipCalendarTime:"Select Date Time.",tooltipCalendarDisabled:"Select Date Disabled.",tooltipCalendarTimeDisabled:"Select Date Time Disabled.",picker:"Picker",weekText:"Week",datePicker:"Date Picker",inputHelp:"Press Key down or Key up for access to Calendar.",inputHelpBoth:"Press Key down or Key up for access to Calendar and Shift + Key down or Shift Key up for access to time drop down.",dateTimeRange:{hint:{min:"",max:"",inRange:""},messageDetail:{rangeUnderflow:"",rangeOverflow:""},messageSummary:{rangeUnderflow:"",rangeOverflow:""}},dateRestriction:{hint:"",messageSummary:"",messageDetail:""}},"oj-ojInputTime":{cancelText:"Cancel",okText:"OK",currentTimeText:"Now",hourWheelLabel:"Hour",minuteWheelLabel:"Minute",ampmWheelLabel:"AMPM",tooltipTime:"Select Time.",tooltipTimeDisabled:"Select Time Disabled.",inputHelp:"Press Key down or Key up for access to time drop down.",dateTimeRange:{hint:{min:"",max:"",inRange:""},messageDetail:{rangeUnderflow:"",rangeOverflow:""},messageSummary:{rangeUnderflow:"",rangeOverflow:""}}},"oj-inputBase":{required:{hint:"",messageSummary:"",messageDetail:""},regexp:{messageSummary:"",messageDetail:""},accessibleMaxLengthExceeded:"Maximum length {len} exceeded.",accessibleMaxLengthRemaining:"{chars} characters left."},"oj-ojInputPassword":{regexp:{messageDetail:"Value must match this pattern: '{pattern}'."}},"oj-ojFilmStrip":{labelAccFilmStrip:"Displaying page {pageIndex} of {pageCount}",labelAccArrowNextPage:"Select Next to display next page",labelAccArrowPreviousPage:"Select Previous to display previous page",tipArrowNextPage:"Next",tipArrowPreviousPage:"Previous"},"oj-ojDataGrid":{accessibleSortAscending:"{id} sorted in ascending order",accessibleSortDescending:"{id} sorted in descending order",accessibleActionableMode:"Enter actionable mode.",accessibleNavigationMode:"Enter navigation mode, press F2 to enter edit or actionable mode.",accessibleEditableMode:"Enter editable mode, press escape to navigate outside the data grid.",accessibleSummaryExact:"This is a data grid with {rownum} rows and {colnum} columns",accessibleSummaryEstimate:"This is a data grid with unknown number of rows and columns",accessibleSummaryExpanded:"There are currently {num} rows expanded",accessibleRowExpanded:"Row expanded",accessibleRowCollapsed:"Row collapsed",accessibleRowSelected:"Row {row} selected",accessibleColumnSelected:"Column {column} selected",accessibleStateSelected:"selected",accessibleMultiCellSelected:"{num} cells selected",accessibleColumnSpanContext:"{extent} wide",accessibleRowSpanContext:"{extent} high",accessibleRowContext:"Row {index}",accessibleColumnContext:"Column {index}",accessibleRowHeaderContext:"Row Header {index}",accessibleColumnHeaderContext:"Column Header {index}",accessibleRowEndHeaderContext:"Row End Header {index}",accessibleColumnEndHeaderContext:"Column End Header {index}",accessibleRowHeaderLabelContext:"Row Header Label {level}",accessibleColumnHeaderLabelContext:"Column Header Label {level}",accessibleRowEndHeaderLabelContext:"Row End Header Label {level}",accessibleColumnEndHeaderLabelContext:"Column End Header Label {level}",accessibleLevelContext:"Level {level}",accessibleRangeSelectModeOn:"Add selected range of cells mode on.",accessibleRangeSelectModeOff:"Add selected range of cells mode off.",accessibleFirstRow:"You have reached the first row.",accessibleLastRow:"You have reached the last row.",accessibleFirstColumn:"You have reached the first column",accessibleLastColumn:"You have reached the last column.",accessibleSelectionAffordanceTop:"Top selection handle.",accessibleSelectionAffordanceBottom:"Bottom selection handle.",msgFetchingData:"Fetching Data...",msgNoData:"No items to display.",labelResize:"Resize",labelResizeWidth:"Resize Width",labelResizeHeight:"Resize Height",labelSortRow:"Sort Row",labelSortRowAsc:"Sort Row Ascending",labelSortRowDsc:"Sort Row Descending",labelSortCol:"Sort Column",labelSortColAsc:"Sort Column Ascending",labelSortColDsc:"Sort Column Descending",labelCut:"Cut",labelPaste:"Paste",labelEnableNonContiguous:"Enable Non-Contiguous Selection",labelDisableNonContiguous:"Disable Non-Contiguous Selection",labelResizeDialogSubmit:"OK",labelResizeDialogCancel:"Cancel"},"oj-ojRowExpander":{accessibleLevelDescription:"Level {level}",accessibleRowDescription:"Level {level}, Row {num} of {total}",accessibleRowExpanded:"Row expanded",accessibleRowCollapsed:"Row collapsed",accessibleStateExpanded:"expanded",accessibleStateCollapsed:"collapsed"},"oj-ojListView":{msgFetchingData:"Fetching Data...",msgNoData:"No items to display.",msgItemsAppended:"{count} items appended to the end.",indexerCharacters:"A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z",accessibleReorderTouchInstructionText:"Double tap and hold.  Wait for the sound then drag to rearrange.",accessibleReorderBeforeItem:"Before {item}",accessibleReorderAfterItem:"After {item}",accessibleReorderInsideItem:"Into {item}",accessibleNavigateSkipItems:"Skipping {numSkip} items",labelCut:"Cut",labelCopy:"Copy",labelPaste:"Paste",labelPasteBefore:"Paste Before",labelPasteAfter:"Paste After"},"oj-_ojLabel":{tooltipHelp:"Help",tooltipRequired:"Required"},"oj-ojLabel":{tooltipHelp:"Help",tooltipRequired:"Required"},"oj-ojInputNumber":{required:{hint:"",messageSummary:"",messageDetail:""},numberRange:{hint:{min:"",max:"",inRange:"",exact:""},messageDetail:{rangeUnderflow:"",rangeOverflow:"",exact:""},messageSummary:{rangeUnderflow:"",rangeOverflow:""}},tooltipDecrement:"Decrement",tooltipIncrement:"Increment"},"oj-ojTable":{accessibleColumnContext:"Column {index}",accessibleColumnHeaderContext:"Column Header {index}",accessibleRowContext:"Row {index}",accessibleSortAscending:"{id} sorted in ascending order",accessibleSortDescending:"{id} sorted in descending order",accessibleStateSelected:"selected",labelAccSelectionAffordanceTop:"Top selection handle",labelAccSelectionAffordanceBottom:"Bottom selection handle",labelEnableNonContiguousSelection:"Enable Non-Contiguous Selection",labelDisableNonContiguousSelection:"Disable Non-Contiguous Selection",labelResize:"Resize",labelResizePopupSubmit:"OK",labelResizePopupCancel:"Cancel",labelResizePopupSpinner:"Resize Column",labelSelectRow:"Select Row",labelEditRow:"Edit Row",labelSelectAndEditRow:"Select And Edit Row",labelSelectColumn:"Select Column",labelSort:"Sort",labelSortAsc:"Sort Ascending",labelSortDsc:"Sort Descending",msgFetchingData:"Fetching Data...",msgNoData:"No data to display.",msgInitializing:"Initializing...",msgColumnResizeWidthValidation:"Width value must be an integer.",msgScrollPolicyMaxCountSummary:"Exceeded maximum rows for table scrolling.",msgScrollPolicyMaxCountDetail:"Please reload with smaller data set.",msgStatusSortAscending:"{0} sorted in ascending order.",msgStatusSortDescending:"{0} sorted in descending order."},"oj-ojTabs":{labelCut:"Cut",labelPasteBefore:"Paste Before",labelPasteAfter:"Paste After",labelRemove:"Remove",labelReorder:"Reorder",removeCueText:"Removable"},"oj-ojCheckboxset":{readonlyNoValue:"",required:{hint:"",messageSummary:"",messageDetail:""}},"oj-ojRadioset":{readonlyNoValue:"",required:{hint:"",messageSummary:"",messageDetail:""}},"oj-ojSelect":{required:{hint:"",messageSummary:"",messageDetail:""},searchField:"Search field",noMatchesFound:"No matches found",oneMatchesFound:"One match found",moreMatchesFound:"{num} matches found",filterFurther:"More results available, please filter further."},"oj-ojSwitch":{SwitchON:"On",SwitchOFF:"Off"},"oj-ojCombobox":{required:{hint:"",messageSummary:"",messageDetail:""},noMatchesFound:"No matches found",oneMatchesFound:"One match found",moreMatchesFound:"{num} matches found",filterFurther:"More results available, please filter further."},"oj-ojSelectSingle":{required:{hint:"",messageSummary:"",messageDetail:""},noMatchesFound:"No matches found",oneMatchFound:"One match found",multipleMatchesFound:"{num} matches found",nOrMoreMatchesFound:"{num} or more matches found",cancel:"Cancel",labelAccOpenDropdown:"expand",labelAccClearValue:"clear value",noResultsLine1:"No results found",noResultsLine2:"We can't find anything matching your search."},"oj-ojInputSearch":{required:{hint:"",messageSummary:"",messageDetail:""},noMatchesFound:"No matches found",oneMatchesFound:"One match found",moreMatchesFound:"{num} matches found"},"oj-ojTree":{stateLoading:"Loading...",labelNewNode:"New Node",labelMultiSelection:"Multiple Selection",labelEdit:"Edit",labelCreate:"Create",labelCut:"Cut",labelCopy:"Copy",labelPaste:"Paste",labelPasteAfter:"Paste After",labelPasteBefore:"Paste Before",labelRemove:"Remove",labelRename:"Rename",labelNoData:"No data"},"oj-ojPagingControl":{labelAccPaging:"Pagination",labelAccPageNumber:"Page {pageNum} content loaded",labelAccNavFirstPage:"First Page",labelAccNavLastPage:"Last Page",labelAccNavNextPage:"Next Page",labelAccNavPreviousPage:"Previous Page",labelAccNavPage:"Page",labelLoadMore:"Show More...",labelLoadMoreMaxRows:"Reached Maximum Limit of {maxRows} rows",labelNavInputPage:"Page",labelNavInputPageMax:"of {pageMax}",fullMsgItemRange:"{pageFrom}-{pageTo} of {pageMax} items",fullMsgItemRangeAtLeast:"{pageFrom}-{pageTo} of at least {pageMax} items",fullMsgItemRangeApprox:"{pageFrom}-{pageTo} of approx {pageMax} items",msgItemRangeNoTotal:"{pageFrom}-{pageTo} items",fullMsgItem:"{pageTo} of {pageMax} items",fullMsgItemAtLeast:"{pageTo} of at least {pageMax} items",fullMsgItemApprox:"{pageTo} of approx {pageMax} items",msgItemNoTotal:"{pageTo} items",msgItemRangeCurrent:"{pageFrom}-{pageTo}",msgItemRangeCurrentSingle:"{pageFrom}",msgItemRangeOf:"of",msgItemRangeOfAtLeast:"of at least",msgItemRangeOfApprox:"of approx.",msgItemRangeItems:"items",tipNavInputPage:"Go To Page",tipNavPageLink:"Go To Page {pageNum}",tipNavNextPage:"Next",tipNavPreviousPage:"Previous",tipNavFirstPage:"First",tipNavLastPage:"Last",pageInvalid:{summary:"The page value entered is invalid.",detail:"Please enter a value greater than 0."},maxPageLinksInvalid:{summary:"Value for maxPageLinks is invalid.",detail:"Please enter a value greater than 4."}},"oj-ojMasonryLayout":{labelCut:"Cut",labelPasteBefore:"Paste Before",labelPasteAfter:"Paste After"},"oj-panel":{labelAccButtonExpand:"Expand",labelAccButtonCollapse:"Collapse",labelAccButtonRemove:"Remove",labelAccFlipForward:"Flip forward",labelAccFlipBack:"Flip back",tipDragToReorder:"Drag to reorder",labelAccDragToReorder:"Drag to reorder, context menu available"},"oj-ojChart":{labelDefaultGroupName:"Group {0}",labelSeries:"Series",labelGroup:"Group",labelDate:"Date",labelValue:"Value",labelTargetValue:"Target",labelX:"X",labelY:"Y",labelZ:"Z",labelPercentage:"Percentage",labelLow:"Low",labelHigh:"High",labelOpen:"Open",labelClose:"Close",labelVolume:"Volume",labelQ1:"Q1",labelQ2:"Q2",labelQ3:"Q3",labelMin:"Min",labelMax:"Max",labelOther:"Other",tooltipPan:"Pan",tooltipSelect:"Marquee select",tooltipZoom:"Marquee zoom",componentName:"Chart"},"oj-dvtBaseGauge":{componentName:"Gauge"},"oj-ojDiagram":{promotedLink:"{0} link",promotedLinks:"{0} links",promotedLinkAriaDesc:"Indirect",componentName:"Diagram"},"oj-ojGantt":{componentName:"Gantt",accessibleDurationDays:"{0} days",accessibleDurationHours:"{0} hours",accessibleTaskInfo:"Start time is {0}, end time is {1}, duration is {2}",accessibleMilestoneInfo:"Time is {0}",accessibleRowInfo:"Row {0}",accessibleTaskTypeMilestone:"Milestone",accessibleTaskTypeSummary:"Summary",accessiblePredecessorInfo:"{0} predecessors",accessibleSuccessorInfo:"{0} successors",accessibleDependencyInfo:"Dependency type {0}, connects {1} to {2}",startStartDependencyAriaDesc:"start to start",startFinishDependencyAriaDesc:"start to finish",finishStartDependencyAriaDesc:"finish to start",finishFinishDependencyAriaDesc:"finish to finish",tooltipZoomIn:"Zoom In",tooltipZoomOut:"Zoom Out",labelLevel:"Level",labelRow:"Row",labelStart:"Start",labelEnd:"End",labelDate:"Date",labelBaselineStart:"Baseline Start",labelBaselineEnd:"Baseline End",labelBaselineDate:"Baseline Date",labelLabel:"Label",labelProgress:"Progress",labelMoveBy:"Move By",labelResizeBy:"Resize By",taskMoveInitiated:"Task move initiated",taskResizeEndInitiated:"Task resize end initiated",taskResizeStartInitiated:"Task resize start initiated",taskMoveSelectionInfo:"{0} others selected",taskResizeSelectionInfo:"{0} others selected",taskMoveInitiatedInstruction:"Use the arrow keys to move",taskResizeInitiatedInstruction:"Use the arrow keys to resize",taskMoveFinalized:"Task move finalized",taskResizeFinalized:"Task resize finalized",taskMoveCancelled:"Task move cancelled",taskResizeCancelled:"Task resize cancelled",taskResizeStartHandle:"Task resize start handle",taskResizeEndHandle:"Task resize end handle"},"oj-ojLegend":{componentName:"Legend",tooltipExpand:"Expand",tooltipCollapse:"Collapse"},"oj-ojNBox":{highlightedCount:"{0}/{1}",labelOther:"Other",labelGroup:"Group",labelSize:"Size",labelAdditionalData:"Additional Data",componentName:"{0} Box"},"oj-ojPictoChart":{componentName:"Picture Chart"},"oj-ojSparkChart":{componentName:"Chart"},"oj-ojSunburst":{labelColor:"Color",labelSize:"Size",tooltipExpand:"Expand",tooltipCollapse:"Collapse",componentName:"Sunburst"},"oj-ojTagCloud":{componentName:"Tag Cloud"},"oj-ojThematicMap":{componentName:"Thematic Map",areasRegion:"Areas",linksRegion:"Links",markersRegion:"Markers"},"oj-ojTimeAxis":{componentName:"Time Axis"},"oj-ojTimeline":{componentName:"Timeline",accessibleItemDesc:"Description is {0}.",accessibleItemEnd:"End time is {0}.",accessibleItemStart:"Start time is {0}.",accessibleItemTitle:"Title is {0}.",labelSeries:"Series",tooltipZoomIn:"Zoom In",tooltipZoomOut:"Zoom Out",labelStart:"Start",labelEnd:"End",labelDate:"Date",labelTitle:"Title",labelDescription:"Description"},"oj-ojTreemap":{labelColor:"Color",labelSize:"Size",tooltipIsolate:"Isolate",tooltipRestore:"Restore",componentName:"Treemap"},"oj-dvtBaseComponent":{labelScalingSuffixThousand:"K",labelScalingSuffixMillion:"M",labelScalingSuffixBillion:"B",labelScalingSuffixTrillion:"T",labelScalingSuffixQuadrillion:"Q",labelInvalidData:"Invalid data",labelNoData:"No data to display",labelClearSelection:"Clear Selection",labelDataVisualization:"Data Visualization",stateSelected:"Selected",stateUnselected:"Unselected",stateMaximized:"Maximized",stateMinimized:"Minimized",stateExpanded:"Expanded",stateCollapsed:"Collapsed",stateIsolated:"Isolated",stateHidden:"Hidden",stateVisible:"Visible",stateDrillable:"Drillable",labelAndValue:"{0}: {1}",labelCountWithTotal:"{0} of {1}"},"oj-ojNavigationList":{defaultRootLabel:"Navigation List",hierMenuBtnLabel:"Hierarchical Menu button",selectedLabel:"selected",previousIcon:"Previous",msgFetchingData:"Fetching Data...",msgNoData:"No items to display.",overflowItemLabel:"More",accessibleReorderTouchInstructionText:"Double tap and hold.  Wait for the sound then drag to rearrange.",accessibleReorderBeforeItem:"Before {item}",accessibleReorderAfterItem:"After {item}",labelCut:"Cut",labelPasteBefore:"Paste Before",labelPasteAfter:"Paste After",labelRemove:"Remove",removeCueText:"Removable"},"oj-ojSlider":{noValue:"ojSlider has no value",maxMin:"Max must not be less than or equal to min",startEnd:"value.start must not be greater than value.end",valueRange:"Value must be within min to max range",optionNum:"{option} option is not a number",invalidStep:"Invalid step; step must be > 0"},"oj-ojDialog":{labelCloseIcon:"Close"},"oj-ojPopup":{ariaLiveRegionInitialFocusFirstFocusable:"Entering pop-up. Press F6 to navigate between the pop-up and associated control.",ariaLiveRegionInitialFocusNone:"Pop-up opened. Press F6 to navigate between the pop-up and associated control.",ariaLiveRegionInitialFocusFirstFocusableTouch:"Entering pop-up. Pop-up can be closed by navigating to the last link within the pop-up.",ariaLiveRegionInitialFocusNoneTouch:"Pop-up opened. Navigate to the next link to establish focus within the pop-up.",ariaFocusSkipLink:"Double tap to navigate to the open pop-up.",ariaCloseSkipLink:"Double tap to close the open pop-up."},"oj-ojRefresher":{ariaRefreshLink:"Activate link to refresh content",ariaRefreshingLink:"Refreshing content",ariaRefreshCompleteLink:"Refresh complete"},"oj-ojSwipeActions":{ariaShowStartActionsDescription:"Show start actions",ariaShowEndActionsDescription:"Show end actions",ariaHideActionsDescription:"Hide actions"},"oj-ojIndexer":{indexerCharacters:"A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z",indexerOthers:"#",ariaDisabledLabel:"No matching group header",ariaOthersLabel:"number",ariaInBetweenText:"Between {first} and {second}",ariaKeyboardInstructionText:"Press enter to select value.",ariaTouchInstructionText:"Double tap and hold to enter gesture mode, then drag up or down to adjust value."},"oj-ojMenu":{labelCancel:"Cancel",ariaFocusSkipLink:"Focus is within the menu, double tap or swipe to move focus to the first menu item."},"oj-ojColorSpectrum":{labelHue:"Hue",labelOpacity:"Opacity",labelSatLum:"Saturation/Luminance",labelThumbDesc:"Color spectrum four way slider."},"oj-ojColorPalette":{labelNone:"None"},"oj-ojColorPicker":{labelSwatches:"Swatches",labelCustomColors:"Custom Colors",labelPrevColor:"Previous Color",labelDefColor:"Default Color",labelDelete:"Delete",labelDeleteQ:"Delete?",labelAdd:"Add",labelAddColor:"Add color",labelMenuHex:"HEX",labelMenuRgba:"RGBa",labelMenuHsla:"HSLa",labelSliderHue:"Hue",labelSliderSaturation:"Saturation",labelSliderSat:"Sat",labelSliderLightness:"Lightness",labelSliderLum:"Luminosity",labelSliderAlpha:"Alpha",labelOpacity:"Opacity",labelSliderRed:"Red",labelSliderGreen:"Green",labelSliderBlue:"Blue"},"oj-ojFilePicker":{dropzoneText:"Drop files here or click to upload",singleFileUploadError:"Upload one file at a time.",singleFileTypeUploadError:"You can't upload files of type {fileType}.",multipleFileTypeUploadError:"You can't upload files of type: {fileTypes}.",dropzonePrimaryText:"Drag and Drop",secondaryDropzoneText:"Select a file or drop one here.",secondaryDropzoneTextMultiple:"Select or drop files here.",unknownFileType:"unknown"},"oj-ojProgressbar":{ariaIndeterminateProgressText:"In Progress"},"oj-ojMessage":{labelCloseIcon:"Close",categories:{error:"Error",warning:"Warning",info:"Information",confirmation:"Confirmation"}},"oj-ojSelector":{checkboxAriaLabel:"Checkbox Select {rowKey}"},"oj-ojMessages":{labelLandmark:"Messages",ariaLiveRegion:{navigationFromKeyboard:"Entering messages region. Press F6 to navigate back to prior focused element.",navigationToTouch:"Messages region has new messages. Use the voice-over rotor to navigate to the messages landmark.",navigationToKeyboard:"Messages region has new messages.  Press F6 to navigate to the most recent message region.",newMessage:"Message category {category}. {summary}. {detail}."}}},ar:1,"ar-XB":1,cs:1,da:1,de:1,el:1,"en-XA":1,"en-XC":1,es:1,et:1,fi:1,fr:1,"fr-CA":1,he:1,hr:1,hu:1,is:1,it:1,ja:1,ko:1,lt:1,lv:1,nl:1,no:1,pl:1,pseudo:1,pt:1,"pt-PT":1,ro:1,ru:1,sk:1,sl:1,sr:1,"sr-Latn":1,sv:1,th:1,tr:1,"zh-Hans":1,"zh-Hant":1});

/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

//although Config has a direct dependency on oj.LocaleData and oj.TimezoneData we will not list 
// these direct dependencies here because of circulare reference error. 
// The oj.LocaleData and oj.TimezoneData dependencies are tested in the code
// if they exist. We purposely leave them out for two reasons: one is they have a circular reference,
// and another is to not incur the download cost if the code doesn't need them.
define('ojs/ojconfig',['require','ojs/ojcore-base', 'ojL10n!ojtranslations/nls/ojtranslations'  ], function(require, oj, ojt)
{
  "use strict";


/* jslint browser: true*/

/* global ojt:true, Promise:false */

/**
 * @namespace oj.Config
 * @hideconstructor
 * @classdesc Services for setting and retrieving configuration options
 * @since 1.0
 * @ojtsmodule
 * @export
 * @ojtsimport {module: "ojcspexpressionevaluator", type: "AMD", importName: "CspExpressionEvaluator"}
 */
var Config = {};
/**
 * Retrieves the render mode the application should use.  This allows the application to render content
 * differently based on the type of device.
 * <p>By default, this function returns the value from getDeviceType.</p>
 * <p>An application can override it by adding a "data-oj-device-render-mode" attribute with the desired value
 * to the document body.  This may be useful in simulating the look of one device type on a different device type,
 * such as simulating the look of "phone" on a destop computer.</p>
 *
 * @memberof oj.Config
 * @method getDeviceRenderMode
 * @return {"phone" | "tablet" | "others"} The render mode
 * @export
 */

Config.getDeviceRenderMode = function () {
  return document.body.getAttribute('data-oj-device-render-mode') || Config.getDeviceType();
};
/**
 * Retrieves the type of device the application is running on.  This allows the application to behave
 * differently based on the type of device.
 * <p>This function always return the actual device type.  Use getDeviceRenderMode if the application wants
 * to render content differently based on the device type, including simulated device type.</p>
 *
 * @memberof oj.Config
 * @method getDeviceType
 * @return {"phone" | "tablet" | "others"} The device type
 * @export
 */


Config.getDeviceType = function () {
  return oj.AgentUtils.getAgentInfo().deviceType;
};
/**
 * Retrieves the current locale
 * @memberof oj.Config
 * @method getLocale
 * @return {string} current locale
 * @export
 */


Config.getLocale = function () {
  if (oj.__isAmdLoaderPresent()) {
    oj.Assert.assert(typeof ojt !== 'undefined', 'ojtranslations module must be defined');
    var rl = ojt._ojLocale_; // If Require.js internationalziation plugin resolved the locale to "root" (presumably because "lang" attribute was not
    // set, and neither navigator.language or navigator.userLanguage were not available), return "en"

    return rl === 'root' ? 'en' : rl;
  }

  var loc = Config._locale;

  if (loc == null) {
    loc = document.documentElement.lang;

    if (!loc) {
      loc = navigator === undefined ? 'en' : (navigator.language || navigator.userLanguage || 'en').toLowerCase();
    }

    loc = loc.toLowerCase();
    Config._locale = loc;
  }

  return loc;
};
/**
 * Changes the current locale
 * @method setLocale
 * @param {string} locale (language code and subtags separated by dash)
 * @param {function(): void} [callback] - for applications running with an AMD Loader (such as Require.js), this optional callback
 * will be invoked when the framework is done loading its translated resources and Locale Elements for the newly specified locale.
 * For applications running without an AMD loader, this optional callback will be invoked immediately
 * @return {undefined}
 * @export
 * @memberof oj.Config
 */


Config.setLocale = function (locale, callback) {
  if (oj.__isAmdLoaderPresent()) {
    var prefix = 'ojL10n!ojtranslations/nls/';
    var requestedBundles = [prefix + locale + '/ojtranslations'];
    var timezoneBundleCount = 0; // Request LocaleElements only if the ojs/ojlocaledata module is loaded;
    // oj.LocaleData will exist in that case.
    // Validators/Converters that need locale data import ojs/ojlocaledata
    // themselves.
    // If you're just using Config.setLocale to change your
    // translation bundle, this code will do that without
    // incurring the download hit of the ojs/ojlocaledata module.

    if (oj.LocaleData) {
      requestedBundles.push(prefix + locale + '/localeElements');

      if (oj.TimezoneData) {
        var tzBundles = oj.TimezoneData.__getBundleNames();

        timezoneBundleCount = tzBundles.length;
        tzBundles.forEach(function (bundle) {
          requestedBundles.push(prefix + locale + bundle);
        });
      }
    } // eslint-disable-next-line global-require


    require(
    /* ojWebpackError: 'oj.Config.setLocale() is not supported when the ojs/ojcore module has been bundled by Webpack' */
    requestedBundles, function (translations, localeElements) {
      ojt = translations;

      if (localeElements) {
        oj.LocaleData.__updateBundle(localeElements);
      }

      for (var i = 0; i < timezoneBundleCount; i++) {
        var tzBundle = arguments[i + 2];

        oj.TimezoneData.__mergeIntoLocaleElements(tzBundle);
      }

      if (callback) {
        callback();
      }
    });
  } else {
    Config._locale = locale;

    if (callback) {
      callback();
    }
  }
};
/**
 * Retrieves a URL for loading a component-specific resource.
 * The URL is resolved as follows:
 * 1. If the application has specified a base URL with setResourceBaseUrl(), the return values will be
 * a relative path appended to the base URL.
 * 2. Otherwise, if the application running with an AMD Loader (such as Require.js), the parent folder of a
 * module with ojs/ mapping will be used as a base URL.
 * 3. Otherwise, the original relative path will be returned.
 * @method getResourceUrl
 * @param {string} relativePath resource path
 * @return {string} resource URL
 * @see oj.Config.setResourceBaseUrl
 * @export
 * @memberof oj.Config
 */


Config.getResourceUrl = function (relativePath) {
  // Returning null and full URLs (containing protocol or a leading slash) as is
  var fullUrlExp = /^\/|:/;

  if (relativePath == null || fullUrlExp.test(relativePath)) {
    return relativePath;
  }

  var base = Config._resourceBaseUrl;

  if (base == null) {
    base = Config._getOjBaseUrl() || '';
  }

  var len = base.length;
  return base + (len === 0 || base.charAt(len - 1) === '/' ? '' : '/') + relativePath;
};
/**
 * Sets the base URL for retrieving component-specific resources
 * @method setResourceBaseUrl
 * @param {string} baseUrl base URL
 * @return {undefined}
 * @see oj.Config.getResourceUrl
 * @export
 * @memberof oj.Config
 */


Config.setResourceBaseUrl = function (baseUrl) {
  Config._resourceBaseUrl = baseUrl;
};
/**
 * Sets the automation mode.
 * @method setAutomationMode
 * @param {string} mode "enabled" for running in automation mode
 * @return {undefined}
 * @see oj.Config.getAutomationMode
 * @export
 * @memberof oj.Config
 */


Config.setAutomationMode = function (mode) {
  Config._automationMode = mode;
};
/**
 * Gets the automation mode.
 * @method getAutomationMode
 * @return {string} automation mode
 * @see oj.Config.setAutomationMode
 * @export
 * @memberof oj.Config
 */


Config.getAutomationMode = function () {
  return Config._automationMode;
};
/**
 * Return a string containing important version information about JET and the libraries
 * it has loaded
 * @method getVersionInfo
 * @return {string}
 * @export
 * @memberof oj.Config
 */


Config.getVersionInfo = function () {
  // JET information
  var info = 'Oracle JET Version: ' + oj.version + '\n';
  info += 'Oracle JET Revision: ' + oj.revision + '\n';
  var windowDefined = typeof window !== 'undefined'; // Browser information

  if (windowDefined && window.navigator) {
    info += 'Browser: ' + window.navigator.userAgent + '\n';
    info += 'Browser Platform: ' + window.navigator.platform + '\n';
  } // 3rd party libraries


  if ($) {
    if ($.fn) {
      info += 'jQuery Version: ' + $.fn.jquery + '\n';
    }

    if ($.ui && $.ui.version) {
      info += 'jQuery UI Version: ' + $.ui.version + '\n';
    }
  }

  if (oj.ComponentBinding) {
    info += 'Knockout Version: ' + oj.ComponentBinding.__getKnockoutVersion() + '\n';
  } // Local require doesn't have version #


  if (windowDefined && window.require) {
    info += 'Require Version: ' + window.require.version + '\n';
  }

  return info;
};
/**
 * Dump information to the browser's console containing important version information about JET and
 * the libraries it has loaded
 * @method logVersionInfo
 * @return {undefined}
 * @memberof oj.Config
 * @export
 */


Config.logVersionInfo = function () {};
/**
 * This method gets replaced by JET's Webpack plugin to return the value provided as baseResourceUrl in the
 * config for the plugin
 * @private
 * @ignore
 */


Config._getOjBaseUrl = function () {
  var base = null;

  if (oj.__isAmdLoaderPresent()) {
    // : use ojs/_foo_ instead of ojs/ojcore to handle the case when ojs.core ends up in a partition bundle
    // in a different location
    var modulePath = require.toUrl('ojs/_foo_');

    base = modulePath.replace(/[^/]*$/, '../');
  }

  return base;
};
/**
 * Retrives JET's template engine for dealing with inline templates (currently internal only)
 * @ignore
 * @memberof oj.Config
 * @private
 */


Config.__getTemplateEngine = function () {
  if (!Config._templateEnginePromise) {
    if (!oj.__isAmdLoaderPresent()) {
      throw new Error('JET Template engine cannot be loaded with an AMD loader');
    }

    Config._templateEnginePromise = new Promise(function (resolve, reject) {
      // eslint-disable-next-line global-require
      require(['./ojtemplateengine'], resolve, reject);
    });
  }

  return Config._templateEnginePromise;
};
/**
 * Returns ojtranslation module. Called by oj.Translations, in this way we can make sure that the ojtranslation module
 * instance is shared between Config and Translations.
 * @ignore
 * @memberof oj.Config
 * @private
 */


Config.getConfigBundle = function () {
  return ojt;
};
/**
 * Returns expression evaluator
 * @return {undefined | Object}
 * @ignore
 * @export
 * @memberof oj.Config
 * @since 7.1.0
 */


Config.getExpressionEvaluator = function () {
  return Config._expressionEvaluator;
};
/**
 * Sets an optional CSP-compliant expression evaluator for the JET binding provider and JET ExpressionUtils.
 * This method can only be called once and must be called before applying
 * knockout bindings in the application for the first time.
 * @see <a href="oj.CspExpressionEvaluator.html">CspExpressionEvaluator</a>
 * @method setExpressionEvaluator
 * @param {Object} expressionEvaluator An instance of CspExpressionEvaluator class
 * @return {undefined}
 * @memberof oj.Config
 * @ojshortdesc Sets a CSP-compliant expression evaluator.
 * @export
 * @ojsignature {target:"Type", value: "oj.CspExpressionEvaluator", for: "expressionEvaluator"}
 * @since 7.1.0
 */


Config.setExpressionEvaluator = function (expressionEvaluator) {
  if (Config._expressionEvaluator) {
    throw new Error("JET Expression evaluator can't be set more than once.");
  }

  Config._expressionEvaluator = expressionEvaluator;
};

;return Config;
});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojresponsiveutils',['ojs/ojlogger'], function(Logger)
{
  "use strict";


/* jslint browser: true*/

/* global Logger:false */

/**
 * @namespace oj.ResponsiveUtils
 * @classdesc Utilities for working with the framework's responsive screen widths
 * and ranges. Often used in conjunction with {@link oj.ResponsiveKnockoutUtils}
 * to create knockout observables that can be used to drive responsive page behavior.
 * See the method doc below for specific examples.
 * @ojtsmodule
 * @since 1.1.0
 * @hideconstructor
 * @export
 */
var ResponsiveUtils = function ResponsiveUtils() {};
/**
 * <p>In the jet sass files there are variables for
 * responsive screen widths, these look something like</p>
 *  <ul>
 *    <li>$screenSmallRange:  0, 767px;</li>
 *    <li>$screenMediumRange: 768px, 1023px;</li>
 *    <li>$screenLargeRange:  1024px, 1280px;</li>
 *    <li>$screenXlargeRange: 1281px, null;</li>
 *  </ul>
 *
 * <p>These constants are used to identify these ranges.</p>
 * @enum {string}
 * @memberof oj.ResponsiveUtils
 * @alias SCREEN_RANGE
 * @constant
 * @export
 */


ResponsiveUtils.SCREEN_RANGE = {
  /**
   * @expose
   * @constant
   */
  SM: 'sm',

  /**
   * @expose
   * @constant
   */
  MD: 'md',

  /**
   * @expose
   * @constant
   */
  LG: 'lg',

  /**
   * @expose
   * @constant
   */
  XL: 'xl',

  /**
   * @expose
   * @constant
   */
  XXL: 'xxl'
};
/**
 * <p>In the jet sass files there are variables for
 * responsive screen widths,
 * see {@link oj.ResponsiveUtils.SCREEN_RANGE} for details.
 * The jet sass files also has variables for
 * responsive queries like $responsiveQuerySmallUp,
 * $responsiveQuerySmallOnly, $responsiveQueryMediumUp, etc.</p>
 *
 * <p>These constants are used to identify these queries.</p>
 * @enum {string}
 * @memberof oj.ResponsiveUtils
 * @alias FRAMEWORK_QUERY_KEY
 * @constant
 * @export
 */

ResponsiveUtils.FRAMEWORK_QUERY_KEY = {
  /**
   * Matches screen width small and wider
   * @expose
   * @constant
   */
  SM_UP: 'sm-up',

  /**
   * matches screen width medium and wider
   * @expose
   * @constant
   */
  MD_UP: 'md-up',

  /**
   * matches screen width large and wider
   * @expose
   * @constant
   */
  LG_UP: 'lg-up',

  /**
   * matches screen width extra-large and wider
   * @expose
   * @constant
   */
  XL_UP: 'xl-up',

  /**
   * matches screen width extra-extra-large and wider
   * @expose
   * @constant
   */
  XXL_UP: 'xxl-up',

  /**
   * matches screen width small only
   * @expose
   * @constant
   */
  SM_ONLY: 'sm-only',

  /**
   * matches screen width medium only
   * @expose
   * @constant
   */
  MD_ONLY: 'md-only',

  /**
   * matches screen width large only
   * @expose
   * @constant
   */
  LG_ONLY: 'lg-only',

  /**
   * matches screen width extra-large only
   * @expose
   * @constant
   */
  XL_ONLY: 'xl-only',

  /**
   * matches screen width medium and narrower
   * @expose
   * @constant
   */
  MD_DOWN: 'md-down',

  /**
   * matches screen width large and narrower
   * @expose
   * @constant
   */
  LG_DOWN: 'lg-down',

  /**
   * matches screen width extra-large and narrower
   * @expose
   * @constant
   */
  XL_DOWN: 'xl-down',

  /**
   * matches high resolution screens
   * @expose
   * @constant
   */
  HIGH_RESOLUTION: 'high-resolution'
}; // used by the compare function

ResponsiveUtils._RANGE = {};
ResponsiveUtils._RANGE[ResponsiveUtils.SCREEN_RANGE.SM] = 0;
ResponsiveUtils._RANGE[ResponsiveUtils.SCREEN_RANGE.MD] = 1;
ResponsiveUtils._RANGE[ResponsiveUtils.SCREEN_RANGE.LG] = 2;
ResponsiveUtils._RANGE[ResponsiveUtils.SCREEN_RANGE.XL] = 3;
ResponsiveUtils._RANGE[ResponsiveUtils.SCREEN_RANGE.XXL] = 4;
/**
 * This idea/code is from zurb foundation, thanks zurb!
 *
 * In the jet sass files there are variables for
 * responsive screen sizes, these look something like

 *  <ul>
 *    <li>$screenSmallRange:  0, 767px;</li>
 *    <li>$screenMediumRange: 768px, 1023px;</li>
 *    <li>$screenLargeRange:  1024px, 1280px;</li>
 *    <li>$screenXlargeRange: 1281px, null;</li>
 *  </ul>
 *
 * <p>These variables in turn are used to generate responsive media queries in variables like
 * $responsiveQuerySmallUp, $responsiveQueryMediumUp, etc.</p>
 *
 * <p>we send down these media queries as the font family in classes
 * that look something like this:<p>
 *
 * <pre class="prettyprint">
 * <code>
 * .oj-mq-md {
 *    font-family: "/screen and (min-width: 768px)/";
 * }
 * </code></pre>
 *
 * <p>This function applies the class and then reads the font family off a dom
 * element to get the media query string</p>
 *
 * @param {string} selector a class selector name, for example 'oj-mq-md';
 * @return {string} the media query sent down for that class
 * @private
 */

ResponsiveUtils._getMediaQueryFromClass = function (selector) {
  var elem =
  /** @type {(Element | null)} */
  document.getElementsByClassName(selector).item(0);

  if (elem === null) {
    elem = document.createElement('meta');
    elem.className = selector;
    document.head.appendChild(elem); // @HTMLUpdateOK
  }

  var fontFamily = window.getComputedStyle(elem).getPropertyValue('font-family');
  return fontFamily.replace(/^[/\\'"]+|(;\s?})+|[/\\'"]+$/g, '');
};
/**
 * Get a framework (built in) media query string,
 * see {@link oj.ResponsiveUtils.FRAMEWORK_QUERY_KEY} for details on framework queries.
 * The media query string returned can be passed to
 * {@link oj.ResponsiveKnockoutUtils.createMediaQueryObservable} to create a knockout
 * observable, which in turn can be used to drive responsive page behavior.
 *
 * <p>Example:</p>
 * <pre class="prettyprint">
 * <code>
 *
 *     var lgQuery = oj.ResponsiveUtils.getFrameworkQuery(
 *                             oj.ResponsiveUtils.FRAMEWORK_QUERY_KEY.LG_UP);
 *
 *     self.large = oj.ResponsiveKnockoutUtils.createMediaQueryObservable(lgQuery);
 * </code></pre>
 *
 *
 * @method getFrameworkQuery
 * @memberof oj.ResponsiveUtils
 * @param {oj.ResponsiveUtils.FRAMEWORK_QUERY_KEY} frameworkQueryKey one of the FRAMEWORK_QUERY_KEY constants,
 *                       for example oj.ResponsiveUtils.FRAMEWORK_QUERY_KEY.MD_UP
 * @return {string | null} the media query to use for the framework query key passed in
 * @export
 * @static
 */


ResponsiveUtils.getFrameworkQuery = function (frameworkQueryKey) {
  var selector = 'oj-mq-' + frameworkQueryKey;

  var query = ResponsiveUtils._getMediaQueryFromClass(selector);

  if (query === 'null') {
    Logger.warn('Framework query not found. Please check that the value of the theming variable' + '$includeResponsiveMediaQueryClasses is set to true, if it' + 'is set to false the media queries are not sent down to the browser.');
    return null;
  }

  return query;
};
/**
 * <p> Compare can be used in conjunction with
 * {@link oj.ResponsiveKnockoutUtils.createScreenRangeObservable}</p>
 *
 *
 * <p>Example:</p>
 * <pre class="prettyprint">
 * <code>
 *        // create an observable which returns the current screen range
 *        self.screenRange = oj.ResponsiveKnockoutUtils.createScreenRangeObservable();
 *
 *        self.label2 = ko.computed(function() {
 *          var range = self.screenRange();
 *
 *          if ( oj.ResponsiveUtils.compare(
 *                       range, oj.ResponsiveUtils.SCREEN_RANGE.MD) <= 0)
 *          {
 *            // code for when screen is in small or medium range
 *          }
 *          else if (range == oj.ResponsiveUtils.SCREEN_RANGE.XL)
 *          {
 *            // code for when screen is in XL range
 *          }
 *        });
 * </code></pre>
 *
 * @method compare
 * @memberof oj.ResponsiveUtils
 * @param {oj.ResponsiveUtils.SCREEN_RANGE} size1 one of the screen size constants,
 * for example oj.ResponsiveUtils.SCREEN_RANGE.MD
 * @param {oj.ResponsiveUtils.SCREEN_RANGE} size2 one of the screen size constants,
 * for example oj.ResponsiveUtils.SCREEN_RANGE.LG
 * @return {number} a negative integer if the first
 * argument is less than the second. Zero if the two are equal.
 * 1 or greater if the first argument is more than the second.
 *
 * @export
 * @static
 */


ResponsiveUtils.compare = function (size1, size2) {
  var range1 = ResponsiveUtils._RANGE[size1];
  var range2 = ResponsiveUtils._RANGE[size2];

  if (range1 == null) {
    throw new Error('size1 param ' + size1 + ' illegal, please use one of the screen size constants like oj.ResponsiveUtils.SCREEN_RANGE.MD');
  }

  if (range2 == null) {
    throw new Error('size2 param ' + size2 + ' illegal, please use one of the screen size constants like oj.ResponsiveUtils.SCREEN_RANGE.MD');
  }

  return range1 - range2;
};

;return ResponsiveUtils;
});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojthemeutils',['ojs/ojlogger'], function(Logger)
{
  "use strict";


/* jslint browser: true*/

/* global Logger:false */

/**
 * @namespace oj.ThemeUtils
 * @classdesc Services for getting information from the theme
 * @since 1.2.0
 * @ojtsmodule
 * @export
 */
var ThemeUtils = function ThemeUtils() {};
/**
 * get the name of the current theme
 * @method getThemeName
 * @memberof oj.ThemeUtils
 * @export
 * @static
 * @memberof oj.ThemeUtils
 *
 * @return {string|null} the name of the theme
 */


ThemeUtils.getThemeName = function () {
  // get the map of theme info
  var themeMap = ThemeUtils.parseJSONFromFontFamily('oj-theme-json') || {};
  return themeMap.name;
};
/**
 * <p>Get the target platform of the current theme. </p>
 * <p>This API does not look at the user agent and therefore it
 *    tells you nothing about the current platform you are actually on.
 *    Instead it tells you the target platform the theme was written
 *    for so that programmatic behaviors that match the theme's UI can be written.
 *    This can be useful when writing a cross platform hybrid mobile app.  </p>
 *
 * <p>Example</p>
 * <pre class="prettyprint">
 * <code>
 * var themeTargetPlatform = oj.ThemeUtils.getThemeTargetPlatform();
 *
 * if (themeTargetPlatform == 'ios')
 *    // code for a behavior familiar in ios
 * else if (themeTargetPlatform == 'android')
 *    // code for a behavior familiar on android
 * else
 *    // code for the default behavior
 * </code></pre>
 * @export
 * @static
 * @method getThemeTargetPlatform
 * @memberof oj.ThemeUtils
 * @return {string|null} the target platform can be any string the theme
 * wants to send down, but common values are 'all', 'web', 'ios', 'android', 'windows'
 */


ThemeUtils.getThemeTargetPlatform = function () {
  // get the map of theme info
  var themeMap = ThemeUtils.parseJSONFromFontFamily('oj-theme-json') || {};
  return themeMap.targetPlatform;
};
/**
 * clear values cached in  [oj.ThemeUtils.parseJSONFromFontFamily]{@link oj.ThemeUtils.parseJSONFromFontFamily}
 * @export
 * @static
 * @method clearCache
 * @return {void}
 * @memberof oj.ThemeUtils
 */


ThemeUtils.clearCache = function () {
  this._cache = null;
};
/**
 *
 * <p>json can be sent down as the font family in classes
 * that look something like this
 * (on the sass side of things see the file
 * scss/utilities/_oj.utilities.json.scss
 * for information on jet mixins available to generate json):<p>
 *
 * <p>Example CSS</p>
 * <pre class="prettyprint">
 * <code>
 * .demo-map-json {
 *    font-family: '{"foo":"bar", "binky": 4}';
 * }
 *
 * .demo-list-json {
 *    font-family: '["foo","bar","binky"}';
 * }
 * </code></pre>
 * <p>Example Usage</p>
 * <pre class="prettyprint">
 * <code>
 * var mymap = oj.ThemeUtils.parseJSONFromFontFamily("demo-map-json");
 * var myarray = oj.ThemeUtils.parseJSONFromFontFamily("demo-list-json");
 * </code></pre>
 *
 * This function
 * <ul>
 *   <li>Gets the font family string by creating a dom element,
 *      applying the selector passed in, calling getcomputedstyle,
 *      and then reading the value for font-family.
 *   </li>
 *   <li>Parses the font family value by calling JSON.pars.</li>
 *   <li>Caches the parsed value because calling getComputedStyle is a perf hit.
 *       Subsequent requests for the same selector will return the cached value.
 *       Call [oj.ThemeUtils.clearCache]{@link oj.ThemeUtils.clearCache} if new css is loaded.</li>
 *   <li>Return the parsed value.</li>
 * </ul>
 *
 * <p>
 * If new css is loaded call oj.ThemeUtils.clearCache to clear the cache</p>
 *
 * @method parseJSONFromFontFamily
 * @memberof oj.ThemeUtils
 * @param {string} selector a class selector name, for example 'demo-map-json';
 * @return {any} the result of parsing the font family with JSON.parse.
 *      The returned value is cached, so if you modify the returned
 *      value it will be reflected in the cache.
 * @throws {SyntaxError} If JSON.parse throws a SyntaxError exception we will log an error and rethrow
 * @export
 * @static
 */


ThemeUtils.parseJSONFromFontFamily = function (selector) {
  // NOTE: I first tried code inspired by
  // https://css-tricks.com/making-sass-talk-to-javascript-with-json/
  // so I was using :before and content, for example
  //   .oj-button-option-defaults:before {
  //     content: '{"foo":"bar", "binky": 4}';
  //    }
  //
  //  however IE 11 has a bug where the computed style doesn't actually
  //  seem to be computed when it comes to :before,
  //  so if you set a class that affects :before after the page loads
  //  on IE getComputedStyle doesn't work.
  //  See the pen below, the yellow box has the class applied in js,
  //  computedstyle works on chrome, doesn't work on IE11 for
  //  class applied after page load.
  //     http://codepen.io/gabrielle/pen/OVOwev
  // if needed create the cache and initialize some things
  if (this._cache == null) {
    this._cache = {}; // magic value that means null in the cache

    this._null_cache_value = {}; // font family is inherited, so even if no selector/json
    // is sent down we will get a string like
    // 'HelveticaNeue',Helvetica,Arial,sans-serif' off of our generated element.
    // So save off the font family from the head
    // element to compare to what we read off our generated element.

    this._headfontstring = window.getComputedStyle(document.head).getPropertyValue('font-family');
  } // see if we already have a map for this component's option defaults


  var jsonval = this._cache[selector]; // if there's something already cached return it

  if (jsonval === this._null_cache_value) {
    return null;
  } else if (jsonval != null) {
    return jsonval;
  } // there's nothing cached, so we need to create a dom element to apply the class to.
  // We're creating a meta element,
  // the hope is that the browser is smart enough to realize the
  // meta element isn't visible and therefore we avoid perf issues of calling
  // getcomputedstyle


  var elem = document.createElement('meta');
  elem.className = selector;
  document.head.appendChild(elem); // @HTMLUpdateOK

  var rawfontstring = window.getComputedStyle(elem).getPropertyValue('font-family');

  if (rawfontstring != null) {
    // if the raw font string is the same value as the saved header
    // font value then log a warning that no value was sent down.
    if (rawfontstring === this._headfontstring) {
      Logger.warn('parseJSONFromFontFamily: When the selector ', selector, ' is applied the font-family read off the dom element is ', rawfontstring, '. The parent dom elment has the same font-family value.', ' This is interpreted to mean that no value was sent down for selector ', selector, '. Null will be returned.');
    } else {
      // remove inconsistent quotes
      var fontstring = rawfontstring.replace(/^['"]+|\s+|\\|(;\s?})+|['"]$/g, ''); // console.log("json fontstring for selector " + selector + ': ' + fontstring);

      if (fontstring) {
        try {
          jsonval = JSON.parse(fontstring);
        } catch (e) {
          // In Firefox you can turn off the page font
          // Options -> Content -> Fonts and Colors -> Advanced
          // Uncheck the "Allow pages to choose their own fonts, instead of my selections above"
          // In that case they stick something like 'serif,"'at the front of the font family,
          // so search for the first comma, add 2, and try parsing again.
          var commaindex = fontstring.indexOf(',');
          var reparseSuccess = false;

          if (commaindex > -1) {
            fontstring = fontstring.substring(commaindex + 2);

            try {
              jsonval = JSON.parse(fontstring);
              reparseSuccess = true;
            } catch (e2) {// Ignore Error
            }
          }

          if (reparseSuccess === false) {
            Logger.error('Error parsing json for selector ' + selector + '.\nString being parsed is ' + fontstring + '. Error is:\n', e); // remove the meta tag

            document.head.removeChild(elem);
            throw e;
          }
        }
      }
    }
  } // remove the meta tag


  document.head.removeChild(elem); // cache the result

  if (jsonval == null) {
    this._cache[selector] = this._null_cache_value;
  } else {
    this._cache[selector] = jsonval;
  } // console.log(this._cache);


  return jsonval;
};

;return ThemeUtils;
});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojtimerutils',[], function()
{
  "use strict";


/* global Promise:false */

/**
 * Timing related utilities
 * @namespace
 * @name oj.TimerUtils
 * @since 4.1.0
 *
 * @ojtsignore
 */
var TimerUtils = {};
/**
 * A Timer encapsulates a Promise associated with a deferred function execution
 * and the ability to cancel the timer before timeout.
 * @interface Timer
 * @ojtsignore
 */

function Timer() {}
/**
 * Get the Promise assocaited with this timer.  Promise callbacks will be
 * passed a single boolean value indicating if the timer's timeout expired
 * normally (without being canceled/cleared).  If the timer is left to expire
 * after its configured timeout has been exceeded, then it will pass
 * boolean(true) to the callbacks.  If the timer's {@link #clear} method is
 * called before its configured timeout has been reached, then the callbacks
 * will receive boolean(false).
 * @memberof Timer
 * @return {Promise.<boolean>} This timer's Promise
 */


Timer.prototype.getPromise = function () {};
/**
 * Clears the timer and resolves the Promise.  If the normal timeout hasn't
 * yet expired, the value passed to the Promise callbacks will be boolean(false).
 * If the timeout has already expired, this function will do nothing, and all of
 * its Promise callbacks will receive boolean(true).
 * @return {void}
 * @memberof Timer
 */


Timer.prototype.clear = function () {};
/**
 * Get a Timer object with the given timeout in milliseconds.  The Promise
 * associated with the timer is resolved when the timeout window expires, or if
 * the clear() function is called.
 * This is useful for when code needs to be executed on timeout (setTimeout) and
 * must handle cleanup tasks such as clearing {@link BusyState} when the timer
 * expires or is canceled.
 *
 * @param  {number} timeout The timeout value in milliseconds to wait before the
 * promise is resolved.
 * @return {Timer}
 * A Timer object which encapsulates the Promise that will be
 * resolved once the timeout has been exceeded or cleared.
 * @export
 * @memberof oj.TimerUtils
 * @alias getTimer
 * @example <caption>Get a timer to execute code on normal timeout and
 * cancelation.  If the timeout occurs normally (not canceled), both
 * callbacks are executed and the value of the 'completed' parameter will be
 * true.</caption>
 * var timer = oj.TimerUtils.getTimer(1000);
 * timer.getPromise().then(function(completed) {
 *     if (completed) {
 *       // Delayed code
 *     }
 *   })
 * timer.getPromise().then(function() {
 *   // Code always to be run
 * })
 *
 * @example <caption>Get a timer to execute code on normal timeout and cancelation.
 * In this example, the timer is canceled before its timeout expires, and the
 * value of the 'completed' parameter will be false.</caption>
 * var timer = oj.TimerUtils.getTimer(1000);
 * timer.getPromise()
 *   .then(function(completed) {
 *     if (completed) {
 *       // Delayed code
 *     }
 *   })
 * timer.getPromise()
 *   .then(function() {
 *     // Code always to be run
 *   })
 * ...
 * timer.clear(); // timer cleared before timeout expires
 */


TimerUtils.getTimer = function (timeout) {
  return new TimerUtils._TimerImpl(timeout);
};
/**
 * @constructor
 * @implements {Timer}
 * @param  {number} timeout The timeout value in milliseconds.
 * @private
 */


TimerUtils._TimerImpl = function (timeout) {
  var _promise;

  var _resolve;

  var _timerId;

  this.getPromise = function () {
    return _promise;
  };

  this.clear = function () {
    window.clearTimeout(_timerId);
    _timerId = null;

    _timerDone(false);
  };
  /**
   * Called on normal and early timeout (cancelation)
   */


  function _timerDone(completed) {
    _timerId = null;

    _resolve(completed);
  }

  if (typeof window === 'undefined') {
    _promise = Promise.reject();
  } else {
    _promise = new Promise(function (resolve) {
      _resolve = resolve;
      _timerId = window.setTimeout(_timerDone.bind(null, true), timeout); // @HTMLUpdateOK
    });
  }
};

;return TimerUtils;
});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojtranslation',['ojs/ojcore-base', 'ojs/ojconfig'], function(oj, Config)
{
  "use strict";
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }



/* global Config:false */

/**
 * @namespace oj.Translations
 * @classdesc Services for Retrieving Translated Resources
 * @export
 * @since 1.0
 * @ojtsmodule
 * @hideconstructor
 */
var Translations = {};
/**
 * Sets the translation bundle used by JET
 * If an AMD loader (such as Require.js) is not present, this method should be called by the application to provide
 * translated strings for JET.
 * This method may also be used by an application that wants to completely replace the resource bundle that is automatically
 * fetched by an AMD loader.
 * @method setBundle
 * @memberof oj.Translations
 * @param {Object} bundle resource bundle that should be used by the framework
 * @return {void}
 * @export
 */

Translations.setBundle = function (bundle) {
  Translations._bundle = bundle;
};
/**
 * Retrives a translated resource for a given key
 * @method getResource
 * @memberof oj.Translations
 * @param {string} key resource key The dot character (.) within the key string
 * is interpreted as a separator for the name of a sub-section within the bundle.
 * For example, 'components.chart', would be read as the 'chart' section within
 * 'components'. Thus the key name for an individual section should never contain a dot.
 * @return {Object|string|null} resource associated with the key or null if none was found
 * @export
 */


Translations.getResource = function (key) {
  return Translations._getResourceString(key);
};
/**
 * Applies parameters to a format pattern
 * @method applyParameters
 * @memberof oj.Translations
 * @param {string} pattern pattern that may contain tokens like {0}, {1}, {name}. These tokens
 * will be used to define string keys for retrieving values from the parameters
 * object. Token strings should not contain comma (,)
 * or space characters, since they are reserved for future format type enhancements.
 * The reserved characters within a pattern are:
 * $ { } [ ]
 * These characters will not appear in the formatted output unless they are escaped
 * with a dollar character ('$').
 *
 * @param {Object|Array} parameters parameters to be inserted into the string. Both arrays and
 * Javascript objects with string keys are accepted.
 *
 * @return {string|null} formatted message or null if the pattern argument was null
 * @export
 */


Translations.applyParameters = function (pattern, parameters) {
  return pattern == null ? null : Translations._format(pattern, parameters);
};
/**
 * Retrieves a translated string after inserting optional parameters.
 * The method uses a key to retrieve a format pattern from the resource bundle.
 * Tokens like {0}, {1}, {name} within the pattern will be used to define placement
 * for the optional parameters.  Token strings should not contain comma (,)
 * or space characters, since they are reserved for future format type enhancements.
 * The reserved characters within a pattern are:
 * $ { } [ ]
 * These characters will not appear in the formatted output unless they are escaped
 * with a dollar character ('$').
 * @method getTranslatedString
 * @memberof oj.Translations
 * @param {string} key  translations resource key. The dot character (.) within the key string
 * is interpreted as a separator for the name of a sub-section within the bundle.
 * For example, 'components.chart', would be read as the 'chart' section within
 * 'components'. Thus the key name for an individual section should never contain a dot.
 *
 * @param {...(string|Object|Array)} var_args  - optional parameters to be inserted into the
 * translated pattern.
 *
 * If more than one var_args arguments are passed, they will be treated as an array
 * for replacing positional tokens like {0}, {1}, etc.
 * If a single argument is passed, it will be treated as a Javascript Object whose
 * keys will be matched to tokens within the pattern. Note that an Array is just
 * a special kind of such an Object.
 *
 * For backward compatibility, a var_args argument whose type is neither
 * Object or Array will be used to replace {0} in the pattern.
 *
 * @return formatted translated string
 * @ojsignature {target: "Type", for:"returns", value: "string"}
 * @export
 */
// eslint-disable-next-line camelcase, no-unused-vars


Translations.getTranslatedString = function (key, var_args) {
  var val = Translations._getResourceString(key);

  if (val == null) {
    return key;
  }

  var params = {};

  if (arguments.length > 2) {
    params = Array.prototype.slice.call(arguments, 1);
  } else if (arguments.length === 2) {
    params = arguments[1];

    if (_typeof(params) !== 'object' && !(params instanceof Array)) {
      params = [params];
    }
  }

  return Translations.applyParameters(val, params);
};
/**
 * Provides a key-to-value map of the translated resources for a given component name
 * @method getComponentTranslations
 * @memberof oj.Translations
 * @param {string} componentName name of the component
 * @return {Object} a map of translated resources
 * @export
 */


Translations.getComponentTranslations = function (componentName) {
  var bundle = Translations._getBundle()[componentName];

  if (bundle == null) {
    return {};
  } // Assume that the set of keys remains constant regardless of the current locale


  var translations = {};
  var keys = Object.keys(bundle);

  for (var k = 0; k < keys.length; k++) {
    var key = keys[k];
    translations[key] = bundle[key];
  }

  return translations;
};
/**
 * Retrives a translated resource for a given key, accounting for nested keys
 * @param {string} key
 * @return {string|null} resource associated with the key or null if none was found
 * @private
 */


Translations._getResourceString = function (key) {
  // Account for dot separated nested keys
  var keys = key ? key.split('.') : [];

  var bundle = Translations._getBundle();

  oj.Assert.assertObject(bundle); // even though we start with a valid bundle it's possible that part or all of the key is invalid,
  // so check we have a valid bundle in the for loop
  // if we have a key like a.b.c

  for (var index = 0; index < keys.length && bundle != null; index++) {
    var subkey = keys[index];
    bundle = bundle[subkey];
  }

  return bundle != null ? bundle : null;
};

Translations._format = function (formatString, parameters) {
  var formatLength = formatString.length; // Use the javascript StringBuffer technique.

  var buffer = [];
  var token = null;
  var escaped = false;
  var isToken = false;
  var isGroup = false;
  var isExcluded = false;
  var tokenTerminated; // this will be set to true when a comma or space is
  // encountered in teh token

  var i;

  for (i = 0; i < formatLength; i++) {
    var ch = formatString.charAt(i);
    var accumulate = false;

    if (!escaped) {
      switch (ch) {
        case '$':
          escaped = true;
          break;

        case '{':
          if (!isExcluded) {
            if (!isToken) {
              tokenTerminated = false;
              token = [];
            }

            isToken = true;
          }

          break;

        case '}':
          if (isToken && token.length > 0) {
            var val = parameters[token.join('')];
            buffer.push(val === undefined ? 'null' : val);
          }

          isToken = false;
          break;

        case '[':
          if (!isToken) {
            if (isGroup) {
              isExcluded = true;
            } else {
              isGroup = true;
            }
          }

          break;

        case ']':
          if (isExcluded) {
            isExcluded = false;
          } else {
            isGroup = false;
          }

          break;

        default:
          accumulate = true;
      }
    } else {
      accumulate = true;
      escaped = false;
    }

    if (accumulate) {
      if (isToken) {
        if (ch === ',' || ch === ' ') {
          tokenTerminated = true;
        } else if (!tokenTerminated) {
          token.push(ch);
        }
      } else if (!isExcluded) {
        buffer.push(ch);
      }
    }
  } // Use the javascript StringBuffer technique for toString()


  return buffer.join('');
};

Translations._getBundle = function () {
  var b = Translations._bundle;

  if (b) {
    return b;
  }

  if (oj.__isAmdLoaderPresent()) {
    var ojt = Config.getConfigBundle();
    oj.Assert.assert(ojt !== undefined, 'ojtranslations module must be defined');
    return ojt;
  }

  return {};
};

;return Translations;
});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojcore',['require', 'ojs/ojcore-base', 'ojs/ojcontext', 'ojs/ojconfig', 'ojs/ojlogger', 'ojs/ojresponsiveutils', 'ojs/ojthemeutils', 'ojs/ojtimerutils', 'ojs/ojtranslation'], function(require, oj, Context, Config, Logger, ResponsiveUtils, ThemeUtils, TimerUtils, Translations)
{
  "use strict";


/**
 * @ojoverviewdoc ModuleLoadingOverview - [5]JET Module Loading
 * @classdesc
 * {@ojinclude "name":"moduleLoadingOverviewDoc"}
 */

/**
 * <h2 id="usage">Overview
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#overview"></a>
 * </h2>
 * <p>
 *  JET classes and components are delivered via a set of <a href="https://github.com/amdjs/amdjs-api/wiki/AMD">asynchronous module definitions</a> (AMDs or more informally, modules).
 *  JET applications typically use <a href="https://requirejs.org/">RequireJS</a> to load the necessary modules and call API as required.  The values returned from JET modules come in one of three forms:
 * </p>
 * <h4>No return value</h4>
 *  <p>Some modules may not return any value at all.  The purpose of these modules is simply to load the associated JavaScript into memory,
 *     but the application typically does not directly interact with or instantiate this code. For example, modules that define
 *     JET Web Components typically would not have return values.
 *  </p>
 * <pre class="prettyprint"><code>
 * //Loading a JET component in your Typescript code
 *
 * //To typecheck the element APIs, import as below.
 * import {ojAccordion} from "ojs/ojaccordion";
 *
 * //For the transpiled javascript to load the element's module, import as below
 * import "ojs/ojaccordion";</code></pre>
 * <h4>One return value</h4>
 *  <p>Some modules directly return a single object or constructor function.  Applications would typically call functions on the returned
 *     object or instantiate new objects via the constructor function.  For example, the 'ojs/ojcontext' module
 *     has a single return value:
 *  </p>
 * <pre class="prettyprint"><code>
 * //Javascript example
 * define(['ojs/ojcontext'], function(Context) {
 *   var pageContext = Context.getPageContext();
 * })</code></pre>
 * <pre class="prettyprint"><code>
 * //TypeScript example
 * import Context = require('ojs/ojcontext');
 *   let pageContext = Context.getPageContext();
 * </code></pre>
 * <h4>Multiple return values</h4>
 *  <p>Some modules package several objects or constructor functions inside a single JavaScript object.  Applications would typically retrieve the relevant object or constructor function via a
 *     documented property on this object and then either call functions or instantiate new objects as appropriate.  For example, the 'ojs/ojattributegrouphandler' module has multiple return values.
 *  </p>
 * <pre class="prettyprint"><code>
 * //TypeScript example
 * import {ColorAttributeGroupHandler, ShapeAttributeGroupHandler} from "ojs/ojattributegrouphandler";
 *  let colorHandler = new ColorAttributeGroupHandler();
 *  let shapeHandler = new ShapeAttributeGroupHandler({'0-2 years': 'triangleDown',
 *                                                     '3-5 years': 'circle',
 *                                                     '6+ years': 'triangleUp'});
 *  var getLegendData = function(data, colorHandler) {
 *     var items = [];
 *     for (var i = 0; i < data.length; i++)
 *     {
 *       items.push({
 *         value: data[i].value,
 *         text: data[i].category,
 *         color: colorHandler.getValue(data[i].category),
 *       });
 *     }
 *     return [{items: items}];
 *   };
 *
 * //Another example
 * import * as Logger from "ojs/ojlogger";
 *  Logger.log("Please enter a valid input");
 * </code></pre>
 *
 * @ojfragment moduleLoadingOverviewDoc
 * @memberof ModuleLoadingOverview
 */



/* global Logger:false, Context:false, Config:false, ResponsiveUtils:false, ThemeUtils:false, TimerUtils:false, Translations:false */
oj.Logger = Logger;
oj.Context = Context;
oj.Config = Config;
oj.ResponsiveUtils = ResponsiveUtils;
oj.ThemeUtils = ThemeUtils;
oj.TimerUtils = TimerUtils;
oj.Translations = Translations;

;return oj;
});
/*! Hammer.JS - v2.0.8 - 2016-04-23
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
!function(a,b,c,d){"use strict";function e(a,b,c){return setTimeout(j(a,c),b)}function f(a,b,c){return Array.isArray(a)?(g(a,c[b],c),!0):!1}function g(a,b,c){var e;if(a)if(a.forEach)a.forEach(b,c);else if(a.length!==d)for(e=0;e<a.length;)b.call(c,a[e],e,a),e++;else for(e in a)a.hasOwnProperty(e)&&b.call(c,a[e],e,a)}function h(b,c,d){var e="DEPRECATED METHOD: "+c+"\n"+d+" AT \n";return function(){var c=new Error("get-stack-trace"),d=c&&c.stack?c.stack.replace(/^[^\(]+?[\n$]/gm,"").replace(/^\s+at\s+/gm,"").replace(/^Object.<anonymous>\s*\(/gm,"{anonymous}()@"):"Unknown Stack Trace",f=a.console&&(a.console.warn||a.console.log);return f&&f.call(a.console,e,d),b.apply(this,arguments)}}function i(a,b,c){var d,e=b.prototype;d=a.prototype=Object.create(e),d.constructor=a,d._super=e,c&&la(d,c)}function j(a,b){return function(){return a.apply(b,arguments)}}function k(a,b){return typeof a==oa?a.apply(b?b[0]||d:d,b):a}function l(a,b){return a===d?b:a}function m(a,b,c){g(q(b),function(b){a.addEventListener(b,c,!1)})}function n(a,b,c){g(q(b),function(b){a.removeEventListener(b,c,!1)})}function o(a,b){for(;a;){if(a==b)return!0;a=a.parentNode}return!1}function p(a,b){return a.indexOf(b)>-1}function q(a){return a.trim().split(/\s+/g)}function r(a,b,c){if(a.indexOf&&!c)return a.indexOf(b);for(var d=0;d<a.length;){if(c&&a[d][c]==b||!c&&a[d]===b)return d;d++}return-1}function s(a){return Array.prototype.slice.call(a,0)}function t(a,b,c){for(var d=[],e=[],f=0;f<a.length;){var g=b?a[f][b]:a[f];r(e,g)<0&&d.push(a[f]),e[f]=g,f++}return c&&(d=b?d.sort(function(a,c){return a[b]>c[b]}):d.sort()),d}function u(a,b){for(var c,e,f=b[0].toUpperCase()+b.slice(1),g=0;g<ma.length;){if(c=ma[g],e=c?c+f:b,e in a)return e;g++}return d}function v(){return ua++}function w(b){var c=b.ownerDocument||b;return c.defaultView||c.parentWindow||a}function x(a,b){var c=this;this.manager=a,this.callback=b,this.element=a.element,this.target=a.options.inputTarget,this.domHandler=function(b){k(a.options.enable,[a])&&c.handler(b)},this.init()}function y(a){var b,c=a.options.inputClass;return new(b=c?c:xa?M:ya?P:wa?R:L)(a,z)}function z(a,b,c){var d=c.pointers.length,e=c.changedPointers.length,f=b&Ea&&d-e===0,g=b&(Ga|Ha)&&d-e===0;c.isFirst=!!f,c.isFinal=!!g,f&&(a.session={}),c.eventType=b,A(a,c),a.emit("hammer.input",c),a.recognize(c),a.session.prevInput=c}function A(a,b){var c=a.session,d=b.pointers,e=d.length;c.firstInput||(c.firstInput=D(b)),e>1&&!c.firstMultiple?c.firstMultiple=D(b):1===e&&(c.firstMultiple=!1);var f=c.firstInput,g=c.firstMultiple,h=g?g.center:f.center,i=b.center=E(d);b.timeStamp=ra(),b.deltaTime=b.timeStamp-f.timeStamp,b.angle=I(h,i),b.distance=H(h,i),B(c,b),b.offsetDirection=G(b.deltaX,b.deltaY);var j=F(b.deltaTime,b.deltaX,b.deltaY);b.overallVelocityX=j.x,b.overallVelocityY=j.y,b.overallVelocity=qa(j.x)>qa(j.y)?j.x:j.y,b.scale=g?K(g.pointers,d):1,b.rotation=g?J(g.pointers,d):0,b.maxPointers=c.prevInput?b.pointers.length>c.prevInput.maxPointers?b.pointers.length:c.prevInput.maxPointers:b.pointers.length,C(c,b);var k=a.element;o(b.srcEvent.target,k)&&(k=b.srcEvent.target),b.target=k}function B(a,b){var c=b.center,d=a.offsetDelta||{},e=a.prevDelta||{},f=a.prevInput||{};b.eventType!==Ea&&f.eventType!==Ga||(e=a.prevDelta={x:f.deltaX||0,y:f.deltaY||0},d=a.offsetDelta={x:c.x,y:c.y}),b.deltaX=e.x+(c.x-d.x),b.deltaY=e.y+(c.y-d.y)}function C(a,b){var c,e,f,g,h=a.lastInterval||b,i=b.timeStamp-h.timeStamp;if(b.eventType!=Ha&&(i>Da||h.velocity===d)){var j=b.deltaX-h.deltaX,k=b.deltaY-h.deltaY,l=F(i,j,k);e=l.x,f=l.y,c=qa(l.x)>qa(l.y)?l.x:l.y,g=G(j,k),a.lastInterval=b}else c=h.velocity,e=h.velocityX,f=h.velocityY,g=h.direction;b.velocity=c,b.velocityX=e,b.velocityY=f,b.direction=g}function D(a){for(var b=[],c=0;c<a.pointers.length;)b[c]={clientX:pa(a.pointers[c].clientX),clientY:pa(a.pointers[c].clientY)},c++;return{timeStamp:ra(),pointers:b,center:E(b),deltaX:a.deltaX,deltaY:a.deltaY}}function E(a){var b=a.length;if(1===b)return{x:pa(a[0].clientX),y:pa(a[0].clientY)};for(var c=0,d=0,e=0;b>e;)c+=a[e].clientX,d+=a[e].clientY,e++;return{x:pa(c/b),y:pa(d/b)}}function F(a,b,c){return{x:b/a||0,y:c/a||0}}function G(a,b){return a===b?Ia:qa(a)>=qa(b)?0>a?Ja:Ka:0>b?La:Ma}function H(a,b,c){c||(c=Qa);var d=b[c[0]]-a[c[0]],e=b[c[1]]-a[c[1]];return Math.sqrt(d*d+e*e)}function I(a,b,c){c||(c=Qa);var d=b[c[0]]-a[c[0]],e=b[c[1]]-a[c[1]];return 180*Math.atan2(e,d)/Math.PI}function J(a,b){return I(b[1],b[0],Ra)+I(a[1],a[0],Ra)}function K(a,b){return H(b[0],b[1],Ra)/H(a[0],a[1],Ra)}function L(){this.evEl=Ta,this.evWin=Ua,this.pressed=!1,x.apply(this,arguments)}function M(){this.evEl=Xa,this.evWin=Ya,x.apply(this,arguments),this.store=this.manager.session.pointerEvents=[]}function N(){this.evTarget=$a,this.evWin=_a,this.started=!1,x.apply(this,arguments)}function O(a,b){var c=s(a.touches),d=s(a.changedTouches);return b&(Ga|Ha)&&(c=t(c.concat(d),"identifier",!0)),[c,d]}function P(){this.evTarget=bb,this.targetIds={},x.apply(this,arguments)}function Q(a,b){var c=s(a.touches),d=this.targetIds;if(b&(Ea|Fa)&&1===c.length)return d[c[0].identifier]=!0,[c,c];var e,f,g=s(a.changedTouches),h=[],i=this.target;if(f=c.filter(function(a){return o(a.target,i)}),b===Ea)for(e=0;e<f.length;)d[f[e].identifier]=!0,e++;for(e=0;e<g.length;)d[g[e].identifier]&&h.push(g[e]),b&(Ga|Ha)&&delete d[g[e].identifier],e++;return h.length?[t(f.concat(h),"identifier",!0),h]:void 0}function R(){x.apply(this,arguments);var a=j(this.handler,this);this.touch=new P(this.manager,a),this.mouse=new L(this.manager,a),this.primaryTouch=null,this.lastTouches=[]}function S(a,b){a&Ea?(this.primaryTouch=b.changedPointers[0].identifier,T.call(this,b)):a&(Ga|Ha)&&T.call(this,b)}function T(a){var b=a.changedPointers[0];if(b.identifier===this.primaryTouch){var c={x:b.clientX,y:b.clientY};this.lastTouches.push(c);var d=this.lastTouches,e=function(){var a=d.indexOf(c);a>-1&&d.splice(a,1)};setTimeout(e,cb)}}function U(a){for(var b=a.srcEvent.clientX,c=a.srcEvent.clientY,d=0;d<this.lastTouches.length;d++){var e=this.lastTouches[d],f=Math.abs(b-e.x),g=Math.abs(c-e.y);if(db>=f&&db>=g)return!0}return!1}function V(a,b){this.manager=a,this.set(b)}function W(a){if(p(a,jb))return jb;var b=p(a,kb),c=p(a,lb);return b&&c?jb:b||c?b?kb:lb:p(a,ib)?ib:hb}function X(){if(!fb)return!1;var b={},c=a.CSS&&a.CSS.supports;return["auto","manipulation","pan-y","pan-x","pan-x pan-y","none"].forEach(function(d){b[d]=c?a.CSS.supports("touch-action",d):!0}),b}function Y(a){this.options=la({},this.defaults,a||{}),this.id=v(),this.manager=null,this.options.enable=l(this.options.enable,!0),this.state=nb,this.simultaneous={},this.requireFail=[]}function Z(a){return a&sb?"cancel":a&qb?"end":a&pb?"move":a&ob?"start":""}function $(a){return a==Ma?"down":a==La?"up":a==Ja?"left":a==Ka?"right":""}function _(a,b){var c=b.manager;return c?c.get(a):a}function aa(){Y.apply(this,arguments)}function ba(){aa.apply(this,arguments),this.pX=null,this.pY=null}function ca(){aa.apply(this,arguments)}function da(){Y.apply(this,arguments),this._timer=null,this._input=null}function ea(){aa.apply(this,arguments)}function fa(){aa.apply(this,arguments)}function ga(){Y.apply(this,arguments),this.pTime=!1,this.pCenter=!1,this._timer=null,this._input=null,this.count=0}function ha(a,b){return b=b||{},b.recognizers=l(b.recognizers,ha.defaults.preset),new ia(a,b)}function ia(a,b){this.options=la({},ha.defaults,b||{}),this.options.inputTarget=this.options.inputTarget||a,this.handlers={},this.session={},this.recognizers=[],this.oldCssProps={},this.element=a,this.input=y(this),this.touchAction=new V(this,this.options.touchAction),ja(this,!0),g(this.options.recognizers,function(a){var b=this.add(new a[0](a[1]));a[2]&&b.recognizeWith(a[2]),a[3]&&b.requireFailure(a[3])},this)}function ja(a,b){var c=a.element;if(c.style){var d;g(a.options.cssProps,function(e,f){d=u(c.style,f),b?(a.oldCssProps[d]=c.style[d],c.style[d]=e):c.style[d]=a.oldCssProps[d]||""}),b||(a.oldCssProps={})}}function ka(a,c){var d=b.createEvent("Event");d.initEvent(a,!0,!0),d.gesture=c,c.target.dispatchEvent(d)}var la,ma=["","webkit","Moz","MS","ms","o"],na=b.createElement("div"),oa="function",pa=Math.round,qa=Math.abs,ra=Date.now;la="function"!=typeof Object.assign?function(a){if(a===d||null===a)throw new TypeError("Cannot convert undefined or null to object");for(var b=Object(a),c=1;c<arguments.length;c++){var e=arguments[c];if(e!==d&&null!==e)for(var f in e)e.hasOwnProperty(f)&&(b[f]=e[f])}return b}:Object.assign;var sa=h(function(a,b,c){for(var e=Object.keys(b),f=0;f<e.length;)(!c||c&&a[e[f]]===d)&&(a[e[f]]=b[e[f]]),f++;return a},"extend","Use `assign`."),ta=h(function(a,b){return sa(a,b,!0)},"merge","Use `assign`."),ua=1,va=/mobile|tablet|ip(ad|hone|od)|android/i,wa="ontouchstart"in a,xa=u(a,"PointerEvent")!==d,ya=wa&&va.test(navigator.userAgent),za="touch",Aa="pen",Ba="mouse",Ca="kinect",Da=25,Ea=1,Fa=2,Ga=4,Ha=8,Ia=1,Ja=2,Ka=4,La=8,Ma=16,Na=Ja|Ka,Oa=La|Ma,Pa=Na|Oa,Qa=["x","y"],Ra=["clientX","clientY"];x.prototype={handler:function(){},init:function(){this.evEl&&m(this.element,this.evEl,this.domHandler),this.evTarget&&m(this.target,this.evTarget,this.domHandler),this.evWin&&m(w(this.element),this.evWin,this.domHandler)},destroy:function(){this.evEl&&n(this.element,this.evEl,this.domHandler),this.evTarget&&n(this.target,this.evTarget,this.domHandler),this.evWin&&n(w(this.element),this.evWin,this.domHandler)}};var Sa={mousedown:Ea,mousemove:Fa,mouseup:Ga},Ta="mousedown",Ua="mousemove mouseup";i(L,x,{handler:function(a){var b=Sa[a.type];b&Ea&&0===a.button&&(this.pressed=!0),b&Fa&&1!==a.which&&(b=Ga),this.pressed&&(b&Ga&&(this.pressed=!1),this.callback(this.manager,b,{pointers:[a],changedPointers:[a],pointerType:Ba,srcEvent:a}))}});var Va={pointerdown:Ea,pointermove:Fa,pointerup:Ga,pointercancel:Ha,pointerout:Ha},Wa={2:za,3:Aa,4:Ba,5:Ca},Xa="pointerdown",Ya="pointermove pointerup pointercancel";a.MSPointerEvent&&!a.PointerEvent&&(Xa="MSPointerDown",Ya="MSPointerMove MSPointerUp MSPointerCancel"),i(M,x,{handler:function(a){var b=this.store,c=!1,d=a.type.toLowerCase().replace("ms",""),e=Va[d],f=Wa[a.pointerType]||a.pointerType,g=f==za,h=r(b,a.pointerId,"pointerId");e&Ea&&(0===a.button||g)?0>h&&(b.push(a),h=b.length-1):e&(Ga|Ha)&&(c=!0),0>h||(b[h]=a,this.callback(this.manager,e,{pointers:b,changedPointers:[a],pointerType:f,srcEvent:a}),c&&b.splice(h,1))}});var Za={touchstart:Ea,touchmove:Fa,touchend:Ga,touchcancel:Ha},$a="touchstart",_a="touchstart touchmove touchend touchcancel";i(N,x,{handler:function(a){var b=Za[a.type];if(b===Ea&&(this.started=!0),this.started){var c=O.call(this,a,b);b&(Ga|Ha)&&c[0].length-c[1].length===0&&(this.started=!1),this.callback(this.manager,b,{pointers:c[0],changedPointers:c[1],pointerType:za,srcEvent:a})}}});var ab={touchstart:Ea,touchmove:Fa,touchend:Ga,touchcancel:Ha},bb="touchstart touchmove touchend touchcancel";i(P,x,{handler:function(a){var b=ab[a.type],c=Q.call(this,a,b);c&&this.callback(this.manager,b,{pointers:c[0],changedPointers:c[1],pointerType:za,srcEvent:a})}});var cb=2500,db=25;i(R,x,{handler:function(a,b,c){var d=c.pointerType==za,e=c.pointerType==Ba;if(!(e&&c.sourceCapabilities&&c.sourceCapabilities.firesTouchEvents)){if(d)S.call(this,b,c);else if(e&&U.call(this,c))return;this.callback(a,b,c)}},destroy:function(){this.touch.destroy(),this.mouse.destroy()}});var eb=u(na.style,"touchAction"),fb=eb!==d,gb="compute",hb="auto",ib="manipulation",jb="none",kb="pan-x",lb="pan-y",mb=X();V.prototype={set:function(a){a==gb&&(a=this.compute()),fb&&this.manager.element.style&&mb[a]&&(this.manager.element.style[eb]=a),this.actions=a.toLowerCase().trim()},update:function(){this.set(this.manager.options.touchAction)},compute:function(){var a=[];return g(this.manager.recognizers,function(b){k(b.options.enable,[b])&&(a=a.concat(b.getTouchAction()))}),W(a.join(" "))},preventDefaults:function(a){var b=a.srcEvent,c=a.offsetDirection;if(this.manager.session.prevented)return void b.preventDefault();var d=this.actions,e=p(d,jb)&&!mb[jb],f=p(d,lb)&&!mb[lb],g=p(d,kb)&&!mb[kb];if(e){var h=1===a.pointers.length,i=a.distance<2,j=a.deltaTime<250;if(h&&i&&j)return}return g&&f?void 0:e||f&&c&Na||g&&c&Oa?this.preventSrc(b):void 0},preventSrc:function(a){this.manager.session.prevented=!0,a.preventDefault()}};var nb=1,ob=2,pb=4,qb=8,rb=qb,sb=16,tb=32;Y.prototype={defaults:{},set:function(a){return la(this.options,a),this.manager&&this.manager.touchAction.update(),this},recognizeWith:function(a){if(f(a,"recognizeWith",this))return this;var b=this.simultaneous;return a=_(a,this),b[a.id]||(b[a.id]=a,a.recognizeWith(this)),this},dropRecognizeWith:function(a){return f(a,"dropRecognizeWith",this)?this:(a=_(a,this),delete this.simultaneous[a.id],this)},requireFailure:function(a){if(f(a,"requireFailure",this))return this;var b=this.requireFail;return a=_(a,this),-1===r(b,a)&&(b.push(a),a.requireFailure(this)),this},dropRequireFailure:function(a){if(f(a,"dropRequireFailure",this))return this;a=_(a,this);var b=r(this.requireFail,a);return b>-1&&this.requireFail.splice(b,1),this},hasRequireFailures:function(){return this.requireFail.length>0},canRecognizeWith:function(a){return!!this.simultaneous[a.id]},emit:function(a){function b(b){c.manager.emit(b,a)}var c=this,d=this.state;qb>d&&b(c.options.event+Z(d)),b(c.options.event),a.additionalEvent&&b(a.additionalEvent),d>=qb&&b(c.options.event+Z(d))},tryEmit:function(a){return this.canEmit()?this.emit(a):void(this.state=tb)},canEmit:function(){for(var a=0;a<this.requireFail.length;){if(!(this.requireFail[a].state&(tb|nb)))return!1;a++}return!0},recognize:function(a){var b=la({},a);return k(this.options.enable,[this,b])?(this.state&(rb|sb|tb)&&(this.state=nb),this.state=this.process(b),void(this.state&(ob|pb|qb|sb)&&this.tryEmit(b))):(this.reset(),void(this.state=tb))},process:function(a){},getTouchAction:function(){},reset:function(){}},i(aa,Y,{defaults:{pointers:1},attrTest:function(a){var b=this.options.pointers;return 0===b||a.pointers.length===b},process:function(a){var b=this.state,c=a.eventType,d=b&(ob|pb),e=this.attrTest(a);return d&&(c&Ha||!e)?b|sb:d||e?c&Ga?b|qb:b&ob?b|pb:ob:tb}}),i(ba,aa,{defaults:{event:"pan",threshold:10,pointers:1,direction:Pa},getTouchAction:function(){var a=this.options.direction,b=[];return a&Na&&b.push(lb),a&Oa&&b.push(kb),b},directionTest:function(a){var b=this.options,c=!0,d=a.distance,e=a.direction,f=a.deltaX,g=a.deltaY;return e&b.direction||(b.direction&Na?(e=0===f?Ia:0>f?Ja:Ka,c=f!=this.pX,d=Math.abs(a.deltaX)):(e=0===g?Ia:0>g?La:Ma,c=g!=this.pY,d=Math.abs(a.deltaY))),a.direction=e,c&&d>b.threshold&&e&b.direction},attrTest:function(a){return aa.prototype.attrTest.call(this,a)&&(this.state&ob||!(this.state&ob)&&this.directionTest(a))},emit:function(a){this.pX=a.deltaX,this.pY=a.deltaY;var b=$(a.direction);b&&(a.additionalEvent=this.options.event+b),this._super.emit.call(this,a)}}),i(ca,aa,{defaults:{event:"pinch",threshold:0,pointers:2},getTouchAction:function(){return[jb]},attrTest:function(a){return this._super.attrTest.call(this,a)&&(Math.abs(a.scale-1)>this.options.threshold||this.state&ob)},emit:function(a){if(1!==a.scale){var b=a.scale<1?"in":"out";a.additionalEvent=this.options.event+b}this._super.emit.call(this,a)}}),i(da,Y,{defaults:{event:"press",pointers:1,time:251,threshold:9},getTouchAction:function(){return[hb]},process:function(a){var b=this.options,c=a.pointers.length===b.pointers,d=a.distance<b.threshold,f=a.deltaTime>b.time;if(this._input=a,!d||!c||a.eventType&(Ga|Ha)&&!f)this.reset();else if(a.eventType&Ea)this.reset(),this._timer=e(function(){this.state=rb,this.tryEmit()},b.time,this);else if(a.eventType&Ga)return rb;return tb},reset:function(){clearTimeout(this._timer)},emit:function(a){this.state===rb&&(a&&a.eventType&Ga?this.manager.emit(this.options.event+"up",a):(this._input.timeStamp=ra(),this.manager.emit(this.options.event,this._input)))}}),i(ea,aa,{defaults:{event:"rotate",threshold:0,pointers:2},getTouchAction:function(){return[jb]},attrTest:function(a){return this._super.attrTest.call(this,a)&&(Math.abs(a.rotation)>this.options.threshold||this.state&ob)}}),i(fa,aa,{defaults:{event:"swipe",threshold:10,velocity:.3,direction:Na|Oa,pointers:1},getTouchAction:function(){return ba.prototype.getTouchAction.call(this)},attrTest:function(a){var b,c=this.options.direction;return c&(Na|Oa)?b=a.overallVelocity:c&Na?b=a.overallVelocityX:c&Oa&&(b=a.overallVelocityY),this._super.attrTest.call(this,a)&&c&a.offsetDirection&&a.distance>this.options.threshold&&a.maxPointers==this.options.pointers&&qa(b)>this.options.velocity&&a.eventType&Ga},emit:function(a){var b=$(a.offsetDirection);b&&this.manager.emit(this.options.event+b,a),this.manager.emit(this.options.event,a)}}),i(ga,Y,{defaults:{event:"tap",pointers:1,taps:1,interval:300,time:250,threshold:9,posThreshold:10},getTouchAction:function(){return[ib]},process:function(a){var b=this.options,c=a.pointers.length===b.pointers,d=a.distance<b.threshold,f=a.deltaTime<b.time;if(this.reset(),a.eventType&Ea&&0===this.count)return this.failTimeout();if(d&&f&&c){if(a.eventType!=Ga)return this.failTimeout();var g=this.pTime?a.timeStamp-this.pTime<b.interval:!0,h=!this.pCenter||H(this.pCenter,a.center)<b.posThreshold;this.pTime=a.timeStamp,this.pCenter=a.center,h&&g?this.count+=1:this.count=1,this._input=a;var i=this.count%b.taps;if(0===i)return this.hasRequireFailures()?(this._timer=e(function(){this.state=rb,this.tryEmit()},b.interval,this),ob):rb}return tb},failTimeout:function(){return this._timer=e(function(){this.state=tb},this.options.interval,this),tb},reset:function(){clearTimeout(this._timer)},emit:function(){this.state==rb&&(this._input.tapCount=this.count,this.manager.emit(this.options.event,this._input))}}),ha.VERSION="2.0.8",ha.defaults={domEvents:!1,touchAction:gb,enable:!0,inputTarget:null,inputClass:null,preset:[[ea,{enable:!1}],[ca,{enable:!1},["rotate"]],[fa,{direction:Na}],[ba,{direction:Na},["swipe"]],[ga],[ga,{event:"doubletap",taps:2},["tap"]],[da]],cssProps:{userSelect:"none",touchSelect:"none",touchCallout:"none",contentZooming:"none",userDrag:"none",tapHighlightColor:"rgba(0,0,0,0)"}};var ub=1,vb=2;ia.prototype={set:function(a){return la(this.options,a),a.touchAction&&this.touchAction.update(),a.inputTarget&&(this.input.destroy(),this.input.target=a.inputTarget,this.input.init()),this},stop:function(a){this.session.stopped=a?vb:ub},recognize:function(a){var b=this.session;if(!b.stopped){this.touchAction.preventDefaults(a);var c,d=this.recognizers,e=b.curRecognizer;(!e||e&&e.state&rb)&&(e=b.curRecognizer=null);for(var f=0;f<d.length;)c=d[f],b.stopped===vb||e&&c!=e&&!c.canRecognizeWith(e)?c.reset():c.recognize(a),!e&&c.state&(ob|pb|qb)&&(e=b.curRecognizer=c),f++}},get:function(a){if(a instanceof Y)return a;for(var b=this.recognizers,c=0;c<b.length;c++)if(b[c].options.event==a)return b[c];return null},add:function(a){if(f(a,"add",this))return this;var b=this.get(a.options.event);return b&&this.remove(b),this.recognizers.push(a),a.manager=this,this.touchAction.update(),a},remove:function(a){if(f(a,"remove",this))return this;if(a=this.get(a)){var b=this.recognizers,c=r(b,a);-1!==c&&(b.splice(c,1),this.touchAction.update())}return this},on:function(a,b){if(a!==d&&b!==d){var c=this.handlers;return g(q(a),function(a){c[a]=c[a]||[],c[a].push(b)}),this}},off:function(a,b){if(a!==d){var c=this.handlers;return g(q(a),function(a){b?c[a]&&c[a].splice(r(c[a],b),1):delete c[a]}),this}},emit:function(a,b){this.options.domEvents&&ka(a,b);var c=this.handlers[a]&&this.handlers[a].slice();if(c&&c.length){b.type=a,b.preventDefault=function(){b.srcEvent.preventDefault()};for(var d=0;d<c.length;)c[d](b),d++}},destroy:function(){this.element&&ja(this,!1),this.handlers={},this.session={},this.input.destroy(),this.element=null}},la(ha,{INPUT_START:Ea,INPUT_MOVE:Fa,INPUT_END:Ga,INPUT_CANCEL:Ha,STATE_POSSIBLE:nb,STATE_BEGAN:ob,STATE_CHANGED:pb,STATE_ENDED:qb,STATE_RECOGNIZED:rb,STATE_CANCELLED:sb,STATE_FAILED:tb,DIRECTION_NONE:Ia,DIRECTION_LEFT:Ja,DIRECTION_RIGHT:Ka,DIRECTION_UP:La,DIRECTION_DOWN:Ma,DIRECTION_HORIZONTAL:Na,DIRECTION_VERTICAL:Oa,DIRECTION_ALL:Pa,Manager:ia,Input:x,TouchAction:V,TouchInput:P,MouseInput:L,PointerEventInput:M,TouchMouseInput:R,SingleTouchInput:N,Recognizer:Y,AttrRecognizer:aa,Tap:ga,Pan:ba,Swipe:fa,Pinch:ca,Rotate:ea,Press:da,on:m,off:n,each:g,merge:ta,extend:sa,assign:la,inherit:i,bindFn:j,prefixed:u});var wb="undefined"!=typeof a?a:"undefined"!=typeof self?self:{};wb.Hammer=ha,"function"==typeof define&&define.amd?define('hammerjs',[],function(){return ha}):"undefined"!=typeof module&&module.exports?module.exports=ha:a[c]=ha}(window,document,"Hammer");

/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojjquery-hammer',['ojs/ojcore', 'jquery', 'hammerjs', 'ojs/ojlogger'], function(oj, $, Hammer, Logger) 
{
  "use strict";

// Forked from Version 2.0.0 of https://github.com/hammerjs/jquery.hammer.js, retrieved 2/4/2015.

/* global Hammer:false, Logger:false */
if (Hammer) {
  /** @export */
  $.fn.ojHammer = function (options) {
    switch (options) {
      // $(...).ojHammer("instance") returns the Hammer instance previously instantiated on this element via $(...).ojHammer(options), or undefined if none.
      case 'instance':
        return this.data('ojHammer');
      // $(...).ojHammer("destroy") destroys the Hammer instance and removes it from the node's data store.

      case 'destroy':
        return this.each(function () {
          var $el = $(this);
          var hammer = $el.data('ojHammer');

          if (hammer) {
            hammer.destroy();
            $el.removeData('ojHammer');
          }
        });

      default:
        // $(...).ojHammer(options) instantiates Hammer on this element, and stores it for later retrieval via $(...).ojHammer("instance")
        return this.each(function () {
          var $el = $(this);

          if (!$el.data('ojHammer')) {
            $el.data('ojHammer', new Hammer.Manager($el[0], options));
          }
        });
    }
  }; // extend the emit method to also trigger jQuery events


  Hammer.Manager.prototype.emit = function (originalEmit) {
    return function (type, data) {
      originalEmit.call(this, type, data);
      $(this.element).trigger({
        type: type,
        gesture: data
      });
    };
  }(Hammer.Manager.prototype.emit);
} else {
  Logger.warn('Hammer jQuery extension loaded without Hammer.');
}

});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojmessaging',['ojs/ojcore', 'jquery'], function(oj, $)
{
  "use strict";


/**
 * Constructs a message object.
 * <p><strong>NOTE:</strong>  Instead of using the constructor, please use an Object
 * that duck-types oj.Message - has summary, detail, and severity properties.
 * Creating an oj.Message Object provides no additional value than
 * the duck-typed Object.
 * </p>
 * @param {string} summary - Localized summary message text
 * @param {string} detail - Localized detail message text
 * @param {(number|string)=} severity - An optional severity for this message. Use constants
 * oj.Message.SEVERITY_LEVEL for number types and oj.Message.SEVERITY_TYPE for string types. Default
 * is SEVERITY_ERROR if no severity is specified
 * @constructor
 * @final
 * @ojtsmodule
 * @export
 * @since 0.6.0
 * @example <caption>Set application messages using the
 * <code class="prettyprint">messages-custom</code> attribute. This example creates messages
 * the recommended way, by creating an Object that duck-types oj.Message.</caption>
 * --- HTML ---
 * &lt;oj-input-text messages-custom="{{appMessages}}");>&lt;/oj-input-text>
 *
 * --- Javascript ---
 * // for messagesCustom property
 * self.appMessages = ko.observable();
 * var msgs = [];
 * msgs.push({summary: "Error Summary", detail: "Error Detail",
 *  severity: oj.Message.SEVERITY_TYPE['CONFIRMATION']});
 * self.appMessages(msgs);
 * @ojsignature [{target: "Type",
 *                value: "oj.Message.SEVERITY_TYPE| oj.Message.SEVERITY_LEVEL",
 *                for: "severity"}]
 */
oj.Message = function (summary, detail, severity) {
  this.Init(summary, detail, severity);
};
/**
 * Indicates the type of severity that the message represents.
 * @enum {string}
 * @export
 */


oj.Message.SEVERITY_TYPE = {
  /**
   * Indicates a confirmation that an operation or task was completed. This is the lowest severity
   * level.
   */
  CONFIRMATION: 'confirmation',

  /**
   * Indicates information or operation messages. This has a lower severity level than warning.
   */
  INFO: 'info',

  /**
   * Indicates an application condition or situation that might require users' attention. This has a
   * lower severity than error.
   */
  WARNING: 'warning',

  /**
   * Used when data inaccuracies occur when completing a field and that needs fixing before user can
   * continue. This has a lower severity level than fatal.
   * fatal.
   */
  ERROR: 'error',

  /**
   * Used when a critical application error or an unknown failure occurs. This is the highest
   * severity level.
   * @const
   * @export
   */
  FATAL: 'fatal'
};
/**
 * Message severity level
 * @enum {number}
 * @export
 */

oj.Message.SEVERITY_LEVEL = {
  FATAL: 5,
  ERROR: 4,
  WARNING: 3,
  INFO: 2,
  CONFIRMATION: 1
}; // Subclass from oj.Object

oj.Object.createSubclass(oj.Message, oj.Object, 'oj.Message');
/**
 * Localized summary text.
 *
 * @member
 * @name summary
 * @memberof oj.Message
 * @instance
 * @type {string}
 * @default ""
 */

/**
 * Localized detail text.
 *
 * @member
 * @name detail
 * @memberof oj.Message
 * @instance
 * @type {string}
 * @default ""
 */

/**
 * Severity type of message. See oj.Message.SEVERITY_TYPE for string types and oj.Message.SEVERITY_LEVEL for number types.
 *
 * @member
 * @name severity
 * @memberof oj.Message
 * @instance
 * @type {string|number}
 * @ojsignature [{target: "Type",
 *                value: "oj.Message.SEVERITY_TYPE| oj.Message.SEVERITY_LEVEL"}]
 * @default oj.Message.SEVERITY_TYPE.ERROR
 */

/**
 * Initializes Message instance with the set options
 * @param {string} summary a localized summary message text
 * @param {string} detail a localized detail message text
 * @param {number|string=} severity - An optional severity for this message.  Use constants
 * oj.Message.SEVERITY_LEVEL for number types and oj.Message.SEVERITY_TYPE for string types.
 *
 * @export
 * @ignore
 */

oj.Message.prototype.Init = function (summary, detail, severity) {
  oj.Message.superclass.Init.call(this);
  this.summary = summary;
  this.detail = detail;
  this.severity = severity || oj.Message.SEVERITY_TYPE.ERROR; // defaults to ERROR
};
/**
 * A convenience method that returns the severity level when given either a severity level of type
 * number or a severity type of string.
 * If severity level is not provided or is not valid this returns a severity error.
 * @param {(string|number)=} severity
 * @return {number}
 * @memberof oj.Message
 * @ojsignature [{target: "Type",
 *                value: "oj.Message.SEVERITY_LEVEL",
 *                for: "returns"},
 *               {target: "Type",
 *                value: "oj.Message.SEVERITY_TYPE|oj.Message.SEVERITY_LEVEL",
 *                for: "severity"}]
 * @public
 * @export
 */


oj.Message.getSeverityLevel = function (severity) {
  var _severity = severity;

  if (_severity) {
    if (typeof severity === 'string') {
      var index = oj.Message._LEVEL_TO_TYPE.indexOf(_severity, 1);

      if (index === -1) {
        _severity = oj.Message.SEVERITY_LEVEL.ERROR;
      } else {
        _severity = index;
      }
    } else if (typeof _severity === 'number' && (_severity < oj.Message.SEVERITY_LEVEL.CONFIRMATION || _severity > oj.Message.SEVERITY_LEVEL.FATAL)) {
      _severity = oj.Message.SEVERITY_LEVEL.ERROR;
    }
  }

  return _severity || oj.Message.SEVERITY_LEVEL.ERROR;
};
/**
 * A convenience method that returns the severity type when given either a severity level of type
 * number or a severity type of string.
 * If severity level is not provided or is not valid this return a severity error.
 * @param {(string|number)=} level
 * @return {string}
 * @ojsignature [{target: "Type",
 *                value: "oj.Message.SEVERITY_TYPE",
 *                for: "returns"},
 *               {target: "Type",
 *                value: "oj.Message.SEVERITY_TYPE|oj.Message.SEVERITY_LEVEL",
 *                for: "level"}]
 * @memberof oj.Message
 * @public
 * @export
 */


oj.Message.getSeverityType = function (level) {
  var _level = level;

  if (_level) {
    if (typeof _level === 'string') {
      var index = oj.Message._LEVEL_TO_TYPE.indexOf(_level, 1);

      if (index === -1) {
        // when given an unrecognized type return "error"
        _level = oj.Message.SEVERITY_TYPE.ERROR;
      }
    } else if (typeof _level === 'number') {
      if (_level < oj.Message.SEVERITY_LEVEL.CONFIRMATION || _level > oj.Message.SEVERITY_LEVEL.FATAL) {
        _level = oj.Message.SEVERITY_TYPE.ERROR;
      } else {
        _level = oj.Message._LEVEL_TO_TYPE[level];
      }
    }
  }

  return _level || oj.Message.SEVERITY_TYPE.ERROR;
};
/**
 * Returns the max severity level in a array of message objects.
 *
 * @param {Array.<oj.Message>=} messages an array of message instances or duck typed messages
 * @returns {number} -1 if none can be determined; otherwise a severity level as defined by
 * oj.Message.SEVERITY_LEVEL.
 * @export
 * @memberof oj.Message
 * @ojsignature [{target: "Type",
 *                value: "oj.Message.SEVERITY_LEVEL| -1",
 *                for: "returns"}]
 * @public
 */


oj.Message.getMaxSeverity = function (messages) {
  var maxLevel = -1;

  if (messages && messages.length > 0) {
    $.each(messages, function (i, message) {
      var currLevel = oj.Message.getSeverityLevel(message.severity);
      maxLevel = maxLevel < currLevel ? currLevel : maxLevel;
    });
  }

  return maxLevel;
};
/**
 * Returns false if messages are of severity error or greater.
 *
 * @param {Array.<oj.Message>} messages an array of message instances or duck-typed messages
 * @returns {boolean} true if none of the messages are of severity error or greater. false otherwise
 * @export
 * @memberof oj.Message
 * @public
 */


oj.Message.isValid = function (messages) {
  var maxSeverity = oj.Message.getMaxSeverity(messages);

  if (maxSeverity >= oj.Message.SEVERITY_LEVEL.ERROR) {
    return false;
  }

  return true;
};
/**
 * @private
 * @type Array
 */


oj.Message._LEVEL_TO_TYPE = ['none', // this can never be set
oj.Message.SEVERITY_TYPE.CONFIRMATION, oj.Message.SEVERITY_TYPE.INFO, oj.Message.SEVERITY_TYPE.WARNING, oj.Message.SEVERITY_TYPE.ERROR, oj.Message.SEVERITY_TYPE.FATAL]; // mapping a variable to the name used in the require callback function for this module
// it is used in a no-require environment
// eslint-disable-next-line no-unused-vars

var Message = oj.Message;



/**
 * Extends oj.Message to represent a component specific message, this defines options that control
 * how the message will display.
 *
 * @param {string} summary - Localized summary message text
 * @param {string} detail - Localized detail message text
 * @param {number|string} severity - An optional severity for this message. Use constants
 * oj.Message.SEVERITY_LEVEL for number types and oj.Message.SEVERITY_TYPE for string types. Default
 * is SEVERITY_ERROR if no severity is specified
 * @param {Object} options - an Object literal that defines the following properties
 * @property {string} display - whether the message needs to be displayed immediately or not.
 * Accepted values are 'immediate', 'deferred'. The default is 'immediate'.
 * @property {string} context - the context the component was in when the validation messages was
 * added.<p>
 *
 * NOTE: messages added to the component directly by applications are unknown context and always
 * shown {display: 'immediate', context: ''}. </p>
 * @private
 * @constructor
 * @since 0.7.0
 */
oj.ComponentMessage = function (summary, detail, severity, options) {
  this.Init(summary, detail, severity, options);
}; // Subclass from oj.Message


oj.Object.createSubclass(oj.ComponentMessage, oj.Message, 'oj.ComponentMessage');
/**
 * Determines whether the message is displayed immediately or not. Deferred messages are not shown
 * to the user right away but are deferred until component explicitly does. See
 * {@link oj.editableValue#showMessages}.
 * @private
 * @const
 * @type {Object}
 */

oj.ComponentMessage.DISPLAY = {
  SHOWN: 'shown',
  HIDDEN: 'hidden'
};
/**
 * The default display options to use when none set.
 *
 * @type {Object}
 * @private
 */

oj.ComponentMessage._DEFAULT_OPTIONS = {
  display: oj.ComponentMessage.DISPLAY.SHOWN,
  context: ''
};
/**
 * Initializes the strategy based on the display options that specify the messaging artifacts that
 * will be displayed by this strategy.
 *
 * @param {string} summary - Localized summary message text
 * @param {string} detail - Localized detail message text
 * @param {number|string} severity - An optional severity for this message. Use constants
 * oj.Message.SEVERITY_LEVEL for number types and oj.Message.SEVERITY_TYPE for string types. Default
 * is SEVERITY_ERROR if no severity is specified
 * @param {Object} options - an Object literal that defines the following properties
 * @memberof! oj.ComponentMessage
 * @instance
 * @protected
 * @ignore
 */

oj.ComponentMessage.prototype.Init = function (summary, detail, severity, options) {
  oj.ComponentMessage.superclass.Init.call(this, summary, detail, severity);
  this._options = $.extend({}, oj.ComponentMessage._DEFAULT_OPTIONS, options);
};
/**
 * Clones this and returns the new instance.
 *
 * @memberof! oj.ComponentMessage
 * @instance
 * @protected
 * @ignore
 * @returns {Object}
 */


oj.ComponentMessage.prototype.clone = function () {
  return new oj.ComponentMessage(this.summary, this.detail, this.severity, this._options);
};
/**
 * Whether a message can display on the UI.
 *
 * @memberof! oj.ComponentMessage
 * @returns {boolean} true if messages can be displayed; false if marked as deferred by component.
 * @instance
 * @protected
 * @ignore
 */


oj.ComponentMessage.prototype.canDisplay = function () {
  return !(this._options && this._options.display ? this._options.display === oj.ComponentMessage.DISPLAY.HIDDEN : false);
};
/**
 *
 * Called by framework when the message needs to be shown
 *
 * @returns {boolean} true if shown; false if message display was already shown
 *
 * @memberof! oj.ComponentMessage
 * @instance
 * @private
 */


oj.ComponentMessage.prototype._forceDisplayToShown = function () {
  if (this._options && oj.ComponentMessage.DISPLAY.HIDDEN === this._options.display) {
    this._options.display = oj.ComponentMessage.DISPLAY.SHOWN;
    return true;
  }

  return false;
};
/**
 * Called by framework to determine if message was added by component versus app.
 *
 * @returns {boolean} true if messages was added by component. Usually the context is set.
 *
 * @memberof! oj.ComponentMessage
 * @instance
 * @private
 */


oj.ComponentMessage.prototype._isMessageAddedByComponent = function () {
  if (this._options && this._options.context) {
    return true;
  }

  return false;
};

  return oj.Message;
});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojmetadatautils',['ojs/ojcore-base'], function(oj)
{
  "use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }



/**
 * Component Metadata utilities.
 * @class MetadataUtils
 * @export
 * @ignore
 */
var MetadataUtils = {};
/**
 * Default values can be specified at the top level or at leaf subproperties.
 * This utility walks complex property subproperties to generate default value.
 * @property {object} metadata property-level metadata
 * @property {boolean?} shouldFreeze Contol whether we copy or freeze Object/Array types
 * @memberof MetadataUtils
 * @ignore
 */

MetadataUtils.getDefaultValue = function (metadata, shouldFreeze) {
  var defaultValue = metadata.value;

  if (defaultValue === undefined) {
    // If top level metadata isn't specified, check subproperties.
    // Note that we are not handling cases where both top level and subproperty
    // default values are provided, leaving that to auditing and build tools to check.
    var subMeta = metadata.properties;

    if (subMeta) {
      var complexValue = {};
      var keys = Object.keys(subMeta);

      for (var i = 0; i < keys.length; i++) {
        var subpropDefault = MetadataUtils.getDefaultValue(subMeta[keys[i]]);

        if (subpropDefault !== undefined) {
          complexValue[keys[i]] = subpropDefault;
        }
      } // Cache the default value on the top level property. This is ok
      // because we make a copy of the metadata when we process it for
      // event listener properties


      if (Object.keys(complexValue).length > 0) {
        // eslint-disable-next-line no-param-reassign
        metadata.value = complexValue;
        defaultValue = complexValue;
      }
    }
  }

  if (defaultValue !== undefined) {
    // For object/array types, either freeze or make a copy of the value
    // to prevent modification
    if (Array.isArray(defaultValue)) {
      defaultValue = shouldFreeze ? MetadataUtils.deepFreeze(defaultValue) : defaultValue.slice();
    } else if (defaultValue !== null && _typeof(defaultValue) === 'object') {
      defaultValue = shouldFreeze ? MetadataUtils.deepFreeze(defaultValue) : oj.CollectionUtils.copyInto({}, defaultValue, undefined, true);
    }
  }

  return defaultValue;
};
/**
 * Default values can be specified at the top level or at leaf subproperties.
 * This utility creates an object containing the default values for all properties
 * in the metadata (including rolling up subproperty defaults).  Returns null if no
 * default values are found
 * @property {object} metadata properties metadata (i.e. the value of the 'properties' property in component.json)
 * @property {boolean?} shouldFreeze Contol whether we copy or freeze Object/Array types
 * @memberof MetadataUtils
 * @ignore
 */


MetadataUtils.getDefaultValues = function (metadata, shouldFreeze) {
  var defaults = {};
  var propNames = Object.keys(metadata);
  var hasDefaults = false;
  propNames.forEach(function (propName) {
    // would be nice if this could be done lazily via defineProperty, but this causes
    // Object.assign to fail because the property has no setter
    var defaultValue = MetadataUtils.getDefaultValue(metadata[propName], shouldFreeze);

    if (defaultValue !== undefined) {
      defaults[propName] = defaultValue;
      hasDefaults = true;
    }
  });
  return hasDefaults ? defaults : null;
};
/**
 * Helper to deep freeze object literals. This method will walk arrays and
 * freeze array contents as needed. If anything other than a plain old object,
 * we will not attempt to freeze it so the owner should ensure that the
 * object is immutable.
 * @param {any} value The value to freeze
 * @return {any}
 * @ignore
 */


MetadataUtils.deepFreeze = function (value) {
  if (Object.isFrozen(value)) {
    return value;
  } else if (Array.isArray(value)) {
    // eslint-disable-next-line no-param-reassign
    value = value.map(function (item) {
      return MetadataUtils.deepFreeze(item);
    });
  } else if (value !== null && _typeof(value) === 'object') {
    // We should only recurse/freeze if value is a pojo.
    // proto will be null if Object.create(null) was used
    var proto = Object.getPrototypeOf(value);

    if (proto === null || proto === Object.prototype) {
      // Retrieve the property names defined on object
      Object.keys(value).forEach(function (name) {
        // eslint-disable-next-line no-param-reassign
        value[name] = MetadataUtils.deepFreeze(value[name]);
      });
      Object.freeze(value);
    }
  }

  return value;
};

;return MetadataUtils;
});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojdefaultsutils',['ojs/ojmetadatautils'], function(MetadataUtils)
{
  "use strict";


/**
 * Utility methods for handling defaults coming from metadata,
 * Props classes, and dynamic defaults for various JET component
 * models.
 * @private
 */
var DefaultsUtils;

(function (DefaultsUtils) {
  function getFrozenDefault(property, constr, metadata) {
    var defaults = DefaultsUtils.getDefaults(constr, metadata, true); // Default values must be either:
    // 1. primitives
    // 2. immutable classes, e.g. KeySetImpl
    // 3. Object/Arrays composed of #1 or #2

    return MetadataUtils.deepFreeze(defaults[property]);
  }

  DefaultsUtils.getFrozenDefault = getFrozenDefault;

  function getDefaults(constr, metadata, shouldFreeze) {
    // Defaults are created once and stashed on the constructor
    var defaults = constr['_defaults'];

    if (defaults === undefined) {
      // Adding the optional shouldFreeze param for definitional elements so we don't break
      // backwards compatibility, but our preference is to freeze the defaults and clone internally
      // where needed instead (e.g. dot notation sets).
      var staticDefaults = getStaticDefaults(constr, metadata, shouldFreeze); // If staticDefaults is null Object.create will return an empty object

      defaults = Object.create(staticDefaults); // Metadata defaults always override dynamic defaults

      applyDynamicDefaults(constr, defaults);
      constr['_defaults'] = defaults;
    }

    return defaults;
  }

  DefaultsUtils.getDefaults = getDefaults;

  function getStaticDefaults(constr, metadata, shouldFreeze) {
    var _a; // Defaults are created once and stashed on the constructor


    var defaults = constr['_staticDefaults'];

    if (defaults === undefined) {
      // Instantiate defaults to null in case we don't have metadata or properties
      // so when we call Object.create(null) we'll get an empty {} back vs an error for
      // Object.create(undefined);
      defaults = null;

      if (metadata) {
        var propertiesMetadata = metadata.properties;
        var PropDefaults = (_a = metadata.extension) === null || _a === void 0 ? void 0 : _a._DEFAULTS;

        if (PropDefaults) {
          // For VComponents, use the Props class stashed in the metadata and instantiate
          // it in order to get the properties and default values.
          var defaultsInstance = new PropDefaults();
          defaults = Object.create(defaultsInstance);
        } else if (propertiesMetadata) {
          defaults = Object.create( // Adding the optional shouldFreeze param for definitional elements so we don't break
          // backwards compatibility, but our preference is to freeze the defaults and clone internally
          // where needed instead (e.g. dot notation sets).
          MetadataUtils.getDefaultValues(propertiesMetadata, shouldFreeze));
        }
      }

      constr['_staticDefaults'] = defaults;
    }

    return defaults;
  }

  DefaultsUtils.getStaticDefaults = getStaticDefaults; // Keep for oj-form-layout which is the only usage

  function applyDynamicDefaults(constr, props) {
    if (constr['getDynamicDefaults']) {
      var dynamicDefaults = constr['getDynamicDefaults']();

      if (dynamicDefaults) {
        // Dyanmic getters specified via the es6 get function() syntax
        // will be added to the object prototype instead of instance so we
        // use a for...in loop here instead of Object.keys
        // eslint-disable-next-line no-restricted-syntax
        for (var key in dynamicDefaults) {
          if (props[key] === undefined) {
            props[key] = dynamicDefaults[key];
          }
        }
      }
    }
  }

  DefaultsUtils.applyDynamicDefaults = applyDynamicDefaults;
})(DefaultsUtils || (DefaultsUtils = {}));

;return { DefaultsUtils: DefaultsUtils };
});
(function(){
'use strict';var h=new function(){};var aa=new Set("annotation-xml color-profile font-face font-face-src font-face-uri font-face-format font-face-name missing-glyph".split(" "));function m(b){var a=aa.has(b);b=/^[a-z][.0-9_a-z]*-[\-.0-9_a-z]*$/.test(b);return!a&&b}function n(b){var a=b.isConnected;if(void 0!==a)return a;for(;b&&!(b.__CE_isImportDocument||b instanceof Document);)b=b.parentNode||(window.ShadowRoot&&b instanceof ShadowRoot?b.host:void 0);return!(!b||!(b.__CE_isImportDocument||b instanceof Document))}
function p(b,a){for(;a&&a!==b&&!a.nextSibling;)a=a.parentNode;return a&&a!==b?a.nextSibling:null}
function t(b,a,c){c=c?c:new Set;for(var d=b;d;){if(d.nodeType===Node.ELEMENT_NODE){var e=d;a(e);var f=e.localName;if("link"===f&&"import"===e.getAttribute("rel")){d=e.import;if(d instanceof Node&&!c.has(d))for(c.add(d),d=d.firstChild;d;d=d.nextSibling)t(d,a,c);d=p(b,e);continue}else if("template"===f){d=p(b,e);continue}if(e=e.__CE_shadowRoot)for(e=e.firstChild;e;e=e.nextSibling)t(e,a,c)}d=d.firstChild?d.firstChild:p(b,d)}}function u(b,a,c){b[a]=c};function v(){this.a=new Map;this.s=new Map;this.f=[];this.b=!1}function ba(b,a,c){b.a.set(a,c);b.s.set(c.constructor,c)}function w(b,a){b.b=!0;b.f.push(a)}function x(b,a){b.b&&t(a,function(a){return y(b,a)})}function y(b,a){if(b.b&&!a.__CE_patched){a.__CE_patched=!0;for(var c=0;c<b.f.length;c++)b.f[c](a)}}function z(b,a){var c=[];t(a,function(b){return c.push(b)});for(a=0;a<c.length;a++){var d=c[a];1===d.__CE_state?b.connectedCallback(d):A(b,d)}}
function B(b,a){var c=[];t(a,function(b){return c.push(b)});for(a=0;a<c.length;a++){var d=c[a];1===d.__CE_state&&b.disconnectedCallback(d)}}
function C(b,a,c){c=c?c:{};var d=c.w||new Set,e=c.i||function(a){return A(b,a)},f=[];t(a,function(a){if("link"===a.localName&&"import"===a.getAttribute("rel")){var c=a.import;c instanceof Node&&(c.__CE_isImportDocument=!0,c.__CE_hasRegistry=!0);c&&"complete"===c.readyState?c.__CE_documentLoadHandled=!0:a.addEventListener("load",function(){var c=a.import;if(!c.__CE_documentLoadHandled){c.__CE_documentLoadHandled=!0;var f=new Set(d);f.delete(c);C(b,c,{w:f,i:e})}})}else f.push(a)},d);if(b.b)for(a=0;a<
f.length;a++)y(b,f[a]);for(a=0;a<f.length;a++)e(f[a])}
function A(b,a){if(void 0===a.__CE_state){var c=a.ownerDocument;if(c.defaultView||c.__CE_isImportDocument&&c.__CE_hasRegistry)if(c=b.a.get(a.localName)){c.constructionStack.push(a);var d=c.constructor;try{try{if(new d!==a)throw Error("The custom element constructor did not produce the element being upgraded.");}finally{c.constructionStack.pop()}}catch(r){throw a.__CE_state=2,r;}a.__CE_state=1;a.__CE_definition=c;if(c.attributeChangedCallback)for(c=c.observedAttributes,d=0;d<c.length;d++){var e=c[d],
f=a.getAttribute(e);null!==f&&b.attributeChangedCallback(a,e,null,f,null)}n(a)&&b.connectedCallback(a)}}}v.prototype.connectedCallback=function(b){var a=b.__CE_definition;a.connectedCallback&&a.connectedCallback.call(b)};v.prototype.disconnectedCallback=function(b){var a=b.__CE_definition;a.disconnectedCallback&&a.disconnectedCallback.call(b)};
v.prototype.attributeChangedCallback=function(b,a,c,d,e){var f=b.__CE_definition;f.attributeChangedCallback&&-1<f.observedAttributes.indexOf(a)&&f.attributeChangedCallback.call(b,a,c,d,e)};function D(b,a){this.c=b;this.a=a;this.b=void 0;C(this.c,this.a);"loading"===this.a.readyState&&(this.b=new MutationObserver(this.f.bind(this)),this.b.observe(this.a,{childList:!0,subtree:!0}))}function E(b){b.b&&b.b.disconnect()}D.prototype.f=function(b){var a=this.a.readyState;"interactive"!==a&&"complete"!==a||E(this);for(a=0;a<b.length;a++)for(var c=b[a].addedNodes,d=0;d<c.length;d++)C(this.c,c[d])};function ca(){var b=this;this.b=this.a=void 0;this.f=new Promise(function(a){b.b=a;b.a&&a(b.a)})}function F(b){if(b.a)throw Error("Already resolved.");b.a=void 0;b.b&&b.b(void 0)};function G(b){this.j=!1;this.c=b;this.o=new Map;this.l=function(b){return b()};this.g=!1;this.m=[];this.u=new D(b,document)}
G.prototype.define=function(b,a){var c=this;if(!(a instanceof Function))throw new TypeError("Custom element constructors must be functions.");if(!m(b))throw new SyntaxError("The element name '"+b+"' is not valid.");if(this.c.a.get(b))throw Error("A custom element with name '"+b+"' has already been defined.");if(this.j)throw Error("A custom element is already being defined.");this.j=!0;var d,e,f,r,k;try{var g=function(b){var a=l[b];if(void 0!==a&&!(a instanceof Function))throw Error("The '"+b+"' callback must be a function.");
return a},l=a.prototype;if(!(l instanceof Object))throw new TypeError("The custom element constructor's prototype is not an object.");d=g("connectedCallback");e=g("disconnectedCallback");f=g("adoptedCallback");r=g("attributeChangedCallback");k=a.observedAttributes||[]}catch(q){return}finally{this.j=!1}a={localName:b,constructor:a,connectedCallback:d,disconnectedCallback:e,adoptedCallback:f,attributeChangedCallback:r,observedAttributes:k,constructionStack:[]};ba(this.c,b,a);this.m.push(a);this.g||
(this.g=!0,this.l(function(){return da(c)}))};G.prototype.i=function(b){C(this.c,b)};function da(b){if(!1!==b.g){b.g=!1;for(var a=b.m,c=[],d=new Map,e=0;e<a.length;e++)d.set(a[e].localName,[]);C(b.c,document,{i:function(a){if(void 0===a.__CE_state){var e=a.localName,f=d.get(e);f?f.push(a):b.c.a.get(e)&&c.push(a)}}});for(e=0;e<c.length;e++)A(b.c,c[e]);for(;0<a.length;){for(var f=a.shift(),e=f.localName,f=d.get(f.localName),r=0;r<f.length;r++)A(b.c,f[r]);(e=b.o.get(e))&&F(e)}}}
G.prototype.get=function(b){if(b=this.c.a.get(b))return b.constructor};G.prototype.whenDefined=function(b){if(!m(b))return Promise.reject(new SyntaxError("'"+b+"' is not a valid custom element name."));var a=this.o.get(b);if(a)return a.f;a=new ca;this.o.set(b,a);this.c.a.get(b)&&!this.m.some(function(a){return a.localName===b})&&F(a);return a.f};G.prototype.v=function(b){E(this.u);var a=this.l;this.l=function(c){return b(function(){return a(c)})}};window.CustomElementRegistry=G;
G.prototype.define=G.prototype.define;G.prototype.upgrade=G.prototype.i;G.prototype.get=G.prototype.get;G.prototype.whenDefined=G.prototype.whenDefined;G.prototype.polyfillWrapFlushCallback=G.prototype.v;var H=window.Document.prototype.createElement,I=window.Document.prototype.createElementNS,ea=window.Document.prototype.importNode,fa=window.Document.prototype.prepend,ga=window.Document.prototype.append,ha=window.DocumentFragment.prototype.prepend,ia=window.DocumentFragment.prototype.append,J=window.Node.prototype.cloneNode,K=window.Node.prototype.appendChild,L=window.Node.prototype.insertBefore,M=window.Node.prototype.removeChild,N=window.Node.prototype.replaceChild,O=Object.getOwnPropertyDescriptor(window.Node.prototype,
"textContent"),P=window.Element.prototype.attachShadow,Q=Object.getOwnPropertyDescriptor(window.Element.prototype,"innerHTML"),R=window.Element.prototype.getAttribute,S=window.Element.prototype.setAttribute,T=window.Element.prototype.removeAttribute,U=window.Element.prototype.getAttributeNS,ja=window.Element.prototype.setAttributeNS,ka=window.Element.prototype.removeAttributeNS,la=window.Element.prototype.insertAdjacentElement,ma=window.Element.prototype.insertAdjacentHTML,na=window.Element.prototype.prepend,
oa=window.Element.prototype.append,V=window.Element.prototype.before,pa=window.Element.prototype.after,qa=window.Element.prototype.replaceWith,ra=window.Element.prototype.remove,sa=window.HTMLElement,W=Object.getOwnPropertyDescriptor(window.HTMLElement.prototype,"innerHTML"),ta=window.HTMLElement.prototype.insertAdjacentElement,ua=window.HTMLElement.prototype.insertAdjacentHTML;function va(){var b=X;window.HTMLElement=function(){function a(){var a=this.constructor,d=b.s.get(a);if(!d)throw Error("The custom element being constructed was not registered with `customElements`.");var e=d.constructionStack;if(!e.length)return e=H.call(document,d.localName),Object.setPrototypeOf(e,a.prototype),e.__CE_state=1,e.__CE_definition=d,y(b,e),e;var d=e.length-1,f=e[d];if(f===h)throw Error("The HTMLElement constructor was either called reentrantly for this constructor or called multiple times.");
e[d]=h;Object.setPrototypeOf(f,a.prototype);y(b,f);return f}a.prototype=sa.prototype;Object.defineProperty(a.prototype,"constructor",{writable:!0,configurable:!0,enumerable:!1,value:a});return a}()};function Y(b,a,c){function d(a){return function(c){for(var e=[],d=0;d<arguments.length;++d)e[d-0]=arguments[d];for(var d=[],f=[],l=0;l<e.length;l++){var q=e[l];q instanceof Element&&n(q)&&f.push(q);if(q instanceof DocumentFragment)for(q=q.firstChild;q;q=q.nextSibling)d.push(q);else d.push(q)}a.apply(this,e);for(e=0;e<f.length;e++)B(b,f[e]);if(n(this))for(e=0;e<d.length;e++)f=d[e],f instanceof Element&&z(b,f)}}c.h&&(a.prepend=d(c.h));c.append&&(a.append=d(c.append))};function wa(){var b=X;u(Document.prototype,"createElement",function(a){if(this.__CE_hasRegistry){var c=b.a.get(a);if(c)return new c.constructor}a=H.call(this,a);y(b,a);return a});u(Document.prototype,"importNode",function(a,c){a=ea.call(this,a,c);this.__CE_hasRegistry?C(b,a):x(b,a);return a});u(Document.prototype,"createElementNS",function(a,c){if(this.__CE_hasRegistry&&(null===a||"http://www.w3.org/1999/xhtml"===a)){var d=b.a.get(c);if(d)return new d.constructor}a=I.call(this,a,c);y(b,a);return a});
Y(b,Document.prototype,{h:fa,append:ga})};function xa(){var b=X;function a(a,d){Object.defineProperty(a,"textContent",{enumerable:d.enumerable,configurable:!0,get:d.get,set:function(a){if(this.nodeType===Node.TEXT_NODE)d.set.call(this,a);else{var e=void 0;if(this.firstChild){var c=this.childNodes,k=c.length;if(0<k&&n(this))for(var e=Array(k),g=0;g<k;g++)e[g]=c[g]}d.set.call(this,a);if(e)for(a=0;a<e.length;a++)B(b,e[a])}}})}u(Node.prototype,"insertBefore",function(a,d){if(a instanceof DocumentFragment){var e=Array.prototype.slice.apply(a.childNodes);
a=L.call(this,a,d);if(n(this))for(d=0;d<e.length;d++)z(b,e[d]);return a}e=n(a);d=L.call(this,a,d);e&&B(b,a);n(this)&&z(b,a);return d});u(Node.prototype,"appendChild",function(a){if(a instanceof DocumentFragment){var c=Array.prototype.slice.apply(a.childNodes);a=K.call(this,a);if(n(this))for(var e=0;e<c.length;e++)z(b,c[e]);return a}c=n(a);e=K.call(this,a);c&&B(b,a);n(this)&&z(b,a);return e});u(Node.prototype,"cloneNode",function(a){a=J.call(this,a);this.ownerDocument.__CE_hasRegistry?C(b,a):x(b,a);
return a});u(Node.prototype,"removeChild",function(a){var c=n(a),e=M.call(this,a);c&&B(b,a);return e});u(Node.prototype,"replaceChild",function(a,d){if(a instanceof DocumentFragment){var e=Array.prototype.slice.apply(a.childNodes);a=N.call(this,a,d);if(n(this))for(B(b,d),d=0;d<e.length;d++)z(b,e[d]);return a}var e=n(a),f=N.call(this,a,d),c=n(this);c&&B(b,d);e&&B(b,a);c&&z(b,a);return f});O&&O.get?a(Node.prototype,O):w(b,function(b){a(b,{enumerable:!0,configurable:!0,get:function(){for(var a=[],b=
0;b<this.childNodes.length;b++)a.push(this.childNodes[b].textContent);return a.join("")},set:function(a){for(;this.firstChild;)M.call(this,this.firstChild);K.call(this,document.createTextNode(a))}})})};function ya(b){var a=Element.prototype;function c(a){return function(e){for(var c=[],d=0;d<arguments.length;++d)c[d-0]=arguments[d];for(var d=[],k=[],g=0;g<c.length;g++){var l=c[g];l instanceof Element&&n(l)&&k.push(l);if(l instanceof DocumentFragment)for(l=l.firstChild;l;l=l.nextSibling)d.push(l);else d.push(l)}a.apply(this,c);for(c=0;c<k.length;c++)B(b,k[c]);if(n(this))for(c=0;c<d.length;c++)k=d[c],k instanceof Element&&z(b,k)}}V&&(a.before=c(V));V&&(a.after=c(pa));qa&&u(a,"replaceWith",function(a){for(var e=
[],c=0;c<arguments.length;++c)e[c-0]=arguments[c];for(var c=[],d=[],k=0;k<e.length;k++){var g=e[k];g instanceof Element&&n(g)&&d.push(g);if(g instanceof DocumentFragment)for(g=g.firstChild;g;g=g.nextSibling)c.push(g);else c.push(g)}k=n(this);qa.apply(this,e);for(e=0;e<d.length;e++)B(b,d[e]);if(k)for(B(b,this),e=0;e<c.length;e++)d=c[e],d instanceof Element&&z(b,d)});ra&&u(a,"remove",function(){var a=n(this);ra.call(this);a&&B(b,this)})};function za(){var b=X;function a(a,c){Object.defineProperty(a,"innerHTML",{enumerable:c.enumerable,configurable:!0,get:c.get,set:function(a){var e=this,d=void 0;n(this)&&(d=[],t(this,function(a){a!==e&&d.push(a)}));c.set.call(this,a);if(d)for(var f=0;f<d.length;f++){var r=d[f];1===r.__CE_state&&b.disconnectedCallback(r)}this.ownerDocument.__CE_hasRegistry?C(b,this):x(b,this);return a}})}function c(a,c){u(a,"insertAdjacentElement",function(a,e){var d=n(e);a=c.call(this,a,e);d&&B(b,e);n(a)&&z(b,e);
return a})}function d(a,c){function e(a,e){for(var c=[];a!==e;a=a.nextSibling)c.push(a);for(e=0;e<c.length;e++)C(b,c[e])}u(a,"insertAdjacentHTML",function(a,b){a=a.toLowerCase();if("beforebegin"===a){var d=this.previousSibling;c.call(this,a,b);e(d||this.parentNode.firstChild,this)}else if("afterbegin"===a)d=this.firstChild,c.call(this,a,b),e(this.firstChild,d);else if("beforeend"===a)d=this.lastChild,c.call(this,a,b),e(d||this.firstChild,null);else if("afterend"===a)d=this.nextSibling,c.call(this,
a,b),e(this.nextSibling,d);else throw new SyntaxError("The value provided ("+String(a)+") is not one of 'beforebegin', 'afterbegin', 'beforeend', or 'afterend'.");})}P&&u(Element.prototype,"attachShadow",function(a){return this.__CE_shadowRoot=a=P.call(this,a)});Q&&Q.get?a(Element.prototype,Q):W&&W.get?a(HTMLElement.prototype,W):w(b,function(b){a(b,{enumerable:!0,configurable:!0,get:function(){return J.call(this,!0).innerHTML},set:function(a){var b="template"===this.localName,e=b?this.content:this,
c=I.call(document,this.namespaceURI,this.localName);for(c.innerHTML=a;0<e.childNodes.length;)M.call(e,e.childNodes[0]);for(a=b?c.content:c;0<a.childNodes.length;)K.call(e,a.childNodes[0])}})});u(Element.prototype,"setAttribute",function(a,c){if(1!==this.__CE_state)return S.call(this,a,c);var e=R.call(this,a);S.call(this,a,c);c=R.call(this,a);b.attributeChangedCallback(this,a,e,c,null)});u(Element.prototype,"setAttributeNS",function(a,c,d){if(1!==this.__CE_state)return ja.call(this,a,c,d);var e=U.call(this,
a,c);ja.call(this,a,c,d);d=U.call(this,a,c);b.attributeChangedCallback(this,c,e,d,a)});u(Element.prototype,"removeAttribute",function(a){if(1!==this.__CE_state)return T.call(this,a);var c=R.call(this,a);T.call(this,a);null!==c&&b.attributeChangedCallback(this,a,c,null,null)});u(Element.prototype,"removeAttributeNS",function(a,c){if(1!==this.__CE_state)return ka.call(this,a,c);var d=U.call(this,a,c);ka.call(this,a,c);var e=U.call(this,a,c);d!==e&&b.attributeChangedCallback(this,c,d,e,a)});ta?c(HTMLElement.prototype,
ta):la?c(Element.prototype,la):console.warn("Custom Elements: `Element#insertAdjacentElement` was not patched.");ua?d(HTMLElement.prototype,ua):ma?d(Element.prototype,ma):console.warn("Custom Elements: `Element#insertAdjacentHTML` was not patched.");Y(b,Element.prototype,{h:na,append:oa});ya(b)};/*

 Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 Code distributed by Google as part of the polymer project is also
 subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
var Z=window.customElements;if(!Z||Z.forcePolyfill||"function"!=typeof Z.define||"function"!=typeof Z.get){var X=new v;va();wa();Y(X,DocumentFragment.prototype,{h:ha,append:ia});xa();za();document.__CE_hasRegistry=!0;var customElements=new G(X);Object.defineProperty(window,"customElements",{configurable:!0,enumerable:!0,value:customElements})};
}).call(self);

//# sourceMappingURL=custom-elements.min.js.map
;
define("customElements", function(){});

/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojcustomelement',['ojs/ojcore', 'require', 'ojs/ojlogger', 'ojs/ojcontext', 'ojs/ojmetadatautils', 'customElements'],
  function(oj, require, Logger, Context, MetadataUtils)
{
  "use strict";
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }



/* global Promise:false, Set:false, Logger:false, Context:false */

/**
 * Custom element bridge prototype.
 *
 * @class
 * @ignore
 */
oj.BaseCustomElementBridge = {};
/**
 * Prototype for subclasses
 * @ignore
 */

oj.BaseCustomElementBridge.proto = {
  getClass: function getClass(descriptor) {
    var proto = Object.create(HTMLElement.prototype);
    this.InitializePrototype(proto);
    var metadata = this.GetMetadata(descriptor); // Enumerate metadata to define the prototype properties, methods, and events

    oj.BaseCustomElementBridge._enumerateMetadataForKey(proto, metadata, 'properties', this.DefinePropertyCallback.bind(this));

    oj.BaseCustomElementBridge._enumerateMetadataForKey(proto, metadata, 'methods', this.DefineMethodCallback.bind(this)); // Add additional element methods not defined in metadata, e.g. getNodeBySubId/getSubIdByNode or get/setProperty


    this.AddComponentMethods(proto);

    proto.setProperties = function (props) {
      oj.BaseCustomElementBridge.getInstance(this)._setProperties(this, props);
    }; // The set/unset methods are used for TypeScript only so we should define these as non enumerated properties


    Object.defineProperty(proto, 'set', {
      value: function value(prop, _value2) {
        this.setProperty(prop, _value2);
      }
    });
    Object.defineProperty(proto, 'unset', {
      value: function value(prop) {
        this.setProperty(prop, undefined);
      }
    }); // Add lifecycle listeners

    proto.attributeChangedCallback = this.AttributeChangedCallback;
    proto.connectedCallback = this._connectedCallback;
    proto.disconnectedCallback = this._detachedCallback;

    var constructorFunc = function constructorFunc() {
      var reflect = window.Reflect;
      var ret;

      if (typeof reflect !== 'undefined') {
        ret = reflect.construct(HTMLElement, [], this.constructor);
      } else {
        ret = HTMLElement.call(this);
      }

      return ret;
    };

    var bridge = this;
    Object.defineProperty(constructorFunc, 'observedAttributes', {
      get: function get() {
        return bridge.GetAttributes(metadata);
      }
    });
    Object.defineProperty(proto, 'constructor', {
      value: constructorFunc,
      writable: true,
      configurable: true
    });
    constructorFunc.prototype = proto;
    Object.setPrototypeOf(constructorFunc, HTMLElement);
    return constructorFunc;
  },
  playbackEarlyPropertySets: function playbackEarlyPropertySets(element) {
    this._bCanSetProperty = true;
    this.PlaybackEarlyPropertySets(element);
  },
  resolveBindingProvider: function resolveBindingProvider(provider) {
    if (this._bpResolve) {
      this._bpResolve(provider);
    } else {
      this._bpInst = provider;
    }
  },
  disposeBindingProvider: function disposeBindingProvider(element) {
    this._bDisposed = true;

    if (!this._complete && this._bConnected) {
      // The creation busy state is normally resolved upon component creation.
      // In the event that a component is disposed or disconnected before
      // creation, the busy state will be resolved by the first of the
      // disposal or disconnected callbacks that gets invoked.
      this._resolveBusyState(element);
    }
  },
  resolveDelayedReadyPromise: function resolveDelayedReadyPromise() {
    this.GetDelayedReadyPromise().resolvePromise();
  },
  whenCreated: function whenCreated() {
    return this._whenCreatedPromise;
  },
  // eslint-disable-next-line no-unused-vars
  AddComponentMethods: function AddComponentMethods(proto) {},
  AttributeChangedCallback: function AttributeChangedCallback(attr, oldValue, newValue) {
    // The browser triggers this callback even if old and new values are the same
    // so we should do an equality check ourselves to prevent extra work
    if (oldValue !== newValue) {
      var bridge = oj.BaseCustomElementBridge.getInstance(this); // Due to  where IE11 disables child inputs for a parent with the disabled attribute,
      // we will remove the disabled attribute after we save the value and will ignore all disabled
      // attribute sets after component initialization when the application can just as easily use the property
      // setter instead. Expressions will be handled in the CustomElementBinding.

      if (attr === 'disabled' && bridge.ShouldRemoveDisabled() && bridge._isDisabledAttributeRemoved()) {
        // Always remove the disabled attribute even after component initialization and log warning.
        // A null value indicates that the value was removed already.
        if (newValue != null) {
          Logger.warn("Ignoring 'disabled' attribute change after component initialization. Use element property setter instead.");

          bridge._removeDisabledAttribute(this);
        }

        return;
      }

      if (bridge.ShouldHandleAttributeChanged(this)) {
        var prop = oj.__AttributeUtils.attributeToPropertyName(attr);

        var propMeta = oj.BaseCustomElementBridge.__GetPropertyMetadata(prop, oj.BaseCustomElementBridge.getProperties(bridge));

        oj.BaseCustomElementBridge.__CheckOverlappingAttribute(this, attr); // removeAttribute calls return null as the newValue which we want to treat as
        // a property unset and convert to undefined. We allow property null sets as an
        // actual property override.


        if (newValue === null) {
          // eslint-disable-next-line no-param-reassign
          newValue = undefined;
        }

        var params = {
          detail: {
            attribute: attr,
            value: newValue,
            previousValue: oldValue
          }
        };
        this.dispatchEvent(new CustomEvent('attribute-changed', params));

        var expression = oj.__AttributeUtils.getExpressionInfo(newValue).expr;

        if (!expression) {
          if (propMeta) {
            this.setProperty(prop, oj.BaseCustomElementBridge.__ParseAttrValue(this, attr, prop, newValue, propMeta));
          } // This allows subclasses to handle special cases like global transfer
          // attributes for JET components or controlled properties for virtual components


          bridge.HandleAttributeChanged(this, attr, oldValue, newValue);
        }
      }
    }
  },
  // eslint-disable-next-line no-unused-vars
  CreateComponent: function CreateComponent(element) {},
  // eslint-disable-next-line no-unused-vars
  DefineMethodCallback: function DefineMethodCallback(proto, method, methodMeta) {},
  // eslint-disable-next-line no-unused-vars
  DefinePropertyCallback: function DefinePropertyCallback(proto, property, propertyMeta) {},

  /**
   * Returns a promise that will be resolved when the component has been initialized.
   * @return {Promise}
   */
  GetDelayedReadyPromise: function GetDelayedReadyPromise() {
    if (!this._delayedReady) {
      this._delayedReady = new oj.BaseCustomElementBridge.__DelayedPromise();
    }

    return this._delayedReady;
  },
  GetAttributes: function GetAttributes(metadata) {
    return metadata ? oj.BaseCustomElementBridge.getAttributes(metadata.properties) : [];
  },
  GetMetadata: function GetMetadata(descriptor) {
    return descriptor[oj.BaseCustomElementBridge.DESC_KEY_META] || {};
  },

  /**
   * Returns the aliased component property for a given custom element property,
   * e.g. readOnly for oj-switch's readonly custom element property.
   * Will return the original property if there is no aliasing.
   * @param {string} property The property to check
   */
  GetAliasForProperty: function GetAliasForProperty(property) {
    return property;
  },
  // eslint-disable-next-line no-unused-vars
  GetTrackChildrenOption: function GetTrackChildrenOption(element) {
    return this.METADATA.extension && this.METADATA.extension._TRACK_CHILDREN ? this.METADATA.extension._TRACK_CHILDREN : 'none';
  },

  /**
   * Tests whether attribute changed processing should be performed.
   */
  // eslint-disable-next-line no-unused-vars
  ShouldHandleAttributeChanged: function ShouldHandleAttributeChanged(element) {
    return this._bCreateCalled;
  },

  /**
   * Tests whether the HandleAttributeChanged callback should be called.
   * This is only needed in the VirtualElementBridge case when a VComponent
   * is patching and updates a controlled property on the root element which we
   * want to update our internal _CONTROLLED_PROPS object with, but not cause a
   * rerender.
   */
  // eslint-disable-next-line no-unused-vars
  ShouldCallHandleAttributeChanged: function ShouldCallHandleAttributeChanged(element) {
    return this.ShouldHandleAttributeChanged();
  },
  // eslint-disable-next-line no-unused-vars
  HandleAttributeChanged: function HandleAttributeChanged(element, attr, oldValue, newValue) {},
  // eslint-disable-next-line no-unused-vars
  HandleBindingsApplied: function HandleBindingsApplied(element, bindingContext) {},
  // eslint-disable-next-line no-unused-vars
  HandleDetached: function HandleDetached(element) {},
  // eslint-disable-next-line no-unused-vars
  HandleReattached: function HandleReattached(element) {},
  // eslint-disable-next-line no-unused-vars
  InitializeElement: function InitializeElement(element) {},
  // eslint-disable-next-line no-unused-vars
  InitializePrototype: function InitializePrototype(proto) {},
  BatchedPropertySet: function BatchedPropertySet(elem, props) {
    var keys = Object.keys(props);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      elem.setProperty(key, props[key]);
    }
  },
  GetEventListenerProperty: function GetEventListenerProperty(property) {
    var event = oj.__AttributeUtils.eventListenerPropertyToEventType(property); // Get event listener


    var eventListener = this._eventListeners[event];

    if (eventListener) {
      return eventListener.getListener();
    }

    return undefined;
  },
  GetProperty: function GetProperty(element, prop, props) {
    var event = oj.__AttributeUtils.eventListenerPropertyToEventType(prop);

    var meta = oj.BaseCustomElementBridge.__GetPropertyMetadata(prop, oj.BaseCustomElementBridge.getProperties(this)); // For event listener and non component properties, retrieve the value directly stored on the element.
    // For top level properties, this will delegate to our 'set' methods so we can handle default values.
    // props is the properties object we pass the definitional element or composite ViewModel


    if (event || !meta || prop.indexOf('.') === -1) {
      return props[prop];
    }

    return oj.BaseCustomElementBridge.__GetProperty(props, prop);
  },
  InitializeBridge: function InitializeBridge(element, descriptor) {
    // Initialize property storage and other variables needed for property sets.
    // Since early property sets can occur before the element's connected callback
    // is triggered we can't rely on performing this logic there. The cases where
    // the connected callback isn't called before a property set can occur if the
    // custom element is programatically created and sets are done before adding
    // the element to the DOM or if the element is stamped by knockout and its expressions
    // processed disconnected as in the case for oj-bind-for-each.
    this.METADATA = this.GetMetadata(descriptor);
    this._eventListeners = {};
  },
  PlaybackEarlyPropertySets: function PlaybackEarlyPropertySets(element) {
    if (this._earlySets) {
      while (this._earlySets.length) {
        var setObj = this._earlySets.shift();

        element.setProperty(setObj.property, setObj.value);
      }
    }
  },

  /**
   * Returns true if this property set was handled as an early property set.
   * An early property set is any set that occurs before the component is created.
   * These sets do not trigger [property]Changed events.
   * @param {string} prop
   * @param {any} value
   * @return {boolean}
   */
  SaveEarlyPropertySet: function SaveEarlyPropertySet(prop, value) {
    // Do not save sets that occur during oj.BaseCustomElementBridge.__InitProperties
    // or expression evaluation. We can process these as normal. Playback occurs before the
    // binding provider promise is resolved leading to component creation.
    if (this.__INITIALIZING_PROPS || this._bCanSetProperty) {
      return false;
    }

    if (!this._earlySets) {
      this._earlySets = [];
    }

    this._earlySets.push({
      property: prop,
      value: value
    });

    return true;
  },
  SetEventListenerProperty: function SetEventListenerProperty(element, property, value) {
    var event = oj.__AttributeUtils.eventListenerPropertyToEventType(property); // Get event listener


    var eventListener = this._eventListeners[event];

    if (!eventListener) {
      // Create the wrapper
      eventListener = this._createEventListenerWrapper();
      this._eventListeners[event] = eventListener;
      element.addEventListener(event, eventListener);
    }

    if (value == null || value instanceof Function) {
      eventListener.setListener(value);
    } else {
      oj.BaseCustomElementBridge.__ThrowTypeError(element, property, value, 'function');
    }
  },
  SetProperty: function SetProperty(element, prop, value, props, bOuter) {
    // Check value against any defined enums
    var event = oj.__AttributeUtils.eventListenerPropertyToEventType(prop);

    var meta = oj.BaseCustomElementBridge.__GetPropertyMetadata(prop, oj.BaseCustomElementBridge.getProperties(this));

    if (event || !meta) {
      // eslint-disable-next-line no-param-reassign
      element[prop] = value;
    } else {
      // props is the properties object we pass the definitional element or composite ViewModel
      var previousValue = element.getProperty(prop);
      var propPath = prop.split('.');
      var topProp = propPath[0]; // If the top level property is an object, make a copy otherwise the old/new values
      // will be the same.

      var topPropPrevValue = props[topProp];

      if (oj.CollectionUtils.isPlainObject(topPropPrevValue)) {
        topPropPrevValue = oj.CollectionUtils.copyInto({}, topPropPrevValue, undefined, true);
      }

      if (!oj.BaseCustomElementBridge.__CompareOptionValues(prop, meta, value, previousValue)) {
        var isSubprop = prop.indexOf('.') !== -1;

        if (isSubprop) {
          // Set a flag for the case a subproperty results in a set of the top level property
          // which was not instantiated to an empty object to avoid firing two events.
          this._SKIP_PROP_CHANGE_EVENT = true;
        }

        if (bOuter) {
          // This ultimately triggers our element defined property setter
          this.ValidateAndSetProperty(this.GetAliasForProperty.bind(this), props, prop, value, element);
        } else {
          // Skip validation for inner sets so we don't throw an error when updating readOnly writeable properties
          oj.BaseCustomElementBridge.__SetProperty(this.GetAliasForProperty.bind(this), props, prop, value);
        }

        this._SKIP_PROP_CHANGE_EVENT = false; // Property change events for top level properties will be triggered by ValidateAndSetProperty so avoid firing twice

        if (isSubprop) {
          var subprop = {};
          subprop.path = prop;
          subprop.value = value;
          subprop.previousValue = previousValue; // Pass the top level property value/previousValues

          var updatedFrom = bOuter ? 'external' : 'internal';

          oj.BaseCustomElementBridge.__FirePropertyChangeEvent(element, topProp, props[topProp], topPropPrevValue, updatedFrom, subprop);
        }

        return {
          property: topProp,
          propertySet: true,
          isSubproperty: isSubprop
        };
      }
    } // We return true if a component property is updated with a different value and false
    // for other cases like on[Event] property updates


    return {
      property: null,
      propertySet: false,
      isSubproperty: false
    };
  },
  ShouldRemoveDisabled: function ShouldRemoveDisabled() {
    // Subclasses should override if the disabled attribute shouldn't be unconditionally removed
    // from the DOM, e.g. definitional and composite components
    return true;
  },
  ValidateAndSetProperty: function ValidateAndSetProperty(propNameFun, componentProps, property, value, element) {
    var _value = this.ValidatePropertySet(element, property, value);

    oj.BaseCustomElementBridge.__SetProperty(propNameFun, componentProps, property, _value);
  },
  ValidatePropertySet: function ValidatePropertySet(element, property, value) {
    var propsMeta = oj.BaseCustomElementBridge.getProperties(this);

    var propMeta = oj.BaseCustomElementBridge.__GetPropertyMetadata(property, propsMeta);

    var propAr = property.split('.');

    if (!propMeta) {
      Logger.warn(oj.BaseCustomElementBridge.getElementInfo(element) + ": Ignoring property set for undefined property '" + property + "'.");
      return undefined;
    } // Check readOnly property for top level property


    if (propsMeta[propAr[0]].readOnly) {
      this.throwError(element, "Read-only property '" + property + "' cannot be set.");
    }

    oj.BaseCustomElementBridge.checkEnumValues(element, property, value, propMeta); // TODO support checking for null values once we generate metadata from jsDoc and have accurate info
    // about component support for undefined/null

    if (value != null) {
      return oj.BaseCustomElementBridge.checkType(element, property, value, propMeta);
    }

    return value;
  },
  GetPreCreatePromise: function GetPreCreatePromise(element) {
    var preCreatePromise = this._getBindingProvider(element);

    var trackOption = oj.BaseCustomElementBridge.getTrackChildrenOption(element);

    if (trackOption !== 'none') {
      // this will return a promise that will get automatically chained to the binding provider promise
      preCreatePromise = preCreatePromise.then(function (bindingProvider) {
        return this._whenChildrenCreated(element, bindingProvider);
      }.bind(this));
    }

    return preCreatePromise;
  },
  PostCreate: function PostCreate(element) {
    // After parsing the DOM attribute values and initializing properties, remove the disabled
    // property if it exists due to 
    if (element.hasAttribute('disabled') && this.ShouldRemoveDisabled() && !this._isDisabledAttributeRemoved()) {
      this._removeDisabledAttribute(element);
    }
  },
  _connected: function _connected(element) {
    this._bConnected = true;

    if (!this._bCreateCalled) {
      // initial attach
      this._bCreateCalled = true;

      this._registerBusyState(element);

      this._monitorReadyPromise(element);

      this.InitializeElement(element);
      var self = this;

      var createComponentCallback = function createComponentCallback() {
        try {
          // Short circuit component creation if disposed.
          // The state of the various flags are being reset here, but that's
          // not critical because attempting to reconnect a disposed node
          // is an invalid use case.
          //
          // The create flag is reset here.  Busy states will have been
          // resolved in the disposal (or disconnect) callback.
          if (!self._bDisposed) {
            self.CreateComponent(element);
            self.PostCreate(element);
          } else {
            // Reset the create flag
            self._bCreateCalled = false;
          }
        } catch (ex) {
          // If an error occurs during component creation, resolve the busy context and throw an error.
          self.throwError(element, 'Error while rendering component.', ex);
        }
      };

      this._whenCreatedPromise = this.GetPreCreatePromise(element).then(createComponentCallback);
    } else if (!this._complete) {
      // If the component had been previously disconnected, and the 'ready'
      // promise is still not resolved, we need to re-register the busy state
      this._registerBusyState(element);
    } else {
      this.HandleReattached(element);
    }
  },
  _connectedCallback: function _connectedCallback() {
    var bridge = oj.BaseCustomElementBridge.getInstance(this);

    bridge._connected(this);
  },
  _detachedCallback: function _detachedCallback() {
    var bridge = oj.BaseCustomElementBridge.getInstance(this);
    bridge._bConnected = false;

    if (!bridge._complete) {
      if (!bridge._bDisposed) {
        // The creation busy state is normally resolved upon component creation.
        // In the event that a component is disposed or disconnected before
        // creation, the busy state will be resolved by the first of the
        // disposal or disconnected callbacks that gets invoked.
        bridge._resolveBusyState(this);
      }
    } else {
      bridge.HandleDetached(this);
    }
  },
  // This wrapper does not provide any additional functionality to event listener functions
  // It exists solely to preserve event listener order
  _createEventListenerWrapper: function _createEventListenerWrapper() {
    var eventListener;

    var domListener = function domListener(event) {
      if (eventListener) {
        eventListener(event);
      }
    };

    domListener.setListener = function (listener) {
      eventListener = listener;
    };

    domListener.getListener = function () {
      return eventListener;
    };

    return domListener;
  },
  _monitorReadyPromise: function _monitorReadyPromise(element) {
    var self = this;

    var completeHandler = function completeHandler() {
      // If the component is disconnected, the busy state
      // must be already resolved
      if (!self._complete && self._bConnected) {
        self._resolveBusyState(element);

        self._complete = true;
      }
    };

    this.GetDelayedReadyPromise().getPromise().then(function () {
      // Add marker class to unhide components
      element.classList.add('oj-complete');
      completeHandler();
    }, function () {
      // Add marker class to mark that there was an error duing upgrade so consumers like
      // VBCS can apply their own styling to incorrectly setup custom elements.
      element.classList.add('oj-incomplete');
      completeHandler();
    });
  },
  _registerBusyState: function _registerBusyState(element) {
    var busyContext = Context.getContext(element).getBusyContext();
    this._initCompleteCallback = busyContext.addBusyState({
      description: oj.BaseCustomElementBridge.getElementInfo(element) + ' is being upgraded.'
    });
  },
  _resolveBusyState: function _resolveBusyState(element) {
    var callback = this._initCompleteCallback;

    if (!callback) {
      this.throwError(element, 'Unexpected call to _resolveBusyState().');
    }

    this._initCompleteCallback = null;
    callback();
  },
  _setProperties: function _setProperties(elem, props) {
    var mutationKeys = []; // keys for the 'dot mutation' properties

    var regularProps = {}; // the rest of the properties

    var hasRegularProps = false;
    var keys = Object.keys(props);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];

      if (key.indexOf('.') >= 0) {
        mutationKeys.push(key);
      } else {
        regularProps[key] = props[key];
        hasRegularProps = true;
      }
    } // Regular property updates may be batched


    if (hasRegularProps) {
      this.BatchedPropertySet(elem, regularProps);
    } // 'Dot notation' properties can only be set individually for now


    for (var p = 0; p < mutationKeys.length; p++) {
      var mkey = mutationKeys[p];
      elem.setProperty(mkey, props[mkey]);
    }
  },

  /**
   * Throws new error.
   * @ignore
   * @param {Element} elem The element that reports an error
   * @param {string} msg Error message
   * @param {Error=} origErr Original error whose stack should be preserved
   */
  throwError: function throwError(elem, msg, origErr) {
    this.GetDelayedReadyPromise().rejectPromise();
    var errMsg = oj.BaseCustomElementBridge.getElementInfo(elem) + ': ' + msg;

    if (origErr) {
      // The error.stack feature is considered non-standard,
      // but all the browsers support it according to caniuse:
      // https://caniuse.com/#feat=mdn-javascript_builtins_error_stack
      errMsg = errMsg + ' ' + (origErr.stack ? origErr.stack : origErr);
    }

    throw new Error(errMsg);
  },
  _setBpResolver: function _setBpResolver(resolve) {
    this._bpResolve = resolve;
  },
  _getBindingProvider: function _getBindingProvider(element) {
    var name = this._getBindingProviderName(element);

    if (name === oj.BaseCustomElementBridge._NO_BINDING_PROVIDER) {
      this.playbackEarlyPropertySets(element);
      return Promise.resolve(null);
    } else if (name === 'knockout') {
      if (this._bpInst) {
        return Promise.resolve(this._bpInst);
      }

      return new Promise(this._setBpResolver.bind(this));
    }

    this.throwError(element, "Unknown binding provider '" + name + "'.");
    return undefined; // not reachable but eslint is too stupid to figure that out.
  },
  _getBindingProviderName: function _getBindingProviderName(element) {
    var cachedProp = '_ojBndgPrv';
    var name = element[cachedProp];

    if (name) {
      return name;
    }

    name = element.getAttribute('data-oj-binding-provider') || oj.BaseCustomElementBridge._getCompositeBindingProviderName(element);

    if (!name) {
      var parent = element.parentElement;

      if (parent == null) {
        if (element === document.documentElement) {
          name = 'knockout'; // the default
        } else {
          this.throwError(element, 'Cannot determine binding provider for a disconnected subtree.');
        }
      } else if (parent._vcomp) {
        // Content rendered by a VComponent parent does not get processed
        // by any binding provider.
        name = oj.BaseCustomElementBridge._NO_BINDING_PROVIDER;
      } else {
        name = this._getBindingProviderName(parent);
      }
    } // cache provider name as a non-enumerable property


    Object.defineProperty(element, cachedProp, {
      value: name
    });
    return name;
  },
  // used by _whenChildrenCreated() call - called for trackOption "immediate" or "nearestCustomElement"
  _getChildrenToTrack: function _getChildrenToTrack(element, trackOption, trackedElements) {
    var children = element.childNodes;

    for (var i = 0; i < children.length; i++) {
      var child = children[i];

      if (oj.ElementUtils.isValidCustomElementName(child.localName)) {
        trackedElements.push(child);
      } else if (trackOption === 'nearestCustomElement') {
        this._getChildrenToTrack(child, trackOption, trackedElements);
      }
    }

    return trackedElements;
  },
  // tracks upgrade and creation of relevant children for the element
  _whenChildrenCreated: function _whenChildrenCreated(element, bindingProvider) {
    var _UPGRADE_MESSAGE_INTERVAL = 20000;
    var trackOption = oj.BaseCustomElementBridge.getTrackChildrenOption(element);
    var busyContext = Context.getContext(element).getBusyContext();

    var trackedElements = this._getChildrenToTrack(element, trackOption, []); // map tracked elements to promises


    var promises = trackedElements.map(function (trackedElement) {
      // 1) if bindingProvider is null, then we don't expect to discover knockout custom components -
      //    wait for all components to be defined, then wait for JET components to be created
      // 2) if bindingProvider is knockout, then child JET components should already be registered -
      //    no need to wait for whenDefined, just wait for JET components to be created
      if (!bindingProvider) {
        // register busy state for the element
        var resolveElementDefinedBusyState = busyContext.addBusyState({
          description: 'Waiting for element ' + trackedElement.localName + ' to be defined.'
        }); // setup a timer to log 'waiting' message for an element

        var timer = setInterval(function () {
          Logger.warn('Warning: waiting for element ' + trackedElement.localName + ' to be defined.');
        }, _UPGRADE_MESSAGE_INTERVAL); // return a promise that will be resolved, when element is defined and created

        return customElements.whenDefined(trackedElement.localName).then(function () {
          resolveElementDefinedBusyState();
          clearInterval(timer);

          if (oj.BaseCustomElementBridge.getRegistered(trackedElement.tagName)) {
            return oj.BaseCustomElementBridge.getInstance(trackedElement).whenCreated();
          }

          return null;
        }).catch(function (error) {
          resolveElementDefinedBusyState();
          clearInterval(timer);
          throw new Error('Error defining element ' + trackedElement.localName + ' : ' + error);
        });
      } else if (oj.BaseCustomElementBridge.getRegistered(trackedElement.tagName)) {
        return oj.BaseCustomElementBridge.getInstance(trackedElement).whenCreated();
      }

      return null; // knockout binding provider, but the component is not JET component
    });
    return Promise.all(promises);
  },

  /**
   * Returns true if the disabled attribute has already been removed by the bridge.
   * @return  {boolean}
   * @private
   */
  _isDisabledAttributeRemoved: function _isDisabledAttributeRemoved() {
    return this._disabledProcessed === true;
  },

  /**
   * Removes the disabled attribute from an element and marks the bridge as having
   * processed the value to prevent evaluation of additional attribute sets.
   * @param  {Element} element The custom element
   * @private
   */
  _removeDisabledAttribute: function _removeDisabledAttribute(element) {
    this._disabledProcessed = true;
    element.removeAttribute('disabled');
  }
};
/** ***********************/

/* PUBLIC STATIC METHODS */

/** ***********************/

/**
 * Returns the attributes including the dot notation versions of all complex properties
 * not including readOnly properties.
 * @param {Object} props The properties object
 * @return {Array}
 * @ignore
 */

oj.BaseCustomElementBridge.getAttributes = function (props) {
  var attrs = [];

  oj.BaseCustomElementBridge._getAttributesFromProperties('', props, attrs);

  return attrs;
};
/**
 * Returns track children option for the element - 'none', 'immediate' or 'nearestCustomElement'
 * @param {Element} element Custom element
 * @return {String}
 * @ignore
 */


oj.BaseCustomElementBridge.getTrackChildrenOption = function (element) {
  var bridge = oj.BaseCustomElementBridge.getInstance(element);
  return bridge ? bridge.GetTrackChildrenOption(element) : 'none';
};
/**
 * Helper method for Returns the attributes including the dot notation versions of all complex attributes
 * stored on a bridge instance
 * @param {string} propName The property to evaluate
 * @param {Object} props The properties object
 * @param {Array} attrs The attribute array to add to
 * @ignore
 */


oj.BaseCustomElementBridge._getAttributesFromProperties = function (propName, props, attrs) {
  if (props) {
    var propKeys = Object.keys(props);

    for (var i = 0; i < propKeys.length; i++) {
      var prop = propKeys[i];
      var propMeta = props[prop];

      if (!propMeta.readOnly) {
        var concatName = propName + prop;
        attrs.push(oj.__AttributeUtils.propertyNameToAttribute(concatName));

        if (propMeta.properties) {
          oj.BaseCustomElementBridge._getAttributesFromProperties(concatName + '.', propMeta.properties, attrs);
        }
      }
    }
  }
};
/**
 * Returns a string including the element tag name and id for use in error messages and logging.
 * @param {Element} element The element to get the information for.
 * @return {string}
 * @ignore
 */


oj.BaseCustomElementBridge.getElementInfo = function (element) {
  if (element) {
    return element.tagName.toLowerCase() + " with id '" + element.id + "'";
  }

  return '';
};
/**
 * Returns the bridge instance for an element.
 * @ignore
 */


oj.BaseCustomElementBridge.getInstance = function (element) {
  var instance = element[oj.BaseCustomElementBridge._INSTANCE_KEY];

  if (!instance) {
    var info = oj.BaseCustomElementBridge._registry[element.tagName.toLowerCase()];

    if (!info) {
      Logger.error(oj.BaseCustomElementBridge.getElementInfo(element) + ' Attempt to interact with the custom element before it has been registered.');
    }

    instance = Object.create(info.bridgeProto);

    var descriptor = oj.BaseCustomElementBridge.__GetDescriptor(element.tagName);

    instance.InitializeBridge(element, descriptor);
    Object.defineProperty(element, oj.BaseCustomElementBridge._INSTANCE_KEY, {
      value: instance
    });
  }

  return instance;
};
/**
 * Returns the properties stored on a bridge instance
 * @param  {Object} bridge The bridge instance
 * @return {Object}
 * @ignore
 */
// eslint-disable-next-line no-unused-vars


oj.BaseCustomElementBridge.getProperties = function (bridge) {
  return bridge.METADATA.properties;
};
/**
 * Returns an object if JET component tag has been registered, null otherwise.
 * @param  {string}  tagName The tag name to look up
 * @return {Object|null} True if the component module has been loaded and registered
 * @ignore
 */


oj.BaseCustomElementBridge.getRegistered = function (tagName) {
  if (tagName) {
    var info = oj.BaseCustomElementBridge._registry[tagName.toLowerCase()];

    if (info) {
      return {
        composite: info.composite
      };
    }
  }

  return null;
};
/**
 * Returns the slot map of slot name to slotted child elements for a given custom element.
 * If the given element has no children, this method returns an empty object.
 * Note that the default slot name is mapped to the empty string.
 * @param  {Element} element The custom element
 * @return {Object} A map of the child elements for a given custom element.
 * @ignore
 */


oj.BaseCustomElementBridge.getSlotMap = function (element) {
  var slotMap = {};
  var childNodeList = element.childNodes;

  for (var i = 0; i < childNodeList.length; i++) {
    var child = childNodeList[i]; // Only assign Text and Element nodes to a slot

    if (oj.BaseCustomElementBridge.isSlotable(child)) {
      var slot = oj.BaseCustomElementBridge.getSlotAssignment(child);

      if (!slotMap[slot]) {
        slotMap[slot] = [];
      }

      slotMap[slot].push(child);
    }
  }

  return slotMap;
};
/**
 * Returns the slot that the node should get assigned to.
 * Note that the default slot name is mapped to the empty string.
 * @param  {Node} node The custom element
 * @return {string} The slot name of the element
 * @ignore
 */


oj.BaseCustomElementBridge.getSlotAssignment = function (node) {
  // Text nodes and elements with no slot attribute map to the default slot.
  // __oj_slots is the slot attribute saved from an oj-bind-slot or oj-bind-template-slot element
  // Remember that the slot name can be the empty string so we should do a null check instead of just using || directly
  var slot = node.__oj_slots != null ? node.__oj_slots : node.getAttribute && node.getAttribute('slot');

  if (!slot) {
    slot = '';
  }

  return slot;
};
/**
 * Returns true if an element is slot assignable.
 * @param {Element} node The element to check
 * @return {boolean}
 * @ignore
 */


oj.BaseCustomElementBridge.isSlotable = function (node) {
  // Ignore text nodes that only contain whitespace
  return node.nodeType === 1 || node.nodeType === 3 && node.nodeValue.trim();
};
/** ***************************/

/* NON PUBLIC STATIC METHODS */

/** ***************************/

/**
 * @ignore
 */


oj.BaseCustomElementBridge._NO_BINDING_PROVIDER = 'none';
/**
 * @ignore
 */

oj.BaseCustomElementBridge._enumerateMetadataForKey = function (proto, metadata, key, callback) {
  if (!metadata || !metadata[key]) {
    return;
  }

  var values = metadata[key];
  var names = Object.keys(values);
  names.forEach(function (name) {
    callback(proto, name, values[name]);
  });
};
/**
 * Returns a binding provder name if the element is managed by a JET composite
 * @ignore
 */


oj.BaseCustomElementBridge._getCompositeBindingProviderName = function (element) {
  // for upstream dependency we will still rely components being registered on the oj namespace.
  var name = oj.Composite ? oj.Composite.getBindingProviderName(element.parentElement) : null;
  return name;
};
/**
 * Checks to see whether a value is valid for an element property's enum and throws an error if not.
 * @param  {Element}  element The custom element
 * @param  {string}  property The property to check
 * @param  {string}  value The property value
 * @param  {Object}  metadata The property metadata
 * @ignore
 */


oj.BaseCustomElementBridge.checkEnumValues = function (element, property, value, metadata) {
  // Only check enum values for string types
  if (typeof value === 'string' && metadata) {
    var enums = metadata.enumValues;

    if (enums && enums.indexOf(value) === -1) {
      var bridge = oj.BaseCustomElementBridge.getInstance(element);
      bridge.throwError(element, "Invalid value '" + value + "' found for property '" + property + "'. Expected one of the following '" + enums.toString() + "'.");
    }
  }
};
/**
 * Checks to see whether a value is valid for an element property and throws an error if not.
 * @param  {Element}  element The custom element
 * @param  {string}  property The property to check
 * @param  {string}  value The property value
 * @param  {Object}  metadata The property metadata
 * @ignore
 */


oj.BaseCustomElementBridge.checkType = function (element, property, value, metadata) {
  // We currently support checking of single typed properties of type: string, number,
  // boolean, Array, Object OR properties w/ two possible types where
  // the value can either be of type string|Array, string|Object, string|function, Array|Promise.
  // Any other types are currently skipped, but can be validated by the component in a future ER.
  var type = metadata.type;

  if (type) {
    type = type.toLowerCase();
    var typeAr = type.split('|');

    var typeOf = _typeof(value);

    if (typeAr.length === 1) {
      if (type.substring(0, 5) === 'array' && !Array.isArray(value) || type.substring(0, 6) === 'object' && typeOf !== 'object' || type === 'number' && !(typeof value === 'number' && isFinite(value)) || // Number.isFinite isn't availabe on IE11
      type === 'string' && typeOf !== 'string') {
        oj.BaseCustomElementBridge.__ThrowTypeError(element, property, value, type);
      } // Treat boolean property sets like the DOM does where any value that passes
      // 'if (boolVal)' results in a true prop set


      if (type === 'boolean') {
        // eslint-disable-next-line no-param-reassign
        value = !!value;
      }
    } else if (typeAr.length === 2) {
      var strIdx = typeAr.indexOf('string');
      var promiseIdx = typeAr.indexOf('promise');
      var otherType;

      if (strIdx !== -1 && typeOf !== 'string') {
        otherType = strIdx === 0 ? typeAr[1] : typeAr[0];

        if (otherType === 'function' && typeOf !== 'function' || otherType.substring(0, 5) === 'array' && !Array.isArray(value) || otherType.substring(0, 6) === 'object' && typeOf !== 'object') {
          oj.BaseCustomElementBridge.__ThrowTypeError(element, property, value, type);
        }
      } else if (promiseIdx !== -1 && !(value instanceof Promise)) {
        otherType = promiseIdx === 0 ? typeAr[1] : typeAr[0];

        if (otherType.substring(0, 5) === 'array' && !Array.isArray(value)) {
          oj.BaseCustomElementBridge.__ThrowTypeError(element, property, value, type);
        }
      }
    }
  }

  return value;
};
/**
 * Compares two values, returning true if they are equal. Does a deeper check for writeback values
 * because we can't prevent knockout from triggering a second property set with the same values
 * when writing back, but we do want to prevent the addtional update and property changed event.
 * @ignore
 */


oj.BaseCustomElementBridge.__CompareOptionValues = function (property, metadata, value1, value2) {
  if (metadata.writeback) {
    return oj.Object.compareValues(value1, value2);
  }

  return value1 === value2;
};
/**
 * @ignore
 */


oj.BaseCustomElementBridge.__ThrowTypeError = function (element, property, value, type) {
  var bridge = oj.BaseCustomElementBridge.getInstance(element);
  bridge.throwError(element, "Invalid type '" + _typeof(value) + "' found for property '" + property + "'. Expected value of type '" + type + "'.");
};
/**
 * @ignore
 */


oj.BaseCustomElementBridge.__GetDescriptor = function (tagName) {
  return oj.BaseCustomElementBridge._registry[tagName.toLowerCase()].descriptor;
};
/**
 * @ignore
 */


oj.BaseCustomElementBridge.__GetCache = function (tagName) {
  if (tagName) {
    return oj.BaseCustomElementBridge._registry[tagName.toLowerCase()].cache;
  }

  return null;
};
/**
 * Checks to see if there are any overlapping attribute for the given element and attribute
 * @ignore
 */


oj.BaseCustomElementBridge.__CheckOverlappingAttribute = function (element, attr) {
  var attrPath = attr.split('.');

  if (attrPath.length > 1) {
    attrPath.pop();

    while (attrPath.length) {
      var attrSubPath = attrPath.join('.');

      if (element.hasAttribute(attrSubPath)) {
        var bridge = oj.BaseCustomElementBridge.getInstance(element);
        bridge.throwError(element, "Cannot set overlapping attributes '" + attr + "' and '" + attrSubPath + "'.");
      }

      attrPath.pop();
    }
  }
};
/**
  * Returns the metadata for the property, walking down the metadata hierarchy
  * for subproperties.
  * @param {string} prop The property including dot notation if applicable
  * @param {Object} metadata The component metadata
  * @return {Object|null} The metadata for the property or subproperty or
  *                       null if not a component property, e.g. a global attribute
  * @ignore
  */


oj.BaseCustomElementBridge.__GetPropertyMetadata = function (prop, metadata) {
  var meta = metadata;
  var propAr = prop.split('.');

  for (var i = 0; i < propAr.length; i++) {
    meta = meta[propAr[i]];

    if (!meta) {
      break;
    }

    if (propAr.length > 1 && i < propAr.length - 1) {
      meta = meta.properties;

      if (!meta) {
        break;
      }
    }
  }

  return meta;
};
/**
 * @ignore
 */


oj.BaseCustomElementBridge.__InitProperties = function (element, componentProps) {
  var bridge = oj.BaseCustomElementBridge.getInstance(element);
  bridge.__INITIALIZING_PROPS = true;
  var metaProps = oj.BaseCustomElementBridge.getProperties(bridge);

  if (metaProps) {
    var attrs = element.attributes; // attrs is a NodeList

    for (var i = 0; i < attrs.length; i++) {
      var attr = attrs[i];

      var property = oj.__AttributeUtils.attributeToPropertyName(attr.nodeName); // See if attribute is a component property


      var meta = oj.BaseCustomElementBridge.__GetPropertyMetadata(property, metaProps);

      if (meta && !meta.readOnly) {
        // If complex property, check if there are any overlapping attributes
        oj.BaseCustomElementBridge.__CheckOverlappingAttribute(element, attr.nodeName);

        var info = oj.__AttributeUtils.getExpressionInfo(attr.value);

        if (!info.expr) {
          var value = oj.BaseCustomElementBridge.__ParseAttrValue(element, attr.nodeName, property, attr.value, meta);

          bridge.ValidateAndSetProperty(bridge.GetAliasForProperty.bind(bridge), componentProps, property, value, element);
        }
      }
    }
  }

  bridge.__INITIALIZING_PROPS = false;
};
/**
 * @param {function} propNameFun A function that returns the actual property name to use, e.g. an alias
 * @param {Object} componentProps The object to set the new property value on which is the
 *                                element for outer property sets and the property bag for inner sets.
 * @param {string} property The property name
 * @param {Object} value The value to set for the property
 * @ignore
 */


oj.BaseCustomElementBridge.__SetProperty = function (propNameFun, componentProps, property, value) {
  var propsObj = componentProps;
  var propPath = property.split('.');
  var branchedProps; // Set subproperty, initializing parent objects along the way unless the top level
  // property is not defined since setting it to an empty object will trigger a property changed
  // event. Instead, branch and set at the end. We only have listeners on top level properties
  // so setting a subproperty will not trigger a property changed event along the way.

  var topProp = propNameFun(propPath[0]);

  if (propPath.length > 1 && !componentProps[topProp]) {
    branchedProps = {};
    propsObj = branchedProps;
  } // Walk to the correct location


  for (var i = 0; i < propPath.length; i++) {
    var subprop = propNameFun(propPath[i]);

    if (i === propPath.length - 1) {
      propsObj[subprop] = value;
    } else if (!propsObj[subprop]) {
      propsObj[subprop] = {};
    }

    propsObj = propsObj[subprop];
  } // Update the original component properties if we branched


  if (branchedProps) {
    // eslint-disable-next-line no-param-reassign
    componentProps[topProp] = branchedProps[topProp];
  }
};
/**
 * @ignore
 */


oj.BaseCustomElementBridge.__GetProperty = function (componentProps, property) {
  var propsObj = componentProps;
  var propPath = property.split('.');

  for (var i = 0; i < propPath.length; i++) {
    var subprop = propPath[i]; // If no metadata is passed in, assume that the value has already been evaluated

    if (i === propPath.length - 1) {
      return propsObj[subprop];
    } else if (!propsObj[subprop]) {
      return undefined;
    }

    propsObj = propsObj[subprop];
  }

  return undefined;
};
/**
 * Returns the coerced attribute value using a custom parse function or the framework default.
 * @ignore
 */


oj.BaseCustomElementBridge.__ParseAttrValue = function (elem, attr, prop, val, metadata) {
  if (val == null) {
    return val;
  }

  var type = metadata.type;
  var bridge = oj.BaseCustomElementBridge.getInstance(elem);

  function _coerceVal(value) {
    var coercedValue;

    try {
      coercedValue = oj.__AttributeUtils.coerceValue(elem, attr, value, type);
    } catch (ex) {
      bridge.throwError(elem, 'Error parsing attribute value.', ex);
    }

    return coercedValue;
  }

  var parseFunction = oj.BaseCustomElementBridge.__GetDescriptor(elem.tagName).parseFunction;

  if (parseFunction) {
    return parseFunction(val, prop, metadata, function (value) {
      return _coerceVal(value);
    });
  }

  return _coerceVal(val);
};
/**
 * @ignore
 */


oj.BaseCustomElementBridge.__ProcessEventListeners = function (_metadata) {
  var metadata = oj.CollectionUtils.copyInto({}, _metadata, undefined, true, 1);
  metadata.properties = metadata.properties || {};

  oj.BaseCustomElementBridge._enumerateMetadataForKey(null, metadata, 'properties', function (proto, property) {
    var eventName = oj.__AttributeUtils.propertyNameToChangeEventType(property);

    var eventListenerProperty = oj.__AttributeUtils.eventTypeToEventListenerProperty(eventName);

    metadata.properties[eventListenerProperty] = {
      _derived: true,
      _eventListener: true
    };
  });

  oj.BaseCustomElementBridge._enumerateMetadataForKey(null, metadata, 'events', function (proto, event) {
    var eventListenerProperty = oj.__AttributeUtils.eventTypeToEventListenerProperty(event);

    metadata.properties[eventListenerProperty] = {
      _derived: true,
      _eventListener: true
    };
  });

  return metadata;
};
/**
 * @ignore
 * @param {string} tagName
 * @param {Object} descriptor
 * @param {Object} bridgeProto
 * @param {boolean=} isComposite
 */


oj.BaseCustomElementBridge.__Register = function (tagName, descriptor, bridgeProto, isComposite) {
  var name = tagName.toLowerCase();

  if (!oj.BaseCustomElementBridge._registry[name]) {
    if (!descriptor) {
      Logger.error('Cannot register ' + tagName + '. Missing a descriptor.');
    }

    oj.BaseCustomElementBridge._registry[name] = {
      descriptor: descriptor,
      bridgeProto: bridgeProto,
      composite: isComposite,
      cache: {}
    };
    return true;
  }

  return false;
};
/**
 * @ignore
 * @param {Element} element
 * @param {string} name
 * @param {Object} value
 * @param {Object} previousValue
 * @param {string} updatedFrom
 * @param {Object=} subprop
 */


oj.BaseCustomElementBridge.__FirePropertyChangeEvent = function (element, name, value, previousValue, updatedFrom, subprop) {
  var bridge = oj.BaseCustomElementBridge.getInstance(element); // There are cases where a subproperty set can trigger a top level property set
  // if the top level property was not instantiated to an empty object. We don't want
  // to fire two events for that case. The BaseCustomElementBridge has logic to fire
  // the subproperty change event there.

  if (!bridge._SKIP_PROP_CHANGE_EVENT) {
    var detail = {};

    if (subprop) {
      detail.subproperty = subprop;
    }

    detail.value = value;
    detail.previousValue = previousValue;
    detail.updatedFrom = updatedFrom; // Check if the subclass needs to do anything before we fire the property change event,
    // e.g. composites that need to call the propertyChanged ViewModel callback.

    if (bridge.beforePropertyChangedEvent) {
      bridge.beforePropertyChangedEvent(element, name, detail);
    } // The bridge sets the ready to fire flag after the component has been instantiated.
    // We shouldn't fire property changed events before then unless the update comes from internally
    // for cases like readOnly property updates.


    if (updatedFrom !== 'external' || bridge.__READY_TO_FIRE) {
      element.dispatchEvent(new CustomEvent(name + 'Changed', {
        detail: detail
      }));
    }
  }
};
/**
 * @ignore
 */


oj.BaseCustomElementBridge.__DefineDynamicObjectProperty = function (obj, property, getter, setter) {
  Object.defineProperty(obj, property, {
    enumerable: true,
    get: getter,
    set: setter
  });
};
/**
 * @ignore
 */


oj.BaseCustomElementBridge._registry = {};
/** @ignore */

oj.BaseCustomElementBridge.DESC_KEY_CSS = 'css';
/** @ignore */

oj.BaseCustomElementBridge.DESC_KEY_META = 'metadata';
/** @ignore */

oj.BaseCustomElementBridge.DESC_KEY_PARSE_FUN = 'parseFunction';
/** @ignore */

oj.BaseCustomElementBridge.DESC_KEY_VIEW = 'view';
/** @ignore */

oj.BaseCustomElementBridge.DESC_KEY_VIEW_MODEL = 'viewModel';
/**
 * @ignore
 */

oj.BaseCustomElementBridge._INSTANCE_KEY = '_ojBridge';
/**
 * Class used to track the create state.
 * @constructor
 * @protected
 * @ignore
 */

oj.BaseCustomElementBridge.__DelayedPromise = function () {
  var _promise;

  var _resolve;

  var _reject;
  /**
   * Returns the create Promise, creating one as needed.
   * @return {Promise}
   * @ignore
   */


  this.getPromise = function () {
    if (!_promise) {
      _promise = new Promise(function (resolve, reject) {
        _resolve = resolve;
        _reject = reject;
      });
    }

    return _promise;
  };
  /**
   * Rejects the create Promise if one exists.
   * @ignore
   */


  this.rejectPromise = function (reason) {
    if (_reject) {
      _reject(reason);
    }
  };
  /**
   * Resolves the create Promise if one exists.
   * @ignore
   */


  this.resolvePromise = function (value) {
    if (_resolve) {
      _resolve(value);
    }
  };
};



/**
 * @ojoverviewdoc CustomElementOverview - [2]JET Web Components
 * @classdesc
 * {@ojinclude "name":"customElementOverviewDoc"}
 */

/**
 * <h2 id="ce-overview-section">
 *   Overview<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-overview-section"></a>
 * </h2>
 * <p>
 *   JET components and <a href="CompositeOverview.html">custom components</a>, collectively referred to as <b>JET Web Components</b>,
 *   are implemented as <a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Custom_Elements">custom HTML elements</a>
 *   and extend the <a href="https://html.spec.whatwg.org/multipage/dom.html#htmlelement">HTMLElement</a> interface. This means that
 *   JET custom elements automatically inherit
 *   <a href=https://html.spec.whatwg.org/multipage/dom.html#global-attributes>global attributes</a>
 *   and programmatic access to these components is similar to interacting with native HTML elements.
 *   All JET components live in the "oj" namespace and have HTML element names starting with "oj-". We will use
 *   the term "JET component" to refer to both native JET custom elements and custom elements implemented using the
 *   <a href="oj.Composite.html">Composite</a> component APIs after this point.
 * </p>
 * <h2 id="ce-overview-upgrade-section" class="subsection-title">
 *   Upgrading a Custom Element<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-overview-upgrade-section"></a>
 * </h2>
 * <p>
 *   The upgrade process will begin for current JET custom elements in the DOM when the component module is loaded,
 *   registering a class constructor with its tag name using the
 *   <a href="https://developer.mozilla.org/en-US/docs/Web/API/CustomElementRegistry/define">CustomElementRegistry</a>
 *   <code>define()</code> API. Existing elements matching the registered tag name will be updated to inherit the new
 *   class definition and all of the component properties and methods will be available on the custom element after
 *   this process completes. Additionally, JET components will resolve any data bindings during the upgrade process.
 *   The application is responsible for calling their binding provider to apply bindings or for adding a
 *   <code>data-oj-binding-provider="none"</code> attribute in their page to indicate that no data bindings exist.
 *   Note that the JET custom element upgrade process will not complete until data bindings
 *   are resolved or no binding provider is indicated using the <code>data-oj-binding-provider</code> attribute.
 *   Also, due to JET components' data binding support, all JET component upgrades will occur asynchronously regardless
 *   of whether a binding provider is used.
 *   Please see the <a href="#ce-databind-section">data binding</a> section for more details on binding providers and data binding.
 *   The application should not interact with the JET custom element except to  programmatically set properties until the
 *   custom element upgrade is complete. The recommended way to wait on the asynchronous upgrade process is to use an
 *   element-scoped or page-level <a href="oj.BusyContext.html">BusyContext</a>.
 * </p>
 * <h2 id="ce-overview-usage-section" class="subsection-title">
 *   Using a JET Custom Element<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-overview-usage-section"></a>
 * </h2>
 * <p>
 *   Custom elements can be used declaratively in HTML by using the component tag name and attributes. They are not self closing
 *   elements and applications should include a closing tag. To interact with them  programmatically, DOM APIs can be used to
 *   retrieve the element and then access properties and methods directly on the element instance. JET custom elements can also fire
 *   <code>CustomEvents</code> for which the application can attach event listeners both declaratively and  programmatically.
 *   The rest of this document discusses these features in more detail.
 * </p>
 *
 * <h2 id="ce-attributes-section" class="subsection-title">
 *   Attributes<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-attributes-section"></a>
 * </h2>
 * <p>
 *   Attribute values set as string literals will be parsed and coerced to the property type. JET currently
 *   only supports the following string literal type coercions: boolean, number, string, Object and Array, where
 *   Object and Array types must use JSON notation with double quoted strings. A special "any" type is also supported
 *   and is described <a href="#ce-attrs-any-section">below</a>. All other types should to be set using
 *   <a href="#ce-databind-section">expression syntax</a> in the DOM or using the element's property setters or <code>setProperty</code>
 *   and <code>setProperties</code> methods programmatically. Unless updates are done via the DOM element.setAttribute(),
 *   the DOM's attribute value will not reflect changes like those done via the property setters or the setProperty and
 *   setProperties methods. Attribute removals are treated as unsetting of a property where the component default value will be used if one exists.
 * </p>
 * <p>
 *   As described <a href="#ce-databind-section">below</a>, JET uses [[...]] and {{...}} syntax to represent data bound expressions.
 *   JET does not currently provide any escaping syntax for "[[" or "{{" appearing at the beginning of the attribute
 *   value. You will need to add a space character to avoid having the string literal value interpreted as a binding
 *   expression (e.g. &lt;oj-some-element some-attribute='[ ["arrayValue1", "arrayValue2", ... ] ]'>&lt;/oj-some-element>).
 * </p>
 * <h2 id="ce-attrs-boolean-section" class="subsection-title">
 *   Boolean Attributes<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-attrs-boolean-section"></a>
 * </h2>
 * <p>
 *   JET components treat boolean attributes differently than HTML5. Since a common application use case
 *   is to toggle a data bound boolean attribute, JET will coerce the string literal "false" to the boolean
 *   false for boolean attributes. The absence of a boolean attribute in the DOM will also be interpreted as false.
 *   JET will coerce the following string literal values to the boolean true and throw an Error for all other
 *   invalid values.
 *   <ul>
 *    <li>No value assignment (e.g. &lt;oj-some-element boolean-attribute>&lt;/oj-some-element>)</li>
 *    <li>Empty string (e.g. &lt;oj-some-element boolean-attribute="">&lt;/oj-some-element>)</li>
 *    <li>The "true" string literal (e.g. &lt;oj-some-element boolean-attribute="true">&lt;/oj-some-element>)</li>
 *    <li>The case-insensitive attribute name (e.g. &lt;oj-some-element boolean-attribute="boolean-attribute">&lt;/oj-some-element>)</li>
 *   </ul>
 * </p>
 * <h2 id="ce-attrs-object-section" class="subsection-title">
 *   Object-Typed Attributes<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-attrs-object-section"></a>
 * </h2>
 * <p>
 *   Attributes that support Object type can be declaratively set using dot notation.
 *   Note that applications should not set overlapping attributes as these will cause an error to be thrown.
 *   <pre class="prettyprint">
 *   <code>
 * &lt;!-- person is an Object typed attribute with a firstName subproperty -->
 * &lt;oj-some-element person.first-name="{{name}}">&lt;/oj-some-element>
 *
 * &lt;!-- overlapping attributes will throw an error -->
 * &lt;oj-some-element person="{{personInfo}}" person.first-name="{{name}}">&lt;/oj-some-element>
 *   </code>
 *   </pre>
 *   If applications need to programmatically set subproperties, they can call the JET components's <code>setProperty</code>
 *   method with dot notation using the camelCased property syntax (e.g. element.setProperty("person.firstName", "Sally")).
 * </p>
 * <h2 id="ce-attrs-any-section" class="subsection-title">
 *   Any-Typed Attributes<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-attrs-any-section"></a>
 * </h2>
 * <p>
 *   Attributes that support any type are documented with type {any} in the API doc and will be coerced as
 *   Objects, Arrays, or strings when set in HTML as a string literal. Numeric types are not supported due
 *   to the fact that we cannot determine whether value="2" on a property supporting any type should be
 *   coerced to a string or a number. The application should use data binding for all other value types and ensure
 *   that when linking any-typed attributes across multiple components, that the resolved types will match, e.g.
 *   do not data bind an <oj-select-one> <code>value</code> attribute to a numeric value and use a string literal
 *   number for its child <oj-option> <code>value</code> attributes since those would evaluate to strings.
 * </p>
 *
 * <h2 id="ce-databind-section" class="subsection-title">
 *   Data Binding<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-databind-section"></a>
 * </h2>
 * <p>
 *   Applications can use the JET data binding syntax in order to use expressions or a non coercible attribute
 *   type (e.g. a type other than boolean, number, string, Object or Array) declaratively in HTML.
 *   This syntax can be used on both JET custom elements and native HTML elements.
 *   The application is responsible for applying bindings using a supported binding provider which then notifies
 *   JET framework code that the bindings have been resolved and to finish the custom element upgrade process.
 * </p>
 * <h2 id="ce-databind-bindingprovider-section" class="subsection-title">
 *   Binding Providers<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-databind-bindingprovider-section"></a>
 * </h2>
 * <p>
 *   The binding provider is responsible for setting and updating attribute
 *   expressions and any custom elements within its managed subtree will not finish upgrading until it
 *   applies bindings on that subtree. By default, there is a single binding provider for a page,
 *   but subtree specific binding providers can be added by using the <code>data-oj-binding-provider</code>
 *   attribute with values of "none" and "knockout". The default binding provider is knockout, but if a
 *   page or DOM subtree does not use any expression syntax or knockout, the application can set
 *   <code>data-oj-binding-provider="none"</code> on that element so its dependent JET custom elements
 *   do not need to wait for bindings to be applied to finish upgrading. Note that regardless of whether a
 *   binding provider is used, the custom element upgrade process will be asynchronous. <b>When using the
 *   knockout binding provider, applications should require the ojknockout module.</b>
 * </p>
 * <h2 id="ce-databind-syntax-section" class="subsection-title">
 *   Data Binding Syntax for JET Components<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-databind-syntax-section"></a>
 * </h2>
 * <p>
 *   Data binding syntax can be used directly on component attributes. See the specific component API doc
 *   for the complete list of component attributes. Global HTML attributes inherited from HTMLElement can also be
 *   data bound, but require special syntax described below. JET detects data bound attributes by looking for values
 *   wrapped with {{...}} or [[...]]. Please note that there should be no spaces between the braces
 *   when using the data bind syntax (e.g. some-attribute="[ [...] ]"). The {{...}} wrapped expression indicates that the
 *   application is allowing the component to update the expression which can be a knockout observable. Attributes
 *   bound using [[...]] will not be updated or "written back" to by the component. Unless the component attribute documents
 *   that it supports "writeback", we recommend that the [[...]] syntax be used, e.g. selection-mode="[[currentSelectionMode]]".
 * </p>
 * <h2 id="ce-databind-writeback-section" class="subsection-title">
 *   Writeback<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-databind-writeback-section"></a>
 * </h2>
 * <p>
 *   Certain properties such as "value" on editable components support updating the associated expression
 *   automatically whenever their value changes. This usually occurs after user interaction such as with selection
 *   or typing into an input field. This expression update functionality is also known as "writeback".
 *   Applications can control expression writeback by using the {{...}} syntax for two-way writable
 *   binding expressions or [[...]] for one-way only expressions. The one-way expressions should
 *   be used when the application needs expressions strictly for "downstream-only" purposes, e.g. only for
 *   updating a component property. Note that if a writeback attribute is bound using the "downstream-only"
 *   syntax, the application and component states can become out of sync. This is different from the
 *   read-only properties, which are "upstream-only", e.g. they are used only to monitor component state.
 *   Thus an expression associated with a read-only property should always use the {{}} syntax.
 *   Most component properties do not writeback and those that do will indicate it in their API doc.
 * </p>
 * <pre class="prettyprint">
 *   <code>
 *   &lt;oj-some-element value="[[currentValue]]" selection={{currentSelection}}>&lt;/oj-some-element>
 *   </code>
 * </pre>
 * <h2 id="ce-databind-global-section" class="subsection-title">
 *   Data Binding Syntax for Native HTML Elements and Global Attributes
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-databind-global-section"></a>
 * </h2>
 * <p>
 *   JET's data binding syntax can also be used on native HTML elements and
 *   <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes">global attributes</a>
 *   to create one-way bindings by prefixing the attribute
 *   name with ":" (e.g. :id="[[idVar]]"). The attribute binding syntax results in the attribute being set in the DOM
 *   with the evaluated expression. Since global HTML attributes are always string typed, expressions using the ":"
 *   prefixing should resolve to strings with the exception of the style and class attributes which support additional types
 *   and are described in more detail below. In the case of component attributes, applications are recommended to bind
 *   the attribute names directly and avoid the use of the ":" prefix.
 * </p>
 * <h2 id="ce-databind-class-section" class="subsection-title">
 *   :Class Attribute<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-databind-class-section"></a>
 * </h2>
 * <p>
 *   The class attribute binding supports a space delimited string of classes, an Array of classes, or an Object whose keys are
 *   individual style classes and whose values are booleans to determine whether those style classes should be present in the DOM
 *   (e.g. :class="[[{errorClass: hasErrors}]]"). Note that the Array and string types will override existing values in the class
 *   attribute when updates occur, whereas the Object type will only add and remove the classes specified. Since JET custom elements
 *   add their own classes, we recommend using the Object type when using the class attribute binding on JET custom elements.
 * </p>
 * <h2 id="ce-databind-style-section" class="subsection-title">
 *   :Style Attribute<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-databind-style-section"></a>
 * </h2>
 * <p>
 *   When using the style attribute binding with an Object type, the style Object names should be the JavaScript
 *   names for that style (e.g. "fontWeight" instead of "font-weight" style='{"fontWeight": "..."}').
 *   Since the style attribute supports Object types, it also supports dot notation for setting style subproperties
 *   directly (e.g. :style.font-weight="[[...]]").
 * </p>
 *
 * <h2 id="ce-properties-section" class="subsection-title">
 *   Properties<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-properties-section"></a>
 * </h2>
 * <p>
 *   In addition to properties inherited from the HTMLElement prototype, attributes listed
 *   in the component API doc will also be exposed as properties on the JET custom element.
 *   See the <a href="#ce-proptoattr-section">property to attribute mapping</a>
 *   section below to see the syntax difference between setting attributes and properties.
 *   These properties can be set at any time, but can only be retrieved once the HTML element
 *   is fully upgraded. Early property sets before the component has been upgraded
 *   will not result in [property]Changed events and will be passed to the component as part of its initial state.
 * </p>
 * <h2 id="ce-properties-readonlywriteback-section" class="subsection-title">
 *   Read-only and Writeback Properties
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-properties-readonlywriteback-section"></a>
 * </h2>
 * <p>
 *   Some properties are specially marked as read-only or supporting writeback in the component API doc.
 *   Read-only properties can only be read and not set by the application and generally support writeback.
 *   Writeback properties support automatic updates if they are bound using two way data binding syntax to an
 *   expression, e.g. value="{{valueObservable}}".
 *   Applications can bind an expression to a read-only attribute in HTML by using the {{..}} to ensure
 *   that updates will be reflected in the observable, but should not use this syntax to try and push a
 *   value to the read-only attribute which will result in an error state.
 *   Similarly, property sets using the setProperty, setProperties, or the element property setters should also
 *   be avoided for a read-only property.
 * </p>
 * <h2 id="ce-properties-subproperties-section" class="subsection-title">Subproperties
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-properties-subproperties-section"></a>
 * </h2>
 * <p>
 *   Some JET components support complex properties where the top level property is of type Object and it
 *   contains additional subproperties. If the application needs to set a single subproperty
 *   instead of the entire complex property, the <code>setProperty</code> method should be used
 *   instead to ensure that [property]Changed events will be fired with the subproperty changes.
 *   Note that directly updating the subproperty via dot notation (e.g. element.topProp.subProp = newValue)
 *   will not result in a [property]Changed event being fired.
 * </p>
 * <h2 id="ce-properties-unset-section" class="subsection-title">Unsetting of a Property
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-properties-unset-section"></a>
 * </h2>
 * <p>
 *   The undefined value is treated as unsetting of a property when passed to the
 *   property setter and will result in the component using the default value if one exists. Unsetting of
 *   subproperties using the element's <code>setProperty</code> is not supported. Subproperties can only
 *   only be unset when the top level property is unset.
 *   Property sets will not result in DOM attribute updates and after the custom
 *   element is upgraded, the application should use the custom element properties, not attributes to check
 *   the current value.
 * </p>
 * <h2 id="ce-properties-changed-section" class="subsection-title">[property]Changed Events
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-properties-changed-section"></a>
 * </h2>
 * <p>
 *   When a property or attribute value changes, a non-bubbling [property]Changed <code>CustomEvent</code>
 *   will be fired with the following properties in the event's detail property.
 *   <table class="props">
 *     <thead>
 *       <tr>
 *         <th>Name</th>
 *         <th>Type</th>
 *         <th>Description</th>
 *       </tr>
 *     </thead>
 *     <tbody>
 *       <tr>
 *      <td>value</td>
 *      <td>any</td>
 *      <td>The current value of the property that changed.</td>
 *    </tr>
 *    <tr>
 *      <td>previousValue</td>
 *      <td>any</td>
 *      <td>The previous value of the property that changed.</td>
 *    </tr>
 *    <tr>
 *      <td>updatedFrom</td>
 *      <td>string</td>
 *      <td>
 *        Where the property was updated from. Supported values are:
 *        <ul>
 *          <li>external - By the application, using either the element's property setter, setAttribute, or external data binding.</li>
 *          <li>internal - By the component, e.g. after user interaction with a text field or selection.</li>
 *        </ul>
 *      </td>
 *    </tr>
 *    <tr>
 *      <td>subproperty</td>
 *      <td>Object</td>
 *      <td>An object holding information about the subproperty that changed.
 *        <table class="props">
 *          <thead>
 *            <tr>
 *              <th>Name</th>
 *              <th>Type</th>
 *              <th>Description</th>
 *            </tr>
 *          </thead>
 *        <tbody>
 *          <tr>
 *            <td>path</td>
 *            <td>string</td>
 *            <td>
 *              The subproperty path that changed, starting from the top level
 *              property with subproperties delimited by ".".
 *            </td>
 *          </tr>
 *          <tr>
 *            <td>value</td>
 *            <td>any</td>
 *            <td>The current value of the subproperty that changed.</td>
 *          </tr>
 *          <tr>
 *            <td>previousValue</td>
 *            <td>any</td>
 *            <td>The previous value of the subproperty that changed.</td>
 *            </tr>
 *            </tbody>
 *          </table>
 *        </td>
 *      </tr>
 *    </tbody>
 *   </table>
 * </p>
 * <p>
 *   Please note that in order for components to be notified of a property change for Array properties, the
 *   value should be data bound and updated using an expression, setting the property to an updated copy
 *   by calling slice(), or by refreshing the component after an in place Array mutation.
 * </p>
 * <p>
 *   See <a href="#ce-events-section">Events and Listeners</a> for additional information on how to listen for
 *   these events.
 * </p>
 * <p>
 * Note as well that in cases where a component property that supports writeback is bound to a writable expression,
 * the relative order of expression writing and invocation of property change listeners is not guaranteed.
 * For this reason, it is not recommended to write logic that depends both on component/event state and application
 * view model state.
 * </p>
 * <h2 id="ce-proptoattr-section" class="subsection-title">Property-to-Attribute Mapping
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-proptoattr-section"></a>
 * </h2>
 * <p>
 *   The following rules apply when mapping property to attribute names:
 *   <ul>
 *     <li>Attribute names are case insensitive. CamelCased properties are mapped to
 *   kebab-cased attribute names by inserting a dash before the uppercase letter and converting that letter to lower case
 *   (e.g. a "chartType" property will be mapped to a "chart-type" attribute).</li>
 *     <li> The reverse occurs when mapping a property name from an attribute name.</li>
 *   </ul>
 * </p>
 *
 * <h2 id="ce-methods-section" class="subsection-title">
 *   Methods<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-methods-section"></a>
 * </h2>
 * <p>
 *   Methods can be accessed on the JET component after the element is fully upgraded. See
 *   the component API doc for specifics.
 * </p>
 *
 * <h2 id="ce-events-section" class="subsection-title">
 *   Events and Listeners<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-events-section"></a>
 * </h2>
 * <p>
 *   JET Web Components, like other custom HTML elements, may fire <code>CustomEvents</code>.  These
 *   events will be described in component documentation, including whether they bubble, are cancelable and any
 *   event detail payloads. In addition, JET components
 *   fire non-bubbling, non-cancelable [property]Changed (e.g. valueChanged) <code>CustomEvents</code>
 *   whenever a property is updated. See the <a href="#ce-properties-section">properties section</a> above
 *   for details on the event payload.
 * </p>
 *  <p>
 *   JET <code>CustomEvents</code> can be listened to using the standard addEventListener mechanism:
 *   <pre class="prettyprint">
 *   <code>
 * someElement.addEventListener("eventName", function(event) {...});
 *   </code>
 *   </pre>
 * </p>
 * <p>
 *   Additionally, JET custom elements and native HTML elements within JET pages support declarative specification of event
 *   listeners via <code>on-[event-name]</code> attributes (e.g. <code>on-click</code>,
 *   <code>on-value-changed</code> or <code>on-oj-expand</code>). The attributes ultimately delegate to the standard
 *   <code>addEventListener</code> mechanism and only support data bound expressions
 *   that evaluate to functions; arbitrary JavaScript will not be accepted.
 * </p>
 * <p>
 *   Please note that event listeners specified using this syntax can only be set during component initialization.
 *   Subsequent setAttribute calls for the event listener attributes will be ignored.
 *   There is no associated <code>on[EventName]</code> property on the JET custom element for the equivalent
 *   <code>on-[event-name]</code> attribute.
 * </p>
 * <p>
 *   In addition to the event parameter, event listeners specified via <code>on-[event-name]</code>
 *   attributes will receive two additional parameters when they are invoked: <code>data</code> and <code>bindingContext</code>.
 *   The <code>bindingContext</code> parameter provides the listener with the entire data binding context that
 *   was applied to the element while the data parameter provides convenient access to relevant data.
 *   When in an iteration context (e.g. inside an <code>oj-bind-for-each</code>), the <code>data</code> parameter
 *   is equal to <code>bindingContext["$current"]</code>; otherwise, it is equal to <code>bindingContext["$data"]</code>.
 *   These declarative event listeners should take the form:
 *   <pre class="prettyprint">
 *   <code>
 * &lt;oj-some-element on-event-name="[[eventListener]]">&lt;/oj-some-element>
 *
 *
 * function eventListener(event, data, bindingContext) {
 *   ...
 * }
 *   </code>
 *   </pre>
 * </p>
 *
 * <h2 id="ce-slots-section" class="subsection-title">
 *   Slots<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-slots-section"></a>
 * </h2>
 * <p>
 *  Some JET components allow application provided child content. This child content will be moved by the JET component to
 *  a designated "slot" and is referred to as slot content. Slot content can have one of two characteristics:
 *  <ul>
 *    <li>
 *      Named slot content - Any direct child element with a slot attribute will be moved into that named slot, e.g.  &lt;span slot='startIcon'>... &lt;/span>.
 *      All supported named slots are described in the API Doc. Child elements with unsupported named slots will be removed from the DOM.
 *    </li>
 *    <li>
 *      Default slot content - Any direct child element lacking a slot attribute will be moved to the default slot, also known as a regular child.
 *    </li>
 *  </ul>
 *  Bindings are applied to slot content in the application's context with the exception of template slots which are described
 *  below. Slot content are moved to their designated component slots after bindings are applied. <b>Please note that only text and
 *  element nodes can be assigned to a slot. Comment nodes are not eligible, so oj-bind-* elements which resolve to comment nodes
 *  after bindings are applied should be wrapped in a span or other element node for slotting.</b>
 * </p>
 * <h3 id="ce-slots-template-section" class="subsection-title">
 *   Template Slots<a class="bookmarkable-link" title="Bookmarkable Link" href="#ce-slots-template-section"></a>
 * </h3>
 * <p>
 *  Some components support template slots which allow the application to pass a template element with a DOM fragment that
 *  will be stamped out by the component. Bindings are not applied to template slot content until they are stamped out by the
 *  component. All template slot children will have access to the following variables:
 *  <ul>
 *    <li>$current - Default variable that contains component exposed subproperties as documented in the component's API doc.</li>
 *    <li>component-level template alias - Set by the application if the component has provided a component-level alias attribute
 *        as part of its API. Provides a template alias available to all template slot binding contexts and has the same
 *        subproperties as the $current variable.</li>
 *    <li>template-level alias - Set by the application on the template element via the 'data-oj-as' attribute. Provides an alias
 *        for a specific template instance and has the same subproperties as the $current variable.</li>
 *  </ul>
 *  Note that $current is always availble on the binding context regardless of whether any application provided aliases are set.
 * </p>
 *
 * @ojfragment customElementOverviewDoc - General description doc fragment that shows up in every component's page via a link.
 * @memberof CustomElementOverview
 */

});
/*! jQuery UI - v1.12.1 - 2016-09-15
* http://jqueryui.com
* Copyright jQuery Foundation and other contributors; Licensed  */
!function(e){"function"==typeof define&&define.amd?define('jqueryui-amd/version',["jquery"],e):e(jQuery)}(function(e){return e.ui=e.ui||{},e.ui.version="1.12.1"});
/*! jQuery UI - v1.12.1 - 2016-09-15
* http://jqueryui.com
* Copyright jQuery Foundation and other contributors; Licensed  */
!function(t){"function"==typeof define&&define.amd?define('jqueryui-amd/widget',["jquery","./version"],t):t(jQuery)}(function(t){var e=0,i=Array.prototype.slice;return t.cleanData=function(e){return function(i){var s,n,o;for(o=0;null!=(n=i[o]);o++)try{s=t._data(n,"events"),s&&s.remove&&t(n).triggerHandler("remove")}catch(t){}e(i)}}(t.cleanData),t.widget=function(e,i,s){var n,o,a,r={},l=e.split(".")[0];e=e.split(".")[1];var u=l+"-"+e;return s||(s=i,i=t.Widget),t.isArray(s)&&(s=t.extend.apply(null,[{}].concat(s))),t.expr[":"][u.toLowerCase()]=function(e){return!!t.data(e,u)},t[l]=t[l]||{},n=t[l][e],o=t[l][e]=function(t,e){return this._createWidget?void(arguments.length&&this._createWidget(t,e)):new o(t,e)},t.extend(o,n,{version:s.version,_proto:t.extend({},s),_childConstructors:[]}),a=new i,a.options=t.widget.extend({},a.options),t.each(s,function(e,s){return t.isFunction(s)?void(r[e]=function(){function t(){return i.prototype[e].apply(this,arguments)}function n(t){return i.prototype[e].apply(this,t)}return function(){var e,i=this._super,o=this._superApply;return this._super=t,this._superApply=n,e=s.apply(this,arguments),this._super=i,this._superApply=o,e}}()):void(r[e]=s)}),o.prototype=t.widget.extend(a,{widgetEventPrefix:n?a.widgetEventPrefix||e:e},r,{constructor:o,namespace:l,widgetName:e,widgetFullName:u}),n?(t.each(n._childConstructors,function(e,i){var s=i.prototype;t.widget(s.namespace+"."+s.widgetName,o,i._proto)}),delete n._childConstructors):i._childConstructors.push(o),t.widget.bridge(e,o),o},t.widget.extend=function(e){for(var s,n,o=i.call(arguments,1),a=0,r=o.length;a<r;a++)for(s in o[a])n=o[a][s],o[a].hasOwnProperty(s)&&void 0!==n&&(t.isPlainObject(n)?e[s]=t.isPlainObject(e[s])?t.widget.extend({},e[s],n):t.widget.extend({},n):e[s]=n);return e},t.widget.bridge=function(e,s){var n=s.prototype.widgetFullName||e;t.fn[e]=function(o){var a="string"==typeof o,r=i.call(arguments,1),l=this;return a?this.length||"instance"!==o?this.each(function(){var i,s=t.data(this,n);return"instance"===o?(l=s,!1):s?t.isFunction(s[o])&&"_"!==o.charAt(0)?(i=s[o].apply(s,r),i!==s&&void 0!==i?(l=i&&i.jquery?l.pushStack(i.get()):i,!1):void 0):t.error("no such method '"+o+"' for "+e+" widget instance"):t.error("cannot call methods on "+e+" prior to initialization; attempted to call method '"+o+"'")}):l=void 0:(r.length&&(o=t.widget.extend.apply(null,[o].concat(r))),this.each(function(){var e=t.data(this,n);e?(e.option(o||{}),e._init&&e._init()):t.data(this,n,new s(o,this))})),l}},t.Widget=function(){},t.Widget._childConstructors=[],t.Widget.prototype={widgetName:"widget",widgetEventPrefix:"",defaultElement:"<div>",options:{classes:{},disabled:!1,create:null},_createWidget:function(i,s){s=t(s||this.defaultElement||this)[0],this.element=t(s),this.uuid=e++,this.eventNamespace="."+this.widgetName+this.uuid,this.bindings=t(),this.hoverable=t(),this.focusable=t(),this.classesElementLookup={},s!==this&&(t.data(s,this.widgetFullName,this),this._on(!0,this.element,{remove:function(t){t.target===s&&this.destroy()}}),this.document=t(s.style?s.ownerDocument:s.document||s),this.window=t(this.document[0].defaultView||this.document[0].parentWindow)),this.options=t.widget.extend({},this.options,this._getCreateOptions(),i),this._create(),this.options.disabled&&this._setOptionDisabled(this.options.disabled),this._trigger("create",null,this._getCreateEventData()),this._init()},_getCreateOptions:function(){return{}},_getCreateEventData:t.noop,_create:t.noop,_init:t.noop,destroy:function(){var e=this;this._destroy(),t.each(this.classesElementLookup,function(t,i){e._removeClass(i,t)}),this.element.off(this.eventNamespace).removeData(this.widgetFullName),this.widget().off(this.eventNamespace).removeAttr("aria-disabled"),this.bindings.off(this.eventNamespace)},_destroy:t.noop,widget:function(){return this.element},option:function(e,i){var s,n,o,a=e;if(0===arguments.length)return t.widget.extend({},this.options);if("string"==typeof e)if(a={},s=e.split("."),e=s.shift(),s.length){for(n=a[e]=t.widget.extend({},this.options[e]),o=0;o<s.length-1;o++)n[s[o]]=n[s[o]]||{},n=n[s[o]];if(e=s.pop(),1===arguments.length)return void 0===n[e]?null:n[e];n[e]=i}else{if(1===arguments.length)return void 0===this.options[e]?null:this.options[e];a[e]=i}return this._setOptions(a),this},_setOptions:function(t){var e;for(e in t)this._setOption(e,t[e]);return this},_setOption:function(t,e){return"classes"===t&&this._setOptionClasses(e),this.options[t]=e,"disabled"===t&&this._setOptionDisabled(e),this},_setOptionClasses:function(e){var i,s,n;for(i in e)n=this.classesElementLookup[i],e[i]!==this.options.classes[i]&&n&&n.length&&(s=t(n.get()),this._removeClass(n,i),s.addClass(this._classes({element:s,keys:i,classes:e,add:!0})))},_setOptionDisabled:function(t){this._toggleClass(this.widget(),this.widgetFullName+"-disabled",null,!!t),t&&(this._removeClass(this.hoverable,null,"ui-state-hover"),this._removeClass(this.focusable,null,"ui-state-focus"))},enable:function(){return this._setOptions({disabled:!1})},disable:function(){return this._setOptions({disabled:!0})},_classes:function(e){function i(i,o){var a,r;for(r=0;r<i.length;r++)a=n.classesElementLookup[i[r]]||t(),a=t(e.add?t.unique(a.get().concat(e.element.get())):a.not(e.element).get()),n.classesElementLookup[i[r]]=a,s.push(i[r]),o&&e.classes[i[r]]&&s.push(e.classes[i[r]])}var s=[],n=this;return e=t.extend({element:this.element,classes:this.options.classes||{}},e),this._on(e.element,{remove:"_untrackClassesElement"}),e.keys&&i(e.keys.match(/\S+/g)||[],!0),e.extra&&i(e.extra.match(/\S+/g)||[]),s.join(" ")},_untrackClassesElement:function(e){var i=this;t.each(i.classesElementLookup,function(s,n){t.inArray(e.target,n)!==-1&&(i.classesElementLookup[s]=t(n.not(e.target).get()))})},_removeClass:function(t,e,i){return this._toggleClass(t,e,i,!1)},_addClass:function(t,e,i){return this._toggleClass(t,e,i,!0)},_toggleClass:function(t,e,i,s){s="boolean"==typeof s?s:i;var n="string"==typeof t||null===t,o={extra:n?e:i,keys:n?t:e,element:n?this.element:t,add:s};return o.element.toggleClass(this._classes(o),s),this},_on:function(e,i,s){var n,o=this;"boolean"!=typeof e&&(s=i,i=e,e=!1),s?(i=n=t(i),this.bindings=this.bindings.add(i)):(s=i,i=this.element,n=this.widget()),t.each(s,function(s,a){function r(){if(e||o.options.disabled!==!0&&!t(this).hasClass("ui-state-disabled"))return("string"==typeof a?o[a]:a).apply(o,arguments)}"string"!=typeof a&&(r.guid=a.guid=a.guid||r.guid||t.guid++);var l=s.match(/^([\w:-]*)\s*(.*)$/),u=l[1]+o.eventNamespace,h=l[2];h?n.on(u,h,r):i.on(u,r)})},_off:function(e,i){i=(i||"").split(" ").join(this.eventNamespace+" ")+this.eventNamespace,e.off(i).off(i),this.bindings=t(this.bindings.not(e).get()),this.focusable=t(this.focusable.not(e).get()),this.hoverable=t(this.hoverable.not(e).get())},_delay:function(t,e){function i(){return("string"==typeof t?s[t]:t).apply(s,arguments)}var s=this;return setTimeout(i,e||0)},_hoverable:function(e){this.hoverable=this.hoverable.add(e),this._on(e,{mouseenter:function(e){this._addClass(t(e.currentTarget),null,"ui-state-hover")},mouseleave:function(e){this._removeClass(t(e.currentTarget),null,"ui-state-hover")}})},_focusable:function(e){this.focusable=this.focusable.add(e),this._on(e,{focusin:function(e){this._addClass(t(e.currentTarget),null,"ui-state-focus")},focusout:function(e){this._removeClass(t(e.currentTarget),null,"ui-state-focus")}})},_trigger:function(e,i,s){var n,o,a=this.options[e];if(s=s||{},i=t.Event(i),i.type=(e===this.widgetEventPrefix?e:this.widgetEventPrefix+e).toLowerCase(),i.target=this.element[0],o=i.originalEvent)for(n in o)n in i||(i[n]=o[n]);return this.element.trigger(i,s),!(t.isFunction(a)&&a.apply(this.element[0],[i].concat(s))===!1||i.isDefaultPrevented())}},t.each({show:"fadeIn",hide:"fadeOut"},function(e,i){t.Widget.prototype["_"+e]=function(s,n,o){"string"==typeof n&&(n={effect:n});var a,r=n?n===!0||"number"==typeof n?i:n.effect||i:e;n=n||{},"number"==typeof n&&(n={duration:n}),a=!t.isEmptyObject(n),n.complete=o,n.delay&&s.delay(n.delay),a&&t.effects&&t.effects.effect[r]?s[e](n):r!==e&&s[r]?s[r](n.duration,n.easing,o):s.queue(function(i){t(this)[e](),o&&o.call(s[0]),i()})}}),t.widget});
/*! jQuery UI - v1.12.1 - 2016-09-15
* http://jqueryui.com
* Copyright jQuery Foundation and other contributors; Licensed  */
!function(i){"function"==typeof define&&define.amd?define('jqueryui-amd/unique-id',["jquery","./version"],i):i(jQuery)}(function(i){return i.fn.extend({uniqueId:function(){var i=0;return function(){return this.each(function(){this.id||(this.id="ui-id-"+ ++i)})}}(),removeUniqueId:function(){return this.each(function(){/^ui-id-\d+$/.test(this.id)&&i(this).removeAttr("id")})}})});
/*! jQuery UI - v1.12.1 - 2016-09-15
* http://jqueryui.com
* Copyright jQuery Foundation and other contributors; Licensed  */
!function(E){"function"==typeof define&&define.amd?define('jqueryui-amd/keycode',["jquery","./version"],E):E(jQuery)}(function(E){return E.ui.keyCode={BACKSPACE:8,COMMA:188,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,LEFT:37,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SPACE:32,TAB:9,UP:38}});
/*! jQuery UI - v1.12.1 - 2016-09-15
* http://jqueryui.com
* Copyright jQuery Foundation and other contributors; Licensed  */
!function(e){"function"==typeof define&&define.amd?define('jqueryui-amd/focusable',["jquery","./version"],e):e(jQuery)}(function(e){function i(e){for(var i=e.css("visibility");"inherit"===i;)e=e.parent(),i=e.css("visibility");return"hidden"!==i}return e.ui.focusable=function(t,n){var a,r,s,o,u,f=t.nodeName.toLowerCase();return"area"===f?(a=t.parentNode,r=a.name,!(!t.href||!r||"map"!==a.nodeName.toLowerCase())&&(s=e("img[usemap='#"+r+"']"),s.length>0&&s.is(":visible"))):(/^(input|select|textarea|button|object)$/.test(f)?(o=!t.disabled,o&&(u=e(t).closest("fieldset")[0],u&&(o=!u.disabled))):o="a"===f?t.href||n:n,o&&e(t).is(":visible")&&i(e(t)))},e.extend(e.expr[":"],{focusable:function(i){return e.ui.focusable(i,null!=e.attr(i,"tabindex"))}}),e.ui.focusable});
/*! jQuery UI - v1.12.1 - 2016-09-15
* http://jqueryui.com
* Copyright jQuery Foundation and other contributors; Licensed  */
!function(e){"function"==typeof define&&define.amd?define('jqueryui-amd/tabbable',["jquery","./version","./focusable"],e):e(jQuery)}(function(e){return e.extend(e.expr[":"],{tabbable:function(n){var t=e.attr(n,"tabindex"),u=null!=t;return(!u||t>=0)&&e.ui.focusable(n,u)}})});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojdomutils',['ojs/ojcore-base', 'jquery', 'ojs/ojthemeutils'], function(oj, $, ThemeUtils)
{
  "use strict";
/* jslint browser: true*/



/* global ThemeUtils:false */

/**
 * DOM utilities.
 * @ignore
 */
var DomUtils = {}; // TODO Internal utility so we can remove once we replace oj.DomUtils
// usages w/ DomUtils as part of JET-35291

oj.DomUtils = DomUtils;
DomUtils._HTML_START_TAG = '\x3chtml\x3e';
DomUtils._HTML_END_TAG = '\x3c/html\x3e';
DomUtils._LEGAL_ELEMENTS = {
  SPAN: 1,
  B: 1,
  I: 1,
  EM: 1,
  BR: 1,
  HR: 1,
  LI: 1,
  OL: 1,
  UL: 1,
  P: 1,
  TT: 1,
  BIG: 1,
  SMALL: 1,
  PRE: 1
};
DomUtils._LEGAL_ATTRIBUTES = {
  class: 1,
  style: 1
};
/**
 * Returns true if the value is null or if the trimmed value is of zero length.
 *
 * @param {string|null} content
 * @return {boolean} true if the string is wrapped in <html> tag.
 */

DomUtils.isHTMLContent = function (content) {
  if (content.indexOf(DomUtils._HTML_START_TAG) === 0 && content.lastIndexOf(DomUtils._HTML_END_TAG) === content.length - 7) {
    return true;
  }

  return false;
};

DomUtils.cleanHtml = function (value) {
  var offSpan = $(document.createElement('span')).get(0);
  offSpan.innerHTML = value; // @HTMLUpdateOK safe manipulation

  if (value && value.indexOf('\x3c') >= 0) {
    DomUtils._cleanElementHtml(offSpan);
  }

  return offSpan;
};

DomUtils._cleanElementHtml = function (node) {
  var children = node.childNodes;

  for (var count = children.length - 1; count >= 0; count--) {
    var child = children.item(count);

    if (child && child.nodeType === 1) {
      if (DomUtils._LEGAL_ELEMENTS[child.nodeName]) {
        var attrs = child.attributes;

        for (var i = attrs.length - 1; i >= 0; i--) {
          var attr = attrs[i]; // jquery - the .attr() method returns undefined for attributes that have not been set.

          var childHasAttr = $(child).attr(attr.name) !== undefined;

          if (childHasAttr) {
            if (!DomUtils._LEGAL_ATTRIBUTES[attr.name]) {
              child.removeAttribute(attr.nodeName);
            }
          }
        }

        DomUtils._cleanElementHtml(child);
      } else if (child) {
        node.removeChild(child);
      }
    }
  }
};
/**
 * Checks to see if the "ancestorNode" is a ancestor of "node".
 *
 * @param {!Element} ancestorNode dom subtree to check to see if the target node exists
 * @param {!Element} node target node to check to see if it exists within a subtree rooted at the ancestorNode
 * @return {boolean} <code>true</code> if the "ancestorNode" is a ancestor of "node".
 */


DomUtils.isAncestor = function (ancestorNode, node) {
  // These can cause problems in IE11: sometimes the node is just an "empty" object
  // oj.Assert.assertDomElement(ancestorNode);
  // oj.Assert.assertDomElement(node);
  var parentNode = node.parentNode;

  while (parentNode) {
    if (parentNode === ancestorNode) {
      return true;
    }

    parentNode = parentNode.parentNode;
  }

  return false;
};
/**
 * Checks to see if the "ancestorNode" is a ancestor of "node" or if they are the same.
 *
 * @param {!Element} ancestorNode dom subtree to check to see if the target node exists
 * @param {!Element} node target node to check to see if it exists within a subtree rooted at the ancestorNode
 * @return {boolean} <code>true</code> if the "ancestorNode" is a ancestor of "node" or if they are the same
 */


DomUtils.isAncestorOrSelf = function (ancestorNode, node) {
  // These can cause problems in IE11: sometimes the node is just an "empty" object
  // oj.Assert.assertDomElement(ancestorNode);
  // oj.Assert.assertDomElement(node);
  return node === ancestorNode ? true : DomUtils.isAncestor(ancestorNode, node);
};
/**
 * Adds a resize listener for a block or inline-block element
 * @param {!Element} elem - node where the listener should be added
 * @param {!Function} listener - listener to be added. The listener will receive
 * two parameters: 1) the new width in pixels; 2) the new height in pixels
 * @param {number=} collapseEventTimeout - timeout in milliseconds for collapsing
 * multiple resize events into one
 * @export
 */


DomUtils.addResizeListener = function (elem, listener, collapseEventTimeout) {
  var jelem = $(elem);
  var tracker = jelem.data(DomUtils._RESIZE_TRACKER_KEY);

  if (tracker == null) {
    tracker = new DomUtils._ResizeTracker(elem);
    jelem.data(DomUtils._RESIZE_TRACKER_KEY, tracker);
    tracker.start();
  }

  tracker.addListener(listener, collapseEventTimeout);
};
/**
 * Removes a resize listener
 * @param {!Element} elem - node whose listener should be removed
 * @param {!Function} listener - listener to be removed
 * @export
 */


DomUtils.removeResizeListener = function (elem, listener) {
  var jelem = $(elem);
  var tracker = jelem.data(DomUtils._RESIZE_TRACKER_KEY);

  if (tracker != null) {
    tracker.removeListener(listener);

    if (tracker.isEmpty()) {
      tracker.stop();
      jelem.removeData(DomUtils._RESIZE_TRACKER_KEY);
    }
  }
};
/**
 * Fixes resize listeners after a subtree has been connected to the DOM or after
 * its display:none stayle has been removed
 * @param {!Element} subtreeRoot - subtree root
 */


DomUtils.fixResizeListeners = function (subtreeRoot) {
  $(subtreeRoot).find('.oj-helper-detect-expansion').parent().each(function (index, div) {
    var tracker = $(div).data(DomUtils._RESIZE_TRACKER_KEY);

    if (tracker != null) {
      tracker.init(true);
    }
  });
};
/**
 * Determines whether a special 'meta' key was pressed when the event was fired.
 * For Mac OS, the 'meta' key is mapped to the 'Command' key, for all other platforms it is mapped
 * to the 'Control' key.
 * Note that this method will only work for the events that support .ctrlKey and .metaKey fields.
 * @param {!Object} evt - the event
 * @return true if the meta key is pressed, false otherwise
 */


DomUtils.isMetaKeyPressed = function (evt) {
  var agentInfo = oj.AgentUtils.getAgentInfo();
  return oj.AgentUtils.OS.MAC === agentInfo.os ? evt.metaKey : evt.ctrlKey;
};
/**
 * Dispatches an event on the element
 * @param {!Element} element
 * @param {!Event} evt event object
 */


DomUtils.dispatchEvent = function (element, evt) {
  // Workaround for Mozilla issue #329509 - dispatchEvent() throws an error if
  // the element is disabled and disconnected
  // Also, IE simply ignores the .dispatchEvent() call for disabled elements
  var dis = 'disabled';
  var oldDisabled = element[dis];

  try {
    // eslint-disable-next-line no-param-reassign
    element[dis] = false;
    element.dispatchEvent(evt);
  } finally {
    // eslint-disable-next-line no-param-reassign
    element[dis] = oldDisabled;
  }
};
/**
 * @private
 */


DomUtils._invokeAfterPaint = (window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || function (fn) {
  return window.setTimeout(fn, 0); // @HTMLUpdateOK
}).bind(window);
/**
 * @private
 */


DomUtils._cancelInvokeAfterPaint = (window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || function (id) {
  return window.clearTimeout(id);
}).bind(window);
/**
 * Utility class for tracking resize events for a given element and  sispatching them
 * to listeners
 * @constructor
 * @ignore
 * @private
 */


DomUtils._ResizeTracker = function (div) {
  var _listeners = $.Callbacks();

  var _collapsingManagers = [];
  var _collapsingListeners = [];
  var _RETRY_MAX_COUNT = 2;
  var _retrySetScroll = 0;
  var _invokeId = null;
  var _oldWidth = null;
  var _oldHeight = null;
  var _detectExpansion = null;
  var _detectContraction = null;
  var _resizeListener = null;
  var _scrollListener = null;

  this.addListener = function (listener, collapseEventTimeout) {
    if (collapseEventTimeout === undefined || collapseEventTimeout === 0) {
      _listeners.add(listener);
    } else {
      _collapsingManagers.push(new DomUtils._collapsingListenerManager(listener, collapseEventTimeout));

      _collapsingListeners.push(listener);
    }
  };

  this.removeListener = function (listener) {
    var index = _collapsingListeners.indexOf(listener);

    if (index >= 0) {
      _collapsingListeners.splice(index, 1);

      var removed = _collapsingManagers.splice(index, 1);

      removed[0].stop();
    } else {
      _listeners.remove(listener);
    }
  };

  this.isEmpty = function () {
    return !_listeners.has() && _collapsingListeners.length === 0;
  };

  this.start = function () {
    _scrollListener = _handleScroll.bind(this); // : Use native onresize support on teh DIV in IE9/10 and  since no scroll events are fired on the
    // contraction/expansion DIVs in IE9

    if (div.attachEvent) {
      _resizeListener = _handleResize.bind(this);
      div.attachEvent('onresize', _resizeListener);
    } else {
      var firstChild = div.childNodes[0]; // This child DIV will track expansion events. It is meant to be 1px taller and wider than the DIV
      // whose resize events we are tracking. After we set its scrollTop and scrollLeft to 1, any increate in size
      // will fire a scroll event

      _detectExpansion = document.createElement('div');
      _detectExpansion.className = 'oj-helper-detect-expansion';
      var expansionChild = document.createElement('div');

      _detectExpansion.appendChild(expansionChild); // @HTMLUpdateOK expansionChild constructed by the code above


      if (firstChild != null) {
        div.insertBefore(_detectExpansion, firstChild); // @HTMLUpdateOK _detectExpansion constructed by the code above
      } else {
        div.appendChild(_detectExpansion); // @HTMLUpdateOK _detectExpansion constructed by the code above
      }

      _detectExpansion.addEventListener('scroll', _scrollListener, false); // This child DIV will track contraction events. Its height and width are set to 200%. After we set its scrollTop and
      // scrollLeft to the current height and width of its parent, any decrease in size will fire a scroll event


      _detectContraction = document.createElement('div');
      _detectContraction.className = 'oj-helper-detect-contraction';
      var contractionChild = document.createElement('div');
      contractionChild.style.width = '200%';
      contractionChild.style.height = '200%';

      _detectContraction.appendChild(contractionChild); // @HTMLUpdateOK contractionChild constructed by the code above


      div.insertBefore(_detectContraction, _detectExpansion); // @HTMLUpdateOK _detectContraction constructed by the code above

      _detectContraction.addEventListener('scroll', _scrollListener, false);

      this.init(false);
    }
  };

  this.stop = function () {
    if (_invokeId != null) {
      DomUtils._cancelInvokeAfterPaint(_invokeId);

      _invokeId = null;
    }

    if (_detectExpansion != null) {
      _detectExpansion.removeEventListener('scroll', _scrollListener);

      _detectContraction.removeEventListener('scroll', _scrollListener); // Check before removing to prevent CustomElement polyfill from throwing
      // a NotFoundError when removeChild is called with an element not in the DOM


      if (_detectExpansion.parentNode) {
        div.removeChild(_detectExpansion);
      }

      if (_detectContraction.parentNode) {
        div.removeChild(_detectContraction);
      }
    } else {
      // assume IE9/10
      div.detachEvent('onresize', _resizeListener);
    }
  };

  this.init = function (isFixup) {
    var adjusted = _checkSize(isFixup);

    if (isFixup && !adjusted && _detectExpansion.offsetParent != null) {
      _adjust(_oldWidth, _oldHeight);
    }
  };

  function _checkSize(fireEvent) {
    var adjusted = false;

    if (_detectExpansion.offsetParent != null) {
      var newWidth = _detectExpansion.offsetWidth;
      var newHeight = _detectExpansion.offsetHeight;

      if (_oldWidth !== newWidth || _oldHeight !== newHeight) {
        _retrySetScroll = _RETRY_MAX_COUNT;

        _adjust(newWidth, newHeight);

        adjusted = true;

        if (fireEvent) {
          _notifyListeners(true);
        }
      }
    }

    return adjusted;
  }

  function _notifyListeners(useAfterPaint) {
    var newWidth = div.offsetWidth;
    var newHeight = div.offsetHeight;

    if (_listeners.has()) {
      if (!useAfterPaint) {
        _listeners.fire(newWidth, newHeight);
      } else {
        if (_invokeId !== null) {
          DomUtils._cancelInvokeAfterPaint(_invokeId);
        }

        _invokeId = DomUtils._invokeAfterPaint(function () {
          _invokeId = null;

          _listeners.fire(newWidth, newHeight);
        });
      }
    }

    for (var i = 0; i < _collapsingManagers.length; i++) {
      _collapsingManagers[i].getCallback()(newWidth, newHeight);
    }
  }

  function _handleScroll(evt) {
    evt.stopPropagation();

    if (!_checkSize(true)) {
      // Workaround for the WebKit issue where scrollLeft gets reset to 0 without the DIV being expanded
      // We will retry to the set the scrollTop only twice to avoid infinite loops
      if (_retrySetScroll > 0 && _detectExpansion.offsetParent != null && (_detectExpansion.scrollLeft === 0 || _detectExpansion.scrollTop === 0)) {
        _retrySetScroll -= 1;

        _adjust(_oldWidth, _oldHeight);
      }
    }
  }

  function _handleResize() {
    _notifyListeners(false);
  }

  function _adjust(width, height) {
    _oldWidth = width;
    _oldHeight = height;
    var expansionChildStyle = _detectExpansion.firstChild.style;
    var delta = 1; // The following loop is a workaround for the WebKit issue with zoom < 100% -
    // the scrollTop/Left gets reset to 0 because it gets computed to a value less than 1px.
    // We will try up to the delta of 5 to support scaling down to 20% of the original size

    do {
      expansionChildStyle.width = width + delta + 'px';
      expansionChildStyle.height = height + delta + 'px';
      _detectExpansion.scrollLeft = delta;
      _detectExpansion.scrollTop = delta;
      delta += 1;
    } while ((_detectExpansion.scrollTop === 0 || _detectExpansion.scrollLeft === 0) && delta <= 5);

    _detectContraction.scrollLeft = width;
    _detectContraction.scrollTop = height;
  }
};

DomUtils._RESIZE_TRACKER_KEY = '_ojResizeTracker';
/**
 * Returns true if the name is a valid identifier
 *
 * @param {string} name
 * @return {boolean} true if the name is a valid identifier
 */

DomUtils.isValidIdentifier = function (name) {
  return /^[A-Za-z][0-9A-Z_a-z-]*$/.test(name);
};
/**
 * @constructor
 * @ignore
 */


DomUtils._collapsingListenerManager = function (originalCallback, timeout) {
  var _lastArgs = null;
  var _timerId = null;

  var _timerCallback = function _timerCallback() {
    originalCallback.apply(null, _lastArgs);
    _timerId = null;
  };

  var _callback = function _callback() {
    _lastArgs = Array.prototype.slice.call(arguments);

    if (_timerId == null) {
      _timerId = window.setTimeout(_timerCallback, timeout);
    }
  };

  this.getCallback = function () {
    return _callback;
  };

  this.stop = function () {
    if (_timerId != null) {
      window.clearTimeout(_timerId);
      _timerId = null;
    }
  };
};
/**
 * @return {boolean} true if touch is supported
 */


DomUtils.isTouchSupported = function () {
  return 'ontouchstart' in window || // C, FF, Safari, Edge
  navigator.msMaxTouchPoints > 0 // IE10
  || navigator.maxTouchPoints > 0; // IE11
};
/**
 * @ignore
 */


DomUtils.setInKoCleanExternal = function (node) {
  DomUtils._koCleanNode = node;
};
/**
 * Delegates to JQuery's unwrap() if the component's node is not currently
 * being removed by Knockout
 * @param {Object} locator
 * @param {Object=} replaceLocator - locator to be replaced. I fthis parameter is ommitted,
 * the parent node will be replaced
 * @ignore
 */


DomUtils.unwrap = function (locator, replaceLocator) {
  var koCleanNode = DomUtils._koCleanNode;

  if (koCleanNode) {
    if (locator.get(0) === koCleanNode) {
      // skip unwrap
      return;
    }
  }

  if (replaceLocator) {
    replaceLocator.replaceWith(locator); // @HTMLUpdateOK
  } else {
    locator.unwrap();
  }
};
/**
 * Determines if the mouse event target is on browser chrome - i.e. "scrollbar".
 * If the event is not a mouse event with a clientX and clientY, the resultant will
 * be false.
 *
 * @param {Event} event native dom event
 * @returns {boolean} <code>true</code> if the target of the mouse event is browser
 *          chrome such as scrollbars.
 * @public
 */


DomUtils.isChromeEvent = function (event) {
  /**
   * @param {Event} event
   * @return {boolean}
   */
  function _isChromeEventGecko(_event) {
    // assume that if we can't access the original target of the event, then it's because
    // the target was implemented in XUL and is part of the chrome;
    try {
      return !_event.originalTarget.localName;
    } catch (e) {
      return true;
    }
  }
  /**
   * @param {Event} event
   * @return {boolean}
   */


  function _isChromeEventIE(_event) {
    /*
      //IE has a specific API for this but doesn't seem to want to work in automation.
      //The webkit method works in IE too.  Using that over componentFromPoint but leaving
      //the code for future reference.
      //
      var target = event.target;
      var chromePart = target.componentFromPoint(event.clientX, event.clientY);
      if (oj.StringUtils.isEmpty(chromePart))
        return false;
      else
        return true;
    */
    return _isChromeEventWebkit(_event);
  }
  /**
   * @param {Event} event
   * @return {boolean}
   */


  function _isChromeEventWebkit(_event) {
    var domTarget = _event.target;
    var target = $(domTarget);
    var pos = domTarget.getBoundingClientRect();
    var sbw = DomUtils.getScrollBarWidth();
    var isLTR = DomUtils.getReadingDirection() === 'ltr';

    if (isLTR && (domTarget.nodeName === 'HTML' || target.css('overflow-x') !== 'visible') && _event.clientX > pos.right - sbw) {
      return true;
    } else if (!isLTR && domTarget.nodeName === 'HTML' && _event.clientX > pos.left - sbw) {
      // ltr scrollbar is always on the right
      return true;
    } else if (!isLTR && target.css('overflow-x') !== 'visible' && _event.clientX < pos.left + sbw) {
      // RTL scrollbar on the document is still on the right
      return true;
    } else if ((domTarget.nodeName === 'HTML' || target.css('overflow-y') !== 'visible') && _event.clientY > pos.bottom - sbw) {
      // RTL scrollbar not on the document is on the left
      return true;
    } // below the scrollbar


    return false;
  } // verify event is a mouse event


  if (!('clientX' in event) || !('clientY' in event)) {
    return false;
  }

  var agentInfo = oj.AgentUtils.getAgentInfo();

  if (oj.AgentUtils.OS.ANDROID === agentInfo.os || oj.AgentUtils.OS.IOS === agentInfo.os) {
    return false;
  }

  if (oj.AgentUtils.ENGINE.GECKO === agentInfo.engine) {
    return _isChromeEventGecko(event);
  } else if (oj.AgentUtils.ENGINE.WEBKIT === agentInfo.engine || oj.AgentUtils.ENGINE.BLINK === agentInfo.engine) {
    return _isChromeEventWebkit(event);
  }

  if (oj.AgentUtils.BROWSER.IE === agentInfo.browser) {
    return _isChromeEventIE(event);
  }

  return false;
};
/**
 * @returns {number} width of the browser scrollbar
 */


DomUtils.getScrollBarWidth = function () {
  var scrollBarWidth = DomUtils._scrollBarWidth;

  if ($.isNumeric(scrollBarWidth)) {
    return scrollBarWidth;
  }
  /** @type {jQuery} **/


  var scrollBarMeasure = $('<div></div>');
  $(document.body).append(scrollBarMeasure); // @HTMLUpdateOK scrollBarMeasure constructed by the code above

  scrollBarMeasure.width(50).height(50).css({
    overflow: 'scroll',
    visibility: 'hidden',
    position: 'absolute'
  });
  /** @type {jQuery} **/

  var scrollBarMeasureContent = $('<div></div>');
  scrollBarMeasureContent.height(1);
  scrollBarMeasure.append(scrollBarMeasureContent); // @HTMLUpdateOK scrollBarMeasureContent constructed by the code above

  var insideWidth = scrollBarMeasureContent.width();
  var outsideWitdh = scrollBarMeasure.width();
  scrollBarMeasure.remove();
  scrollBarWidth = outsideWitdh - insideWidth;
  DomUtils._scrollBarWidth = scrollBarWidth;
  return scrollBarWidth;
};
/**
 * @returns {string!} "rtl" or "ltr"
 */


DomUtils.getReadingDirection = function () {
  var dir = document.documentElement.getAttribute('dir');

  if (dir) {
    dir = dir.toLowerCase();
  }

  return dir === 'rtl' ? 'rtl' : 'ltr';
};
/**
 * Retrieve the bidi independent position of the horizontal scroll position that
 * is consistent across all browsers.
 * @param {Element} elem the element to retrieve the scrollLeft from
 * @return {number} the element's scrollLeft
 */


DomUtils.getScrollLeft = function (elem) {
  if (DomUtils.getReadingDirection() === 'rtl') {
    var browser = oj.AgentUtils.getAgentInfo().browser;

    if (browser === oj.AgentUtils.BROWSER.FIREFOX || browser === oj.AgentUtils.BROWSER.IE || browser === oj.AgentUtils.BROWSER.EDGE) {
      return Math.abs(elem.scrollLeft);
    } // webkit


    return Math.max(0, elem.scrollWidth - elem.clientWidth - elem.scrollLeft);
  }

  return elem.scrollLeft;
};
/**
 * Sets the bidi independent position of the horizontal scroll position that
 * is consistent across all browsers.
 * @param {Element} elem the element to set the scrollLeft on
 * @param {number} scrollLeft the element's new scrollLeft
 */


DomUtils.setScrollLeft = function (elem, scrollLeft) {
  if (DomUtils.getReadingDirection() === 'rtl') {
    var browser = oj.AgentUtils.getAgentInfo().browser;

    if (browser === oj.AgentUtils.BROWSER.FIREFOX) {
      // see mozilla , even though it's marked as fixed, they basically
      // did not change anything.  It still expects a negative value for RTL
      // eslint-disable-next-line no-param-reassign
      elem.scrollLeft = -scrollLeft;
    } else if (browser === oj.AgentUtils.BROWSER.IE || browser === oj.AgentUtils.BROWSER.EDGE) {
      // eslint-disable-next-line no-param-reassign
      elem.scrollLeft = scrollLeft;
    } else {
      // webkit
      // eslint-disable-next-line no-param-reassign
      elem.scrollLeft = Math.max(0, elem.scrollWidth - elem.clientWidth - scrollLeft);
    }
  } else {
    // eslint-disable-next-line no-param-reassign
    elem.scrollLeft = scrollLeft;
  }
};
/**
 * Converts a CSS length attribute into a integer value.
 * Conversion errors or non-number will result in a zero
 * resultant.
 *
 * @param {?} cssLength style attribute
 * @return {number} value as integer
 */


DomUtils.getCSSLengthAsInt = function (cssLength) {
  if (!isNaN(cssLength)) {
    return parseInt(cssLength, 10);
  }

  if (cssLength && cssLength.length > 0 && cssLength !== 'auto') {
    var intLength = parseInt(cssLength, 10);

    if (isNaN(intLength)) {
      intLength = 0;
    }

    return intLength;
  }

  return 0;
};
/**
 * Converts a CSS attribute into a float value.
 * Conversion errors or non-number will result in a zero
 * resultant.
 *
 * @param {?} cssLength style attribute
 * @return {number} value as integer
 */


DomUtils.getCSSLengthAsFloat = function (cssLength) {
  if (!isNaN(cssLength)) {
    return parseFloat(cssLength);
  }

  if (cssLength && cssLength.length > 0) {
    var floatLength = parseFloat(cssLength);

    if (isNaN(floatLength)) {
      floatLength = 0;
    }

    return floatLength;
  }

  return 0;
};
/**
 * Key used to store the logical parent of the popup element
 * as a jQuery data property. The logical parent refers the launcher of a popup.
 * @const
 * @private
 * @type {string}
 */


DomUtils._LOGICAL_PARENT_DATA = 'oj-logical-parent';
/**
 * This method returns the launcher of a popup when it's open.
 * Returns undefined otherwise.
 *
 * @param {jQuery} element jquery element
 * @returns {any}
 * @see #setLogicalParent
 */

DomUtils.getLogicalParent = function (element) {
  if (element) {
    return element.data(DomUtils._LOGICAL_PARENT_DATA);
  }

  return undefined;
};
/**
 * Set the logical parent as a jQuery data property
 *
 * @param {jQuery} element jquery element
 * @param {jQuery | null} parent jquery element
 * @see #getLogicalParent
 */


DomUtils.setLogicalParent = function (element, parent) {
  if (!element) {
    return;
  }

  if (parent === null) {
    element.removeData(DomUtils._LOGICAL_PARENT_DATA);
  } else {
    element.data(DomUtils._LOGICAL_PARENT_DATA, parent);
  }
};
/**
 * Checks to see if the "ancestorNode" is a logical ancestor of "node"
 *
 * @param {!Element} ancestorNode dom subtree to check to see if the target node exists
 * @param {!Element} node target node to check to see if it exists within a subtree rooted at the ancestorNode
 * @return {boolean} <code>true</code> if the "ancestorNode" is a logical ancestor of "node" or if they are the same
 */


DomUtils.isLogicalAncestorOrSelf = function (ancestorNode, node) {
  oj.Assert.assertDomElement(ancestorNode);
  oj.Assert.assertDomElement(node);
  var parentNode = node;

  while (parentNode) {
    if (parentNode === ancestorNode) {
      return true;
    }

    var logicalParent = DomUtils.getLogicalParent($(parentNode));

    if (logicalParent) {
      parentNode = logicalParent[0];
    } else {
      parentNode = parentNode.parentNode;
    }
  }

  return false;
};
/**
 * Checks whether the href represents a safe URL
 * @param {!string} href - HREF to test
 * @param {Array=} whitelist - optional list of the allowed protocols. Protocol name has to use lowercase letters and
 * be followed by a ':'. If the parameter is ommitted, ['http:', 'https:'] will be used
 * @throws {Exception} an error if the HREF represents an invalid URL
 * @ignore
 */


DomUtils.validateURL = function (href, whitelist) {
  var allowed = whitelist || ['http:', 'https:'];
  var link = document.createElement('a');
  link.href = href;
  var protocol = link.protocol;

  if (protocol != null) {
    protocol = protocol.toLowerCase();
  } // if it isn't on the allowed list and it isn't '', throw an error.
  // IE11 returns '' for hrefs like 'abc', other browsers return 'https'
  // and we want to allow hrefs like 'abc' since those are relative urls.


  if (allowed.indexOf(protocol) < 0 && protocol !== '') {
    throw new Error(protocol + ' is not a valid URL protocol');
  }
};
/**
 * Cancels native context menu events for hybrid mobile applications.
 * @private
 */


DomUtils._supressNativeContextMenu = function () {
  if ($(document.body).hasClass('oj-hybrid')) {
    document.body.addEventListener('contextmenu', function (event) {
      if (event.target.nodeName !== 'INPUT') {
        event.preventDefault();
      }
    }, true);
  }
};

DomUtils._supressNativeContextMenu(); // standard duration of a pressHold gesture.  Point of reference: default
// JQ Mobile threshold to be a press-and-hold is 750ms.


DomUtils.PRESS_HOLD_THRESHOLD = 750; // ------------------------------------------------------------------------------------------------
// Recent touch end
// ------------------------------------------------------------------------------------------------

/**
 * Returns true if a touchend or touchcancel has been detected anywhere in the document in the last 500 ms.
 * Note: This function adds event listeners only once per document load.
 *
 * @return {boolean} boolean indicating whether a touch has recently been detected
 */

DomUtils.recentTouchEnd = function () {
  // This function is immediately executed and returns the recentTouchEnd function
  // and therefore only execute once per document load.
  var touchTimestamp = 0;
  var TOUCH_THRESHOLD = 500;

  function _touchEndHandler() {
    touchTimestamp = Date.now();
  } // --- Document listeners ---


  document.addEventListener('touchend', _touchEndHandler, true);
  document.addEventListener('touchcancel', _touchEndHandler, true); // --- The function assigned to DomUtils.recentTouchEnd ---

  return function () {
    // must be at least 300 for the "300ms" delay
    return Date.now() - touchTimestamp < TOUCH_THRESHOLD;
  };
}();
/**
 * Returns true if a touchstart has been detected anywhere in the document in the last 800 ms.
 * Note: This function adds event listeners only once per document load.
 *
 * @return {boolean} boolean indicating whether a touch has recently been detected
 */


DomUtils.recentTouchStart = function () {
  // This function is immediately executed and returns the recentTouchStart function
  // and therefore only execute once per document load.
  var touchTimestamp = 0; // 800 because this is used to ignore mouseenter and focusin on 'press', and a 'press'
  // is usually detected after 750ms.

  var TOUCH_THRESHOLD = DomUtils.PRESS_HOLD_THRESHOLD + 50;

  function _touchStartHandler() {
    touchTimestamp = Date.now();
  } // --- Document listeners ---


  document.addEventListener('touchstart', _touchStartHandler, {
    passive: true,
    capture: true
  }); // --- The function assigned to DomUtils.recentTouchStart ---

  return function () {
    // must be at least TOUCH_THRESHOLD for the  delay
    return Date.now() - touchTimestamp < TOUCH_THRESHOLD;
  };
}(); // ------------------------------------------------------------------------------------------------
// Recent pointer
// ------------------------------------------------------------------------------------------------

/**
 * Returns true if a touchstart, touchend, mousedown, or mouseup has been detected anywhere in the
 * document in the last n ms, where n is calibrated across a variety of platforms to make this API
 * a maximally reliable indicator of whether the code now running was likely "caused by" the
 * specified touch and mouse interaction, vs. some other thing (e.g. mousemove, keyboard, or page
 * load).  E.g. the makeFocusable() / _focusable() mechanism uses this API to vary the focus theming
 * depending on whether the element was focused via keyboard or pointer.
 *
 * @return {boolean} boolean indicating whether a mouse button or finger has recently been down or up
 */


DomUtils.recentPointer = function () {
  // The comments in this function are tailored to the makeFocusable() usage.
  // - Let "pointer down" mean mousedown or touchstart, and "pointer up" likewise.  (Not MS pointer events.)
  // - Event order can be 1) mousedown>focus>mouseup (like push buttons) or 2) mousedown>mouseup>focus (like toggle buttons).
  // - For 2, semantics for "focus caused by pointer" must be "if pointer interaction in last n ms," rather than "if pointer is currently down".
  // - Those "last n ms" semantics are preferred for 1 as well, rather than relying on pointer up to cancel a state set by pointer down,
  //   since if the pointer up is never received, we'd get stuck in an inaccessible state.
  // - So both pointer down and pointer up set a timestamp, and recentPointer() returns true if Date.now() is within n ms of that timestamp,
  //   where n is higher for touchstart per below.
  // Timestamp of last mousedown/up or touchstart/end. Initial value of 0 (1/1/1970) guarantees that if element is focused before any
  // mouse/touch interaction, then recentPointer() is false, so focus ring appears as desired.
  var pointerTimestamp = 0;
  var pointerTimestampIsTouchStart; // whether the latest timestamp is for touchstart vs. touchend/mouse
  // On Edge (Surface Win10), the lag from the up event to resulting programmatic focus is routinely ~350ms, even when the 300ms "tap delay" has
  // been prevented and confirmed to be absent.  (In Chrome on same device the same lag is ~10 ms.)  So use 600ms to be safe.  Even on Chrome,
  // the lag from the down/up event to natively induced focus can routinely be well into the 1xx ms range. Can exceed 600 if needed. There is no
  // need for a tight bound; if there was pointer interaction in the last second or so, it's perfectly reasonable to suppress the focus ring.

  var POINTER_THRESHOLD_CUSHION = 600; // If the number of millis since the last pointer down or up is < this threshold, then recentPointer() considers it recent and returns true.
  // See also TOUCHSTART_THRESHOLD.

  var POINTER_THRESHOLD = POINTER_THRESHOLD_CUSHION; // For touchstart only, use 750+600ms so that focus set by a 750ms pressHold gesture (e.g. context menu) is recognized as touch-related.  Same
  // 600ms padding as for POINTER_THRESHOLD.  A high threshold is OK, as it is used only for actual pressHolds (and the unusual case where the
  // pointer up is never received), since for normal clicks and taps, the pointerUp replaces the "1350ms after touchstart" policy with a "600ms
  // after pointerUp" policy. On Edge and desktop FF (desktop version runs on hybrid devices like Surface), which lack touchstart, context menus
  // are launched by the contextmenu event, which happen after the pointer up in both browsers, so the fact that we're using the higher
  // threshold only for touchstart should not be a problem there.

  var TOUCHSTART_THRESHOLD = DomUtils.PRESS_HOLD_THRESHOLD + POINTER_THRESHOLD_CUSHION; // --- Document listeners ---
  // Use capture phase to make sure we hear the events before someone cancels them

  document.addEventListener('mousedown', function () {
    // If the mousedown immediately follows a touchstart, i.e. if it seems to be the compatibility mousedown
    // corresponding to the touchstart, then we want to consider it a "recent pointer activity" until the end time
    // that is max(touchstartTime + TOUCHSTART_THRESHOLD, now + POINTER_THRESHOLD), where now is mousedownTime in this
    // case.  (I.e. it would defeat the purpose if the inevitable mousedown replaced the longer touchstart threshold with
    // a shorter one.)  We don't do this in the touchend/mouseup listeners, as those obviously happen after the pressHold
    // is over, in which case the following analysis applies:
    // - If the pressHold was < PRESS_HOLD_THRESHOLD ms,
    // - then the higher TOUCHSTART_THRESHOLD is not needed or relevant, since anything focused on pressHold
    //   (like a context menu) never happened,
    // - else the touchend/mouseup happened > PRESS_HOLD_THRESHOLD ms after the touchstart, so in the max() above,
    //   the 2nd quantity is always bigger (later).
    var now = Date.now();

    if (!pointerTimestampIsTouchStart || now > pointerTimestamp + DomUtils.PRESS_HOLD_THRESHOLD) {
      pointerTimestamp = now;
      pointerTimestampIsTouchStart = false;
    }
  }, true);
  document.addEventListener('touchstart', function () {
    pointerTimestamp = Date.now();
    pointerTimestampIsTouchStart = true;
  }, {
    passive: true,
    capture: true
  });
  document.addEventListener('mouseup', function () {
    pointerTimestamp = Date.now();
    pointerTimestampIsTouchStart = false;
  }, true);
  document.addEventListener('touchend', function () {
    pointerTimestamp = Date.now();
    pointerTimestampIsTouchStart = false;
  }, true); // --- The function assigned to DomUtils.recentPointer ---

  return function () {
    var millisSincePointer = Date.now() - pointerTimestamp;
    var threshold = pointerTimestampIsTouchStart ? TOUCHSTART_THRESHOLD : POINTER_THRESHOLD;
    var isRecent = millisSincePointer < threshold;
    return isRecent;
  };
}(); // ------------------------------------------------------------------------------------------------
// Utility for suppressing focus ring for mouse/touch interaction, but not KB or other interaction:
// ------------------------------------------------------------------------------------------------

/**
 * This API works like baseComponent's _focusable() API (see its detailed JSDoc), with the
 * similarities and differences listed below.  This API is intended for non-component callers;
 * components should typically call the baseComponent API via this._focusable().
 *
 * Comparison to baseComponent._focusable() :
 *
 * - This function's "options" param must be an object.  Only baseComponent._focusable()
 *   supports the backward-compatibility syntax where the options param can be the element.
 * - Same usage of oj-focus, oj-focus-highlight, and $focusHighlightPolicy.
 * - Same required invariant that oj-focus-highlight must not be set if oj-focus is not set.
 * - Same parameters with same semantics, plus the additional "component" and "remove" params
 *   discussed below.
 * - New options.component param, which takes a JET component instance.  (When a component is
 *   involved, typically that component should call this._focusable() rather than calling this
 *   version of the method directly.)
 *
 * If options.component is specified, then the following things work like the baseComponent
 * version of this API:
 *
 * - If the specified element is in the component subtree,
 *   then the classes will automatically be removed when the component is
 *   destroyed/disabled/detached, as detailed in the baseComponent JSDoc,
 *   else the caller has the same responsibility to remove the classes at those times.
 * - Same rules as to whether listeners are automatically cleaned up, or suppressed when the
 *   component is disabled, vs. being the caller's responsibility to handle those things.
 *
 * If options.component is NOT specified (for non-component callers), then those things are
 * the caller's responsibility.  Specifically:
 *
 * - Class removal can be done directly, as needed.
 * - To remove the listeners, see the following.
 *
 * Listener removal:
 *
 * - If options.component was specified, see above.
 * - Else if options.setupHandlers was specified, then only the caller knows what listeners were
 *   registered and how, so it is the caller's responsibility to remove them directly when needed.
 * - The remaining case is that options.component and options.setupHandlers were not specified.
 *   To remove from element e both the 2 classes and all listeners applied to e by all previous
 *   invocations of makeFocusable() where these options were not specified,
 *   call makeFocusable( {'element': e, 'remove': true} ).
 */
// If this is named focusable(), Closure Compiler generates a warning, and fails to rename the function in minified code,
// which suggests that focusable (not just _focusable) is apparently externed somewhere (although not in
// 3rdparty\jquery\externs\jquery-1.8.js, main\javascript\externs.js, or build\tools\closure\compiler.jar\externs.zip\),
// perhaps for JQUI's :focusable selector.  So name it makeFocusable().


DomUtils.makeFocusable = function () {
  var nextId = 0; // used for unique namespace, for "remove" functionality
  // This private var is shared by all callers that use makeFocusable() and don't supply their own focus highlight policy.
  // If the oj-focus-config SASS object ever acquires a 2nd field, should continue to call pJFFF() only once, statically.

  var FOCUS_HIGHLIGHT_POLICY = (ThemeUtils.parseJSONFromFontFamily('oj-focus-config') || {}).focusHighlightPolicy;
  /**
   * @param {function()} focusPolicyCallback Optional getter passed to makeFocusable() by callers wishing to get use a caller-
   *   specific focus policy mechanism instead of the built-in mechanism.
   * @param {function()} recentPointerCallback Optional function passed to makeFocusable() by callers wishing to use a caller-
   *   specific mechanism in addition to the built-in mechanism.
   * @return {boolean} boolean indicating whether it is appropriate to apply the <code class="prettyprint">oj-focus-highlight</code>
   *   CSS class for a focus happening at the time of this method call.
   */

  var shouldApplyFocusHighlight = function shouldApplyFocusHighlight(focusPolicyCallback, recentPointerCallback) {
    var focusHighlightPolicy = focusPolicyCallback ? focusPolicyCallback() : FOCUS_HIGHLIGHT_POLICY;

    switch (focusHighlightPolicy) {
      case 'all':
        return true;

      case 'none':
        return false;

      default:
        // "nonPointer" or no value provided (e.g. SASS var missing)
        return !(DomUtils.recentPointer() || recentPointerCallback && recentPointerCallback());
    }
  }; // the function assigned to DomUtils.makeFocusable


  var makeFocusable = function makeFocusable(options) {
    var element = options.element;
    var dataKey = 'ojFocusable';
    var namespacePrefix = '.' + dataKey;
    var namespaceSeparator = ' ' + namespacePrefix;

    if (options.remove) {
      element.removeClass('oj-focus oj-focus-highlight'); // id's of listeners needing removal

      var ids = element.data(dataKey);

      if (ids == null) {
        return;
      } // map ids to namespaces.  "2" -> ".ojFocusable2".  "2,7" -> ".ojFocusable2 .ojFocusable7"


      var namespaces = namespacePrefix + ('' + ids).split(',').join(namespaceSeparator);
      element.off(namespaces) // remove the listeners
      .removeData(dataKey); // clear list of listener id's needing removal

      return;
    }

    var afterToggle = options.afterToggle || $.noop;

    function applyOnlyFocus(_element) {
      _element.addClass('oj-focus');

      afterToggle('focusin');
    }

    function applyBothClasses(_element) {
      _element.addClass('oj-focus');

      if (shouldApplyFocusHighlight(options.getFocusHighlightPolicy, options.recentPointer)) {
        _element.addClass('oj-focus-highlight');
      }

      afterToggle('focusin');
    }

    var addClasses = options.applyHighlight ? applyBothClasses : applyOnlyFocus;

    function removeClasses(_element) {
      _element.removeClass('oj-focus oj-focus-highlight');

      afterToggle('focusout');
    }

    var hasFocus = false;

    var setupHandlers = options.setupHandlers || function (focusInHandler, focusOutHandler) {
      var component = options.component;

      var focusInListener = function focusInListener(event) {
        focusInHandler($(event.currentTarget));
        hasFocus = true;
      };

      var focusOutListener = function focusOutListener(event) {
        // We should only do this once, even though this event may fire multiple times.
        if (hasFocus) {
          focusOutHandler($(event.currentTarget));
          hasFocus = false;
        }
      };

      if (component) {
        component._on(element, {
          focusin: focusInListener,
          focusout: focusOutListener
        });
      } else {
        // neither options.component nor options.setupHandlers were passed, so we must provide a
        // way for the caller to remove the listeners.  That's done via the "remove" param, which
        // uses the namespaces that we stash via data().
        var id = nextId;
        nextId += 1; // list of id's of existing listeners needing removal

        var _ids = element.data(dataKey); // append id to that list, or start new list if first one


        element.data(dataKey, _ids == null ? id : _ids + ',' + id); // add listeners namespaced by that id

        var handlers = {};
        var namespace = namespacePrefix + id;
        handlers['focusin' + namespace] = focusInListener;
        handlers['focusout' + namespace] = focusOutListener;
        element.on(handlers);
      }
    };

    setupHandlers(addClasses, removeClasses);
  };

  return makeFocusable;
}();

;return DomUtils;
});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojfocusutils',['ojs/ojcore-base', 'jquery', 'ojs/ojdomutils'], function(oj, $, DomUtils)
{
  "use strict";
/* jslint browser: true*/



/* global DomUtils:false */

/**
 * Focus utilities.
 * @ignore
 */
var FocusUtils = {}; // TODO Internal utility so we can remove once we replace oj.FocusUtils
// usages w/ FocusUtils as part of JET-35291

oj.FocusUtils = FocusUtils;
FocusUtils._TABBABLE = ':tabbable,iframe'; // These functions inspired by AdfFocusUtils

/**
 * Tests whether the specified element contains the keyboard focus.
 * @param {!Element} element Element for which to check if it contains focus.
 * @returns {boolean} True if the element contains focus, false otherwise.
 */

FocusUtils.containsFocus = function (element) {
  var activeElem = document.activeElement; // FIX : if either elem is undefined, just return false

  if (!element || !activeElem) {
    return false;
  }

  return DomUtils.isAncestorOrSelf(element, activeElem);
};
/**
 * Sets focus to the specified element.
 * @param {!Element} element Element to focus.
 */


FocusUtils.focusElement = function (element) {
  element.focus();
};
/**
 * Sets focus to the first tabbable element inside the given element, which
 * may be the given element itself.
 * @param {!Element} element Element to start searching for a tabbable element in.
 * @returns {Element} The DOM element that was focused, if any.
 */


FocusUtils.focusFirstTabStop = function (element) {
  var focusElement = FocusUtils.getFirstTabStop(element);

  if (focusElement) {
    FocusUtils.focusElement(focusElement);
  }

  return focusElement;
};
/**
 * Return true if the activeElement is the first tabbable. Used to ensure that tabbing cycles through dialogs/popups.
 * @param {!Element} element Element containing tabbable elements.
 * @returns {boolean} <code>true</code> if the active element is the first tabbable.
 */


FocusUtils.isFirstActiveElement = function (element) {
  var jqElem = $(element);
  var jqFocusables = jqElem.find(FocusUtils._TABBABLE);
  if (jqFocusables == null || jqFocusables.length === 0) return false;
  var first = jqFocusables[0];
  if (document.activeElement === first) return true; //
  // Return true if the activeElement is in the "first tabble set".
  // Check to see if the first tabbable and the active element are members
  // of the same radio set.
  // If this is the case, then return true.
  //

  if (first.name === document.activeElement.name && first.type === 'radio' && document.activeElement.type === 'radio') {
    return true;
  }

  return false;
};
/**
 * Return true if the activeElement is the last tabbable. Used to ensure that tabbing cycles through dialogs/popups.
 * @param {!Element} element Element containing tabbable elements.
 * @returns {boolean} <code>true</code> if the active element is the last tabbable.
 */


FocusUtils.isLastActiveElement = function (element) {
  var jqElem = $(element);
  var jqFocusables = jqElem.find(FocusUtils._TABBABLE);
  if (jqFocusables == null || jqFocusables.length === 0) return false;
  var last = jqFocusables[jqFocusables.length - 1];
  if (document.activeElement === last) return true; //
  // Return true if the activeElement is in the "first tabble set".
  // Check to see if the last tabbable and the active element are members
  // of the same radio set.
  // If this is the case, then return true.
  //

  if (last.name === document.activeElement.name && last.type === 'radio' && document.activeElement.type === 'radio') {
    return true;
  }

  return false;
};
/**
 * Get the first tabbable element inside the given element, which may be the
 * given element itself.
 * @param {!Element} element Element to start searching for a tabbable element in.
 * @returns {Element} The first tabbable element inside the given element.
 */


FocusUtils.getFirstTabStop = function (element) {
  var jqElem = $(element);

  if (jqElem.is(FocusUtils._TABBABLE)) {
    return element;
  }

  var jqFocusables = jqElem.find(FocusUtils._TABBABLE);

  if (jqFocusables && jqFocusables.length > 0) {
    //
    // Handle set-based content (radiosets).
    // Return the first selected radioset item.
    // Note that there are two cases
    //   Common case - a single radioset
    //   Other case - multiple radiosets
    // In both cases we return the first selected radioset item.
    //
    if (jqFocusables[0].classList.contains('oj-radio')) {
      var selectedItem = jqFocusables.filter('.oj-selected.oj-radio');

      if (selectedItem && selectedItem.length) {
        return selectedItem[0];
      }

      return jqFocusables[0];
    }

    return jqFocusables[0];
  }

  return null;
};
/**
 * Get the last tabbable element inside the given element, which may be the
 * given element itself.
 * @param {!Element} element Element to start searching for a tabbable element in.
 * @returns {Element} The last tabbable element inside the given element.
 */


FocusUtils.getLastTabStop = function (element) {
  var jqElem = $(element);
  var jqFocusables = jqElem.find(FocusUtils._TABBABLE);

  if (jqFocusables && jqFocusables.length > 0) {
    //
    // Handle set-based content (radiosets).
    // Return the last selected radioset item.
    //
    if (jqFocusables[jqFocusables.length - 1].classList.contains('oj-radio')) {
      var selectedItem = jqFocusables.filter('.oj-selected.oj-radio');

      if (selectedItem && selectedItem.length) {
        return selectedItem[selectedItem.length - 1];
      }

      return jqFocusables[jqFocusables.length - 1];
    }

    return jqFocusables[jqFocusables.length - 1];
  }

  return null;
};
/**
 * Extends the jquery ":focusable" pseudo selector check for a Safari browser specific
 * exception - an anchor element not having a tabindex attribute.
 *
 * @param {Element} element target dom element to test if it will take focus
 * @returns {boolean} <code>true</code> if the target element is focusable
 */


FocusUtils.isFocusable = function (element) {
  if ($(element).is(':focusable')) {
    // An anchor element in safari will not take focus unless it has a tabindex.
    // http://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#Clicking_and_focus
    if (element.nodeName === 'A' && !element.hasAttribute('tabindex') && oj.AgentUtils.getAgentInfo().browser === oj.AgentUtils.BROWSER.SAFARI) {
      return false;
    }

    return true;
  }

  return false;
};

;return FocusUtils;
});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojcomponentcore',['ojs/ojcore', 'ojs/ojtranslation', 'jquery', 'ojs/ojmessaging', 'ojs/ojlogger', 'ojs/ojmetadatautils',
        'ojs/ojdefaultsutils', 'ojs/ojcustomelement', 'jqueryui-amd/widget', 'jqueryui-amd/unique-id', 'jqueryui-amd/keycode', 'jqueryui-amd/focusable', 
        'jqueryui-amd/tabbable', 'ojs/ojdomutils', 'ojs/ojfocusutils'], 
  function(oj, Translations, $, Message, Logger, MetadataUtils, defaults)
{
  "use strict";
  var DefaultsUtils = defaults.DefaultsUtils;


/**
 * @namespace oj.Components
 * @classdesc JET Component services
 * @since 1.0
 * @export
 * @ojtsmodule
 * @hideconstructor
 */
oj.Components = {}; // this is the variable name that the AMD module will return in the require callback (used in a no-require environment)
// eslint-disable-next-line no-unused-vars

var Components = oj.Components;
/**
 * @private
 */

oj.Components._OJ_CONTAINER_ATTR = 'data-oj-container';
/**
 * @private
 */

var _OJ_WIDGET_NAMES_DATA = 'oj-component-names';
/**
 * Marks the element which is a jQueryUI component
 * @private
 */

var _OJ_COMPONENT_NODE_CLASS = 'oj-component-initnode';
/**
 * Marks an element as being hidden.
 *
 * @private
 */

var _OJ_SUBTREE_HIDDEN_CLASS = 'oj-subtree-hidden';
/**
 * Marks an element as a container that will control hidden of its children
 * once it finishes initializing
 *
 * @private
 */

var _OJ_PENDING_SUBTREE_HIDDEN_CLASS = 'oj-pending-subtree-hidden';
/**
 * Sets default options values for JET components.
 * @param {!Object} options - property values that will be merged into the values
 * that were previously set using this method. The options object is expected to have the format demonstrated
 * by the following example:
 * <pre>
 * {
 *   'default': // properties for all JET components
 *   {
 *     'option1': 'somevalue'
 *   },
 *   'editableValue': // properties for editableValue components
 *   {
 *     'option1': 'somevalue1',
 *     'option2': oj.Components.createDynamicPropertyGetter(function(context){
 *                                 return context['containers'].indexOf('ojTable') >= 0 ? 'tableValue' : 'normalValue'})
 *   },
 *   'ojText': // properties for instances of ojText
 *   {
 *     'option1': 'somevalue2'
 *   }
 * }
 * </pre>
 * To specify a dynamic getter for the property, pass your callback to oj.Components.createDynamicPropertyGetter(). Note
 * that dynamic getters nested within a complex property value are not supported
 * @see oj.Components.createDynamicPropertyGetter
 * @return {void}
 * @export
 * @ojtsignore
 */

oj.Components.setDefaultOptions = function (options) {
  var props = oj.Components._defaultProperties || {};
  var keys = Object.keys(options);
  keys.forEach(function (key) {
    var value = options[key];

    if (!oj.CollectionUtils.isPlainObject(value)) {
      throw new Error('Invalid default options');
    }

    props[key] = _accumulateValues(props[key] || {}, value, false);
  });
  oj.Components._defaultProperties = props;
};
/**
 * Retrieves default option values for JET components. This method should only be used internally by JET.
 * @deprecated since version 2.2
 * @ignore
 * @return {Object} default option values
 * @see oj.Components.setDefaultOptions
 * @export
 */


oj.Components.getDefaultOptions = function () {
  return oj.Components._defaultProperties || {};
};
/**
 * Creates a dynamic getter that can be used as a property value in oj.Components.setDefaultOptions()
 * @param {!Function} callback - dynamic property callback. The callback will receive a context object as a parameter.
 * The following properties are currently supported on the context object:
 * <ul>
 * <li>containers - an array of component names of the current component's containers that require special behavior from
 * their children</li>
 * <li>element - component's host DOM element</li>
 * </ul>
 * The callback should return the computed property value
 *
 * @return {Object} - dynamic property getter
 * @see oj.Components.setDefaultOptions
 * @export
 * @ojtsignore
 */


oj.Components.createDynamicPropertyGetter = function (callback) {
  return new __ojDynamicGetter(callback);
};
/**
 * This method should only be used for JQueryUI components and will return null if used
 * with a custom element. Retrieves widget constructor associated with the HTML element
 * or null if none is found. The returned constructor is already bound to the associated
 * JQuery element, so it can be invoked as a function directly. For example:
 * <pre>
 * widgetConstructor("option", "label", "custom"); // sets label option
 * </pre>
 * If widgetName is not specified, and if more than one widget is associated with the element,
 * the method will a return the widget that was created first.
 * @param {?(Element|Node)} element - HTML element
 * @param {string=} widgetName - optional widget name
 * @return {Function|null} widget constructor
 * @export
 * @ojtsignore
 */


oj.Components.getWidgetConstructor = function (element, widgetName) {
  if (element && !oj.BaseCustomElementBridge.getRegistered(element.tagName)) {
    return oj.Components.__GetWidgetConstructor(element, widgetName);
  }

  return null;
};
/**
 * Internal version for components to call which won't return null for
 * custom elements. See public method for jsDoc.
 * @param {?(Element|Node)} element - HTML element
 * @param {string=} widgetName - optional widget name
 * @return {Function|null} widget constructor
 * @ignore
 */


oj.Components.__GetWidgetConstructor = function (element, widgetName) {
  var jelem = $(element);
  var data = jelem.data(_OJ_WIDGET_NAMES_DATA);

  if (data) {
    if (widgetName == null) {
      // eslint-disable-next-line no-param-reassign
      widgetName = data[0];
    } else if (data.indexOf(widgetName) < 0) {
      // eslint-disable-next-line no-param-reassign
      widgetName = undefined;
    }

    if (widgetName != null) {
      var func = jelem[widgetName];

      if (typeof func === 'function') {
        return func.bind(jelem);
      }
    }
  }

  return null;
};
/**
 * Notifies JET framework that a subtree possibly containing JET components has been inserted
 * into the document programmatically.
 *
 * Note that there is no need to call this method when the new DOM is being inserted by the template engine
 * in Knockout.js
 * @param {!Element} node - the root of the subtree
 * @see oj.Components.subtreeDetached
 * @return {void}
 * @export
 */


oj.Components.subtreeAttached = function (node) {
  oj.DomUtils.fixResizeListeners(node);

  _applyToComponents(node, function (instance) {
    instance.__handleSubtreeAttached();
  });
};
/**
 * Notifies JET framework that a subtree possibly containing JET components has been removed
 * from the document programmatically.
 *
 * Note that calling this method is not needs after calling JQuery's .remove() because all JET components would have been
 * already destroyed in that case. Similarly, there is no need to call this method after the subtree has been removed by
 * Knockout.js
 * @param {!Element} node - the root of the subtree
 * @see oj.Components.subtreeAttached
 * @return {void}
 * @export
 */


oj.Components.subtreeDetached = function (node) {
  _applyToComponents(node, function (instance) {
    instance.__handleSubtreeDetached();
  });
};
/**
 * Notifies JET framework that a subtree possibly containing JET components is no longer hidden with display:none style
 * This method should be called by the application if the 'display' style is being changed from 'hidden' programmatically,
 * such as when JQuery's .show() method is called.
 * For cases where subtree is shown on initial render, this method should be called with the options parameter set to
 * {'initialRender':true}, that will result in _NotifyInitShown() calls to the subtree components.
 * All oj-defer elements in the entire subtree will be activated. Note that subtreeShown currently notifies the entire
 * subtree as well. This generally means that only non-nested oj-defer elements make sense in a subtree.
 *
 * @param {!Node} node - the root of the subtree
 * @param {Object=} options Options to control subtreeShown
 * @param {boolean} options.initialRender The index at which to start fetching records.
 * @see oj.Components.subtreeHidden
 * @return {void}
 * @export
 */


oj.Components.subtreeShown = function (node, options) {
  var _node = $(node)[0]; // Strip possible jQuery wrapper

  if (_node.nodeType !== Node.ELEMENT_NODE) {
    return;
  }

  var _options = options || {};

  var isInitialRender = _options.initialRender;

  if (!isInitialRender) {
    oj.DomUtils.fixResizeListeners(_node);
  }

  unmarkSubtreeHidden(_node);

  _applyHideShowToComponents(_node, function (instance) {
    if (isInitialRender) {
      instance._NotifyInitShown();
    } else {
      instance._NotifyShown();
    }
  }, true);
};
/**
 * Notifies JET framework that a subtree possibly containing JET components has been hidden  with display:none style
 * This method should be called by the application after the subtree has been hidden programmatically, such as
 * when JQuery's .hide() method is called.
 *
 * @param {!Node} node - the root of the subtree
 * @see oj.Components.subtreeShown
 * @return {void}
 * @export
 */


oj.Components.subtreeHidden = function (node) {
  var _node = $(node)[0]; // Strip possible jQuery wrapper

  if (_node.nodeType !== Node.ELEMENT_NODE) {
    return;
  }

  _applyHideShowToComponents(_node, function (instance) {
    instance._NotifyHidden();
  }, false);

  markSubtreeHidden(_node);
};
/**
 * Add a marker class indicating that this subtree is hidden.
 *
 * @ignore
 */


function markSubtreeHidden(element) {
  element.classList.add(_OJ_SUBTREE_HIDDEN_CLASS);
}
/**
 * Remove the marker class indicating that this subtree is hidden.
 *
 * @ignore
 */


function unmarkSubtreeHidden(element) {
  element.classList.remove(_OJ_SUBTREE_HIDDEN_CLASS);
}
/**
 * Called by CCAs and certain custom elements when they are first connected
 * to indicate that this component is initializing and will control
 * whether its child subtrees are hidden.
 *
 * @ignore
 */


oj.Components.markPendingSubtreeHidden = function (element) {
  element.classList.add(_OJ_PENDING_SUBTREE_HIDDEN_CLASS);
};
/**
 * Called by CCAs and certain custom elements right before they are first rendered.
 * This component will control whether its child subtrees are hidden.
 *
 * @ignore
 */


oj.Components.unmarkPendingSubtreeHidden = function (element) {
  element.classList.remove(_OJ_PENDING_SUBTREE_HIDDEN_CLASS);
};
/**
 * Determines if a component identified by the <code>widgetName</code> has been
 * bound and initialized on a given <code>jelement</code>.
 *
 * @param {jQuery} jelement to which the component is bound
 * @param {string} widgetName constructor name of the target component.
 * @return {boolean} <code>true</code> if the component identified by the widgetName
 *  has be bound and initialized to the target element.
 * @ojtsignore
 */


oj.Components.isComponentInitialized = function (jelement, widgetName) {
  /** @type {?} */
  var widgets = jelement.data(_OJ_WIDGET_NAMES_DATA);

  if ($.isArray(widgets) && widgets.indexOf(widgetName) > -1 && jelement.is('.' + _OJ_COMPONENT_NODE_CLASS)) {
    return true;
  }

  return false;
};
/**
 * @ignore
 */


oj.Components.__getDefaultOptions = function (hierarchyNames) {
  var defaults = {};
  var allProperties = oj.Components.getDefaultOptions();

  for (var i = hierarchyNames.length - 1; i >= 0; i--) {
    var name = hierarchyNames[i];
    var props = allProperties[name];

    if (props !== undefined) {
      defaults = _accumulateValues(defaults, props, true);
    }
  }

  return defaults;
};
/**
 * Retrieves the JET component element that
 * the node is in.
 * @param {?(Element|Node)} node - DOM node
 * @return {?(Element|Node)} componentElement - JET component element
 * A component element is the DOM element on which the JET component is
 * initialized.
 * @export
 * @ojtsignore
*/


oj.Components.getComponentElementByNode = function (node) {
  // Temporarily exposing this private flag in order to allow
  // MonkeyTalk to access JET components that are part of the
  // composite's implementation. We are not exposing this flag
  // as a public API as a) accessing composite implementation
  // components is bad and b) the need for this method will soon
  // go away. Once our new automation API (recording adapters) are
  // in place, even MonkeyTalk will no longer need this flag. Adding
  // this as a stop-gap measure to allow MonkeyTalk to carry on in the
  // meantime. Callers other than MonkeyTalk must avoid specifying this flag.
  var mtAccessCompositeInternals = !!(arguments.length > 1 && arguments[1]);
  return _getComponentElementByNode(node, mtAccessCompositeInternals);
};
/**
 * Private method implementing the functionality of
 * getComponentElementByNode. This was done because Closure
 * throws an error when the private, undocumented flag (mtAccessCompositeInternals)
 * is passed to recursive calls of getComponentElementByNode.
 * @private
*/


function _getComponentElementByNode(node, mtAccessCompositeInternals) {
  if (node == null) {
    return null;
  } // node can be a Node or Element but we call some Element only APIs
  // so we need to do an additional isElement check first


  var isElement = node.nodeType === 1; // for upstream or indirect dependency we will still rely components being registered on the oj namespace.

  var containingComposite = oj.Composite && !mtAccessCompositeInternals ? oj.Composite.getContainingComposite(node) : null;

  if (containingComposite) {
    // node is in or is a composite, return composite
    return containingComposite;
  } else if (isElement && node.hasAttribute('data-oj-internal')) {
    // node is an internal component
    if (node.parentNode instanceof Element && node.parentNode.hasAttribute('data-oj-surrogate-id')) {
      // internal component is a popup
      // eslint-disable-next-line no-param-reassign
      node = document.querySelector('[data-oj-popup-' + node.id + '-parent]'); // retrieves popups parent element

      return _getComponentElementByNode(node, mtAccessCompositeInternals);
    }

    return _getComponentElementByNode(node.parentNode, mtAccessCompositeInternals);
  } else if (_isComponentElement(node)) {
    // node is a component element
    return node;
  } else if (isElement && node.classList.contains('oj-component')) {
    // node is component wrapper
    // eslint-disable-next-line no-param-reassign
    node = node.querySelector('.oj-component-initnode:not([data-oj-internal])') || node;

    if (_isJQueryUI(node)) {
      return node;
    }
  } else if (isElement && node.hasAttribute('data-oj-containerid')) {
    // node is non-internal component popup e.g listbox
    // eslint-disable-next-line no-param-reassign
    node = document.getElementById(node.getAttribute('data-oj-containerid'));
    return _getComponentElementByNode(node, mtAccessCompositeInternals);
  }

  return _getComponentElementByNode(node.parentNode, mtAccessCompositeInternals);
}
/**
 * Retrieves the subId of the node as
 * as part of a locator object i.e. at least
 * {subId: subIdOfNode}
 * @param {?Element} componentElement - JET component element
 * @param {?Element} node - DOM node
 * @return {any} locator - object with at least a subId
 * or null if the node does not have a subId
 * @export
 * @ojtsignore
*/


oj.Components.getSubIdByNode = function (componentElement, node) {
  return oj.Components.callComponentMethod(componentElement, 'getSubIdByNode', node);
};
/**
 * Returns the component DOM node indicated
 * by the locator parameter.
 * @param {?Element} componentElement - JET component element
 * @param {Object} locator - Object containing, at minimum,
 * a subId property, whose value is a string that identifies
 * a particular DOM node in this component.
 * @return {any} node - The DOM node located by
 * the locator, or null if none is found
 * @export
 * @ojtsignore
*/


oj.Components.getNodeBySubId = function (componentElement, locator) {
  return oj.Components.callComponentMethod(componentElement, 'getNodeBySubId', locator);
};
/**
 * Retrieves the specified option of
 * the specified JET component element
 * @param {?Element} componentElement - JET component element
 * @param {string} option - option to retrieve
 * @return {any} value of option
 * @export
 * @ojtsignore
*/


oj.Components.getComponentOption = function (componentElement, option) {
  if (!_isComponentElement(componentElement)) {
    throw new Error('node is not a component element');
  } else if (_isCompositeOrCustom(componentElement)) {
    if (componentElement.getProperty) {
      return componentElement.getProperty.call(componentElement, option);
    }
  } else {
    return oj.Components.__GetWidgetConstructor(componentElement)('option', option);
  }

  return undefined;
};
/**
 * Sets the specified option of the specified
 * JET component element to the specified value
 * @param {?Element} componentElement - JET component element
 * @param {string} option - option to set
 * @param {any} value - value to set option to
 * @return {void}
 * @export
 * @ojtsignore
*/


oj.Components.setComponentOption = function (componentElement, option, value) {
  if (!_isComponentElement(componentElement)) {
    throw new Error('node is not a component element');
  } else if (_isCompositeOrCustom(componentElement)) {
    if (componentElement.setProperty) {
      componentElement.setProperty.call(componentElement, option, value);
    }
  } else {
    oj.Components.__GetWidgetConstructor(componentElement)('option', option, value);
  }
};
/**
 * Calls the specified JET component element's method
 * with the given arguments
 * @param {?Element} componentElement - JET component element
 * @param {string} method - name of JET component element method to call
 * @param {...*} methodArguments - list of arguments to pass to method call
 * @return {any}
 * @export
 * @ojtsignore
*/
// eslint-disable-next-line no-unused-vars


oj.Components.callComponentMethod = function (componentElement, method, methodArguments) {
  if (!_isComponentElement(componentElement)) {
    throw new Error('node is not a component element');
  } else if (_isCompositeOrCustom(componentElement)) {
    if (componentElement[method]) {
      return componentElement[method].apply(componentElement, [].slice.call(arguments, 2));
    }
  } else {
    return oj.Components.__GetWidgetConstructor(componentElement).apply($(componentElement), [].slice.call(arguments, 1));
  }

  return undefined;
};
/**
 * @private
 */


function _applyToComponents(subtreeRoot, jqCallback) {
  var processFunc = function processFunc() {
    var jelem = $(this);
    var names = jelem.data(_OJ_WIDGET_NAMES_DATA);

    if (names != null) {
      for (var i = 0; i < names.length; i++) {
        var instance = jelem.data('oj-' + names[i]);

        if (instance != null) {
          jqCallback(instance);
        }
      }
    }
  };

  var locator = $(subtreeRoot); // Include the root node itself, and not just children ()

  if (locator.hasClass(_OJ_COMPONENT_NODE_CLASS)) {
    processFunc.call(subtreeRoot);
  }

  locator.find('.' + _OJ_COMPONENT_NODE_CLASS).each(processFunc);
}
/**
 * @private
 */


function _applyHideShowToComponents(subtreeRoot, jqCallback, activateDefer) {
  // Detect hidden without forcing a layout.
  function isHidden(_node) {
    var node = _node;

    while (node) {
      if (node.nodeType === Node.DOCUMENT_NODE) {
        return false; // Walked up to document.  Not hidden
      }

      if (node.nodeType === Node.ELEMENT_NODE && node.classList.contains(_OJ_SUBTREE_HIDDEN_CLASS)) {
        return true;
      }

      node = node.parentNode;
    }

    return true; // Didn't find document, so it must be detached and therefore hidden.
  }
  /**
   * Both node lists must be in document order.
   * Return new array containing nodes in 'allNodes' that are not in 'hiddenNodes'
   * @private
   */


  function filterHidden(allNodes, hiddenNodes) {
    var shownNodes = [];
    var j = 0;

    for (var i = 0; i < hiddenNodes.length; i++) {
      var hidden = hiddenNodes[i];

      while (j < allNodes.length && allNodes[j] !== hidden) {
        shownNodes.push(allNodes[j]);
        j += 1;
      }

      j += 1;
    }

    while (j < allNodes.length) {
      shownNodes.push(allNodes[j]);
      j += 1;
    }

    return shownNodes;
  }

  function processFunc(element) {
    if (jqCallback && element.classList.contains(_OJ_COMPONENT_NODE_CLASS)) {
      var jelem = $(element);
      var names = jelem.data(_OJ_WIDGET_NAMES_DATA);

      if (names != null) {
        for (var i = 0; i < names.length; i++) {
          var instance = jelem.data('oj-' + names[i]);

          if (instance != null) {
            jqCallback(instance);
          }
        }
      }
    }

    if (activateDefer && element.tagName.toLowerCase() === 'oj-defer') {
      if (element._activate) {
        element._activate();
      } else {
        throw new Error('subtreeShown called before module ojs/ojdefer was loaded');
      }
    }
  }

  if (!isHidden(subtreeRoot)) {
    processFunc(subtreeRoot); // Create selectors for jquery components and oj-defer as needed.

    var selectors = ['.' + _OJ_COMPONENT_NODE_CLASS];

    if (activateDefer) {
      selectors.push('oj-defer');
    }

    var hiddenSelectors = [];
    selectors.forEach(function (s) {
      hiddenSelectors.push('.' + _OJ_SUBTREE_HIDDEN_CLASS + ' ' + s);
      hiddenSelectors.push('.' + _OJ_PENDING_SUBTREE_HIDDEN_CLASS + ' ' + s);
    }); // Create assemble a selector that gets all matches and the subset that are hidden

    var selector = selectors.join(',');
    var hiddenSelector = hiddenSelectors.join(','); // Fetch all matching elements and those that are hidden.
    // Use the second list to filter out hidden elements.

    var allNodes = subtreeRoot.querySelectorAll(selector);
    var hiddenNodes = subtreeRoot.querySelectorAll(hiddenSelector);
    var shownNodes = filterHidden(allNodes, hiddenNodes);

    for (var i = 0; i < shownNodes.length; i++) {
      processFunc(shownNodes[i]);
    }
  }
}
/**
 * @constructor
 * @param {!Function} callback
 * @private
 */


function __ojDynamicGetter(callback) {
  this.getCallback = function () {
    return callback;
  };
}
/**
 * @ignore
 */


function _accumulateValues(target, source, valueInArray) {
  var keys = Object.keys(source);
  keys.forEach(function (key) {
    var holder = target[key] || [];
    var sourceVal = source[key];

    if (valueInArray) {
      holder = holder.concat(sourceVal);
    } else {
      holder.push(sourceVal);
    } // eslint-disable-next-line no-param-reassign


    target[key] = holder;
  });
  return target;
}
/**
 * @ignore
 */


function _isCompositeOrCustom(node) {
  return oj.BaseCustomElementBridge.getRegistered(node.tagName);
}
/**
 * @ignore
 */


function _isJQueryUI(node) {
  return !!oj.Components.__GetWidgetConstructor(node);
}
/**
 * @ignore
 */


function _isComponentElement(node) {
  return _isCompositeOrCustom(node) || _isJQueryUI(node);
}

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }



/* global Promise:false, _OJ_COMPONENT_NODE_CLASS:false, _OJ_WIDGET_NAMES_DATA:false,
          __ojDynamicGetter:false, Translations:false, Logger: false*/

/* jslint browser: true*/

/**
 * @private
 */
var _OJ_TRANSLATIONS_OPTION = 'translations';
/**
 * @private
 */

var _OJ_TRANSLATIONS_PREFIX = _OJ_TRANSLATIONS_OPTION + '.';
/**
 * @private
 */


var _OJ_COMPONENT_EVENT_OVERRIDES = {
  isDefaultPrevented: function isDefaultPrevented() {
    return false;
  },
  preventDefault: function preventDefault() {
    this.isDefaultPrevented = _returnTrue;
  },
  stopPropagation: function stopPropagation() {
    this.isPropagationStopped = _returnTrue;
  },
  stopImmediatePropagation: function stopImmediatePropagation() {
    this.isImmediatePropagationStopped = _returnTrue;
  }
};

(function () {
  // BaseComponent wrapper function, to keep "private static members" private

  /**
   * @private
   */
  var _BASE_COMPONENT = 'baseComponent';
  var _STATE_CONNECTED = 0;
  var _STATE_DISCONNECTED = 1; // -----------------------------------------------------------------------------
  // "private static members" shared by all components
  // -----------------------------------------------------------------------------

  var _lastActiveElement;
  /**
   * @ojcomponent oj.baseComponent
   * @abstract
   * @since 0.6.0
   */


  $.widget('oj.' + _BASE_COMPONENT, {
    options: {
      /**
       * <p>There is no restriction on the order in which the JET Menu and the referencing component are initialized.  However, when specifying
       * the Menu via the HTML attribute, the referenced DOM element must be in the document at the time that the referencing component is
       * initialized.
       *
       * @ojfragment contextMenuInitOrderDoc - Decomped to fragment so Tabs, Tree, and MasonryLayout can override the fragment to convey their init order restrictions.
       * @memberof oj.baseComponent
       */

      /**
       * <p>To help determine whether it's appropriate to cancel the launch or customize the menu, the <code class="prettyprint">beforeOpen</code>
       * listener can use component API's to determine which table cell, chart item, etc., is the target of the context menu. See the JSDoc and
       * demos of the individual components for details.  Keep in mind that any such logic must work whether the context menu was launched via right-click,
       * <kbd>Shift-F10</kbd>, <kbd>Press & Hold</kbd>, or component-specific touch gesture.
       *
       * @ojfragment contextMenuTargetDoc - Decomped to fragment so components can override the fragment to convey their specific API's for this.
       * @memberof oj.baseComponent
       */

      /**
       * <p>Identifies the [JET Menu]{@link oj.ojMenu} that the component should launch as a context menu on right-click, <kbd>Shift-F10</kbd>, <kbd>Press & Hold</kbd>,
       * or component-specific gesture. If specified, the browser's native context menu will be replaced by the specified JET Menu.
       *
       * <p>The value can be an HTML element, JQ selector, JQ object, NodeList, or array of elements.  In all cases, the first indicated element is used.
       *
       * <p>To specify a JET context menu on a DOM element that is not a JET component, see the <code class="prettyprint">ojContextMenu</code> binding.
       *
       * <p>To make the page semantically accurate from the outset, applications are encouraged to specify the context menu via the standard
       * HTML5 syntax shown in the below example.  When the component is initialized, the context menu thus specified will be set on the component.
       *
       * {@ojinclude "name":"contextMenuInitOrderDoc"}
       *
       * <p>After create time, the <code class="prettyprint">contextMenu</code> option should be set via this API, not by setting the DOM attribute.
       *
       * <p>The application can register a listener for the Menu's [beforeOpen]{@link oj.ojMenu#event:beforeOpen} event.  The listener can cancel the
       * launch via <code class="prettyprint">event.preventDefault()</code>, or it can customize the menu contents by editing the menu DOM directly,
       * and then calling [refresh()]{@link oj.ojMenu#refresh} on the Menu.
       *
       * {@ojinclude "name":"contextMenuTargetDoc"}
       *
       * @ojfragment contextMenuDoc - Decomped to fragment so subclasses can extend the verbiage as needed, by ojinclude'ing this fragment and then adding their own verbiage.
       * @memberof oj.baseComponent
       */

      /**
       * {@ojinclude "name":"contextMenuDoc"}
       *
       * @ignore
       * @expose
       * @memberof oj.baseComponent
       * @instance
       * @type {Element|Array.<Element>|string|jQuery|NodeList}
       * @default <code class="prettyprint">null</code>
       *
       * @example <caption>Initialize a JET component with a context menu:</caption>
       * // via recommended HTML5 syntax:
       * &lt;div id="myComponent" contextmenu="myMenu" data-bind="ojComponent: { ... }>
       *
       * // via JET initializer (less preferred) :
       * // Foo is the component, e.g., InputText, InputNumber, Select, etc.
       * $( ".selector" ).ojFoo({ "contextMenu": "#myMenu" });
       *
       * @example <caption>Get or set the <code class="prettyprint">contextMenu</code> option, after initialization:</caption>
       * // getter
       * // Foo is the component, e.g., InputText, InputNumber, Select, etc.
       * var menu = $( ".selector" ).ojFoo( "option", "contextMenu" );
       *
       * // setter
       * // Foo is the component, e.g., InputText, InputNumber, Select, etc.
       * $( ".selector" ).ojFoo( "option", "contextMenu", ".my-marker-class" );
       *
       * @example <caption>Set a JET context menu on an ordinary HTML element:</caption>
       * &lt;a href="#" id="myAnchor" contextmenu="myMenu" data-bind="ojContextMenu: {}">Some text</a>
       */
      contextMenu: null,

      /**
       * <p>Attributes specified here will be set on the component's root DOM element at creation time.
       * This is particularly useful for components like Dialog that wrap themselves in a new root element
       * at creation time.
       *
       * <p>The supported attributes are <code class="prettyprint">id</code>, which overwrites any existing value,
       * and <code class="prettyprint">class</code> and <code class="prettyprint">style</code>, which are appended
       * to the current class and style, if any.
       *
       * <p>Setting this option after component creation has no effect.  At that time, the root element already
       * exists, and can be accessed directly via the <code class="prettyprint">widget</code> method, per the second example below.
       *
       * @example <caption>Initialize a JET component, specifying a set of attributes to be set
       * on the component's root DOM element:</caption>
       * // Foo is the component, e.g., Menu, Button, InputText, InputNumber, Select, etc.
       * $( ".selector" ).ojFoo({ "rootAttributes": {
       *   "id": "myId",
       *   "style": "max-width:100%; color:blue;",
       *   "class": "my-class"
       * }});
       *
       * @example <caption>After initialization, <code class="prettyprint">rootAttributes</code> should not be used.  It is
       * not needed at that time, as attributes of the root DOM element can simply be set directly, using
       * <code class="prettyprint">widget</code>:</caption>
       * // Foo is the component, e.g., Menu, Button, InputText, InputNumber, Select, etc.
       * $( ".selector" ).ojFoo( "widget" ).css( "height", "100px" );
       * $( ".selector" ).ojFoo( "widget" ).addClass( "my-class" );
       *
       * @ignore
       * @expose
       * @memberof oj.baseComponent
       * @instance
       * @type {?Object}
       * @default <code class="prettyprint">null</code>
       */
      rootAttributes: null,

      /**
       * <p>A collection of translated resources from the translation bundle, or <code class="prettyprint">null</code> if this
       * component has no resources.  Resources may be accessed and overridden individually or collectively, as seen in the examples.
       *
       * <p> If the component does not contain any translatable resource, the default value of this attribute will be
       * <code class="prettyprint">null</code>. If not, an object containing all resources relevant to the component.
       *
       * <p>If this component has translations, their documentation immediately follows this doc entry.
       *
       * @member
       * @name translations
       * @ojshortdesc A collection of translated resources from the translation bundle, or null if this component has no resources.
       * @memberof oj.baseComponent
       * @instance
       * @ojtranslatable
       * @type {object|null}
       *
       *
       * @example <caption>Initialize the component, overriding some translated resources and leaving the others intact:</caption>
       * &lt;!-- Using dot notation -->
       * &lt;oj-some-element translations.some-key='some value' translations.some-other-key='some other value'>&lt;/oj-some-element>
       *
       * &lt;!-- Using JSON notation -->
       * &lt;oj-some-element translations='{"someKey":"some value", "someOtherKey":"some other value"}'>&lt;/oj-some-element>
       *
       * @example <caption>Get or set the <code class="prettyprint">translations</code> property after initialization:</caption>
       * // Get one
       * var value = myComponent.translations.someKey;
       *
       * // Set one, leaving the others intact. Always use the setProperty API for
       * // subproperties rather than setting a subproperty directly.
       * myComponent.setProperty('translations.someKey', 'some value');
       *
       * // Get all
       * var values = myComponent.translations;
       *
       * // Set all.  Must list every resource key, as those not listed are lost.
       * myComponent.translations = {
       *     someKey: 'some value',
       *     someOtherKey: 'some other value'
       * };
       *
       */
      // translations property is initialized programmatically, so this top-level API doc lives in this virtual comment.
      // Translations for all components are listed and JSDoc'ed in rt\src\main\resources\nls\root\ojtranslations.js.
      // That JSDoc appears in the same generated doc page as this top-level doc.
      // Events

      /**
       * Fired whenever a supported component option changes, whether due to user interaction or programmatic
       * intervention.  If the new value is the same as the previous value, no event will be fired.  The event
       * listener will receive two parameters described below:
       *
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui event payload
       * @property {string} ui.option the name of the option that changed.
       * @property {Object} ui.previousValue - an Object holding the previous value of the option.
       * When previousValue is not a primitive type, i.e., is an Object, it may hold the same value as
       * the value property.
       * @property {Object} ui.value - an Object holding the current value of the option.
       * @property {?Object} ui.subproperty - an Object holding information about the subproperty that changed.
       * @property {string} ui.subproperty.path - the subproperty path that changed.
       * @property {Object} ui.subproperty.previousValue - an Object holding the previous value of the subproperty.
       * @property {Object} ui.subproperty.value - an Object holding the current value of the subproperty.
       * @property {Object} ui.optionMetadata information about the option that changed
       * @property {string} ui.optionMetadata.writeback <code class="prettyprint">"shouldWrite"</code> or
       *  <code class="prettyprint">"shouldNotWrite"</code>. For use by the JET writeback mechanism;
       *  'shouldWrite' indicates that the value should be written to the observable.
       *
       * @example <caption>Initialize component with the <code class="prettyprint">optionChange</code> callback</caption>
       * // Foo is Button, InputText, etc.
       * $(".selector").ojFoo({
       *   'optionChange': function (event, ui) {}
       * });
       * @example <caption>Bind an event listener to the ojoptionchange event</caption>
       * $(".selector").on({
       *   'ojoptionchange': function (event, ui) {
       *       // verify that the component firing the event is a component of interest
       *       if ($(event.target).is(".mySelector")) {
       *           window.console.log("option that changed is: " + ui['option']);
       *       }
       *   };
       * });
       *
       * @ignore
       * @memberof oj.baseComponent
       * @expose
       * @event
       * @instance
       */
      optionChange: undefined,

      /**
       * <p>Triggered before the component is destroyed. This event cannot be canceled; the
       * component will always be destroyed regardless.
       *
       * @example <caption>Initialize component with the <code class="prettyprint">destroy</code> callback</caption>
       * // Foo is Button, InputText, etc.
       * $(".selector").ojFoo({
       *   'destroy': function (event, data) {}
       * });
       * @example <caption>Bind an event listener to the destroy event</caption>
       * $(".selector").on({
       *   'ojdestroy': function (event, data) {
       *       // verify that the component firing the event is a component of interest
       *       if ($(event.target).is(".mySelector")) {
       *           window.console.log("The DOM node id for the destroyed component is : %s", event.target.id);
       *       }
       *   };
       * });
       *
       * @ignore
       * @memberof oj.baseComponent
       * @expose
       * @event
       * @instance
       */
      destroy: undefined
    },
    // TODO: flesh out JSDoc verbiage, re: call after dom changes underneath component...

    /**
     * Refreshes the component.
     * @return {void}
     * @expose
     * @memberof oj.baseComponent
     * @instance
     */
    refresh: function refresh() {
      this._propertyContext = null; // if application sets the context menu after initialization, it must refresh the component

      this._SetupContextMenu();
    },

    /**
     * <p>Overridden to save off component's default options and the options passed into the constructor (to be passed into
     * the _InitOptions() call).
     *
     * <p>This method is final. Components should instead override one or more of the overridable create-time methods
     * listed in <a href="#_ComponentCreate">_ComponentCreate</a>.
     *
     * @memberof oj.baseComponent
     * @instance
     * @private
     * @final
     */
    _createWidget: function _createWidget(options, element) {
      // Save wrapper element
      if (options) {
        this.OuterWrapper = options._wrapper;
      } // There is no need to clone these objects since they are not modified by the _createWidget() in the base class


      this._originalDefaults = this.options || {};
      this._constructorOptions = options || {};

      this._super(options, element);

      this._AfterCreateEvent();
    },

    /**
     * <p>Reads the <code class="prettyprint">rootAttributes</code> option, and sets the root attributes on the
     * component's root DOM element.  See <a href="#rootAttributes">rootAttributes</a> for the set of supported
     * attributes and how they are handled.
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     * @throws if unsupported attributes are supplied.
     */
    _SetRootAttributes: function _SetRootAttributes() {
      var value = this.options.rootAttributes;

      if (value) {
        var widget = this.widget();

        if (widget == null) {
          return;
        }

        var classValue = value.class;

        if (classValue) {
          widget.addClass(classValue);
        }

        var styleValue = value.style;

        if (styleValue) {
          var currStyle = widget.attr('style');

          if (currStyle) {
            widget.attr('style', currStyle + ';' + styleValue); // @HTMLUpdateOK
          } else {
            widget.attr('style', styleValue); // @HTMLUpdateOK
          }
        } // make shallow copy, remove class and style from the copy, and set all
        // remaining attrs on the element.  Currently id is the only remaining attr
        // that we support.


        value = $.extend({}, value);
        delete value.class;
        delete value.style;
        widget.attr(value);
        delete value.id; // remove the remaining supported value

        var unsupportedAttrs = Object.keys(value);

        if (unsupportedAttrs.length) {
          throw new Error('Unsupported values passed to rootAttributes option: ' + unsupportedAttrs.toString());
        }
      }
    },

    /**
     * <p>This method is final in JET. Components should instead override one or more of the overridable create-time methods
     * listed in <a href="#_ComponentCreate">_ComponentCreate</a>.
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     * @final
     */
    _create: function _create() {
      this._SaveAttributes(this.element);

      this._InitOptions(this._originalDefaults, this._constructorOptions);

      delete this._originalDefaults;
      delete this._constructorOptions;

      this._ComponentCreate();

      this._AfterCreate(); // allow subcomponent to setup needed resources
      // after the component is created.


      this._SetupResources(); // Marker class for all JET components on the init node (as opposed to the outer node)
      // This marker class is used to:
      // 1) find all JET components within a subtree
      // 2) to prevent FOUC:  init nodes NOT yet having this class are hidden.


      this.element.addClass(_OJ_COMPONENT_NODE_CLASS);
    },

    /**
     * <p>This method is not used in JET. Components should instead override <a href="#_InitOptions">_InitOptions</a>.
     *
     * @method
     * @name oj.baseComponent#_getCreateOptions
     * @memberof oj.baseComponent
     * @instance
     * @protected
     * @final
     */

    /**
     * <p>This method is called before <a href="#_ComponentCreate">_ComponentCreate</a>, at which point
     * the component has not yet been rendered.  Component options should be initialized in this method,
     * so that their final values are in place when <a href="#_ComponentCreate">_ComponentCreate</a> is called.
     *
     * <p>This includes getting option values from the DOM, where applicable, and coercing option
     * values (however derived) to their appropriate data type if needed.
     *
     * <p>No work other than setting options should be done in this method.  In particular, nothing should be
     * set on the DOM until <a href="#_ComponentCreate">_ComponentCreate</a>, e.g. setting the <code class="prettyprint">disabled</code>
     * DOM attribute from the <code class="prettyprint">disabled</code> option.
     *
     * <p>A given option (like <code class="prettyprint">disabled</code>) appears in the <code class="prettyprint">constructorOptions</code>
     * param iff the app set it in the constructor:
     *
     * <ul>
     *   <li>If it appears in <code class="prettyprint">constructorOptions</code>, it should win over what's in the DOM
     *     (e.g. <code class="prettyprint">disabled</code> DOM attribute).  If for some reason you need to tweak the value
     *     that the app set, then enable writeback when doing so:
     *     <code class="prettyprint">this.option('foo', bar, {'_context': {writeback: true, internalSet: true}})</code>.</li>
     *   <li>If it doesn't appear in <code class="prettyprint">constructorOptions</code>, then that option definitely is not bound,
     *     so writeback is not needed.  So if you need to set the option (e.g. from a DOM attribute), use
     *     <code class="prettyprint">this.option('foo', bar, {'_context': {internalSet: true}})</code>.</li>
     * </ul>
     *
     * <p>Overrides of this method should call <code class="prettyprint">this._super</code> first.
     *
     * @param {!Object} originalDefaults - original default options defined on the component and its ancestors
     * @param {?Object} constructorOptions - options passed into the widget constructor
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    _InitOptions: function _InitOptions(originalDefaults, constructorOptions) {
      this._setupDefaultOptions(originalDefaults, constructorOptions);

      this._initContextMenuOption(constructorOptions);
    },

    /**
     * <p>All component create-time initialization lives in this method, except the logic that specifically
     * needs to live in <a href="#_InitOptions">_InitOptions</a>, <a href="#_AfterCreate">_AfterCreate</a>,
     * or <a href="#_AfterCreateEvent">_AfterCreateEvent</a>,
     * per the documentation for those methods.  All DOM creation must happen here, since the intent of
     * <a href="#_AfterCreate">_AfterCreate</a>, which is called next, is to contain superclass logic that must
     * run after that DOM is created.
     *
     * <p>Overrides of this method should call <code class="prettyprint">this._super</code> first.
     *
     * <p>Summary of create-time methods that components can override, in the order that they are called:
     *
     * <ol>
     *   <li><a href="#_InitOptions">_InitOptions</a></li>
     *   <li><a href="#_ComponentCreate">_ComponentCreate</a> (this method)</li>
     *   <li><a href="#_AfterCreate">_AfterCreate</a></li>
     *   <li>(The <code class="prettyprint">create</code> event is fired here.)</li>
     *   <li><a href="#_AfterCreateEvent">_AfterCreateEvent</a></li>
     * </ol>
     *
     * <p>For all of these methods, the contract is that overrides must call <code class="prettyprint">this._super</code> <i>first</i>, so e.g., the
     * <code class="prettyprint">_ComponentCreate</code> entry means <code class="prettyprint">baseComponent._ComponentCreate</code>,
     * then <code class="prettyprint">_ComponentCreate</code> in any intermediate subclasses, then
     * <code class="prettyprint">_ComponentCreate</code> in the leaf subclass.
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    _ComponentCreate: function _ComponentCreate() {
      // Store widget name, so that oj.Components.__GetWidgetConstructor() can get widget from the element
      _storeWidgetName(this.element, this.widgetName); // namespace facilitates removing activeable and hoverable handlers handlers separately


      this.activeableEventNamespace = this.eventNamespace + 'activeable';
      this.hoverableEventNamespace = this.eventNamespace + 'hoverable';
    },

    /**
     * <p>This method is called after <a href="#_ComponentCreate">_ComponentCreate</a>, but before the
     * <code class="prettyprint">create</code> event is fired.  The JET base component does
     * tasks here that must happen after the component (subclass) has created itself in its override of
     * <a href="#_ComponentCreate">_ComponentCreate</a>.  Notably, the base component handles the
     * <a href="#rootAttributes">rootAttributes</a> and <a href="#contextMenu">contextMenu</a> options here,
     * since those options operate on the component root node, which for some components is created in their override
     * of <a href="#_ComponentCreate">_ComponentCreate</a>.
     *
     * <p>Subclasses should override this method only if they have tasks that must happen after a superclass's
     * implementation of this method, e.g. tasks that must happen after the context menu is set on the component.
     *
     * <p>Overrides of this method should call <code class="prettyprint">this._super</code> first.
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    _AfterCreate: function _AfterCreate() {
      this._SetRootAttributes(); // do first, since has no dependencies, but other stuff might care about these attrs
      // namespace facilitates removing contextMenu handlers separately, if app clears the "contextMenu" option


      this.contextMenuEventNamespace = this.eventNamespace + 'contextMenu'; // same for activeable and hoverable handlers

      this.activeableEventNamespace = this.eventNamespace + 'activeable';
      this.hoverableEventNamespace = this.eventNamespace + 'hoverable';
    },

    /**
     * <p>This method is called after the <code class="prettyprint">create</code> event is fired.
     * Components usually should not override this method, as it is rarely correct to wait until after the
     * <code class="prettyprint">create</code> event to perform a create-time task.
     *
     * <p>An example of a correct usage of this method is [Dialog's auto-open behavior]{@link oj.ojDialog#initialVisibility},
     * which needs to happen after the <code class="prettyprint">create</code> event.
     *
     * <p>Only <i>behaviors</i> (like Dialog auto-open behavior) should occur in this method.  Component <i>initialization</i>
     * must occur earlier, before the <code class="prettyprint">create</code> event is fired, so that
     * <code class="prettyprint">create</code> listeners see a fully inited component.
     *
     * <p>Overrides of this method should call <code class="prettyprint">this._super</code> first.
     *
     * <p>Do not confuse this method with the <a href="#_AfterCreate">_AfterCreate</a> method, which is more commonly used.
     *
     * @method
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    _AfterCreateEvent: $.noop,

    /**
     * <p>JET components should almost never implement this JQUI method.  Please consult an architect if you believe you have an exception.  Reasons:
     * <ul>
     *   <li>This method is called at create time, after the <code class="prettyprint">create</code> event is fired.  It is rare
     *       for that to be the appropriate time to perform a create-time task.  For those rare cases, we have the
     *       <a href="#_AfterCreateEvent">_AfterCreateEvent</a> method, which is preferred over this method since it is called only
     *       at that time, not also at re-init time (see next).</li>
     *   <li>This method is also called at "re-init" time, i.e. when the initializer is called after the component has already been created.
     *       JET has not yet identified any desired semantics for re-initing a component.</li>
     * </ul>
     *
     * @method
     * @name oj.baseComponent#_init
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    //  - remove JQUI memory leaks and CSS cruft introduced in 1.12 and 1.12.1
    _setOptionClasses: function _setOptionClasses() {},
    _setOptionDisabled: function _setOptionDisabled() {},
    _classes: function _classes() {
      return '';
    },
    _removeClass: function _removeClass() {
      return this;
    },
    _addClass: function _addClass() {
      return this;
    },
    _toggleClass: function _toggleClass() {
      return this;
    },

    /**
     * <p>Saves the element's attributes. This is called during _create.
     * <a href="#_RestoreAttributes">_RestoreAttributes</a> will restore all these attributes
     * and is called during _destroy.
     * </p>
     * <p> This base class default implementation does nothing.
     * </p>
     * <p>We also have <a href="#_SaveAllAttributes">_SaveAllAttributes</a> and
     * <a href="#_RestoreAllAttributes">_RestoreAllAttributes</a> methods
     *  that save and restore <i>all</i> the attributes on an element.
     *  Component subclasses can opt into these _SaveAllAttributes/_RestoreAllAttributes
     *  implementations by overriding _SaveAttributes and _RestoreAttributes to call
     *  _SaveAllAttributes/_RestoreAllAttributes. If the subclass wants a different implementation
     *  (like save only the 'class' attribute), it can provide the implementation itself in
     *  _SaveAttributes/_RestoreAttributes.
     *
     *
     * @param {Object} element - jQuery selection to save attributes for
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    // eslint-disable-next-line no-unused-vars
    _SaveAttributes: function _SaveAttributes(element) {// default implementation does nothing.
    },

    /**
     * <p>Saves all the element's attributes within an internal variable.
     * <a href="#_RestoreAllAttributes">_RestoreAllAttributes</a> will restore the attributes
     * from this internal variable.</p>
     * <p>
     * This method is final in JET.
     * Subclasses can override _RestoreAttributes and call _RestoreAllAttributes.
     * </p>
     *
     * <p>The JSON variable will be held as:
     *
     * <pre class="prettyprint">
     * <code>[
     *   {
     *   "element" : element[i],
     *   "attributes" :
     *     {
     *       attributes[m]["name"] : {"attr": attributes[m]["value"]
     *     }
     *   }
     * ]
     * </code></pre>
     *
     * @param {Object} element - jQuery selection to save attributes for
     * @memberof oj.baseComponent
     * @instance
     * @protected
     * @final
     */
    _SaveAllAttributes: function _SaveAllAttributes(element) {
      var self = this;
      this._savedAttributes = [];
      $.each(element, function (index, ele) {
        // need to be able to save for multiple elements
        var saveAttributes = {};
        var save = {
          element: ele,
          attributes: saveAttributes
        };
        var attributes = ele.attributes;

        self._savedAttributes.push(save);

        $.each(attributes, function (index2, attr) {
          // for proper access certain so called attributes should be accessed as properties
          // [i.e. required, disabled] so fetch them initially
          var attrName = attr.name;
          saveAttributes[attrName] = {
            attr: attr.value
          };
        });
      });
    },

    /**
     * <p>Gets the saved attributes for the provided element.
     *
     * <p>If you don't override <a href="#_SaveAttributes">_SaveAttributes</a> and
     * <a href="#_RestoreAttributes">_RestoreAttributes</a>, then this will return null.
     * <p>If you override _SaveAttributes to call <a href="#_SaveAllAttributes">_SaveAllAttributes</a>,
     * then this will return all the attributes.
     * If you override _SaveAttributes/_RestoreAttributes to do your own thing, then you may also have
     * to override _GetSavedAttributes to return whatever you saved if you need access to the saved
     * attributes.
     *
     * @param {Object} element - jQuery selection, should be a single entry
     * @return {Object|null} savedAttributes - attributes that were saved for this element
     * in <a href="#_SaveAttributes">_SaveAttributes</a>, or null if none were saved.
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    _GetSavedAttributes: function _GetSavedAttributes(element) {
      var savedAttributes = this._savedAttributes; // The component may not have saved any attributes. If so, return.

      if (savedAttributes === undefined) {
        return null;
      }

      var domElement = element[0];

      for (var i = 0, j = savedAttributes.length; i < j; i++) {
        var curr = savedAttributes[i];

        if (curr.element === domElement) {
          return curr.attributes;
        }
      }

      return {};
    },

    /**
     * <p>Restore the attributes saved in <a href="#_SaveAttributes">_SaveAttributes</a>.</p>
     * <p>
     * _SaveAttributes is called during _create. And _RestoreAttributes is called during _destroy.
     * </p>
     * <p> This base class default implementation does nothing.
     * </p>
     * <p>We also have <a href="#_SaveAllAttributes">_SaveAllAttributes</a> and
     * <a href="#_RestoreAllAttributes">_RestoreAllAttributes</a> methods
     *  that save and restore <i>all</i> the attributes on an element.
     *  Component subclasses can opt into these _SaveAllAttributes/_RestoreAllAttributes
     *  implementations by overriding _SaveAttributes and _RestoreAttributes to call
     *  _SaveAllAttributes/_RestoreAllAttributes. If the subclass wants a different implementation
     *  (like save only the 'class' attribute), it can provide the implementation itself in
     *  _SaveAttributes/_GetSavedAttributes/_RestoreAttributes.
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    _RestoreAttributes: function _RestoreAttributes() {// default implementation does nothing.
    },

    /**
     * <p>Restores <i>all</i> the element's attributes which were saved in
     * <a href="#_SaveAllAttributes">_SaveAllAttributes</a>.
     * This method is final in JET.</p>
     * <p>
     * If a subclass wants to save/restore all attributes on create/destroy, then the
     * subclass can override <a href="#_SaveAttributes">_SaveAttributes</a>
     *  and call  <a href="#_SaveAllAttributes">_SaveAllAttributes</a> and also
     *  override <a href="#_RestoreAttributes">_RestoreAttributes</a>
     *  and call <a href="#_RestoreAllAttributes">_RestoreAllAttributes</a>.
     *
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     * @final
     */
    _RestoreAllAttributes: function _RestoreAllAttributes() {
      $.each(this._savedAttributes, function (index, savedAttr) {
        var element = $(savedAttr.element);
        var attributes = savedAttr.attributes; // sanity check

        if (element.length === 1) {
          var currAttr = savedAttr.element.attributes;
          var removeAttr = [];
          var i;
          var j; // request is to remove any attributes that didn't exist previously
          // need to store the attributes in an array and remove them afterwards as otherwise there are side affects

          for (i = 0, j = currAttr.length; i < j; i++) {
            if (!(currAttr[i].name in attributes)) {
              removeAttr.push(currAttr[i].name);
            }
          }

          for (i = 0, j = removeAttr.length; i < j; i++) {
            element.removeAttr(removeAttr[i]);
          }

          var attributeKeys = Object.keys(attributes);

          for (i = 0; i < attributeKeys.length; i++) {
            var attribute = attributeKeys[i];
            element.attr(attribute, attributes[attribute].attr); // @HTMLUpdateOK
          }
        }
      });
    },

    /**
     * <p>Determines the name of the translation bundle section for this component.
     *
     * @return {string} the name of this component's translations section
     * @memberof oj.baseComponent
     * @protected
     */
    _GetTranslationsSectionName: function _GetTranslationsSectionName() {
      return this.widgetFullName;
    },

    /**
     * Compares 2 option values for equality and returns true if they are equal; false otherwise.
     * This method is called before _setOptions()/_internalSetOptions() to prevent an extra call
     * with the same values when observables are written back. Components should override this
     * method for options with non primitive writeback values like Arrays or Objects and ensure
     * their metadata has writeback properties correctly indicated.
     *
     * @param {String} option - the name of the option
     * @param {Object} value1 first value
     * @param {Object} value2 another value
     * @return {boolean}
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    _CompareOptionValues: function _CompareOptionValues(option, value1, value2) {
      // We process the metadata for custom elements for writeback properties and save them on the component.
      // For jQuery syntax, components are expected to override this method to check writeback values since
      // there's not always a straightforward mapping of custom element to jQuery widget name.
      if (this._IsCustomElement() && this._getWritebackOption(option)) {
        return oj.Object.compareValues(value1, value2);
      }

      return value1 === value2;
    },

    /**
     * <p>Retrieves a translated string after inserting optional parameters.
     *
     * @param {string} key the translations resource key
     * The key is used to retrieve a format pattern from the component options, or if none
     * is found - from the translated resource bundle.
     * Tokens like {0}, {1}, {name} within the pattern will be used to define placement
     * for the optional parameters.  Token strings should not contain comma (,)
     * or space characters, since they are reserved for future format type enhancements.
     * The reserved characters within a pattern are:
     * $ { } [ ]
     * These characters will not appear in the formatted output unless they are escaped
     * with a dollar character ('$').
     *
     * @param {...string|Object|Array} var_args  - optional parameters to be inserted into the
     * translated pattern.
     *
     * If more than one var_args arguments are passed, they will be treated as an array
     * for replacing positional tokens like {0}, {1}, etc.
     * If a single argument is passed, it will be treated as a Javascript Object whose
     * keys will be matched to tokens within the pattern. Note that an Array is just
     * a special kind of such an Object.
     *
     * For backward compatibility, a var_args argument whose type is neither
     * Object or Array will be used to replace {0} in the pattern.
     *
     * @return formatted translated string or the key argument if the resource for the
     * key was not found
     *
     * @memberof oj.baseComponent
     * @instance
     * @private
     */
    // TODO: non-public methods need to start with "_".  Pinged architect, who thinks this
    // method should become protected post-V1, which would imply a capital _GetTranslatedString
    // eslint-disable-next-line no-unused-vars, camelcase
    getTranslatedString: function getTranslatedString(key, var_args) {
      var params = {};

      if (arguments.length > 2) {
        params = Array.prototype.slice.call(arguments, 1);
      } else if (arguments.length === 2) {
        params = arguments[1];

        if (_typeof(params) !== 'object' && !(params instanceof Array)) {
          params = [params];
        }
      }

      var pattern = this.option(_OJ_TRANSLATIONS_PREFIX + key); // pattern could be undefined

      return pattern == null ? key : Translations.applyParameters(pattern.toString(), params);
    },
    // Subclasses should doc their sub-id's in the Sub-ID's section, via the ojsubid tag, not by overriding
    // and extending this method doc, which should remain general purpose.

    /**
     * <p>Returns the DOM node indicated by the <code class="prettyprint">locator</code> parameter.
     *
     * <p>If the <code class="prettyprint">locator</code> or its <code class="prettyprint">subId</code> is
     * <code class="prettyprint">null</code>, then this method returns this element.
     *
     * <p>If a non-null <code class="prettyprint">subId</code> is provided but no corresponding node
     * can be located, then this method returns <code class="prettyprint">null</code>.
     *
     * <p>This method is intended for use in test automation only, and should not be used in a production environment.
     *
     * @expose
     * @memberof oj.baseComponent
     * @instance
     * @ignore
     *
     * @param {Object} locator An Object containing, at minimum, a <code class="prettyprint">subId</code>
     * property, whose value is a string that identifies a particular DOM node in this element.
     *
     * <p>If this component has any subIds, then they are documented in the
     * <a href="#subids-section">Sub-ID's</a> section of this document.
     *
     * <p>Some components may support additional fields of the
     * <code class="prettyprint">locator</code> Object, to further specify the desired node.
     *
     * @returns {Element|null} The DOM node located by the
     * <code class="prettyprint">locator</code>, or <code class="prettyprint">null</code> if none is found.
     *
     * @example <caption>Get the node for a certain subId:</caption>
     * var node = myComponent.getNodeBySubId({'subId': 'oj-some-sub-id'});
     */
    getNodeBySubId: function getNodeBySubId(locator) {
      if (locator == null || locator.subId == null) {
        return this.element ? this.element[0] : null;
      } // Non-null locators have to be handled by the component subclasses


      return null;
    },

    /**
     * <p>Returns the subId string for the given DOM node in this element.  For details, see
     * <a href="#getNodeBySubId">getNodeBySubId</a> and the <a href="#subids-section">Sub-ID's</a>
     * section of this document.
     *
     * <p>This method is intended for use in test automation only, and should not be used in a production environment.
     *
     * @ojfragment getSubIdByNodeDesc
     * @memberof oj.baseComponent
     */

    /**
     * DOM node in this element
     *
     * @ojfragment getSubIdByNodeNodeParam
     * @memberof oj.baseComponent
     */

    /**
     * The subId for the DOM node, or <code class="prettyprint">null</code> if none is found.
     *
     * @ojfragment getSubIdByNodeReturn
     * @memberof oj.baseComponent
     */

    /**
     * Get the subId for a certain DOM node:
     *
     * @ojfragment getSubIdByNodeCaption
     * @memberof oj.baseComponent
     */

    /**
     * var locator = myComponent.getSubIdByNode(nodeInsideElement);
     *
     * @ojfragment getSubIdByNodeExample
     * @memberof oj.baseComponent
     */
    // While a subclass could technically extend the verbiage by adding its own verbiage after the ojinclude,
    // please doc sub-id's in the subid's section, not by extending this method doc.

    /**
     * {@ojinclude "name":"getSubIdByNodeDesc"}
     *
     * @expose
     * @memberof oj.baseComponent
     * @instance
     * @ignore
     *
     * @param {!Element} node {@ojinclude "name":"getSubIdByNodeNodeParam"}
     * @returns {Object|null} {@ojinclude "name":"getSubIdByNodeReturn"}
     *
     * @example <caption>{@ojinclude "name":"getSubIdByNodeCaption"}</caption>
     * {@ojinclude "name":"getSubIdByNodeExample"}
     */
    // eslint-disable-next-line no-unused-vars
    getSubIdByNode: function getSubIdByNode(node) {
      return null;
    },
    // Overridden to set oj-hover and oj-focus classes
    // TODO: Move JSDoc from subclasses to here.  Don't include above internal comment.  Make at-final.
    destroy: function destroy() {
      if (this._IsCustomElement()) {
        throw new Error('destroy cannot be called on a custom element');
      } // Fire 'destroy' event


      this._trigger('destroy'); // Since jQuery event listeners get removed before the destroy() method whne jQuery.clean() cleans up the subtree,
      // we need to fire a custom DOM event as well. This will allow component binding to execute destroy callbacks for
      // custom bindings and managed attributes.


      oj.DomUtils.dispatchEvent(this.element[0], new CustomEvent('_ojDestroy')); // allow subcomponent to release resources they hold.

      this._ReleaseResources();

      this._super(); // remove hover and active listeners
      //    this.widget().off(this.eventNamespace);
      // clean up states


      this.element.removeClass(_OJ_COMPONENT_NODE_CLASS);
      this.widget().removeClass('oj-disabled'); // pass init node (this.element), not root node if different (this.widget()), since all elements in
      // the root node subtree but not the init node subtree should have been removed by the call to _super.

      this._removeStateClasses(this.element);

      _removeWidgetName(this.element, this.widgetName);

      this._RestoreAttributes(); // TODO: move this to _RestoreAttributes?


      if (this._initialCmDomAttr) {
        this.element.attr('contextmenu', this._initialCmDomAttr);
      } else {
        this.element.removeAttr('contextmenu');
      }

      this._propertyContext = null;
    },

    /*
     * Internal notes:
     * Overridden to pass extra flags to _setOption
     * param {...Object} var_args - key (or map), value, flags
     */

    /**
     * <p>This method has several overloads, which get and set component options and their fields.  The functionality is unchanged from
     * that provided by JQUI.  See the examples for details on each overload.
     *
     * @ignore
     * @expose
     * @memberof oj.baseComponent
     * @instance
     * @final
     *
     * @param {string|Object=} optionName the option name (string, first two overloads), or the map (Object, last overload).
     *        Omitted in the third overload.
     * @param {Object=} value a value to set for the option.  Second overload only.
     * @return {Object|undefined} The getter overloads return the retrieved value(s).  When called via the public jQuery syntax, the setter overloads
     *         return the object on which they were called, to facilitate method chaining.
     *
     * @example <caption>First overload: get one option:
     * <p>This overload accepts a (possibly dot-separated) <code class="prettyprint">optionName</code> param as a string, and returns
     * the current value of that option.</caption>
     * var isDisabled = $( ".selector" ).ojFoo( "option", "disabled" ); // Foo is Button, Menu, etc.
     *
     * // For object-valued options, dot notation can be used to get the value of a field or nested field.
     * var startIcon = $( ".selector" ).ojButton( "option", "icons.start" ); // icons is object with "start" field
     *
     * @example <caption>Second overload: set one option:
     * <p>This overload accepts two params: a (possibly dot-separated) <code class="prettyprint">optionName</code> string, and a new value to
     * which that option will be set.</caption>
     * $( ".selector" ).ojFoo( "option", "disabled", true ); // Foo is Button, Menu, etc.
     *
     * // For object-valued options, dot notation can be used to set the value
     * // of a field or nested field, without altering the rest of the object.
     * $( ".selector" ).ojButton( "option", "icons.start", myStartIcon ); // icons is object with "start" field
     *
     * @example <caption>Third overload: get all options:
     * <p>This overload accepts no params, and returns a map of key/value pairs representing all the component
     * options and their values.</caption>
     * var options = $( ".selector" ).ojFoo( "option" ); // Foo is Button, Menu, etc.
     *
     * @example <caption>Fourth overload: set one or more options:
     * <p>This overload accepts a single map of option-value pairs to set on the component.  Unlike the first two
     * overloads, dot notation cannot be used.</caption>
     * $( ".selector" ).ojFoo( "option", { disabled: true, bar: 42 } ); // Foo is Button, Menu, etc.
     */
    option: function option(optionName, value) {
      // actually varArgs per comment above the JSDoc, but GCC warns unless matches the @param that we wish to doc
      if (arguments.length === 0) {
        // don't return a reference to the internal hash
        return $.widget.extend({}, this.options);
      }

      var key = arguments[0];
      var options = key;
      var subkey = null;
      var flags = {};
      var i;

      if (typeof key === 'string') {
        // handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
        options = {};
        var parts = key.split('.');
        key = parts.shift();

        if (parts.length) {
          subkey = parts.join('.');
          var curOption;

          try {
            // Inform dynamic getters that the subkey is being set
            if (arguments.length > 1) {
              this._settingNestedKey = subkey;
            }

            curOption = $.widget.extend({}, this.options[key]);
            options[key] = curOption;
          } finally {
            this._settingNestedKey = null;
          }

          for (i = 0; i < parts.length - 1; i++) {
            curOption[parts[i]] = curOption[parts[i]] || {};
            curOption = curOption[parts[i]];
          }

          key = parts.pop();

          if (arguments.length === 1) {
            return curOption[key] === undefined ? null : curOption[key];
          }

          curOption[key] = value;
        } else {
          if (arguments.length === 1) {
            return this.options[key] === undefined ? null : this.options[key];
          }

          options[key] = value;
        }

        flags = arguments[2] || flags;
      } else {
        flags = arguments[1] || flags;
      } // Store subkey on the flags to let _setOption() know that dot notation was used


      if (subkey != null) {
        var subprop = {
          path: optionName,
          value: value
        };
        flags = $.widget.extend({}, flags, {
          subkey: subkey,
          subproperty: subprop
        });
      }

      var context = flags ? flags._context : null;
      var internalSet = context ? context.internalSet : false; // This method can be called twice with the same value for writeback properties
      // so we need to go through the options object and only pass through the changed values

      var newOptions = {};
      var optionKeys = Object.keys(options);

      for (i = 0; i < optionKeys.length; i++) {
        var option = optionKeys[i];
        var newValue = options[option];
        var oldValue = this.options[option]; // The changed flag is set when components have updated an object or array value in place

        var changed = flags && flags.changed;

        if (changed || !this._CompareOptionValues(option, oldValue, newValue)) {
          newOptions[option] = newValue;
        } else if (this._IsCustomElement()) {
          Logger.info(oj.BaseCustomElementBridge.getElementInfo(this.element[0]) + ": Ignoring property set for property '" + option + "' with same value.");
        }
      }

      if (Object.keys(newOptions).length > 0) {
        // Avoid _setOption() calls for internal sets, since component's _setOption()
        // and setOptions() overrides do not expect to be called in that case
        if (internalSet) {
          this._internalSetOptions(newOptions, flags);
        } else {
          this._setOptions(newOptions, flags);
        }
      }

      return this;
    },

    /**
     * option() calls this rather than _setOption() if the caller was internal.
     *
     * @memberof oj.baseComponent
     * @instance
     * @private
     */
    _internalSetOptions: function _internalSetOptions(options, flags) {
      var keys = Object.keys(options);

      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var value = options[key];
        var oldValue = this.options[key];
        this.options[key] = value;

        this._optionChanged(key, value, oldValue, flags);
      }
    },

    /**
     * <p>Overridden to pass extra flags to _setOption.
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     * @ignore
     */
    _setOptions: function _setOptions(options, flags) {
      var keys = Object.keys(options);

      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var value = options[key];

        this._setOption(key, value, flags);
      }

      return this;
    },

    /**
     * Overridden to set oj-hover and oj-focus classes.
     * Components should not call this method directly, but instead call option().
     * @memberof oj.baseComponent
     * @instance
     * @protected
     * @ignore
     */
    _setOption: function _setOption(key, value, flags) {
      var originalValue = this.options[key];

      if (key === 'disabled') {
        // The JQUI superclass method has hard-coded style classes in the 'if key === "disabled"' block, so unfortunately
        // we must copy that logic here with updated style classes, and NOT call _super() for the disabled case.
        // TBD: keep this logic updated if superclass method changes.
        this.options[key] = value; // TBD: widget() is not always the thing that should have aria-disabled on it.  E.g. for the checkbox/radio flavors of ojButton,
        // widget() returns the root node, but aria-disabled belongs on the <input>.  We fixed this JQUI bug in ojButton by having ojButton
        // override this method to remove it from the root node and add it to the input.  Would be better for each component to know which
        // element to apply that to, e.g. an overridable method returning that element, or copying "hoverable" paradigm if appropriate.
        // In the cases where this.element is different than widget(), this.element is more likely to be the right thing, so maybe change
        // default to that.
        // Update: this issue is getting even more awkward now that we have "effectively disabled".  Probably need to refactor this code!

        this.widget().toggleClass('oj-disabled', !!value).attr('aria-disabled', value);

        if (value) {
          this._removeStateClasses(this.widget());
        }
      } else {
        try {
          var subkey = flags == null ? null : flags.subkey;

          if (subkey != null) {
            this._settingNestedKey = subkey;
          }

          this._super(key, value);
        } finally {
          this._settingNestedKey = null;
        } // if contextMenu option wasn't set before, we'll need to start detect gesture


        if (key === 'contextMenu') {
          this._SetupContextMenu();
        }
      }

      this._optionChanged(key, value, originalValue, flags);

      return this;
    },

    /**
     * @memberof oj.baseComponent
     * @instance
     * @private
     */
    _optionChanged: function _optionChanged(key, value, originalValue, flags) {
      // Assume that all values are different from originalValues as we do equality
      // checking before calling this method or trust components that have set the
      // 'changed' flag to indicate that they updated in place for an Object or Array
      // since we won't see any difference for those cases.
      // var changed = false;
      var context = null;
      var writeback = false;
      var readOnly = false;
      var originalEvent = null;
      var updatedFrom = 'external';
      var optionMetadata = null;
      var extraData;

      if (flags) {
        context = flags._context;

        if (context) {
          // Skip firing an option changed event for certain cases like
          // custom element default value sets where the bridge interprets an
          // application undefined value set to the property default defined in the
          // metadata.
          if (context.skipEvent) {
            return;
          }

          originalEvent = context.originalEvent;
          writeback = context.writeback === undefined ? originalEvent != null : context.writeback;
          readOnly = context.readOnly;
          optionMetadata = context.optionMetadata;
          extraData = context.extraData;

          if (context.internalSet) {
            updatedFrom = 'internal';
          }
        }
      }

      optionMetadata = optionMetadata || {};
      optionMetadata.writeback = writeback ? 'shouldWrite' : 'shouldNotWrite';

      if (readOnly) {
        optionMetadata.readOnly = true;
      }

      var optionChangeData = {
        option: key,
        previousValue: originalValue,
        value: value,
        optionMetadata: optionMetadata,
        updatedFrom: updatedFrom
      };
      var subkey = flags == null ? null : flags.subkey; // Walk previousValue object and find the subproperty previousValue

      if (subkey) {
        var subprops = subkey.split('.');
        var originalSubpropValue = originalValue;
        subprops.forEach(function (subprop) {
          if (!originalSubpropValue) {
            return;
          }

          originalSubpropValue = originalSubpropValue[subprop];
        });
        var subproperty = flags.subproperty;
        subproperty.previousValue = originalSubpropValue;
        optionChangeData.subproperty = subproperty;
      }

      if (extraData != null) {
        optionChangeData = $.extend({}, extraData, optionChangeData);
      }

      this._trigger('optionChange', originalEvent, optionChangeData);
    },

    /**
     * <p>Sets up needed resources for this component, for example, add
     * listeners. This is called during _create.
     * <a href="#_ReleaseResources">_ReleaseResources</a> will release resources
     * help by this component, and is called during destroy.
     * </p>
     *  Component subclasses can opt in by overriding _SetupResources and
     *   _ReleaseResources.
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    _SetupResources: function _SetupResources() {
      this._SetupContextMenu();
    },

    /**
     * <p>Release resources held by this component, for example, remove
     * listeners. This is called during destroy.
     * <a href="#_SetupResources">_SetupResources</a> will set up resources
     * needed by this component, and is called during _create.
     * </p>
     *  Component subclasses can opt in by overriding _SetupResources and
     *   _ReleaseResources.
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    _ReleaseResources: function _ReleaseResources() {
      this._ReleaseContextMenu();
    },

    /**
     * <p>Overridden to change the way the component events are treating original events:
     *
     * 1) preventDefault(), stopPropagation() and stopImmediatePropagation() no longer invoke
     *    the corresponding methods on the .originalEvent
     * 2) Properties of the .originalEvent are no longer copied to the new event being
     *    triggered
     *
     * @param {string} type - component event type
     * @param {?Object} event - original event
     * @param {Object=} data - event data
     * @return {boolean} true if the default action has not been prevented, false otherwise
     *
     * @private
     */
    _trigger: function _trigger(type, event, data) {
      return this._trigger2(type, event, data).proceed;
    },

    /**
     * <p>Same as _trigger(), but returns an object containing both the "prevented" status and the event.
     *
     * <p>This is useful for event chaining, so that the returned event (e.g. Menu's select event) can be
     * passed as the originalEvent of a subsequent event caused by the first (e.g. Menu's close event).
     *
     * @param {string} type - component event type
     * @param {?Object} event - original event
     * @param {Object=} data - event data
     * @return {!{proceed: boolean, event: ($.Event|CustomEvent)}}
     *     proceed is true if the default action has not been prevented, false otherwise
     *     event is the new event that was triggered
     *
     * @private
     */
    _trigger2: function _trigger2(type, event, data) {
      var eventData = data || {};

      if (this._IsCustomElement()) {
        return this._triggerCustomEvent(type, event, eventData);
      }

      var callback = this.options[type];
      var jqEvent = $.Event(event, _OJ_COMPONENT_EVENT_OVERRIDES);
      jqEvent.type = (this.widgetEventPrefix + type).toLowerCase(); // the original event may come from any element
      // so we need to reset the target on the new event

      jqEvent.target = this.element[0];
      this.element.trigger(jqEvent, eventData);
      return {
        proceed: !($.isFunction(callback) && callback.apply(this.element[0], [jqEvent].concat(eventData)) === false || jqEvent.isDefaultPrevented()),
        event: jqEvent
      };
    },

    /**
     * <p>Fires a CustomEvent instead of a jQuery event for when this component is created as a custom element.
     *
     * @param {string} type - component event type
     * @param {?Object} event - original event
     * @param {Object} data - event data
     * @return {!{proceed: boolean, event: CustomEvent}}
     *     proceed is true if the default action has not been prevented, false otherwise
     *     event is the new event that was triggered
     *
     * @private
     */
    _triggerCustomEvent: function _triggerCustomEvent(type, event, data) {
      var eventName;
      var detail = {};
      var bubbles;
      var cancelable;

      var rootElement = this._getRootElement();

      if (type === 'optionChange') {
        var property = oj.CustomElementBridge.getPropertyForAlias(rootElement, data.option);

        if (!oj.CustomElementBridge.isKnownProperty(rootElement, property)) {
          return {
            proceed: true,
            event: null
          };
        }

        eventName = oj.__AttributeUtils.propertyNameToChangeEventType(property); // Copy over component specific optionChange event properties, promoting those exposed
        // in the optionMetadata to the top level alongside value/previousValue/subproperty.

        var keys = Object.keys(data);

        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];

          if (key !== 'option') {
            if (key === 'optionMetadata') {
              // Do not expose optionMetadata for custom element property change events
              // Instead, promote any component specific metadata to the top level.
              var metaKeys = Object.keys(data[key]);

              for (var j = 0; j < metaKeys.length; j++) {
                var metaKey = metaKeys[j];

                if (metaKey !== 'writeback' && metaKey !== 'component') {
                  detail[metaKey] = data[key][metaKey];
                }
              }
            } else {
              detail[key] = data[key];
            }
          }
        }
      } else {
        eventName = oj.__AttributeUtils.eventTriggerToEventType(type);

        if (!oj.CustomElementBridge.isKnownEvent(rootElement, eventName)) {
          return {
            proceed: true,
            event: null
          };
        }

        bubbles = true;
        cancelable = true;
        detail = this._resolveJQueryObjects(data);
      }

      if (event) {
        detail.originalEvent = event instanceof $.Event ? event.originalEvent : event;
      }

      var params = {
        detail: detail
      };

      if (bubbles) {
        params.bubbles = true;
      }

      if (cancelable) {
        params.cancelable = true;
      }

      var customEvent = new CustomEvent(eventName, params);
      rootElement.dispatchEvent(customEvent);
      return {
        proceed: !customEvent.defaultPrevented,
        event: customEvent
      };
    },

    /**
     * <p>Creates a shallow copy of the passed in object where any top-level JQuery objects have been resolved to their underlying objects.
     * @param {Object} data the original object
     * @return {Object} the resolved object copy
     *
     * @private
     */
    _resolveJQueryObjects: function _resolveJQueryObjects(data) {
      var resolved = oj.CollectionUtils.copyInto({}, data);
      var keys = Object.keys(resolved);

      for (var k = 0; k < keys.length; k++) {
        var key = keys[k];
        var val = resolved[key];

        if (val && val instanceof $) {
          if (val.length === 0) {
            resolved[key] = null;
          } else if (val.length === 1) {
            resolved[key] = val[0];
          } else {
            resolved = val.toArray();
          }
        }
      }

      return resolved;
    },

    /**
     * <p>Sets contextMenu option from DOM if option not set.
     *
     * <p>Do not override.  To be called only from _InitOptions().
     *
     * @memberof oj.baseComponent
     * @instance
     * @private
     * @final
     */
    _initContextMenuOption: function _initContextMenuOption(constructorOptions) {
      var contextMenu = this.element.attr('contextmenu');
      this._initialCmDomAttr = contextMenu; // TODO: remove this after the _RestoreAttributes() call in destroy() is uncommented

      if (contextMenu && !('contextMenu' in constructorOptions)) {
        // if app set DOM attr but not option, then set the option from the DOM
        this.option('contextMenu', document.getElementById(contextMenu), {
          _context: {
            internalSet: true
          }
        }); // writeback not needed since "not in constructorOptions" means "not bound"
      }
    },

    /**
     * Handler
     * @param {Element} contextMenu root element of context menu
     * @param {Event} event the dom event
     * @param {string} eventType the type of event
     * @private
     */
    _handleContextMenuGesture: function _handleContextMenuGesture(contextMenu, event, eventType) {
      // For components like Button where "effectively disabled" --> "not focusable", keyboard CM launch is impossible, so
      // allowing right-click access would be an a11y issue.  If there's ever a need to enable this for focusable effectively
      // disabled components, we can always replace the _IsEffectivelyDisabled() call with a new protected method whose
      // baseComponent impl returns _IsEffectivelyDisabled().
      if (this._IsEffectivelyDisabled()) {
        return;
      } // contextMenu should reference the latest one from the scope


      var menu;

      if (contextMenu.tagName === 'OJ-MENU') {
        menu = contextMenu;
      } else {
        var constructor = oj.Components.__GetWidgetConstructor(contextMenu, 'ojMenu');

        menu = constructor && constructor('instance');

        if (!menu) {
          throw new Error('Invalid JET Menu.'); // keeping old behavior
        }
      }

      this._NotifyContextMenuGesture(menu, event, eventType); // todo: modify NotifyContextMenuGesture contract so we don't need to check visible


      if ($(contextMenu).is(':visible')) {
        event.preventDefault(); // don't show native context menu
      }
    },

    /**
     * <p>Call this method from _SetupResources().  It sets up listeners needed to detect context menu gestures.
     *
     * <p>We don't look for the menu until context menu gesture has been detected on the first launch,
     * so that the menu needn't be inited before this component.
     *
     * <p>If needed, override <code class="prettyprint">_NotifyContextMenuGesture()</code>, not this private method.
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    _SetupContextMenu: function _SetupContextMenu() {
      var contextMenu = this._GetContextMenu();

      if (!contextMenu) {
        contextMenu = this._GetDefaultContextMenu();
      }

      if (contextMenu && this._contextMenuGestureInit === undefined) {
        this._contextMenuGestureInit = contextMenu;
        var self = this;
        oj.GestureUtils.startDetectContextMenuGesture(this.widget()[0], function (event, eventType) {
          self._handleContextMenuGesture(contextMenu, event, eventType);
        });
      }
    },

    /**
     * <p>This method removes contextMenu functionality from the component and specified menu.
     *
     * @memberof oj.baseComponent
     * @instance
     * @private
     */
    _ReleaseContextMenu: function _ReleaseContextMenu() {
      this._contextMenuGestureInit = undefined; // access menu elem directly, rather than using the widget() of the Menu component, so listener is cleared even if component no longer exists.
      // $(contextMenuOption).off( this.contextMenuEventNamespace );

      oj.GestureUtils.stopDetectContextMenuGesture(this.widget()[0]);
    },

    /**
     * Helper method to retrieve the context menu element
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    _GetContextMenu: function _GetContextMenu() {
      if (this._IsCustomElement()) {
        var slotMap = oj.BaseCustomElementBridge.getSlotMap(this._getRootElement());
        var slot = slotMap.contextMenu;

        if (slot && slot.length > 0) {
          return slot[0];
        }
      } else if (this.options.contextMenu) {
        return $(this.options.contextMenu).first()[0];
      }

      return null;
    },

    /**
     * <p>When the <a href="#contextMenu">contextMenu</a> option is set, this method is called when the user invokes the context menu via
     * the default gestures: right-click, <kbd>Press & Hold</kbd>, and <kbd>Shift-F10</kbd>.  Components should not call this method directly.
     *
     * <p>The default implementation simply calls <a href="#_OpenContextMenu">this._OpenContextMenu(event, eventType)</a>.
     * Overrides of this method should call that same method, perhaps with additional params, not [menu.open()]{@link oj.ojMenu#open}.
     *
     * <p>This method may be overridden by components needing to do things like the following:
     *
     * <ul>
     * <li>Customize the [launcher]{@link oj.ojMenu#openOptions.launcher} or [position]{@link oj.ojMenu#openOptions.position} passed to
     * <a href="#_OpenContextMenu">_OpenContextMenu()</a>.  See that method for guidance on these customizations.</li>
     *
     * <li>Customize the menu contents.  E.g. some components need to enable/disable built-in commands like <kbd>Cut</kbd> and <kbd>Paste</kbd>,
     * based on state at launch time.</li>
     *
     * <li>Bail out in some cases.  E.g. components with UX approval to use <kbd>PressHoldRelease</kbd> rather than <kbd>Press & Hold</kbd> can override this method
     * to say <code class="prettyprint">if (eventType !== "touch") this._OpenContextMenu(event, eventType);</code>.  When those components
     * detect the alternate context menu gesture (e.g. <kbd>PressHoldRelease</kbd>), that separate listener should call <a href="#_OpenContextMenu">this._OpenContextMenu()</a>,
     * not this method (<code class="prettyprint">_NotifyContextMenuGesture()</code>), and not [menu.open()]{@link oj.ojMenu#open}.  </li>
     * </ul>
     *
     * <p>Components needing to do per-launch setup like the above tasks should do so in an override of this method, <i>not</i> in
     * a [beforeOpen]{@link oj.ojMenu#event:beforeOpen} listener or an <a href="#_OpenContextMenu">_OpenContextMenu()</a> override.
     * This is discussed more fully <a href="#_OpenContextMenu">here</a>.
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     *
     * @param {!Object} menu The JET Menu to open as a context menu.  Always non-<code class="prettyprint">null</code>.
     * @param {!Event} event What triggered the menu launch.  Always non-<code class="prettyprint">null</code>.
     * @param {string} eventType "mouse", "touch", or "keyboard".  Never <code class="prettyprint">null</code>.
     */
    _NotifyContextMenuGesture: function _NotifyContextMenuGesture(menu, event, eventType) {
      this._OpenContextMenu(event, eventType);
    },

    /**
     * <p>The only correct way for a component to open its context menu is by calling this method, not by calling [Menu.open()]{@link oj.ojMenu#open} or
     * <a href="#_NotifyContextMenuGesture">_NotifyContextMenuGesture()</a>.  This method should be called in two cases:
     *
     * <ul>
     * <li>This method is called by <a href="#_NotifyContextMenuGesture">_NotifyContextMenuGesture()</a> and its overrides.  That method is
     * called when the baseComponent detects the default context menu gestures: right-click, <kbd>Press & Hold</kbd>, and <kbd>Shift-F10</kbd>.</li>
     *
     * <li>Components with UX-approved support for alternate context menu gestures like <kbd>PressHoldRelease</kbd> should call this method directly
     * when those gestures are detected.</li>
     * </ul>
     *
     * <p>Components needing to customize how the context menu is launched, or do any per-launch setup, should do so in the caller of this method,
     * (which is one of the two callers listed above), often by customizing the params passed to this method
     * (<code class="prettyprint">_OpenContextMenu</code>) per the guidance below.  This setup should <i>not</i> be done in the following ways:
     *
     * <ul>
     * <li>Components should not perform setup in a [beforeOpen]{@link oj.ojMenu#event:beforeOpen} listener, as this can cause a race
     * condition where behavior depends on who got their listener registered first: the component or the app.  The only correct component use
     * of a <code class="prettyprint">beforeOpen</code> listener is when there's a need to detect whether <i>something else</i> launched the menu.</li>
     *
     * <li>Components should not override this method (<code class="prettyprint">_OpenContextMenu</code>), as this method is final.  Instead, customize
     * the params that are passed to it.</li>
     * </ul>
     *
     * <p><b>Guidance on setting OpenOptions fields:</b>
     *
     * <p><b>Launcher:</b>
     *
     * <p>Depending on individual component needs, any focusable element within the component can be the appropriate
     * [launcher]{@link oj.ojMenu#openOptions.launcher} for this launch.
     *
     * <p>Browser focus returns to the launcher on menu dismissal, so the launcher must at least be focusable.  Typically a tabbable (not just
     * focusable) element is safer, since it just focuses something the user could have focused on their own.
     *
     * <p>By default (i.e. if <code class="prettyprint">openOptions</code> is not passed, or if it lacks a <code class="prettyprint">launcher</code>
     * field), the component init node is used as the launcher for this launch.  If that is not focusable or is suboptimal for a given
     * component, that component should pass something else.  E.g. components with a "roving tabstop" (like Toolbar) should typically choose the
     * current tabstop as their launcher.
     *
     * <p>The [:focusable]{@link http://api.jqueryui.com/focusable-selector/} and [:tabbable]{@link http://api.jqueryui.com/tabbable-selector/} selectors
     * may come in handy for choosing a launcher, e.g. something like <code class="prettyprint">this.widget().find(".my-class:tabbable").first()</code>.
     *
     * <p><b>Position:</b>
     *
     * <p>By default, this method applies [positioning]{@link oj.ojMenu#openOptions.position} that differs from Menu's default in the following ways:
     * (The specific settings are subject to change.)
     *
     * <ul>
     * <li>For mouse and touch events, the menu is positioned relative to the event, not the launcher.</li>
     *
     * <li>For touch events, <code class="prettyprint">"my"</code> is set to <code class="prettyprint">"start>40 center"</code>,
     * to avoid having the context menu obscured by the user's finger.</li>
     * </ul>
     *
     * <p>Usually, if <code class="prettyprint">position</code> needs to be customized at all, the only thing that needs changing is its
     * <code class="prettyprint">"of"</code> field, and only for keyboard launches (since mouse/touch launches should almost certainly keep
     * the default <code class="prettyprint">"event"</code> positioning).  This situation arises anytime the element relative to which the menu
     * should be positioned for keyboard launches is different than the <code class="prettyprint">launcher</code> element (the element to which
     * focus should be returned upon dismissal).  For this case, <code class="prettyprint">{ "position": {"of": eventType==="keyboard" ? someElement : "event"} }</code>
     * can be passed as the <code class="prettyprint">openOptions</code> param.
     *
     * <p>Be careful not to clobber useful defaults by specifying too much.  E.g. if you only want to customize <code class="prettyprint">"of"</code>,
     * don't pass other fields like <code class="prettyprint">"my"</code>, since your value will be used for all modalities (mouse, touch, keyboard),
     * replacing the modality-specific defaults that are usually correct.  Likewise, don't forget the
     * <code class="prettyprint">eventType==="keyboard"</code> check if you only want to customize <code class="prettyprint">"of"</code> for keyboard launches.
     *
     * <p><b>InitialFocus:</b>
     *
     * <p>This method forces [initialFocus]{@link oj.ojMenu#openOptions.initialFocus} to <code class="prettyprint">"menu"</code> for this
     * launch, so the caller needn't specify it.
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     * @final
     *
     * @param {!Event} event What triggered the context menu launch.  Must be non-<code class="prettyprint">null</code>.
     * @param {string} eventType "mouse", "touch", or "keyboard".  Must be non-<code class="prettyprint">null</code>.  Passed explicitly since caller
     *        knows what it's listening for, and since events like <code class="prettyprint">contextmenu</code> and
     *        <code class="prettyprint">click</code> can be generated by various input modalities, making it potentially error-prone for
     *        this method to determine how they were generated.
     * @param {Object=} openOptions Options to merge with this method's defaults, which are discussed above.  The result will be passed to
     *        [Menu.open()]{@link oj.ojMenu#open}.  May be <code class="prettyprint">null</code> or omitted.  See also the
     *        <code class="prettyprint">shallow</code> param.
     * @param {Object=} submenuOpenOptions Options to be passed through to [Menu.open()]{@link oj.ojMenu#open}.  May be <code class="prettyprint">null</code>
     *        or omitted.
     * @param {boolean=} shallow Whether to perform a deep or shallow merge of <code class="prettyprint">openOptions</code> with this method's default
     *        value.  The default and most commonly correct / useful value is <code class="prettyprint">false</code>.
     *
     *        <ul>
     *        <li>If <code class="prettyprint">true</code>, a shallow merge is performed, meaning that the caller's <code class="prettyprint">position</code>
     *        object, if passed, will completely replace this method's default <code class="prettyprint">position</code> object.</li>
     *
     *        <li>If <code class="prettyprint">false</code> or omitted, a deep merge is performed.  For example, if the caller wishes to tweak
     *        <code class="prettyprint">position.of</code> while keeping this method's defaults for <code class="prettyprint">position.my</code>,
     *        <code class="prettyprint">position.at</code>, etc., it can pass <code class="prettyprint">{"of": anOfValue}</code> as the
     *        <code class="prettyprint">position</code> value.</li>
     *        </ul>
     *
     *        <p>The <code class="prettyprint">shallow</code> param is n/a for <code class="prettyprint">submenuOpenOptions</code>, since this method doesn't
     *        apply any defaults to that.  (It's a direct pass-through.)
     */
    _OpenContextMenu: function _OpenContextMenu(event, eventType, openOptions, submenuOpenOptions, shallow) {
      var contextMenuNode = this._GetContextMenu();

      if (!contextMenuNode) {
        // the context menu node could have been currently opened with another launcher
        if (this._contextMenuGestureInit && $(this._contextMenuGestureInit).is(':visible')) {
          contextMenuNode = this._contextMenuGestureInit;
        } else {
          contextMenuNode = this._GetDefaultContextMenu();
        }
      }

      if (contextMenuNode) {
        // Note: our touch positioning is similar to that of the iOS touch callout (bubble with "Open in New Tab", etc.), which is offset from the pressHold location as follows:
        // - to the right, vertically centered.  (by default)
        // - to the left, vertically centered.  (if fits better)
        // - above or below, horizontally centered.  (if fits better)
        // An offset like 40 prevents it from opening right under your finger, and is similar to iOS's offset.  It also prevents the issue (on iOS7 at least)
        // where touchend after the pressHold can dismiss the CM b/c the menu gets the touchend.
        var position = {
          mouse: {
            my: 'start top',
            at: 'start bottom',
            of: event,
            collision: 'flipfit'
          },
          touch: {
            my: 'start>40 center',
            at: 'start bottom',
            of: event,
            collision: 'flipfit'
          },
          keyboard: {
            my: 'start top',
            at: 'start bottom',
            of: 'launcher',
            collision: 'flipfit'
          }
        };
        var defaults = {
          launcher: this.element,
          position: position[eventType]
        }; // used for fields caller omitted

        var forcedOptions = {
          initialFocus: 'menu'
        };
        var mergedOpenOptions = shallow ? $.extend(defaults, openOptions, forcedOptions) : $.extend(true, defaults, openOptions, forcedOptions);
        contextMenuNode.__openingContextMenu = true; // Hack.  See todo on this ivar in Menu.open().

        if (contextMenuNode.tagName === 'OJ-MENU') {
          contextMenuNode.open(event, mergedOpenOptions, submenuOpenOptions);
        } else {
          var constructor = oj.Components.__GetWidgetConstructor(contextMenuNode, 'ojMenu');

          var menu = constructor && constructor('instance');
          menu.open(event, mergedOpenOptions, submenuOpenOptions); // Open is immediate for jquery UI menus.
          // Win FF will fire a contextmenu event on shift+F10 long after the keypress was prevented.
          // jquery ui needs immediate focus to the menu on open. The contextmenu event is fired on
          // the menu versus the launcher. This logic prevents the context menu event within a 50ms
          // window after the menu is open.

          var eatEventHandler = function eatEventHandler(e) {
            e.preventDefault();
          };

          contextMenuNode.addEventListener('contextmenu', eatEventHandler);
          window.setTimeout(function () {
            contextMenuNode.removeEventListener('contextmenu', eatEventHandler);
          }, 50);
        }

        contextMenuNode.__openingContextMenu = false;
      }
    },

    /**
     * Retrieve the default context menu.
     * @return {Element|null} the root element for the default context menu, or null if there is no default context menu.  The default is null.
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    _GetDefaultContextMenu: function _GetDefaultContextMenu() {
      return null;
    },

    /**
     * <p>Removes the <code class="prettyprint">oj-hover</code>, <code class="prettyprint">oj-focus</code>,
     * <code class="prettyprint">oj-focus-highlight</code>, and
     * <code class="prettyprint">oj-active</code> classes from the specified element and its subtree.
     *
     * @memberof oj.baseComponent
     * @instance
     * @private
     *
     * @param {!jQuery} element The element from whose subtree the 3 classes should be removed
     */
    _removeStateClasses: function _removeStateClasses(element) {
      element.removeClass('oj-hover oj-focus oj-focus-highlight oj-active');
      element.find('.oj-hover').removeClass('oj-hover');
      element.find('.oj-focus').removeClass('oj-focus');
      element.find('.oj-focus-highlight').removeClass('oj-focus-highlight');
      element.find('.oj-active').removeClass('oj-active');
    },

    /**
     * @private
     * @return {boolean} true if there is no touch detected within the last 500 ms
     */
    _isRealMouseEvent: function _isRealMouseEvent() {
      return !oj.DomUtils.recentTouchEnd();
    },

    /**
     * Add mouse listners to toggle oj-hover class
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
       * @param {(!Object|!jQuery)} options This param can either be the element
     * (convenience syntax for callers needing to
     *   specify only the element(s) that would
     *   otherwise have been passed as <code class="prettyprint">options.element</code>)
     *   or an object supporting the following fields:
     * @param {jQuery} options.element The element(s) to receive the <code class="prettyprint">oj-hover</code> class on hover
     *   Required if <code class="prettyprint">afterToggle</code> is specified.
     * @param {?function(string)} options.afterToggle Optional callback function called each time the hover classes have been toggled,
     *   after the toggle.  The string "mouseenter" or "mouseleave" is passed, indicating whether the classes were added or removed.
     *   Components with consistency requirements, such as "<code class="prettyprint">oj-default</code> must be applied iff no state classes
     *   such as <code class="prettyprint">oj-hover</code> are applied," can enforce those rules in this callback.
     * @see #_RemoveHoverable
     */
    _AddHoverable: function _AddHoverable(options) {
      var element;

      if ($.isPlainObject(options)) {
        element = options.element;
      } else {
        element = options; // eslint-disable-next-line no-param-reassign

        options = {};
      }

      var afterToggle = options.afterToggle || $.noop;
      var markerClass = 'oj-hover';
      element.on('mouseenter' + this.hoverableEventNamespace, this._hoverStartHandler.bind(this, afterToggle)).on('mouseleave' + this.hoverableEventNamespace, this._hoverAndActiveEndHandler.bind(this, markerClass, afterToggle));
    },

    /**
     * Remove mouse listners that were registered in _AddHoverable
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     * @param {!jQuery} element The same element passed to _AddHoverable
     * @see #_AddHoverable
     */
    _RemoveHoverable: function _RemoveHoverable(element) {
      if (element) {
        element.off(this.hoverableEventNamespace);
      }
    },

    /**
     * Add touch and mouse listeners to toggle oj-active class
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
       * @param {(!Object|!jQuery)} options This parameter can either be the element
     * (convenience syntax for callers needing to
     *   specify only the element(s) that would
     *   otherwise have been passed as <code class="prettyprint">options.element</code>)
     *   or an object supporting the following fields:
     * @param {jQuery} options.element The element(s) to receive the
     * <code class="prettyprint">oj-active</code> class on active
     *   Required if <code class="prettyprint">afterToggle</code> is specified.
     * @param {?function(string)} options.afterToggle Optional callback function called each time
     *   the active classes have been toggled, after the toggle.  The event.type string is passed
     *   and indicates whether the classes were added or removed. The active classes are added on
     *   "touchstart" or "mousedown" or "mouseenter" and the active classes are removed on
     *   "touchend" or "touchcancel" or "mouseup" or "mouseleave".
     *   Components with consistency requirements, such as
     *   "<code class="prettyprint">oj-default</code> must be applied iff no state classes
     *   such as <code class="prettyprint">oj-active</code> are applied,"
     *   can enforce those rules in this callback.
     * @see #_RemoveActiveable
     */
    _AddActiveable: function _AddActiveable(options) {
      var element;

      if ($.isPlainObject(options)) {
        element = options.element;
      } else {
        element = options; // eslint-disable-next-line no-param-reassign

        options = {};
      }

      var afterToggle = options.afterToggle || $.noop;
      var markerClass = 'oj-active';

      if (oj.DomUtils.isTouchSupported()) {
        // make sure native element exists
        if (element[0]) {
          // register touchstart with passive option
          this._touchstartListener = this._activeStartHandler.bind(this, afterToggle);
          element[0].addEventListener('touchstart', this._touchstartListener, {
            passive: true
          });
        }

        element.on('touchend' + this.activeableEventNamespace + ' ' + 'touchcancel' + this.activeableEventNamespace, this._hoverAndActiveEndHandler.bind(this, markerClass, afterToggle));
      }

      element.on('mousedown' + this.activeableEventNamespace, this._activeStartHandler.bind(this, afterToggle)).on('mouseup' + this.activeableEventNamespace, this._hoverAndActiveEndHandler.bind(this, markerClass, afterToggle)) // mouseenter/mouseleave is for the case where you mousedown, then move mouse
      // out of element, then move mouse back. We want oj-active to disappear when you move
      // outside and reappear when you move back.
      .on('mouseenter' + this.activeableEventNamespace, this._activeStartHandler.bind(this, afterToggle)).on('mouseleave' + this.activeableEventNamespace, this._hoverAndActiveEndHandler.bind(this, markerClass, afterToggle));
    },

    /**
     * Remove touch and mouse listeners that were registered in _AddActiveable
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     * @param {!jQuery} element The same element passed to _AddActiveable
     * @see #_AddActiveable
     */
    _RemoveActiveable: function _RemoveActiveable(element) {
      if (element) {
        // make sure native element exists
        if (element[0]) {
          // remove touchstart registered with passive option
          element[0].removeEventListener('touchstart', this._touchstartListener, {
            passive: true
          });
          delete this._touchstartListener;
        }

        element.off(this.activeableEventNamespace);
        _lastActiveElement = null;
      }
    },

    /**
     * Add oj-active style class and call the afterToggleFunction.
     * Set _lastActiveElement to event.currentTarget on mousedown. Clear it on mouseup.
     * _lastActiveElement is used to remove and add back oj-active on mouseleave and mouseenter
     * if the mouse stays down.
     * @private
     */
    _activeStartHandler: function _activeStartHandler(afterToggleFunction, event) {
      var elem = $(event.currentTarget); // do nothing on mouseenter if _lastActiveElement ivar is not the currentTarget or child of
      // currentTarget. Checking for the child is needed in case there are two nested
      // dom nodes that have set_AddActiveable. Since events bubble, the _lastActiveElement will
      // be the outermost dom that got the mousedown event.

      if (event.type === 'mouseenter' && !this._isTargetInActiveElement(event.currentTarget)) {
        return;
      } // do this for either touchstart or real mouse events, but not mouse compatibility event


      if (!elem.hasClass('oj-disabled') && (event.type === 'touchstart' || this._isRealMouseEvent(event))) {
        elem.addClass('oj-active');
        afterToggleFunction(event.type); // If we get mousedown on the element, we want oj-active to be removed on mouseleave
        // and added back on mouseenter if the mouse stays down.

        if (event.type === 'mousedown') {
          _lastActiveElement = event.currentTarget;
          this.document.one('mouseup', function () {
            _lastActiveElement = null;
          });
        }
      }
    },

    /**
     * @private
     */
    _hoverStartHandler: function _hoverStartHandler(afterToggleFunction, event) {
      // do this for real mouseenter, but not mouse compatibility event
      var elem = $(event.currentTarget);

      if (!elem.hasClass('oj-disabled') && this._isRealMouseEvent(event)) {
        elem.addClass('oj-hover');
        afterToggleFunction(event.type);
      }
    },

    /**
     * Remove markerClass and call the afterToggleFunction.
     * @private
     */
    _hoverAndActiveEndHandler: function _hoverAndActiveEndHandler(markerClass, afterToggleFunction, event) {
      // for oj-active we don't care about mouseleave unless it was triggered when _lastActiveElement
      // was set on the currentTarget. (see _activeStartHandler). If that's not the case, return.
      if (markerClass === 'oj-active' && event.type === 'mouseleave' && !this._isTargetInActiveElement(event.currentTarget)) {
        return;
      }

      $(event.currentTarget).removeClass(markerClass);
      afterToggleFunction(event.type);
    },

    /**
     * Returns true if the event target is _lastActiveElement or a child of _lastActiveElement.
     * Checking for the child is needed in case there are two nested dom nodes that have set
     * _AddActiveable. For example, inputDateTime -> the trigger root container and the trigger icon.
     * We are only keeping track of the _lastActiveElement, which means the ancestor element will
     * be stored in _lastActiveElement because the mouseleave event bubbles.
     * @private
     */
    _isTargetInActiveElement: function _isTargetInActiveElement(currentTarget) {
      return _lastActiveElement === currentTarget || _lastActiveElement != null && $.contains(_lastActiveElement, currentTarget);
    },
    // We no longer use _hoverable, but should still override it to ensure the JQUI impl is not called.
    _hoverable: function _hoverable() {},
    // The internal JSDoc of the DomUtils version of this API refers to this doc, so if changes are made here, that doc
    // must be updated as needed.

    /**
     * <p>Sets JET's "focus" CSS classes when the element is focused and removes them when focus is lost.
     *
     * <p>The <code class="prettyprint">oj-focus</code> class is set on all focuses.
     *
     * <p>Some components additionally have an <code class="prettyprint">oj-focus-highlight</code> class, which applies a focus
     * indicator that is appropriate on a subset of the occasions that <code class="prettyprint">oj-focus</code> is appropriate.
     * Those components should pass <code class="prettyprint">true</code> for the <code class="prettyprint">applyHighlight</code>
     * param, in which case the <code class="prettyprint">oj-focus-highlight</code> class is set if appropriate given the
     * current focus highlight policy.
     *
     * <h5>Focus highlight policy</h5>
     *
     * <p>The focus highlight policy supports the 3 values listed below.  By default, it is retrieved from the
     * <code class="prettyprint">$focusHighlightPolicy</code> SASS variable, shared by many components and patterns.  Components
     * with different needs, including those exposing a component-specific SASS variable or other API for this, should see the
     * <code class="prettyprint">getFocusHighlightPolicy</code> parameter below.
     *
     * Valid focus highlight policies:
     *
     * <table class="generic-table">
     *   <thead>
     *     <tr>
     *       <th>Policy</th>
     *       <th>Description</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>"nonPointer"</td>
     *       <td>Indicates that the component should apply the <code class="prettyprint">oj-focus-highlight</code>
     *           class only for focuses not resulting from pointer (touch or mouse) interaction.  (In the built-in themes, the
     *           SASS variable defaults to this value.)</td>
     *     </tr>
     *     <tr>
     *       <td>"all"</td>
     *       <td>Indicates that the component should apply the class for all focuses.</td>
     *     </tr>
     *     <tr>
     *       <td>"none"</td>
     *       <td>Indicates that the component should never apply the class, because the application has taken responsibility
     *           for applying the class when needed for accessibility.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h5>Toggling the classes</h5>
     *
     * <p>Components that toggle these focus classes outside of this API must maintain the invariant that
     * <code class="prettyprint">oj-focus-highlight</code> is applied to a given element in a (not necessarily strict) subset
     * of cases that <code class="prettyprint">oj-focus</code> is applied to that element.
     *
     * <p>Typically the specified element should be within the component subtree, in which case the classes will
     * automatically be removed from the element when the component is destroyed, when its <code class="prettyprint">disabled</code>
     * option is set to true, and when <code class="prettyprint">_NotifyDetached()</code> is called.
     *
     * <p>As a minor exception, for components that wrap themselves in a new root node at create time, if the specified
     * element is within the root node's subtree but not within the init node's subtree, then at destroy time only, the
     * classes will not be removed, since <code class="prettyprint">destroy()</code> is expected to remove such nodes.
     *
     * <p>If the element is NOT in the component subtree, then the caller is responsible for removing the classes at the
     * times listed above.
     *
     * <h5>Listeners</h5>
     *
     * <p>If <code class="prettyprint">setupHandlers</code> is not passed, or if <code class="prettyprint">setupHandlers</code>
     * is passed and uses <code class="prettyprint">_on</code> to register its listeners as seen in the example, then
     * the listeners are not invoked when the component is disabled, and the listeners are automatically cleaned up when the
     * component is destroyed.  Otherwise, the caller is responsible for ensuring that the disabled state is handled correctly,
     * and removing the listeners at destroy time.
     *
     * <h5>Related API's</h5>
     *
     * <p>Non-component internal callers should see oj.DomUtils.makeFocusable().  Per its JSDoc (unpublished; see the source), it
     * has a couple of additional usage considerations.
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     *
     * @param {(!Object|!jQuery)} options This param can either be the element (convenience syntax for callers needing to
     *   specify only the element(s) that would otherwise have been passed as <code class="prettyprint">options.element</code>)
     *   or an object supporting the following fields:
     * @param {jQuery} options.element The element(s) to receive the <code class="prettyprint">oj-focus</code> classes on focus.
     *   Required if <code class="prettyprint">setupHandlers</code> not passed; ignored otherwise.
     * @param {boolean} options.applyHighlight <code class="prettyprint">true</code> if the <code class="prettyprint">oj-focus-highlight</code>
     *   class should be applied when appropriate.  <code class="prettyprint">false</code> or omitted if that class should never be applied.
     * @param {?function(string)} options.afterToggle Optional callback function called each time the focus classes have been toggled,
     *   after the toggle.  The
     *   string "focusin" or "focusout" is passed, indicating whether the classes were added or removed.  Components
     *   with consistency requirements, such as "<code class="prettyprint">oj-default</code> must be applied iff no state classes such
     *   as <code class="prettyprint">oj-focus</code> are applied," can enforce those rules in this callback.
     * @param {?function()} options.getFocusHighlightPolicy Optional if <code class="prettyprint">applyHighlight</code> is
     *   <code class="prettyprint">true</code>; ignored otherwise.  Components with a component-specific focus policy
     *   mechanism should pass a function that always returns one of the three valid values listed above, keeping in mind
     *   that this method can be called on every focus.  See the example.
     * @param {?function()} options.recentPointer Relevant iff <code class="prettyprint">applyHighlight</code> is
     *   <code class="prettyprint">true</code> and the focus highlight policy is <code class="prettyprint">"nonPointer"</code>;
     *   ignored otherwise.  Recent pointer activity is considered to have occurred if (a) a mouse button or finger has
     *   recently been down or up, or (b) this optional callback function returns true.  Components wishing to additionally take into
     *   account (say) recent pointer <i>movements</i> can supply a function returning true if those movements have been detected,
     *   keeping in mind that this method can be called on every focus.  See the example.
     * @param {?function(function(!jQuery),function(!jQuery))} options.setupHandlers Can be omitted by components whose focus
     *   classes need to be added and removed on focusin and focusout, respectively.  Components needing to add/remove those
     *   classes in response to other events should specify this parameter, which is called once, immediately.  See the examples.
     *
     * @example <caption>Opt into the highlight behavior, and specify a function to be called every time the classes are toggled:</caption>
     * var self = this;
     * this._focusable({
     *     'element': this.element,
     *     'applyHighlight': true,
     *     'afterToggle' : function() {
     *         self._toggleDefaultClasses();
     *     }
     * });
     *
     * @example <caption>Arrange for mouse movement to be considered <u>in addition to</u> mouse/finger up/down.
     *   Also supply a component-specific focusHighlightPolicy:</caption>
     * var self = this;
     * this._focusable({
     *     'element': someElement,
     *     'applyHighlight': true,
     *     'recentPointer' : function() {
     *         // A timestamp-based approach avoids the risk of getting stuck in an inaccessible
     *         // state if (say) mouseenter is not followed by mouseleave for some reason.
     *         var millisSincePointerMove = Date.now() - _myPointerMoveTimestamp;
     *         var isRecent = millisSincePointerMove < myThreshold;
     *         return isRecent;
     *     },
     *     'getFocusHighlightPolicy' : function() {
     *         // Return the value of a component-specific SASS $variable, component option, or other
     *         // component-specific mechanism, either "all", "none", or "nonPointer".  SASS variables
     *         // should be pulled into JS once statically on load, not per-instance or per-focus.
     *     }
     * });
     *
     * @example <caption>Add/remove the focus classes in response to events other than focusin/focusout:</caption>
     * var self = this;
     * this._focusable({
     *     'applyHighlight': myBooleanValue,
     *     'setupHandlers': function( focusInHandler, focusOutHandler) {
     *         self._on( self.element, {
     *             // This example uses focus/blur listeners, which don't bubble, rather than the
     *             // default focusin/focusout (which bubble).  This is useful when one focusable
     *             // element is a descendant of another.
     *             focus: function( event ) {
     *                 focusInHandler($( event.currentTarget ));
     *             },
     *             blur: function( event ) {
     *                 focusOutHandler($( event.currentTarget ));
     *             }
     *         });
     *     }
     * });
     *
     * @example <caption>Alternate usage of <code class="prettyprint">setupHandlers</code>, which simply stashes the
     *   handlers so they can be called from the component's existing handlers:</caption>
     * var self = this;
     * this._focusable({
     *     'applyHighlight': myBooleanValue,
     *     'setupHandlers': function( focusInHandler, focusOutHandler) {
     *         self._focusInHandler = focusInHandler;
     *         self._focusOutHandler = focusOutHandler;
     *     }
     * });
     */
    _focusable: function _focusable(options) {
      if (!$.isPlainObject(options)) {
        // eslint-disable-next-line no-param-reassign
        options = {
          element: options
        };
      } // eslint-disable-next-line no-param-reassign


      options.component = this;
      oj.DomUtils.makeFocusable(options);
    },

    /**
     * Remove all listener references that were attached to the element.
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    _UnregisterChildNode: function _UnregisterChildNode(element) {
      if (element) {
        $(element).off(this.eventNamespace);
        var bindings = this.bindings;

        if (bindings) {
          this.bindings = $(bindings.not(element));
        }
      }
    },

    /**
     * <p>Determines whether the component is LTR or RTL.
     *
     * <p>Component responsibilities:
     *
     * <ul>
     * <li>All components must determine directionality exclusively by calling this protected superclass method.
     *     (So that any future updates to the logic can be made in this one place.)</li>
     * <li>Components that need to know the directionality must call this method at create-time
     *     and from <code class="prettyprint">refresh()</code>, and cache the value.
     * <li>Components should not call this at other times, and should instead use the cached value.  (This avoids constant DOM
     *     queries, and avoids any future issues with component reparenting (i.e. popups) if support for directional islands is added.)</li>
     * </ul>
     *
     * <p>App responsibilities:
     *
     * <ul>
     * <li>The app specifies directionality by setting the HTML <code class="prettyprint">"dir"</code> attribute on the
     *     <code class="prettyprint">&lt;html></code> node.  When omitted, the default is <code class="prettyprint">"ltr"</code>.
     *     (Per-component directionality / directional islands are not currently supported due to inadequate CSS support.)</li>
     * <li>As with any DOM change, the app must <code class="prettyprint">refresh()</code> the component if the directionality changes dynamically.
     *   (This provides a hook for component housekeeping, and allows caching.)</li>
     * </ul>
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     * @return {string} the reading direction, either <code class="prettyprint">"ltr"</code> or <code class="prettyprint">"rtl"</code>
     * @default <code class="prettyprint">"ltr"</code>
     */
    _GetReadingDirection: function _GetReadingDirection() {
      return oj.DomUtils.getReadingDirection();
    },

    /**
     * <p>Notifies the component that its subtree has been connected to the document programmatically after the component has
     * been created.
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    _NotifyAttached: function _NotifyAttached() {
      this._propertyContext = null;
    },

    /**
     * <p>Notifies the component that its subtree has been removed from the document programmatically after the component has
     * been created.
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    _NotifyDetached: function _NotifyDetached() {
      this._propertyContext = null;

      this._removeStateClasses(this.widget());
    },

    /**
     * <p>Notifies the component that its subtree is initially visible after the component has
     * been created.
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    _NotifyInitShown: function _NotifyInitShown() {},

    /**
     * <p>Notifies the component that its subtree has been made visible programmatically after the component has
     * been created.
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    _NotifyShown: function _NotifyShown() {},

    /**
     * <p>Notifies the component that its subtree has been made hidden programmatically after the component has
     * been created.
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    _NotifyHidden: function _NotifyHidden() {},

    /**
     * <p>Determines whether this component is effectively disabled, i.e. it has its 'disabled' attribute set to true
     * or it has been disabled by its ancestor component.
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     * @return {boolean} true if the component has been effectively disabled, false otherwise
     */
    _IsEffectivelyDisabled: function _IsEffectivelyDisabled() {
      return !!(this.options.disabled || this._ancestorDisabled);
    },

    /**
     * <p>Sets the ancestor-provided disabled state on this component.
     *
     * @memberof oj.baseComponent
     * @instance
     * @private
     * @param {boolean} disabled - true if this component is being disabled by its ancestor component, false otherwise
     */
    __setAncestorComponentDisabled: function __setAncestorComponentDisabled(disabled) {
      this._ancestorDisabled = disabled;
    },

    /**
     * @memberof oj.baseComponent
     * @instance
     * @private
     */
    _getTranslationSectionLoader: function _getTranslationSectionLoader() {
      var sectionNames = [];
      var self = this;
      var index = 0;

      this._traverseWidgetHierarchy(function (proto) {
        // retrive translation section name for the widget and all of its ancestors
        // Since _GetTranslationsSectionName() is a protected method, we can only call it on the widget instance.
        // For superclases, we will assume that their section names can only be their full widget name
        var name = index === 0 ? self._GetTranslationsSectionName() : proto.widgetFullName;
        index += 1;
        var section = Translations.getComponentTranslations(name);

        if (section != null && !$.isEmptyObject(section)) {
          sectionNames.push(name);
        }
      });

      var count = sectionNames.length;

      if (count > 0) {
        return function () {
          // Optimize for the most common case where superclasses do not define translations
          if (count === 1) {
            return Translations.getComponentTranslations(sectionNames[0]);
          }

          var trs = {};

          for (var i = count - 1; i >= 0; i--) {
            $.widget.extend(trs, Translations.getComponentTranslations(sectionNames[i]));
          }

          return trs;
        };
      }

      return null;
    },

    /**
     * @memberof oj.baseComponent
     * @instance
     * @private
     */
    _getDynamicPropertyContext: function _getDynamicPropertyContext() {
      if (!this._propertyContext) {
        var c = {};
        this._propertyContext = c;
        var element = this.element[0];
        c.containers = _getSpecialContainerNames(element);
        c.element = element;
        c.isCustomElement = this._IsCustomElement();
        if (c.isCustomElement) c.customElement = this._getRootElement();
      }

      return this._propertyContext;
    },

    /**
     * @memberof oj.baseComponent
     * @instance
     * @private
     */
    _setupDefaultOptions: function _setupDefaultOptions(originalDefaults, constructorOptions) {
      var options = this.options; // Load component translations

      var translationLoader = this._getTranslationSectionLoader();

      var currVal = constructorOptions[_OJ_TRANSLATIONS_OPTION];

      if (translationLoader != null && (currVal === undefined || $.isPlainObject(currVal))) {
        _defineDynamicProperty(this, undefined, constructorOptions[_OJ_TRANSLATIONS_OPTION], options, _OJ_TRANSLATIONS_OPTION, translationLoader);
      } // Load options specified with oj.Components.setDefaultOptions()


      this._loadGlobalDefaultOptions(originalDefaults, constructorOptions);
    },

    /**
     * @memberof oj.baseComponent
     * @instance
     * @private
     */
    _loadGlobalDefaultOptions: function _loadGlobalDefaultOptions(originalDefaults, constructorOptions) {
      var options = this.options;
      var widgetHierNames = []; // walk up the widget hierarchy

      this._traverseWidgetHierarchy(function (proto) {
        widgetHierNames.push(proto.widgetName);
      });

      widgetHierNames.push('default'); // get properties applicable to this component

      var defaults = oj.Components.__getDefaultOptions(widgetHierNames);

      if ($.isEmptyObject(defaults)) {
        return;
      }

      var self = this;

      var contextCallback = function contextCallback() {
        return self._getDynamicPropertyContext();
      };

      var props = Object.keys(defaults);

      for (var i = 0; i < props.length; i++) {
        var prop = props[i];
        var val = constructorOptions[prop];

        if (val === undefined || $.isPlainObject(val)) {
          var defaultValueList = defaults[prop];

          if (defaultValueList) {
            var callback = _getCompoundDynamicGetter(defaultValueList);

            if (callback) {
              _defineDynamicProperty(this, originalDefaults[prop], val, options, prop, callback, contextCallback);
            } else {
              var list = [originalDefaults[prop]].concat(defaultValueList);
              list.push(val);
              options[prop] = _mergeOptionLayers(list);
            }
          }
        }
      }
    },

    /**
     * @memberof oj.baseComponent
     * @instance
     * @private
     */
    _traverseWidgetHierarchy: function _traverseWidgetHierarchy(callback) {
      var proto = this.constructor.prototype;

      while (proto != null && proto.namespace === 'oj') {
        callback(proto);
        proto = Object.getPrototypeOf(proto);
      }
    },

    /**
     * @memberof oj.baseComponent
     * @instance
     * @private
     */
    _getRootElement: function _getRootElement() {
      return this.OuterWrapper || this.element[0];
    },

    /**
     * Determines whether the component is being rendered as a custom element.
     * @return {boolean} True if the component is being rendered as a custom element
     *
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    _IsCustomElement: function _IsCustomElement() {
      return oj.BaseCustomElementBridge.getRegistered(this._getRootElement().tagName) != null;
    },

    /**
     * Prepares a custom renderer context object for either the JQuery or custom element syntax,
     * removing and exposing keys as needed.
     * @param {Object} context The renderer context object.
     * @return {Object} The cleaned up renderer context.
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    _FixRendererContext: function _FixRendererContext(context) {
      if (this._IsCustomElement()) {
        // Do a shallow copy to avoid setter/getters from being lost
        var contextCopy = oj.CollectionUtils.copyInto({}, context); // remove component or widget constructor references and expose element reference instead

        delete contextCopy.component;
        contextCopy.componentElement = this._getRootElement();
        return contextCopy;
      }

      return context;
    },

    /**
     * Returns a wrapper function for custom elements that converts an object
     * returned by a custom renderer into an old format supported by widgets
     * @param {Function} origRenderer Renderer function called to create custom content
     * @return {Function} A wrapper function that will used to convert result into toolkit format
     * @protected
     * @memberof oj.baseComponent
     */
    _WrapCustomElementRenderer: function _WrapCustomElementRenderer(origRenderer) {
      if (this._IsCustomElement() && typeof origRenderer === 'function') {
        var customRenderer = function customRenderer(context) {
          var obj = origRenderer(context);
          return obj && obj.insert ? obj.insert : null;
        };

        return customRenderer;
      }

      return origRenderer;
    },

    /**
     * Stores a map of writeback options that we reference during option comparison.
     * Package private method called from the CustomElementBridge.
     * @param  {Object} options The writeback options map
     * @memberof oj.baseComponent
     * @instance
     * @private
     */
    __saveWritebackOptions: function __saveWritebackOptions(options) {
      this._writebackOptions = options;
    },

    /**
     * Returns true if an option should be written back.
     * @param  {string} option The option to lookup
     * @memberof oj.baseComponent
     * @instance
     * @private
     */
    _getWritebackOption: function _getWritebackOption(option) {
      if (this._writebackOptions && this._writebackOptions[option]) {
        return true;
      }

      return false;
    },

    /**
     * Called by oj.Components.subtreeAttached and will only call _NotifyAttached
     * for non custom elements. Custom elements are notified when they are
     * attached from the DOM so oj.Components.subtreeAttached is unnecessary.
     * @memberof oj.baseComponent
     * @instance
     * @private
     */
    __handleSubtreeAttached: function __handleSubtreeAttached() {
      if (!this._IsCustomElement()) {
        this._NotifyAttached();
      }
    },

    /**
     * Called by oj.Components.subtreeAttached and will only call _NotifyDetached
     * for non custom elements. Custom elements are notified when they are
     * detached from the DOM so oj.Components.subtreeDetached is unnecessary.
     * @memberof oj.baseComponent
     * @instance
     * @private
     */
    __handleSubtreeDetached: function __handleSubtreeDetached() {
      if (!this._IsCustomElement()) {
        this._NotifyDetached();
      }
    },

    /**
     * Whether special handling is needed for connected and disconnected ops
     * @return {boolean} returns true if the component wants to suppress disconnect and connect operations that happened
     *                   in quick succession, since they can be very expensive.  Returns false otherwise, which is the default.
     * @memberof oj.baseComponent
     * @protected
     */
    _VerifyConnectedForSetup: function _VerifyConnectedForSetup() {
      return false;
    },

    /**
     * Called by the CustomElementBridge when the custom element is attached
     * to the DOM.
     * @memberof oj.baseComponent
     * @instance
     * @private
     */
    __handleConnected: function __handleConnected() {
      this._NotifyAttached();

      if (!this.__delayConnectDisconnect(_STATE_CONNECTED)) {
        this._SetupResources();
      }
    },

    /**
     * Called by the CustomElementBridge when the custom element is detached
     * from the DOM.
     * @memberof oj.baseComponent
     * @instance
     * @private
     */
    __handleDisconnected: function __handleDisconnected() {
      // note that when it is delayed, then NotifyDetached would be called before ReleaseResources
      // this is fine for all the components that will use delayed disconnect, will need to re-visit if that is not the case.
      if (!this.__delayConnectDisconnect(_STATE_DISCONNECTED)) {
        this._ReleaseResources();
      }

      this._NotifyDetached();
    },

    /**
     * Delay the call to SetupResources and ReleaseResources as part of connected and disconnected.
     * See _verifyConnectedForSetup method for details.
     * @return {boolean} true if SetupResources/ReleaseResources has been delayed, false otherwise.
     * @memberof oj.baseComponent
     * @instance
     * @private
     */
    __delayConnectDisconnect: function __delayConnectDisconnect(state) {
      if (!this._VerifyConnectedForSetup()) {
        return false;
      }

      if (this.connectedState === undefined) {
        window.queueMicrotask(function () {
          if (this.connectedState === state) {
            if (state === _STATE_CONNECTED) {
              this._SetupResources();
            } else {
              this._ReleaseResources();
            }
          }

          this.connectedState = undefined;
        }.bind(this));
      }

      this.connectedState = state;
      return true;
    },

    /**
     * Method called by the CustomElementBridge to notify the component of changes to
     * any watched attributes registered in its metadata extension._WATCHED_ATTRS property.
     * @param {string} attr The name of the watched attribute
     * @param {string} oldValue The old attribute value
     * @param {string} newValue The new attribute value
     * @memberof oj.baseComponent
     * @instance
     * @private
     */
    __handleWatchedAttribute: function __handleWatchedAttribute(attr, oldValue, newValue) {
      this._WatchedAttributeChanged(attr, oldValue, newValue);
    },

    /**
     * Method for components to override in order to handle changes to watched attributes.
     * @param {string} attr The name of the watched attribute
     * @param {string} oldValue The old attribute value
     * @param {string} newValue The new attribute value
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    // eslint-disable-next-line no-unused-vars
    _WatchedAttributeChanged: function _WatchedAttributeChanged(attr, oldValue, newValue) {},

    /**
     * Method called by the CustomElementBridge to get the element to call focus on for this custom element
     * which can be the root custom element or an HTML element like an input or select.
     * @return {Element}
     * @memberof oj.baseComponent
     * @instance
     * @private
     */
    __getFocusElement: function __getFocusElement() {
      return this.GetFocusElement();
    },

    /**
     * Returns the current focusable element for this component which can be the root custom element
     * or an HTML element like an input or select.
     * @return {Element}
     * @memberof oj.baseComponent
     * @instance
     * @protected
     */
    GetFocusElement: function GetFocusElement() {
      return this.element[0];
    }
    /**
     * Under normal circumstances this class is applied automatically. It is documented here for the rare cases that an app
     * developer needs per-instance control.
     *
     * <p>The <code class="prettyprint">oj-focus-highlight</code> class applies focus styling that may not be desirable when
     * the focus results from pointer interaction (touch or mouse), but which is needed for accessibility when the focus
     * occurs by a non-pointer mechanism, for example keyboard or initial page load.
     *
     * <p>The application-level behavior for this component is controlled in the theme by the
     * <code class="prettyprint">$focusHighlightPolicy</code> SASS variable; however, note that this same variable controls
     * the focus highlight policy of many components and patterns. The values for the variable are:
     *
     * <ul>
     *   <li><code class="prettyprint">nonPointer</code>: <code class="prettyprint">oj-focus-highlight</code> is applied only
     *       when focus is not the result of pointer interaction. Most themes default to this value.</li>
     *   <li><code class="prettyprint">all</code>: <code class="prettyprint">oj-focus-highlight</code> is applied regardless
     *       of the focus mechanism.</li>
     *   <li><code class="prettyprint">none</code>: <code class="prettyprint">oj-focus-highlight</code> is never applied. This
     *       behavior is not accessible, and is intended for use when the application wishes to use its own event listener to
     *       precisely control when the class is applied (see below). The application must ensure the accessibility of the result.</li>
     * </ul>
     *
     * <p>To change the behavior on a per-instance basis, the application can set the SASS variable as desired and then use
     * event listeners to toggle this class as needed.
     *
     * @ojfragment ojFocusHighlightDoc - For use in the Styling table of components using the oj-focus-highlight class with the
     *    $focusHighlightPolicy var.  Components using that class with a component-specific mechanism instead of that $var will need
     *    different verbiage, which could be decomped to another baseComponent fragment if shareable by multiple components.
     * @memberof oj.baseComponent
     */

  }); // Remove base component from the jQuery prototype, so it could not be created
  // directly by page authors

  delete $.fn[_BASE_COMPONENT];
})(); // end of BaseComponent wrapper function
// -----------------------------------------------------------------------------
// End of baseComponent, start of other content
// -----------------------------------------------------------------------------

/**
 * <p>This method is our version of $.widget, i.e. the static initializer of a component such as ojButton.
 * It calls that method, plus does any other static init we need.
 *
 * TODO:
 * - Consider moving this method into its own file.
 * - For base param, make the type oj.baseComponent rather than Object, but need to declare that as a type first.  Review how that's done.
 *
 * @private
 * @param {string} name typically of the form "oj.ojMenu"
 * @param {Object} base NOT optional (unlike JQUI)
 * @param {Object} prototype
 * @param {boolean=} isHidden - if true, indicates that the component name should not
 * be available on jQuery prototype
 */


oj.__registerWidget = function (name, base, prototype, isHidden) {
  $.widget(name, base, prototype);

  if (isHidden) {
    var globalName = name.split('.')[1];
    delete $.fn[globalName];
  } // create single-OJ pseudo-selector for component, e.g. ":oj-menu", in addition to the ":oj-ojMenu" that $.widget() creates.
  // for private components it will begin with an underscore, e.g.,  ":_oj-radio"


  if (name.substring(0, 5) === 'oj.oj' || name.substring(0, 6) === 'oj._oj') {
    var nameArray = name.split('.'); // ["oj", "ojMenu"], ["oj", "_ojRadio"]

    var namespace = nameArray[0]; // "oj"

    var simpleName = nameArray[1]; // "ojMenu", "_ojRadio"

    var fullName = namespace + '-' + simpleName; // "oj-ojMenu", "oj-_ojRadio"

    var isPrivate = simpleName.substring(0, 1) === '_'; // if private, make the single-oj pseudo-selector start with an underscore, like this -> "_oj-radio"

    var modifiedFullName; // "oj-Menu", "_oj-Radio".  Lowercased below.

    if (isPrivate) {
      modifiedFullName = '_' + namespace + '-' + simpleName.substring(3);
    } else {
      modifiedFullName = namespace + '-' + simpleName.substring(2);
    } // Capitalization doesn't seem to matter with JQ pseudos, e.g. for the existing double-oj pseudo, both $(":oj-ojMenu") and $(":oj-ojmenu") work.
    // So, follow JQUI's pattern of using toLowerCase here, which will lowercase not only the "M' in "Menu", but also any camelcased chars after that.


    $.expr.pseudos[modifiedFullName.toLowerCase()] = function (elem) {
      return !!$.data(elem, fullName);
    };
  }
};
/**
 * @param {Object} self
 * @param {Object|undefined} originalDefaultValue
 * @param {?Object} constructorValue
 * @param {!Object} options
 * @param {string} prop
 * @param {Function} getter
 * @param {Function=} contextCallback
 * @private
 */


function _defineDynamicProperty(self, originalDefaultValue, constructorValue, options, prop, getter, contextCallback) {
  var override = constructorValue;
  var replaced = false;
  var overriddenSubkeys = {}; // eslint-disable-next-line no-param-reassign

  delete options[prop];
  Object.defineProperty(options, prop, {
    get: function get() {
      // Once the option is replaced, we no longer merge in defaults
      if (replaced) {
        return override;
      }

      if (self._settingNestedKey != null) {
        // The getter is getting called from the option() method that will be mutating the current
        // object. We need to return only the override portion in this case to avoid the defaults being
        // reapplied as an override
        return override;
      }

      var defaultVal = getter(contextCallback ? contextCallback() : prop);
      return _mergeOptionLayers([originalDefaultValue, defaultVal, override], overriddenSubkeys);
    },
    set: function set(value) {
      override = value;

      if (self._settingNestedKey != null) {
        overriddenSubkeys[self._settingNestedKey] = true;
      } else {
        // The entire option has been replaced
        replaced = true;
      }
    },
    enumerable: true
  });
}
/**
 * @ignore
 */


function _getCompoundDynamicGetter(values) {
  if (values.length === 1) {
    var val = values[0];
    return val instanceof __ojDynamicGetter ? val.getCallback() : null;
  }

  var hasGetters = false;

  for (var i = 0; i < values.length && !hasGetters; i++) {
    var value = values[i];

    if (value != null && value instanceof __ojDynamicGetter) {
      hasGetters = true;
    }
  }

  if (hasGetters) {
    var getter = function getter(context) {
      var resolvedVals = [];
      values.forEach(function (_value) {
        if (_value != null && _value instanceof __ojDynamicGetter) {
          resolvedVals.push(_value.getCallback()(context));
        } else {
          resolvedVals.push(_value);
        }
      });
      return _mergeOptionLayers(resolvedVals);
    };

    return getter;
  }

  return null;
}
/**
 * @private
 */


function _getSpecialContainerNames(element) {
  var elem = element;
  var containers = [];

  while (elem) {
    var ga = elem.getAttribute;
    var name = ga ? ga.call(elem, oj.Components._OJ_CONTAINER_ATTR) : null;

    if (name != null) {
      containers.push(name);
    }

    elem = elem.parentNode;
  }

  return containers;
}
/**
 * @private
 */


function _storeWidgetName(element, widgetName) {
  var data = element.data(_OJ_WIDGET_NAMES_DATA);

  if (!data) {
    data = [];
    element.data(_OJ_WIDGET_NAMES_DATA, data);
  }

  if (data.indexOf(widgetName) < 0) {
    data.push(widgetName);
  }
}
/**
 * @private
 */


function _removeWidgetName(element, widgetName) {
  var data = element.data(_OJ_WIDGET_NAMES_DATA);

  if (data) {
    var index = data.indexOf(widgetName);

    if (index >= 0) {
      data.splice(index, 1);

      if (data.length === 0) {
        element.removeData(_OJ_WIDGET_NAMES_DATA);
      }
    }
  }
}
/**
 * @private
 * @param {Array} values - values to merge
 * @param {Object=} overriddenSubkeys subkeys where the merging should not occur, i.e.
 * the value from corresponsing subkey on the last element of values array should win
 */


function _mergeOptionLayers(values, overriddenSubkeys) {
  var result;

  for (var i = 0; i < values.length; i++) {
    var value = values[i];

    if (value !== undefined) {
      if ($.isPlainObject(value)) {
        var input = $.isPlainObject(result) ? [result, value] : [value]; // The last object (overrides) is always fully merged in

        result = _mergeObjectsWithExclusions({}, input, i === values.length - 1 ? null : overriddenSubkeys, null);
      } else {
        result = value;
      }
    }
  }

  return result;
}
/**
 * @private
 */


function _mergeObjectsWithExclusions(target, input, ignoreSubkeys, basePath) {
  var inputLength = input.length;

  for (var inputIndex = 0; inputIndex < inputLength; inputIndex++) {
    var source = input[inputIndex];
    var keys = Object.keys(source);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var path;

      if (ignoreSubkeys == null) {
        path = null;
      } else if (basePath == null) {
        path = key;
      } else {
        path = basePath + '.' + key;
      } // Ignore all sources when the current path is registered in ignoreSubkeys


      if (ignoreSubkeys == null || !ignoreSubkeys[path]) {
        var value = source[key];

        if (value !== undefined) {
          if ($.isPlainObject(value)) {
            var params = $.isPlainObject(target[key]) ? [target[key], value] : [value]; // eslint-disable-next-line no-param-reassign

            target[key] = _mergeObjectsWithExclusions({}, params, ignoreSubkeys, path);
          } else {
            // eslint-disable-next-line no-param-reassign
            target[key] = value;
          }
        }
      }
    }
  }

  return target;
}
/**
 * @private
 */


function _returnTrue() {
  return true;
}
/**
 * Returns an object with context for the given child DOM node. This will always contain the subid for the node,
 * defined as the 'subId' property on the context object. Additional component specific information may also be included.
 *
 * For more details on returned objects, see <a href="#contextobjects-section">context objects</a>.
 *
 * @ojfragment nodeContextDoc
 * @memberof oj.baseComponent
 */

/**
 * The child DOM node
 *
 * @ojfragment nodeContextParam
 * @memberof oj.baseComponent
 */

/**
 * The context for the DOM node, or <code class="prettyprint">null</code> when none is found.
 *
 * @ojfragment nodeContextReturn
 * @memberof oj.baseComponent
 */

/**
 * // Returns {'subId': 'oj-some-sub-id', 'componentSpecificProperty': someValue, ...}
 * var context = myComponent.getContextByNode(nodeInsideElement);
 *
 * @ojfragment nodeContextExample
 * @memberof oj.baseComponent
 */

/**
 * <p>The contextMenu slot is set on the <code class="prettyprint">oj-menu</code> within this element.
 * This is used to designate the JET Menu that this component should launch as a context menu on right-click, Shift-F10, Press & Hold, or component-specific gesture.
 * If specified, the browser's native context menu will be replaced by the JET Menu specified in this slot.
 * <p>
 * The application can register a listener for the Menu's ojBeforeOpen event. The listener can cancel the launch via event.preventDefault(),
 * or it can customize the menu contents by editing the menu DOM directly, and then calling refresh() on the Menu.
 * <p>
 * To help determine whether it's appropriate to cancel the launch or customize the menu, the ojBeforeOpen listener can use component API's to determine which
 * table cell, chart item, etc., is the target of the context menu. See the JSDoc of the individual components for details.
 * <p>
 * Keep in mind that any such logic must work whether the context menu was launched via right-click, Shift-F10, Press & Hold, or component-specific touch gesture.
 *
 * @ojslot contextMenu
 * @memberof oj.baseComponent
 *
 * @ojshortdesc The contextMenu slot is set on the oj-menu instance within this element.  It designates the JET Menu to launch as a context menu.
 * @ojmaxitems 1
 *
 * @example <caption>Initialize the component with a context menu:</caption>
 * &lt;oj-some-element>
 *     &lt;-- use the contextMenu slot to designate this as the context menu for this component -->
 *     &lt;oj-menu slot="contextMenu" style="display:none" aria-label="Some element's context menu">
 * ...
 *     &lt;/oj-menu>
 * &lt;/oj-some-element>
 */

/**
 * Sets a property or a subproperty (of a complex property) and notifies the component
 * of the change, triggering a [property]Changed event.
 * The value should be of the same type as the type of the attribute mentioned in this API document.
 *
 * @function setProperty
 * @since 4.0.0
 * @param {string} property - The property name to set. Supports dot notation for subproperty access.
 * @param {any} value - The new value to set the property to.
 * @return {void}
 *
 * @expose
 * @memberof oj.baseComponent
 * @ojshortdesc Sets a property or a single subproperty for complex properties and notifies the component of the change, triggering a corresponding event.
 * @instance
 *
 * @ojtsexample <caption>Set a single subproperty of a complex property:</caption>
 * myComponent.setProperty('complexProperty.subProperty1.subProperty2', "someValue");
 */

/**
 * Retrieves the value of a property or a subproperty.
 * The return type will be the same as the type of the property as specified in this API document.
 * If the method is invoked with an incorrect property/subproperty name, it returns undefined.
 * @function getProperty
 * @since 4.0.0
 * @param {string} property - The property name to get. Supports dot notation for subproperty access.
 * @return {any}
 *
 * @expose
 * @memberof oj.baseComponent
 * @ojshortdesc Retrieves the value of a property or a subproperty.
 * @instance
 *
 * @ojtsexample <caption>Get a single subproperty of a complex property:</caption>
 * let subpropValue = myComponent.getProperty('complexProperty.subProperty1.subProperty2');
 */

/**
 * Performs a batch set of properties.
 * The type of value for each property being set must match the type of the property as specified in this
 * API document.
 * @function setProperties
 * @since 4.0.0
 * @param {Object} properties - An object containing the property and value pairs to set.
 * @return {void}
 *
 * @expose
 * @memberof oj.baseComponent
 * @ojshortdesc Performs a batch set of properties.
 * @instance
 *
 * @ojtsexample <caption>Set a batch of properties:</caption>
 * myComponent.setProperties({"prop1": "value1", "prop2.subprop": "value2", "prop3": "value3"});
 */



/* global Message:false */

/**
 * This picks a strategy for where to put each piece of information
 * that is on a component. It started out being messaging pieces: like
 * placeholder, converter hints, validator hints, error messages. In v8.0
 * we added labelEdge which could be top or inside the text field or inside
 * a non-text-field (like a radioset).
 * @param {Object} component instance
 * @protected
 * @constructor
 * @since 0.6.0
 * @ignore
 */
oj.ComponentMessaging = function (component) {
  this.Init(component);
}; // Subclass from oj.Object


oj.Object.createSubclass(oj.ComponentMessaging, oj.Object, 'oj.ComponentMessaging');
/**
 * Default strategy types supported for component messaging.
 * Think of these as places in the dom you want things.
 * Labels are the only things you put into the 'label-edge' positions,
 * so you will have only one of these at a time.
 * @memberof! oj.ComponentMessaging
 * @const
 * @protected
 * @ignore
 */

oj.ComponentMessaging._STRATEGY_TYPE = {
  NONE: 'none',
  NOTEWINDOW: 'notewindow',
  PLACEHOLDER: 'placeholder',
  INLINE: 'inline',
  LABEL_EDGE_INSIDE: 'inside',
  LABEL_EDGE_INSIDE_FORM_CNTRL: 'insideformcontrol',
  USER_ASSISTANCE_INLINE: 'userassistanceinline'
};
/**
 * Tracks the messaging strategy callback function by type, used to instantiate messaging strategies.
 * Implementations register by type.
 * @memberof! oj.ComponentMessaging
 * @const
 * @protected
 * @ignore
 */

oj.ComponentMessaging._STRATEGY_TYPE_TO_CALLBACK = {};
/**
 * Stores the constructor function callback object used to constuct a strategy object for the
 * specified type.
 *
 * @param {string} type
 * @param {Function} strategyConstructorCallback a constructor callback that can be used to constuct
 * a strategy object for the specified type
 * @ignore
 */

oj.ComponentMessaging.registerMessagingStrategy = function (type, strategyConstructorCallback) {
  if (type && typeof strategyConstructorCallback === 'function') {
    oj.ComponentMessaging._STRATEGY_TYPE_TO_CALLBACK[type] = strategyConstructorCallback;
  }
};
/**
 * Initializes the strategy based on the display options that specify the messaging artifacts that
 * will be displayed by this strategy.
 *
 * @param {Object} component widget instance
 * @memberof! oj.ComponentMessaging
 * @instance
 * @protected
 */


oj.ComponentMessaging.prototype.Init = function (component) {
  oj.ComponentMessaging.superclass.Init.call(this);
  this._component = component;
  this._activated = false; // sets up this._strategies, which is a list of what we will display in each type of
  // displayOption. E.g., 'inline': 'messages', 'notewindow': converterHint, validatorHint, etc.
  // See EditableValues displayOption attribute jsdoc for more details.

  this._initializeMessagingStrategies();
};
/**
 * Utility function that activates messaging on the component using the strategy provided.
 * @param {Object} launcher element(s) to which messaging applies
 * @param {Object} content
 * @private
 */


oj.ComponentMessaging.prototype.activate = function (launcher, contentElement, content) {
  var that = this;
  oj.Assert.assertObject(content);
  this._launcher = launcher;
  this._contentElement = contentElement;
  this._messagingContent = oj.CollectionUtils.copyInto(this._messagingContent || {}, content); // if already active, reinitialize strategies based on new messagingDisplay
  // and labelEdge preferences.

  if (!this._isActive()) {
    // for each 'messaging strategy' (e.g., inline == InlineMessagingStrategy,
    // notewindow == PopupMessagingStrategy, etc), call .activate which initializes
    // the strategy.
    $.each(this._strategies, function (i, strategy) {
      strategy.activate(that);
    });
    this._activated = true;
  } else {
    this._reactivate();
  }
};
/**
 * Utility function that updates messaging on the component for the content provided, using the
 * strategies.
 *
 * @param {Object} content
 * @private
 */
// TODO: component messaging could take the component instance


oj.ComponentMessaging.prototype.update = function (content) {
  oj.Assert.assertObject(content);
  oj.Assert.assertBoolean(this._activated);
  this._messagingContent = oj.CollectionUtils.copyInto(this._messagingContent || {}, content);

  if (this._activated) {
    $.each(this._strategies, function (i, strategy) {
      if (strategy.shouldUpdate(content)) {
        strategy.update();
      }
    });
  }
};
/**
 * Utility function that deactivates messaging on the component using the strategy provided.
 * @private
 */


oj.ComponentMessaging.prototype.deactivate = function () {
  $.each(this._strategies, function (i, strategy) {
    strategy.deactivate();
  });
  this._activated = false;
  this._component = null;
  this._launcher = null;
  this._contentElement = null;
  this._strategies = {};
};
/**
 * Utility function that closes anything that needs to be closed when oj.Components.subtreeHidden
 * is called. e.g, popup.
 * @private
 */


oj.ComponentMessaging.prototype.close = function () {
  if (this._activated) {
    $.each(this._strategies, function (i, strategy) {
      strategy.close();
    });
  }
};
/**
 * Creates a messaging strategy for the specified type, initializing it with the options provided.
 * @param {string|number} type defined by oj.ComponentMessaging._STRATEGY_TYPE. For example,
 * a strategyType of 'notewindow' creates a PopupComponentMessaging strategy. See
 * registerMessagingStrategy where we register the type and the callback to call for a given type.
 * We currently have PopupMessagingStrategy, DefaultMessagingStrategy, PlaceholderMessagingStrategy,
 * and InlineComponentStrategy.
 * e.g., In PopupComponentMessaging.js:
 *  oj.ComponentMessaging.registerMessagingStrategy(oj.ComponentMessaging._STRATEGY_TYPE.NOTEWINDOW,
 *                              oj.PopupMessagingStrategy
 * @param {Array.<string>|undefined} artifactsForType (e.g., 'messages', 'helpInstruction', 'validatorHints')
 *
 * @private
 * @instance
 * @memberof !oj.ComponentMessaging
 */


oj.ComponentMessaging.prototype._createMessagingStrategy = function (type, artifactsForType) {
  var Callback = oj.ComponentMessaging._STRATEGY_TYPE_TO_CALLBACK[type] || oj.ComponentMessaging._STRATEGY_TYPE_TO_CALLBACK[oj.ComponentMessaging._STRATEGY_TYPE.NONE]; // dynamically instantiate the strategy objects.

  return new Callback(artifactsForType);
};
/**
 * Returns the component instance or null
 *
 * @return {Object|null}
 * @private
 * @instance
 * @memberof !oj.ComponentMessaging
 */


oj.ComponentMessaging.prototype._getComponent = function () {
  return this._component || null;
};
/**
 * Returns the launcher jquery element. This is the element on the component to which messaging
 * applies.
 *
 * @return {Object|null} null if messaging is not activated.
 * @private
 * @instance
 * @memberof !oj.ComponentMessaging
 */


oj.ComponentMessaging.prototype._getLauncher = function () {
  return this._launcher || null;
};
/**
 * Returns the jquery element on the component to which aria-invalid
 * applies. This is either the launcher itself or the inputs
 * within the launcher dom.  JAWS only reads aria-invalid when it is on the input/textara/select.
 * <p>
 * In the case of radioset/checkboxset, for example, where the launcher
 * is the root dom element and the inputs are with it, we return the inputs.
 *
 * </p>
 *
 * @return {Object|null} null if launcher is null
 * @private
 * @instance
 * @memberof !oj.ComponentMessaging
 */


oj.ComponentMessaging.prototype._getContentElement = function () {
  return this._contentElement || null;
};
/**
 * Returns the last saved messagingContent object.
 *
 * @return {Object}
 * @private
 * @instance
 * @memberof !oj.ComponentMessaging
 */


oj.ComponentMessaging.prototype._getMessagingContent = function () {
  return this._messagingContent || {};
};
/**
 * Useful for on-demand messaging content, like validation hints.
 *
 * @param {Object} content
 * @private
 * @memberof !oj.ComponentMessaging
 */


oj.ComponentMessaging.prototype._setMessagingContent = function (content) {
  oj.Assert.assertObject(content);
  this._messagingContent = oj.CollectionUtils.copyInto(this._messagingContent || {}, content);
};
/**
 * Whether the component messaging is activated.
 * @return {boolean}
 * @private
 */


oj.ComponentMessaging.prototype._isActive = function () {
  return this._activated;
};
/**
 * Returns a key/value array: strategyTypes -> array of artifacts using that strategyType.
 * where artifacts is 'messages', 'converterHint', 'validatorHint', 'helpInstruction';
 * e.g.,
 * strategyToArtifacts[oj.ComponentMessaging._STRATEGY_TYPE.NOTEWINDOW] = ['messages', 'converterHints']
 * strategyToArtifacts[oj.ComponentMessaging._STRATEGY_TYPE.NONE] = ['validatorHints']
 * The types of messaging content for which displayOptions can be configured include
 * messages, converterHint, validatorHint and helpInstruction.
 * The displayOptions for each type is specified either as an array of strings or a string.
 * When an array is specified the first display option takes precedence over the second and so on,
 * so we will only have ONE display type per artifact.
 */


oj.ComponentMessaging.prototype._getResolvedMessagingDisplayOptions = function (messagingPreferences) {
  var strategyToArtifacts = {};
  var artifactStrategyTypeResolved = false;
  var options = this._component.options;
  var $messagingPreferences = {};
  var self = this; // first resolve primary display options for each artifact.
  // E.g. at the end of this loop you should have something like this
  // {messages: 'notewindow', converterHint: 'placeholder', validatorHint: 'notewindow', helpInstruction: 'none'}

  var keys = Object.keys(messagingPreferences);

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var strategyTypes = messagingPreferences[key]; // loop over array of strategyTypes preferred for artifact.
    // artifacts are 'messages', 'converterHint', 'validatorHint', 'helpInstruction'

    artifactStrategyTypeResolved = false;
    var artifact = key + ''; // we take either array or string values for displayOptions.

    if (Array.isArray(strategyTypes)) {
      for (var j = 0; j < strategyTypes.length; j++) {
        var strategyType = strategyTypes[j];

        if (!artifactStrategyTypeResolved) {
          artifactStrategyTypeResolved = self._resolveStrategyTypeForArtifact(artifact, strategyType, options, $messagingPreferences);
        }
      }
    } else if (typeof strategyTypes === 'string') {
      if (!artifactStrategyTypeResolved) {
        artifactStrategyTypeResolved = self._resolveStrategyTypeForArtifact(artifact, strategyTypes, options, $messagingPreferences);
      }
    } // if we couldn't resolve then use "none". E.g., validationHint: ['none']


    if (!artifactStrategyTypeResolved) {
      $messagingPreferences[artifact] = oj.ComponentMessaging._STRATEGY_TYPE.NONE;
    }
  } // update the label creation strategy
  // at this point, $messagingPreferences may have an Object like:
  // {converterHint:'notewindow',
  // helpInstruction:'notewindow', messages:'inline', validatorHint:'notewindow}
  // After the call to _addLabelStrategy, it might be added
  // labelEdge:'top'


  self._addLabelStrategy($messagingPreferences); // collate by strategyType -> artifact. but first reset


  $.each(oj.ComponentMessaging._STRATEGY_TYPE, function (type, name) {
    strategyToArtifacts[name] = [];
  });
  $.each($messagingPreferences, function (_artifact, _strategyType) {
    // an artifact eventually resolves to one strategyType.
    strategyToArtifacts[_strategyType].push(_artifact);
  }); // The keys to the object is the DisplayType, like inline, inside,
  // insideFormControl, none, notewindow, placeholder.
  // The artifacts are things like converterHint, label.

  return strategyToArtifacts;
};
/**
 * This function is used when the component's user assistance option should be used.
 * The component.display-options is used only to see if 'none' is specified.
 * display-options is ignored otherwise for the Redwood theme (via a theming variable).
 *
 * This function returns a key/value array: strategyTypes -> array of artifacts
 * using that strategyType. where artifacts is
 * 'messages', 'converterHint', 'validatorHint', 'helpInstruction';
 * e.g., {userAssistanceInline: ['messages', 'helpInstruction'],
 *        none: ['validationHint']
 * Note: the only strategies for inline are userAssistanceInline and none (and the label strategies)
 * The types of messaging content that can be configured include
 * messages, converterHint, validatorHint and helpInstruction.
 */


oj.ComponentMessaging.prototype._getUserAssistanceStrategyToArtifactsObj = function () {
  var strategyToArtifacts = {};
  var options = this._component.options;
  var componentDisplayOptions = options.displayOptions || {};
  var artifactPiecesToStrategyObj = {};
  var self = this; // componentDisplayOptions will be an Object like this:
  // {messages:['inline'], converterHint:['placeholder','notewindow'],
  // validatorHint:['notewindow], helpInstruction:['notewindow']
  // If we are looking at the user-assistance-density attribute on the component,
  // then all we care about from the displayOptions attribute is whether or not there
  // is a 'none' for any of these 'artifacts'. Like, is validatorHint:'none'? If so, do not
  // render the validatorHint. Otherwise render it how the user-assistance-density says to.
  //
  // first resolve primary display options for each artifact.
  // E.g. at the end of this loop you should have something like this
  // {messages: 'userassistanceinline', validatorHint:
  // 'userassistanceinline', helpInstruction: 'none'}

  var keys = Object.keys(componentDisplayOptions);

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var strategyTypes = componentDisplayOptions[key]; // loop over array of strategyTypes preferred for artifact.
    // artifacts are 'messages', 'converterHint', 'validatorHint', 'helpInstruction'

    var artifact = key + ''; // we only look at 'string' for 'none'.

    if (typeof strategyTypes === 'string' && strategyTypes === 'none') {
      artifactPiecesToStrategyObj[artifact] = oj.ComponentMessaging._STRATEGY_TYPE.NONE;
    } else {
      // put it in the user assistance inline
      artifactPiecesToStrategyObj[artifact] = oj.ComponentMessaging._STRATEGY_TYPE.USER_ASSISTANCE_INLINE;
    }
  } // update the label creation strategy
  // at this point, artifactPiecesToStrategyObj may have an Object like:
  // {converterHint:'none',
  // helpInstruction:'userassistanceinline', messages:'userassistanceinline', validatorHint:'none'}
  // After the call to _addLabelStrategy, it might be added
  // labelEdge:'top'


  self._addLabelStrategy(artifactPiecesToStrategyObj); // collate by strategyType -> artifact. but first reset


  Object.keys(oj.ComponentMessaging._STRATEGY_TYPE).forEach(function (key) {
    var value = oj.ComponentMessaging._STRATEGY_TYPE[key];
    strategyToArtifacts[value] = [];
  });
  Object.keys(artifactPiecesToStrategyObj).forEach(function (key) {
    var _strategyType = artifactPiecesToStrategyObj[key];

    strategyToArtifacts[_strategyType].push(key);
  }); // This returns an Object with all the StrategyTypes as keys and the
  // 'artifacts' as values, like {none:['validationHint'], 'userAssistanceInline':['messages', 'helpInstruction']
  // inside:['labelEdge']}

  return strategyToArtifacts;
}; // Note:
// Each LabelStrategy is self-registering., e.g., InsideFormControlLabelStrategy registers itself
// by calling oj.ComponentMessaging.registerMessagingStrategy.
// this adds the label strategy for the component by the same type.


oj.ComponentMessaging.prototype._addLabelStrategy = function ($messagingPreferences) {
  var self = this;
  var artifactKey = 'labelEdge'; // The strategyTypeLabelEdge will be one of these: oj.ComponentMessaging._STRATEGY_TYPE.LABEL_EDGE*

  var strategyTypeLabelEdge = this._component._ResolveLabelEdgeStrategyType();

  var artifactStrategyTypeResolved = self._resolveStrategyTypeForArtifact(artifactKey, strategyTypeLabelEdge, this._component.options, $messagingPreferences);

  if (!artifactStrategyTypeResolved) {
    // eslint-disable-next-line no-param-reassign
    $messagingPreferences[artifactKey] = oj.ComponentMessaging._STRATEGY_TYPE.NONE;
  }
};

oj.ComponentMessaging.prototype._resolveStrategyTypeForArtifact = function (artifact, strategyType, options, $messagingPreferences) {
  var artifactStrategyTypeResolved = false;
  var compPH = options.placeholder;

  switch (strategyType) {
    // placeholder display is special in that it's only supported on 'converterHint'.
    case oj.ComponentMessaging._STRATEGY_TYPE.PLACEHOLDER:
      if (artifact === 'converterHint') {
        // if placeholder is the first preference for converterHint, it's used under certain
        // conditions
        // if options.placeholder is not set then use 'converterHint' as the default
        // 'placeholder'
        // alternately if (options.placeholder), i.e., a custom placeholder is set, then
        // ignore the placeholder strategyType and use the next display type as the default
        // for the artifact. We may have a fallback strategyType in which case we use it,
        // otherwise we use 'none'. E.g.,
        // {'converterHint': ['placeholder', 'notewindow']} // use notewindow
        // {'converterHint': ['placeholder']}               // use none
        if (!artifactStrategyTypeResolved) {
          if (!compPH) {
            // eslint-disable-next-line no-param-reassign
            $messagingPreferences[artifact] = strategyType;
            artifactStrategyTypeResolved = true;
          }
        }
      } else {// strategyType 'placeholder' is not supported on other artifacts
        // ignore if present
        // TODO: In the future we may want to support configuring validatorHint ot helpInstruction as
        // placeholder as well.
      }

      break;
    // inline display is special in that it's only supported on 'messages'.

    case oj.ComponentMessaging._STRATEGY_TYPE.INLINE:
      if (artifact === 'messages') {
        if (!artifactStrategyTypeResolved) {
          // eslint-disable-next-line no-param-reassign
          $messagingPreferences[artifact] = strategyType;
          artifactStrategyTypeResolved = true;
        }
      } else {// strategyType 'inline' is not supported on other artifacts
        // ignore if present
      }

      break;

    case oj.ComponentMessaging._STRATEGY_TYPE.LABEL_EDGE_INSIDE:
    case oj.ComponentMessaging._STRATEGY_TYPE.LABEL_EDGE_INSIDE_FORM_CNTRL:
      if (artifact === 'labelEdge' && !artifactStrategyTypeResolved && !oj.StringUtils.isEmptyOrUndefined(options.labelHint)) {
        // eslint-disable-next-line no-param-reassign
        $messagingPreferences[artifact] = strategyType;
        artifactStrategyTypeResolved = true;
      }

      break;

    default:
      if (!artifactStrategyTypeResolved && artifact !== 'labelEdge') {
        // eslint-disable-next-line no-param-reassign
        $messagingPreferences[artifact] = strategyType;
        artifactStrategyTypeResolved = true;
      }

      break;
  }

  return artifactStrategyTypeResolved;
};
/**
 * Creates messaging strategies for the component.
 * As of v9.0 form components have a user-assistance-density attribute in addition
 * to the existing display-options. For Redwood UX we look at the user-assistance-density
 * which is efficient or compact and the app will have all its 'user assistance' (i.e., help instruction,
 * hint, messages) inline, or if compact it is in popups.
 * For bw compatibility/Alta we continue to look at display-options
 * like display-options.help-instruction that could be notewindow,
 * and for display-options.messages that could be inline, etc.
 * BOTH will look at display-options for validationHint/messages for 'none'
 * because we still want to be able to turn these off.
 * @private
 */


oj.ComponentMessaging.prototype._initializeMessagingStrategies = function () {
  var strategyToArtifacts = this._strategyToArtifacts();

  var displayInNoteWindow = strategyToArtifacts[oj.ComponentMessaging._STRATEGY_TYPE.NOTEWINDOW];
  var displayNone = strategyToArtifacts[oj.ComponentMessaging._STRATEGY_TYPE.NONE];
  var displayInPlaceholder = strategyToArtifacts[oj.ComponentMessaging._STRATEGY_TYPE.PLACEHOLDER];
  var displayInline = strategyToArtifacts[oj.ComponentMessaging._STRATEGY_TYPE.INLINE]; // these are input components

  var displayLabelEdgeInsideTextField = strategyToArtifacts[oj.ComponentMessaging._STRATEGY_TYPE.LABEL_EDGE_INSIDE]; // these are form controls that aren't inputs, like radioset

  var displayLabelEdgeInsideFormControl = strategyToArtifacts[oj.ComponentMessaging._STRATEGY_TYPE.LABEL_EDGE_INSIDE_FORM_CNTRL]; // these are for user assistance inline that is used in the Redwood theme

  var displayUserAssistanceInline = strategyToArtifacts[oj.ComponentMessaging._STRATEGY_TYPE.USER_ASSISTANCE_INLINE];
  var messagingStrategies = {};

  if (displayInNoteWindow.length > 0) {
    // displayInNoteWindow is an array of the artifacts that want to be displayed in the note window
    // e.g., 'messages', 'converterHints', etc.
    messagingStrategies[oj.ComponentMessaging._STRATEGY_TYPE.NOTEWINDOW] = this._createMessagingStrategy(oj.ComponentMessaging._STRATEGY_TYPE.NOTEWINDOW, displayInNoteWindow);
  }

  if (displayInPlaceholder.length > 0 && displayLabelEdgeInsideTextField.length === 0) {
    // displayInPlaceholder is an array of the artifacts that want to be displayed in placeholder
    // e.g., 'converterHints'
    messagingStrategies[oj.ComponentMessaging._STRATEGY_TYPE.PLACEHOLDER] = this._createMessagingStrategy(oj.ComponentMessaging._STRATEGY_TYPE.PLACEHOLDER, displayInPlaceholder);
  }

  if (displayInline.length > 0) {
    // displayInline is an array of the artifacts that want to be displayed in inline
    // e.g., 'messages'
    messagingStrategies[oj.ComponentMessaging._STRATEGY_TYPE.INLINE] = this._createMessagingStrategy(oj.ComponentMessaging._STRATEGY_TYPE.INLINE, displayInline);
  }

  if (displayUserAssistanceInline.length > 0) {
    messagingStrategies[oj.ComponentMessaging._STRATEGY_TYPE.USER_ASSISTANCE_INLINE] = this._createMessagingStrategy(oj.ComponentMessaging._STRATEGY_TYPE.USER_ASSISTANCE_INLINE, displayUserAssistanceInline);
  } // Create one of these strategies for whatever labelEdge we are using currently


  if (displayLabelEdgeInsideTextField.length > 0) {
    messagingStrategies[oj.ComponentMessaging._STRATEGY_TYPE.LABEL_EDGE_INSIDE] = this._createMessagingStrategy(oj.ComponentMessaging._STRATEGY_TYPE.LABEL_EDGE_INSIDE, displayLabelEdgeInsideTextField);
  } else if (displayLabelEdgeInsideFormControl.length > 0) {
    messagingStrategies[oj.ComponentMessaging._STRATEGY_TYPE.LABEL_EDGE_INSIDE_FORM_CNTRL] = this._createMessagingStrategy(oj.ComponentMessaging._STRATEGY_TYPE.LABEL_EDGE_INSIDE_FORM_CNTRL, displayLabelEdgeInsideFormControl);
  }

  messagingStrategies[oj.ComponentMessaging._STRATEGY_TYPE.NONE] = this._createMessagingStrategy(oj.ComponentMessaging._STRATEGY_TYPE.NONE, displayNone);
  this._strategies = messagingStrategies;
};
/**
 * Reinitializes component messaging.
 *
 * @private
 */


oj.ComponentMessaging.prototype._reactivate = function () {
  var strategyToArtifacts = this._strategyToArtifacts();

  var strategy;
  var cm = this; // for every strategyType being requested either create the messaging strategy for the type or
  // reuse existing strategy if it has already been created.

  $.each(strategyToArtifacts, function (type, artifactsForType) {
    // eslint-disable-next-line no-param-reassign
    type += ''; // coerce to avoid GCC warning

    strategy = cm._strategies[type];

    if (artifactsForType && artifactsForType.length > 0) {
      if (!strategy) {
        // create a strategy if one doesn't exist for the type
        strategy = cm._createMessagingStrategy(type, artifactsForType);
        cm._strategies[type] = strategy;
        strategy.activate(cm);
      } else if (strategy) {
        // update strategy with the latest displayOptions if already present. we don;t
        // want to remove it once activated.
        strategy.reactivate(artifactsForType);
      }
    } else if (strategy && oj.ComponentMessaging._STRATEGY_TYPE.NONE !== type) {
      // if we have no artifacts to show for a type, then remove the strategy.
      // only if its other than the DefaultMessagingStrategy as it's always needed to theme
      // component.
      strategy.deactivate();
      delete cm._strategies[type];
    }
  });
};
/**
 * get strategy to artifacts
 * we do different things depending on whether we are using displayOptions
 * or the user-assistance-density attribute.
 *
 * @private
 */


oj.ComponentMessaging.prototype._strategyToArtifacts = function () {
  var strategyToArtifacts;

  var resolvedUserAssistance = this._component._getResolvedUserAssistance();

  if (resolvedUserAssistance !== 'compact' && resolvedUserAssistance !== 'displayOptions') {
    strategyToArtifacts = this._getUserAssistanceStrategyToArtifactsObj();
  } else {
    var options = this._component.options;
    var messagingPreferences = options.displayOptions || {};

    if (resolvedUserAssistance === 'compact') {
      // for 'compact' set displayOptions.messages to notewindow.
      messagingPreferences.messages = 'notewindow';
      strategyToArtifacts = this._getResolvedMessagingDisplayOptions(messagingPreferences);
    } else {
      strategyToArtifacts = this._getResolvedMessagingDisplayOptions(messagingPreferences);
    }
  }

  return strategyToArtifacts;
};
/**
 * A base messaging strategy class that is initialized with a set of displayOptions. This object
 * also provides helper methods for its subclasses.
 *
 * @param {Array.<string>} displayOptions an array of messaging artifacts displayed.
 *
 * @constructor
 * @class oj.MessagingStrategy
 * @private
 */


oj.MessagingStrategy = function (displayOptions) {
  this.Init(displayOptions);
}; // Subclass from oj.Object


oj.Object.createSubclass(oj.MessagingStrategy, oj.Object, 'oj.MessagingStrategy');
/**
 * Initializes the strategy based on the display options that specify the messaging artifacts that
 * will be displayed by this strategy.
 *
 * @param {Array.<string>} displayOptions an array of messaging artifacts displayed.
 * @private
 */

oj.MessagingStrategy.prototype.Init = function (displayOptions) {
  oj.Assert.assertArray(displayOptions);
  oj.MessagingStrategy.superclass.Init.call(this);
  this._displayOptions = displayOptions;
};

oj.MessagingStrategy.prototype.activate = function (cm) {
  this._componentMessaging = cm;
};
/**
 * Cleans up messaging artifacts that were created on the component instance. E.g., destroys any
 * widgets it created, removes styles added etc.
 *
 * @private
 */


oj.MessagingStrategy.prototype.deactivate = function () {};
/**
 * Utility function that closes anything that needs to be closed when oj.Components.subtreeHidden
 * is called. e.g, popup.
 *
 * @private
 */


oj.MessagingStrategy.prototype.close = function () {};
/**
 * Reinitializes with the new display options and updates component messaging using the new content.
 *
 * @param {Array.<string>} newDisplayOptions
 * @private
 */


oj.MessagingStrategy.prototype.reactivate = function (newDisplayOptions) {
  this.Init(newDisplayOptions);
};
/**
 * Returns true always. Subclasses can override to ignore updates.
 *
 * @param {Object=} content the messaging content that is being updated
 * @return {boolean}
 *
 * @private
 */
// eslint-disable-next-line no-unused-vars


oj.MessagingStrategy.prototype.shouldUpdate = function (content) {
  return true;
};
/**
 * Updates component with instance using the content provided.
 *
 * @private
 */


oj.MessagingStrategy.prototype.update = function () {}; // P R O T E C T E D  M E T H O D S

/**
 * Gets the launcher element for which the messaging is applied.
 * @return {Object} the jquery element of the form element.
 * @private
 */


oj.MessagingStrategy.prototype.GetLauncher = function () {
  return this._componentMessaging._getLauncher();
};
/**
 * @return {Object} the jquery element of the form element.
 * @private
 */


oj.MessagingStrategy.prototype.GetContentElement = function () {
  return this._componentMessaging._getContentElement();
};
/**
 * Gets the component (widget).
 * @return {Object} the jet component instance
 * @private
 */


oj.MessagingStrategy.prototype.GetComponent = function () {
  return this._componentMessaging._getComponent();
};
/**
 * This is simply a flag.
 * Set to true when we get the validator hints from the component the first time.
 * Then use getHasValidatorHints to check if it is true. If so we
 * know we've already gotten the validator hints the first time and
 * won't get them from the component again.
 * @param {boolean} hasValidatorHints true if we have the validator hints
 * @private
 */


oj.MessagingStrategy.prototype.setHasValidatorHints = function (hasValidatorHints) {
  this._hasValidatorHints = hasValidatorHints;
};
/**
 * If true, it means we have already retrieved the validator hints from the
 * component.
 * @private
 * @return {boolean} true if we already have the validator hints, else false
 */


oj.MessagingStrategy.prototype.getHasValidatorHints = function () {
  return this._hasValidatorHints === true;
};
/**
 * Generates a unique id if the element doesn't have one already assigned.
 * @param {Element} element requiring an id
 * @private
 */


oj.MessagingStrategy.prototype.GenerateIdIfNeeded = function (element) {
  if (isNaN(oj.MessagingStrategy._uidCounter)) {
    oj.MessagingStrategy._uidCounter = 0;
  }

  var e = element;

  if (!e.id) {
    e.id = 'ojms_' + oj.MessagingStrategy._uidCounter;
    oj.MessagingStrategy._uidCounter += 1;
  }
};
/**
 * Returns an array of messages.
 *
 * @return {Array} of messages each an instance of oj.Message
 * @private
 */


oj.MessagingStrategy.prototype.GetMessages = function () {
  return this.GetValidityState().getMessages();
};

oj.MessagingStrategy.prototype.GetMaxSeverity = function () {
  return this.GetValidityState().getMaxSeverity();
};
/**
 * Gets the converter hint.
 *
 * @return {Array} an array of hints, each a string.
 * @private
 */


oj.MessagingStrategy.prototype.GetConverterHint = function () {
  var hints = [];

  var mc = this._getMessagingContent();

  var converterHint = mc && mc.converterHint;

  if (converterHint) {
    hints.push(converterHint);
  }

  return hints;
};
/**
 * ValidatorHints are retrieved on-demand. The first time they are requested,
 * we get them and set the mc.validatorHints.
 * @return {string} helpInstruction or ""
 * @private
 */


oj.MessagingStrategy.prototype.GetValidatorHints = function () {
  if (!this.getHasValidatorHints()) {
    this.setHasValidatorHints(true);
    var component = this.GetComponent(); // get the sync validator hints from the component, then set the messaging content.

    this._setMessagingContent(component._getValidatorHintsMC());

    component._initAsyncValidatorMessagingHint();
  } // Eventually the messagingContent will have all the validatorHints, even the async ones.
  // The async validators call componentMessaging.update(cm) when each hint Promise resolves with
  // all the validator hints it has so far, sync/async.
  // The first time through, before update, this will return the sync validator hints.
  // Every time the componentMessaging.update(cm) is called after, it will have the sync hints
  // plus any new async hints. The most common use case is to have only one validator per
  // form component but this supports multiple and sync and async.


  var mc = this._getMessagingContent();

  return mc && mc.validatorHint || [];
};
/**
 * Gets the short description.
 * @return {string} helpInstruction or ""
 * @private
 */


oj.MessagingStrategy.prototype.GetTitle = function () {
  var mc = this._getMessagingContent();

  return mc && mc.title || '';
};
/**
 * Gets the validityState, an instance of oj.ComponentValidity or null.
 * @private
 */


oj.MessagingStrategy.prototype.GetValidityState = function () {
  var mc = this._getMessagingContent();

  return mc && mc.validityState || null;
};
/**
 * Whether the strategy is displaying messages or not.
 * @return {boolean} true if strategy has messages to display
 * @private
 */


oj.MessagingStrategy.prototype.HasMessages = function () {
  var messages = this.GetMessages();
  return !!(messages && messages.length > 0);
};
/**
 * The following explains what this._displayOptions is in the following methods --
 * When the Strategy is created, like the PopupComponentMessaging strategy, it gets passed
 * in what artifacts it needs to display, like 'messages' or 'validatorHint'.
 * The default in alta is to show 'helpInstruction' and 'validatorHint' in 'notewindow'.
 * The api is displayOptions.helpInstruction = 'notewindow' and
 * displayOptions.validatorHint = 'notewindow', and this gets consolidated the other way,
 * notewindow: [helpInstruction, validatorHint], where notewindow is the PopupComponentStrategy.
 * For Redwood, we look at the user-assistance-density attribute, and by default the displayOptions
 * will be 'messages', 'helpInstruction' and 'validatorHint'.
 * 'helpInstruction', 'helpDefinition' and 'helpSource' are
 * shown if the attributes are set.
 * The user can turn off helpInstruction by not having a help instruction option.
 * The user can turn off messages and/or validationHint by setting its display-options to none, like
 * display-options.validatorHint = 'none'.
 */


oj.MessagingStrategy.prototype.ShowMessages = function () {
  return this._displayOptions.indexOf('messages') !== -1;
};

oj.MessagingStrategy.prototype.ShowConverterHint = function () {
  return this._displayOptions.indexOf('converterHint') !== -1;
};

oj.MessagingStrategy.prototype.ShowValidatorHint = function () {
  return this._displayOptions.indexOf('validatorHint') !== -1;
};

oj.MessagingStrategy.prototype.ShowTitle = function () {
  return this._displayOptions.indexOf('title') !== -1 || this._displayOptions.indexOf('helpInstruction') !== -1;
};
/**
 * Returns true if we have invalid messages; false otherwise.
 *
 * @return {boolean}
 * @private
 */


oj.MessagingStrategy.prototype.IsInvalid = function () {
  return this.GetValidityState().isInvalid();
};
/**
 * Create an id to put on the root dom element that holds the inline messaging content,
 * then add aria-describedby on the component on the appropriate dom node(s).
 * This makes it so the screen reader user knows the messaging content is connected to the launcher.
 * @memberof oj.MessagingStrategy
 * @param {Element} containerRoot
 * @instance
 * @private
 */


oj.MessagingStrategy.prototype.AddAriaDescribedByForInlineMessaging = function (containerRoot) {
  // create an id on the div holding the inline messaging.
  // add aria-describedby to the launcher to associate the launcher and the inline message
  var $contentElems = this.GetContentElement();
  oj.Assert.assertPrototype($contentElems, $);
  var containerRootId = $(containerRoot).uniqueId()[0].getAttribute('id');
  $contentElems.each(function () {
    // get ariaAttr that is on the content element(s)
    var ariaAttributeValue = this.getAttribute('aria-describedby'); // split into tokens

    var tokens = ariaAttributeValue ? ariaAttributeValue.split(/\s+/) : []; // Get index that id is in the tokens, if at all.

    var index = tokens.indexOf(containerRootId); // push id into tokens if it isn't already there

    if (index === -1) {
      tokens.push(containerRootId);
    } // join the tokens together


    var newValue = tokens.join(' ').trim();
    this.setAttribute('aria-describedby', newValue); // @HTMLUpdateOK
  });
};
/**
 * @memberof oj.MessagingStrategy
 * @param {Element} containerRoot
 * @instance
 * @private
 */


oj.MessagingStrategy.prototype.AddDescribedByToElement = function (elem, id) {
  var attr = 'described-by';
  var currentAttributeValue = elem.getAttribute(attr);
  var newAttributeValue;
  var tokens = currentAttributeValue ? currentAttributeValue.split(/\s+/) : []; // Get index that id is in the tokens, if at all.

  var index = tokens.indexOf(id); // add id if it isn't already there

  if (index === -1) {
    tokens.push(id);
  }

  newAttributeValue = tokens.join(' ').trim();
  elem.setAttribute(attr, newAttributeValue); // @HTMLUpdateOK
};
/**
 * Removes the aria-describedby from the launcher that was added by AddAriaDescribedByForInlineMessaging
 * @param {Element} containerRoot
 * @memberof oj.MessagingStrategy
 * @instance
 * @private
 */


oj.MessagingStrategy.prototype.RemoveAriaDescribedByForInlineMessaging = function (containerRoot) {
  var $contentElems = this.GetContentElement();
  oj.Assert.assertPrototype($contentElems, $);
  var containerRootId = containerRoot.getAttribute('id');
  $contentElems.each(function () {
    // get ariaAttr that is on the content element(s)
    var ariaAttributeValue = this.getAttribute('aria-describedby'); // split into tokens

    var tokens = ariaAttributeValue ? ariaAttributeValue.split(/\s+/) : []; // Get index that id is in the tokens, if at all.

    var index = tokens.indexOf(containerRootId); // remove id if it is there.

    if (index !== -1) {
      // remove that from the tokens array
      tokens.splice(index, 1);
    }

    var newValue = tokens.join(' ').trim();

    if (newValue) {
      this.setAttribute('aria-describedby', newValue); // @HTMLUpdateOK
    } else {
      this.removeAttribute('aria-describedby');
    }
  });
};
/**
 * Gets the messagingContent stored in ComponentMessaging instance
 * @return {Object}
 * @private
 */


oj.MessagingStrategy.prototype._getMessagingContent = function () {
  if (this._componentMessaging) {
    return this._componentMessaging._getMessagingContent();
  }

  return {};
};
/**
 * Gets the messagingContent stored in ComponentMessaging instance
 * @param {Object} messaging content.
 * @private
 */


oj.MessagingStrategy.prototype._setMessagingContent = function (content) {
  if (this._componentMessaging) {
    return this._componentMessaging._setMessagingContent(content);
  }

  return {};
};
/**
 * A messaging strategy that updates the component theming and accessibility attributes.
 *
 * @param {Array.<string>} displayOptions .
 * @constructor
 * @extends {oj.MessagingStrategy}
 * @private
 */


oj.DefaultMessagingStrategy = function (displayOptions) {
  this.Init(displayOptions);
};

oj.ComponentMessaging.registerMessagingStrategy(oj.ComponentMessaging._STRATEGY_TYPE.NONE, oj.DefaultMessagingStrategy); // TODO: Need to retrieve style selectors from a Style Manager

oj.DefaultMessagingStrategy._SELECTOR_STATE_INVALID = 'oj-invalid';
oj.DefaultMessagingStrategy._SELECTOR_STATE_WARNING = 'oj-warning';
oj.Object.createSubclass(oj.DefaultMessagingStrategy, oj.MessagingStrategy, 'oj.DefaultMessagingStrategy');
/**
 * Updates component theming, a11y attributes using the latest component state and its messaging
 * content.
 *
 * @private
 */

oj.DefaultMessagingStrategy.prototype.update = function () {
  oj.DefaultMessagingStrategy.superclass.update.call(this);
  var launcher = this.GetLauncher();
  var maxSeverity = this.GetMaxSeverity();
  var removeClasses = [];
  var addClasses = [];
  var invalid = false;
  var component = this.GetComponent();
  var jqRoot = component.widget();

  if (!launcher) {
    return;
  } // apply element error styling if invalid


  if (this.IsInvalid()) {
    // enable tooltip; set invalid class and aria invalid
    // TODO: oj classes should be set on the root DOM
    removeClasses.push(oj.DefaultMessagingStrategy._SELECTOR_STATE_WARNING);
    addClasses.push(oj.DefaultMessagingStrategy._SELECTOR_STATE_INVALID);
    invalid = true;
  } else if (this.HasMessages() && maxSeverity === Message.SEVERITY_LEVEL.WARNING) {
    // TODO: add warning or other severity state
    removeClasses.push(oj.DefaultMessagingStrategy._SELECTOR_STATE_INVALID);
    addClasses.push(oj.DefaultMessagingStrategy._SELECTOR_STATE_WARNING);
  } else {
    // for all other messages we remove selectors
    removeClasses.push(oj.DefaultMessagingStrategy._SELECTOR_STATE_INVALID);
    removeClasses.push(oj.DefaultMessagingStrategy._SELECTOR_STATE_WARNING);
  }

  jqRoot.removeClass(removeClasses.join(' ')).addClass(addClasses.join(' ')); // classes added to root
  // aria-invalid needs to be on an input/textarea

  this.GetContentElement().attr({
    'aria-invalid': invalid
  });
};
/**
 * Cleans up messaging artifacts that were created on the component instance. E.g., destroys any
 * widgets it created, removes styles added etc.
 *
 * @private
 */


oj.DefaultMessagingStrategy.prototype.deactivate = function () {
  var jqRoot = this.GetComponent().widget();
  jqRoot.removeClass(oj.DefaultMessagingStrategy._SELECTOR_STATE_INVALID).removeClass(oj.DefaultMessagingStrategy._SELECTOR_STATE_WARNING);
  this.GetContentElement().removeAttr('aria-invalid');
  oj.DefaultMessagingStrategy.superclass.deactivate.call(this);
};
/**
 * A messaging strategy that uses html5 placeholder (for now) to set/remove placeholder content.
 *
 * @param {Array.<string>} displayOptions an array of messaging artifacts displayed in the placeholder.
 * @constructor
 * @extends {oj.MessagingStrategy}
 * @private
 */


oj.PlaceholderMessagingStrategy = function (displayOptions) {
  this.Init(displayOptions);
};

oj.ComponentMessaging.registerMessagingStrategy(oj.ComponentMessaging._STRATEGY_TYPE.PLACEHOLDER, oj.PlaceholderMessagingStrategy); // Subclass from oj.MessagingStrategy

oj.Object.createSubclass(oj.PlaceholderMessagingStrategy, oj.MessagingStrategy, 'oj.PlaceholderMessagingStrategy');
/**
 * Initializer
 *
 * @param {Array.<string>} displayOptions an array of messaging artifacts displayed in the notewindow.
 * @private
 */

oj.PlaceholderMessagingStrategy.prototype.Init = function (displayOptions) {
  oj.PlaceholderMessagingStrategy.superclass.Init.call(this, displayOptions);
};
/**
 * Sets up a placeholder for the component instance using the converter hint.
 *
 * @param {Object} cm a reference to an instance of oj.ComponentMessaging that provides access to
 * the latest messaging content.
 *
 * @private
 */


oj.PlaceholderMessagingStrategy.prototype.activate = function (cm) {
  oj.PlaceholderMessagingStrategy.superclass.activate.call(this, cm);

  this._refreshPlaceholder();
};

oj.PlaceholderMessagingStrategy.prototype.reactivate = function (newDisplayOptions) {
  oj.PlaceholderMessagingStrategy.superclass.reactivate.call(this, newDisplayOptions);

  this._refreshPlaceholder();
};
/**
 * Returns true if the content being updated includes converterHint prop. This method is an
 * optimization because the update() method is called too often and any time any content changes.
 * The only time PlaceholderMessagingStrategy#update needs to execute is when the converter hint
 * changes.
 *
 * @param {Object=} content the messaging content that is being updated
 * @return {boolean}
 *
 * @private
 */


oj.PlaceholderMessagingStrategy.prototype.shouldUpdate = function (content) {
  return !!(content && content.converterHint !== undefined);
};

oj.PlaceholderMessagingStrategy.prototype.update = function () {
  oj.PlaceholderMessagingStrategy.superclass.update.call(this);

  this._refreshPlaceholder();
}; // a default placeholder is set on the component, and that is typically the converter hint


oj.PlaceholderMessagingStrategy.prototype._refreshPlaceholder = function () {
  var launcher = this.GetLauncher();

  if (this.ShowPlaceholderContent() && launcher) {
    var hints = this.GetConverterHint();
    var content = hints.length ? hints[0] : ''; // don't override the placeholder with the converter hint if it's empty

    if (oj.StringUtils.isEmptyOrUndefined(content)) return;
    var context = {};
    context.internalMessagingSet = true; // to indicate to component that placeholder is being
    // set from messaging module

    this.GetComponent().option({
      placeholder: content
    }, {
      _context: context
    });
  }
};

oj.PlaceholderMessagingStrategy.prototype.ShowPlaceholderContent = function () {
  // we have a placeholder to set/show if we have converterHint set.
  return this.ShowConverterHint();
};
/**
 * The ComponentValidity object represent a component's current validity state. The instance
 * provides specific methods to retrieve info such as <p>
 *  - whether the component is valid <p>
 *  - the messages currently tracked on the component.<p>
 *  - the max severity level of the messages, e.g., fatal, error etc. See oj.Message for details
 *
 * @param {boolean} valid
 * @param {Array} messages
 * @constructor
 * @private
 */


oj.ComponentValidity = function (valid, messages) {
  // TODO: provide methods that allow model implementations to instruct the elements to showMessages,
  // especially the ones marked for 'lazy' notification.
  this.Init(valid, messages);
};
/**
 * whether there are invalid messages among the list of messages.
 *
 * @param {Array} messages list of messages
 * @returns {boolean} true if we have invalid messages; false otherwise
 */


oj.ComponentValidity.isInvalid = function (messages) {
  var maxLevel = Message.getMaxSeverity(messages);

  if (maxLevel >= Message.SEVERITY_LEVEL.ERROR) {
    return true;
  }

  return false;
}; // Subclass from oj.Object


oj.Object.createSubclass(oj.ComponentValidity, oj.Object, 'oj.ComponentValidity');
/**
 * The jquery element whose validity this object describes
 * @param {boolean} valid
 * @param {Array} messages instances of oj.Message
 */

oj.ComponentValidity.prototype.Init = function (valid, messages) {
  oj.ComponentValidity.superclass.Init.call(this);

  this._initialize(valid, messages);
};
/**
 * Returns a boolean true if valid; false if element not valid
 * @returns {boolean}
 * @private
 */


oj.ComponentValidity.prototype.isInvalid = function () {
  return this._invalid;
};
/**
 * Returns an Array or messages that we are marked for immediate display or an empty array.
 * @private
 * @returns {Array}
 */


oj.ComponentValidity.prototype.getMessages = function () {
  return this._messages;
};
/**
 * Returns the max severity level.
 * @return {number}
 * @private
 */


oj.ComponentValidity.prototype.getMaxSeverity = function () {
  return this._maxSeverity;
};
/**
 * Updates the validity state for the component.
 *
 * @param {boolean} valid
 * @param {Array} messages instances of oj.Message
 * @private
 */


oj.ComponentValidity.prototype.update = function (valid, messages) {
  this._initialize(valid, messages);
};

oj.ComponentValidity.prototype._initialize = function (valid, messages) {
  this._compValid = valid;
  this._compMessages = messages;
  this._messages = this._getImmediateMessages(); // messages currently showing

  this._maxSeverity = Message.getMaxSeverity(this._messages); // max severity of messages currently showing

  this._invalid = oj.ComponentValidity.isInvalid(this._messages);
};
/**
 * Returns an array of messages that are marked for immediate display.
 *
 * @return {Array} of messages each an instance of oj.Message
 * @private
 */


oj.ComponentValidity.prototype._getImmediateMessages = function () {
  var messages = this._compMessages || [];
  var immediateMsgs = [];

  for (var index = 0; index < messages.length; index++) {
    var msg = messages[index]; // gather component messages marked for immediate display

    if (!(msg instanceof oj.ComponentMessage) || msg.canDisplay()) {
      immediateMsgs.push(msg);
    }
  }

  return immediateMsgs;
};



/**
 * JET component custom element bridge.
 *
 * This bridge ensures that JET components with child JET custom elements
 * can access child properties before the child busy state resolves.
 * This bridge does not guarantee that all properties for the child
 * will be available to the application before its busy states resolves,
 * e.g data bound attribute values.
 *
 * Applications should still wait on the element or page level
 * busy context before accessing properties or methods.
 *
 * @class
 * @ignore
 */
oj.CustomElementBridge = {};
/* global Logger:false, MetadataUtils:false */

/**
 * Prototype for the JET component custom element bridge instance
 */

oj.CustomElementBridge.proto = Object.create(oj.BaseCustomElementBridge.proto);
oj.CollectionUtils.copyInto(oj.CustomElementBridge.proto, {
  AddComponentMethods: function AddComponentMethods(proto) {
    // Add subproperty getter/setter
    // eslint-disable-next-line no-param-reassign
    proto.setProperty = function (prop, value) {
      var bridge = oj.BaseCustomElementBridge.getInstance(this);

      if (!bridge.SaveEarlyPropertySet(prop, value)) {
        if (!bridge._setEventProperty(this, prop, value) && !bridge._validateAndSetCopyProperty(this, prop, value, null)) {
          // If not an event or copy property, check to see if it's a component specific property
          var meta = oj.BaseCustomElementBridge.__GetPropertyMetadata(prop, oj.BaseCustomElementBridge.getProperties(bridge)); // For non component specific properties, just set directly on the element instead.


          if (!meta) {
            this[prop] = value;
          } else {
            oj.CustomElementBridge._getPropertyAccessor(this, prop)(value);
          }
        }
      }
    }; // eslint-disable-next-line no-param-reassign


    proto.getProperty = function (prop) {
      var bridge = oj.BaseCustomElementBridge.getInstance(this);

      var meta = oj.BaseCustomElementBridge.__GetPropertyMetadata(prop, oj.BaseCustomElementBridge.getProperties(bridge));

      var event = oj.__AttributeUtils.eventListenerPropertyToEventType(prop); // For event listeners and non component specific properties, return the property from the element.
      // Otherwise, return the widget property and let the widget handle dot notation for subproperties.


      if (event || !meta) {
        return this[prop];
      }

      var ext = meta ? meta.extension : null;

      if (ext && ext._COPY_TO_INNER_ELEM) {
        return bridge._getCopyProperty(this, prop, meta);
      }

      return oj.CustomElementBridge._getPropertyAccessor(this, prop)();
    }; // Override HTMLELement's focus/blur methods so we can call focus/blur on an inner element if needed.
    // eslint-disable-next-line no-param-reassign


    proto.focus = function () {
      var bridge = oj.BaseCustomElementBridge.getInstance(this); // If focus is called before the component has been created there
      // will be no saved widget instance yet so call the HTMLElement
      // focus instead.

      if (bridge._WIDGET_INSTANCE) {
        var focusElem = bridge._WIDGET_INSTANCE.__getFocusElement();

        if (focusElem) {
          if (focusElem !== this) {
            focusElem.focus();
          } else {
            HTMLElement.prototype.focus.call(this);
          }
        }
      } else {
        HTMLElement.prototype.focus.call(this);
      }
    }; // eslint-disable-next-line no-param-reassign


    proto.blur = function () {
      var bridge = oj.BaseCustomElementBridge.getInstance(this);

      if (bridge._WIDGET_INSTANCE) {
        var focusElem = bridge._WIDGET_INSTANCE.__getFocusElement();

        if (focusElem) {
          if (focusElem !== this) {
            focusElem.blur();
          } else {
            HTMLElement.prototype.blur.call(this);
          }
        }
      } else {
        HTMLElement.prototype.focus.call(this);
      }
    };
  },
  BatchedPropertySet: function BatchedPropertySet(elem, props) {
    var keys = Object.keys(props);
    var processedMap = {};
    var i;

    for (i = 0; i < keys.length; i++) {
      var property = keys[i];
      var value = props[property]; // exclude event proprties and transfer attributes from batch updates

      if (!this._setEventProperty(elem, property, value) && !this._validateAndSetCopyProperty(elem, property, value, null)) {
        value = this.ValidatePropertySet(elem, property, value);
        property = this.GetAliasForProperty(property);
        processedMap[property] = value;
      }
    } // Skip batched property sets if widget constructor isn't available meaning
    // the widget wasn't instantiated due to an error on creation or destroyed.


    var widgetConstructor = oj.Components.__GetWidgetConstructor(this._WIDGET_ELEM);

    if (widgetConstructor) {
      widgetConstructor('option', processedMap);
    } else {
      for (i = 0; i < keys.length; i++) {
        var key = keys[i];
        elem.setProperty(key, props[key]);
      }
    }
  },
  CreateComponent: function CreateComponent(element) {
    var innerDomFun = this._INNER_DOM_FUNCTION;
    this._WIDGET_ELEM = oj.CustomElementBridge._getWidgetElement(element, innerDomFun ? innerDomFun(element) : this._EXTENSION._INNER_ELEM); // Transfer global attributes and copy tagged properties to child element if one exists

    if (this._WIDGET_ELEM !== element) {
      var transferAttrs = this._EXTENSION._GLOBAL_TRANSFER_ATTRS || [];

      for (var i = 0; i < transferAttrs.length; i++) {
        var attr = transferAttrs[i];

        if (element.hasAttribute(attr)) {
          this._WIDGET_ELEM.setAttribute(attr, element.getAttribute(attr)); // @HTMLUpdateOK
          // Remove attribute from custom element after transfering value to inner element
          // Set a flag so we know that we're removing the attribute, not app so
          // that on attribute changed we don't remove it again


          this._removingTransfer = true;
          element.removeAttribute(attr);
        }
      }

      this._copyProperties();
    }

    oj.Components.unmarkPendingSubtreeHidden(element); // Initialize jQuery object with options and pass element as wrapper if needed

    var locator = $(this._WIDGET_ELEM);

    var widgetConstructor = $(this._WIDGET_ELEM)[this._EXTENSION._WIDGET_NAME].bind(locator);

    widgetConstructor(this._PROPS);
    this._WIDGET = widgetConstructor;
    this._WIDGET_INSTANCE = widgetConstructor('instance');

    if (this._WRITEBACK_PROPS) {
      this._WIDGET_INSTANCE.__saveWritebackOptions(this._WRITEBACK_PROPS);
    } // Setup blur/focus listeners on inner element so we can trigger on the root custom element for 


    var getFocusEventPropagator = function getFocusEventPropagator(type) {
      return function (event) {
        // Ensure that the target is the custom element, not the inner element, so create
        // a new event and dispatch on the custom element.
        element.dispatchEvent(new FocusEvent(type, {
          relatedTarget: event.relatedTarget
        }));
      };
    };

    var focusElem = this._WIDGET_INSTANCE.__getFocusElement();

    if (focusElem && focusElem !== element) {
      focusElem.addEventListener('focus', getFocusEventPropagator('focus'));
      focusElem.addEventListener('blur', getFocusEventPropagator('blur'));
    } // Set flag when we can fire property change events


    this.__READY_TO_FIRE = true; // Resolve the component busy state

    this.resolveDelayedReadyPromise();
  },
  DefineMethodCallback: function DefineMethodCallback(proto, method, methodMeta) {
    // eslint-disable-next-line no-param-reassign
    proto[method] = function () {
      var bridge = oj.BaseCustomElementBridge.getInstance(this);
      var methodName = methodMeta.internalName || method; // Pass in null as thisArg to apply since the widget constructor is prebound to the jQuery element

      return bridge._WIDGET.apply(null, [methodName].concat([].slice.call(arguments)));
    };
  },
  DefinePropertyCallback: function DefinePropertyCallback(proto, property, propertyMeta) {
    var ext = propertyMeta.extension;
    Object.defineProperty(proto, property, {
      enumerable: true,
      get: function get() {
        var bridge = oj.BaseCustomElementBridge.getInstance(this);

        if (propertyMeta._eventListener) {
          return bridge.GetEventListenerProperty(property);
        } else if (ext && ext._COPY_TO_INNER_ELEM) {
          return bridge._getCopyProperty(this, property, propertyMeta);
        }

        return oj.CustomElementBridge._getPropertyAccessor(this, property)();
      },
      set: function set(value) {
        var bridge = oj.BaseCustomElementBridge.getInstance(this); // Properties can be set before the component is created. These early
        // sets are actually saved until after component creation and played back.

        if (!bridge.SaveEarlyPropertySet(property, value)) {
          if (propertyMeta._eventListener) {
            bridge.SetEventListenerProperty(this, property, value);
          } else if (!bridge._validateAndSetCopyProperty(this, property, value, propertyMeta)) {
            // For widget based components, see if there is a default value assigned in the
            // metadata if application tries to unset the property. For composites and
            // definitional elements, this is handled in the getter since the bridge handles
            // sets/gets, but for widget based components the bridge only calls through to the
            // widget code which initializes the component to the default value (which should match
            // the metadata default)
            var flags = {};

            if (value === undefined) {
              flags = {
                _context: {
                  skipEvent: true
                }
              }; // eslint-disable-next-line no-param-reassign

              value = MetadataUtils.getDefaultValue(propertyMeta); // Usually the widget logic fires the property changed events, but in this case
              // the app has set undefined, but we're setting the default value on the widget so
              // we'll handle firing the property changed from the bridge code for this case
              // and skip the event in the widget code.

              if (bridge.__READY_TO_FIRE) {
                var previousValue = this[property];

                oj.BaseCustomElementBridge.__FirePropertyChangeEvent(this, property, undefined, previousValue, 'external');
              }
            }

            oj.CustomElementBridge._getPropertyAccessor(this, property, flags)(value);
          }
        }
      }
    });
  },
  GetAttributes: function GetAttributes(metadata) {
    var attrs = oj.BaseCustomElementBridge.getAttributes(metadata.properties);

    if (metadata.extension._GLOBAL_TRANSFER_ATTRS) {
      attrs = attrs.concat(metadata.extension._GLOBAL_TRANSFER_ATTRS);
    } // Private array based API to allow widget based components to specify any
    // additional attributes they want to get notified about, e.g. data-oj-input-id.
    // These attributes will get passed through to the widget via the
    // __handleWatchedAttribute method.


    if (metadata.extension._WATCHED_ATTRS) {
      attrs = attrs.concat(metadata.extension._WATCHED_ATTRS);
    }

    return attrs;
  },
  GetAliasForProperty: function GetAliasForProperty(property) {
    // Aliasing only supported for top level properties
    var alias = this._EXTENSION._ALIASED_PROPS;

    if (alias && alias[property]) {
      return alias[property];
    }

    return property;
  },
  InitializeElement: function InitializeElement(element) {
    // Invoke callback on the superclass
    oj.BaseCustomElementBridge.proto.InitializeElement.call(this, element);

    if (this._EXTENSION._CONTROLS_SUBTREE_HIDDEN) {
      oj.Components.markPendingSubtreeHidden(element);
    }

    oj.BaseCustomElementBridge.__InitProperties(element, this._PROPS);
  },
  HandleAttributeChanged: function HandleAttributeChanged(element, attr, oldValue, newValue) {
    var transferAttrs = this._EXTENSION._GLOBAL_TRANSFER_ATTRS;
    var bTransfer = transferAttrs && transferAttrs.indexOf(attr) !== -1;
    var watchedAttrs = this._EXTENSION._WATCHED_ATTRS;
    var bWatchedAttr = watchedAttrs && watchedAttrs.indexOf(attr) !== -1;

    if (bTransfer && this._WIDGET_ELEM) {
      if (!this._removingTransfer) {
        // When we transfer the attribute the app will not be able to remove the
        // attribute from the DOM, we will recommend binding the value if the value
        // needs to be toggled.
        this._WIDGET_ELEM.setAttribute(attr, newValue); // @HTMLUpdateOK
        // Remove attribute from custom element after transfering value to inner element
        // Set a flag so we know that we're removing the attribute, not app so
        // that on attribute changed we don't remove it again


        this._removingTransfer = true;
        element.removeAttribute(attr);
      } else if (this._removingTransfer) {
        this._removingTransfer = false;
      }
    } else if (bWatchedAttr && oldValue !== newValue && this._WIDGET_INSTANCE) {
      // Check to see if this is attribute is being watched by the component
      // in which case we will just pass this through as is without converting
      // the attribute to a property name. Components are responsible for retrieving
      // attribute values on component initialization. This method only handles changes
      // after the fact.
      this._WIDGET_INSTANCE.__handleWatchedAttribute(attr, oldValue, newValue);
    }
  },
  HandleDetached: function HandleDetached(element) {
    // Invoke callback on the superclass
    oj.BaseCustomElementBridge.proto.HandleDetached.call(this, element); // Only call __handleDisconnected if the component hasn't previously
    // been destroyed which we can check by seeing if the widget constructor is null

    if (oj.Components.__GetWidgetConstructor(this._WIDGET_ELEM) && this._WIDGET_INSTANCE) {
      this._WIDGET_INSTANCE.__handleDisconnected();
    }
  },
  HandleReattached: function HandleReattached(element) {
    // Invoke callback on the superclass
    oj.BaseCustomElementBridge.proto.HandleReattached.call(this, element);

    if (this._WIDGET_INSTANCE) {
      this._WIDGET_INSTANCE.__handleConnected();
    }
  },
  InitializeBridge: function InitializeBridge(element, descriptor) {
    // Invoke callback on the superclass
    oj.BaseCustomElementBridge.proto.InitializeBridge.call(this, element, descriptor);
    this._INNER_DOM_FUNCTION = descriptor.innerDomFunction;
    this._EXTENSION = this.METADATA.extension || {};
    this._PROPS = this._EXTENSION._INNER_ELEM || this._INNER_DOM_FUNCTION ? {
      _wrapper: element
    } : {};

    this._setupPropertyAccumulator(element, this._PROPS); // Checks metadata for copy and writeback properties


    this._processProperties();
  },
  _copyProperties: function _copyProperties() {
    // Copies properties from the bridge _PROPS before the widget is instantiated
    // removing copied props from the object
    if (this._COPY_ATTRS) {
      for (var i = 0; i < this._COPY_ATTRS.length; i++) {
        var attr = this._COPY_ATTRS[i];

        var propName = oj.__AttributeUtils.attributeToPropertyName(attr);

        if (Object.prototype.hasOwnProperty.call(this._PROPS, propName)) {
          var value = this._PROPS[propName];

          this._setCopyProperty(attr, value); // Delete the attribute we just copied from the options that we
          // instantiate the widget with


          delete this._PROPS[propName];
        }
      }
    }
  },
  _getCopyProperty: function _getCopyProperty(elem, prop, propMeta) {
    var attrName = oj.__AttributeUtils.propertyNameToAttribute(prop);

    var ext = propMeta.extension;

    if (ext._ATTRIBUTE_ONLY) {
      if (this._WIDGET_ELEM.hasAttribute(attrName)) {
        var value = this._WIDGET_ELEM.getAttribute(attrName);

        var coercedValue;

        try {
          coercedValue = oj.__AttributeUtils.coerceValue(elem, attrName, value, propMeta.type);
        } catch (ex) {
          this.throwError(elem, 'Error parsing attribute value.', ex);
        }

        return coercedValue;
      }

      return null;
    }

    return this._WIDGET_ELEM[prop];
  },
  _processProperties: function _processProperties() {
    var props = oj.BaseCustomElementBridge.getProperties(this);

    if (props) {
      var propKeys = Object.keys(props);

      for (var i = 0; i < propKeys.length; i++) {
        var propName = propKeys[i];
        var propMeta = props[propName]; // Store writeback properties on the bridge and set on widget when we instantiate it later

        if (propMeta.writeback) {
          if (!this._WRITEBACK_PROPS) {
            this._WRITEBACK_PROPS = {};
          }

          this._WRITEBACK_PROPS[propName] = true;
        } // Store properties to copy to inner element for easy lookup


        var ext = propMeta.extension;

        if (ext && ext._COPY_TO_INNER_ELEM) {
          if (!this._COPY_ATTRS) {
            this._COPY_ATTRS = [];
          }

          this._COPY_ATTRS.push(propName);
        }
      }
    }
  },
  _setCopyProperty: function _setCopyProperty(attribute, value) {
    if (value == null || value === false) {
      this._WIDGET_ELEM.removeAttribute(attribute);
    } else if (value === true) {
      this._WIDGET_ELEM.setAttribute(attribute, ''); // @HTMLUpdateOK

    } else {
      this._WIDGET_ELEM.setAttribute(attribute, value); // @HTMLUpdateOK

    }
  },
  _setupPropertyAccumulator: function _setupPropertyAccumulator(element, widgetOptions) {
    // Add an element function that will track property values until expressions are all evaluated.
    // This object will be replaced with the actual widget constructor.
    this._WIDGET = function (method, prop, value) {
      // Allow property access before widget is created for element binding and dynamic element creation
      if (method === 'option') {
        oj.BaseCustomElementBridge.__SetProperty(this.GetAliasForProperty.bind(this), widgetOptions, prop, value);

        return widgetOptions[prop];
      } // throw is eslint hack to fix consistent-return


      throw this.throwError(element, 'Cannot access methods before element is upgraded.');
    };
  },
  _validateAndSetCopyProperty: function _validateAndSetCopyProperty(elem, prop, value, propMeta) {
    // propMeta is could be null so we should retrieve it if not passed in
    var attrName = oj.__AttributeUtils.propertyNameToAttribute(prop);

    var isCopy = this._COPY_ATTRS && this._COPY_ATTRS.indexOf(attrName) !== -1; // If widget hasn't been instantiated skip setting until CreateComponent

    if (isCopy) {
      // We need to validate the value so that we don't copy an invalid value.
      // eslint-disable-next-line no-param-reassign
      value = this.ValidatePropertySet(elem, prop, value);

      if (this._WIDGET_ELEM) {
        if (!propMeta) {
          // eslint-disable-next-line no-param-reassign
          propMeta = oj.BaseCustomElementBridge.__GetPropertyMetadata(prop, oj.BaseCustomElementBridge.getProperties(this));
        }

        var previousValue = this._getCopyProperty(elem, prop, propMeta);

        this._setCopyProperty(attrName, value); // Fire a property change event for the copy properties since we don't actually pass
        // these to the widget. The widget will never update these properties themselves so
        // all updates are external.


        oj.BaseCustomElementBridge.__FirePropertyChangeEvent(elem, prop, this._getCopyProperty(elem, prop, propMeta), previousValue, 'external');
      } else {
        // Save the value until inner widget is created and we can copy them over
        this._PROPS[attrName] = value;
      }
    }

    return isCopy;
  },
  _setEventProperty: function _setEventProperty(elem, prop, value) {
    var isEvent = false;

    var event = oj.__AttributeUtils.eventListenerPropertyToEventType(prop);

    if (event) {
      // eslint-disable-next-line no-param-reassign
      elem[prop] = value;
      isEvent = true;
    }

    return isEvent;
  }
});
/** ***********************/

/* PUBLIC STATIC METHODS */

/** ***********************/

/**
 * Returns the metadata object for the given component.
 * @param  {string} tagName        The component tag name
 * @return {Object}                The component metadata object
 * @ignore
 */

oj.CustomElementBridge.getMetadata = function (tagName) {
  return oj.CustomElementBridge._METADATA_MAP[tagName.toLowerCase()];
};
/**
 * Checks whether the specified event type was declared in the metadata for this custom element
 * @param {Element} element the custom element
 * @param {string} type the event type (e.g. "beforeExpand")
 * @return {boolean} true if the event type was declared in the metadata, false otherwise
 * @ignore
 */


oj.CustomElementBridge.isKnownEvent = function (element, type) {
  var bridge = oj.BaseCustomElementBridge.getInstance(element);
  return (bridge.METADATA.events && bridge.METADATA.events[type]) != null;
};
/**
 * Checks whether the specified property was declared in the metadata for this custom element
 * @param {Element} element the custom element
 * @param {string} prop the property name (e.g. "selection")
 * @return {boolean} true if the property was declared in the metadata, false otherwise
 * @ignore
 */


oj.CustomElementBridge.isKnownProperty = function (element, prop) {
  var bridge = oj.BaseCustomElementBridge.getInstance(element);
  return (bridge.METADATA.properties && bridge.METADATA.properties[prop]) != null;
};
/**
 * Returns the custom element property for a given aliased component property which can be used
 * for converting an internal optionChange event, e.g. returning readonly for oj-switch's readOnly
 * property so we can fire a readonly-changed event instead of readOnly-changed.
 * Will return the original property if there is no aliasing.
 * @param {Element} element The custom element
 * @param {string} property The component property
 * @return {string}
 * @ignore
 */


oj.CustomElementBridge.getPropertyForAlias = function (element, property) {
  // Aliasing only supported for top level properties
  var bridge = oj.BaseCustomElementBridge.getInstance(element);
  var alias = bridge._EXTENSION._COMPONENT_TO_ELEMENT_ALIASES;

  if (alias && alias[property]) {
    return alias[property];
  }

  return property;
};
/**
 * Registers a component as a custom element.
 * @param {string} tagName The component tag name (all lower case), which should contain a dash '-' and not be a reserved tag name.
 * @param {Object} descriptor The registration descriptor. The descriptor will contain keys for metadata and other component overrides.
 * @param {Object} descriptor.metadata The JSON object containing info like the widget name, whether component has an inner element, an outer wrapper, and the component metadata.
 * @param {function(string, string, Object, function(string))} descriptor.parseFunction The function that will be called to parse attribute values.
 * Note that this function is only called for non bound attributes. The parseFunction will take the following parameters:
 * <ul>
 *  <li>{string} value: The value to parse.</li>
 *  <li>{string} name: The name of the attribute.</li>
 *  <li>{Object} meta: The metadata object for the property which can include its type, default value,
 *      and any extensions that the composite has provided on top of the required metadata.</li>
 *  <li>{function(string)} defaultParseFunction: The default parse function for the given attribute
 *      type which is used when a custom parse function isn't provided and takes as its parameters
 *      the value to parse.</li>
 * </ul>
 * @param {Element} descriptor.innerDomFunction The function that will be called to return the tag name of the inner DOM element, e.g. 'button' or 'a'
 * The innerDomFunction will take the following parameters:
 * <ul>
 *  <li>{Element} element: The component custom element.</li>
 * </ul>
 * @ignore
 */


oj.CustomElementBridge.register = function (tagName, descriptor) {
  var meta = descriptor[oj.BaseCustomElementBridge.DESC_KEY_META];
  meta = oj.BaseCustomElementBridge.__ProcessEventListeners(meta); // eslint-disable-next-line no-param-reassign

  descriptor[oj.BaseCustomElementBridge.DESC_KEY_META] = meta;
  oj.CustomElementBridge._METADATA_MAP[tagName.toLowerCase()] = meta;
  var ext = meta.extension; // Use the simple definitional element prototype if no real widget is associated with this custom element

  var proto = ext && ext._WIDGET_NAME ? oj.CustomElementBridge.proto : oj.DefinitionalElementBridge.proto; // Create component to element property alias mapping for easy optionChange lookup and stash it in the extension object

  var aliasMap = ext._ALIASED_PROPS;

  if (aliasMap) {
    ext._COMPONENT_TO_ELEMENT_ALIASES = {};
    var aliases = Object.keys(aliasMap);
    aliases.forEach(function (alias) {
      ext._COMPONENT_TO_ELEMENT_ALIASES[aliasMap[alias]] = alias;
    });
  }

  if (oj.BaseCustomElementBridge.__Register(tagName, descriptor, proto)) {
    customElements.define(tagName.toLowerCase(), proto.getClass(descriptor));
  }
};
/** ***************************/

/* NON PUBLIC STATIC METHODS */

/** ***************************/

/**
 * Returns a property accessor for setting/getting options
 * @private
 */


oj.CustomElementBridge._getPropertyAccessor = function (element, property, flags) {
  function optionAccessor(value) {
    var bridge = oj.BaseCustomElementBridge.getInstance(element); // option set case

    if (arguments.length === 1) {
      // eslint-disable-next-line no-param-reassign
      value = bridge.ValidatePropertySet(element, property, value); // eslint-disable-next-line no-param-reassign

      property = bridge.GetAliasForProperty(property);

      bridge._WIDGET('option', property, value, flags);

      return undefined;
    } // option get case
    // eslint-disable-next-line no-param-reassign


    property = bridge.GetAliasForProperty(property);
    return bridge._WIDGET('option', property);
  }

  return optionAccessor.bind(element);
};
/**
 * Returns the element that the widget constructor will be instantiated on which can be the custom element or a child element.
 * @private
 */


oj.CustomElementBridge._getWidgetElement = function (element, innerTagName) {
  // If component widget is bound to an inner child element like <ul> for <oj-list-view>,
  // create one only if the application does not provide it.
  var widgetElem = element;

  if (innerTagName) {
    var firstChild = element.firstElementChild;

    if (firstChild && firstChild.tagName.toLowerCase() === innerTagName) {
      widgetElem = firstChild;
    } else {
      widgetElem = document.createElement(innerTagName); // @HTMLUpdateOK
      // Make a copy of the custom element children before appending the inner element

      var children = [];
      var nodeList = element.childNodes;

      for (var i = 0; i < nodeList.length; i++) {
        children.push(nodeList[i]);
      }

      element.appendChild(widgetElem); // @HTMLUpdateOK
      // If we create the inner child element, check to see if there are any children
      // to move like for <oj-button> which can have a child elements that should be moved to
      // the newly created inner <button> element.

      while (children.length) {
        var child = children.shift(); // Only move default slot children to inner child element. Default slot children are those
        // that do not explictly set a slot attribute (or have one passed from a composite) or have slot=''.
        // The component will be responsible for moving all named slot children.
        // For example, it does not make sense for <oj-list-view> to move contextMenu slot to its inner <ul> element.

        if (!oj.BaseCustomElementBridge.getSlotAssignment(child)) {
          widgetElem.appendChild(child);
        }
      }
    } // add data-oj-internal attribute for automation tests


    widgetElem.setAttribute('data-oj-internal', '');
  }

  return widgetElem;
};
/**
 * Map of registered custom element names
 * @private
 */


oj.CustomElementBridge._METADATA_MAP = {};

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }


var DataProviderFeatureChecker = /*#__PURE__*/function () {
  function DataProviderFeatureChecker() {
    _classCallCheck(this, DataProviderFeatureChecker);
  }

  _createClass(DataProviderFeatureChecker, null, [{
    key: "isDataProvider",
    value: function isDataProvider(dataprovider) {
      if (dataprovider['fetchFirst']) {
        return true;
      }

      return false;
    }
  }, {
    key: "isTreeDataProvider",
    value: function isTreeDataProvider(dataprovider) {
      if (dataprovider['getChildDataProvider']) {
        return true;
      }

      return false;
    }
  }]);

  return DataProviderFeatureChecker;
}();

oj.DataProviderFeatureChecker = DataProviderFeatureChecker;



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * Utilities for getting DataProvider features.
 * @ignore
 */

/**
 * End of jsdoc
 */



/* global Logger:false, MetadataUtils:false, DefaultsUtils:false */

/**
 * A bridge for a custom element that renders using a constructor
 * function. Note that when a constructor function is provided, the new instance isn't
 * created until the CreateComponent method so property changes that occur before the
 * component instance is created will no-op.
 *
 * Components that provide a constructor function should implement the following methods:
 * createDOM - Called when the component is instantiated
 * updateDOM - Called after createDOM and when the component needs to do a full render on
 * refresh and property changes if the component is not handling them separately.
 * handlePropertyChanged - (optional) Called when properties change and should return true if
 * the component has handled the property change and does not need to do a full render. If
 * false is returned, updateDOM will be called to do a full render.
 * static getDynamicDefaults - (optional) An optional method that can return an object with
 * non JSON compatible default values or getters for properties with dynamic default values,
 * e.g. theme dependent properties. If a default for a property is also found in metadata,
 * the dynamic value will be ignored.
 *
 * When the constructor function is called, the bridge will pass a context object
 * with the following keys:
 * element - The custom element
 * props - A proxy for the element properties with setter/getter and setProperty APIs allowing the
 *         component to control writeback.
 * unique - A unique ID that the component can append to the custom element ID to generate unique IDs
 *
 * Note that components supporting the constructor function approach may eventually
 * be refactored into composites once composites support non template rendering.
 *
 * This bridge ensures that JET components with child JET custom elements
 * can access child properties before the child busy state resolves.
 * This bridge does not guarantee that all properties for the child
 * will be available to the application before its busy states resolves,
 * e.g data bound attribute values.
 *
 * Applications should still wait on the element or page level
 * busy context before accessing properties or methods.
 *
 * @class
 * @ignore
 */
oj.DefinitionalElementBridge = {};
/**
 * Prototype for the JET component definitional bridge instance
 */

oj.DefinitionalElementBridge.proto = Object.create(oj.BaseCustomElementBridge.proto);
oj.CollectionUtils.copyInto(oj.DefinitionalElementBridge.proto, {
  beforePropertyChangedEvent: function beforePropertyChangedEvent(element, property, detail) {
    // Call the renderer function so the definitional element can refresh its UI
    var changedProp = property;
    var value = detail.value;

    if (detail.subproperty) {
      changedProp = detail.subproperty.path;
      value = detail.subproperty.value;
    }

    this._partialRender(element, changedProp, value);
  },
  AddComponentMethods: function AddComponentMethods(proto) {
    // Add refresh and subproperty getter/setter methods for all definitional elements
    // eslint-disable-next-line no-param-reassign
    proto.refresh = function () {
      var bridge = oj.BaseCustomElementBridge.getInstance(this);

      bridge._fullRender(this);
    }; // eslint-disable-next-line no-param-reassign


    proto.setProperty = function (prop, value) {
      var bridge = oj.BaseCustomElementBridge.getInstance(this);

      if (!bridge.SaveEarlyPropertySet(prop, value)) {
        bridge.SetProperty(this, prop, value, this, true);
      }
    }; // eslint-disable-next-line no-param-reassign


    proto.getProperty = function (prop) {
      // 'this' is the property object we pass to the definitional element contructor to track internal property changes
      var bridge = oj.BaseCustomElementBridge.getInstance(this);
      return bridge.GetProperty(this, prop, this);
    }; // eslint-disable-next-line no-param-reassign


    proto._propsProto.setProperty = function (prop, value) {
      // 'this' is the property object we pass to the definitional element contructor to track internal property changes
      this._BRIDGE.SetProperty(this._ELEMENT, prop, value, this, false);
    }; // eslint-disable-next-line no-param-reassign


    proto._propsProto.getProperty = function (prop) {
      return this._BRIDGE.GetProperty(this, prop, this);
    };
  },
  CreateComponent: function CreateComponent(element) {
    oj.Components.unmarkPendingSubtreeHidden(element);

    if (!this._INSTANCE && this._EXTENSION._CONSTRUCTOR) {
      // We expose a similar set of properties as composites except that props is
      // not a Promise and we don't expose any slot information.
      // At the moment some definitional elements have mutation observers so they don't need
      // to rely on refresh being called to be alerted of new children so any cached slotMap
      // can become out of sync. We should add this once we build in support to auto detect
      // added/removed children to custom elements.
      var unique = oj.__AttributeUtils.getUniqueId();

      this._CONTEXT = {
        element: element,
        props: this._PROPS_PROXY,
        unique: unique
      };
      this._CONTEXT.uniqueId = element.id ? element.id : unique;
      this._INSTANCE = new this._EXTENSION._CONSTRUCTOR(this._CONTEXT); // Let the component initialize any additional DOM and then do a full render

      if (this._INSTANCE.createDOM) {
        this._INSTANCE.createDOM();
      }

      if (this._INSTANCE.updateDOM) {
        this._INSTANCE.updateDOM();
      }
    } // Set flag when we can fire property change events


    this.__READY_TO_FIRE = true; // Resolve the component busy state

    this.resolveDelayedReadyPromise();
  },
  DefineMethodCallback: function DefineMethodCallback(proto, method, methodMeta) {
    // eslint-disable-next-line no-param-reassign
    proto[method] = function () {
      var bridge = oj.BaseCustomElementBridge.getInstance(this);

      if (bridge._INSTANCE) {
        var methodName = methodMeta.internalName || method;
        return bridge._INSTANCE[methodName].apply(bridge._INSTANCE, arguments);
      }

      return undefined;
    };
  },
  DefinePropertyCallback: function DefinePropertyCallback(proto, property, propertyMeta) {
    function set(value, bOuterSet) {
      // Properties can be set before the component is created. These early
      // sets are actually saved until after component creation and played back.
      if (!this._BRIDGE.SaveEarlyPropertySet(property, value)) {
        var previousValue = this._BRIDGE._PROPS[property];

        if (!oj.BaseCustomElementBridge.__CompareOptionValues(property, propertyMeta, value, previousValue)) {
          // Skip validation for inner sets so we don't throw an error when updating readOnly writeable properties
          if (bOuterSet) {
            // eslint-disable-next-line no-param-reassign
            value = this._BRIDGE.ValidatePropertySet(this._ELEMENT, property, value);
          }

          if (propertyMeta._eventListener) {
            this._BRIDGE.SetEventListenerProperty(this._ELEMENT, property, value);

            this._BRIDGE._PROPS[property] = value;
          } else {
            this._BRIDGE._PROPS[property] = value;

            oj.BaseCustomElementBridge.__FirePropertyChangeEvent(this._ELEMENT, property, value, previousValue, bOuterSet ? 'external' : 'internal');
          }
        } else {
          Logger.info(oj.BaseCustomElementBridge.getElementInfo(this._ELEMENT) + ": Ignoring property set for property '" + property + "' with same value.");
        }
      }
    }

    function innerSet(value) {
      set.bind(this)(value, false);
    } // Called on the custom element


    function outerSet(value) {
      var bridge = oj.BaseCustomElementBridge.getInstance(this);
      set.bind(bridge._PROPS_PROXY)(value, true);
    }

    function get() {
      var value = this._BRIDGE._PROPS[property]; // If the attribute has not been set, return the default value

      if (value === undefined) {
        value = this._BRIDGE._getDefaultValue(property, propertyMeta);
        this._BRIDGE._PROPS[property] = value;
      }

      return value;
    }

    function innerGet() {
      return get.bind(this)();
    } // Called on the custom element


    function outerGet() {
      var bridge = oj.BaseCustomElementBridge.getInstance(this);
      return get.bind(bridge._PROPS_PROXY)();
    } // Don't add event listener properties for inner props


    if (!propertyMeta._derived) {
      oj.BaseCustomElementBridge.__DefineDynamicObjectProperty(proto._propsProto, property, innerGet, innerSet);
    }

    oj.BaseCustomElementBridge.__DefineDynamicObjectProperty(proto, property, outerGet, outerSet);
  },
  InitializeElement: function InitializeElement(element) {
    // Invoke callback on the superclass
    oj.BaseCustomElementBridge.proto.InitializeElement.call(this, element);

    if (this._EXTENSION._CONTROLS_SUBTREE_HIDDEN) {
      oj.Components.markPendingSubtreeHidden(element);
    }

    oj.BaseCustomElementBridge.__InitProperties(element, element);
  },
  InitializePrototype: function InitializePrototype(proto) {
    // Invoke callback on the superclass
    oj.BaseCustomElementBridge.proto.InitializePrototype.call(this, proto);
    Object.defineProperty(proto, '_propsProto', {
      value: {}
    });
  },
  InitializeBridge: function InitializeBridge(element, descriptor) {
    // Invoke callback on the superclass
    oj.BaseCustomElementBridge.proto.InitializeBridge.call(this, element, descriptor);
    this._EXTENSION = this.METADATA.extension || {}; // For tracking outer property sets

    this._PROPS = {}; // / For tracking inner property sets

    if (element._propsProto) {
      this._PROPS_PROXY = Object.create(element._propsProto);
      this._PROPS_PROXY._BRIDGE = this;
      this._PROPS_PROXY._ELEMENT = element;
    }
  },
  ShouldRemoveDisabled: function ShouldRemoveDisabled() {
    // Definitional components can opt in to have their disabled attribute removed.
    return this._EXTENSION._SHOULD_REMOVE_DISABLED === true;
  },
  // eslint-disable-next-line no-unused-vars
  _fullRender: function _fullRender(element) {
    if (this._INSTANCE && this._INSTANCE.updateDOM) {
      this._INSTANCE.updateDOM();
    }
  },
  _partialRender: function _partialRender(element, property, value) {
    if (this._INSTANCE) {
      // For partial renders, check to see if the component is handling the property change
      // or if it should do a full render
      var handlePropChangedFun = this._INSTANCE.handlePropertyChanged;
      var fullRender = !handlePropChangedFun || !handlePropChangedFun(property, value);

      if (fullRender && this._INSTANCE.updateDOM) {
        this._INSTANCE.updateDOM();
      }
    }
  },
  _getDefaultValue: function _getDefaultValue(property, propertyMeta) {
    if (this._EXTENSION._CONSTRUCTOR) {
      // The defaults object contains metadata and dynamic defaults
      var defaults = DefaultsUtils.getDefaults(this._EXTENSION._CONSTRUCTOR, this.METADATA, false);
      return defaults[property];
    }

    return MetadataUtils.getDefaultValue(propertyMeta);
  }
});

/* jslint browser: true*/



/**
 * Gesture utilities provided internally for JET components, currently only context menu gesture are available.
 * Moved from ojcomponentcore and made into static methods.
 * @ignore
 */
oj.GestureUtils = {};
/**
 * Event namespace used by context menu internal event registration.
 * Previously we got the namespace from the widget.
 */

oj.GestureUtils._EVENT_NAMESPACE = '.contextMenu';
/**
 * Utility method to tear down any artifacts created by GestureUtils.startDetectContextMenuGesture
 * @param {Element} rootNode the root element of the component
 */

oj.GestureUtils.stopDetectContextMenuGesture = function (rootNode) {
  if (rootNode._clickListener) {
    $(rootNode).off(oj.GestureUtils._EVENT_NAMESPACE).removeClass('oj-menu-context-menu-launcher')[0].removeEventListener('click', rootNode._clickListener, true); // the other 2 contextMenu timeouts don't need to be cleared here

    clearTimeout(rootNode._contextMenuPressHoldTimer); // eslint-disable-next-line no-param-reassign

    delete rootNode._clickListener; // eslint-disable-next-line no-param-reassign

    delete rootNode._contextMenuPressHoldTimer;
  }

  if (rootNode._touchStartAndMouseDownListener) {
    rootNode.removeEventListener('touchstart', rootNode._touchStartAndMouseDownListener, {
      passive: false
    }); // eslint-disable-next-line no-param-reassign

    delete rootNode._touchStartAndMouseDownListener;
  }

  if (rootNode._touchMoveListener) {
    rootNode.removeEventListener('touchmove', rootNode._touchMoveListener, {
      passive: true
    }); // eslint-disable-next-line no-param-reassign

    delete rootNode._touchMoveListener;
  }
};
/**
 * Utility method to setup context menu gesture detection on a component
 * @param {Element} rootNode the root node of the component
 * @param {function(Event, string)} callback callback to invoke on the component when context menu gesture is detected
 */


oj.GestureUtils.startDetectContextMenuGesture = function (rootNode, callback) {
  // Note: Whether or not we use Hammer to detect press-hold, this code would need to do the following things seen below:
  //
  // (1) Prevent the compatibility mousedown event from triggering Menu's clickAway logic.
  // (2) Prevent press-hold from also generating a click (unless Hammer does this automatically; I'm guessing it doesn't).
  // (3) Ensure we don't respond to *both* press-hold and contextmenu events on Android.
  //
  // So the only thing that Hammer would replace is:
  //
  // (4) Detecting the press-hold.
  //
  // Not currently using Hammer for (4), since:
  //
  // - This code predates Hammer, and was already stable after extensive iteration / fine-tuning.
  // - We use the same listeners for parts of 1-4. If moved 4 off to Hammer (separate listener), just need to ensure that
  //   we don't introduce any race conditions, etc.  (May be easy or hard, just need to look.)
  // - Hammer only wants to have one instance per DOM node, else they fight to control some things like touch-action. So
  //   a prereq for having this baseComponent logic put Hammer on components is to work out a protocol for super- and sub-
  //   classes to share the same instance and not step on each other.  Not insurmountable; just need to have the conversation.
  //   Tracked by ER 21357133, which links to detailed wiki.
  var pressHoldThreshold = oj.DomUtils.PRESS_HOLD_THRESHOLD; // launch CM at 750ms per UX spec

  var isPressHold = false; // to prevent pressHold from generating a click

  var contextMenuPressHoldTimer;
  var touchInProgress = false; // 5px is Hammer default.  (Didn't check whether they apply that separately to x and y like us, or to the hypotenuse,
  // but it's within a couple px either way -- think 3-4-5 triangle.)

  var maxAllowedMovement = 5;
  var touchPageX;
  var touchPageY;
  var doubleOpenTimer; // to prevent double open.  see usage below.

  var doubleOpenThreshold = 300; // made up this number.  TBD: Tweak as needed to make all platforms happy.

  var doubleOpenType = null; // "touchstart" or "contextmenu"

  var namespace = oj.GestureUtils._EVENT_NAMESPACE;
  var contextMenuPressHoldJustEnded = false;

  function launch(event, eventType, pressHold) {
    // ensure that pressHold doesn't result in a click.  Set this before the bailouts below.
    isPressHold = pressHold; // In Mobile Safari only, mousedown fires *after* the touchend, which causes at least 2 problems:
    // 1) CM launches after 750ms (good), then disappears when lift finger (bad), because touchend -->
    // mousedown, which calls Menu's "clikAway" mousedown listener, which dismisses Menu.
    // 2) The isPressHold logic needs to reset the isPressHold ivar on any event that can start a click,
    // including mousedown.  This problem causes the mousedown listener to incorrectly clear the ivar
    // after a pressHold, which broke the whole mechanism.
    // SOLUTION FOR 1-2:  On each launch (at 750ms), set a one-time touchend listener that will set a
    // var and clear it 50ms later.  While the var is set, both mousedown listeners can disregard the
    // mousedown.  Make the var a static var in Menu, since Menu's listener is static, and since this
    // launcher component can get/set it via an (effectively static) menu method.
    // NON-SOLUTIONS:  Cancelling touchstart or touchend, via pD() and sP(), doesn't cancel iPad's mousedown.
    // Cancelling mousedown from here doesn't work even if capture phase, since ojMenu's listener is capture phase.
    // TIMING: The following block should be before the doubleOpen bailout.

    if (isPressHold) {
      $(rootNode).one('touchend' + namespace, function () {
        var touchendMousedownThreshold = 50; // 50ms.  Make as small as possible to prevent unwanted side effects.

        contextMenuPressHoldJustEnded = true;
        setTimeout(function () {
          contextMenuPressHoldJustEnded = false;
        }, touchendMousedownThreshold);
      });
    } // On platforms like Android Chrome where long presses already fire the contextmenu event, the pressHold
    // logic causes the menu to open twice, once for the pressHold, once for the contextmenu.  There's no
    // guarantee which will happen first, but as long as they happen within doubleOpenThreshold ms
    // of each other, this logic should prevent the double open.
    // Note: Another option is a platform-specific solution where we only use pressHold for platforms that need
    // it (that don't already fire a contextmenu event for pressHold), but architectural preference is to avoid
    // platform-specific solutions if possible.


    if (doubleOpenType === 'touchstart' && event.type === 'contextmenu' || doubleOpenType === 'contextmenu' && event.type === 'touchstart' || doubleOpenType === 'keydown' && event.type === 'contextmenu') {
      // FF 60.2.2esr (32-bit) Win fires a rogue contextmenu event following the prevented keydown. What's odd is
      // preventing the keydown for shift+F10 prevents keypress but still files the contextmenu event.
      // Seems like "fallout" (behavior not yet correct) from bug https://bugzilla.mozilla.org/show_bug.cgi?id=1382199
      // For this case, prevent the native context menu within double open timeout window
      if (doubleOpenType === 'keydown' && event.type === 'contextmenu') event.preventDefault();
      doubleOpenType = null;
      clearTimeout(doubleOpenTimer);
      return;
    } // If a nested element or component already showed a JET context menu for this event, don't replace it with ours.
    // Hack: must check defaultPrevented on the nested event too, because for touchstart events on iOS7 at least, when
    // the outer component reaches this point, event is a different JQ wrapper event than the one on which the inner
    // component previously called preventDefault, although they both wrap the same native originalEvent.  The new wrapper
    // never had its isDefaultPrevented field set to the returnTrue method, so must check the nested originalEvent.
    // This never seems to happen with right-click and Shift-F10 events.  Has nothing to do with the setTimeout: the events
    // received by the rootNode.on("touchstart"...) code are different (firstWrapper==secondWrapper returns false).
    // TODO: link to JQ bug once filed.


    if (event.isDefaultPrevented && event.isDefaultPrevented() || event.originalEvent && event.originalEvent.defaultPrevented || event.defaultPrevented) {
      return;
    } // for downstream modules still dependent on originalEvent that used
    // to be added by JQuery


    if (event.type === 'touchstart' || event.type === 'touchmove') {
      // eslint-disable-next-line no-param-reassign
      event.originalEvent = event;
    }

    callback(event, eventType); // if _NotifyContextMenuGesture() (or subclass override of it) actually opened the CM, and if that launch wasn't
    // cancelled by a beforeOpen listener...

    if (event.isDefaultPrevented && event.isDefaultPrevented() || event.defaultPrevented) {
      // see double-open comments above
      if (event.type === 'touchstart' || event.type === 'contextmenu' || event.type === 'keydown') {
        doubleOpenType = event.type;
        doubleOpenTimer = setTimeout(function () {
          doubleOpenType = null;
        }, doubleOpenThreshold);
      }
    }
  } // At least some of the time, the pressHold gesture also fires a click event same as a short tap.  Prevent that here.


  var _clickListener = function _clickListener(event) {
    if (isPressHold) {
      // For Mobile Safari capture phase at least, returning false doesn't work; must use pD() and sP() explicitly.
      event.preventDefault();
      event.stopPropagation();
      isPressHold = false;
    }
  }; // eslint-disable-next-line no-param-reassign


  rootNode._clickListener = _clickListener; // Use capture phase to make sure we cancel it before any regular bubble listeners hear it.

  rootNode.addEventListener('click', _clickListener, true);

  var _touchStartAndMouseDownListener = function _touchStartAndMouseDownListener(event) {
    // for mousedown-after-touchend Mobile Safari issue explained above where __contextMenuPressHoldJustEnded is set.
    if (event.type === 'mousedown' && contextMenuPressHoldJustEnded) {
      return undefined;
    } // reset isPressHold flag for all events that can start a click.


    isPressHold = false; // start a pressHold timer on touchstart.  If not cancelled before 750ms by touchend/etc., will launch the CM.
    // isolate the context menu long tap to a single touch point.

    if (event.type === 'touchstart' && event.touches.length === 1) {
      // note starting position so touchmove handler can tell if touch moved too much
      var firstTouch = event.touches[0];
      touchPageX = firstTouch.pageX;
      touchPageY = firstTouch.pageY;
      touchInProgress = true;
      contextMenuPressHoldTimer = setTimeout(launch.bind(undefined, event, 'touch', true), pressHoldThreshold); // @HTMLUpdateOK
      // eslint-disable-next-line no-param-reassign

      rootNode._contextMenuPressHoldTimer = contextMenuPressHoldTimer;
    }

    return true;
  }; // eslint-disable-next-line no-param-reassign


  rootNode._touchStartAndMouseDownListener = _touchStartAndMouseDownListener;
  rootNode.addEventListener('touchstart', _touchStartAndMouseDownListener, {
    passive: false
  });

  var _touchMoveListener = function _touchMoveListener(event) {
    var firstTouch = event.touches[0];

    if (Math.abs(touchPageX - firstTouch.pageX) > maxAllowedMovement || Math.abs(touchPageY - firstTouch.pageY) > maxAllowedMovement) {
      touchInProgress = false;
      clearTimeout(contextMenuPressHoldTimer);
    }

    return true;
  }; // eslint-disable-next-line no-param-reassign


  rootNode._touchMoveListener = _touchMoveListener;
  rootNode.addEventListener('touchmove', _touchMoveListener, {
    passive: true
  });
  $(rootNode).on('mousedown' + namespace, _touchStartAndMouseDownListener) // if the touch moves too much, it's not a pressHold
  // if the touch ends before the 750ms is up, it's not a long enough pressHold to show the CM
  .on('touchend' + namespace + ' ' + 'touchcancel' + namespace, function () {
    touchInProgress = false;
    clearTimeout(contextMenuPressHoldTimer);
    return true;
  }).on('keydown' + namespace + ' ' + 'contextmenu' + namespace, function (event) {
    if (event.type === 'contextmenu' // right-click.  pressHold for Android but not iOS
    || event.which === 121 && event.shiftKey) {
      // Shift-F10
      var eventType;

      if (touchInProgress) {
        eventType = 'touch';
      } else if (event.type === 'keydown') {
        eventType = 'keyboard';
      } else {
        eventType = 'mouse';
      }

      launch(event, eventType, false);
    }

    return true;
  }); // Does 2 things:
  // 1) Prevents native context menu / callout from appearing in Mobile Safari.  E.g. for links, native CM has "Open in New Tab".
  // 2) In Mobile Safari and Android Chrome, prevents pressHold from selecting the text and showing the selection handles and (in Safari) the Copy/Define callout.
  // In UX discussion, we decided to prevent both of these things for all JET components for now.  If problems, can always, say, add protected method allowing
  // subclass to opt out (e.g. if they need 1 and/or 2 to work).
  // Per discussion with architects, do #2 only for touch devices, so that text selection isn't prevented on desktop.  Since #1
  // is a no-op for non-touch, we can accomplish this by omitting the entire style class, which does 1 and 2, for non-touch.
  // Per comments in scss file, the suppression of 1 and 2 has issues in old versions of Mobile Safari.

  if (oj.DomUtils.isTouchSupported()) {
    $(rootNode).addClass('oj-menu-context-menu-launcher');
  }
};



/* jslint browser: true*/

/**
 * in some OS/browser combinations you can attempt to detect high contrast mode
 * in javascript, go to the url below and look for "High Contrast"
 * https://www.w3.org/TR/2016/WD-wai-aria-practices-1.1-20160317/
 *
 * This function uses a variation of the code in the "High Contrast" section of
 * the site above to try and detect high contrast mode
 * by script, but it by no means definitively tells you whether or not you
 * are actually in high contrast mode. As discussed at the url above you
 * may need to have a user preference setting for high contrast.
 *
 * If the script is able to detect high contrast mode it sets the class
 * "oj-hicontrast" on the body tag. When "oj-high-contrast" is present
 * JET provides alternate informational images that are specially designed
 * for high contrast users.
 * @private
 */
function _ojHighContrast() {
  // using a data uri, I googled for shortest uri to get this one since
  // I don't care about the actual image, but I do want a legit image
  // otherwise I see an error in chrome and I don't want users to be
  // confused by seeing any error.
  var div = document.createElement('div');
  div.style.border = '1px solid';
  div.style.borderColor = 'red green';
  div.style.position = 'absolute';
  div.style.top = '-999px';
  div.style.backgroundImage = 'url(data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=)';
  var body = document.body;
  body.appendChild(div); // @HTMLUpdateOK safe manipulation

  var computedStyles = window.getComputedStyle(div);
  var bki = computedStyles.backgroundImage;

  if (computedStyles.borderTopColor === computedStyles.borderRightColor || bki != null && (bki === 'none' || bki === 'url (invalid-url:)')) {
    body.classList.add('oj-hicontrast');
  }

  body.removeChild(div);
}

$(document).ready(function () {
  _ojHighContrast();
});



/* jslint browser: true*/

/**
 * @export
 * @class
 * @since 1.0
 * @classdesc Common test support in JavaScript
 * @ojtsignore
 */
oj.Test = {};
/**
 * A global application flag that can be set by a test to indicate that all page startup processing is done
 * and an external automated test can begin
 * @export
 * @type {boolean}
 */

oj.Test.ready = false;
/**
 * @export
 * Return the node found given the locator
 * @param {Object|string} locator A locator which is either a JSON string (to be parsed using $.parseJSON), or an Object with the following properties:
 *                                             element: the component's selector, determined by the test author when laying out the page
 *                                             subId: the string, documented by the component, that the component expects in getNodeBySubId to locate a particular subcomponent
 *  @returns {any} the subcomponent located by the subId string passed in locator, if found.
 */

oj.Test.domNodeForLocator = function (locator) {
  var locObj = locator;

  if (oj.StringUtils.isString(locator)) {
    var locStr =
    /** @type {string} */
    locator;

    try {
      locObj = JSON.parse(locStr);
    } catch (e) {
      return null;
    }
  }

  if (locObj && locObj.element) {
    var element = $(locObj.element);

    if (element && element.length > 0) {
      delete locObj.element;
      var id =
      /** @type {Object} */
      locObj;
      return oj.Components.getNodeBySubId(element[0], id);
    }
  }

  return null;
};
/**
 * @return {number} total number of open popups
 * @export
 * @since 1.1.0
 */


oj.Test.getOpenPopupCount = function () {
  return oj.ZOrderUtils.getOpenPopupCount();
};
/**
 * Returns a jQuery set of popup root elements that are open and actively
 * managed by the popup framework.
 *
 * @return {!jQuery}
 * @export
 * @since 1.1.0
 */


oj.Test.findOpenPopups = function () {
  return oj.ZOrderUtils.findOpenPopups();
};
/**
 * Utility used for testing. Compares two jQuery singleton wappered elements
 * determining which element has the greatest stacking context.
 *
 * @export
 * @param {jQuery} el1 first element to compare
 * @param {jQuery} el2 second element to compare
 * @return {number} 0 if elements have the same stacking context;
 *                  1 if the first element has a greater stacking context;
 *                 -1 when the second element has a greater stacking context;
 * @since 1.1.0
 */


oj.Test.compareStackingContexts = function (el1, el2) {
  return oj.ZOrderUtils.compareStackingContexts(el1, el2);
};


// override jQuery's cleanData method to bypass cleanup of custom elements and composites
$.cleanData = function (orig) {
  return function (elems) {
    var nonCustomElements = [];

    for (var i = 0; i < elems.length; i++) {
      var elem = elems[i];

      if (elem == null) {
        break;
      } // Skip cleaning any elements that are custom elements or are created by a custom element


      var bSkip = false;

      var constr = oj.Components.__GetWidgetConstructor(elem);

      if (constr) {
        bSkip = constr('instance')._IsCustomElement();

        if (!bSkip) {
          var parent = oj.Components.getComponentElementByNode(elem);
          bSkip = parent && oj.BaseCustomElementBridge.getRegistered(parent.tagName);
        }
      }

      if (!bSkip) {
        nonCustomElements.push(elem);
      }
    }

    if (nonCustomElements.length > 0) {
      orig(nonCustomElements);
    }
  };
}($.cleanData);

  return oj.Components;
});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojindexer',['ojs/ojcore', 'jquery', 'hammerjs', 'ojs/ojcontext', 'ojs/ojtranslation', 'ojs/ojjquery-hammer', 'ojs/ojcomponentcore'],
/*
* @param {Object} oj 
* @param {jQuery} $
* @param {Object} Hammer
*/
function(oj, $, Hammer, Context, Translations)
{
  "use strict";
var __oj_indexer_metadata = 
{
  "properties": {
    "data": {
      "type": "object"
    },
    "translations": {
      "type": "object",
      "value": {},
      "properties": {
        "ariaDisabledLabel": {
          "type": "string"
        },
        "ariaInBetweenText": {
          "type": "string"
        },
        "ariaKeyboardInstructionText": {
          "type": "string"
        },
        "ariaOthersLabel": {
          "type": "string"
        },
        "ariaTouchInstructionText": {
          "type": "string"
        },
        "indexerCharacters": {
          "type": "string"
        },
        "indexerOthers": {
          "type": "string"
        }
      }
    }
  },
  "methods": {
    "refresh": {},
    "setProperty": {},
    "getProperty": {},
    "setProperties": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "extension": {}
};




/* global Promise:false */

/**
 * Implementation of the IndexerModel used by ListView.  This implementation groups the data based on the first letter of the
 * group header text and the alphabet of the current locale.
 * @export
 * @ojtsnoexport
 * @param {Object} listview the internal ListView instance
 * @class oj.ListViewIndexerModel
 * @implements oj.IndexerModel
 * @classdesc Implementation of IndexerModel used by ListView.
 * @extends oj.EventSource
 * @constructor
 * @ignore
 */
oj.ListViewIndexerModel = function (listview) {
  this.listview = listview;
  this.Init();
}; // Subclass from oj.EventSource


oj.Object.createSubclass(oj.ListViewIndexerModel, oj.EventSource, 'oj.ListViewIndexerModel');
/**
 * @export
 * Returns the sections displayed by the Indexer.
 * @returns {Array.<Object>} an array of sections
 * @memberof! oj.ListViewIndexerModel
 */

oj.ListViewIndexerModel.prototype.getIndexableSections = function () {
  var sections = this.listview.ojContext.getTranslatedString('indexerCharacters');
  return sections.split('|');
};
/**
 * @export
 * Returns the sections that are missing in the associated ListView.
 * @return {Array.<Object>} an array of sections that are missing.
 * @memberof! oj.ListViewIndexerModel
 */


oj.ListViewIndexerModel.prototype.getMissingSections = function () {
  if (this.missingSections == null) {
    this.missingSections = this._getMissingSections();
  }

  return this.missingSections;
};
/**
 * Returns the sections that are currently missing.
 * @private
 */


oj.ListViewIndexerModel.prototype._getMissingSections = function () {
  var results = [];

  var groupItems = this.listview._getGroupItemsCache();

  var sections = this.getIndexableSections();
  var i;

  for (i = 0; i < sections.length; i++) {
    var section = sections[i];
    var found = false; // eslint-disable-next-line no-loop-func

    groupItems.each(function () {
      var content = $(this).text();

      if (content.length > 0 && content.charAt(0) === section) {
        found = true;
        return false;
      }

      return true;
    });

    if (!found) {
      results.push(section);
    }
  }

  return results;
};
/**
 * @export
 * Sets the current section.  When associated with a ListView, this will scroll the ListView to the corresponding group header.
 * @param {Object} section the current section
 * @return {Promise} a Promise object which when resolve will return the section that the IndexerModel actually sets as current.
 * @memberof! oj.ListViewIndexerModel
 */


oj.ListViewIndexerModel.prototype.setSection = function (section) {
  if (section === oj.IndexerModel.SECTION_OTHERS) {
    return this._setOtherSection();
  }

  return this._setSection(section);
};
/**
 * Sets the 'Other' section as current
 * @private
 */


oj.ListViewIndexerModel.prototype._setOtherSection = function () {
  var sections = this.getIndexableSections();
  var self = this;
  return new Promise(function (resolve) {
    var match = null; // find the group header that DOES NOT match ANY of the sections

    self.listview._getGroupItemsCache().each(function () {
      var content = $(this).text();

      for (var i = 0; i < sections.length; i++) {
        var section = sections[i];

        if (content.indexOf(section) === 0) {
          // skip and check next group header
          return true;
        }
      }

      match = this;
      return false;
    });

    if (match) {
      self.listview._scrollToGroupHeader(match);

      resolve(oj.IndexerModel.SECTION_OTHERS);
    } else {
      resolve(null);
    }
  });
};
/**
 * Sets the specified section as current.
 * @private
 */


oj.ListViewIndexerModel.prototype._setSection = function (section) {
  var sections = this.getIndexableSections();
  var index = sections.indexOf(section);
  var self = this;
  return new Promise(function (resolve) {
    if (index === -1) {
      // if it's not even in the indexable sections, then we don't need to process anymore
      resolve(null);
    } else {
      var match = null; // try to find the group header, use the next section as needed

      for (; index < sections.length; index++) {
        var _section = sections[index];

        var groupHeader = self._findGroupHeader(_section);

        if (groupHeader != null) {
          self.listview._scrollToGroupHeader(groupHeader);

          match = _section;
          break;
        }
      }

      resolve(match);
    }
  });
};
/**
 * Finds the group header with the specified section
 * @private
 */


oj.ListViewIndexerModel.prototype._findGroupHeader = function (section) {
  var match;

  this.listview._getGroupItemsCache().each(function () {
    var content = $(this).text();

    if (content.indexOf(section) === 0) {
      match = this;
      return false;
    }

    return true;
  });

  return match;
};



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* global Hammer:false, Context:false */
(function () {
  /*!
   * JET Indexer @VERSION
   *
   *
   * Depends:
   *  jquery.ui.widget.js
   */

  /**
   * @ojcomponent oj.ojIndexer
   * @augments oj.baseComponent
   * @since 1.2.0
   *
   * @ojshortdesc An indexer displays a list of sections that corresponds to group headers of a list.
   * @ojrole slider
   *
   * @ojuxspecs ['indexer']
   *
   * @classdesc
   * <h3 id="indexerOverview-section">
   *   JET Indexer Component
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#indexerOverview-section"></a>
   * </h3>
   * <p>Description: The JET Indexer is usually associated with a scrollable JET ListView.  It provides a list of sections that
   *                 corresponds to group headers in ListView.  When a section is selected the corresponding group header will be
   *                 scroll to the top of the ListView.
   * </p>
   *
   * <pre class="prettyprint">
   * <code>
   * &lt;oj-indexer
   *   aria-controls='listview1'
   *   data='{{data}}'>
   * &lt;/oj-indexer>
   * </code>
   * </pre>
   *
   * <h3 id="touch-section">
   *   Touch End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"touchDoc"}
   *
   * <h3 id="keyboard-section">
   *   Keyboard End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"keyboardDoc"}
   *
   * <h3 id="accessibility-section">
   *   Accessibility
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#accessibility-section"></a>
   * </h3>
   * <p>
   * The JET Indexer is accessible - it sets and maintains the appropriate aria- attributes,
   * including <code class="prettyprint">aria-valuenow</code>, <code class="prettyprint">aria-valuemax</code>,
   * <code class="prettyprint">aria-valuemin</code> and <code class="prettyprint">aria-orientation</code>.
   * <p>
   * Application developer should associate a ListView with the Indexer by specifying the id of the ListView in the aria-controls attribute in the Indexer.
   * </p>
   */
  oj.__registerWidget('oj.ojIndexer', $.oj.baseComponent, {
    defaultElement: '<ul>',
    version: '1.2',
    widgetEventPrefix: 'oj',
    options: {
      /**
       * The data model for the Indexer which must be a oj.IndexerModel.  Currently the <a href="oj.IndexerModelTreeDataProvider.html">IndexerModelTreeDataProvider</a>
       * is available that applications can use as the data for both ListView and the Indexer.  If not specified, then an empty indexer is rendered.
       *
       * @ojshortdesc The data provider for the Indexer.
       * @expose
       * @memberof! oj.ojIndexer
       * @instance
       * @type {Object}
       * @ojsignature {target:"Type", value:"IndexerModel", jsdocOverride:true}
       * @default null
       *
       * @example <caption>Initialize the Indexer with an IndexModel:</caption>
       * &lt;oj-indexer data='{{myIndexerModel}}'>&lt;/oj-indexer>
       *
       * @example <caption>Get or set the <code class="prettyprint">data</code> property after initialization:</caption>
       * // getter
       * var dataValue = myIndexer.data;
       *
       * // setter
       * myIndexer.data = myIndexerModel;
       */
      data: null
    },

    /**
     * Creates the indexer
     * @override
     * @memberof! oj.ojIndexer
     * @protected
     */
    _ComponentCreate: function _ComponentCreate() {
      this._super();

      this._setup();
    },

    /**
     * Initialize the indexer after creation
     * @protected
     * @override
     * @memberof! oj.ojIndexer
     */
    _AfterCreate: function _AfterCreate() {
      this._super();

      this._createIndexerContent();

      this._setAriaProperties();

      this._createInstructionText();
    },

    /**
     * Destroy the indexer
     * @memberof! oj.ojIndexer
     * @override
     * @private
     */
    _destroy: function _destroy() {
      this._super();

      var container = this._getIndexerContainer();

      this._unregisterResizeListener(container);

      this._unregisterTouchHandler(container);

      this._unsetAriaProperties();

      this.element.removeClass('oj-component-initnode');
      oj.DomUtils.unwrap(this.element, container);
    },

    /**
     * Sets a single option
     * @memberof! oj.ojIndexer
     * @override
     * @private
     */
    // eslint-disable-next-line no-unused-vars
    _setOption: function _setOption(key, value) {
      this._superApply(arguments);

      if (key === 'data') {
        this.refresh();
      }
    },

    /**
     * Sets up resources needed by indexer
     * @memberof! oj.ojIndexer
     * @instance
     * @override
     * @protected
     */
    _SetupResources: function _SetupResources() {
      this._super(); // register a resize listener and swipe handler


      var container = this._getIndexerContainer()[0];

      this._registerResizeListener(container);

      this._registerTouchHandler(container);
    },

    /**
     * Release resources held by indexer
     * @memberof! oj.ojIndexer
     * @instance
     * @override
     * @protected
     */
    _ReleaseResources: function _ReleaseResources() {
      this._super();

      var container = this._getIndexerContainer()[0];

      this._unregisterResizeListener(container);

      this._unregisterTouchHandler(container); // if there's outstanding busy state, release it now


      this._resolveBusyState();
    },

    /**
     * @private
     */
    _resolveBusyState: function _resolveBusyState() {
      if (this.busyStateResolve) {
        this.busyStateResolve(null);
        this.busyStateResolve = null;
      }
    },

    /**
     * Returns a jQuery object containing the root dom element of the indexer
     * @ignore
     * @expose
     * @override
     * @memberof! oj.ojIndexer
     * @instance
     * @return {jQuery} the root DOM element of the indexer
     */
    widget: function widget() {
      return this._getIndexerContainer();
    },

    /**
     * Redraw the entire indexer after having made some external modification.
     *
     * <p>This method does not accept any arguments.
     *
     * @ojshortdesc Redraw the entire indexer.
     * @expose
     * @memberof! oj.ojIndexer
     * @instance
     * @return {void}
     * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
     * $( ".selector" ).ojIndexer( "refresh" );
     */
    refresh: function refresh() {
      this._super();

      this.element.empty();

      this._createIndexerContent();

      this._setAriaProperties();

      this.m_current = null;
    },
    //* * @inheritdoc */
    getNodeBySubId: function getNodeBySubId(locator) {
      if (locator == null) {
        return this.element ? this.element[0] : null;
      }

      var subId = locator.subId;

      if (subId === 'oj-indexer-section') {
        var section = locator.section;
        var sections = this.element.children('li');

        for (var i = 0; i < sections.length; i++) {
          var node = sections.get(i);
          var data = $(node).data('data-range');

          if (data === section) {
            return node;
          } // it's a separator, check the sections included in the range


          var includes = $(node).data('data-includes');

          if (includes != null) {
            for (var j = 0; j < includes.length; j++) {
              if (includes[j] === section) {
                return node;
              }
            }
          }
        }
      } // Non-null locators have to be handled by the component subclasses


      return null;
    },
    //* * @inheritdoc */
    getSubIdByNode: function getSubIdByNode(node) {
      if (node != null) {
        var section = $(node).data('data-range');

        if (section != null) {
          return {
            subId: 'oj-indexer-section',
            section: section
          };
        }
      }

      return null;
    },

    /** **************************** core rendering **********************************/

    /**
     * Sets wai-aria properties on root element
     * @private
     */
    _setAriaProperties: function _setAriaProperties() {
      this.element.attr('role', 'slider').attr('aria-orientation', 'vertical').attr('aria-describedby', this.element.prop('id') + ':desc').attr('aria-valuemin', 0).attr('aria-valuemax', Math.max(0, this.element.children().length - 1));
    },

    /**
     * Removes wai-aria properties on root element
     * @private
     */
    _unsetAriaProperties: function _unsetAriaProperties() {
      this.element.removeAttr('role').removeAttr('aria-orientation').removeAttr('aria-describedby').removeAttr('aria-valuemin').removeAttr('aria-valuemax').removeAttr('aria-valuetext');
    },

    /**
     * Create instruction text for screen reader
     * @private
     */
    _createInstructionText: function _createInstructionText() {
      var key;

      if (oj.DomUtils.isTouchSupported()) {
        key = 'ariaTouchInstructionText';
      } else {
        key = 'ariaKeyboardInstructionText';
      }

      var text = $(document.createElement('div'));
      text.prop('id', this.element.prop('id') + ':desc');
      text.addClass('oj-helper-hidden-accessible').text(this.getTranslatedString(key));

      this._getIndexerContainer().append(text); // @HTMLUpdateOK

    },

    /**
     * Retrieves the div around the root element, create one if needed.
     * @return {jQuery} the div around the root element
     * @private
     */
    _getIndexerContainer: function _getIndexerContainer() {
      if (this.m_container == null) {
        this.m_container = this._createIndexerContainer();
      }

      return this.m_container;
    },

    /**
     * Creates the div around the root element.
     * @return {jQuery} the div around the root element
     * @private
     */
    _createIndexerContainer: function _createIndexerContainer() {
      var container;

      if (this.OuterWrapper) {
        container = $(this.OuterWrapper);
      } else {
        container = $(document.createElement('div'));
        this.element.parent()[0].replaceChild(container[0], this.element[0]);
      }

      container.addClass('oj-indexer oj-component');
      container.prepend(this.element); // @HTMLUpdateOK

      return container;
    },

    /**
     * @private
     */
    _createIndexerContent: function _createIndexerContent() {
      var model = this._getIndexerModel();

      if (model == null) {
        return;
      }

      var root = this.element;
      var missingSections;
      var sections = model.getIndexableSections();

      if (model.getMissingSections) {
        missingSections = model.getMissingSections();
      }

      var sectionOthers = this.getTranslatedString('indexerOthers');
      var height = this.widget().outerHeight(); // the first character is always present, use it to test height

      var first = this._createItem(sections[0], missingSections);

      root.append(first); // @HTMLUpdateOK
      // remove abbr first otherwise it will affect item height

      this._getIndexerContainer().removeClass('oj-indexer-abbr');

      if (this.m_itemHeight == null) {
        this.m_itemHeight = first.outerHeight();
      } // safeguard this.m_itemHeight from being 0, which shouldn't happen


      var itemHeight = Math.max(1, this.m_itemHeight);
      var max = Math.floor(height / itemHeight); // first +1 is to include the '#', second +1 is to include rendering of the symbol between letters

      var skip = Math.floor((sections.length + 1) / max) + 1;

      if (skip > 1) {
        // the height of item is a little different
        this._getIndexerContainer().addClass('oj-indexer-abbr');
      }

      for (var i = 1 + skip; i < sections.length; i = i + skip + 1) {
        if (skip > 1) {
          var separator = this._createSeparator(sections, i - skip, i - 1);

          root.append(separator); // @HTMLUpdateOK
        } else {
          i -= 1;
        }

        var section = sections[i];

        var item = this._createItem(section, missingSections);

        root.append(item); // @HTMLUpdateOK
      } // the last character is always present


      var last = this._createItem(sections[sections.length - 1], missingSections);

      root.append(last); // @HTMLUpdateOK
      // the special others character is always present

      var others = this._createItem(sectionOthers);

      others.attr('data-others', 'true');
      root.append(others); // @HTMLUpdateOK

      if (this.m_height == null) {
        this.m_height = height;
      }
    },

    /**
     * @private
     */
    _createItem: function _createItem(section, missingSections) {
      var label = section.label ? section.label : section;
      var item = $(document.createElement('li'));
      item.data('data-range', section).text(label);

      if (missingSections != null && missingSections.indexOf(section) > -1) {
        item.addClass('oj-disabled');
      }

      return item;
    },

    /**
     * @private
     */
    _createSeparator: function _createSeparator(sections, from, to) {
      var includes = [];
      var item = $(document.createElement('li'));
      item.addClass('oj-indexer-ellipsis').data('data-range', sections[from + Math.round((to - from) / 2)]);

      for (var i = from; i <= to; i++) {
        includes.push(sections[i]);
      }

      item.data('data-includes', includes);
      return item;
    },

    /** ************************** end core rendering **********************************/

    /** ****************************** event handler **********************************/

    /**
     * Initialize the indexer
     * @private
     */
    _setup: function _setup() {
      var self = this;
      this.element.uniqueId().addClass('oj-component-initnode').attr('tabIndex', 0);

      this._on(this.element, {
        click: function click(event) {
          self._handleClick(event);
        },
        keydown: function keydown(event) {
          self._handleKeyDown(event);
        },
        focus: function focus(event) {
          self._handleFocus(event);
        },
        blur: function blur(event) {
          self._handleBlur(event);
        }
      });

      this._focusable({
        applyHighlight: true,
        setupHandlers: function setupHandlers(focusInHandler, focusOutHandler) {
          self._focusInHandler = focusInHandler;
          self._focusOutHandler = focusOutHandler;
        }
      });
    },

    /**
     * Event handler for when mouse click anywhere in the indexer
     * @param {Event} event mouseclick event
     * @private
     */
    _handleClick: function _handleClick(event) {
      var target; // only perform events on left mouse, (right in rtl culture)

      if (event.button === 0) {
        target = $(event.target);

        this._setCurrent(target);
      }
    },

    /**
     * Handler for focus event
     * @param {Event} event the focus event
     * @private
     */
    // eslint-disable-next-line no-unused-vars
    _handleFocus: function _handleFocus(event) {
      this._getIndexerContainer().addClass('oj-focus-ancestor');

      if (this.m_current == null) {
        this._setFocus(this.element.children('li').first());
      } else {
        this._setFocus(this.m_current);
      }
    },

    /**
     * Handler for blur event
     * @param {Event} event the blur event
     * @private
     */
    // eslint-disable-next-line no-unused-vars
    _handleBlur: function _handleBlur(event) {
      this._getIndexerContainer().removeClass('oj-focus-ancestor');
    },

    /**
     * Event handler for when user press down a key
     * @param {Event} event keydown event
     * @private
     */
    _handleKeyDown: function _handleKeyDown(event) {
      var next;
      var processed = false;

      switch (event.keyCode) {
        // UP key
        case 38:
          next = this.m_current.prev();
          break;
        // DOWN key

        case 40:
          next = this.m_current.next();
          break;
        // ENTER key

        case 13:
          this._setCurrent(this.m_current);

          processed = true;
          break;

        default:
          break;
      }

      if (next != null && next.length > 0) {
        processed = true;

        this._setFocus(next);
      }

      if (processed) {
        event.preventDefault();
      }
    },
    _setFocus: function _setFocus(item) {
      if (this.m_current != null) {
        this._focusOutHandler(this.m_current);
      }

      this._focusInHandler(item);

      this._updateAriaProperties(item);

      this.m_current = item;
    },

    /**
     * Retrieves the indexer model.
     * @private
     */
    _getIndexerModel: function _getIndexerModel() {
      var model = this.option('data');

      if (model != null && (model.setSection === undefined || model.getIndexableSections === undefined)) {
        throw new Error('Invalid IndexerModel');
      }

      return model;
    },

    /**
     * Sets the character item as current
     * @param {jQuery} item
     * @private
     */
    _setCurrent: function _setCurrent(item) {
      var section = item.data('data-range');

      if (item.attr('data-others')) {
        section = oj.IndexerModel.SECTION_OTHERS;
      }

      this._setCurrentSection(section);
    },

    /**
     * Sets the section as current
     * @param {Object} section
     * @private
     */
    _setCurrentSection: function _setCurrentSection(section) {
      var self = this;
      var busyContext = Context.getContext(this.element[0]).getBusyContext();
      this.busyStateResolve = busyContext.addBusyState({
        description: 'setCurrentSection'
      }); // sets on the IndexerModel

      var promise =
      /** @type {Promise} */
      this._getIndexerModel().setSection(section);

      promise.then(function (val) {
        // the resolve value is the section that actually scrolls to
        if (val != null) {
          var item = self._findItem(val);

          if (item != null) {
            self._setFocus(item);
          }
        }

        self._resolveBusyState();
      }, function () {
        self._resolveBusyState();
      });
    },

    /**
     * Update wai-aria properties
     * @param {jQuery} item the item
     * @private
     */
    _updateAriaProperties: function _updateAriaProperties(item) {
      var includes = item.data('data-includes');
      var valueText = '';

      if (includes != null) {
        // length should always be > 0
        if (includes.length > 0) {
          var first = includes[0].label ? includes[0].label : includes[0];
          var second = includes[includes.length - 1].label ? includes[includes.length - 1].label : includes[includes.length - 1];
          valueText = this.getTranslatedString('ariaInBetweenText', {
            first: first,
            second: second
          });
        }
      } else {
        var val = item.data('data-range'); // checks if it's the special others section

        if (val === oj.IndexerModel.SECTION_OTHERS) {
          valueText = this.getTranslatedString('ariaOthersLabel');
        } else {
          valueText = val;
        }
      } // convey to screen reader that it's disabled


      if (item.hasClass('oj-disabled')) {
        valueText = valueText + '. ' + this.getTranslatedString('ariaDisabledLabel');
      }

      this.element.attr('aria-valuetext', valueText);
      this.element.attr('aria-valuenow', item.index());
    },

    /**
     * Finds the item with the specified section
     * @param {Object} section
     * @return {jQuery} the item, null if not found
     * @private
     */
    _findItem: function _findItem(section) {
      var children = this.element.children();

      for (var i = 0; i < children.length; i++) {
        var item = children.get(i);
        var value = $(item).data('data-range');
        var includes = $(item).data('data-includes');

        if (value != null && value === section || includes != null && includes.indexOf(section) > -1) {
          return $(item);
        }
      }

      return null;
    },

    /**
     * Unregister event listeners for resize the container DOM element.
     * @param {Element} element the container DOM element
     * @private
     */
    _unregisterResizeListener: function _unregisterResizeListener(element) {
      if (element && this._resizeHandler) {
        // remove existing listener
        oj.DomUtils.removeResizeListener(element, this._resizeHandler);
      }
    },

    /**
     * Register event listeners for resize the container DOM element.
     * @param {Element} element  DOM element
     * @private
     */
    _registerResizeListener: function _registerResizeListener(element) {
      if (element) {
        if (this._resizeHandler == null) {
          this._resizeHandler = this._handleResize.bind(this);
        }

        oj.DomUtils.addResizeListener(element, this._resizeHandler);
      }
    },

    /**
     * Unregister panning handler
     * @param {Element} element  DOM element
     * @private
     */
    _unregisterTouchHandler: function _unregisterTouchHandler(element) {
      if (this.hammer) {
        this.hammer.off('panstart panmove panend');
        $(element).ojHammer('destroy');
      }

      this.hammer = null;
    },

    /**
     * Register panning handler
     * @param {Element} element  DOM element
     * @private
     */
    _registerTouchHandler: function _registerTouchHandler(element) {
      var self = this;
      var x;
      var y;
      var currentTarget;
      var currentSection;
      var currentY;
      var options = {
        recognizers: [[Hammer.Pan, {
          direction: Hammer.DIRECTION_VERTICAL
        }]]
      };
      this.hammer = $(element).ojHammer(options).on('panstart', function (event) {
        var target = event.gesture.target; // for x, don't use the target, use x relative to the indexer to ensure it reflects item in Indexer
        // even if the finger is off the Indexer

        x = self.element[0].getBoundingClientRect().left + 5;
        y = target.getBoundingClientRect().top;

        self._setCurrent($(target));

        currentTarget = target;
        currentSection = $(target).data('data-range');
        currentY = y;
      }).on('panmove', function (event) {
        // calculate point instead of using screenX/Y from touch is better since
        // 1) x stays constant
        // 2) in voiceover user could have pan anywhere on the screen
        var previousY = currentY;
        currentY = y + event.gesture.deltaY;
        var target = document.elementFromPoint(x, currentY); // should not happen

        if (target == null) {
          return;
        }

        var delta = currentY - previousY;
        var range;
        var section;

        if (currentTarget === target) {
          range = $(target).data('data-includes'); // if the section is a range (dot), then try to set the next section inside the range current
          // for example, if move on * which represents range BCD, if current is C then move up should go to B and move down should go to D

          if (range != null) {
            var index = range.indexOf(currentSection);
            section = null;

            if (delta > 0 && index < range.length - 1) {
              section = range[index + 1];
            } else if (delta < 0 && index > 0) {
              section = range[index - 1];
            }

            if (section != null) {
              currentSection = section;

              self._setCurrentSection(section);
            }
          }
        } else if ($(target).data('data-range')) {
          range = $(target).data('data-includes');
          section = null; // if the target is a range (dot), check to see if we should set the section to the beginning of
          // range or end of range.  For example, if you have A * E with * represents BCD, coming from A should go to B
          // where as coming from E should go to D.

          if (range != null) {
            if (delta > 0 && target === currentTarget.nextElementSibling) {
              section = range[0];
            } else if (delta < 0 && target === currentTarget.previousElementSibling) {
              section = range[range.length - 1];
            }
          }

          if (section == null) {
            section = $(target).data('data-range');
          }

          currentTarget = target;
          currentSection = section;

          self._setCurrentSection(currentSection);
        }
      }).on('panend', function () {
        currentTarget = null;
        currentSection = null;
        currentY = null;
      });
    },

    /**
     * The resize handler.
     * @param {number} width the new width
     * @param {number} height the new height
     * @private
     */
    _handleResize: function _handleResize(width, height) {
      if (height > 0 && height !== this.m_height) {
        this.refresh();
        this.m_height = height;
      }
    }
    /**
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Characters</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Selects the character in the indexer, which scrolls to the corresponding group header in the associated ListView.
     *           When tap on the ellipsis character, the character in between will be selected.</td>
     *     </tr>
     *     <tr>
     *       <td>Characters</td>
     *       <td><kbd>Pan</kbd></td>
     *       <td>Selects the character in the indexer, which scrolls to the corresponding group header in the associated ListView.
     *           When pan up and down the ellipsis character, the indexer will select the range of characters represented by the ellipsis.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * @ojfragment touchDoc - Used in touch gesture section of classdesc, and standalone gesture doc
     * @memberof oj.ojIndexer
     */

    /**
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td rowspan = "3" nowrap>Section</td>
     *       <td><kbd>DownArrow</kbd></td>
     *       <td>Move focus to the section below.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>UpArrow</kbd></td>
     *       <td>Move focus to the section above.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Enter</kbd></td>
     *       <td>Selects the current section.  No op if the section is already selected.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * @ojfragment keyboardDoc - Used in keyboard section of classdesc, and standalone gesture doc
     * @memberof oj.ojIndexer
     */
    // ////////////////     SUB-IDS     //////////////////

    /**
     * <p>Sub-ID for the sections within the Indexer.  See the <a href="#getNodeBySubId">getNodeBySubId</a>
     * method for details.</p>
     *
     * @ojsubid oj-indexer-section
     * @memberof oj.ojIndexer
     *
     * @example <caption>Get the node that represents the specified prefix 'A' in the indexer:</caption>
     * var node = myIndexer.getNodeBySubId({'subId': 'oj-indexer-section', 'section': 'A'});
     */

  });
})();



/* jslint browser: true,devel:true*/

/* global Translations:false */

/**
 * The interface for oj.IndexerModel which should be implemented by all object instances
 * bound to the data parameter for ojIndexer.
 * @export
 * @since 1.2
 * @interface oj.IndexerModel
 */
oj.IndexerModel = function () {}; // without the at-name tag, JSDoc tool prepends a "." to the field name for some reason, which messes up the QuickNav.

/**
 * Constant for the section that represents all non-letters including numbers and symbols.
 * @export
 * @expose
 * @type {Object}
 * @property {string} id The id of this section
 * @property {string} label The label of this section
 * @name SECTION_OTHERS
 * @memberof oj.IndexerModel
 */


oj.IndexerModel.SECTION_OTHERS = {
  id: '__others__',
  label: Translations.getTranslatedString('oj-ojIndexer.indexerOthers')
};
/**
 * @typedef {string|Object} oj.IndexerModel.Section
 * @ojsignature {target:"Type", value:"string|{label: string}"}
 */

/**
 * Make a section current in the Indexer.  The implementation should scroll the associated ListView so that the section becomes visible.
 * @param {string|Object} section the current section
 * @return {Promise.<string>|Promise.<Object>} a Promise which when resolved will return the section that the associated ListView actually scrolls to.
 *                   For example, the implementation could choose to scroll to the next available section in ListView if no data
 *                   exists for that section.
 * @method
 * @name setSection
 * @memberof oj.IndexerModel
 * @instance
 * @ojsignature {target: "Type",
 *               value: "(section: oj.IndexerModel.Section): Promise<oj.IndexerModel.Section>"}
 */

/**
 * Returns an array of objects each representing a section in the associated ListView.  The section object could either be
 * a String or an object containing at least a 'label' field.  For example, the implementation may return an array of Strings
 * representing letters of the alphabet. Or it may return an array of objects each containing a 'label' field for the section
 * titles.
 * @return {Array.<string>|Array.<Object>} an array of all indexable sections
 * @method
 * @name getIndexableSections
 * @memberof oj.IndexerModel
 * @instance
 * @ojsignature {target: "Type", value: "(): oj.IndexerModel.Section[]"}
 */

/**
 * Returns an array of objects each representing a section that does not have a corresponding section in the associated ListView.
 * It must be a subset of the return value of <code>getIndexableSections</code>.  Return null or undefined if there's nothing missing.
 * @return {Array.<string>|Array.<Object>} an array of missing sections
 * @method
 * @name getMissingSections
 * @memberof oj.IndexerModel
 * @instance
 * @ojsignature {target: "Type", value: "(): oj.IndexerModel.Section[]"}
 */



/* global __oj_indexer_metadata:false */
(function () {
  __oj_indexer_metadata.extension._WIDGET_NAME = 'ojIndexer';
  __oj_indexer_metadata.extension._INNER_ELEM = 'ul';
  __oj_indexer_metadata.extension._GLOBAL_TRANSFER_ATTRS = ['aria-label', 'aria-labelledby'];
  oj.CustomElementBridge.register('oj-indexer', {
    metadata: __oj_indexer_metadata
  });
})();

});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojdatasource-common',['ojs/ojcore', 'jquery'], function(oj, $)
{
  "use strict";


/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true*/

/**
 * @export
 * @class oj.DataSource
 * @extends oj.EventSource
 * @classdesc Object representing data used by table and grid components
 * @param {Object} data data supported by the components
 * @constructor
 * @final
 * @since 1.0
 * @abstract
 * @ojdeprecated {since: '5.0.0', description: 'Use DataProvider instead.'}
 * @ojtsignore
 */
oj.DataSource = function (data) {
  this.data = data;
  this.Init();
};
/**
 * Subclass from oj.Object
 * @private
 */


oj.Object.createSubclass(oj.DataSource, oj.EventSource, 'oj.DataSource');
/**
 * Initializes the instance.
 * @export
 * @memberof oj.DataSource
 * @return {undefined}
 * @ojtsignore
 */

oj.DataSource.prototype.Init = function () {
  oj.DataSource.superclass.Init.call(this);
};
/**
 * Determines whether this DataSource supports the specified feature.
 * @method
 * @name getCapability
 * @memberof oj.DataSource
 * @instance
 * @param {string} feature the feature in which its capabilities is inquired.
 * @return {string|null} the capability of the specified feature.  Returns null if the feature is not recognized.
 */



/**
 * @class oj.TreeDataSource
 * @classdesc Abstract class representing hierarchical (tree) data that can be used by different components such as [Indexer]{@link oj.ojIndexer}, [ListView]{@link oj.ojListView}, [NavigationList]{@link oj.ojNavigationList},
 * and [TreeView]{@link oj.ojTreeView}.<br><br>
 * This class is not used directly and is used as the base to implement other subclasses.  Implementations of TreeDataSource must implement all of the methods documented here.<br><br>
 * JET provides the following implementations:<br><br>
 * <table class="generic-table">
 *   <thead>
 *     <th>Subclass</th>
 *     <th>When to Use</th>
 *     <th>Use with</th>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td>{@link oj.CollectionTreeDataSource}</td>
 *       <td>When the data is available from an {@link oj.Collection} object, such as an external data source.</td>
 *       <td>ListView<br>NavigationList<br>TreeView<br></td>
 *     </tr>
 *     <tr>
 *       <td>{@link oj.IndexerModelTreeDataSource}</td>
 *       <td>When the data has a tree-like structure that is displayed in a ListView with Indexer.</td>
 *       <td>ListView (with Indexer)<br></td>
 *     </tr>
 *     <tr>
 *       <td>{@link oj.JsonTreeDataSource}</td>
 *       <td>When the data is available from an array of JSON objects that represent tree nodes.</td>
 *       <td>ListView<br>NavigationList<br>TreeView<br></td>
 *     </tr>
 *   </tbody>
 * </table>
 * <br>Refer to the documentation and demos of individual components for more information on how to use them with the TreeDataSource subclasses.</br><br>
 * In case specialized behavior is needed, new subclass can be created by using [oj.Object.createSubclass]{@link oj.Object#createSubclass}.  New subclass can be based on
 * TreeDataSource, in which case all methods must be implemented, or it can be based on an existing subclass, in which case only methods that require different behavior need
 * to be overridden.
 *
 * @param {Object} data data supported by the component
 * @export
 * @extends oj.DataSource
 * @abstract
 * @constructor
 * @final
 * @since 1.0
 * @ojdeprecated {since: '6.0.0', description: 'Use TreeDataProvider instead.'}
 * @ojtsignore
 */
oj.TreeDataSource = function (data) {
  oj.TreeDataSource.superclass.constructor.call(this, data);
};
/**
 * Subclass TreeDataSource to DataSource
 * @private
 */


oj.Object.createSubclass(oj.TreeDataSource, oj.DataSource, 'oj.TreeDataSource');
/**
 * Returns the number of children for a specified parent.  If the value returned is not >= 0 then it is automatically assumed
 * that the child count is unknown.
 * @param {any} parent the parent key.  Specify null if inquiring child count of the root.
 * @return {number} the number of children for the specified parent.
 * @method
 * @name getChildCount
 * @memberof oj.TreeDataSource
 * @instance
 */

/**
 * Fetch the children
 * @param {any} parent the parent key.  Specify null if fetching children from the root.
 * @param {Object} range information about the range, it must contain the following properties: start, count
 * @property {number} range.start the start index of the range in which the children are fetched
 * @property {number} range.count the size of the range in which the children are fetched
 * @param {Object} callbacks the callbacks to be invoke when fetch children operation is completed.  The valid callback
 *        types are "success" and "error"
 * @property {function(oj.NodeSet)} callbacks.success the callback to invoke when fetch completed successfully.
 * @property {function({status: *})=} callbacks.error the callback to invoke when fetch children failed.
 * @param {Object=} options optional parameters for this operation
 * @property {boolean=} options.queueOnly true if this fetch request is to be queued and not execute yet.  The implementation must maintain
 *        the order of the fetch operations.  When queueOnly is false/null/undefined, any queued fetch operations are then
 *        flushed and executed in the order they are queued.  This flag is ignored if the datasource does not support batching
 * @return {void}
 * @method
 * @name fetchChildren
 * @memberof oj.TreeDataSource
 * @instance
 */

/**
 * Fetch all children and their children recursively from a specified parent.
 * @param {any} parent the parent key.  Specify null to fetch everything from the root (i.e. expand all)
 * @param {Object} callbacks the callbacks to be invoke when fetch children operation is completed.  The valid callback
 *        types are "success" and "error"
 * @property {function(oj.NodeSet)} callbacks.success the callback to invoke when fetch completed successfully.
 * @property {function({status: *})=} callbacks.error the callback to invoke when fetch children failed.
 * @param {Object=} options optional parameters for this operation
 * @property {number=} options.start the index related to parent in which to begin fetching descendants from.  If this is not specified, then value zero will be used
 * @property {number=} options.maxCount the maximum number of children to fetch.  If a non-positive number is specified, then the value is ignored and
 *        there is no maximum fetch count
 * @return {void}
 * @method
 * @name fetchDescendants
 * @memberof oj.TreeDataSource
 * @instance
 */

/**
 * Performs a sort operation on the tree data.
 * @param {Object} criteria the sort criteria.  It must contain the following properties: key, direction
 * @property {any} criteria.key the key identifying the attribute (column) to sort on
 * @property {'ascending'|'descending'|'none'} criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
 * @param {Object} callbacks callbacks for the sort operation
 * @property {function():void} callbacks.success the callback to invoke when the sort completed successfully
 * @property {function({status: *})=} callbacks.error the callback to invoke when sort failed.
 * @return {void}
 * @method
 * @name sort
 * @memberof oj.TreeDataSource
 * @instance
 */

/**
 * Returns the current sort criteria of the tree data.
 * @return {Object} the current sort criteria.  It should contain the following properties: key, direction where
 *         criteria.key the key identifying the attribute (column) to sort on.  Value is null if it's not sorted.
 *         criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
 * @ojsignature {target: "Type",
 *               value: "{key: any, direction: 'ascending'|'descending'|'none'}",
 *               for: "returns"}
 * @method
 * @name getSortCriteria
 * @memberof oj.TreeDataSource
 * @instance
 */

/**
 * Moves a row from one location to another (different position within the same parent or a completely different parent)
 * @param {any} rowToMove the key of the row to move
 * @param {any} referenceRow the key of the reference row which combined with position are used to determine
 *        the destination of where the row should moved to.
 * @param {number|string} position The position of the moved row relative to the reference row.
 *        This can be a string: "before", "after", "inside", "first", "last", or the zero based index to position
 *        the element at a specific point among the reference row's current children.
 * @param {Object} callbacks the callbacks for the move function
 * @property {function():void} callbacks.success the callback to invoke when the move completed successfully
 * @property {function({status: *})=} callbacks.error the callback to invoke when move failed.
 * @return {void}
 * @method
 * @name move
 * @memberof oj.TreeDataSource
 * @instance
 */

/**
 * Checks whether a move operation is valid.
 * @param {any} rowToMove the key of the row to move
 * @param {any} referenceRow the key of the reference row which combined with position are used to determine
 *        the destination of where the row should moved to.
 * @param {number|string} position The position of the moved row relative to the reference row.
 *        This can be a string: "before", "after", "inside", "first", "last", or the zero based index to position
 *        the element at a specific point among the reference row's current children.
 * @return {string} returns "valid" if the move is valid, "invalid" otherwise.
 * @ojsignature {target: "Type",
 *               value: "'valid'|'invalid'",
 *               for: "returns"}
 * @method
 * @name moveOK
 * @memberof oj.TreeDataSource
 * @instance
 */

/**
 * Determines whether this TreeDataSource supports the specified feature.
 * @param {string} feature the feature in which its capabilities is inquired.  Currently the valid features "sort",
 *        "move", "fetchDescendants", "batchFetch"
 * @return {string|null} the name of the feature.  Returns null if the feature is not recognized.
 *         For "sort", the valid return values are: "default", "none".
 *         For "fetchDescendants", the valid return values are: "enable", "disable", "suboptimal".
 *         For "move", the valid return values are: "default", "none".
 *         For "batchFetch", the valid return values are: "enable", "disable".
 * @method
 * @name getCapability
 * @memberof oj.TreeDataSource
 * @instance
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @export
 * @class oj.TableDataSource
 * @abstract
 * @classdesc Abstract class representing tabular data that can be used by different components such as [ListView]{@link oj.ojListView}, [NavigationList]{@link oj.ojNavigationList},
 * [PagingControl]{@link oj.ojPagingControl}, [TabBar]{@link oj.ojTabBar}, and [Table]{@link oj.ojTable}.<br><br>
 * This class is not used directly and is used as the base to implement other subclasses.  Implementations of TableDataSource must implement all of the methods documented here.<br><br>
 * JET provides the following implementations:<br><br>
 * <table class="generic-table">
 *   <thead>
 *     <th>Subclass</th>
 *     <th>When to Use</th>
 *     <th>Use with</th>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td>{@link oj.ArrayTableDataSource}</td>
 *       <td>When the data is available from an array.</td>
 *       <td>ListView<br>NavigationList<br>TabBar<br>Table<br></td>
 *     </tr>
 *     <tr>
 *       <td>{@link oj.CollectionTableDataSource}</td>
 *       <td>When the data is available from an {@link oj.Collection} object, such as an external data source.</td>
 *       <td>ListView<br>NavigationList<br>TabBar<br>Table<br></td>
 *     </tr>
 *     <tr>
 *       <td>{@link oj.FlattenedTreeTableDataSource}</td>
 *       <td>When the data has a tree-like structure that is displayed in a Table with RowExpander.</td>
 *       <td>Table (with RowExpander)<br></td>
 *     </tr>
 *     <tr>
 *       <td>{@link oj.PagingTableDataSource}</td>
 *       <td>When paging functionality is needed on top of other TableDataSource implementations.</td>
 *       <td>ListView<br>PagingControl<br>Table<br></td>
 *     </tr>
 *   </tbody>
 * </table>
 * <br>Refer to the documentation and demos of individual components for more information on how to use them with the TableDataSource subclasses.</br><br>
 * In case specialized behavior is needed, new subclass can be created by using [oj.Object.createSubclass]{@link oj.Object#createSubclass}.  New subclass can be based on
 * TableDataSource, in which case all methods must be implemented, or it can be based on an existing subclass, in which case only methods that require different behavior need
 * to be overridden.
 *
 * @extends oj.DataSource
 * @param {Object} data data supported by the components
 * @param {Object=} options Options for the TableDataSource
 * @constructor
 * @final
 * @since 1.0
 * @ojdeprecated {since: '5.0.0', description: 'Use DataProvider instead.'}
 * @ojtsignore
 */
oj.TableDataSource = function (data, options) {
  if (this.constructor === oj.TableDataSource) {
    // This should only be called by the constructors of the subclasses. If you need
    // to initialize a new TableDataSource then call the constructors of the subclasses such
    // as oj.ArrayTableDataSource or oj.CollectionTableDataSource.
    var errSummary = oj.TableDataSource._LOGGER_MSG._ERR_TABLE_DATASOURCE_INSTANTIATED_SUMMARY;
    var errDetail = oj.TableDataSource._LOGGER_MSG._ERR_TABLE_DATASOURCE_INSTANTIATED_DETAIL;
    throw new Error(errSummary + '\n' + errDetail);
  } // Initialize


  this.data = data;
  this.options = options;
  this.isFetching = false;
  this._startIndex = 0;
  this.Init();
};
/**
 * Subclass from oj.DataSource
 * @private
 */


oj.Object.createSubclass(oj.TableDataSource, oj.DataSource, 'oj.TableDataSource');
/**
 * Initializes the instance.
 * @memberof oj.TableDataSource
 * @instance
 * @override
 * @protected
 */

oj.TableDataSource.prototype.Init = function () {
  oj.TableDataSource.superclass.Init.call(this);
};
/**
 * @export
 * @expose
 * @memberof oj.TableDataSource
 * @desc The sort criteria. Whenever sort() is called with the criteria parameter, that value is copied to this
 * property. If sort() is called with empty sort criteria then the criteria set in this property is used.
 *
 * @type {Object}
 * @property {any} criteria.key The key that identifies which field to sort
 * @property {'ascending'|'descending'|'none'} criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
 */


oj.TableDataSource.prototype.sortCriteria = null;
/**
 * Return the row data found at the given index.
 *
 * @param {number} index Index for which to return the row data.
 * @param {Object=} options Options to control the at.
 * @return {Promise.<null|oj.TableDataSource.RowData>} Promise resolves to a compound object which has the structure below. If the index is out of range, Promise resolves to null.<p>
 * <table>
 * <tbody>
 * <tr><td><b>data</b></td><td>The raw row data</td></tr>
 * <tr><td><b>index</b></td><td>The index for the row</td></tr>
 * <tr><td><b>key</b></td><td>The key value for the row</td></tr>
 * </tbody>
 * </table>
 * @method
 * @name at
 * @memberof oj.TableDataSource
 * @instance
 */

/**
 * Fetch the row data.
 * @param {Object=} options Options to control fetch
 * @property {number} [options.startIndex] The index at which to start fetching records.
 * @property {boolean} [options.silent] If set, do not fire a sync event.
 * @return {Promise.<null|oj.TableDataSource.RowDatas>} Promise object resolves to a compound object which contains an array of row data objects, an array of ids, and the startIndex triggering done when complete.<p>
 *         The structure of the resolved compound object is:<p>
 * <table>
 * <tbody>
 * <tr><td><b>data</b></td><td>An array of raw row data</td></tr>
 * <tr><td><b>keys</b></td><td>An array of key values for the rows</td></tr>
 * <tr><td><b>startIndex</b></td><td>The startIndex for the returned set of rows</td></tr>
 * </tbody>
 * </table>
 * @method
 * @name fetch
 * @memberof oj.TableDataSource
 * @instance
 */

/**
 * Return the first row data whose id value is the given id
 * @param {string} id ID for which to return the row data, if found.
 * @param {Object=} options Options to control the get.
 * @return {Promise.<null|oj.TableDataSource.RowData>} Promise which resolves to a compound object which has the structure below where the id matches the given id. If none are found, resolves to null.<p>
 * <table>
 * <tbody>
 * <tr><td><b>data</b></td><td>The raw row data</td></tr>
 * <tr><td><b>index</b></td><td>The index for the row</td></tr>
 * <tr><td><b>key</b></td><td>The key value for the row</td></tr>
 * </tbody>
 * </table>
 * @method
 * @name get
 * @memberof oj.TableDataSource
 * @instance
 */

/**
 * Determines whether this TableDataSource supports certain feature.
 * @param {string} feature the feature in which its capabilities is inquired.  Currently the only valid feature is "sort".
 * @return {string|null} the name of the feature.  For "sort", the valid return values are: "full", "none".
 *         Returns null if the feature is not recognized.
 * @memberof oj.TableDataSource
 * @instance
 * @method
 * @name getCapability
 */

/**
 * Performs a sort on the data source. Null criteria clears the existing sort.
 * @param {Object} [criteria] the sort criteria.
 * @property {any} criteria.key The key that identifies which field to sort
 * @property {'ascending'|'descending'|'none'} criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
 * @return {Promise.<null>} promise object triggering done when complete.
 * @method
 * @name sort
 * @memberof oj.TableDataSource
 * @instance
 */

/**
 * Return the total size of data available, including server side if not local.
 * @returns {number} total size of data
 * @method
 * @name totalSize
 * @memberof oj.TableDataSource
 * @instance
 */

/**
 * Returns the confidence for the totalSize value.
 * @return {string} "actual" if the totalSize is the time of the fetch is an exact number
 *                  "estimate" if the totalSize is an estimate
 *                  "atLeast" if the totalSize is at least a certain number
 *                  "unknown" if the totalSize is unknown
 * @ojsignature {target: "Type", for: "returns", value: "'actual'|'estimate'|'atLeast'|'unknown'"}
 * @export
 * @expose
 * @memberof oj.TableDataSource
 * @instance
 */

oj.TableDataSource.prototype.totalSizeConfidence = function () {
  return 'actual';
};
/**
* Row Data returned by methods like, at/get.
* @typedef {Object} oj.TableDataSource.RowData
* @property {Object} data The raw row data.
* @property {number} index The index for the row.
* @property {any} key The key value for the row.
*/

/**
* Row Datas returned by fetch method.
* @typedef {Object} oj.TableDataSource.RowDatas
* @property {Array.<Object>} data An array of raw row data.
* @property {Array.<any>} keys An array of key values for the rows.
* @property {number} startIndex The startIndex for the returned set of rows.
*/

/**
 * Events which are published by TableDataSource. Any custom TableDataSource
 * implementation must publish the corresponding events.
 * @export
 * Event types
 * @enum {string}
 * @memberof oj.TableDataSource
 */


oj.TableDataSource.EventType = {
  /** Triggered when a Row has been added to a TableDataSource<p>
   * The event payload contains:<p>
   * <table cellspacing="0" style="border-collapse: collapse;">
   * <tbody>
   * <tr><td><b>data</b></td><td>An array of raw row data</td></tr>
   * <tr><td><b>keys</b></td><td>An array of key values for the rows</td></tr>
   * <tr><td><b>indexes</b></td><td>An array of index values for the rows in post-insert sorted order</td></tr>
   * </tbody>
   * </table>
   */
  ADD: 'add',

  /** Triggered when a Row has been removed from a TableDataSource<p>
   * The event payload contains:<p>
   * <table cellspacing="0" style="border-collapse: collapse;">
   * <tbody>
   * <tr><td><b>data</b></td><td>An array of raw row data</td></tr>
   * <tr><td><b>keys</b></td><td>An array of key values for the rows</td></tr>
   * <tr><td><b>indexes</b></td><td>An array of index values for the rows in pre-remove sorted order</td></tr>
   * </tbody>
   * </table>
   */
  REMOVE: 'remove',

  /** Triggered when a TableDataSource has been reset */
  RESET: 'reset',

  /** Triggered when a TableDataSource has been refreshed */
  REFRESH: 'refresh',

  /** Triggered when a TableDataSource has been sorted<p>
   * The event payload contains:<p>
   * <table cellspacing="0" style="border-collapse: collapse;">
   * <tbody>
   * <tr><td><b>header</b></td><td>the key of the header which was sorted on</td></tr>
   * <tr><td><b>direction</b></td><td>the direction of the sort ascending/descending</td></tr>
   * </tbody>
   * </table>
   */
  SORT: 'sort',

  /** Triggered when a Row's attributes have been changed<p>
   * The event payload contains:<p>
   * <table cellspacing="0" style="border-collapse: collapse;">
   * <tbody>
   * <tr><td><b>data</b></td><td>An array of raw row data</td></tr>
   * <tr><td><b>keys</b></td><td>An array of key values for the rows</td></tr>
   * <tr><td><b>indexes</b></td><td>An array of index values for the rows</td></tr>
   * </tbody>
   * </table>
   */
  CHANGE: 'change',

  /** Triggered when a TableDataSource has sent a fetch request. It is expected that
   * a component using TableDataSource will go into a busy state upon receiving
   * this event.
   * The event payload contains:<p>
   * <table cellspacing="0" style="border-collapse: collapse;">
   * <tbody>
   * <tr><td><b>startIndex</b></td><td>The start index at which the fetch was invoked</td></tr>
   * </tbody>
   * </table>
   */
  REQUEST: 'request',

  /** Triggered when a TableDataSource has been updated by a fetch. It is expected that
   * a component using TableDataSource will exit busy state upon completion of rendering
   * after receiving this event.<p>
   * The event payload contains:<p>
   * <table cellspacing="0" style="border-collapse: collapse;">
   * <tbody>
   * <tr><td><b>data</b></td><td>An array of raw row data</td></tr>
   * <tr><td><b>keys</b></td><td>An array of key values for the rows</td></tr>
   * <tr><td><b>startIndex</b></td><td>The start index at which the fetch occurred</td></tr>
   * </tbody>
   * </table>
   */
  SYNC: 'sync',

  /** Triggered when an error occurred on the TableDataSource */
  ERROR: 'error'
};
/**
 * @private
 */

oj.TableDataSource._LOGGER_MSG = {
  _ERR_TABLE_DATASOURCE_INSTANTIATED_SUMMARY: 'oj.TableDataSource constructor called.',
  _ERR_TABLE_DATASOURCE_INSTANTIATED_DETAIL: 'Please do not instantiate oj.TableDataSource. Please use one of the subclasses instead such as oj.ArrayTableDataSource or oj.CollectionTableDataSource.',
  _ERR_DATA_INVALID_TYPE_SUMMARY: 'Invalid data type.',
  _ERR_DATA_INVALID_TYPE_DETAIL: 'Please specify the appropriate data type.'
};



/**
 * @class oj.DataGridDataSource
 * @classdesc The base class for DataGridDataSource.<br>
 * DataGridDataSource implementations must implement all of the functions documented here.
 * @export
 * @extends oj.DataSource
 * @constructor
 * @final
 * @since 1.0
 * @ojtsignore
 */
oj.DataGridDataSource = function (data) {
  // oj.DataSource would calls Init
  oj.DataGridDataSource.superclass.constructor.call(this, data);
};
/**
 * Subclass DataGridDataSource to DataSource
 * @private
 */


oj.Object.createSubclass(oj.DataGridDataSource, oj.DataSource, 'oj.DataGridDataSource');
/**
 * Returns the total number of rows or columns.  If the value return is not >= 0 then it is automatically assumed
 * that the total count is unknown.
 * @param {string} axis the axis in which we inquire for the total count.  Valid values are "row" and "column".
 * @return {number} the total number of rows/columns.
 * @method
 * @name getCount
 * @memberof oj.DataGridDataSource
 * @instance
 */

/**
 * Returns whether the total count returned in getCount function is an actual or an estimate.
 * @param {string} axis the axis in which we inquire whether the total count is an estimate.  Valid values are
 *        "row" and "column".
 * @return {string} "exact" if the count returned in getCount function is the actual count, "estimate" if the
 *         count returned in getCount function is an estimate.  The default value is "exact".
 * @method
 * @name getCountPrecision
 * @memberof oj.DataGridDataSource
 * @instance
 */

/**
 * Fetch a range of headers from the data source.
 * @export
 * @method
 * @name fetchHeaders
 * @memberof oj.DataGridDataSource
 * @instance
 * @param {Object} headerRange information about the header range, it must contain the following properties:
 *        axis, start, count.
 * @property {string} headerRange.axis the axis of the header that are fetched.  Valid values are "row" and "column".
 * @property {number} headerRange.start the start index of the range in which the header data are fetched.
 * @property {number} headerRange.count the size of the range in which the header data are fetched.
 * @param {Object} callbacks the callbacks to be invoke when fetch headers operation is completed.
 * @property {function({startHeaderSet: Object}, {headerRange: Object}, {endHeaderSet: Object}):undefined} callbacks.success the callback to invoke when fetch headers completed successfully.
 *        The function takes three parameters: HeaderSet object representing start headers, headerRange object passed into the original fetchHeaders call,
 *        and a HeaderSet object representing the end headers along the axis.
 * @property {function({status: Object}):undefined} callbacks.error the callback to invoke when fetch cells failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.
 * @property {Object=} callbackObjects.success
 * @property {Object=} callbackObjects.error
 * @return {undefined}
 */

/**
 * Fetch a range of cells from the data source.
 * @method
 * @name fetchCells
 * @memberof oj.DataGridDataSource
 * @instance
 * @param {Array.<Object>} cellRanges Information about the cell range.  A cell range is defined by an array
 *        of range info for each axis, where each range contains three properties: axis, start, count.
 * @property {string} cellRanges.axis the axis associated with this range where cells are fetched.  Valid
 *        values are "row" and "column".
 * @property {number} cellRanges.start the start index of the range for this axis in which the cells are fetched.
 * @property {number} cellRanges.count the size of the range for this axis in which the cells are fetched.
 * @param {Object} callbacks the callbacks to be invoke when fetch cells operation is completed.
 * @property {function({cellSet: Object}, {cellRanges: Array.<Object>}):undefined} callbacks.success the callback to invoke when fetch cells completed successfully.
 * @property {function({status: Object}):undefined} callbacks.error the callback to invoke when fetch cells failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.
 * @property {Object=} callbackObjects.success
 * @property {Object=} callbackObjects.error
 * @return {undefined}
 */

/**
 * Returns the keys based on the indexes.
 * @method
 * @name keys
 * @memberof oj.DataGridDataSource
 * @instance
 * @param {Object} indexes the index for each axis
 * @property {number|null} indexes.row the index for the row axis
 * @property {number|null} indexes.column the index for the column axis
 * @return {Promise.<Object>} a Promise object which when resolved returns an object containing the keys for each axis
 */

/**
 * Returns the row and column index based on the keys.
 * @method
 * @name indexes
 * @memberof oj.DataGridDataSource
 * @instance
 * @param {Object} keys the key for each axis
 * @property {any} keys.row the key for the row axis
 * @property {any} keys.column the key for the column axis
 * @return {Promise.<Object>} a Promise object which when resolved returns an object containing the index for each axis
 */

/**
 * Performs a sort on the data source.
 * @method
 * @name sort
 * @memberof oj.DataGridDataSource
 * @instance
 * @param {Object|null} criteria the sort criteria.
 * @property {string} criteria.axis The axis in which the sort is performed, valid values are "row", "column"
 * @property {any} criteria.key The key that identifies which header to sort
 * @property {string} criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
 * @param {Object=} callbacks the callbacks to be invoke upon completion of the sort operation.
 * @property {function():undefined=} callbacks.success the callback to invoke when the sort completed successfully.
 * @property {function({status: Object}):undefined=} callbacks.error the callback to invoke when sort failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.
 * @property {Object=} callbackObjects.success
 * @property {Object=} callbackObjects.error
 * @return {undefined}
 */

/**
 * Moves a row from one location to another.
 * @method
 * @name move
 * @memberof oj.DataGridDataSource
 * @instance
 * @param {any} rowToMove the key of the row to move
 * @param {any} referenceRow the key of the reference row which combined with position are used to determine
 *        the destination of where the row should moved to.
 * @param {string} position The position of the moved row relative to the reference row.
 *        Valid values are: "before", "after"
 * @param {Object=} callbacks the callbacks to be invoke upon completion of the move operation.
 * @property {function():undefined=} callbacks.success the callback to invoke when the sort completed successfully.
 * @property {function({status: Object}):undefined=} callbacks.error the callback to invoke when sort failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.
 * @property {Object=} callbackObjects.success
 * @property {Object=} callbackObjects.error
 * @return {undefined}
 */

/**
 * Checks whether a move operation is valid.
 * @param {any} rowToMove the key of the row to move
 * @param {any} referenceRow the key of the reference row which combined with position are used to determine
 *        the destination of where the row should moved to.
 * @param {string} position the position of the moved row relative to the reference row.
 * @return {string} returns "valid" if the move is valid, "invalid" otherwise.
 * @method
 * @name moveOK
 * @memberof oj.DataGridDataSource
 * @instance
 */

/**
 * Determines whether this DataGridDataSource supports certain feature.
 * @method
 * @name getCapability
 * @memberof oj.DataGridDataSource
 * @instance
 * @param {string} feature the feature in which its capabilities is inquired.  Currently the only valid feature is "sort".
 * @return {string|null} the name of the feature.  For "sort", the valid return values are: "full", "none", "row", "column".
 *         For "move", the valid return values are: "row", "none".
 *         Returns null if the feature is not recognized.
 */



/**
 * @class oj.DiagramDataSource
 * @classdesc Base class for Diagram DataSource.  Implementations must implement all of the functions documented here.
 * @param {Object} data data required by the DiagramDataSource implementation
 * @export
 * @extends oj.DataSource
 * @constructor
 * @final
 * @since 3.0
 * @ojtsignore
 */
oj.DiagramDataSource = function (data) {
  oj.DiagramDataSource.superclass.constructor.call(this, data);
};
/**
 * Subclass DiagramDataSource to DataSource
 * @private
 */


oj.Object.createSubclass(oj.DiagramDataSource, oj.DataSource, 'oj.DiagramDataSource');
/**
 * Object that defines diagram node. The object might also have additional custom properties that can be
 * mapped to node styles (see {@link oj.ojDiagram#nodeProperties})
 * or used during Diagram layout (see {@link oj.DvtDiagramLayoutContextNode#getData}).
 * @typedef {Object} NodeObject
 * @memberof oj.DiagramDataSource
 * @property {string} id Node id
 * @property {Array.<string>=} categories An optional array of additional category strings corresponding to the node.
 * @property {string=} label The label for the node. If the string contains new line characters, a multi-line label will be rendered.
 * @property {Array.<Object>=} nodes An array of objects with properties for the child nodes.
 *                     Set value to null to indicate leaf node, if child nodes could be fetched on container disclosure.
 *                     Set value to 'undefined' to indicate potential child nodes, if the child nodes should be fetched on container disclosure.
 * @property {string=} selectable Specifies whether or not the node will be selectable. Acceptable values are 'off' and 'auto'. Default value is 'auto'
 * @property {string=} draggable  Specifies whether or not the node will be draggable. Acceptable values are 'off' and 'auto'. Default value is 'auto'
 * @property {string=} shortDesc  The description of the node. This is used for accessibility and also for customizing the tooltip text.
 */

/**
 * Object that defines diagram link. The object might also have additional custom properties that can be
 * mapped to link styles (see {@link oj.ojDiagram#linkProperties})
 * or used during Diagram layout (see {@link oj.DvtDiagramLayoutContextLink#getData}).
 * @typedef {Object} LinkObject
 * @memberof oj.DiagramDataSource
 * @property {string} id Link id
 * @property {string} startNode Start node id.
 * @property {string} endNode End node id.
 * @property {Array.<string>=} categories An optional array of additional category strings corresponding to the link.
 * @property {string=} label The label for the link. If the string contains new line characters, a multi-line label will be rendered.
 * @property {string=} selectable Specifies whether or not the node will be selectable. Acceptable values are 'off' and 'auto'. Default value is 'auto'
 * @property {string=} shortDesc  The description of the node. This is used for accessibility and also for customizing the tooltip text.
 */

/**
 * Returns child data for the given parent.
 * The data include all immediate child nodes along with links whose endpoints
 * both descend from the current parent node.
 * If all the links are available upfront, they can be returned as part of the
 * top-level data (since all nodes descend from the diagram root).
 * If lazy-fetching links is desirable, the most
 * optimal way to return links is as part of the data of the
 * nearest common ancestor of the link's endpoints.
 *
 * @param {Object|null} parentData An object that contains data for the parent node. See {@link oj.DiagramDataSource.NodeObject} section.
 *                     If parentData is null, the method retrieves data for top level nodes.
 * @return {Promise} Promise resolves to a component object with the following structure:<p>
 * <table>
 * <tbody>
 * <tr><td><b>nodes</b></td><td>An array of objects for the child nodes for the given parent.
 *              See {@link oj.DiagramDataSource.NodeObject} section.</td></tr>
 * <tr><td><b>links</b></td><td>An array of objects for the links for the given parent.
 *              See {@link oj.DiagramDataSource.LinkObject} section.</td></tr>
 * </tbody>
 * </table>
 * @method
 * @name getData
 * @memberof oj.DiagramDataSource
 * @instance
 */

/**
 * Retrieves number of child nodes
 * @param {Object} nodeData A data object for the node in question.
 *                          See {@link oj.DiagramDataSource.NodeObject} section.
 * @return {number} Number of child nodes if child count is available.
 *                  The method returns 0 for leaf nodes.
 *                  The method returns -1 if the child count is unknown
 *                  (e.g. if the children have not been fetched).
 * @method
 * @name getChildCount
 * @memberof oj.DiagramDataSource
 * @instance
 */

/**
 * Indicates whether the specified object contains links
 * that should be discovered in order to display promoted links.
 *
 * @param {Object} nodeData A data object for the container node in question.
 *                          See {@link oj.DiagramDataSource.NodeObject} section
 * @return {string} the valid values are "connected", "disjoint", "unknown"
 * @method
 * @name getDescendantsConnectivity
 * @memberof oj.DiagramDataSource
 * @instance
 */

/**
* @export
* Event types
* @enum {string}
* @memberof oj.DiagramDataSource
*/

oj.DiagramDataSource.EventType = {
  /**
   * Triggered when nodes or links are added to DiagramDataSource.<p>
   * The event payload contains.<p>
   *
   * <table cellspacing="0" style="border-collapse: collapse;">
   * <tbody>
   * <tr><td><b>data</b></td><td>Object</td><td>An object with the following properties:
   *  <ul>
   *    <li>nodes: An array of node objects. See {@link oj.DiagramDataSource.NodeObject} section.</li>
   *    <li>links: An array of link objects. See {@link oj.DiagramDataSource.LinkObject} section.</li>
   *  </ul>
   * </td></tr>
   * <tr><td><b>parentId</b></td><td>string</td><td>parent id for nodes and links</td></tr>
   * <tr><td><b>index</b></td><td>number</td><td>An index where the nodes should be added</td></tr>
   * </tbody>
   * </table>
   */
  ADD: 'add',

  /**
   * Triggered when nodes or links are removed from DiagramDataSource.
   * The event payload contains:<p>
   *
   * <table cellspacing="0" style="border-collapse: collapse;">
   * <tbody>
   * <tr><td><b>data</b></td><td>Object</td><td>An object with the following properties:
   *  <ul>
   *    <li>nodes: An array of node objects. See {@link oj.DiagramDataSource.NodeObject} section.</li>
   *    <li>links: An array of link objects. See {@link oj.DiagramDataSource.LinkObject} section.</li>
   *  </ul>
   * </td></tr>
   * <tr><td><b>parentId</b></td><td>string</td><td>parent id for nodes and links</td></tr>
   * </tbody>
   * </table>
   */
  REMOVE: 'remove',

  /**
   * Triggered when nodes or links are removed from DiagramDataSource.
   * The event payload contains:<p>
   *
   * <table cellspacing="0" style="border-collapse: collapse;">
   * <tbody>
   * <tr><td><b>data</b></td><td>Object</td><td>An object with the following properties:
   *  <ul>
   *    <li>nodes: An array of node objects. See {@link oj.DiagramDataSource.NodeObject} section.</li>
   *    <li>links: An array of link objects. See {@link oj.DiagramDataSource.LinkObject} section.</li>
   *  </ul>
   * </td></tr>
   * </tbody>
   * </table>
   */
  CHANGE: 'change'
};


// Define a mapping variable that maps the return value of the module to the name used in the callback function of a require call.
var DataSourceCommon = {};
DataSourceCommon.DataGridDataSource = oj.DataGridDataSource;

  return DataSourceCommon;
});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojindexermodeltreedatasource',['ojs/ojcore', 'jquery', 'ojs/ojindexer', 'ojs/ojdatasource-common'],
/*
* @param {Object} oj 
* @param {jQuery} $
*/
function(oj, $)
{
  "use strict";


/**
 * Implementation of the IndexerModel and TreeDataSource based on an array of data set.
 * This should be used with the Indexer and its associated ListView.
 * By default, this adapter groups the data based on the first letter of the data and the alphabet of the current locale.
 * @ojdeprecated {since: '7.0.0', description: 'Use IndexerModelTreeDataProvider instead.'}
 * @class oj.IndexerModelTreeDataSource
 * @classdesc TreeDataSource and IndexerModel implementation that represents hierachical data available from an array of JSON objects.  This data source can be used by [Indexer]{@link oj.ojIndexer} and
 *            associated [ListView]{@link oj.ojListView}.<br><br>
 *            See the <a href="../jetCookbook.html?component=indexer&demo=characterIndexer">Indexer - Basic</a> demo for an example.<br><br>
 *            Refer to {@link oj.TreeDataSource} for other data sources that represent hierarachical data.
 * @param {Array.<any>} data an array of data used for Indexer and ListView
 * @param {string} idAttribute the id attribute of the data
 * @param {function(Object)|function(string)} listener a callback function that handles when a section becomes current (user clicks on the section in the Indexer).
 *                   the function takes the current section and must return a Promise which when resolve returns the section in which the ListView
 *                   actually scrolls to.
 * @param {Object=} options the options set on this IndexerModelTreeDataSource
 * @param {(Array.<string>|Array.<Object>)=} options.sections the set of sections to use with the Indexer.  If not specified, then the sections are derived from the alphabet of the current locale.
 * @param {string=} options.groupingAttribute the attribute of the data where grouping is based on, mandatory if no groupingStrategy is specified.
 * @param {function(Object)=} options.groupingStrategy a callback function that takes a data and returns the section that the data belongs to.  If no groupingStrategy is specified,
 *                   then the default grouping strategy based on the first letter of the data is used.
 * @param {function(Object, Object)=} options.sortComparatorFunction a comparator function that is used to sort data within a section.  If not specified, then
 *                   the items within a section will not be sorted.
 * @ojsignature {target: "Type",
 *               value: "(section: string|object)=> Promise<string|object>",
 *               for: "listener"}
 * @ojsignature {target: "Type",
 *               value: "(data: any)=> string|object",
 *               for: "options.groupingStrategy"}
 * @ojsignature {target: "Type",
 *               value: "(section1: string|object, section2: string|object)=> number",
 *               for: "options.sortComparatorFunction"}
 * @constructor
 * @final
 * @since 3.0
 * @export
 * @ojtsignore
 * @extends oj.TreeDataSource
 * @implements oj.IndexerModel
 */
oj.IndexerModelTreeDataSource = function (data, idAttribute, listener, options) {
  this.data = data;
  this.idAttr = idAttribute;
  this.listener = listener;
  this.options = options;
  this.Init();
}; // Subclass from oj.TreeDataSource


oj.Object.createSubclass(oj.IndexerModelTreeDataSource, oj.TreeDataSource, 'oj.IndexerModelTreeDataSource');
/**
 * Initializes the instance.
 * @return {void}
 * @export
 * @expose
 * @memberof oj.IndexerModelTreeDataSource
 * @ojtsignore
 * @instance
 */

oj.IndexerModelTreeDataSource.prototype.Init = function () {
  // call super
  oj.IndexerModelTreeDataSource.superclass.Init.call(this);
  var sections = this.options.sections;

  if (sections == null) {
    var resource = oj.Translations.getTranslatedString('oj-ojIndexer.indexerCharacters');
    sections = resource.split('|');
  }

  sections.push(oj.IndexerModel.SECTION_OTHERS);
  var strategy = this.options.groupingStrategy;

  if (strategy == null) {
    // if no grouping strategy is specified, use the default which groups based on the first charactor
    // of the data
    var field = this.options.groupingAttribute;

    strategy = function strategy(value) {
      var content = value[field] ? value[field] : value;
      var char = content.toString().toUpperCase()[0];
      return sections.indexOf(char) > -1 ? char : oj.IndexerModel.SECTION_OTHERS;
    };
  }

  var sortComparator = this.options.sortComparatorFunction;
  this.data = this.data.sort(function (a, b) {
    var section1 = strategy(a);
    var section2 = strategy(b);
    var index1 = sections.indexOf(section1);
    var index2 = sections.indexOf(section2);
    var diff = index1 - index2; // used specified sort comparator function to sort within section

    if (diff === 0 && sortComparator) {
      return sortComparator(a, b);
    }

    return diff;
  });
  var current; // figure out the position of the buckets for quick lookup

  for (var i = 0; i < this.data.length; i++) {
    var section = strategy(this.data[i]);

    if (current !== section) {
      current = section;

      this._set(section, i);
    }
  }

  this.sections = sections;
}; // TODO: use Map when we can use it for all supported platforms

/**
 * @private
 */


oj.IndexerModelTreeDataSource.prototype._set = function (key, value) {
  if (this.pos == null) {
    this.pos = [];
  }

  this.pos.push({
    key: key,
    value: value
  });
};
/**
 * @private
 */


oj.IndexerModelTreeDataSource.prototype._get = function (key) {
  for (var i = 0; i < this.pos.length; i++) {
    if (this.pos[i].key === key) {
      return this.pos[i].value;
    }
  }

  return null;
};
/** **************** IndexerModel *******************/

/**
 * Returns an array of objects each representing a section in the associated ListView.
 * @return {Array.<string>|Array.<Object>} an array of all indexable sections
 * @export
 * @expose
 * @memberof oj.IndexerModelTreeDataSource
 * @instance
 */


oj.IndexerModelTreeDataSource.prototype.getIndexableSections = function () {
  // remove other sections from this.sections
  return this.sections.slice(0, this.sections.length - 1);
};
/**
 * Returns an array of objects each representing a section that does not have a corresponding section in the associated ListView.
 * It must be a subset of the return value of <code>getIndexableSections</code>.  Return null or undefined if there's nothing missing.
 * @return {Array.<string>|Array.<Object>} an array of missing sections
 * @export
 * @expose
 * @memberof oj.IndexerModelTreeDataSource
 * @instance
 */


oj.IndexerModelTreeDataSource.prototype.getMissingSections = function () {
  if (this.missing == null) {
    var missing = []; // figure out what's missing, skip the others section since it's always available

    for (var i = 0; i < this.sections.length - 1; i++) {
      var section = this.sections[i];

      if (this._get(section) == null) {
        missing.push(section);
      }
    }

    this.missing = missing;
  }

  return this.missing;
};
/**
 * Make a section current in the Indexer.  The implementation should scroll the associated ListView so that the section becomes visible.
 * @param {string|Object} section the current section
 * @return {Promise.<string>|Promise.<Object>} a Promise which when resolved will return the section that the associated ListView actually scrolls to.
 *                   For example, the implementation could choose to scroll to the next available section in ListView if no data
 *                   exists for that section.
 * @export
 * @expose
 * @memberof oj.IndexerModelTreeDataSource
 * @instance
 */


oj.IndexerModelTreeDataSource.prototype.setSection = function (section) {
  return this.listener.call(this, section);
};
/** **************** TreeDataSource *******************/

/**
 * Returns the number of children for a specified parent.  If the value returned is not >= 0 then it is automatically assumed
 * that the child count is unknown.
 * @param {any} parentKey the parent key.  Specify null if inquiring child count of the root.
 * @return {number} the number of children for the specified parent.
 * @export
 * @expose
 * @memberof oj.IndexerModelTreeDataSource
 * @instance
 */


oj.IndexerModelTreeDataSource.prototype.getChildCount = function (parentKey) {
  if (parentKey == null) {
    var count = this.sections.length - this.getMissingSections().length; // exclude other section if there are no entries in it

    return this._get(oj.IndexerModel.SECTION_OTHERS) != null ? count : count - 1;
  }

  var pos = this._get(parentKey);

  if (pos != null) {
    var index = this.sections.indexOf(parentKey); // if it's the last section

    if (index === this.sections.length - 1) {
      return this.data.length - pos;
    }

    index += 1;
    var next = this.sections[index];

    var nextPos = this._get(next);

    while (nextPos == null && index < this.sections.length) {
      index += 1;
      next = this.sections[index];
      nextPos = this._get(next);
    }

    if (isNaN(nextPos) || nextPos == null) {
      nextPos = this.data.length;
    }

    return nextPos - pos;
  } // should not get here (ex: unexpected parentKey)


  return 0;
};
/**
 * Fetch the children
 * @param {any} parentKey the parent key.  Specify null if fetching children from the root.
 * @param {Object} range information about the range, it must contain the following properties: start, count.
 * @param {number} range.start the start index of the range in which the children are fetched.
 * @param {number} range.count the size of the range in which the children are fetched.
 * @param {Object} callbacks the callbacks to be invoke when fetch children operation is completed.  The valid callback
 *        types are "success" and "error".
 * @param {function(oj.NodeSet)} callbacks.success the callback to invoke when fetch completed successfully.
 * @param {function({status: *})=} callbacks.error the callback to invoke when fetch children failed.
 * @param {Object=} options optional parameters for this operation.
 * @param {boolean=} options.queueOnly true if this fetch request is to be queued and not execute yet.  The implementation must maintain
 *        the order of the fetch operations.  When queueOnly is false/null/undefined, any queued fetch operations are then
 *        flushed and executed in the order they are queued.  This flag is ignored if the datasource does not support batching.
 * @return {void}
 * @export
 * @expose
 * @memberof oj.IndexerModelTreeDataSource
 * @instance
 */


oj.IndexerModelTreeDataSource.prototype.fetchChildren = function ( // eslint-disable-next-line no-unused-vars
parentKey, range, callbacks, options) {
  var nodeSet;
  var self = this;

  if (parentKey == null) {
    // root case
    var available = this.sections.filter(function (section) {
      return self._get(section) != null;
    });
    nodeSet = {
      getParent: function getParent() {
        return parentKey;
      },
      getStart: function getStart() {
        return 0;
      },
      getCount: function getCount() {
        return available.length;
      },
      getData: function getData(index) {
        return available[index];
      },
      getMetadata: function getMetadata(index) {
        return {
          key: available[index],
          leaf: false,
          depth: 0
        };
      }
    };
  } else {
    nodeSet = {
      getParent: function getParent() {
        return parentKey;
      },
      getStart: function getStart() {
        return 0;
      },
      getCount: function getCount() {
        return self.getChildCount(parentKey);
      },
      getData: function getData(index) {
        return self.data[self._get(parentKey) + index];
      },
      getMetadata: function getMetadata(index) {
        var data = self.data[self._get(parentKey) + index];
        return {
          key: self.idAttr != null ? data[self.idAttr] : data,
          leaf: true,
          depth: 1
        };
      }
    };
  } // invoke original success callback


  if (callbacks != null && callbacks.success != null) {
    callbacks.success.call(null, nodeSet);
  }
};
/**
 * Returns the current sort criteria of the tree data.
 * @return {Object} the current sort criteria.  It should contain the following properties: key, direction where
 *         criteria.key the key identifying the attribute (column) to sort on.  Value is null if it's not sorted.
 *         criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
 * @ojsignature {target: "Type",
 *               value: "{key: any, direction: 'ascending'|'descending'|'none'}",
 *               for: "returns"}
 * @export
 * @expose
 * @memberof oj.IndexerModelTreeDataSource
 * @instance
 */


oj.IndexerModelTreeDataSource.prototype.getSortCriteria = function () {
  return {
    key: null,
    direction: 'none'
  };
};

});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojeventtarget',['ojs/ojcore'], function(oj)
{
  "use strict";
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var EventTargetMixin = /*#__PURE__*/function () {
  function EventTargetMixin() {
    _classCallCheck(this, EventTargetMixin);
  }

  _createClass(EventTargetMixin, [{
    key: "addEventListener",
    value: function addEventListener(eventType, listener) {
      if (!this._eventListeners) {
        this._eventListeners = [];
      }

      this._eventListeners.push({
        type: eventType.toLowerCase(),
        listener: listener
      });
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(eventType, listener) {
      if (this._eventListeners) {
        var i;

        for (i = this._eventListeners.length - 1; i >= 0; i--) {
          if (this._eventListeners[i]['type'] == eventType && this._eventListeners[i]['listener'] == listener) {
            this._eventListeners.splice(i, 1);
          }
        }
      }
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(evt) {
      if (this._eventListeners) {
        var i, returnValue; //clone the eventListeners to isolate mutations that may occur during dispatching events

        var eventListeners = this._eventListeners.slice(0);

        for (i = 0; i < eventListeners.length; i++) {
          var eventListener = eventListeners[i];

          if (evt && evt.type && eventListener['type'] == evt.type.toLowerCase()) {
            returnValue = eventListener['listener'].apply(this, [evt]);

            if (returnValue === false) {
              // event cancelled
              return false;
            }
          }
        }
      }

      return true;
    }
  }], [{
    key: "applyMixin",
    value: function applyMixin(derivedCtor) {
      var baseCtors = [EventTargetMixin];
      baseCtors.forEach(function (baseCtor) {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach(function (name) {
          if (name !== 'constructor') {
            derivedCtor.prototype[name] = baseCtor.prototype[name];
          }
        });
      });
    }
  }]);

  return EventTargetMixin;
}();

oj.EventTargetMixin = EventTargetMixin;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var GenericEvent = function GenericEvent(type, options) {
  _classCallCheck(this, GenericEvent);

  this.type = type;
  this.options = options;

  if (options != null) {
    this['detail'] = options['detail'];
  }
};

oj.GenericEvent = GenericEvent;

});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojdataprovider',['ojs/ojcore', 'ojs/ojeventtarget'], function(oj)
{
  "use strict";
  var GenericEvent = oj.GenericEvent;


/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * The interface for AttributeExprFilterDef
 *
 *
 * @export
 * @interface AttributeExprFilterDef
 * @since 8.0.0
 * @ojsignature {target: "Type",
 *               value: "interface AttributeExprFilterDef<D>",
 *               genericParameters: [{"name": "D", "description": "Type of Data"}]}
 */

/**
 * Property which contains an expression specifies which attribute to filter on.
 *
 * @since 8.0.0
 * @export
 * @expose
 * @memberof AttributeExprFilterDef
 * @instance
 * @name attribute
 * @type {AttributeFilterDef.AttributeExpression | string}
 * @ojtsexample <caption>Attribute filter definition which filters on DepartmentId value 10</caption>
 * {op: '$eq', attribute: 'DepartmentId', value: 10}
 */

/**
 * Operator to apply for the filter. Valid operators defined in the AttributeFilterOperator union type are the strings:
 * <ul>
 *   <li>$co The entire operator value must be a substring of the attribute value for a match.</li>
 *   <li>$eq The attribute and operator values must be identical for a match.</li>
 *   <li>$ew The entire operator value must be a substring of the attribute value matching at the end of the attribute value.  This criterion is satisfied if the two strings are identical.</li>
 *   <li>$pr If the attribute has a non-empty or non-null value, or if it contains a non-empty node for complex attributes, there is a match.</li>
 *   <li>$gt If the attribute value is greater than the operator value, there is a match.</li>
 *   <li>$ge If the attribute value is greater than or equal to the operator value, there is a match.</li>
 *   <li>$lt If the attribute value is less than the operator value, there is a match.</li>
 *   <li>$le If the attribute value is less than or equal to the operator value, there is a match.</li>
 *   <li>$ne The attribute and operator values are not identical.</li>
 *   <li>$regex If the attribute value satisfies the regular expression, there is a match.</li>
 *   <li>$sw The entire operator value must be a substring of the attribute value, starting at the beginning of the attribute value.  This criterion is satisfied if the two strings are identical.</li>
 * </ul>
 *
 *
 * @since 8.0.0
 * @export
 * @expose
 * @memberof AttributeExprFilterDef
 * @instance
 * @name op
 * @type {AttributeFilterDef.AttributeOperator}
 */

/**
 * Specifies the value to filter for.
 *
 * @since 8.0.0
 * @export
 * @expose
 * @memberof AttributeExprFilterDef
 * @instance
 * @name value
 * @type {any}
 * @ojtsexample
 * <caption>Filter definition which filters on DepartmentId value 10</caption>
 * {op: '$eq', attribute: 'DepartmentId', value: 10}
 */

/**
 * End of jsdoc
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * The interface for AttributeExprFilter
 *
 *
 * @export
 * @interface AttributeExprFilter
 * @extends AttributeExprFilterDef
 * @extends BaseDataFilter
 * @since 8.0.0
 * @ojsignature {target: "Type",
 *               value: "interface AttributeExprFilter<D> extends AttributeExprFilterDef<D>, BaseDataFilter<D>",
 *               genericParameters: [{"name": "D", "description": "Type of Data"}]}
 */

/**
 * End of jsdoc
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @export
 * @interface AttributeFilterDef
 * @since 7.0.0
 * @ojsignature {target: "Type",
 *               value: "interface AttributeFilterDef<D>",
 *               genericParameters: [{"name": "D", "description": "Type of Data"}]}
 * @classdesc Defines a kind of {@link DataFilter.FilterDef} which applies to the attributes in item data.
 */

/**
 * Operator to apply for the filter.
 * @since 7.0.0
 * @export
 * @expose
 * @memberof AttributeFilterDef
 * @instance
 * @name op
 * @type {AttributeFilterDef.AttributeOperator}
 */

/**
 * Specifies the value to filter for. Value should be an object which specifies attribute/value pairs to filter on. The op will be applied to each attribute/value pair and
 * the whole will be AND'd. For subobjects, please specify them in a nested structure.
 *
 *
 * @since 7.0.0
 * @export
 * @expose
 * @memberof AttributeFilterDef
 * @instance
 * @name value
 * @type {any}
 * @ojtsexample
 * <caption>Filter definition which filters on DepartmentId value 10</caption>
 * {op: '$eq', value: {DepartmentId: 10}}
 * @ojtsexample
 * <caption>Filter definition which filters on DepartmentId value 10 and DepartmentName is Hello</caption>
 * {op: '$eq', value: {DepartmentId: 10, DepartmentName: 'Hello'}}
 * @ojtsexample
 * <caption>Filter definition which filters on subobject Location State is California and DepartmentName is Hello</caption>
 * {op: '$eq', value: {DepartmentName: 'Hello', Location: {State: 'California'}}}
 */

/**
 * AttributeOperator enum
 * <br>
 * <p>The operators are based on the filtering spec of the RFC 7644 SCIM
 * protocol:
 * <br>
 * {@link https://tools.ietf.org/html/rfc7644#section-3.4.2|SCIM Filtering}
 * <br>
 * <p>
 *
 * @export
 * @enum {string}
 * @name AttributeOperator
 * @memberof AttributeFilterDef
 * @property {string} $co=$co The entire operator value must be a substring of the attribute value for a match.
 * @property {string} $eq=$eq The attribute and operator values must be identical for a match.
 * @property {string} $ew=$ew The entire operator value must be a substring of the attribute value matching at the end of the attribute value.  This criterion is satisfied if the two strings are identical.
 * @property {string} $pr=$pr If the attribute has a non-empty or non-null value, or if it contains a non-empty node for complex attributes, there is a match.
 * @property {string} $gt=$gt If the attribute value is greater than the operator value, there is a match.
 * @property {string} $ge=$ge If the attribute value is greater than or equal to the operator value, there is a match.
 * @property {string} $lt=$lt If the attribute value is less than the operator value, there is a match.
 * @property {string} $le=$le If the attribute value is less than or equal to the operator value, there is a match.
 * @property {string} $ne=$ne The attribute and operator values are not identical.
 * @property {string} $regex=$regex If the attribute value satisfies the regular expression, there is a match.
 * @property {string} $sw=$sw The entire operator value must be a substring of the attribute value, starting at the beginning of the attribute value.  This criterion is satisfied if the two strings are identical.
 * @since 9.0.0
 */

/**
 * AttributeExpression enum
 * <br>
 * <p>
 * Attribute expressions supported
 *
 * @export
 * @enum {string}
 * @name AttributeExpression
 * @memberof AttributeFilterDef
 * @property {string} *=* Attribute wildcard
 * @since 9.0.0
 */

/**
 * End of jsdoc
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @export
 * @interface AttributeFilter
 * @extends AttributeFilterDef
 * @extends BaseDataFilter
 * @since 7.0.0
 * @ojsignature {target: "Type",
 *               value: "interface AttributeFilter<D> extends AttributeFilterDef<D>, BaseDataFilter<D>",
 *               genericParameters: [{"name": "D", "description": "Type of Data"}]}
 * @classdesc Defines a kind of {@link DataFilter.Filter} which applies to the attributes in item data.
 */

/**
 * End of jsdoc
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @export
 * @interface CompoundFilterDef
 * @since 7.0.0
 * @ojsignature {target: "Type",
 *               value: "interface CompoundFilterDef<D>",
 *               genericParameters: [{"name": "D", "description": "Type of Data"}]}
 * @classdesc Defines a kind of {@link DataFilter.FilterDef} which applies to the compound filter definitions.
 */

/**
 * Operator to apply for the filter. Valid operators defined in the CompoundFilterOperator union type are the strings:
 * <ul>
 *   <li>$and The filters in the criteria array will be AND'd.</li>
 *   <li>$or The filters in the criteria array will be OR'd.</li>
 * </ul>
 *
 * @since 7.0.0
 * @export
 * @expose
 * @memberof CompoundFilterDef
 * @instance
 * @name op
 * @type {CompoundFilterDef.CompoundOperator}
 */

/**
 * Array of FilterDefs on which to apply the operator
 *
 *
 * @since 7.0.0
 * @export
 * @expose
 * @memberof CompoundFilterDef
 * @instance
 * @name criteria
 * @type {Array.<AttributeFilterDef | AttributeExprFilterDef | CompoundFilterDef>}
 * @ojsignature {target: "Type",
 *               value: "Array<AttributeFilterDef<D> | AttributeExprFilterDef<D> | CompoundFilterDef<D>>"}
 */

/**
 * CompoundOperator enum
 * <br>
 * <p>The operators are based on the filtering spec of the RFC 7644 SCIM
 * protocol:
 * <br>
 * {@link https://tools.ietf.org/html/rfc7644#section-3.4.2|SCIM Filtering}
 * <br>
 * <p>
 *
 * @export
 * @enum {string}
 * @name CompoundOperator
 * @memberof CompoundFilterDef
 * @property {string} $and=$and The filter is only a match if both expressions evaluate to true.
 * @property {string} $or=$or The filter is a match if either expression evaluates to true.
 * @since 5.0.0
 */

/**
 * End of jsdoc
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @export
 * @interface CompoundFilter
 * @extends CompoundFilterDef
 * @extends BaseDataFilter
 * @since 7.0.0
 * @ojsignature {target: "Type",
 *               value: "interface CompoundFilter<D> extends CompoundFilterDef<D>, BaseDataFilter<D>",
 *               genericParameters: [{"name": "D", "description": "Type of Data"}]}
 * @classdesc Defines a kind of {@link DataFilter.Filter} which applies to the compound filters.
 */

/**
 * End of jsdoc
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @export
 * @interface TextFilterDef
 * @since 8.0.0
 * @ojsignature {target: "Type",
 *               value: "interface TextFilterDef",
 *               genericParameters: [{"name": "D", "description": "Type of Data"}]}
 * @classdesc Defines a kind of {@link DataFilter.FilterDef} which applies to text filter definitions. A text filter definition
 * specifies a string which should be used for filtering and leaves it up to the DataProvider to decide which fields are filtered
 * and how the filtering happens (such as whether the filtering is an exact match or contains, etc).
 */

/**
 * Specifies the text to filter for. It is up to the DataProvider implementation to decide which attributes to
 * apply the filter to and also the exact filtering logic used, such as case insensitivity, etc. In addition, for
 * attributes which contain non-string values, the type coercion rule expected is to call toString() on that value.
 * If the value is an object which does not have a string representation then the value does not satisfy the filter.
 * @since 8.0.0
 * @export
 * @expose
 * @memberof TextFilterDef
 * @instance
 * @name text
 * @type {string}
 * @ojtsexample
 * <caption>Filter definition which filters on the text 'abc search'</caption>
 * {text: 'abc search'}
 */

/**
 * End of jsdoc
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @export
 * @interface TextFilter
 * @extends TextFilterDef
 * @extends BaseDataFilter
 * @since 8.0.0
 * @ojsignature {target: "Type",
 *               value: "interface TextFilter<D> extends TextFilterDef, BaseDataFilter<D>",
 *               genericParameters: [{"name": "D", "description": "Type of Data"}]}
 * @classdesc Defines a kind of {@link DataFilter.Filter} which applies to text filters. A text filter
 * specifies a string which should be used for filtering and leaves it up to the DataProvider to decide which fields are filtered
 * and how the filtering happens (such as whether the filtering is an exact match or contains, etc).
 */

/**
 * End of jsdoc
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * The interface for Filter
 *
 *
 * @export
 * @interface BaseDataFilter
 * @since 8.0.0
 * @ojsignature {target: "Type",
 *              value: "interface BaseDataFilter<D>",
 *              genericParameters: [{"name": "D", "description": "Type of Data"}]}
 */

/**
 * Specifies a filter function which has the same signature as the the callback
 * which is specified for the JS Array.filter():
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter
 * This function will be optionally used by the DataProvider to do local filtering.
 * This function is required by the DataProvider so that it is possible for DataProvider
 * implementations to at least do local filtering.
 *
 *
 * @since 8.0.0
 * @export
 * @expose
 * @memberof BaseDataFilter
 * @instance
 * @name filter
 * @method
 * @param {any} item The current element being processed in the array.
 * @param {number=} index The index of the current element being processed in the array.
 * @param {Array=} array The array filter was called upon.
 * @return {boolean} True if the element satisfies the filter.
 * @ojsignature {target: "Type",
 *               value: "(item: D, index?: number, array?: Array<D>): boolean;"}
 */

/**
 * @export
 * @namespace DataFilter
 * @since 8.0.0
 * @ojsignature {target: "Type",
 *              value: "namespace DataFilter"}
 * @classdesc Contains definitions for {@link DataFilter.Filter} used in {@link FetchListParameters#filterCriterion} and {@link FetchByOffsetParameters#filterCriterion}
 */

/**
 * @typedef {Object} DataFilter.FilterDef Union type of all FilterDef types.
 * @ojsignature [{target: "Type",
 *               value: "AttributeFilterDef<D> | AttributeExprFilterDef<D> | CompoundFilterDef<D> | TextFilterDef"},
 *               {target:"Type", value:"<D>", for:"genericTypeParameters"}]
 * @classdesc Union type containing {@link AttributeFilterDef}, {@link AttributeExprFilterDef}, {@link CompoundFilterDef}, and {@link TextFilterDef}
 */

/**
 * @typedef {Object} DataFilter.Filter Union type of all Filter types.
 * @ojsignature [{target: "Type",
 *               value: "AttributeFilter<D> | AttributeExprFilter<D> | CompoundFilter<D> | TextFilter<D>"},
 *               {target:"Type", value:"<D>", for:"genericTypeParameters"}]
 * @classdesc Union type containing {@link AttributeFilter}, {@link AttributeExprFilter}, {@link CompoundFilter}, and {@link TextFilter}
 */

/**
 * End of jsdoc
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @export
 * @expose
 * @interface AttributeFilterCapability
 * @since 6.1.0
 * @ojsignature {target: "Type",
 *               value: "interface AttributeFilterCapability"}
 * @classdesc Defines the properties in the attribute property used in {@link FetchCapability}
 */

/**
 * Optionally indicates what attribute expansion (as in the addition of more attributes) capability the DataProvider has.
 * The exact shape of this property are determined by the DataProvider.
 *
 * @since 6.1.0
 * @export
 * @expose
 * @memberof AttributeFilterCapability
 * @instance
 * @name expansion
 * @type {object=}
 * @ojsignature {target: "Type",
 *               value: "?object"}
 */

/**
 * Optionally indicates what capability the DataProvider has in terms of attribute ordering. By default there is no inherent
 * attribute ordering on the item data property bag. The exact shape of this property are determined by the DataProvider.
 *
 *
 * @since 6.1.0
 * @export
 * @expose
 * @memberof AttributeFilterCapability
 * @instance
 * @name ordering
 * @type {object=}
 * @ojsignature {target: "Type",
 *               value: "?object"}
 */

/**
 * Optionally indicates what capability the DataProvider has in terms of being able to specify the item data shape.
 * The exact shape of this property are determined by the DataProvider.
 *
 *
 * @since 6.1.0
 * @export
 * @expose
 * @memberof AttributeFilterCapability
 * @instance
 * @name defaultShape
 * @type {object=}
 * @ojsignature {target: "Type",
 *               value: "?object"}
 */

/**
 * End of jsdoc
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @export
 * @interface FetchCapability
 * @since 6.1.0
 * @ojsignature {target: "Type",
 *               value: "interface FetchCapability"}
 * @classdesc Defines the result from the DataProvider method {@link DataProvider#getCapability} for capability "fetchCapability"
 */

/**
 * Optional detailed attribute filter capability information
 *
 *
 * @since 6.1.0
 * @export
 * @expose
 * @memberof FetchCapability
 * @instance
 * @name attributeFilter
 * @type {AttributeFilterCapability=}
 * @ojsignature {target: "Type",
 *               value: "?AttributeFilterCapability"}
 */

/**
 * Optional detailed caching capability information
 *
 *
 * @since 9.1.0
 * @export
 * @expose
 * @memberof FetchCapability
 * @instance
 * @name caching
 * @type {string}
 * @ojsignature {target: "Type",
 *               value: "? 'all' | 'none' | 'visitedByCurrentIterator'"}
 */

/**
 * End of jsdoc
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @export
 * @interface FilterCapability
 * @since 5.0.0
 * @ojsignature {target: "Type",
 *               value: "interface FilterCapability"}
 * @classdesc Defines the result from the DataProvider method {@link DataProvider#getCapability} for capability "filter"
 */

/**
 * An array of supported filter operator strings. The filter operators may be for {@link AttributeFilter} or {@link CompoundFilter}.
 *
 *
 * @since 5.0.0
 * @export
 * @expose
 * @memberof FilterCapability
 * @instance
 * @name operators
 * @type {Array.<AttributeFilterDef.AttributeOperator | CompoundFilterDef.CompoundOperator>=}
 * @ojsignature {target: "Type",
 *               value: "?Array.<AttributeFilterDef.AttributeOperator | CompoundFilterDef.CompoundOperator>"}
 */

/**
 * An array of supported attribute expressions.
 *
 *
 * @since 5.0.0
 * @export
 * @expose
 * @memberof FilterCapability
 * @instance
 * @name attributeExpression
 * @type {Array.<AttributeFilterDef.AttributeExpression>=}
 * @ojsignature {target: "Type",
 *               value: "?Array.<AttributeFilterDef.AttributeExpression>"}
 */

/**
 * Existence of this property indicates that {@link TextFilter} is supported. The property value can be used convey more information to the caller.
 *
 *
 * @since 8.0.0
 * @export
 * @expose
 * @memberof FilterCapability
 * @instance
 * @name textFilter
 * @type {any=}
 * @ojsignature {target: "Type",
 *               value: "?any"}
 */

/**
 * End of jsdoc
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @since 4.1.0
 * @export
 * @interface FetchByKeysParameters
 * @ojsignature {target: "Type",
 *               value: "interface FetchByKeysParameters<K>",
 *               genericParameters: [{"name": "K", "description": "Type of Key"}]}
 * @classdesc Defines the parameters to the DataProvider methods {@link DataProvider#fetchByKeys} and {@link DataProvider#containsKeys}
 */

/**
 * Keys for rows to fetch
 *
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof FetchByKeysParameters
 * @instance
 * @name keys
 * @type {Set.<any>}
 * @ojsignature {target: "Type",
 *               value: "Set<K>"}
 */

/**
 * Optional string describing local or global data set to fetch. Local refers to the current fetched data whereas global is the entire data set.
 * The usage is primarily directed towards selection where a selection is on a different part of the data set than that of the local data set.
 *
 *
 * @since 7.0.0
 * @export
 * @expose
 * @memberof FetchByKeysParameters
 * @instance
 * @name scope
 * @type {FetchByKeysParameters.Scope=}
 * @ojsignature {target: "Type",
 *               value: "?FetchByKeysParameters.Scope"}
 * @ojsignature {target: "Type",
 *               value: "?'local' | 'global'"}
 */

/**
 * attributes to include in the result. If specified, then at least these set of attributes will be included in each row
 * results. If not specified then the default attributes will be included.
 *
 *
 * @since 6.1.0
 * @export
 * @expose
 * @memberof FetchByKeysParameters
 * @instance
 * @name attributes
 * @type {Array.<string | FetchAttribute>}
 * @ojsignature {target: "Type",
 *               value: "?Array<string | FetchAttribute>"}
 */

/**
 * Scope enum
 * <br>
 * <p>
 * Scope supported
 *
 * @export
 * @enum {string}
 * @name Scope
 * @memberof FetchByKeysParameters
 * @property {string} local=local Local refers to the current fetched data.
 * @property {string} global=global Global is the entire data set
 * @since 9.0.0
 */

/**
 * @since 4.1.0
 * @export
 * @interface FetchByKeysResults
 * @ojsignature {target: "Type",
 *               value: "interface FetchByKeysResults<K, D>",
 *               genericParameters: [{"name": "K", "description": "Type of Key"}, {"name": "D", "description": "Type of Data"}]}
 * @classdesc FetchByKeysResults defines the result from the DataProvider method {@link DataProvider#fetchByKeys}
 */

/**
 * The parameters used for the fetch call.
 *
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof FetchByKeysResults
 * @instance
 * @name fetchParameters
 * @type {FetchByKeysParameters}
 * @ojsignature {target: "Type",
 *               value: "FetchByKeysParameters<K>"}
 */

/**
 * Map of keys and corresponding {@link Item}. The map will only contain keys which were actually found.
 *
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof FetchByKeysResults
 * @instance
 * @name results
 * @type {Map.<*, Item>}
 * @ojsignature {target: "Type",
 *               value: "Map<K, Item<K, D>>"}
 */

/**
 * @since 4.1.0
 * @export
 * @interface ContainsKeysResults
 * @ojsignature {target: "Type",
 *               value: "interface ContainsKeysResults<K>",
 *               genericParameters: [{"name": "K", "description": "Type of Key"}]}
 * @classdesc ContainsKeysResults defines the results from the DataProvider method {@link DataProvider#containsKeys}
 */

/**
 * The parameters used for the containsKeys call.
 *
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof ContainsKeysResults
 * @instance
 * @name containsParameters
 * @type {FetchByKeysParameters}
 * @ojsignature {target: "Type",
 *               value: "FetchByKeysParameters<K>"}
 */

/**
 * Requested keys subset which are contained in the DataProvider.
 *
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof ContainsKeysResults
 * @instance
 * @name results
 * @type {Set.<any>}
 * @ojsignature {target: "Type",
 *               value: "Set<K>"}
 */

/**
 * end of jsdoc
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @since 4.1.0
 * @export
 * @interface SortCriterion
 * @ojsignature {target: "Type",
 *               value: "interface SortCriterion<D>",
 *               genericParameters: [{"name": "D", "description": "Type of Data"}]}
 * @classdesc Defines the sort criterion objects in {@link FetchListParameters#sortCriterion}
 */

/**
 * sort attribute upon which the data should be sorted.
 *
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof SortCriterion
 * @instance
 * @name attribute
 * @type {string}
 * @ojsignature {target: "Type",
 *               value: "keyof D"}
 */

/**
 * sort direction, either "ascending" or "descending".
 *
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof SortCriterion
 * @instance
 * @name direction
 * @type {string}
 */

/**
 * End of jsdoc
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 *
 * @since 4.1.0
 * @export
 * @interface DataMapping
 * @ojsignature {target: "Type",
 *               value: "interface DataMapping <K, D, Kin, Din>",
 *               genericParameters: [{"name": "K", "description": "Type of output key"}, {"name": "D", "description": "Type of output data"},
 *                    {"name": "Kin", "description": "Type of input key"}, {"name": "Din", "description": "Type of input data"}]}
 */

/**
 * Field mapping function which takes an item and returns the mapped item
 *
 *
 * @export
 * @expose
 * @memberof DataMapping
 * @instance
 * @name mapFields
 * @type {Function}
 * @ojsignature {target: "Type",
 *               value: "(item: Item<Kin, Din>) => Item<K, D>"}
 */

/**
 * Optional FilterCriterion mapping function which takes filterOperator and returns the mapped filterOperator
 *
 *
 * @export
 * @expose
 * @memberof DataMapping
 * @instance
 * @name mapFilterCriterion
 * @type {Function}
 * @ojsignature {target: "Type",
 *               value: "?(filterCriterion: DataFilter.Filter<D>) => DataFilter.Filter<Din>"}
 */

/**
 * Optional FilterCriterion unmapping function which takes a mapped filterOperator and returns the unmapped filterOperator
 *
 *
 * @export
 * @expose
 * @memberof DataMapping
 * @instance
 * @name unmapFilterCriterion
 * @type {Function}
 * @ojsignature {target: "Type",
 *               value: "?(filterCriterion: DataFilter.Filter<Din>) => DataFilter.Filter<D>"}
 */

/**
 * Optional SortCriterion mapping function which takes sortCriteria and returns the mapped sortCriteria
 *
 *
 * @export
 * @expose
 * @memberof DataMapping
 * @instance
 * @name mapSortCriteria
 * @type {Function}
 * @ojsignature {target: "Type",
 *               value: "?(sortCriteria: Array<SortCriterion<D>>) => Array<SortCriterion<Din>>"}
 */

/**
 * Optional SortCriterion unmapping function which takes mapped sortCriteria and returns the unmapped sortCriteria
 *
 *
 * @export
 * @expose
 * @memberof DataMapping
 * @instance
 * @name unmapSortCriteria
 * @type {Function}
 * @ojsignature {target: "Type",
 *               value: "?(sortCriteria: Array<SortCriterion<Din>>) => Array<SortCriterion<D>>"}
 */

/**
 * End of jsdoc
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @since 4.1.0
 * @export
 * @ojsignature {target: "Type",
 *               value: "interface FetchFunc<K, D>",
 *               genericParameters: [{"name": "K", "description": "Type of Key"}, {"name": "D", "description": "Type of Data"}]}
 * @classdesc Defines the interface for the {@link DataProvider#fetchFirst} method
 */

/**
 * @ojsignature {target: "Type",
 *               value: "(FetchListParameters?): AsyncIterable<FetchListResult<K, D>>"}
 */

/**
 * end of jsdoc
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @since 4.1.0
 * @export
 * @interface FetchListParameters
 * @ojsignature {target: "Type",
 *               value: "interface FetchListParameters<D>",
 *               genericParameters: [{"name": "D", "description": "Type of Data"}]}
 * @classdesc Defines the parameters to the DataProvider method {@link DataProvider#fetchFirst}
 */

/**
 * Optional number of rows to fetch.  If fewer than that number of rows exist, the fetch will succeed but be truncated.
 * A value of -1 will return all rows or the maximum size supported by the DataProvider.
 * If the size is not specified, then the DataProvider implementation will determine how many rows to return.
 *
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof FetchListParameters
 * @instance
 * @name size
 * @type {number=}
 * @ojsignature {target: "Type",
 *               value: "?number"}
 */

/**
 * Optional sort criteria to apply.
 *
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof FetchListParameters
 * @instance
 * @name sortCriteria
 * @type {Array.<SortCriterion>}
 * @ojsignature {target: "Type",
 *               value: "?Array<SortCriterion<D>>"}
 * @ojtsexample
 * [{attribute: 'DepartmentName', direction: 'ascending'}]
 */

/**
 * Optional filter criterion to apply. The filter criterion would be composed of a
 * supported {@link DataFilter.Filter} such as a {@link AttributeFilter}, {@link AttributeExprFilter}, {@link CompoundFilter}. {@link TextFilter}
 *
 * @ojtsexample
 * let filterDef = {op: '$or', criteria: [{op: '$eq', value: {name: 'Bob'}}, {op: '$gt', value: {level: 'Low'}}]};
 * let filter = FilterFactory.getFilter(filterDef); // create a standard filter using the filterFactory.
 * let fetchListParam = {filterCriterion: filter, size: 5};
 *
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof FetchListParameters
 * @instance
 * @name filterCriterion
 * @type {DataFilter.Filter}
 * @ojsignature {target: "Type",
 *               value: "?DataFilter.Filter<D>"}
 */

/**
 * Optional attributes to include in the result. If specified, then at least these set of attributes must be included in each row
 * in the data array in the FetchListResult. If not specified then the default attributes must be included.
 *
 *
 * @since 6.1.0
 * @export
 * @expose
 * @memberof FetchListParameters
 * @instance
 * @name attributes
 * @type {Array.<string | FetchAttribute>}
 * @ojsignature {target: "Type",
 *               value: "?Array<string | FetchAttribute>"}
 * @ojtsexample
 * ['!lastName', '@default'] // all attributes except lastName
 * @ojtsexample
 * ['!lastName', '@default', {name: 'location', attributes: ['address line 1', 'address line 2']}] // nested example
 *
 */

/**
 * Optional symbol that can uniquely identify the consumer of the DataProvider.
 *
 * Each consumer can call Symbol() to obtain a unique symbol, which can be
 * stored and reused on each subsequent call to fetchFirst. Note that Symbol()
 * returns a different unique symbol every time, so it should not be called
 * every time the consumer calls fetchFirst.
 *
 * There should only be one active iterator per clientId. All previous iterators
 * obtained with the same clientId should be considered invalid. This is used to
 * optimize resource usage in some DataProvider implementations.
 *
 *
 * @since 9.0.0
 * @export
 * @expose
 * @memberof oj.FetchListParameters
 * @instance
 * @name clientId
 * @type {symbol}
 * @ojsignature {target: "Type",
 *               value: "?symbol"}
 */

/**
 * End of jsdoc
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @since 4.1.0
 * @export
 * @interface FetchListResult
 * @ojsignature {target: "Type",
 *               value: "interface FetchListResult<K, D>",
 *               genericParameters: [{"name": "K", "description": "Type of Key"}, {"name": "D", "description": "Type of Data"}]}
 * @classdesc Defines the results from the DataProvider method {@link DataProvider#fetchFirst}.
 */

/**
 * The {@link FetchListParameters} used for the fetch call.
 * In addition, the property fetchParameters is not only the parameter passed through from fetchFirst.
 * The sortCriteria of fetchParameters is the sort criteria specified in fetchFirst parameter, it also include the implicitSort criteria specified in data provider constructor.
 * For example, if implicitSort is set in ArrayDataProvider constructor, it will be returned as part of the sortCriteria of fetchParameters.
 * The collection components, such as ojTable, will look at the sortCriteria to put appropriate sort icon on the UI rendered.
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof FetchListResult
 * @instance
 * @name fetchParameters
 * @type {FetchListParameters}
 * @ojsignature {target: "Type",
 *               value: "FetchListParameters<D>"}
 * @ojtsexample <caption>Example of retrieving sortCriteria from FetchListResult:</caption>
 * let asyncIterator = dataprovider.fetchFirst(options)[Symbol.asyncIterator]();
 * let result = await asyncIterator.next();
 * let sortCriteria = result.value.fetchParameters.sortCriteria;
 */

/**
 * Array of data for each row
 *
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof FetchListResult
 * @instance
 * @name data
 * @type {Array.<Object>}
 * @ojsignature {target: "Type",
 *               value: "D[]"}
 */

/**
 * Array of {link@ ItemMetadata} for each row
 *
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof FetchListResult
 * @instance
 * @name metadata
 * @type {Array.<ItemMetadata>}
 * @ojsignature {target: "Type",
 *               value: "Array<ItemMetadata<K>>"}
 */

/**
 * end of jsdoc
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @since 4.1.0
 * @export
 * @interface ItemMetadata
 * @ojsignature {target: "Type",
 *               value: "interface ItemMetadata<K>",
 *               genericParameters: [{"name": "K", "description": "Type of Key"}]}
 * @classdesc Defines the item metadata objects in {@link FetchListResult#metadata}.  Note that key is the only mandatory property,
 * implementations can provide additional properties as needed.
 */

/**
 * The key for the row
 *
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof ItemMetadata
 * @instance
 * @name key
 * @type {any}
 * @ojsignature {target: "Type",
 *               value: "K"}
 */

/**
 * An optional message such as error associated with the row
 *
 * @since 9.0.0
 * @export
 * @expose
 * @memberof ItemMetadata
 * @instance
 * @name message
 * @type {ItemMessage=}
 * @ojsignature {target: "Type",
 *               value: "?ItemMessage"}
 */

/**
 * End of jsdoc
 */












var AttributeFilterOperator;

(function (AttributeFilterOperator) {
  var AttributeOperator;

  (function (AttributeOperator) {
    AttributeOperator["$co"] = "$co";
    AttributeOperator["$eq"] = "$eq";
    AttributeOperator["$ew"] = "$ew";
    AttributeOperator["$pr"] = "$pr";
    AttributeOperator["$gt"] = "$gt";
    AttributeOperator["$ge"] = "$ge";
    AttributeOperator["$lt"] = "$lt";
    AttributeOperator["$le"] = "$le";
    AttributeOperator["$ne"] = "$ne";
    AttributeOperator["$regex"] = "$regex";
    AttributeOperator["$sw"] = "$sw";
  })(AttributeOperator = AttributeFilterOperator.AttributeOperator || (AttributeFilterOperator.AttributeOperator = {}));
})(AttributeFilterOperator || (AttributeFilterOperator = {}));

oj['AttributeFilterOperator'] = AttributeFilterOperator;
oj['AttributeFilterOperator']['AttributeOperator'] = AttributeFilterOperator.AttributeOperator;



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * The interface for AttributeFilterOperator
 *
 *
 * @export
 * @interface AttributeFilterOperator
 * @extends FilterOperator
 * @since 5.0.0
 * @ojsignature {target: "Type",
 *               value: "interface AttributeFilterOperator<D>",
 *               genericParameters: [{"name": "D", "description": "Type of Data"}]}
 * @ojdeprecated {since: '7.0.0', description: 'Use AttributeFilter instead.'}
 */

/**
 * Operator one of enum AttributeOperator {$co, $eq, $ew, $pr, $gt, $ge, $lt, $le, $ne, $regex, $sw}
 *
 *
 * @since 5.0.0
 * @export
 * @expose
 * @memberof AttributeFilterOperator
 * @instance
 * @name op
 * @type {AttributeFilterOperator.AttributeOperator}
 */

/**
 * Attribute
 *
 *
 * @since 5.0.0
 * @export
 * @expose
 * @memberof AttributeFilterOperator
 * @instance
 * @name attribute
 * @type {string}
 */

/**
 * Value
 *
 *
 * @since 5.0.0
 * @export
 * @expose
 * @memberof AttributeFilterOperator
 * @instance
 * @name value
 * @type {any}
 */

/**
 * AttributeOperator enum
 * <br>
 * <p>The operators are based on the filtering spec of the RFC 7644 SCIM
 * protocol:
 * <br>
 * {@link https://tools.ietf.org/html/rfc7644#section-3.4.2|SCIM Filtering}
 * <br>
 * <p>
 *
 * @export
 * @enum {string}
 * @name AttributeOperator
 * @memberof AttributeFilterOperator
 * @property {string} $co=$co The entire operator value must be a substring of the attribute value for a match.
 * @property {string} $eq=$eq The attribute and operator values must be identical for a match.
 * @property {string} $ew=$ew The entire operator value must be a substring of the attribute value matching at the end of the attribute value.  This criterion is satisfied if the two strings are identical.
 * @property {string} $pr=$pr If the attribute has a non-empty or non-null value, or if it contains a non-empty node for complex attributes, there is a match.
 * @property {string} $gt=$gt If the attribute value is greater than the operator value, there is a match.
 * @property {string} $ge=$ge If the attribute value is greater than or equal to the operator value, there is a match.
 * @property {string} $lt=$lt If the attribute value is less than the operator value, there is a match.
 * @property {string} $le=$le If the attribute value is less than or equal to the operator value, there is a match.
 * @property {string} $ne=$ne The attribute and operator values are not identical.
 * @property {string} $regex=$regex If the attribute value satisfies the regular expression, there is a match.
 * @property {string} $sw=$sw The entire operator value must be a substring of the attribute value, starting at the beginning of the attribute value.  This criterion is satisfied if the two strings are identical.
 * @since 5.0.0
 */

/**
 * End of jsdoc
 */








var CompoundFilterOperator;

(function (CompoundFilterOperator) {
  var CompoundOperator;

  (function (CompoundOperator) {
    CompoundOperator["$and"] = "$and";
    CompoundOperator["$or"] = "$or";
  })(CompoundOperator = CompoundFilterOperator.CompoundOperator || (CompoundFilterOperator.CompoundOperator = {}));
})(CompoundFilterOperator || (CompoundFilterOperator = {}));

oj['CompoundFilterOperator'] = CompoundFilterOperator;
oj['CompoundFilterOperator']['CompoundOperator'] = CompoundFilterOperator.CompoundOperator;



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * The interface for CompoundFilterOperator
 *
 *
 * @export
 * @interface CompoundFilterOperator
 * @extends FilterOperator
 * @since 5.0.0
 * @ojsignature {target: "Type",
 *               value: "interface CompoundFilterOperator<D>",
 *               genericParameters: [{"name": "D", "description": "Type of Data"}]}
 * @ojdeprecated {since: '7.0.0', description: 'Use CompoundFilter instead.'}
 */

/**
 * Operator one of enum CompoundOperator {$and, $or}
 *
 *
 * @since 5.0.0
 * @export
 * @expose
 * @memberof CompoundFilterOperator
 * @instance
 * @name op
 * @type {CompoundFilterOperator.CompoundOperator}
 */

/**
 * Array of FilterOperators on which to apply the operator
 *
 *
 * @since 5.0.0
 * @export
 * @expose
 * @memberof CompoundFilterOperator
 * @instance
 * @name criteria
 * @type {Array.<FilterOperator>}
 * @ojsignature {target: "Type",
 *               value: "Array<FilterOperator<D>>"}
 */

/**
 * CompoundOperator enum
 * <br>
 * <p>The operators are based on the filtering spec of the RFC 7644 SCIM
 * protocol:
 * <br>
 * {@link https://tools.ietf.org/html/rfc7644#section-3.4.2|SCIM Filtering}
 * <br>
 * <p>
 *
 * @export
 * @enum {string}
 * @name CompoundOperator
 * @memberof CompoundFilterOperator
 * @property {string} $and=$and The filter is only a match if both expressions evaluate to true.
 * @property {string} $or=$or The filter is a match if either expression evaluates to true.
 * @since 5.0.0
 */

/**
 * End of jsdoc
 */

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }


var DataCache = /*#__PURE__*/function () {
  function DataCache() {
    _classCallCheck(this, DataCache);

    this._handleMutationAdd = function (eventDetail) {
      var _a, _b;

      var self = this;
      var eventDetailBeforeKeys = eventDetail[DataCache._BEFOREKEYS];
      var eventDetailKeys = eventDetail[DataCache._KEYS];
      var eventDetailKeysArray = [];
      eventDetailKeys.forEach(function (key) {
        eventDetailKeysArray.push(key);
      });
      var eventDetailData = eventDetail[DataCache._DATA];
      var eventDetailMetadata = eventDetail[DataCache._METADATA];
      var eventDetailIndexes = eventDetail[DataCache._INDEXES];

      if (eventDetailKeysArray && eventDetailKeysArray.length > 0) {
        if (eventDetailIndexes) {
          eventDetailKeysArray.forEach(function (key, index) {
            self._items.splice(eventDetailIndexes[index], 0, new self.Item(eventDetailMetadata[index], eventDetailData[index]));
          });
        } else if (eventDetailBeforeKeys) {
          var eventDetailBeforeKeysClone = Object.assign([], eventDetailBeforeKeys);
          var eventDetailKeysClone = Object.assign(new Set(), eventDetail[DataCache._KEYS]);
          var eventDetailDataClone = Object.assign([], eventDetail[DataCache._DATA]);
          var eventDetailMetadataClone = Object.assign([], eventDetail[DataCache._METADATA]); // first find all the beforekeys which are not in our cache, are not null, and are not in the mutation event

          var outOfRangeKeys = [];
          var i, j, key, findKey, outOfRange;

          for (i = 0; i < eventDetailBeforeKeys.length; i++) {
            key = eventDetailBeforeKeys[i];
            outOfRange = true;

            if (key != null) {
              for (j = 0; j < eventDetailKeysArray.length; j++) {
                if (oj.Object.compareValues(eventDetailKeysArray[j], key)) {
                  outOfRange = false;
                  break;
                }
              }

              if (outOfRange) {
                for (j = 0; j < self._items.length; j++) {
                  if (oj.Object.compareValues((_b = (_a = self._items[j]) === null || _a === void 0 ? void 0 : _a.metadata) === null || _b === void 0 ? void 0 : _b.key, key)) {
                    outOfRange = false;
                    break;
                  }
                }
              }
            } else {
              outOfRange = false;
            }

            if (outOfRange) {
              outOfRangeKeys.push(key);
            }
          } // push all keys chained to the outOfRangeKeys to the array


          var keysToCheck = eventDetailBeforeKeys.length;

          while (keysToCheck > 0) {
            for (i = 0; i < eventDetailBeforeKeys.length; i++) {
              findKey = eventDetailBeforeKeys[i];

              if (outOfRangeKeys.indexOf(findKey) >= 0) {
                outOfRangeKeys.push(findKey);
                break;
              }
            }

            keysToCheck--;
          } // remove all out of range keys and their chained keys


          for (i = eventDetailBeforeKeysClone.length - 1; i >= 0; i--) {
            if (outOfRangeKeys.indexOf(eventDetailBeforeKeysClone[i]) >= 0) {
              delete eventDetailBeforeKeysClone[i];
              eventDetailKeysClone.delete(eventDetailBeforeKeysClone[i]);
              delete eventDetailDataClone[i];
              delete eventDetailMetadataClone[i];
            }
          } // insert them into our cache


          eventDetailBeforeKeysClone.forEach(function (beforeKey, beforeKeyIndex) {
            var _a, _b;

            if (beforeKey === null) {
              self._items.push(new self.Item(eventDetailMetadata[beforeKeyIndex], eventDetailData[beforeKeyIndex]));
            } else {
              for (i = 0; i < self._items.length; i++) {
                if (oj.Object.compareValues((_b = (_a = self._items[i]) === null || _a === void 0 ? void 0 : _a.metadata) === null || _b === void 0 ? void 0 : _b.key, beforeKey)) {
                  self._items.splice(i, 0, new self.Item(eventDetailMetadata[beforeKeyIndex], eventDetailData[beforeKeyIndex]));

                  break;
                }
              }
            }
          });
        } else {
          // we don't have index or beforeKeys so we need to sort to figure out where to insert the keys.
          // if there is no sort, then we don't know where the rows go so just push them in at the end.
          if (self._fetchParams && self._fetchParams.sortCriteria != null) {
            var sortCriteria = self._fetchParams.sortCriteria;

            if (sortCriteria) {
              var comparator = self._getSortComparator(sortCriteria);

              var _i, currentData, currentCompare;

              var insertedIndexes = [];
              eventDetailData.forEach(function (data, index) {
                for (_i = 0; _i < self._items.length; _i++) {
                  currentData = self._items[_i].data;
                  currentCompare = comparator(data, currentData);

                  if (currentCompare < 0) {
                    // found insertion point
                    self._items.splice(_i, 0, new self.Item(eventDetailMetadata[index], eventDetailData[index]));

                    insertedIndexes.push(index);
                    break;
                  }
                }
              }); // inserted all the rows we haven't inserted yet at the end

              eventDetailData.forEach(function (data, index) {
                if (insertedIndexes.indexOf(index) < 0) {
                  self._items.push(new self.Item(eventDetailMetadata[index], eventDetailData[index]));
                }
              });
            }
          } else {
            eventDetailData.forEach(function (data, index) {
              self._items.push(new self.Item(eventDetailMetadata[index], eventDetailData[index]));
            });
          }
        }
      }
    };

    this._handleMutationRemove = function (eventDetail) {
      var self = this;
      var eventDetailKeys = eventDetail[DataCache._KEYS];

      if (eventDetailKeys && eventDetailKeys.size > 0) {
        var i;
        eventDetailKeys.forEach(function (key) {
          for (i = self._items.length - 1; i >= 0; i--) {
            if (oj.Object.compareValues(self._items[i].metadata.key, key)) {
              self._items.splice(i, 1);

              break;
            }
          }
        });
      }
    };

    this._handleMutationUpdate = function (eventDetail) {
      var self = this;
      var eventDetailKeys = eventDetail[DataCache._KEYS];
      var eventDetailData = eventDetail[DataCache._DATA];
      var eventDetailMetadata = eventDetail[DataCache._METADATA];

      if (eventDetailData && eventDetailData.length > 0) {
        var i,
            index = 0;
        eventDetailKeys.forEach(function (key) {
          for (i = self._items.length - 1; i >= 0; i--) {
            if (oj.Object.compareValues(self._items[i].metadata.key, key)) {
              self._items.splice(i, 1, new self.Item(eventDetailMetadata[index], eventDetailData[index]));

              break;
            }
          }

          index++;
        });
      }
    };

    this.Item = /*#__PURE__*/function () {
      function _class(metadata, data) {
        _classCallCheck(this, _class);

        this.metadata = metadata;
        this.data = data;
        this[DataCache._METADATA] = metadata;
        this[DataCache._DATA] = data;
      }

      return _class;
    }();

    this.FetchByKeysResults = /*#__PURE__*/function () {
      function _class2(fetchParameters, results) {
        _classCallCheck(this, _class2);

        this.fetchParameters = fetchParameters;
        this.results = results;
        this[DataCache._FETCHPARAMETERS] = fetchParameters;
        this[DataCache._RESULTS] = results;
      }

      return _class2;
    }();

    this.FetchByOffsetResults = /*#__PURE__*/function () {
      function _class3(fetchParameters, results, done) {
        _classCallCheck(this, _class3);

        this.fetchParameters = fetchParameters;
        this.results = results;
        this.done = done;
        this[DataCache._FETCHPARAMETERS] = fetchParameters;
        this[DataCache._RESULTS] = results;
        this[DataCache._DONE] = done;
      }

      return _class3;
    }();

    this._items = [];
  }

  _createClass(DataCache, [{
    key: "addListResult",
    value: function addListResult(result) {
      var self = this;
      var items = [];
      result.value.data.forEach(function (data, index) {
        items.push(new self.Item(result.value.metadata[index], data));
      });
      this._items = this._items.concat(items);
      this._done = result.done;
    }
  }, {
    key: "getDataList",
    value: function getDataList(params, offset) {
      this._fetchParams = params;
      var fetchSize = 25;

      if (params.size != null) {
        if (params.size == -1) {
          fetchSize = this.getSize();
        } else {
          fetchSize = params.size;
        }
      }

      var items = this._items.slice(offset, offset + fetchSize);

      var data = [];
      var metadata = [];
      items.forEach(function (item) {
        data.push(item.data);
        metadata.push(item.metadata);
      });
      return {
        fetchParameters: params,
        data: data,
        metadata: metadata
      };
    }
  }, {
    key: "getDataByKeys",
    value: function getDataByKeys(params) {
      var self = this;
      var results = new Map();

      if (params && params.keys) {
        var i;
        params.keys.forEach(function (key) {
          for (i = 0; i < self._items.length; i++) {
            if (self._items[i].metadata.key == key) {
              results.set(key, self._items[i]);
              break;
            }
          }
        });
      }

      return new this.FetchByKeysResults(params, results);
    }
  }, {
    key: "getDataByOffset",
    value: function getDataByOffset(params) {
      var self = this;
      var results = [];
      var done = true;

      if (params) {
        results = self._items.slice(params.offset, params.offset + params.size);
      }

      return new this.FetchByOffsetResults(params, results, done);
    }
  }, {
    key: "processMutations",
    value: function processMutations(detail) {
      if (detail.remove != null) {
        this._handleMutationRemove(detail.remove);
      }

      if (detail.add != null) {
        this._handleMutationAdd(detail.add);
      }

      if (detail.update != null) {
        this._handleMutationUpdate(detail.update);
      }
    }
  }, {
    key: "reset",
    value: function reset() {
      this._items = [];
      this._done = false;
    }
  }, {
    key: "getSize",
    value: function getSize() {
      return this._items.length;
    }
  }, {
    key: "isDone",
    value: function isDone() {
      return this._done;
    }
  }, {
    key: "_getSortComparator",
    value: function _getSortComparator(sortCriteria) {
      var self = this;
      return function (x, y) {
        var i, direction, attribute, comparator, xval, yval;

        for (i = 0; i < sortCriteria.length; i++) {
          direction = sortCriteria[i][DataCache._DIRECTION];
          attribute = sortCriteria[i][DataCache._ATTRIBUTE];
          comparator = null;
          xval = self._getVal(x, attribute);
          yval = self._getVal(y, attribute);
          var compareResult = 0;
          var strX = typeof xval === 'string' ? xval : new String(xval).toString();
          var strY = typeof yval === 'string' ? yval : new String(yval).toString();

          if (direction == 'ascending') {
            compareResult = strX.localeCompare(strY, undefined, {
              numeric: true,
              sensitivity: 'base'
            });
          } else {
            compareResult = strY.localeCompare(strX, undefined, {
              numeric: true,
              sensitivity: 'base'
            });
          }

          if (compareResult != 0) {
            return compareResult;
          }
        }

        return 0;
      };
    }
  }, {
    key: "_getVal",
    value: function _getVal(val, attr) {
      if (typeof attr == 'string') {
        var dotIndex = attr.indexOf('.');

        if (dotIndex > 0) {
          var startAttr = attr.substring(0, dotIndex);
          var endAttr = attr.substring(dotIndex + 1);
          var subObj = val[startAttr];

          if (subObj) {
            return this._getVal(subObj, endAttr);
          }
        }
      }

      if (typeof val[attr] == 'function') {
        return val[attr]();
      }

      return val[attr];
    }
  }]);

  return DataCache;
}();

DataCache._DATA = 'data';
DataCache._METADATA = 'metadata';
DataCache._ITEMS = 'items';
DataCache._BEFOREKEYS = 'addBeforeKeys';
DataCache._KEYS = 'keys';
DataCache._INDEXES = 'indexes';
DataCache._FROM = 'from';
DataCache._OFFSET = 'offset';
DataCache._REFRESH = 'refresh';
DataCache._MUTATE = 'mutate';
DataCache._SIZE = 'size';
DataCache._FETCHPARAMETERS = 'fetchParameters';
DataCache._SORTCRITERIA = 'sortCriteria';
DataCache._DIRECTION = 'direction';
DataCache._ATTRIBUTE = 'attribute';
DataCache._VALUE = 'value';
DataCache._DONE = 'done';
DataCache._RESULTS = 'results';
DataCache._CONTAINSPARAMETERS = 'containsParameters';
DataCache._DEFAULT_SIZE = 25;
DataCache._CONTAINSKEYS = 'containsKeys';
DataCache._FETCHBYKEYS = 'fetchByKeys';
DataCache._FETCHBYOFFSET = 'fetchByOffset';
DataCache._FETCHFIRST = 'fetchFirst';
DataCache._FETCHATTRIBUTES = 'attributes';
oj['DataCache'] = DataCache;









/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 *
 * @since 4.2.0
 * @export
 * @interface DataProviderAddOperationEventDetail
 * @extends DataProviderOperationEventDetail
 * @ojsignature {target: "Type",
 *               value: "interface DataProviderAddOperationEventDetail<K, D> extends DataProviderOperationEventDetail<K, D>",
 *               genericParameters: [{"name": "K", "description": "Type of Key"}, {"name": "D", "description": "Type of Data"}]}
 */

/**
 * Optional set of keys for items located after the items involved in the operation. They are relative to after the
 * operation was completed and not the original array. If null and index not specified then insert at the end.
 *
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderAddOperationEventDetail
 * @instance
 * @name afterKeys
 * @type {Set.<any>}
 * @ojdeprecated {since: '6.0.0', description: 'Use addBeforeKeys instead.  addBeforeKeys is an Array instead of a Set.'}
 * @ojsignature {target: "Type",
 *               value: "?Set<K>"}
 */

/**
 * Optional array of keys for items located after the items involved in the operation. They are relative to after the
 * operation was completed and not the original array.If null and index not specified then insert at the end.
 *
 *
 * @since 6.0.0
 * @export
 * @expose
 * @memberof DataProviderAddOperationEventDetail
 * @instance
 * @name addBeforeKeys
 * @type {Array.<any>}
 * @ojsignature {target: "Type",
 *               value: "?K[]"}
 */

/**
 * Keys of parents for the items involved in the operation.
 * <p>If this property is undefined, the items involved in the operation have no parent.
 * This is the case for non-hierarchical DataProvider implementatons such as ArrayDataProvider.</p>
 * <p>If this property has a value, each entry in the array represents the parent key of
 * the corresponding item.  A parent key of null indicates that the item is at the root level.
 * TreeDataProvider implementations should always set this property.</p>
 *
 *
 * @since 6.0.0
 * @export
 * @expose
 * @memberof DataProviderAddOperationEventDetail
 * @instance
 * @name parentKeys
 * @type {Array.<any>}
 * @ojsignature {target: "Type",
 *               value: "?K[]"}
 */

/**
 * End of jsdoc
 */

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var DataProviderMutationEvent = /*#__PURE__*/function (_GenericEvent) {
  _inherits(DataProviderMutationEvent, _GenericEvent);

  var _super = _createSuper(DataProviderMutationEvent);

  function DataProviderMutationEvent(detail) {
    _classCallCheck(this, DataProviderMutationEvent);

    var eventOptions = {};
    eventOptions[DataProviderMutationEvent._DETAIL] = detail;
    return _super.call(this, 'mutate', eventOptions);
  }

  return DataProviderMutationEvent;
}(GenericEvent);

DataProviderMutationEvent._DETAIL = 'detail';
oj.DataProviderMutationEvent = DataProviderMutationEvent;
oj['DataProviderMutationEvent'] = DataProviderMutationEvent;



/**
 * Interface oj.DataProviderMutationEventDetail
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @since 4.2.0
 * @export
 * @interface DataProviderMutationEventDetail
 * @ojsignature {target: "Type",
 *               value: "interface DataProviderMutationEventDetail<K, D>",
 *               genericParameters: [{"name": "K", "description": "Type of Key"}, {"name": "D", "description": "Type of Data"}]}
 * @classdesc This interface defines the payload of the {@link DataProviderMutationEvent} and specifies as one atomic event all the mutation operations which
 * occurred. The keys for each operation must be disjoint from each other, e.g. for example
 * an add and remove cannot occur on the same item. In addition, any indexes specified must
 * be monotonically increasing.
 */

/**
 * Optional add operation detail
 *
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEventDetail
 * @instance
 * @name add
 * @type {DataProviderAddOperationEventDetail}
 * @ojsignature {target: "Type",
 *               value: "?DataProviderAddOperationEventDetail<K, D>"}
 */

/**
 * Optional remove operation detail
 *
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEventDetail
 * @instance
 * @name remove
 * @type {DataProviderOperationEventDetail}
 * @ojsignature {target: "Type",
 *               value: "?DataProviderOperationEventDetail<K, D>"}
 */

/**
 * Optional update operation detail
 *
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEventDetail
 * @instance
 * @name update
 * @type {DataProviderOperationEventDetail}
 * @ojsignature {target: "Type",
 *               value: "?DataProviderOperationEventDetail<K, D>"}
 */

/**
 * End of jsdoc
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 *
 * @since 4.2.0
 * @export
 * @final
 * @class DataProviderMutationEvent
 * @implements Event
 * @classdesc Mutation event dispatched by {@link DataProvider}
 * @param {DataProviderMutationEventDetail} detail the event detail
 * @ojsignature [{target: "Type",
 *               value: "class DataProviderMutationEvent<K, D> implements Event",
 *               genericParameters: [{"name": "K", "description": "Type of Key"}, {"name": "D", "description": "Type of Data"}]},
 *               {target: "Type",
 *               value: "DataProviderMutationEventDetail<K, D>",
 *               for: "detail"}]
 */

/**
 * Event detail
 *
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name detail
 * @type {DataProviderMutationEventDetail}
 * @ojsignature {target: "Type",
 *               value: "DataProviderMutationEventDetail<K, D>"}
 */

/**
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name type
 * @type {string}
 */

/**
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name bubbles
 * @type {boolean}
 */

/**
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name cancelable
 * @type {boolean}
 */

/**
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name cancelBubble
 * @type {boolean}
 */

/**
 *
 * @since 6.0.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name composed
 * @type {boolean}
 */

/**
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name currentTarget
 * @type {EventTarget}
 */

/**
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name defaultPrevented
 * @type {boolean}
 */

/**
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name eventPhase
 * @type {number}
 */

/**
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name isTrusted
 * @type {boolean}
 */

/**
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name returnValue
 * @type {boolean}
 */

/**
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name srcElement
 * @type {Element | null}
 */

/**
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name target
 * @type {EventTarget}
 */

/**
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name timeStamp
 * @type {number}
 */

/**
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name scoped
 * @type {boolean}
 */

/**
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name initEvent
 * @ojsignature {target: "Type",
 *               value: "(eventTypeArg: string, canBubbleArg: boolean, cancelableArg: boolean) => void"}
 */

/**
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name preventDefault
 * @ojsignature {target: "Type",
 *               value: "() => void"}
 */

/**
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name stopImmediatePropagation
 * @ojsignature {target: "Type",
 *               value: "() => void"}
 */

/**
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name stopPropagation
 * @ojsignature {target: "Type",
 *               value: "() => void"}
 */

/**
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name deepPath
 * @ojsignature {target: "Type",
 *               value: "() => EventTarget[]"}
 */

/**
 *
 * @since 9.0.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name composedPath
 * @ojsignature {target: "Type",
 *               value: "() => EventTarget[]"}
 */

/**
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name AT_TARGET
 * @type {number}
 */

/**
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name BUBBLING_PHASE
 * @type {number}
 */

/**
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name CAPTURING_PHASE
 * @type {number}
 */

/**
 *
 * @since 6.0.0
 * @export
 * @expose
 * @memberof DataProviderMutationEvent
 * @instance
 * @name NONE
 * @type {number}
 */

/**
 * End of jsdoc
 */





/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 *
 * @since 4.2.0
 * @export
 * @interface DataProviderOperationEventDetail
 * @ojsignature {target: "Type",
 *               value: "interface DataProviderOperationEventDetail<K, D>",
 *               genericParameters: [{"name": "K", "description": "Type of Key"}, {"name": "D", "description": "Type of Data"}]}
 * @classdesc Defines the details for a particular operation in an {@link DataProviderMutationEventDetail}
 */

/**
 * keys of items involved in the operation
 *
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderOperationEventDetail
 * @instance
 * @name keys
 * @type {Set.<any>}
 * @ojsignature {target: "Type",
 *               value: "Set<K>"}
 */

/**
 * Optional metadata of items involved in the operation
 *
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderOperationEventDetail
 * @instance
 * @name metadata
 * @type {Array.<ItemMetadata>}
 * @ojsignature {target: "Type",
 *               value: "?Array<ItemMetadata<K>>"}
 */

/**
 * Optional data of items involved in the operation
 *
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderOperationEventDetail
 * @instance
 * @name data
 * @type {Array.<Object>}
 * @ojsignature {target: "Type",
 *               value: "?D[]"}
 */

/**
 * Optional indexes of items involved in the operation. Indices are with respect to the DataProvider
 * with only its implicit sort applied. Essentially, indices are the global indices (except for TreeDataProvider, please see
 * the note below), not the indices with respect to whatever query (which might have its own sorting or filtering)
 * fetched the items.
 *
 * <p>For 'add' operation the indexes are relative to after the
 * operation was completed and not the original dataset.</p>
 *
 * <p>For 'update' operation the indexes are relative to after the
 * operation was completed and not the original dataset.</p>
 *
 * <p>For 'remove' operation the indexes are relative to the original dataset.</p>
 *
 * <p>Note: With respect to TreeDataProvider, the index is the index at the level where the mutation occurs.
 * That is, the index of the node among its siblings.</p>
 * <p> Optimization can be achieved by specifying indexes for mutation events. </p>
 * @since 4.2.0
 * @export
 * @expose
 * @memberof DataProviderOperationEventDetail
 * @instance
 * @name indexes
 * @type {Array.<number>}
 * @ojsignature {target: "Type",
 *               value: "?number[]"}
 * @ojtsexample <caption>Example to illustrate indexes from array mutations</caption>
 * let data = [{ id: 1, name: 'Amy Bartlet', title: 'Vice President' },
 *             { id: 2, name: 'Annett Barnes', title: 'Individual  Contributer' },
 *             { id: 3, name: 'Bobby Fisher', title: 'Individual Contributer' }];
 * let observableArray = ko.observableArray(data);
 * let dataProvider = new ArrayDataProvider(ko.observableArray(data), { keyAttributes: 'id' });
 *
 * let listener = function(event) {
 *  // Print DataProviderEventDetail
 * };
 *
 * dataProvider.addEventListener("mutate", listener);
 *
 * observableArray.push({ id: 4, name: âJohn schully', title: âManager' });
 * // Then the DataProviderOperationEventDetail will have Indexes as [3]
 *
 * observableArray.splice(2, 1, { id: 5, name: âScott Jhonson', title: âPresident' });
 * // Then the DataProviderOperationEventDetail will have Indexes as [2]
 * @ojtsexample <caption>Example to illustrate indexes with respect to ArrayTreeDataProvider</caption>
 *
 * let dataArray = [{
 *                    title: "Amy Bartlet",
 *                    id: "100"
 *                  },
 *                  {
 *                    title: "Scott Fisher",
 *                    id: "101",
 *                    children: [{
 *                                 title: "John Fisher",
 *                                 id: "102"
 *                               },
 *                               {
 *                                 title: "Bobby Fisher",
 *                                 id: "103"
 *                               }]
 *                  },
 *                  {
 *                    title: "Annett Barnes",
 *                    id: "104"
 *                  }];
 *
 * createObservableArrayTree(data: Array<any>) {
 *   let array = <any[]>[];
 *   let observableArray = ko.observableArray(array);
 *   for (let i = 0; i < data.length; i++) {
 *     let newItem = data[i];
 *     if (data[i].children) {
 *       newItem.children = this.createObservableArrayTree(data[i].children);
 *     }
 *     observableArray.push(newItem);
 *   }
 *   return observableArray;
 * }
 *
 * let observableArrayTree = createObservableArrayTree(dataArray);
 * let dataProvider = new ArrayTreeDataProvider(observableArrayTree, { keyAttributes: 'id' });
 * dataProvider.addEventListener('mutate', ((event: CustomEvent<any>) => {
 *   console.log(event.detail);
 * }) as EventListener);
 * let index = 1;
 *
 * observableArrayTree()[1].children.splice(index, 1);
 *
 * // Output will be // { 'add': null, 'remove' : { 'indexes': [1] }, 'update': null}
 * // Here the index 1 refers to the object with id '103'.
 */

/**
 * End of jsdoc
 */

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var DataProviderRefreshEvent = /*#__PURE__*/function (_GenericEvent) {
  _inherits(DataProviderRefreshEvent, _GenericEvent);

  var _super = _createSuper(DataProviderRefreshEvent);

  function DataProviderRefreshEvent() {
    _classCallCheck(this, DataProviderRefreshEvent);

    return _super.call(this, 'refresh');
  }

  return DataProviderRefreshEvent;
}(GenericEvent);

oj.DataProviderRefreshEvent = DataProviderRefreshEvent;
oj['DataProviderRefreshEvent'] = DataProviderRefreshEvent;



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @since 4.1.0
 * @export
 * @final
 * @class DataProviderRefreshEvent
 * @implements Event
 * @classdesc Refresh Event dispatched by the {@link DataProvider}. This event is fired when
 * the data has been refreshed and components need to re-fetch the data.
 * @ojsignature {target: "Type",
 *               value: "class DataProviderRefreshEvent implements Event"}
 */

/**
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name type
 * @type {string}
 */

/**
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name bubbles
 * @type {boolean}
 */

/**
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name cancelable
 * @type {boolean}
 */

/**
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name cancelBubble
 * @type {boolean}
 */

/**
 *
 * @since 6.0.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name composed
 * @type {boolean}
 */

/**
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name currentTarget
 * @type {EventTarget}
 */

/**
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name defaultPrevented
 * @type {boolean}
 */

/**
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name eventPhase
 * @type {number}
 */

/**
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name isTrusted
 * @type {boolean}
 */

/**
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name returnValue
 * @type {boolean}
 */

/**
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name srcElement
 * @type {Element | null}
 */

/**
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name target
 * @type {EventTarget}
 */

/**
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name timeStamp
 * @type {number}
 */

/**
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name scoped
 * @type {boolean}
 */

/**
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name initEvent
 * @ojsignature {target: "Type",
 *               value: "(eventTypeArg: string, canBubbleArg: boolean, cancelableArg: boolean) => void"}
 */

/**
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name preventDefault
 * @ojsignature {target: "Type",
 *               value: "() => void"}
 */

/**
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name stopImmediatePropagation
 * @ojsignature {target: "Type",
 *               value: "() => void"}
 */

/**
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name stopPropagation
 * @ojsignature {target: "Type",
 *               value: "() => void"}
 */

/**
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name deepPath
 * @ojsignature {target: "Type",
 *               value: "() => EventTarget[]"}
 */

/**
 *
 * @since 9.0.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name composedPath
 * @ojsignature {target: "Type",
 *               value: "() => EventTarget[]"}
 */

/**
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name AT_TARGET
 * @type {number}
 */

/**
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name BUBBLING_PHASE
 * @type {number}
 */

/**
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name CAPTURING_PHASE
 * @type {number}
 */

/**
 *
 * @since 6.0.0
 * @export
 * @expose
 * @memberof DataProviderRefreshEvent
 * @instance
 * @name NONE
 * @type {number}
 */

/**
 * End of jsdoc
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 *
 * @since 4.2.0
 * @export
 * @interface DataProvider
 * @extends EventTarget
 * @ojsignature {target: "Type",
 *               value: "interface DataProvider<K, D> extends EventTarget",
 *               genericParameters: [{"name": "K", "description": "Type of Key"}, {"name": "D", "description": "Type of Data"}]}
 * @classdesc
 * The DataProvider interface defines the contract by which JET components retrieve data.  By exposing this contract as an interface, we allow for a range of possible data retrieval strategies, while shielding components from dependencies on any one particular implementation choice.  For example, some DataProvider implementations may get data from a local array. Others may retrieve data from a remote endpoint.  In either case, the consuming component simply interacts with the DataProvider interface and is unaware of the of the specific data retrieval approach.
 * <p>
 * The DataProvider contract has the following characteristics:
 * <ul>
 *   <li>Asynchronous: Even in cases where data is available synchronously (eg. the data is already in a local array), the DataProvider contract provides access to the data via asynchronous APIs.  As such, consumers are able to interact with the data in a consistent manner, regardless of how the data is retrieved.</li>
 *   <li>Stateless: The DataProviderâs data retrieval APIs are inherently stateless.  Attempts to retrieve data are atomic and are not impacted by previous interactions with the DataProvider.  This avoids potential brittleness when multiple consumers are interacting with the same DataProvider instance.</li>
 *   <li>Key-based: In order to ensure reliable interactions with the data set, the DataProvider contract assumes that each data item can be accessed via a unique key.  While the index can be used as a key if no viable key is available, stable keys should be used whenever possible.</li>
 *   <li>Read only (with mutation notifications):  The base DataProvider contract does not include mutation APIs.  That is, the DataProvider contract defines APIs for reading data, not for writing data.  However, DataProvider implementations may expose their own type-specific mutation APIs, and the DataProvider contract defines an event-based mechanism for notifying consumers of data changes.</li>
 *   <li>Filterable:  When requesting data from a DataProvider, consumers are able to specify filter criteria that area used to restrict the data set to those items that match the specified criteria.</li>
 *   <li>Sortable:  When requesting data from a DataProvider, consumers are able to specify sort criteria that impact the ordering of the provided data.</li>
 * </ul>
 * <p>
 * The DataProvider contract exposes three ways for consumers to retrieve data:
 * <ul>
 *   <li>Iteration: the {@link DataProvider#fetchFirst} method returns an AsyncIterable that can be used to iterate over the entire data set.  Consumers typically use this when rendering a data set.</li>
 *   <li>By keys: the {@link DataProvider#fetchByKeys} method allows specific items to be retrieved by key.  Consumers typically use this when interacting with a subset of data (eg. for retrieving the values of the selected rows in a table component).</li>
 *   <li>By offset: the {@link DataProvider#fetchByOffset} method allows a specific block of data to be retrieved by specifying an offset and size. Consumers typically use this for paging purposes.</li>
 * </ul>
 * A related interface is {@link TreeDataProvider}, which extends DataProvider. TreeDataProviders represent hierarchical data, whereas (non-tree) DataProviders represent data sets that are single-level.
 * <p>
 * JET provides several out-of-the-box DataProvider implementations that support the most common use cases.
 * <br>
 * <h4 id="description:DataProviderImplementations" class="name">
 *   Implementations
 * </h4>
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Class</th>
 *       <th>Description</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td>
 *         {@link ArrayDataProvider}
 *       </td>
 *       <td>
 *         Basic DataProvider implementation that takes the data from an Javascript array or ko.observableArray.
 *       </td>
 *     </tr>
 *     <tr>
 *       <td>
 *         {@link ArrayTreeDataProvider}
 *       </td>
 *       <td>
 *         Basic TreeDataProvider implementation that takes the data from an Javascript array or ko.observableArray that contains "children" property for subtree data.
 *       </td>
 *     </tr>
 *     <tr>
 *       <td>
 *         {@link CollectionDataProvider}
 *       </td>
 *       <td>
 *         DataProvider implementation that takes the data from a {@link oj.Collection} object. {@link oj.Collection} is an older class that represents data usually comes from external source such as a REST.
 *       </td>
 *     </tr>
 *     <tr>
 *       <td>
 *         {@link DeferredDataProvider}
 *       </td>
 *       <td>
 *         DataProvider implementation that takes the data from a promise that resolves to another DataProvider object.
 *       </td>
 *     </tr>
 *     <tr>
 *       <td>
 *         {@link FlattenedTreeDataProviderView}
 *       </td>
 *       <td>
 *         DataProvider implementation that wraps a TreeDataProvider object and "flattens" the hierarchical data into a single level.
 *       </td>
 *     </tr>
 *     <tr>
 *       <td>
 *         {@link IndexerModelTreeDataProvider}
 *       </td>
 *       <td>
 *         TreeDataProvider implementation that takes the data from an Javascript array that contains "children" property for subtree data. This class also implements the {@link oj.IndexerModel} interface.
 *       </td>
 *     </tr>
 *     <tr>
 *       <td>
 *         {@link ListDataProviderView}
 *       </td>
 *       <td>
 *         DataProvider implementation that wraps another DataProvider, adding data manipulation functionality such as filtering, sorting and field mapping.
 *       </td>
 *     </tr>
 *     <tr>
 *       <td>
 *         {@link PagingDataProviderView}
 *       </td>
 *       <td>
 *         DataProvider implementation that wraps another DataProvider object. This class also implements the {@link oj.PagingModel} interface so that it can be used by components that support paging.
 *       </td>
 *     </tr>
 *     <tr>
 *       <td>
 *         {@link TreeDataProviderView}
 *       </td>
 *       <td>
 *         TreeDataProvider implementation that wraps another TreeDataProvider object and exposes additional APIs. This class provides field mapping functionality for the wrapped TreeDataProvider.
 *       </td>
 *     </tr>
 *   </tbody>
 * </table>
 * <h4 id="description:DataProviderClassHierarchy" class="name">
 *   Class Hierarchy
 * </h4>
 * <ul>
 *   <li><b>Interface {@link DataProvider}</b></li>
 *   <ul>
 *     <li>{@link ArrayDataProvider}</li>
 *     <li>{@link CollectionDataProvider}</li>
 *     <li>{@link DeferredDataProvider}</li>
 *     <li>{@link FlattenedTreeDataProviderView}</li>
 *     <li>{@link ListDataProviderView}</li>
 *     <li>{@link PagingDataProviderView}</li>
 *     <li><b>Interface {@link TreeDataProvider}</b></li>
 *       <ul>
 *         <li>{@link ArrayTreeDataProvider}</li>
 *         <li>{@link IndexerModelTreeDataProvider}</li>
 *         <li>{@link TreeDataProviderView}</li>
 *       </ul>
 *     </li>
 *   </ul>
 * </ul>
 * </p><p>
 *
 * <h3 id="events-section">
 *   Events
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#events-section"></a>
 * </h3>
 * Implementations can fire the following events by creating an instance of the event class and passing the event payload in the constructor.
 * <h4 id="event:DataProviderMutationEvent" class="name">
 *   {@link DataProviderMutationEvent}
 * </h4>
 * This event is fired when items have been added or removed from the data.
 * <p>
 * Event payloads should implement the {@link DataProviderMutationEventDetail} interface.
 * </p><p>
 * Consumers can add an event listener for the "mutate" event type on the DataProvider object.
 * </p>
 * <i>Example of implementation firing an DataProviderMutationEvent for removed items:</i>
 * <pre class="prettyprint"><code>let removeDetail = {data: removedDataArray,
 *                     indexes: removedIndexArray,
 *                     keys: removedKeySet,
 *                     metadata: removedMetadataArray};
 * this.dispatchEvent(new DataProviderMutationEvent({remove: removeDetail}));
 * </code></pre>
 *
 * <i>Example of consumer listening for the "mutate" event type:</i>
 * <pre class="prettyprint"><code>let listener = function(event) {
 *   if (event.detail.remove) {
 *     let removeDetail = event.detail.remove;
 *     // Handle removed items
 *   }
 * };
 * dataProvider.addEventListener("mutate", listener);
 * </code></pre>
 * <h4 id="event:DataProviderRefreshEvent" class="name">
 *   {@link DataProviderRefreshEvent}
 * </h4>
 * This event is fired when the data has been refreshed and components need to re-fetch the data.
 * <p>
 * This event contains no additional event payload.
 * </p><p>
 * Consumers can add an event listener for the "refresh" event type on the DataProvider object.
 * </p>
 * <i>Example of consumer listening for the "refresh" event type:</i>
 * <pre class="prettyprint"><code>let listener = function(event) {
 * };
 * dataProvider.addEventListener("refresh", listener);
 * </code></pre>
 * <h3 id="custom-implementations-section">
 *   Custom Implementations
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#custom-implementations-section"></a>
 * </h3>
 * Applications can also create their own implementations of the DataProvider interface and use them with JET components.  For example, an application can create a DataProvider implementation
 * that fetches data from a REST endpoint.
 * </p><p>
 * Implementation classes must implement all of the interface methods.  It should also fire the DataProvider events when appropriate, so that JET components or other consumers can respond to data change accordingly.
 * </p>
 * <p>
 * A generic implementation of {@link DataProvider#fetchByKeys} and {@link DataProvider#containsKeys} is available from {@link FetchByKeysMixin}
 * which can be used in custom implementations of DataProvider.
 * It is for convenience and may not provide the most efficient implementation for your data provider.
 * Classes that implement the DataProvider interface are encouraged to provide a more efficient implementation.
 * </p>
 */
oj.DataProvider = function () {};
/**
 * Get an asyncIterator which can be used to fetch a block of data.
 *
 *
 * @since 4.2.0
 * @param {FetchListParameters=} params fetch parameters
 * @return {AsyncIterable.<FetchListResult>} AsyncIterable with {@link FetchListResult}
 * @see {@link https://github.com/tc39/proposal-async-iteration} for further information on AsyncIterable.
 * @export
 * @expose
 * @memberof DataProvider
 * @instance
 * @method
 * @name fetchFirst
 * @ojsignature {target: "Type",
 *               value: "(parameters?: FetchListParameters<D>): AsyncIterable<FetchListResult<K, D>>"}
 * @ojtsexample <caption>Get an asyncIterator and then fetch first block of data by executing next() on the iterator. Subsequent blocks can be fetched by executing next() again.</caption>
 * let asyncIterator = dataprovider.fetchFirst(options)[Symbol.asyncIterator]();
 * let result = await asyncIterator.next();
 * let value = result.value;
 * let data = value.data;
 * let keys = value.metadata.map(function(val) {
 *   return val.key;
 * });
 * // true or false for done
 * let done = result.done;
 */

/**
 * Determines whether this DataProvider defines a certain feature.
 *
 *
 * @since 4.2.0
 * @param {string} capabilityName capability name. Defined capability names are:
 *                  "fetchByKeys", "fetchByOffset", "sort", "fetchCapability" and "filter".
 * @return {Object} capability information or null if undefined
 * <ul>
 *   <li>If capabilityName is "fetchByKeys", returns a {@link FetchByKeysCapability} object.</li>
 *   <li>If capabilityName is "fetchByOffset", returns a {@link FetchByOffsetCapability} object.</li>
 *   <li>If capabilityName is "sort", returns a {@link SortCapability} object.</li>
 *   <li>If capabilityName is "filter", returns a {@link FilterCapability} object.</li>
 *   <li>If capabilityName is "fetchCapability", returns a {@link FetchCapability} object.</li>
 * </ul>
 * @export
 * @expose
 * @memberof DataProvider
 * @instance
 * @method
 * @name getCapability
 * @ojsignature {target: "Type",
 *               value: "(capabilityName: string): any"}
 * @ojtsexample <caption>Check what kind of fetchByKeys is defined.</caption>
 * let capabilityInfo = dataprovider.getCapability('fetchByKeys');
 * if (capabilityInfo.implementation == 'iteration') {
 *   // the DataProvider supports iteration for fetchByKeys
 *   ...
 */

/**
 * Return the total number of rows in this dataprovider
 *
 *
 * @return {Promise.<number>} Returns a Promise which resolves to the total number of rows. -1 is unknown row count.
 * @export
 * @expose
 * @memberof DataProvider
 * @instance
 * @method
 * @name getTotalSize
 * @ojtsexample <caption>Get the total rows</caption>
 * let value = await dataprovider.getTotalSize();
 * if (value == -1) {
 *   // we don't know the total row count
 * } else {
 *   // the total count
 *   console.log(value);
 */

/**
 * Fetch rows by keys. The resulting key map will only contain keys which were actually found.
 *
 *
 * @since 4.2.0
 * @param {FetchByKeysParameters} parameters fetch by key parameters
 * @return {Promise.<FetchByKeysResults>} Returns Promise which resolves to {@link FetchByKeysResults}.
 * @export
 * @expose
 * @memberof DataProvider
 * @instance
 * @method
 * @name fetchByKeys
 * @ojsignature {target: "Type",
 *               value: "(parameters : FetchByKeysParameters<K>) : Promise<FetchByKeysResults<K, D>>"}
 * @ojtsexample <caption>Fetch for keys 1001 and 556</caption>
 * let fetchKeys = [1001, 556];
 * let value = await dataprovider.fetchByKeys({keys: fetchKeys});
 * // get the data for key 1001
 * console.log(value.results.get(1001).data);
 */

/**
 * Check if there are rows containing the specified keys. The resulting key map will only contain keys which were actually found.
 *
 *
 * @since 4.2.0
 * @param {FetchByKeysParameters} parameters contains by key parameters
 * @return {Promise.<ContainsKeysResults>} Returns Promise which resolves to {@link ContainsKeysResults}.
 * @export
 * @expose
 * @memberof DataProvider
 * @instance
 * @method
 * @name containsKeys
 * @ojsignature {target: "Type",
 *               value: "(parameters : FetchByKeysParameters<K>) : Promise<ContainsKeysResults<K>>"}
 * @ojtsexample <caption>Check if keys 1001 and 556 are contained</caption>
 * let containsKeys = [1001, 556];
 * let value = await dataprovider.containsKeys({keys: containsKeys});
 * let results = value['results'];
 * if (results.has(1001)) {
 *   console.log('Has key 1001');
 * } else if (results.has(556){
 *   console.log('Has key 556');
 * }
 */

/**
 * Fetch rows by offset
 * <p>
 * A generic implementation of this method is available from {@link FetchByOffsetMixin}.
 * It is for convenience and may not provide the most efficient implementation for your data provider.
 * Classes that implement the DataProvider interface are encouraged to provide a more efficient implementation.
 * </p>
 *
 *
 * @since 4.2.0
 * @param {FetchByOffsetParameters} parameters fetch by offset parameters
 * @return {Promise.<FetchByOffsetResults>} Returns Promise which resolves to {@link FetchByOffsetResults}.
 * @export
 * @expose
 * @memberof DataProvider
 * @instance
 * @method
 * @name fetchByOffset
 * @ojsignature {target: "Type",
 *               value: "(parameters: FetchByOffsetParameters<D>): Promise<FetchByOffsetResults<K, D>>"}
 * @ojtsexample <caption>Fetch by offset 5 rows starting at index 2</caption>
 * let result = await dataprovider.fetchByOffset({size: 5, offset: 2});
 * let results = result['results'];
 * let data = results.map(function(value) {
 *   return value['data'];
 * });
 * let keys = results.map(function(value) {
 *   return value['metadata']['key'];
 * });
 */

/**
 * Returns a string that indicates if this data provider is empty.  Valid values are:
 * <ul>
 * <li>"yes": this data provider is empty.</li>
 * <li>"no": this data provider is not empty.</li>
 * <li>"unknown": it is not known if this data provider is empty until a fetch is made.</li>
 * </ul>
 *
 *
 * @since 4.2.0
 * @return {"yes" | "no" | "unknown"} string that indicates if this data provider is empty
 * @export
 * @expose
 * @memberof DataProvider
 * @instance
 * @method
 * @name isEmpty
 * @ojsignature {target: "Type",
 *               value: "(): 'yes' | 'no' | 'unknown'"}
 * @ojtsexample <caption>Check if empty</caption>
 * let isEmpty = dataprovider.isEmpty();
 * console.log('DataProvider is empty: ' + isEmpty);
 */

/**
 * Return an empty Set which is optimized to store keys
 * <p>
 * Optionally provided by certain DataProvider implementations for storing
 * keys from the DataProvider in a performant fashion. Sometimes components will
 * need to temporarily store a Set of keys provided by the DataProvider, for
 * example, in the case of maintaining a Set of selected keys. Only the DataProvider
 * is aware of the internal structure of keys such as whether they are primitives, Strings,
 * or objects and how to do identity comparisons. Therefore, the DataProvider can optionally
 * provide a Set implementation which can performantly store keys surfaced by the
 * DataProvider.
 * </p>
 *
 *
 * @since 6.2.0
 * @param {Set.<any>=} initialSet Optionally specify an initial set of keys for the Set. If not specified, then return an empty Set.
 * @return {Set.<any>} Returns a Set optimized for handling keys from the DataProvider.
 * @export
 * @expose
 * @memberof DataProvider
 * @instance
 * @method
 * @name createOptimizedKeySet
 * @ojsignature {target: "Type",
 *               value: "?(initialSet?: Set<K>): Set<K>"}
 * @ojtsexample <caption>create empty key Set</caption>
 * let keySet = dataprovider.createOptimizedKeySet();
 */

/**
 * Return an empty Map which is optimized to store key value pairs
 * <p>
 * Optionally provided by certain DataProvider implementations for storing
 * key/value pairs from the DataProvider in a performant fashion. Sometimes components will
 * need to temporarily store a Map of keys provided by the DataProvider, for
 * example, in the case of maintaining a Map of selected keys. Only the DataProvider
 * is aware of the internal structure of keys such as whether they are primitives, Strings,
 * or objects and how to do identity comparisons. Therefore, the DataProvider can optionally
 * provide a Map implementation which can performantly store key/value pairs surfaced by the
 * DataProvider.
 * </p>
 *
 *
 * @since 6.2.0
 * @param {Map.<any>=} initialMap Optionally specify an initial map of key/values for the Map. If not specified, then return an empty Map.
 * @return {Map.<any>} Returns a Map optimized for handling keys from the DataProvider.
 * @export
 * @expose
 * @memberof DataProvider
 * @instance
 * @method
 * @name createOptimizedKeyMap
 * @ojsignature {target: "Type",
 *               value: "?(initialMap?: Map<K, D>): Map<K, D>"}
 * @ojtsexample <caption>create empty key Map</caption>
 * let keyMap = dataprovider.createOptimizedKeyMap();
 */

/**
 * Add a callback function to listen for a specific event type.
 *
 *
 * @export
 * @expose
 * @memberof DataProvider
 * @instance
 * @method
 * @name addEventListener
 * @param {string} eventType The event type to listen for.
 * @param {EventListener} listener The callback function that receives the event notification.
 * @ojsignature {target: "Type",
 *               value: "(eventType: string, listener: EventListener): void"}
 */

/**
 * Remove a listener previously registered with addEventListener.
 *
 *
 * @export
 * @expose
 * @memberof DataProvider
 * @instance
 * @method
 * @name removeEventListener
 * @param {string} eventType The event type that the listener was registered for.
 * @param {EventListener} listener The callback function that was registered.
 * @ojsignature {target: "Type",
 *               value: "(eventType: string, listener: EventListener): void"}
 */

/**
 * Dispatch an event and invoke any registered listeners.
 *
 *
 * @export
 * @expose
 * @memberof DataProvider
 * @instance
 * @method
 * @name dispatchEvent
 * @param {Event} event The event object to dispatch.
 * @return {boolean} Return false if a registered listener has cancelled the event. Return true otherwise.
 * @ojsignature {target: "Type",
 *               value: "(evt: Event): boolean"}
 */

/**
 * End of jsdoc
 */





/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @export
 * @interface DedupCapability
 * @since 9.1.0
 * @ojsignature {target: "Type",
 *               value: "interface DedupCapability"}
 * @classdesc Defines the result from the DataProvider method {@link DataProvider#getCapability} for capability "dedup"
 */

/**
 * Dedup type information. Type of 'global' indicates that this DataProvider globally dedups keys and will always return unique keys. Type of
 * 'iterator' indicates that this DataProvider dedups keys during fetch iteration. Type of 'none' indicates that this DataProvider does not
 * dedup keys and may return duplicate keys.
 *
 *
 * @since 9.1.0
 * @export
 * @expose
 * @memberof DedupCapability
 * @instance
 * @name type
 * @type {string}
 * @ojsignature {target: "Type",
 *               value: "'global' | 'none' | 'iterator'"}
 */

/**
 * End of jsdoc
 */





/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @export
 * @interface EventFilteringCapability
 * @since 9.1.0
 * @ojsignature {target: "Type",
 *               value: "interface EventFilteringCapability"}
 * @classdesc Defines the result from the DataProvider method {@link DataProvider#getCapability} for capability "eventFiltering"
 */

/**
 * Mutation event filtering type information for scrolling. Note that mutation event filtering is
 * only done on remove and update events, not on add events. The reason is because the properties which
 * indicate the location of an added row are optional so it is not possible to guarantee that an add is
 * not occurring inside the already iterated rowset.
 * Type of 'global' indicates that this DataProvider globally filters mutation events. Type of
 * 'iterator' indicates that this DataProvider filters events based on rows which have been fetched via
 * fetch iteration. Type of 'none' indicates that this DataProvider does not filter mutation events.
 *
 *
 * @since 9.1.0
 * @export
 * @expose
 * @memberof EventFilteringCapability
 * @instance
 * @name type
 * @type {string}
 * @ojsignature {target: "Type",
 *               value: "'global' | 'none' | 'iterator'"}
 */

/**
 * End of jsdoc
 */





/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @since 6.1.0
 * @export
 * @interface FetchAttribute
 * @ojsignature {target: "Type",
 *               value: "interface FetchAttribute"}
 * @classdesc Defines the stucture of attribute objects in {@link FetchListParameters#attributes}
 */

/**
 * The name of the attribute or sub object or related object.
 *
 *
 * @since 6.1.0
 * @export
 * @expose
 * @memberof FetchAttribute
 * @instance
 * @name name
 * @type string
 * @ojsignature {target: "Type",
 *               value: "string"}
 */

/**
 * Optional attributes property which specifies at least which attributes of the value we want to include. If not specified then the default attributes are included. If the value
 * is a primitive then this is ignored. Expressions like "!" and "@default" are also supported. @default indicates the default attributes the implementation chooses to include in the result, by default.
 * e.g. ['!lastName', '@default'] for everything except 'lastName'. For only
 * 'firstName' and 'lastName' we'd have ['firstName', 'lastName']. Order does not matter when @default is used with field exclusions "!".
 * This can be nested. e.g. ['!lastName', '@default', {name: 'location', attributes: ['address line 1', 'address line 2']}].
 * When specified attributes, exclusions and @default are all present as in  [âidâ, âfirstNameâ, â!lastNameâ, â@defaultâ, âemailâ], this means that
 * all default attributes (including 'id', 'firstName', and 'email') except for 'lastName' will be included.
 * Also, a string value for attribute is equivalent to an object value with only name. e.g.  ['lastName', 'firstName'] is the same as [{name: 'lastName'}, {name: 'firstName'}]
 *
 *
 * @since 6.1.0
 * @export
 * @expose
 * @memberof FetchAttribute
 * @instance
 * @name attributes
 * @type {Array.<string | FetchAttribute>}
 * @ojsignature {target: "Type",
 *               value: "?Array<string | FetchAttribute>"}
 */

/**
 * end of jsdoc
 */







/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @export
 * @interface FetchByKeysCapability
 * @since 4.2.0
 * @ojsignature {target: "Type",
 *               value: "interface FetchByKeysCapability<D>",
 *               genericParameters: [{"name": "D", "description": "Type of Data"}]}
 * @classdesc Defines the result to the DataProvider method {@link DataProvider#getCapability} for capability "fetchByKeys"
 */

/**
 * The type of implementation for fetchByKeys and containsKeys methods.  Possible values are:
 * <ul>
 * <li>"iteration": the implementation uses fetchFirst iteratively to find the result</li>
 * <li>"lookup": the implementation uses direct lookup to find the result</li>
 * </ul>
 *
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof FetchByKeysCapability
 * @instance
 * @name implementation
 * @type {"iteration" | "lookup"}
 */

/**
 * End of jsdoc
 */

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var FetchByKeysMixin = /*#__PURE__*/function () {
  function FetchByKeysMixin() {
    _classCallCheck(this, FetchByKeysMixin);
  }

  _createClass(FetchByKeysMixin, [{
    key: "fetchByKeys",

    /**
     * Fetch rows by keys
     */
    value: function fetchByKeys(params) {
      var fetched = 0;
      var limit = this['getIterationLimit'] ? this['getIterationLimit']() : -1;
      var options = {};
      options['size'] = 25;
      var resultMap = new Map();
      var dataProviderAsyncIterator = this['fetchFirst'](options)[Symbol.asyncIterator]();

      function _fetchNextSet(params, dataProviderAsyncIterator, resultMap) {
        return dataProviderAsyncIterator.next().then(function (result) {
          var value = result['value'];
          var data = value['data'];
          var metadata = value['metadata'];
          var keys = metadata.map(function (metadata) {
            return metadata['key'];
          });
          var foundAllKeys = true;
          params['keys'].forEach(function (findKey) {
            if (!resultMap.has(findKey)) {
              keys.map(function (key, index) {
                if (key == findKey) {
                  resultMap.set(key, {
                    metadata: metadata[index],
                    data: data[index]
                  });
                }
              });
            }

            if (!resultMap.has(findKey)) {
              foundAllKeys = false;
            }
          }); // Keep track of how many rows we have fetched

          fetched += data.length; // Keep iterating if we haven't found all keys and there are more data

          if (!foundAllKeys && !result['done']) {
            if (limit != -1 && fetched >= limit) {
              // If we have reached the limit, just return the results
              return resultMap;
            } else {
              return _fetchNextSet(params, dataProviderAsyncIterator, resultMap);
            }
          } else {
            return resultMap;
          }
        });
      }

      return _fetchNextSet(params, dataProviderAsyncIterator, resultMap).then(function (resultMap) {
        var mappedResultMap = new Map();
        resultMap.forEach(function (value, key) {
          var mappedItem = [value];
          mappedResultMap.set(key, mappedItem[0]);
        });
        return {
          fetchParameters: params,
          results: mappedResultMap
        };
      });
    }
    /**
     * Check if rows are contained by keys
     */

  }, {
    key: "containsKeys",
    value: function containsKeys(params) {
      return this.fetchByKeys(params).then(function (fetchByKeysResult) {
        var results = new Set();
        params['keys'].forEach(function (key) {
          if (fetchByKeysResult['results'].get(key) != null) {
            results.add(key);
          }
        });
        return Promise.resolve({
          containsParameters: params,
          results: results
        });
      });
    }
  }, {
    key: "getCapability",
    value: function getCapability(capabilityName) {
      if (capabilityName == 'fetchByKeys') {
        return {
          implementation: 'iteration'
        };
      }

      var cap = null;

      if (this['_ojSkipLastCapability'] !== true) {
        this['_ojSkipLastCapability'] = true; // Find the index for the very last _ojLastGetCapability

        var index = 1;

        while (this['_ojLastGetCapability' + index]) {
          ++index;
        } // Iterate through the _ojLastGetCapability(n) in reverse order


        for (--index; index > 0; index--) {
          cap = this['_ojLastGetCapability' + index](capabilityName);

          if (cap) {
            break;
          }
        }

        delete this['_ojSkipLastCapability'];
      }

      return cap;
    }
  }], [{
    key: "applyMixin",
    value: function applyMixin(derivedCtor) {
      // Save the current getCapability
      var _lastGetCapability = derivedCtor.prototype['getCapability'];
      var baseCtors = [FetchByKeysMixin];
      baseCtors.forEach(function (baseCtor) {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach(function (name) {
          if (name !== 'constructor') {
            derivedCtor.prototype[name] = baseCtor.prototype[name];
          }
        });
      });

      if (_lastGetCapability) {
        var index = 1;

        while (derivedCtor.prototype['_ojLastGetCapability' + index]) {
          ++index;
        }

        derivedCtor.prototype['_ojLastGetCapability' + index] = _lastGetCapability;
      }
    }
  }]);

  return FetchByKeysMixin;
}();

oj['FetchByKeysMixin'] = FetchByKeysMixin;
oj['FetchByKeysMixin']['applyMixin'] = FetchByKeysMixin.applyMixin;



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 *
 * @export
 * @namespace FetchByKeysMixin
 * @classdesc Mixin class to provide generic implementation of {@link DataProvider#fetchByKeys} and {@link DataProvider#containsKeys}
 * methods for the {@link DataProvider} interface.
 * <p>
 * By default, the mixin implementation will iterate through all the rows to find
 * the result.  DataProvider implementations can implement a "getIterationLimit" function
 * that returns a row limit for the iteration:<br>
 * getIterationLimit() => number
 * </p>
 * <p>
 * This class cannot be instantiated.  You can only call the static applyMixin
 * method to add the implementation to another class.
 * </p>
 * @since 4.2.0
 * @hideconstructor
 */

/**
 * Apply this mixin to another class
 *
 *
 * @param {Function} derivedCtor the constructor of an existing class
 * @export
 * @expose
 * @memberof FetchByKeysMixin
 * @method
 * @name applyMixin
 * @ojtsexample <caption>Apply the mixin in Typescript:</caption>
 * class CustomDataProvider&lt;K, D> implements DataProvider&lt;K, D> {
 *   // Add stand-in properties to satisfy the compiler
 *   containsKeys: (parameters: FetchByKeysParameters&lt;K>) => Promise&lt;ContainsKeysResults&lt;K>>;
 *   fetchByKeys: (parameters: FetchByKeysParameters&lt;K>) => Promise&lt;FetchByKeysResults&lt;K, D>>;
 *
 *   constructor() {
 *     // Constructor implementation
 *   }
 * }
 *
 * FetchByKeysMixin.applyMixin(CustomDataProvider);
 *
 * @ojtsexample <caption>Apply the mixin in Javascript:</caption>
 * function CustomDataProvider() {
 *   // Constructor implementation
 * }
 *
 * FetchByKeysMixin.applyMixin(CustomDataProvider);
 * @ojsignature {target: "Type", value: "(derivedCtor: {new(): DataProvider<any, any>}): any;"}
 */

/**
 * end of jsdoc
 */







/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @export
 * @interface FetchByOffsetCapability
 * @since 4.2.0
 * @ojsignature {target: "Type",
 *               value: "interface FetchByOffsetCapability<D>",
 *               genericParameters: [{"name": "D", "description": "Type of Data"}]}
 * @classdesc Defines the result to the DataProvider method {@link DataProvider#getCapability} for capability "fetchByOffset"
 */

/**
 * The type of implementation for fetchByOffset method.  Possible values are:
 * <ul>
 * <li>"iteration": the implementation uses fetchFirst iteratively to find the result</li>
 * <li>"randomAccess": the implementation uses random access to find the result</li>
 * </ul>
 *
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof FetchByOffsetCapability
 * @instance
 * @name implementation
 * @type {"iteration" | "randomAccess"}
 */

/**
 * End of jsdoc
 */

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var FetchByOffsetMixin = /*#__PURE__*/function () {
  function FetchByOffsetMixin() {
    _classCallCheck(this, FetchByOffsetMixin);
  }

  _createClass(FetchByOffsetMixin, [{
    key: "fetchByOffset",

    /**
     * Fetch rows by offset
     */
    value: function fetchByOffset(params) {
      var size = params && params['size'] > 0 ? params['size'] : 25;
      var sortCriteria = params ? params['sortCriteria'] : null;
      var offset = params && params['offset'] > 0 ? params['offset'] : 0;
      var fetched = 0;
      var limit = this['getIterationLimit'] ? this['getIterationLimit']() : -1;
      var done = false;
      var options = {};
      options['size'] = size;
      options['sortCriteria'] = sortCriteria;
      var resultArray = new Array();
      var dataProviderAsyncIterator = this['fetchFirst'](options)[Symbol.asyncIterator]();

      function _fetchNextSet(params, dataProviderAsyncIterator, resultArray) {
        return dataProviderAsyncIterator.next().then(function (result) {
          done = result['done'];
          var value = result['value'];
          var data = value['data'];
          var metadata = value['metadata'];
          var dataLen = data.length;

          if (offset < fetched + dataLen) {
            var start = offset <= fetched ? 0 : offset - fetched;

            for (var index = start; index < dataLen; index++) {
              if (resultArray.length == size) {
                break;
              }

              resultArray.push({
                metadata: metadata[index],
                data: data[index]
              });
            }
          }

          fetched += dataLen;

          if (resultArray.length < size && !done) {
            if (limit != -1 && fetched >= limit) {
              // If we have reached the limit, just return the results
              return resultArray;
            } else {
              return _fetchNextSet(params, dataProviderAsyncIterator, resultArray);
            }
          } else {
            return resultArray;
          }
        });
      }

      return _fetchNextSet(params, dataProviderAsyncIterator, resultArray).then(function (resultArray) {
        return {
          fetchParameters: params,
          results: resultArray,
          done: done
        };
      });
    }
  }, {
    key: "getCapability",
    value: function getCapability(capabilityName) {
      if (capabilityName == 'fetchByOffset') {
        return {
          implementation: 'iteration'
        };
      }

      var cap = null;

      if (this['_ojSkipLastCapability'] !== true) {
        this['_ojSkipLastCapability'] = true; // Find the index for the very last _ojLastGetCapability

        var index = 1;

        while (this['_ojLastGetCapability' + index]) {
          ++index;
        } // Iterate through the _ojLastGetCapability(n) in reverse order


        for (--index; index > 0; index--) {
          cap = this['_ojLastGetCapability' + index](capabilityName);

          if (cap) {
            break;
          }
        }

        delete this['_ojSkipLastCapability'];
      }

      return cap;
    }
  }], [{
    key: "applyMixin",
    value: function applyMixin(derivedCtor) {
      // Save the current getCapability
      var _lastGetCapability = derivedCtor.prototype['getCapability'];
      var baseCtors = [FetchByOffsetMixin];
      baseCtors.forEach(function (baseCtor) {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach(function (name) {
          if (name !== 'constructor') {
            derivedCtor.prototype[name] = baseCtor.prototype[name];
          }
        });
      });

      if (_lastGetCapability) {
        var index = 1;

        while (derivedCtor.prototype['_ojLastGetCapability' + index]) {
          ++index;
        }

        derivedCtor.prototype['_ojLastGetCapability' + index] = _lastGetCapability;
      }
    }
  }]);

  return FetchByOffsetMixin;
}();

oj['FetchByOffsetMixin'] = FetchByOffsetMixin;
oj['FetchByOffsetMixin']['applyMixin'] = FetchByOffsetMixin.applyMixin;



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 *
 * @export
 * @namespace FetchByOffsetMixin
 * @classdesc Mixin class to provide generic implementation of {@link DataProvider#fetchByOffset}
 * method for the {@link DataProvider} interface.
 * <p>
 * By default, the mixin implementation will iterate through all the rows to find
 * the result.  DataProvider implementations can implement a "getIterationLimit" function
 * that returns a row limit for the iteration:<br>
 * getIterationLimit() => number
 * </p>
 * <p>
 * This class cannot be instantiated.  You can only call the static applyMixin
 * method to add the implementation to another class.
 * </p>
 * @since 4.2.0
 * @hideconstructor
 */

/**
 * Apply this mixin to another class
 *
 *
 * @param {Function} derivedCtor the constructor of an existing class
 * @export
 * @expose
 * @memberof FetchByOffsetMixin
 * @method
 * @name applyMixin
 * @ojtsexample <caption>Apply the mixin in Typescript:</caption>
 * class CustomDataProvider&lt;K, D> implements DataProvider&lt;K, D> {
 *   // Add a stand-in property to satisfy the compiler
 *   fetchByOffset: (parameters: FetchByOffsetParameters&lt;D>) => Promise&lt;FetchByOffsetResults&lt;K, D>>;
 *
 *   constructor() {
 *     // Constructor implementation
 *   }
 * }
 *
 * FetchByOffsetMixin.applyMixin(CustomDataProvider);
 *
 * @ojtsexample <caption>Apply the mixin in Javascript:</caption>
 * function CustomDataProvider() {
 *   // Constructor implementation
 * }
 *
 * FetchByOffsetMixin.applyMixin(CustomDataProvider);
 * @ojsignature {target: "Type", value: "(derivedCtor: {new(): DataProvider<any, any>}): any;"}
 */

/**
 * end of jsdoc
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @since 4.1.0
 * @export
 * @interface FetchByOffsetParameters
 * @extends FetchListParameters
 * @ojsignature {target: "Type",
 *               value: "interface FetchByOffsetParameters<D> extends FetchListParameters<D>",
 *               genericParameters: [{"name": "D", "description": "Type of Data"}]}
 * @classdesc Defines the parameters to the DataProvider method {@link DataProvider#fetchByOffset}
 */

/**
 * The offset used for the fetch call.
 *
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof FetchByOffsetParameters
 * @instance
 * @name offset
 * @type {number}
 */

/**
 * attributes to include in the result. If specified, then at least these set of attributes will be included in each row
 * results. If not specified then the default attributes will be included.
 *
 *
 * @since 6.1.0
 * @export
 * @expose
 * @memberof FetchByOffsetParameters
 * @instance
 * @name attributes
 * @type {Array.<string | FetchAttribute>}
 * @ojsignature {target: "Type",
 *               value: "?Array<string | FetchAttribute>"}
 */

/**
 * @since 4.1.0
 * @export
 * @interface FetchByOffsetResults
 * @ojsignature {target: "Type",
 *               value: "interface FetchByOffsetResults<K, D>"}
 * @classdesc FetchByOffsetResults defines the result from the DataProvider method {@link DataProvider#fetchByOffset}
 */

/**
 * The parameters used for the fetch call.
 *
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof FetchByOffsetResults
 * @instance
 * @name fetchParameters
 * @type {FetchByOffsetParameters}
 * @ojsignature {target: "Type",
 *               value: "FetchByOffsetParameters<D>"}
 */

/**
 * Array of {@link Item}.
 *
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof FetchByOffsetResults
 * @instance
 * @name results
 * @type {Array.<Item>}
 * @ojsignature {target: "Type",
 *               value: "Array<Item<K, D>>"}
 */

/**
 * Indicates whether there are more items which can be fetched.
 * <p>If this is true, fetching the next block will likely return an empty array as the result.  A DataProvider can potentially make a stronger guarantee (if the DataProvider is running against an immutable repository or the DataProvider doesnât attempt to retrieve a subsequent block if the DataProvider believes it is complete).  We donât generally make the stronger guarantee since the repository may have been mutated since the previous response with done:true, such that new records would be returned.</p>
 * <p>If this is false, fetching the next block may or may not return an empty array as a result.</p>
 *
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof FetchByOffsetResults
 * @instance
 * @name done
 * @type {boolean}
 */

/**
 * end of jsdoc
 */











function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }


var FilterImpl = /*#__PURE__*/function () {
  function FilterImpl(options) {
    _classCallCheck(this, FilterImpl);

    options = options || {};
    this._textFilterAttributes = options['filterOptions'] ? options['filterOptions']['textFilterAttributes'] : null;
    var filterDef = options.filterDef;

    if (filterDef) {
      if (filterDef['op']) {
        this['op'] = filterDef['op'];

        if (filterDef['value']) {
          this['value'] = filterDef['value'];

          if (filterDef['attribute']) {
            this['attribute'] = filterDef['attribute'];
          }
        } else if (filterDef['criteria']) {
          this['criteria'] = filterDef['criteria'];
        }
      } else if (filterDef['text']) {
        this['text'] = filterDef['text'];
      }
    }
  }

  _createClass(FilterImpl, [{
    key: "filter",
    value: function filter(item, index, array) {
      return oj.FilterUtils.satisfy(FilterImpl._transformFilter(this), item);
    }
  }], [{
    key: "_transformFilter",
    value: function _transformFilter(filter) {
      var transformedExpr;

      if (filter) {
        var op = filter.op;
        var filterValue;

        if (filter['text']) {
          op = '$regex';
        } else {
          // offline has slightly different names for some operators
          if (op === '$le') {
            op = '$lte';
          } else if (op === '$ge') {
            op = '$gte';
          } else if (op === '$pr') {
            op = '$exists';
          }
        }

        if (op != '$and' && op != '$or') {
          if (filter['text']) {
            // Escape special characters without change filter['text'] which is the original filter string
            filterValue = new RegExp(filter['text'].replace(/[.*+\-?^${}()|[\]\\]/g, '\\$&'), 'i');
          } else {
            filterValue = filter.value;
          }

          transformedExpr = {};
          var attributeExpr = filter.attribute;

          if (attributeExpr) {
            var operatorExpr = {}; // need express sw and ew as regex

            if (op === '$sw' || op === '$ew' || op === '$co') {
              op = '$regex';
              filterValue = FilterImpl._fixStringExpr(op, filterValue);
            }

            operatorExpr[op] = filterValue;
            transformedExpr[attributeExpr] = operatorExpr;
          } else if (filter['text']) {
            var _operatorExpr = {};
            _operatorExpr[op] = filterValue;

            if (filter._textFilterAttributes) {
              var textFilterArray = [];

              filter._textFilterAttributes.forEach(function (field) {
                var textFilter = {};
                textFilter[field] = _operatorExpr;
                textFilterArray.push(textFilter);
              });

              transformedExpr['$or'] = textFilterArray;
            } else {
              transformedExpr['*'] = _operatorExpr;
            }
          } else {
            // the field/value combos are specified in the value itself
            var criteriaArray = [];

            FilterImpl._transformObjectExpr(filterValue, op, null, criteriaArray);

            transformedExpr['$and'] = criteriaArray;
          }
        } else {
          var _criteriaArray = [];
          filter.criteria.forEach(function (criterion) {
            _criteriaArray.push(FilterImpl._transformFilter(criterion));
          });
          transformedExpr = {};
          transformedExpr[op] = _criteriaArray;
        }
      }

      return transformedExpr;
    }
  }, {
    key: "_transformObjectExpr",
    value: function _transformObjectExpr(objectExpr, op, path, criteriaArray) {
      var self = this;
      var objectProps = Object.keys(objectExpr);

      if (objectProps.length > 0) {
        Object.keys(objectExpr).forEach(function (fieldAttribute) {
          var fieldValue = objectExpr[fieldAttribute];
          var fieldAttributePath = path ? path + '.' + fieldAttribute : fieldAttribute;

          if (!(fieldValue instanceof Object)) {
            var operatorExpr = {}; // need express co, sw and ew as regex

            if (op === '$sw' || op === '$ew' || op === '$co') {
              op = '$regex';
              fieldValue = FilterImpl._fixStringExpr(op, fieldValue);
            }

            operatorExpr[op] = fieldValue;
            var fieldExpr = {};
            fieldExpr[fieldAttributePath] = operatorExpr;
            criteriaArray.push(fieldExpr);
          } else {
            FilterImpl._transformObjectExpr(fieldValue, op, fieldAttributePath, criteriaArray);
          }
        });
      } else {
        var operatorExpr = {};
        operatorExpr[op] = objectExpr;
        var fieldExpr = {};
        fieldExpr[path] = operatorExpr;
        criteriaArray.push(fieldExpr);
      }
    }
  }, {
    key: "_fixStringExpr",
    value: function _fixStringExpr(op, value) {
      if (typeof value === 'string' || value instanceof String) {
        if (op === '$sw') {
          value = '^' + value;
        } else if (op === '$ew') {
          value = value + '$';
        }
      }

      return value;
    }
  }]);

  return FilterImpl;
}();

var FilterFactory = /*#__PURE__*/function () {
  function FilterFactory() {
    _classCallCheck(this, FilterFactory);
  }

  _createClass(FilterFactory, null, [{
    key: "getFilter",
    value: function getFilter(options) {
      return new FilterImpl(options);
    }
  }]);

  return FilterFactory;
}();

oj['FilterFactory'] = FilterFactory;



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @export
 * @class FilterFactory
 * @since 7.0.0
 * @ojsignature {target: "Type",
 *               value: "class FilterFactory<D>"}
 * @hideconstructor
 * @classdesc Provides the ability to construct filters which can be used for {@link FetchListParameters#filterCriterion}. Note is it not a requirement to use this
 * factory to construct filters based on the filter definition. Applications can construct their own filters which implement the interface {@link DataFilter.Filter}
 */

/**
 * This function is used to pass in a filter definition and returns a filter which can be used
 * with DataProviders. It essentially takes the filter definition and then adds a local filter()
 * function which is required when used for a DataProvider filterCriterion.
 *
 *
 * @since 7.0.0
 * @export
 * @expose
 * @memberof FilterFactory
 * @instance
 * @name getFilter
 * @method
 * @static
 * @param {Object} options Options for the getFilter() function
 * @param {DataFilter.FilterDef} options.filterDef The filter definition for the filter to be returned.
 * @param {any=} options.filterOptions Options for the filter such as textFilterAttributes which lists the attributes to filter on for TextFilter.
 * @return {DataFilter.Filter} Returns either an AttributeFilter, AttributeExprFilter, CompoundFilter, or TextFilter depending on whether a AttributeFilterDef or CompoundFilterDef.
 * was passed in.
 * @ojsignature {target: "Type",
 *               value: "(options: {filterDef: DataFilter.FilterDef<any>, filterOptions: any}): DataFilter.Filter<any>",
 *               genericParameters: [{"name": "D", "description": "Type of Data"}]}
 * @example
 * <caption>Get filter which filters on DepartmentId value 10 and then fetch filtered rows from the DataProvider</caption>
 * var filter = FilterFactory.getFilter({filterDef: {op: '$eq', value: {DepartmentId: 10}}};
 * var dataProviderAsyncIterator = dataprovider.fetchFirst({filterCriterion: filter})[Symbol.asyncIterator]();
 * let result = await dataProviderAsyncIterator.next();
 * ...
 **/

/**
 * End of jsdoc
 */





/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * The interface for FilterOperator
 *
 *
 * @export
 * @interface FilterOperator
 * @since 5.0.0
 * @ojsignature {target: "Type",
 *               value: "interface FilterOperator<D>",
 *               genericParameters: [{"name": "D", "description": "Type of Data"}]}
 * @ojdeprecated {since: '7.0.0', description: 'Use AttributeFilter or CompoundFilter instead.'}
 */

/**
 * The operator, either an AttributeFilterOperator.AttributeOperator or CompoundFilterOperator.CompoundOperator.
 *
 *
 * @since 5.0.0
 * @export
 * @expose
 * @memberof FilterOperator
 * @instance
 * @name op
 * @type {AttributeFilterOperator.AttributeOperator | CompoundFilterOperator.CompoundOperator}
 */

/**
 * Optional function which is used to locally filter the data.
 *
 *
 * @since 5.0.0
 * @export
 * @expose
 * @memberof FilterOperator
 * @instance
 * @name filter
 * @method
 * @param {Array} data The data to filter
 * @return {Array} filtered data
 */

/**
 * End of jsdoc
 */

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }



/* eslint-disable */

/**
 * @ignore
 * @class oj.FilterUtils
 * @constructor
 */
oj.FilterUtils = function () {
  'use strict';
  /**
    * Helper function that checks if itemData satisfies the search criteria
    * defined by selector or not. Undefined selector means everything is
    * selected.
    * @method
    * @name satisfy
    * @memberof! storageUtils
    * @static
    * @param {string} selector Rule that defines whether an object is selected
    *                          or not.
    * @param {object} itemData The value to check with.
    * @returns {boolean} true if itemData satisfies search criteria defined
    *                         by selector, and false otherwise.
    */

  function satisfy(selector, itemData) {
    if (!selector) {
      // undefined selector means select everything.
      return true;
    } else {
      var expTree = _buildExpressionTree(selector);

      return _evaluateExpressionTree(expTree, itemData);
    }
  }

  ;
  /**
   * Helper function used by {@link _satisfy} to build an expression tree
   * based on expression object for easier evaluation later.
   * @method
   * @name _buildExpressionTree
   * @memberof! storageUtils
   * @static
   * @param {object} expression The expression that used to filter an object.
   * @returns {object} The tree representation of the passed-in expression.
   */

  function _buildExpressionTree(expression) {
    var subTree;
    var itemTreeArray = [];

    for (var key in expression) {
      if (expression.hasOwnProperty(key)) {
        var value = expression[key];

        if (key.indexOf('$') === 0) {
          if (_isMultiSelector(key)) {
            if (value instanceof Array) {
              subTree = {
                operator: key,
                array: []
              };

              for (var subindex = 0; subindex < value.length; subindex++) {
                var itemTree = _buildExpressionTree(value[subindex]);

                subTree.array.push(itemTree);
              }
            } else {
              throw new Error("not a valid expression: " + expression);
            }
          } else if (_isSingleSelector(key)) {
            throw new Error("not a valid expression: " + expression);
          }
        } else if (_isLiteral(value)) {
          itemTreeArray.push({
            left: key,
            right: value,
            operator: '$eq'
          });
        } else {
          var partialTree = {
            left: key
          };

          _completePartialTree(partialTree, value);

          itemTreeArray.push(partialTree);
        }
      }
    }

    if (itemTreeArray.length > 1) {
      subTree = {
        operator: '$and',
        array: itemTreeArray
      };
    } else if (itemTreeArray.length === 1) {
      subTree = itemTreeArray[0];
    }

    return subTree;
  }

  ;
  /**
   * Helper function used by {@link _buildExpressionTree} to complete the
   * right side of an expression tree.
   * @method
   * @name _completePartialTree
   * @memberof! storageUtils
   * @static
   * @param {object} partialTree The tree representation of an expression.
   * @param {object} expression The object to evaluate the expression tree
   *                          against.
   */

  function _completePartialTree(partialTree, expression) {
    var found = false;

    for (var key in expression) {
      if (expression.hasOwnProperty(key)) {
        var value = expression[key];

        if (found || !_isSingleSelector(key)) {
          throw new Error("parsing error " + expression);
        }

        partialTree.operator = key;
        partialTree.right = value;
        found = true;
      }
    }
  }

  ;
  /**
   * Helper function used by {@link find} to apply an expression tree to
   * an object to check if this object satisfies the expression tree or not.
   * @method
   * @name _evaluateExpressionTree
   * @memberof! storageUtils
   * @tatic
   * @param {object} expTree The tree representation of an expression.
   * @param {object} itemData The object to evaluate the expression tree
   *                          against.
   * @returns {boolean} true if itemData satisfies expression tree, false
   *                    otherwise.
   */

  function _evaluateExpressionTree(expTree, itemData) {
    var operator = expTree.operator;

    if (_isMultiSelector(operator)) {
      if (expTree.left || !(expTree.array instanceof Array)) {
        throw new Error("invalid expression tree!" + expTree);
      } else {
        var result;
        var subTreeArray = expTree.array;

        for (var subIndex = 0; subIndex < subTreeArray.length; subIndex++) {
          var subResult = _evaluateExpressionTree(subTreeArray[subIndex], itemData);

          if (operator === '$or' && subResult === true) {
            return true;
          } else if (operator === '$and' && subResult === false) {
            return false;
          }

          result = subResult;
        }

        return result;
      }
    } else if (_isSingleSelector(operator)) {
      var value = expTree.right;
      var itemValue;

      if (expTree.left != '*') {
        itemValue = getValue(expTree.left, itemData);
        return _evaluateSingleSelectorExpression(operator, value, itemValue);
      } else {
        var i;
        var itemProperties = Object.keys(itemData);

        for (i = 0; i < itemProperties.length; i++) {
          itemValue = getValue(itemProperties[i], itemData);

          if (_evaluateSingleSelectorExpression(operator, value, itemValue)) {
            return true;
          }
        }

        return false;
      }
    } else {
      throw new Error("not a valid expression!" + expTree);
    }
  }

  ;
  /**
   * Helper function to evaluate a single selector expression.
   * @method
   * @name _evaluateSingleSelectorExpression
   * @memberof! storageUtils
   * @static
   * @param {string} operator The operator of an expression.
   * @param {object} value The value.
   * @param {object} itemData The object to evaluate the expression tree
   *                          against.
   * @returns {boolean} true if itemData satisfies expression, false
   *                    otherwise.
   */

  function _evaluateSingleSelectorExpression(operator, value, itemValue) {
    if (operator === '$lt') {
      var fixedTokens = _fixNullForString(itemValue, value);

      itemValue = fixedTokens[0];
      value = fixedTokens[1];
      return itemValue < value;
    } else if (operator === '$gt') {
      var fixedTokens = _fixNullForString(itemValue, value);

      itemValue = fixedTokens[0];
      value = fixedTokens[1];
      return itemValue > value;
    } else if (operator === '$lte') {
      var fixedTokens = _fixNullForString(itemValue, value);

      itemValue = fixedTokens[0];
      value = fixedTokens[1];
      return itemValue <= value;
    } else if (operator === '$gte') {
      var fixedTokens = _fixNullForString(itemValue, value);

      itemValue = fixedTokens[0];
      value = fixedTokens[1];
      return itemValue >= value;
    } else if (operator === '$eq') {
      return itemValue === value;
    } else if (operator === '$ne') {
      return itemValue !== value;
    } else if (operator === '$regex') {
      if (itemValue) {
        if (!(typeof itemValue === 'string') && !(itemValue instanceof String)) {
          if (!(itemValue instanceof Object)) {
            // primitive so coerce to a string
            itemValue = new String(itemValue);
          } else {
            // call toString() on objects. Check if it returns just the default
            // return value for toString(). If so, then we can't do anything so
            // return false
            itemValue = itemValue.toString();

            if (itemValue == '[object Object]') {
              return false;
            }
          }
        }

        var matchResult = itemValue.match(value);
        return matchResult !== null;
      }

      return false;
    } else if (operator === '$exists') {
      if (value) {
        return itemValue !== null && itemValue !== undefined;
      } else {
        return itemValue === null || itemValue === undefined;
      }
    } else {
      throw new Error("not a valid expression! " + expTree);
    }

    return false;
  }
  /**
   * Helper function that checks if the token is a multiple selector operator
   * or not.
   * @method
   * @name _isMultiSelector
   * @memberof! storageUtils
   * @static
   * @param {string} token The token to check against.
   * @returns {boolean} true if the token is the supported multiple selector
   *                    operator, false otherwise.
   */


  function _isMultiSelector(token) {
    return token === '$and' || token === '$or';
  }

  ;
  /**
   * Helper function that checks if the token is a single selector operator
   * or not.
   * @method
   * @name _isSingleSelector
   * @memberof! storageUtils
   * @static
   * @param {string} token The token to check against.
   * @returns {boolean} true if the token is the supported single selector
   *                    operator, false otherwise.
   */

  function _isSingleSelector(token) {
    return token === '$lt' || token === '$gt' || token === '$lte' || token === '$gte' || token === '$eq' || token === '$ne' || token === '$regex' || token === '$exists';
  }

  ;
  /**
   * Helper function that checks if the token is a literal or not.
   * @method
   * @name _isLiteral
   * @memberof! storageUtils
   * @static
   * @param {string} token The token to check against.
   * @returns {boolean} true if the token is a literal, false otherwise.
   */

  function _isLiteral(token) {
    return _typeof(token) !== 'object';
  }

  ;
  /**
   * Helper function that checks if the token is a string
   * @method
   * @name _isSring
   * @memberof! storageUtils
   * @static
   * @param {string} token The token to check against.
   * @returns {boolean} true if the token is a string, false otherwise.
   */

  function _isString(token) {
    return token != null && (token instanceof String || typeof token === 'string');
  }

  ;
  /**
   * Helper function that sets null literals to empty string for string comparison
   * @method
   * @name _fixNullForString
   * @memberof! storageUtils
   * @static
   * @param {string} leftToken left hand token
   * @param {string} rightToken right hand token
   * @returns {Array} Array of left and right hand tokens
   */

  function _fixNullForString(leftToken, rightToken) {
    if (_isString(leftToken) && rightToken == null) {
      rightToken = '';
    } else if (_isString(rightToken) && leftToken == null) {
      leftToken = '';
    }

    return [leftToken, rightToken];
  }

  ;
  /**
   * Helper function that retrieves the value of a property from an object.
   * The object can have nested properties, and the property name could be
   * a path to the leaf property.
   * @method
   * @name getValue
   * @memberof! storageUtils
   * @static
   * @param {string} path The chain of the property names from the root to
   *                      the leaf when the object has nested properties.
   * @param {object} itemValue The object to retrieve the property value
   *                           from.
   * @returns {object} the object that contains all the properties defined
   *                   in fieldsExpression array, the corresponding property
   *                   value is obtained from itemData.
   */

  function getValue(path, itemValue) {
    var paths = path.split('.');
    var returnValue = itemValue;

    for (var index = 0; index < paths.length; index++) {
      returnValue = returnValue[paths[index]];
    }

    return returnValue;
  }

  ;
  /**
   * Helper function that constructs an object out from value
   * based on fields.
   * @method
   * @name assembleObject
   * @param {object} value The original object to construct the return object
   *                       from.
   * @param {Array} fields An array of property names whose values
   *                       should be included in the final contructed
   *                       return object.
   * @returns {object} the object that contains all the properties defined
   *                   in fields array, the corresponding property
   *                   value is obtained from value.
   * @ignore
   */

  function assembleObject(value, fields) {
    var returnObject;

    if (!fields) {
      returnObject = value;
    } else {
      returnObject = {};

      for (var index = 0; index < fields.length; index++) {
        var currentObject = returnObject;
        var currentItemDataValue = value;
        var field = fields[index];
        var paths = field.split('.');

        for (var pathIndex = 0; pathIndex < paths.length; pathIndex++) {
          currentItemDataValue = currentItemDataValue[paths[pathIndex]];

          if (!currentObject[paths[pathIndex]] && pathIndex < paths.length - 1) {
            currentObject[paths[pathIndex]] = {};
          }

          if (pathIndex === paths.length - 1) {
            currentObject[paths[pathIndex]] = currentItemDataValue;
          } else {
            currentObject = currentObject[paths[pathIndex]];
          }
        }
      }
    }

    return returnObject;
  }

  ;
  return {
    satisfy: satisfy,
    getValue: getValue,
    assembleObject: assembleObject
  };
}();







/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * The interface for ItemMetadata.  Note that key is the only mandatory property,
 * implementations can provide additional properties as needed.
 *
 *
 * @since 9.0.0
 * @export
 * @interface ItemMessage
 * @ojsignature {target: "Type",
 *               value: "interface ItemMessage"}
 */

/**
 * Detail text of the message.
 *
 * @since 9.0.0
 * @export
 * @expose
 * @memberof ItemMessage
 * @instance
 * @name detail
 * @type {string}
 */

/**
 * Severity type or level of the message.
 *
 * @since 9.0.0
 * @export
 * @expose
 * @memberof ItemMessage
 * @instance
 * @name severity
 * @type {(ItemMessage.SEVERITY_TYPE | ItemMessage.SEVERITY_LEVEL)=}
 * @ojsignature {target: "Type",
 *               value: "?(ItemMessage.SEVERITY_TYPE | ItemMessage.SEVERITY_LEVEL)"}
 */

/**
 * Summary text of the message.
 *
 * @since 9.0.0
 * @export
 * @expose
 * @memberof ItemMessage
 * @instance
 * @name summary
 * @type {string}
 */

/**
 * The supported severity levels of the message.
 * @typedef {1 | 2 | 3 | 4 | 5} ItemMessage.SEVERITY_LEVEL
 * @ojsignature {target:"Type", value:"1 | 2 | 3 | 4 | 5"}
 * @ojvalue {number} 1 {"description": "Indicates a confirmation that an operation or task was completed. This is the lowest severity level."}
 * @ojvalue {number} 2 {"description": "Indicates information or operation messages. This has a lower severity level than warning."}
 * @ojvalue {number} 3 {"description": "Indicates an application condition or situation that might require users' attention. This has a lower severity than error."}
 * @ojvalue {number} 4 {"description": "Used when data inaccuracies occur when completing a field and that needs fixing before user can continue. This has a lower severity level than fatal."}
 * @ojvalue {number} 5 {"description": "Used when a critical application error or an unknown failure occurs. This is the highest severity level."}
 */

/**
 * The supported severity types of the message.
 * @typedef {'confirmation' | 'info' | 'warning' | 'error' | 'fatal'} ItemMessage.SEVERITY_TYPE
 * @ojsignature {target:"Type", value:"'confirmation' | 'info' | 'warning' | 'error' | 'fatal'"}
 * @ojvalue {string} "confirmation" {"description": "Indicates a confirmation that an operation or task was completed. This is the lowest severity level."}
 * @ojvalue {string} "info" {"description": "Indicates information or operation messages. This has a lower severity level than warning."}
 * @ojvalue {string} "warning" {"description": "Indicates an application condition or situation that might require users' attention. This has a lower severity than error."}
 * @ojvalue {string} "error" {"description": "Used when data inaccuracies occur when completing a field and that needs fixing before user can continue. This has a lower severity level than fatal."}
 * @ojvalue {string} "fatal" {"description": "Used when a critical application error or an unknown failure occurs. This is the highest severity level."}
 */

/**
 * End of jsdoc
 */







/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * The interface for ItemWithOptionalData
 *
 *
 * @since 9.0.0
 * @export
 * @interface ItemWithOptionalData
 * @ojsignature {target: "Type",
 *               value: "interface ItemWithOptionalData<K, D>",
 *               genericParameters: [{"name": "K", "description": "Type of Key"}, {"name": "D", "description": "Type of Data"}]}
 */

/**
 * The metadata for the item
 *
 *
 * @since 9.0.0
 * @export
 * @expose
 * @memberof ItemWithOptionalData
 * @instance
 * @name metadata
 * @type {ItemMetadata}
 * @ojsignature {target: "Type",
 *               value: "ItemMetadata<K>"}
 */

/**
 * The data for the item
 *
 *
 * @since 9.0.0
 * @export
 * @expose
 * @memberof ItemWithOptionalData
 * @instance
 * @name data
 * @type {Object}
 * @ojsignature {target: "Type",
 *               value: "?D"}
 */

/**
 * End of jsdoc
 */



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * @since 4.1.0
 * @export
 * @interface Item
 * @extends ItemWithOptionalData
 * @ojsignature {target: "Type",
 *               value: "interface Item<K, D> extends ItemWithOptionalData<K, D>",
 *               genericParameters: [{"name": "K", "description": "Type of Key"}, {"name": "D", "description": "Type of Data"}]}
 * @classdesc Defines the items returned in the Map<K, Item<K, D>> from the DataProvider method {@link DataProvider#fetchByKeys}
 */

/**
 * The metadata for the item
 *
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof Item
 * @instance
 * @name metadata
 * @type {ItemMetadata}
 * @ojsignature {target: "Type",
 *               value: "ItemMetadata<K>"}
 */

/**
 * The data for the item
 *
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof Item
 * @instance
 * @name data
 * @type {Object}
 * @ojsignature {target: "Type",
 *               value: "D"}
 */

/**
 * End of jsdoc
 */





/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 * The interface for SortCapability
 *
 *
 * @export
 * @interface SortCapability
 * @since 4.2.0
 * @ojsignature {target: "Type",
 *               value: "interface SortCapability<D>",
 *               genericParameters: [{"name": "D", "description": "Type of Data"}]}
 * @classdesc Defines the result from the DataProvider method {@link DataProvider#getCapability} for capability "sort"
 */

/**
 * Number of attributes that can be sorted at the same time.  Possible values are:
 * <ul>
 * <li>"none": no sorting is supported.</li>
 * <li>"single": only one attribute can be sorted at a time.</li>
 * <li>"multiple": more than one attribute can be sorted at a time.</li>
 * </ul>
 *
 *
 * @since 4.2.0
 * @export
 * @expose
 * @memberof SortCapability
 * @instance
 * @name attributes
 * @type {"none" | "single" | "multiple"}
 */

/**
 * End of jsdoc
 */








var __DataProvider = {};
__DataProvider.FetchByKeysMixin = oj.FetchByKeysMixin;
__DataProvider.FetchByOffsetMixin = oj.FetchByOffsetMixin;
__DataProvider.FilterFactory = oj.FilterFactory;
__DataProvider.DataProviderRefreshEvent = oj.DataProviderRefreshEvent;
__DataProvider.DataProviderMutationEvent = oj.DataProviderMutationEvent;
__DataProvider.AttributeFilterOperator = oj.AttributeFilterOperator;
__DataProvider.CompoundFilterOperator = oj.CompoundFilterOperator;
__DataProvider.DataCache = oj.DataCache;

  ;return __DataProvider;
});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojlistdataproviderview',['ojs/ojcore', 'jquery', 'ojs/ojdataprovider', 'ojs/ojcomponentcore', 'ojs/ojeventtarget', 'ojs/ojdataprovider'], function(oj, $, __DataProvider)
{
  "use strict";
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }



/**
 * Class which provides list based optimizations
 */
var ListDataProviderView = /*#__PURE__*/function () {
  function ListDataProviderView(dataProvider, options) {
    _classCallCheck(this, ListDataProviderView);

    this.dataProvider = dataProvider;
    this.options = options;
    this._noFilterSupport = false;

    this.AsyncIterable = /*#__PURE__*/function () {
      function _class(_parent, _asyncIterator) {
        _classCallCheck(this, _class);

        this._parent = _parent;
        this._asyncIterator = _asyncIterator;

        this[Symbol.asyncIterator] = function () {
          return this._asyncIterator;
        };
      }

      return _class;
    }();

    this.AsyncIterator = /*#__PURE__*/function () {
      function _class2(_parent, _nextFunc, _params) {
        _classCallCheck(this, _class2);

        this._parent = _parent;
        this._nextFunc = _nextFunc;
        this._params = _params;
      }

      _createClass(_class2, [{
        key: 'next',
        value: function next() {
          var result = this._nextFunc(this._params);

          return Promise.resolve(result);
        }
      }]);

      return _class2;
    }();

    this.AsyncIteratorYieldResult = /*#__PURE__*/function () {
      function _class3(_parent, value) {
        _classCallCheck(this, _class3);

        this._parent = _parent;
        this.value = value;
        this[ListDataProviderView._VALUE] = value;
        this[ListDataProviderView._DONE] = false;
      }

      return _class3;
    }();

    this.AsyncIteratorReturnResult = /*#__PURE__*/function () {
      function _class4(_parent, value) {
        _classCallCheck(this, _class4);

        this._parent = _parent;
        this.value = value;
        this[ListDataProviderView._VALUE] = value;
        this[ListDataProviderView._DONE] = true;
      }

      return _class4;
    }();

    this.FetchListResult = /*#__PURE__*/function () {
      function _class5(_parent, fetchParameters, data, metadata) {
        _classCallCheck(this, _class5);

        this._parent = _parent;
        this.fetchParameters = fetchParameters;
        this.data = data;
        this.metadata = metadata;
        this[ListDataProviderView._FETCHPARAMETERS] = fetchParameters;
        this[ListDataProviderView._DATA] = data;
        this[ListDataProviderView._METADATA] = metadata;
      }

      return _class5;
    }();

    this.Item = /*#__PURE__*/function () {
      function _class6(_parent, metadata, data) {
        _classCallCheck(this, _class6);

        this._parent = _parent;
        this.metadata = metadata;
        this.data = data;
        this[ListDataProviderView._METADATA] = metadata;
        this[ListDataProviderView._DATA] = data;
      }

      return _class6;
    }();

    this.ItemMetadata = /*#__PURE__*/function () {
      function _class7(_parent, key) {
        _classCallCheck(this, _class7);

        this._parent = _parent;
        this.key = key;
        this[ListDataProviderView._KEY] = key;
      }

      return _class7;
    }();

    this.FetchListParameters = /*#__PURE__*/function () {
      function _class8(_parent, params, size, sortCriteria, filterCriterion, attributes) {
        _classCallCheck(this, _class8);

        this._parent = _parent;
        this.params = params;
        this.size = size;
        this.sortCriteria = sortCriteria;
        this.filterCriterion = filterCriterion;
        this.attributes = attributes;
        var self = this;

        if (params) {
          Object.keys(params).forEach(function (prop) {
            self[prop] = params[prop];
          });
        }

        this[ListDataProviderView._SIZE] = size;

        if (sortCriteria) {
          this[ListDataProviderView._SORTCRITERIA] = sortCriteria;
        }

        if (filterCriterion) {
          this[ListDataProviderView._FILTERCRITERION] = filterCriterion;
        }

        if (attributes) {
          this[ListDataProviderView._FETCHATTRIBUTES] = attributes;
        }
      }

      return _class8;
    }();

    this.FetchByKeysParameters = /*#__PURE__*/function () {
      function _class9(_parent, keys, params, attributes) {
        _classCallCheck(this, _class9);

        this._parent = _parent;
        this.keys = keys;
        this.params = params;
        this.attributes = attributes;
        var self = this;

        if (params) {
          Object.keys(params).forEach(function (prop) {
            self[prop] = params[prop];
          });
        }

        if (keys) {
          this[ListDataProviderView._KEYS] = keys;
        }

        if (attributes) {
          this[ListDataProviderView._FETCHATTRIBUTES] = attributes;
        }
      }

      return _class9;
    }();

    this.FetchByOffsetParameters = /*#__PURE__*/function () {
      function _class10(_parent, offset, params, size, sortCriteria, filterCriterion, attributes) {
        _classCallCheck(this, _class10);

        this._parent = _parent;
        this.offset = offset;
        this.params = params;
        this.size = size;
        this.sortCriteria = sortCriteria;
        this.filterCriterion = filterCriterion;
        this.attributes = attributes;
        var self = this;

        if (params) {
          Object.keys(params).forEach(function (prop) {
            self[prop] = params[prop];
          });
        }

        if (size) {
          this[ListDataProviderView._SIZE] = size;
        }

        if (sortCriteria) {
          this[ListDataProviderView._SORTCRITERIA] = sortCriteria;
        }

        if (offset) {
          this[ListDataProviderView._OFFSET] = offset;
        }

        if (filterCriterion) {
          this[ListDataProviderView._FILTERCRITERION] = filterCriterion;
        }

        if (attributes) {
          this[ListDataProviderView._FETCHATTRIBUTES] = attributes;
        }
      }

      return _class10;
    }();

    this.FetchByKeysResults = /*#__PURE__*/function () {
      function _class11(_parent, fetchParameters, results) {
        _classCallCheck(this, _class11);

        this._parent = _parent;
        this.fetchParameters = fetchParameters;
        this.results = results;
        this[ListDataProviderView._FETCHPARAMETERS] = fetchParameters;
        this[ListDataProviderView._RESULTS] = results;
      }

      return _class11;
    }();

    this.ContainsKeysResults = /*#__PURE__*/function () {
      function _class12(_parent, containsParameters, results) {
        _classCallCheck(this, _class12);

        this._parent = _parent;
        this.containsParameters = containsParameters;
        this.results = results;
        this[ListDataProviderView._CONTAINSPARAMETERS] = containsParameters;
        this[ListDataProviderView._RESULTS] = results;
      }

      return _class12;
    }();

    this.FetchByOffsetResults = /*#__PURE__*/function () {
      function _class13(_parent, fetchParameters, results, done) {
        _classCallCheck(this, _class13);

        this._parent = _parent;
        this.fetchParameters = fetchParameters;
        this.results = results;
        this.done = done;
        this[ListDataProviderView._FETCHPARAMETERS] = fetchParameters;
        this[ListDataProviderView._RESULTS] = results;
        this[ListDataProviderView._DONE] = done;
      }

      return _class13;
    }();

    this[ListDataProviderView._FROM] = this.options == null ? null : this.options[ListDataProviderView._FROM];
    this[ListDataProviderView._OFFSET] = this.options == null ? 0 : this.options[ListDataProviderView._OFFSET] > 0 ? this.options[ListDataProviderView._OFFSET] : 0;
    this[ListDataProviderView._SORTCRITERIA] = this.options == null ? null : this.options[ListDataProviderView._SORTCRITERIA];
    this[ListDataProviderView._DATAMAPPING] = this.options == null ? null : this.options[ListDataProviderView._DATAMAPPING];
    this[ListDataProviderView._FETCHATTRIBUTES] = this.options == null ? null : this.options[ListDataProviderView._FETCHATTRIBUTES];
    this[ListDataProviderView._FILTERCRITERION] = this.options == null ? null : this.options[ListDataProviderView._FILTERCRITERION];

    this._addEventListeners(dataProvider);

    if (dataProvider.getCapability && !dataProvider.getCapability('filter')) {
      this._noFilterSupport = true;
    }
  }

  _createClass(ListDataProviderView, [{
    key: "containsKeys",
    value: function containsKeys(params) {
      var self = this;

      if (this.dataProvider[ListDataProviderView._CONTAINSKEYS]) {
        return this.dataProvider[ListDataProviderView._CONTAINSKEYS](params);
      } else {
        return this.fetchByKeys(params).then(function (fetchByKeysResult) {
          var results = new Set();

          params[ListDataProviderView._KEYS].forEach(function (key) {
            if (fetchByKeysResult[ListDataProviderView._RESULTS].get(key) != null) {
              results.add(key);
            }
          });

          return Promise.resolve(new self.ContainsKeysResults(self, params, results));
        });
      }
    }
  }, {
    key: "fetchByKeys",
    value: function fetchByKeys(params) {
      var self = this;
      var keys = params != null ? params[ListDataProviderView._KEYS] : null;
      var fetchAttributes = params != null ? params[ListDataProviderView._FETCHATTRIBUTES] : null;

      if (fetchAttributes == null) {
        fetchAttributes = this[ListDataProviderView._FETCHATTRIBUTES];
      }

      var updatedParams = new self.FetchByKeysParameters(self, keys, params, fetchAttributes);

      if (this.dataProvider[ListDataProviderView._FETCHBYKEYS]) {
        return this.dataProvider[ListDataProviderView._FETCHBYKEYS](updatedParams).then(function (value) {
          var resultMap = value[ListDataProviderView._RESULTS];
          var mappedResultMap = new Map();
          resultMap.forEach(function (value, key) {
            var mappedItem = self._getMappedItems([value]);

            mappedResultMap.set(key, mappedItem[0]);
          });
          return new self.FetchByKeysResults(self, updatedParams, mappedResultMap);
        });
      } else {
        var options = new this.FetchListParameters(this, null, ListDataProviderView._DEFAULT_SIZE, null, null, fetchAttributes);
        var resultMap = new Map();

        var dataProviderAsyncIterator = this.dataProvider[ListDataProviderView._FETCHFIRST](options)[Symbol.asyncIterator]();

        return this._fetchNextSet(params, dataProviderAsyncIterator, resultMap).then(function (resultMap) {
          var mappedResultMap = new Map();
          resultMap.forEach(function (value, key) {
            var mappedItem = self._getMappedItems([value]);

            mappedResultMap.set(key, mappedItem[0]);
          });
          return new self.FetchByKeysResults(self, updatedParams, mappedResultMap);
        });
      }
    }
  }, {
    key: "fetchByOffset",
    value: function fetchByOffset(params) {
      var self = this;
      var offset = params != null ? params[ListDataProviderView._OFFSET] : null;
      var size = params != null ? params[ListDataProviderView._SIZE] : null;
      var fetchAttributes = params != null ? params[ListDataProviderView._FETCHATTRIBUTES] : null;

      if (fetchAttributes == null) {
        fetchAttributes = this[ListDataProviderView._FETCHATTRIBUTES];
      }

      var sortCriteria = params != null ? params[ListDataProviderView._SORTCRITERIA] : null;

      if (sortCriteria == null) {
        sortCriteria = this[ListDataProviderView._SORTCRITERIA];
      }

      var mappedSortCriteria = this._getMappedSortCriteria(sortCriteria);

      var filterCriterion = params != null ? params[ListDataProviderView._FILTERCRITERION] : null;

      var mappedFilterCriterion = this._getMappedFilterCriterion(filterCriterion);

      var updatedParams = new self.FetchByOffsetParameters(self, offset, params, size, mappedSortCriteria, mappedFilterCriterion, fetchAttributes);
      return this.dataProvider[ListDataProviderView._FETCHBYOFFSET](updatedParams).then(function (value) {
        var resultArray = value[ListDataProviderView._RESULTS];
        var done = value[ListDataProviderView._DONE];
        var mappedResultArray = new Array();
        resultArray.forEach(function (value) {
          var mappedItem = self._getMappedItems([value]);

          mappedResultArray.push(mappedItem[0]);
        });
        return new self.FetchByOffsetResults(self, updatedParams, mappedResultArray, done);
      });
    }
  }, {
    key: "fetchFirst",
    value: function fetchFirst(params) {
      // this fetchFirst applies the offset and from properties on the this.
      // If fetchByOffset is supported by the underlying dataprovider then that is used for offset.
      // Otherwise, fetches are made in chunks until from and offset are fulfilled.
      var cachedData = {};
      cachedData[ListDataProviderView._ITEMS] = [];
      cachedData[ListDataProviderView._DONE] = false;
      cachedData[ListDataProviderView._STARTINDEX] = 0;
      var size = params != null ? params[ListDataProviderView._SIZE] : null;
      var sortCriteria = params != null ? params[ListDataProviderView._SORTCRITERIA] : null;

      if (sortCriteria == null) {
        sortCriteria = this[ListDataProviderView._SORTCRITERIA];
      }

      var mappedSortCriteria = this._getMappedSortCriteria(sortCriteria);

      var filterCriterion = params != null ? params[ListDataProviderView._FILTERCRITERION] : null;

      if (filterCriterion == null) {
        filterCriterion = this[ListDataProviderView._FILTERCRITERION];
      }

      var mappedFilterCriterion = this._getMappedFilterCriterion(filterCriterion);

      var fetchAttributes = params != null ? params[ListDataProviderView._FETCHATTRIBUTES] : null;

      if (fetchAttributes == null) {
        fetchAttributes = this[ListDataProviderView._FETCHATTRIBUTES];
      }

      var self = this;

      if (self[ListDataProviderView._FROM] == null && self[ListDataProviderView._OFFSET] > 0) {
        var offset = self[ListDataProviderView._OFFSET];
        return new this.AsyncIterable(this, new this.AsyncIterator(this, function (cachedData) {
          return function () {
            var updatedParams = new self.FetchByOffsetParameters(self, offset, null, size, mappedSortCriteria, mappedFilterCriterion, fetchAttributes);
            return self.dataProvider[ListDataProviderView._FETCHBYOFFSET](updatedParams).then(function (result) {
              var results = result['results'];
              offset = offset + results.length;

              var mappedResult = self._getMappedItems(results);

              self._cacheResult(cachedData, mappedResult);

              cachedData[ListDataProviderView._DONE] = result[ListDataProviderView._DONE];
              var data = mappedResult.map(function (value) {
                return value[ListDataProviderView._DATA];
              });
              var metadata = mappedResult.map(function (value) {
                return value[ListDataProviderView._METADATA];
              });
              var resultFetchParams = result[ListDataProviderView._FETCHPARAMETERS];
              var resultSortCriteria = resultFetchParams != null ? resultFetchParams[ListDataProviderView._SORTCRITERIA] : null;
              var resultFilterCriterion = resultFetchParams != null ? resultFetchParams[ListDataProviderView._FILTERCRITERION] : null;

              var unmappedResultSortCriteria = self._getUnmappedSortCriteria(resultSortCriteria);

              var unmappedResultFilterCriterion = self._getUnmappedFilterCriterion(resultFilterCriterion);

              var resultParams = new self.FetchByOffsetParameters(self, self[ListDataProviderView._OFFSET], null, size, unmappedResultSortCriteria, unmappedResultFilterCriterion); // if the dataprovider supports fetchByOffset then we use that to do an offset based fetch

              if (cachedData[ListDataProviderView._DONE]) {
                return Promise.resolve(new self.AsyncIteratorReturnResult(self, new self.FetchListResult(self, resultParams, data, metadata)));
              }

              return Promise.resolve(new self.AsyncIteratorYieldResult(self, new self.FetchListResult(self, resultParams, data, metadata)));
            });
          };
        }(cachedData), params));
      } else {
        var updatedParams = new this.FetchListParameters(this, params, size, mappedSortCriteria, mappedFilterCriterion, fetchAttributes);

        var cachedAsyncIterator = this.dataProvider[ListDataProviderView._FETCHFIRST](updatedParams)[Symbol.asyncIterator]();

        return new this.AsyncIterable(this, new this.AsyncIterator(this, function (cachedData, cachedAsyncIterator) {
          return function () {
            return cachedAsyncIterator.next().then(function (result) {
              var data = result[ListDataProviderView._VALUE][ListDataProviderView._DATA];
              var metadata = result[ListDataProviderView._VALUE][ListDataProviderView._METADATA];
              var items = data.map(function (value, index) {
                return new self.Item(self, metadata[index], data[index]);
              });

              if (self._noFilterSupport) {
                self._filterResult(mappedFilterCriterion, items);
              } // apply any mapping defined in the DataMapping parameter


              var mappedResult = self._getMappedItems(items);

              self._cacheResult(cachedData, mappedResult);

              cachedData[ListDataProviderView._DONE] = result[ListDataProviderView._DONE];
              var size = params != null ? params[ListDataProviderView._SIZE] : null;
              var offset = params != null ? params[ListDataProviderView._OFFSET] : null;
              var resultFetchParams = result[ListDataProviderView._VALUE][ListDataProviderView._FETCHPARAMETERS];
              var resultSortCriteria = resultFetchParams != null ? resultFetchParams[ListDataProviderView._SORTCRITERIA] : null;
              var resultFilterCriterion = resultFetchParams != null ? resultFetchParams[ListDataProviderView._FILTERCRITERION] : null;

              var unmappedResultSortCriteria = self._getUnmappedSortCriteria(resultSortCriteria);

              var unmappedResultFilterCriterion = self._getUnmappedFilterCriterion(resultFilterCriterion);

              var resultParams = new self.FetchListParameters(self, params, size, unmappedResultSortCriteria, unmappedResultFilterCriterion);
              return self._fetchUntilKey(resultParams, self[ListDataProviderView._FROM], cachedData, cachedAsyncIterator).then(function () {
                return self._fetchUntilOffset(resultParams, self[ListDataProviderView._OFFSET] + cachedData[ListDataProviderView._STARTINDEX], data.length, cachedData, cachedAsyncIterator);
              });
            });
          };
        }(cachedData, cachedAsyncIterator), params));
      }
    }
  }, {
    key: "getCapability",
    value: function getCapability(capabilityName) {
      return this.dataProvider.getCapability(capabilityName);
    }
  }, {
    key: "getTotalSize",
    value: function getTotalSize() {
      return this.dataProvider.getTotalSize();
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this.dataProvider.isEmpty();
    }
    /**
     * Fetches the next block
     */

  }, {
    key: "_fetchNextSet",
    value: function _fetchNextSet(params, dataProviderAsyncIterator, resultMap) {
      var self = this;
      return dataProviderAsyncIterator.next().then(function (result) {
        var value = result[ListDataProviderView._VALUE];
        var data = value[ListDataProviderView._DATA];
        var metadata = value[ListDataProviderView._METADATA];
        var keys = metadata.map(function (metadata) {
          return metadata[ListDataProviderView._KEY];
        });
        var foundAllKeys = true;

        params[ListDataProviderView._KEYS].forEach(function (findKey) {
          if (!resultMap.has(findKey)) {
            keys.map(function (key, index) {
              if (oj.Object.compareValues(key, findKey)) {
                resultMap.set(findKey, new self.Item(self, metadata[index], data[index]));
              }
            });
          }

          if (!resultMap.has(findKey)) {
            foundAllKeys = false;
          }
        });

        if (!foundAllKeys && !result[ListDataProviderView._DONE]) {
          return self._fetchNextSet(params, dataProviderAsyncIterator, resultMap);
        } else {
          return resultMap;
        }
      });
    }
    /**
     * Fetches until we find the key
     */

  }, {
    key: "_fetchUntilKey",
    value: function _fetchUntilKey(params, key, cachedData, cachedAsyncIterator) {
      var self = this;

      if (key != null) {
        // first check if the key is in our cache
        var resultItems = cachedData[ListDataProviderView._ITEMS].filter(function (resultItem) {
          if (oj.KeyUtils.equals(resultItem[ListDataProviderView._METADATA][ListDataProviderView._KEY], key)) {
            return true;
          }
        });

        if (resultItems.length > 0) {
          // if the key is in our cache, then trim the cache so that it starts from the key
          var itemIndex = cachedData[ListDataProviderView._ITEMS].indexOf(resultItems[0]);

          cachedData[ListDataProviderView._ITEMS] = cachedData[ListDataProviderView._ITEMS].slice(itemIndex, cachedData[ListDataProviderView._ITEMS].length);
        } else if (!cachedData[ListDataProviderView._DONE]) {
          // if the key is not in our cache and we are not done then fetch the next block and call _fetchUntilKey again.
          return cachedAsyncIterator.next().then(function (nextResult) {
            var data = nextResult[ListDataProviderView._VALUE][ListDataProviderView._DATA];
            var metadata = nextResult[ListDataProviderView._VALUE][ListDataProviderView._METADATA];
            var items = data.map(function (value, index) {
              return new self.Item(self, metadata[index], data[index]);
            });

            var mappedResult = self._getMappedItems(items);

            self._cacheResult(cachedData, mappedResult);

            cachedData[ListDataProviderView._DONE] = nextResult[ListDataProviderView._DONE];
            return self._fetchUntilKey(nextResult[ListDataProviderView._FETCHPARAMETERS], mappedResult[ListDataProviderView._KEYS], cachedData, cachedAsyncIterator);
          });
        } else {
          // if we are done then this means that the key is not in the entire data set
          cachedData[ListDataProviderView._ITEMS] = [];
        }
      }

      return Promise.resolve(null);
    }
    /**
     * Fetches until we fulfill the offset
     */

  }, {
    key: "_fetchUntilOffset",
    value: function _fetchUntilOffset(params, offset, resultSize, cachedData, cachedAsyncIterator) {
      var self = this;
      var fetchSize = params != null ? params[ListDataProviderView._SIZE] > 0 ? params[ListDataProviderView._SIZE] : resultSize : resultSize;
      offset = offset > 0 ? offset : 0;

      var cachedItems = cachedData[ListDataProviderView._ITEMS].slice(offset, offset + fetchSize);

      if (this._noFilterSupport) {
        var mappedFilterCriterion = this._getMappedFilterCriterion(params[ListDataProviderView._FILTERCRITERION]);

        this._filterResult(mappedFilterCriterion, cachedItems);
      }

      if (cachedItems.length < fetchSize) {
        if (!cachedData[ListDataProviderView._DONE]) {
          return cachedAsyncIterator.next().then(function (nextResult) {
            var data = nextResult[ListDataProviderView._VALUE][ListDataProviderView._DATA];
            var metadata = nextResult[ListDataProviderView._VALUE][ListDataProviderView._METADATA];
            var items = data.map(function (value, index) {
              return new self.Item(self, metadata[index], data[index]);
            });

            if (self._noFilterSupport) {
              var _mappedFilterCriterion = self._getMappedFilterCriterion(params[ListDataProviderView._FILTERCRITERION]);

              self._filterResult(_mappedFilterCriterion, items);
            }

            var mappedResult = self._getMappedItems(items);

            self._cacheResult(cachedData, mappedResult);

            cachedData[ListDataProviderView._DONE] = nextResult[ListDataProviderView._DONE];
            return self._fetchUntilOffset(nextResult[ListDataProviderView._VALUE][ListDataProviderView._FETCHPARAMETERS], offset, data.length, cachedData, cachedAsyncIterator);
          });
        } else {
          cachedData[ListDataProviderView._STARTINDEX] = cachedData[ListDataProviderView._STARTINDEX] + cachedItems.length;
          var data = cachedItems.map(function (item) {
            return item[ListDataProviderView._DATA];
          });
          var metadata = cachedItems.map(function (item) {
            return item[ListDataProviderView._METADATA];
          });
          return Promise.resolve(new self.AsyncIteratorReturnResult(self, new self.FetchListResult(self, params, data, metadata)));
        }
      } else {
        cachedData[ListDataProviderView._STARTINDEX] = cachedData[ListDataProviderView._STARTINDEX] + cachedItems.length;

        var _data = cachedItems.map(function (item) {
          return item[ListDataProviderView._DATA];
        });

        var _metadata = cachedItems.map(function (item) {
          return item[ListDataProviderView._METADATA];
        });

        if (cachedData[ListDataProviderView._DONE]) {
          return Promise.resolve(new self.AsyncIteratorReturnResult(self, new self.FetchListResult(self, params, _data, _metadata)));
        }

        return Promise.resolve(new self.AsyncIteratorYieldResult(self, new self.FetchListResult(self, params, _data, _metadata)));
      }
    }
    /**
     * Cache the data and keys
     */

  }, {
    key: "_cacheResult",
    value: function _cacheResult(cachedData, items) {
      var self = this;
      items.map(function (value) {
        cachedData[ListDataProviderView._ITEMS].push(value);
      });
    }
  }, {
    key: "_filterResult",
    value: function _filterResult(filterCriterion, items) {
      var filter;

      if (filterCriterion) {
        if (!filterCriterion.filter) {
          filterCriterion = __DataProvider.FilterFactory.getFilter({
            filterDef: filterCriterion
          });
        }

        var i = items.length - 1;

        while (i >= 0) {
          if (!filterCriterion.filter(items[i][ListDataProviderView._DATA])) {
            items.splice(i, 1);
          }

          i--;
        }
      }
    }
    /**
     * Apply DataMapping to the items
     */

  }, {
    key: "_getMappedItems",
    value: function _getMappedItems(items) {
      var self = this;

      if (this[ListDataProviderView._DATAMAPPING] != null) {
        var mapFields = this[ListDataProviderView._DATAMAPPING][ListDataProviderView._MAPFIELDS];

        if (mapFields != null) {
          if (items != null && items.length > 0) {
            var mappedItems = new Array();
            mappedItems = items.map(function (value) {
              return mapFields.bind(self)(value);
            });
            return mappedItems;
          }
        }
      }

      return items;
    }
    /**
     * Apply mapping to the filterCriterion
     */

  }, {
    key: "_getMappedFilterCriterion",
    value: function _getMappedFilterCriterion(filterCriterion) {
      if (this[ListDataProviderView._DATAMAPPING] != null) {
        var mappedFilterCriterion = this[ListDataProviderView._DATAMAPPING][ListDataProviderView._MAPFILTERCRITERION];

        if (mappedFilterCriterion != null) {
          if (filterCriterion != null) {
            return mappedFilterCriterion(filterCriterion);
          }
        }
      }

      return filterCriterion;
    }
    /**
     * Apply mapping to the sortCriteria
     */

  }, {
    key: "_getMappedSortCriteria",
    value: function _getMappedSortCriteria(sortCriteria) {
      if (this[ListDataProviderView._DATAMAPPING] != null) {
        var mapSortCriteria = this[ListDataProviderView._DATAMAPPING][ListDataProviderView._MAPSORTCRITERIA];

        if (mapSortCriteria != null) {
          if (sortCriteria != null && sortCriteria.length > 0) {
            return mapSortCriteria(sortCriteria);
          }
        }
      }

      return sortCriteria;
    }
    /**
     * Unmapping the sortCriteria
     */

  }, {
    key: "_getUnmappedSortCriteria",
    value: function _getUnmappedSortCriteria(sortCriteria) {
      if (this[ListDataProviderView._DATAMAPPING] != null) {
        var unmapSortCriteria = this[ListDataProviderView._DATAMAPPING][ListDataProviderView._UNMAPSORTCRITERIA];

        if (unmapSortCriteria != null) {
          if (sortCriteria != null && sortCriteria.length > 0) {
            return unmapSortCriteria(sortCriteria);
          }
        }
      }

      return sortCriteria;
    }
    /**
     * Unmapping the FilterCriterion
     */

  }, {
    key: "_getUnmappedFilterCriterion",
    value: function _getUnmappedFilterCriterion(filter) {
      if (this[ListDataProviderView._DATAMAPPING] != null) {
        var unmapFilterCriterion = this[ListDataProviderView._DATAMAPPING][ListDataProviderView._UNMAPFILTERCRITERION];

        if (unmapFilterCriterion != null) {
          if (filter != null) {
            return unmapFilterCriterion(filter);
          }
        }
      }

      return filter;
    }
    /**
     * Add event listeners
     */

  }, {
    key: "_addEventListeners",
    value: function _addEventListeners(dataprovider) {
      var self = this;

      dataprovider[ListDataProviderView._ADDEVENTLISTENER](ListDataProviderView._REFRESH, function (event) {
        self.dispatchEvent(event);
      });

      dataprovider[ListDataProviderView._ADDEVENTLISTENER](ListDataProviderView._MUTATE, function (event) {
        self.dispatchEvent(event);
      });
    }
  }]);

  return ListDataProviderView;
}();

ListDataProviderView._KEY = 'key';
ListDataProviderView._KEYS = 'keys';
ListDataProviderView._DATA = 'data';
ListDataProviderView._STARTINDEX = 'startIndex';
ListDataProviderView._SORT = 'sort';
ListDataProviderView._SORTCRITERIA = 'sortCriteria';
ListDataProviderView._FILTERCRITERION = 'filterCriterion';
ListDataProviderView._METADATA = 'metadata';
ListDataProviderView._ITEMS = 'items';
ListDataProviderView._FROM = 'from';
ListDataProviderView._OFFSET = 'offset';
ListDataProviderView._REFRESH = 'refresh';
ListDataProviderView._MUTATE = 'mutate';
ListDataProviderView._SIZE = 'size';
ListDataProviderView._FETCHPARAMETERS = 'fetchParameters';
ListDataProviderView._VALUE = 'value';
ListDataProviderView._DONE = 'done';
ListDataProviderView._DATAMAPPING = 'dataMapping';
ListDataProviderView._MAPFIELDS = 'mapFields';
ListDataProviderView._MAPSORTCRITERIA = 'mapSortCriteria';
ListDataProviderView._MAPFILTERCRITERION = 'mapFilterCriterion';
ListDataProviderView._UNMAPSORTCRITERIA = 'unmapSortCriteria';
ListDataProviderView._UNMAPFILTERCRITERION = 'unmapFilterCriterion';
ListDataProviderView._RESULTS = 'results';
ListDataProviderView._CONTAINSPARAMETERS = 'containsParameters';
ListDataProviderView._DEFAULT_SIZE = 25;
ListDataProviderView._CONTAINSKEYS = 'containsKeys';
ListDataProviderView._FETCHBYKEYS = 'fetchByKeys';
ListDataProviderView._FETCHBYOFFSET = 'fetchByOffset';
ListDataProviderView._FETCHFIRST = 'fetchFirst';
ListDataProviderView._ADDEVENTLISTENER = 'addEventListener';
ListDataProviderView._FETCHATTRIBUTES = 'attributes';
oj['ListDataProviderView'] = ListDataProviderView;
oj.ListDataProviderView = ListDataProviderView;
oj.EventTargetMixin.applyMixin(ListDataProviderView);



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 *
 * @since 4.1.0
 * @export
 * @final
 * @class ListDataProviderView
 * @ojtsmodule
 * @implements DataProvider
 * @classdesc Provides list based optimizations for DataProvider and adds some support for providing state
 * for certain operations. e.g supports {@link DataProvider#fetchFirst} starting at arbitrary key or index offset, sortCriteria,
 * and field mapping. Please see the select demos for examples of DataMapping [Select]{@link oj.ojSelect}
 * @param {DataProvider} dataProvider the DataProvider.
 * @param {Object=} options Options for the ListDataProviderView
 * @param {any=} options.from key to start fetching from. This will be applied first before offset is applied.
 * @param {number=} options.offset offset to start fetching from.
 * @param {Array.<SortCriterion>=} options.sortCriteria {@link SortCriterion} to apply to the data.
 * @param {DataMapping=} options.dataMapping mapping to apply to the data.
 * @param {Array<string | FetchAttribute>=} options.attributes fetch attributes to apply
 * @param {DataFilter.Filter=} options.filterCriterion filter criterion to apply. If the DataProvider does not support filtering then
 *        ListDataProviderView will do local filtering of the data.
 * @ojsignature [{target: "Type",
 *               value: "class ListDataProviderView<K, D, Kin, Din> implements DataProvider<K, D>",
 *               genericParameters: [{"name": "K", "description": "Type of output key"}, {"name": "D", "description": "Type of output data"},
 *                    {"name": "Kin", "description": "Type of input key"}, {"name": "Din", "description": "Type of input data"}]},
 *               {target: "Type",
 *               value: "DataProvider<K, D>",
 *               for: "dataProvider"},
 *               {target: "Type",
 *               value: "Kin",
 *               for: "options.from"},
 *               {target: "Type",
 *               value: "Array<SortCriterion<D>>",
 *               for: "options.sortCriteria"},
 *               {target: "Type",
 *               value: "DataMapping<K, D, Kin, Din>",
 *               for: "options.dataMapping"},
 *               {target: "Type",
 *               value: "Array<string | FetchAttribute>",
 *               for: "options.attributes"},
 *               {target: "Type",
 *               value: "DataFilter.Filter<D>",
 *               for: "options.filterCriterion"}]
 * @ojtsimport {module: "ojdataprovider", type: "AMD", imported: ["DataProvider", "SortCriterion", "FetchByKeysParameters",
 *   "ContainsKeysResults","FetchByKeysResults","FetchByOffsetParameters","FetchByOffsetResults", "DataMapping",
 *   "FetchListResult","FetchListParameters", "FetchAttribute", "DataFilter"]}
 */

/**
 * @inheritdoc
 * @memberof ListDataProviderView
 * @instance
 * @method
 * @name containsKeys
 */

/**
 * @inheritdoc
 * @memberof ListDataProviderView
 * @instance
 * @method
 * @name fetchFirst
 */

/**
 * @inheritdoc
 * @memberof ListDataProviderView
 * @instance
 * @method
 * @name fetchByKeys
 */

/**
 * @inheritdoc
 * @memberof ListDataProviderView
 * @instance
 * @method
 * @name fetchByOffset
 */

/**
 * @inheritdoc
 * @memberof ListDataProviderView
 * @instance
 * @method
 * @name getCapability
 */

/**
 * @inheritdoc
 * @memberof ListDataProviderView
 * @instance
 * @method
 * @name getTotalSize
 */

/**
 * @inheritdoc
 * @memberof ListDataProviderView
 * @instance
 * @method
 * @name isEmpty
 */

/**
 * @inheritdoc
 * @memberof ListDataProviderView
 * @instance
 * @method
 * @name addEventListener
 */

/**
 * @inheritdoc
 * @memberof ListDataProviderView
 * @instance
 * @method
 * @name removeEventListener
 */

/**
 * @inheritdoc
 * @memberof ListDataProviderView
 * @instance
 * @method
 * @name dispatchEvent
 */

/**
 * Optional key to start fetching from. Used to set on the ListDataProviderView instance instead of through the constructor.
 *
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof ListDataProviderView
 * @instance
 * @name from
 * @type {any}
 * @ojsignature {target: "Type",
 *               value: "?Kin"}
 * @ojtsexample <caption>set the key to start fetching from</caption>
 * dataprovider.from = '1234';
 */

/**
 * Optional offset to start fetching from. Used to set on the ListDataProviderView instance instead of through the constructor.. Should be greater than or equal to zero.
 * If a negative offset is used then it will be treated as zero.
 *
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof ListDataProviderView
 * @instance
 * @name offset
 * @type {number=}
 * @ojsignature {target: "Type",
 *               value: "?number"}
 * @ojtsexample <caption>set the offset to start fetching from</caption>
 * dataprovider.offset = 5;
 */

/**
 * Optional sortCriteria to apply. Used to set on the ListDataProviderView instance instead of through the constructor.
 *
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof ListDataProviderView
 * @instance
 * @name sortCriteria
 * @type {Array.<SortCriterion>=}
 * @ojsignature {target: "Type",
 *               value: "?Array<SortCriterion<D>>"}
 * @ojtsexample <caption>set the sortCriteria for fetching</caption>
 * dataprovider.sortCriteria = [{attribute: 'DepartmentName', direction: 'ascending'}];
 */

/**
 * Optional dataMapping to apply. Used to set on the ListDataProviderView instance instead of through the constructor.
 *
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof ListDataProviderView
 * @instance
 * @name dataMapping
 * @type {DataMapping=}
 * @ojsignature {target: "Type",
 *               value: "?DataMapping<K, D, Kin, Din>"}
 * @ojtsexample <caption>set the data mapping for fetching</caption>
 * dataprovider.dataMapping = function (item) {
 *   let data = item.data;
 *   let mappedItem = {};
 *   mappedItem.data = {};
 *   mappedItem.data.label = data.name;
 *   mappedItem.data.value = data.id;
 *   mappedItem.metadata = { key: data.id };
 *   return mappedItem;
 * };
 */

/**
 * Optional fetch attributes to apply. Used to set on the ListDataProviderView instance instead of through the constructor.
 *
 *
 * @since 4.1.0
 * @export
 * @expose
 * @memberof ListDataProviderView
 * @instance
 * @name attributes
 * @type {Array<string | FetchAttribute>=}
 * @ojsignature {target: "Type",
 *               value: "?Array<string | FetchAttribute>"}
 * @ojtsexample <caption>set the attribute filter for fetching</caption>
 * dataprovider.attributes = ['!lastName', '@default']; // all attributes except lastName
 */

/**
 * Optional filter criterion to apply. Used to set on the ListDataProviderView instance instead of through the constructor.
 *
 *
 * @since 7.0.0
 * @export
 * @expose
 * @memberof ListDataProviderView
 * @instance
 * @name filterCriterion
 * @type {DataFilter.Filter=}
 * @ojsignature {target: "Type",
 *               value: "?DataFilter.Filter<D>"}
 * @ojtsexample <caption>set the filter criterion for fetching</caption>
 * let filterDef = {op: '$or', criteria: [{op: '$eq', value: {name: 'Bob'}}, {op: '$gt', value: {level: 'Low'}}]};
 * dataprovider.filterCriterion = FilterFactory.getFilter(filterDef); // create a standard filter using the filterFactory.
 */

/**
 * End of jsdoc
 */

  return ListDataProviderView;
});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojoptgroup',['ojs/ojcore', 'jquery', 'ojs/ojcomponentcore'], 
function(oj, $)
{
  "use strict";
//%COMPONENT_METADATA%
var __oj_optgroup_metadata = 
{
  "properties": {
    "disabled": {
      "type": "boolean",
      "value": false
    },
    "label": {
      "type": "string"
    }
  },
  "methods": {
    "setProperty": {},
    "getProperty": {},
    "refresh": {},
    "setProperties": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "extension": {}
};


/**
 * @constructor
 * @private
 */
// eslint-disable-next-line no-unused-vars
function ojOptGroup(context) {
  this.updateDOM = function () {
    var customRenderer = context.element.customOptgroupRenderer;

    if (customRenderer && typeof customRenderer === 'function') {
      customRenderer(context.element);
    }
  };
}



/**
 * @ojcomponent oj.ojOptgroup
 * @since 4.0.0
 * @ojdisplayname Option Group
 * @ojshortdesc An optgroup supports grouping of child oj-option elements.
 * @ojrole option
 *
 * @ojsignature class ojOptgroup extends JetElement<ojOptgroupSettableProperties>
 *
 * @ojpropertylayout {propertyGroup: "common", items: ["label", "disabled"]}
 *
 * @classdesc
 * <h3 id="optgroupOverview-section">
 *   JET Optgroup
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#optgroupOverview-section"></a>
 * </h3>
 * <p>The oj-optgroup element is used to group [oj-option]{@link oj.ojOption} elements.</p>
 * <p>For example:
 * <pre class="prettyprint">
 * <code>
 * &lt;oj-select-one>
 *   &lt;oj-optgroup label="group1 label">
 *     &lt;oj-option value="option 1">option 1&lt;/oj-option>
 *     &lt;oj-option value="option 2">option 2&lt;/oj-option>
 *   &lt;/oj-optgroup>
 *   &lt;oj-optgroup label="group2 label">
 *     &lt;oj-option value="option 3">option 3&lt;/oj-option>
 *     &lt;oj-option value="option 4">option 4&lt;/oj-option>
 *   &lt;/oj-optgroup>
 * &lt;/oj-select-one>
 * </code></pre>
 */

/**
 * <p>Disables the oj-optgroup if set to <code class="prettyprint">true</code>.
 *
 * @name disabled
 * @ojshortdesc Disables the group if set to true.
 * @expose
 * @memberof oj.ojOptgroup
 * @instance
 * @type {boolean}
 * @default false
 *
 * @example <caption>Initialize the oj-optgroup with the <code class="prettyprint">disabled</code> attribute specified:</caption>
 * &lt;oj-optgroup disabled="[[isDisabled]]">&lt;/oj-optgroup>
 *
 * @example <caption>Get or set the <code class="prettyprint">disabled</code> property after initialization:</caption>
 * // getter
 * var disabledValue = myOptgroup.disabled;
 *
 * // setter
 * myOptgroup.disabled = true;
 */

/**
 * <p>Specifies the oj-optgroup's label.
 *
 * @name label
 * @ojshortdesc The group label.
 * @ojrequired
 * @ojtranslatable
 * @expose
 * @memberof oj.ojOptgroup
 * @instance
 * @type {string}
 *
 * @example <caption>Initialize the oj-optgroup with the <code class="prettyprint">label</code> attribute specified:</caption>
 * &lt;oj-optgroup label="group1 label">&lt;/oj-optgroup>
 *
 * @example <caption>Get or set the <code class="prettyprint">label</code> property after initialization:</caption>
 * // getter
 * var labelValue = myOptgroup.label;
 *
 * // setter
 * myOptgroup.label = 'Group 1';
 */

/**
 * <p>The oj-optgroup element accepts <code class="prettyprint">oj-option</code> elements as children. See the [oj-option]{@link oj.ojOption} documentation for details about
 * accepted children and slots.</p>
 *
 * @ojchild Default
 * @memberof oj.ojOptgroup
 * @ojshortdesc The oj-optgroup element accepts oj-option elements as children.
 *
 * @example <caption>Initialize the oj-optgroup with child content specified:</caption>
 * &lt;oj-optgroup>
 *   &lt;oj-option value="option1">Option label&lt;/oj-option>
 * &lt;/oj-optgroup>
 */

/**
 * Sets a property or a single subproperty for complex properties and notifies the component
 * of the change, triggering a [property]Changed event.
 *
 * @function setProperty
 * @ojshortdesc Sets a property or a single subproperty for complex properties and notifies the component of the change, triggering a corresponding event.
 * @param {string} property - The property name to set. Supports dot notation for subproperty access.
 * @param {any} value - The new value to set the property to.
 * @return {void}
 * @expose
 * @memberof oj.ojOptgroup
 * @instance
 *
 * @example <caption>Set a single subproperty of a complex property:</caption>
 * myComponent.setProperty('complexProperty.subProperty1.subProperty2', "someValue");
 */

/**
 * Retrieves a value for a property or a single subproperty for complex properties.
 * @function getProperty
 * @param {string} property - The property name to get. Supports dot notation for subproperty access.
 * @return {any}
 * @expose
 * @memberof oj.ojOptgroup
 * @instance
 *
 * @example <caption>Get a single subproperty of a complex property:</caption>
 * var subpropValue = myComponent.getProperty('complexProperty.subProperty1.subProperty2');
 */

/**
 * Refreshes the visual state of the component.
 *
 * @function refresh
 * @return {void}
 * @expose
 * @memberof oj.ojOptgroup
 * @instance
 */

/**
 * Performs a batch set of properties.
 * @function setProperties
 * @param {Object} properties - An object containing the property and value pairs to set.
 * @return {void}
 * @expose
 * @memberof oj.ojOptgroup
 * @instance
 *
 * @example <caption>Set a batch of properties:</caption>
 * myComponent.setProperties({"prop1": "value1", "prop2.subprop": "value2", "prop3": "value3"});
 */



/* global ojOptGroup:false */

/* global __oj_optgroup_metadata:false */

/**
 * @protected
 * @ignore
 */
(function () {
  // not documented
  __oj_optgroup_metadata.properties.customOptgroupRenderer = {};
  __oj_optgroup_metadata.extension._CONSTRUCTOR = ojOptGroup;
  oj.CustomElementBridge.register('oj-optgroup', {
    metadata: __oj_optgroup_metadata
  });
})();

});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojtreedataproviderview',['ojs/ojcore', 'jquery', 'ojs/ojlistdataproviderview', 'ojs/ojcomponentcore', 'ojs/ojeventtarget', 'ojs/ojdataprovider'], function(oj, $, ListDataProviderView)
{
  "use strict";
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }



/**
 * Class which provides list based optimizations
 */
var TreeDataProviderView = /*#__PURE__*/function () {
  function TreeDataProviderView(dataProvider, options) {
    _classCallCheck(this, TreeDataProviderView);

    this.dataProvider = dataProvider;
    this.options = options;
    this._listDataProviderView = new ListDataProviderView(dataProvider, options);
  }
  /*
   * Get the data provider for the children of the node identified by parentKey.
   * This should return null for node that cannot have children.
   * This should return a TreeDataProvider for node that can (but doesn't have to) have children.
   */


  _createClass(TreeDataProviderView, [{
    key: "getChildDataProvider",
    value: function getChildDataProvider(parentKey, options) {
      var childDataProvider = this.dataProvider.getChildDataProvider(parentKey, options);

      if (childDataProvider) {
        return new TreeDataProviderView(childDataProvider, this.options);
      }

      return null;
    }
  }, {
    key: "containsKeys",
    value: function containsKeys(params) {
      return this._listDataProviderView.containsKeys(params);
    }
  }, {
    key: "fetchByKeys",
    value: function fetchByKeys(params) {
      return this._listDataProviderView.fetchByKeys(params);
    }
  }, {
    key: "fetchByOffset",
    value: function fetchByOffset(params) {
      return this._listDataProviderView.fetchByOffset(params);
    }
  }, {
    key: "fetchFirst",
    value: function fetchFirst(params) {
      return this._listDataProviderView.fetchFirst(params);
    }
  }, {
    key: "getCapability",
    value: function getCapability(capabilityName) {
      return this._listDataProviderView.getCapability(capabilityName);
    }
  }, {
    key: "getTotalSize",
    value: function getTotalSize() {
      return this._listDataProviderView.getTotalSize();
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this._listDataProviderView.isEmpty();
    }
  }, {
    key: "addEventListener",
    value: function addEventListener(eventType, listener) {
      this._listDataProviderView.addEventListener(eventType, listener);
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(eventType, listener) {
      this._listDataProviderView.removeEventListener(eventType, listener);
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(evt) {
      return this._listDataProviderView.dispatchEvent(evt);
    }
  }]);

  return TreeDataProviderView;
}();

oj['TreeDataProviderView'] = TreeDataProviderView;
oj.TreeDataProviderView = TreeDataProviderView;



/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/* jslint browser: true,devel:true*/

/**
 *
 * @since 6.2.0
 * @final
 * @export
 * @class TreeDataProviderView
 * @ojtsmodule
 * @implements TreeDataProvider
 * @classdesc Provides optimizations for TreeDataProvider. Supports field mapping. Please see the select demos for examples of DataMapping [Select]{@link oj.ojSelect}
 * @param {DataProvider} dataProvider the DataProvider.
 * @param {Object=} options Options for the TreeDataProviderView
 * @param {DataMapping=} options.dataMapping mapping to apply to the data.
 * @ojsignature [{target: "Type",
 *               value: "class TreeDataProviderView<K, D, Kin, Din> implements TreeDataProvider<K, D>",
 *               genericParameters: [{"name": "K", "description": "Type of output key"}, {"name": "D", "description": "Type of output data"},
 *                    {"name": "Kin", "description": "Type of input key"}, {"name": "Din", "description": "Type of input data"}]},
 *               {target: "Type",
 *               value: "TreeDataProvider<K, D>",
 *               for: "dataProvider"},
 *               {target: "Type",
 *               value: "DataMapping<K, D, Kin, Din>",
 *               for: "options.dataMapping"}]
 * @ojtsimport {module: "ojdataprovider", type: "AMD", imported: ["DataProvider", "SortCriterion", "FetchByKeysParameters",
 *   "ContainsKeysResults","FetchByKeysResults","FetchByOffsetParameters","FetchByOffsetResults", "DataMapping",
 *   "FetchListResult","FetchListParameters", "FetchAttribute"]}
 * @ojtsimport {module: "ojtreedataprovider", type: "AMD", importName: "TreeDataProvider"}
 */

/**
 * Optional dataMapping to apply
 *
 *
 * @since 6.2.0
 * @export
 * @expose
 * @memberof TreeDataProviderView
 * @instance
 * @name dataMapping
 * @ojsignature {target: "Type",
 *               value: "?DataMapping<K, D, Kin, Din>"}
 */

/**
 * @inheritdoc
 * @memberof TreeDataProviderView
 * @instance
 * @method
 * @name getChildDataProvider
 */

/**
 * @inheritdoc
 * @memberof TreeDataProviderView
 * @instance
 * @method
 * @name containsKeys
 */

/**
 * @inheritdoc
 * @memberof TreeDataProviderView
 * @instance
 * @method
 * @name fetchFirst
 */

/**
 * @inheritdoc
 * @memberof TreeDataProviderView
 * @instance
 * @method
 * @name fetchByKeys
 */

/**
 * @inheritdoc
 * @memberof TreeDataProviderView
 * @instance
 * @method
 * @name fetchByOffset
 */

/**
 * @inheritdoc
 * @memberof TreeDataProviderView
 * @instance
 * @method
 * @name getCapability
 */

/**
 * @inheritdoc
 * @memberof TreeDataProviderView
 * @instance
 * @method
 * @name getTotalSize
 */

/**
 * @inheritdoc
 * @memberof TreeDataProviderView
 * @instance
 * @method
 * @name isEmpty
 */

/**
 * @inheritdoc
 * @memberof TreeDataProviderView
 * @instance
 * @method
 * @name addEventListener
 */

/**
 * @inheritdoc
 * @memberof TreeDataProviderView
 * @instance
 * @method
 * @name removeEventListener
 */

/**
 * @inheritdoc
 * @memberof TreeDataProviderView
 * @instance
 * @method
 * @name dispatchEvent
 */

/**
 * End of jsdoc
 */

  return TreeDataProviderView;
});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojanimation',['ojs/ojcore', 'jquery', 'ojs/ojthemeutils', 'ojs/ojlogger', 'ojs/ojcomponentcore'], function(oj, $, ThemeUtils, Logger)
{
  "use strict";
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }



/* global Promise:false, Logger:false, ThemeUtils:false */

/**
 * Utility methods for animating elements.
 *
 * <h3 id="custom-animation-section">
 *   Customizing and Disabling Animation
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#custom-animation-section"></a>
 * </h3>
 *
 * Default animations can be customized or disabled at several levels with varying degrees of control:
 * <ol>
 *   <li>For all JET components.</li>
 *   <li>For all instances of a JET component.</li>
 *   <li>For one instance of a JET component.</li>
 * </ol>
 *
 * <h4>1. For all JET components</h4>
 *
 * <p>There are several theme variables that control the speed of animations in JET.  Applications can change their values
 * to speed up or slow down animations for all components, or to disable animations altogether by setting them to 0:</p>
 * <pre class="prettyprint"><code>$animationDurationShort: .25s !default;
 * $animationDurationMedium: .4s !default;
 * $animationDurationLong: .5s !default;
 * </code></pre>
 * <p>Note that setting them to 0 does not make the actions that invoke animations synchronous.  For example, opening a dialog is an asynchronous
 * action.  By setting the animation duration to 0 simply makes the dialog appear to open immediately.  Events related to the dialog opening
 * are still fired asynchronously, though with a much shorter delay.</p>
 *
 * <h4>2. For All Instances of a JET Component.</h4>
 *
 * <p>Default animations for JET components are defined by component-specific theme variables.  Changing the values of the theme variables for a particular component
 * will affect the default animations for all instances of that component.  These theme variables are listed in the API documentation
 * for the <code class="prettyprint">ojAnimateStart</code> event of each component.</p>
 *
 * <h4>3. For One Instance of a JET Component</h4>
 *
 * <p>Applications can customize animations triggered by actions in some components by listening for <code class="prettyprint">ojAnimateStart/ojAnimateEnd</code>
 *    events and override action specific animations.  See the documentation of individual components for support details of <code
 *    class="prettyprint">ojAnimateStart/ojAnimateEnd</code> events and the associated actions.</p>
 * <p>To customize an animation, applications first listen to <code class="prettyprint">ojAnimateStart</code> event and cancel the default animation.  Then
 *    specify the new animation in one of several ways:</p>
 * <ul>
 *   <li>Call one of the animation effect methods in oj.AnimationUtils.</li>
 *   <li>Call a 3rd-party animation function with a Javascript API, such as GreenSock, Velocity.js, etc.</li>
 *   <li>Define action-specific CSS style classes on the animated item.  When an action triggers animation, a marker class of the form "oj-animate-&lt;action&gt;"
 *       (e.g. "oj-animate-open") is added to the animated element.  After a slight delay, a second marker class of the form "oj-animate-&lt;action&gt;-active"
 *       (e.g. "oj-animate-open-active") is added.  This allows application to define CSS transition on the element.</li>
 * </ul>
 *
 * <h4>Examples</h4>
 * <br>
 * <i>Disable a default "open" animation:</i>
 * <pre class="prettyprint"><code>
 * myComponent.addEventListener( "ojAnimateStart", function( event ) {
 *   if (event.detail.action == "open") {
 *     event.preventDefault();
 *     event.detail.endCallback();
 *   }
 * });
 * </code></pre>
 * <br>
 * <i>Customize a default "open" animation with oj.AnimationUtils method:</i>
 * <pre class="prettyprint"><code>
 * myComponent.addEventListener( "ojAnimateStart", function( event ) {
 *   if (event.detail.action == "open") {
 *     event.preventDefault();
 *     oj.AnimationUtils.slideIn(event.detail.element).then(event.detail.endCallback);
 *   }
 * });
 * </code></pre>
 * <br>
 * <i>Customize a default "update" animation with CSS style classes:</i>
 * <pre class="prettyprint"><code>
 * // Cancel the default animation in the event listener
 * myComponent.addEventListener( "ojAnimateStart", function( event ) {
 *   if (event.detail.action == "update") {
 *     event.preventDefault();
 *     event.detail.endCallback();
 *   }
 * });
 *
 * </code></pre>
 *
 * <pre class="prettyprint"><code>
 * /* Define new animation in CSS
 *    Different selectors may be needed to target the CSS correctly *&#47;
 *
 * /* State to animate from is marked by oj-animate-&lt;action&gt; class *&#47;
 * .selector .oj-animate-update {
 *   color: red;
 * }
 *
 * /* State to animate to is marked by oj-animate-&lt;action&gt; and oj-animate-&lt;action&gt;-active classes *&#47;
 * .selector .oj-animate-update.oj-animate-update-active {
 *   transition: color 1s;
 *   color: black;
 * }
 * </code></pre>
 *
 * <h3 id="busy-state-section">
 *   Adding Busy State
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#busy-state-section"></a>
 * </h3>
 *
 * <p>Animations are asynchronous by nature.  Sometimes applications may need to wait for an animation to end before
 *    proceeding with other operations.  All the effect methods in oj.AnimationUtils return promises that are
 *    resolved when the animations end.</p>
 * <p>In cases where applications use the {@link oj.BusyContext} class to track the busy state of components or pages, it is
 *    up to the callers of the effect methods to add busy state to the appropriate context, which may or may not
 *    be the context that contains the element being animated.</p>
 *
 * <h4>Examples</h4>
 * <br>
 * <i>Add a busy state while an animation is in progress:</i>
 * <pre class="prettyprint"><code>
 * // Context node is usually the animated element but can also be a node for any
 * // context that wants to wait for the animation to end.
 * var contextNode = element;
 * var busyContext = oj.Context.getContext(contextNode).getBusyContext();
 * var resolveFunc = busyContext.addBusyState({"description": "Animation in progress"});
 * oj.AnimationUtils.slideOut(element).then(resolveFunc);
 * </code></pre>
 *
 * @namespace
 * @ojtsmodule
 * @since 2.1
 * @export
 */
oj.AnimationUtils = {}; // this is the variable name that the AMD module will return in the require callback (used in a no-require environment)
// eslint-disable-next-line no-unused-vars

var AnimationUtils = oj.AnimationUtils; // Return a platform-dependent property or event name from a base name

oj.AnimationUtils._getName = function (element, baseName) {
  if (!oj.AnimationUtils._nameMap) {
    oj.AnimationUtils._nameMap = {};
    var nameMap = oj.AnimationUtils._nameMap;
    var style = element.style; // Property names

    nameMap.backfaceVisibility = style.webkitBackfaceVisibility !== undefined ? 'webkitBackfaceVisibility' : 'backfaceVisibility';
    nameMap.transform = style.webkitTransform !== undefined ? 'webkitTransform' : 'transform';
    nameMap.transformOrigin = style.webkitTransformOrigin !== undefined ? 'webkitTransformOrigin' : 'transformOrigin';
    nameMap.transition = style.webkitTransition !== undefined ? 'webkitTransition' : 'transition'; // Event names

    nameMap.transitionend = style.webkitTransition !== undefined ? 'webkitTransitionEnd' : 'transitionend';
  }

  var mappedName = oj.AnimationUtils._nameMap[baseName];
  return mappedName || baseName;
};

oj.AnimationUtils._getElementStyle = function (element, baseName) {
  return element.style[oj.AnimationUtils._getName(element, baseName)];
};

oj.AnimationUtils._setElementStyle = function (element, baseName, value) {
  // eslint-disable-next-line no-param-reassign
  element.style[oj.AnimationUtils._getName(element, baseName)] = value;
};
/**
 * Main utility function for starting a css transition on an element.<br>
 * Currently this function assumes the following:<br>
 * 1. If multiple properties are animated, they all use the same delay and duration.<br>
 * All css property names should be specified in camel case.
 * @param {Element} element  the HTML element to animate
 * @param {Object} fromState  the css class and properties for setting up the starting state
 * @param {Object} toState  the css class and properties for setting up the ending state
 * @param {Object} options  the common options for the css transition or animation.  This
 *                          include 'delay', 'duration', 'timingFunction', and 'persist'.
 * @param {Array} transProps  an array of css properties being transitioned.
 * @param {Array=} persistProps  an array of css properties to persist if the persist option is set.
 *                               If this is omitted, it will be set to transProps.
 * @return {Promise|IThenable} a promise that will be resolved when the animation ends
 * @private
 */


oj.AnimationUtils._animate = function (element, fromState, toState, options, transProps, persistProps) {
  var propArray = [].concat(transProps); // eslint-disable-next-line no-unused-vars

  var doAnimate = function doAnimate(resolve, reject) {
    var endListener = function endListener(event) {
      // event.propertyName is the hyphenated name.  Entries in propArray is the
      // camel-case name without prefix.  So we drop any prefix and convert
      // event.propertyName to camel-case before finding it in propArray.
      var basePropName = event.propertyName.indexOf('-webkit-') === 0 ? event.propertyName.substr(8) : event.propertyName;
      basePropName = oj.AnimationUtils._getCamelCasePropName(basePropName);
      var idx = propArray.indexOf(basePropName);

      if (idx > -1) {
        if (propArray.length > 1) {
          propArray.splice(idx, 1);
        } else {
          resolvePromise();
        }
      }
    };

    var requestId = 0;
    var promiseResolved = false;

    function resolvePromise() {
      if (!promiseResolved) {
        if (requestId) {
          window.cancelAnimationFrame(requestId);
          requestId = 0;
        }

        element.removeEventListener(oj.AnimationUtils._getName(element, 'transitionend'), endListener);

        if (resolve) {
          resolve(true);
        }

        promiseResolved = true;
      }
    } // For css transition, specify the transition value when applying the toState
    // since we don't want to trigger the transition prematurely.


    if (toState == null) {
      // eslint-disable-next-line no-param-reassign
      toState = {};
    }

    if (toState.css == null) {
      // eslint-disable-next-line no-param-reassign
      toState.css = {};
    } // eslint-disable-next-line no-param-reassign


    toState.css.transition = oj.AnimationUtils._createTransitionValue(element, transProps, options); // Save the orignal style so that we can restore it later if needed

    var effectCount = oj.AnimationUtils._saveStyle(element, fromState, toState, options, persistProps || transProps);

    oj.AnimationUtils._applyState(element, fromState, effectCount > 1);

    element.addEventListener(oj.AnimationUtils._getName(element, 'transitionend'), endListener);
    var duration = options.duration;
    var delay = options.delay;
    var skipPromise = options._skipPromise;

    function transitionFunc() {
      requestId = 0;

      oj.AnimationUtils._applyState(element, toState, effectCount > 1);
    }

    if (fromState == null) {
      // If there is no fromState, assume that we are transitioning from the
      // current state to a new state, so just apply toState immediately.
      transitionFunc();
    } else {
      if (!options._noReflow) {
        // If the final state is the same as current state,
        // requestAnimationFrame may not trigger a transition.  Need to force
        // a reflow after applying the initial state by getting one of several
        // properties that cause reflow.
        //
        // Assign it to an export object so that Closure compiler will not remove
        // this as dead code
        oj.AnimationUtils._x = element.offsetWidth;
      } // Add the toState after a delay.  This is necessary to trigger css
      // transition.


      requestId = window.requestAnimationFrame(transitionFunc);
    }

    var totalMs = oj.AnimationUtils._getTotalTiming(duration, delay);

    if (!skipPromise) {
      // There are situations in which the transitionend event is never
      // fired (e.g. removing the transiton property or setting the display
      // property to none.)
      // Add a timeout to avoid having unresolved promise.
      setTimeout(resolvePromise, totalMs + 100);
    }
  }; // Special option to skip promise to reduce overhead.  A side effect is that
  // no clean up will be done on the element, which is fine if the element is
  // temporary


  if (options._skipPromise) {
    doAnimate(null, null);
    return null;
  }

  var promise = new Promise(doAnimate);
  return promise.then(function () {
    // Remove any temporary effect class when the promise is fulfilled.
    // Do not remove them in the endListener, since the promise fulfillment
    // callback is not in the same animation frame and occurs later than
    // the endListener.  Because any caller cleanup is done on promise
    // fulfillment, the element may flash if we remove the class too early.
    if (fromState && fromState.addClass) {
      $(element).removeClass(fromState.addClass);
    }

    if (toState && toState.addClass) {
      $(element).removeClass(toState.addClass);
    }

    oj.AnimationUtils._restoreStyle(element);
  });
}; // Save the element style from a property set


oj.AnimationUtils._saveCssValues = function (element, css, savedStyle, persistProps) {
  var cssProps = Object.keys(css);
  var hasOwnProperty = Object.prototype.hasOwnProperty;

  for (var i = 0; i < cssProps.length; i++) {
    var cssProp = cssProps[i];

    if (!hasOwnProperty.call(savedStyle, cssProp) && (!persistProps || persistProps.indexOf(cssProp) === -1)) {
      // eslint-disable-next-line no-param-reassign
      savedStyle[cssProp] = oj.AnimationUtils._getElementStyle(element, cssProp);
    }
  }
}; // Save the original element style before animating it


oj.AnimationUtils._saveStyle = function (element, fromState, toState, options, persistProps) {
  var savedStyle = element._ojSavedStyle || {};
  var fromStateCss = fromState && fromState.css ? fromState.css : {};
  var toStateCss = toState && toState.css ? toState.css : {};
  var _persistProps = persistProps;

  if (!(options && options.persist === 'all')) {
    _persistProps = null;
  }

  oj.AnimationUtils._saveCssValues(element, fromStateCss, savedStyle, _persistProps);

  oj.AnimationUtils._saveCssValues(element, toStateCss, savedStyle, _persistProps); // eslint-disable-next-line no-param-reassign


  element._ojSavedStyle = savedStyle; // Remember how many times this is called to allow composite animation

  var effectCount = element._ojEffectCount || 0;
  effectCount += 1; // eslint-disable-next-line no-param-reassign

  element._ojEffectCount = effectCount;
  return effectCount;
}; // Restore the original element style


oj.AnimationUtils._restoreStyle = function (_element) {
  var element = _element;
  var effectCount = element._ojEffectCount; // In case of composite animation, restore style when the last effect has ended

  if (effectCount > 1) {
    element._ojEffectCount = effectCount - 1;
  } else {
    var savedStyle = element._ojSavedStyle;

    if (savedStyle) {
      var props = Object.keys(savedStyle);

      for (var i = 0; i < props.length; i++) {
        var prop = props[i];

        oj.AnimationUtils._setElementStyle(element, prop, savedStyle[prop]);
      }

      delete element._ojSavedStyle;
      delete element._ojEffectCount;
    }
  }
}; // Get the corresponding camel-cased property name


oj.AnimationUtils._getCamelCasePropName = function (propName) {
  if (propName.indexOf('-') >= 0) {
    var newName = '';
    var strArray = propName.split('-');

    for (var i = 0; i < strArray.length; i++) {
      var subStr = strArray[i];

      if (subStr) {
        if (newName) {
          newName += subStr.charAt(0).toUpperCase() + subStr.slice(1);
        } else {
          // Keep the first segment in lower case
          newName = subStr;
        }
      }
    }

    return newName;
  }

  return propName;
}; // Get the corresponding hyphenated property name


oj.AnimationUtils._getHyphenatedPropName = function (propName) {
  var newName = propName.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();

  if (newName.indexOf('webkit') === 0) {
    newName = '-' + newName;
  }

  return newName;
}; // Concatenate value for style property that allows multiple values


oj.AnimationUtils._concatMultiValue = function (element, state, propName, defaultPrefix, separator) {
  if (state.css[propName]) {
    var currPropValue = oj.AnimationUtils._getElementStyle(element, propName);

    if (currPropValue && currPropValue.indexOf(defaultPrefix) !== 0) {
      // eslint-disable-next-line no-param-reassign
      state.css[propName] = currPropValue + separator + state.css[propName];
    }
  }
};

oj.AnimationUtils._splitTransform = function (transform) {
  var array = [];

  if (transform && transform !== 'none') {
    var _transform = transform;

    var index = _transform.indexOf(')');

    while (index > 0) {
      var funcExpr = _transform.substr(0, index + 1);

      array.push(funcExpr.trim());
      _transform = _transform.slice(index + 1);
      index = _transform.indexOf(')');
    }
  }

  return array;
};

oj.AnimationUtils._getTransformFuncName = function (funcExpr) {
  var index = funcExpr.indexOf('(');

  if (index >= 1) {
    return funcExpr.substr(0, index);
  }

  return funcExpr;
}; // Apply the transform style


oj.AnimationUtils._applyTransform = function (element, newTransform) {
  var oldTransform = oj.AnimationUtils._getElementStyle(element, 'transform');

  var oldTransformArray = oj.AnimationUtils._splitTransform(oldTransform);

  var newTransformArray = oj.AnimationUtils._splitTransform(newTransform);

  var extraTransformArray = [];

  for (var i = 0; i < newTransformArray.length; i++) {
    var funcName = oj.AnimationUtils._getTransformFuncName(newTransformArray[i]);

    var match = false;

    if (funcName) {
      for (var j = 0; j < oldTransformArray.length; j++) {
        // Search for funcName + '(' since some transform functions can be the
        // prefix of other functions such as translate and translateZ.
        if (oldTransformArray[j].indexOf(funcName + '(') === 0) {
          // Replace any matching old transform function with the new one
          oldTransformArray[j] = newTransformArray[i];
          match = true;
        }
      }
    } // Keep track of any new transform function that wasn't specified


    if (!match) {
      extraTransformArray.push(newTransformArray[i]);
    }
  } // Concatenate the updated transform list with newly added list


  oldTransformArray = oldTransformArray.concat(extraTransformArray); // Return the transform list as a string

  return oldTransformArray.join(' ');
};

oj.AnimationUtils._applyState = function (element, state, isComposite) {
  if (state) {
    if (state.css) {
      var transitionPropName = 'transition';
      var transformPropName = 'transform'; // For composite animation, we need to concatenate certain property values
      // instead of replacing them

      if (isComposite) {
        oj.AnimationUtils._concatMultiValue(element, state, transitionPropName, 'all', ', ');
      }

      if (state.css[transformPropName]) {
        // eslint-disable-next-line no-param-reassign
        state.css[transformPropName] = oj.AnimationUtils._applyTransform(element, state.css[transformPropName]);
      }

      var newStyle = state.css;
      var props = Object.keys(newStyle);

      for (var i = 0; i < props.length; i++) {
        var prop = props[i];

        oj.AnimationUtils._setElementStyle(element, prop, newStyle[prop]);
      }
    }

    if (state.addClass) {
      $(element).addClass(state.addClass);
    }

    if (state.removeClass) {
      $(element).removeClass(state.removeClass);
    }
  }
}; // Get a timing value in millisecond from a string such as duration and delay


oj.AnimationUtils._getTimingValue = function (timingStr) {
  var timingValue = parseFloat(timingStr);

  if (isNaN(timingValue)) {
    return 0;
  }

  return timingStr.indexOf('ms') > -1 ? timingValue : timingValue * 1000;
};

oj.AnimationUtils._getTotalTiming = function (duration, delay) {
  var durationMs = oj.AnimationUtils._getTimingValue(duration);

  if (durationMs > 0) {
    var delayMs = delay ? oj.AnimationUtils._getTimingValue(delay) : 0;
    return durationMs + delayMs;
  }

  return 0;
};

oj.AnimationUtils._calcCssTime = function (propertyStr, delayStr, durationStr) {
  var propertyArray = propertyStr.split(',');
  var delayArray = delayStr.split(',');
  var durationArray = durationStr.split(',');
  var propertyLen = propertyArray.length;
  var delayLen = delayArray.length;
  var durationLen = durationArray.length;
  var maxTime = 0;

  for (var i = 0; i < propertyLen; i++) {
    var duration = durationArray[i % durationLen];
    var delay = delayArray[i % delayLen];

    var totalMs = oj.AnimationUtils._getTotalTiming(duration, delay);

    maxTime = Math.max(maxTime, totalMs);
  }

  return maxTime;
};

oj.AnimationUtils._calcEffectTime = function (element) {
  var style = window.getComputedStyle(element);
  var propertyStr;
  var delayStr;
  var durationStr;
  propertyStr = style.animationName || style.webkitAnimationName;
  delayStr = style.animationDelay || style.webkitAnimationDelay;
  durationStr = style.animationDuration || style.webkitAnimationDuration;

  var animationTime = oj.AnimationUtils._calcCssTime(propertyStr, delayStr, durationStr);

  propertyStr = style.transitionProperty || style.webkitTransitionProperty;
  delayStr = style.transitionDelay || style.webkitTransitionDelay;
  durationStr = style.transitionDuration || style.webkitTransitionDuration;

  var transitionTime = oj.AnimationUtils._calcCssTime(propertyStr, delayStr, durationStr);

  return Math.max(animationTime, transitionTime);
}; // Fill in empty timing options from a set of source options


oj.AnimationUtils._fillEmptyOptions = function (targetOptions, sourceOptions) {
  // eslint-disable-next-line no-param-reassign
  targetOptions.delay = targetOptions.delay || sourceOptions.delay; // eslint-disable-next-line no-param-reassign

  targetOptions.duration = targetOptions.duration || sourceOptions.duration; // eslint-disable-next-line no-param-reassign

  targetOptions.timingFunction = targetOptions.timingFunction || sourceOptions.timingFunction; // eslint-disable-next-line no-param-reassign

  targetOptions.persist = targetOptions.persist || sourceOptions.persist;
}; // Trigger oj custom event


oj.AnimationUtils._triggerEvent = function (element, eventName, ui, component) {
  var defaultPrevented;

  if (component && component._trigger) {
    // _trigger() returns false if preventDefault has been called
    defaultPrevented = !component._trigger(eventName, null, ui);
  } else {
    var ojEventType = 'oj' + eventName.substr(0, 1).toUpperCase() + eventName.substr(1);
    var customEvent = new CustomEvent(ojEventType, {
      detail: ui,
      bubbles: true,
      cancelable: true
    });
    var eventTarget = component || element;

    if (eventTarget.dispatchEvent) {
      eventTarget.dispatchEvent(customEvent);
    }

    defaultPrevented = customEvent.defaultPrevented;
  }

  return defaultPrevented;
};
/**
 * Internal method for starting an animation.
 * @param {Element} element  the HTML element to animate
 * @param {string} action  a component-defined string that identifies the action starting
 *                         the animation, such as "open", "close", "add", "remove", etc.
 * @param {string|Object|Array} effects  The name of one of the effect methods
 *                        in oj.AnimationUtils, or an object that specifies the
 *                        effect method and its options, such as:
 *                        {'effect': 'fadeOut', 'endOpacity': 0.5}, or an array of the above.
 * @param {Object=} component  the component that owns the HTML element
 *                             to animate.  If this is specified and it has a
 *                             _trigger method (jQuery UI widget), animation events will
 *                             be triggered on the component via jQuery UI _trigger(),
 *                             so that listeners specified as event options will work.
 *                             If this is specified but it doesn't have a _trigger
 *                             method (HTML element), animation events will be triggered
 *                             on the component via dispatchEvent.
 *                             If this is not specified, animation events will be triggered
 *                             on the animated HTML element via dispatchEvent.
 * @return {Promise} a promise that will be resolved when the animation ends
 * @export
 * @ignore
 */


oj.AnimationUtils.startAnimation = function (element, action, effects, component) {
  // Temporary fix for callers that are passing in jQuery object
  // eslint-disable-next-line no-param-reassign
  element = $(element)[0];
  var promise = new Promise( // eslint-disable-next-line no-unused-vars
  function (resolve, reject) {
    var jelem = $(element);
    var fromMarker = 'oj-animate-' + action;
    var toMarker = fromMarker + '-active';
    var eventProcessed = false;
    var markerProcessed = false;

    var resolvePromise = function resolvePromise() {
      if (eventProcessed && markerProcessed) {
        jelem.removeClass(fromMarker);
        jelem.removeClass(toMarker);

        oj.AnimationUtils._restoreStyle(element);

        resolve(true);
        var ui = {
          action: action,
          element: element
        };

        oj.AnimationUtils._triggerEvent(element, 'animateEnd', ui, component);
      }
    };

    var eventCallback = function eventCallback() {
      eventProcessed = true;
      resolvePromise();
    };

    var markerCallback = function markerCallback() {
      markerProcessed = true;
      resolvePromise();
    }; // This will add a ref count so that the style is not restored until
    // all effects and user-defined css transitions have ended.  Otherwise
    // there may be screen flash if 'persist' !== 'all'.


    oj.AnimationUtils._saveStyle(element, null, null, null, null); // Trigger ojanimatestart event so that app can prevent default animation
    // and define custom effect in JS


    var ui = {
      action: action,
      element: element,
      endCallback: eventCallback
    };

    var defaultPrevented = oj.AnimationUtils._triggerEvent(element, 'animateStart', ui, component); // Continue animation handling if app didn't preventDefault


    if (!defaultPrevented) {
      var effectArray = [].concat(effects);
      var promiseArray = [];
      var lastOptions = {};

      for (var i = 0; i < effectArray.length; i++) {
        var animationEffect = effectArray[i];
        var effectName = '';
        var effectOptions; // Start any explicit animation effect

        if (animationEffect != null && animationEffect !== 'none') {
          if (typeof animationEffect === 'string') {
            effectName = animationEffect;
            effectOptions = {};
          } else if (_typeof(animationEffect) === 'object') {
            effectName = animationEffect.effect;
            effectOptions = $.extend({}, animationEffect);
          } // Fill in empty timing options with what was specified last


          oj.AnimationUtils._fillEmptyOptions(effectOptions, lastOptions); // Remember the last set of options


          lastOptions = $.extend({}, effectOptions);
        }

        if (effectName && oj.AnimationUtils[effectName]) {
          promiseArray.push(oj.AnimationUtils[effectName](element, effectOptions));
        }
      }

      if (promiseArray.length) {
        Promise.all(promiseArray).then(eventCallback);
      } else {
        eventCallback();
      }
    } // Add marker class so that app can define custom effect in CSS


    jelem.addClass(fromMarker);
    var requestId = window.requestAnimationFrame(function () {
      requestId = 0;
      jelem.addClass(toMarker);

      var totalMs = oj.AnimationUtils._calcEffectTime(element);

      if (totalMs > 0) {
        // Set a timeout to resolve the promise.  We can't rely on
        // transitionend event since there can be multiple transition
        // properties, or the transition is never triggered, or the transition
        // is cancelled.
        setTimeout(markerCallback, totalMs + 100);
      } else {
        markerCallback();
      }
    }); // In case we are in the background and requestAnimationFrame is not
    // called, have a timeout that cancel the request and resolve promise

    setTimeout(function () {
      if (requestId) {
        window.cancelAnimationFrame(requestId);
        requestId = 0;
        markerCallback();
      }
    }, 1000);
  });
  return promise;
};

oj.AnimationUtils._mergeOptions = function (effect, options) {
  if (oj.AnimationUtils._defaultOptions == null) {
    oj.AnimationUtils._defaultOptions = ThemeUtils.parseJSONFromFontFamily('oj-animation-effect-default-options');
  } // At the minimum, we should have a duration.  Merge any theming defaults
  // and then any user options to it.


  return $.extend({
    duration: '400ms'
  }, oj.AnimationUtils._defaultOptions ? oj.AnimationUtils._defaultOptions[effect] : null, options);
};

oj.AnimationUtils._createTransitionValue = function (element, transProps, options) {
  var transValue = '';

  if (transProps) {
    for (var i = 0; i < transProps.length; i++) {
      var propName = oj.AnimationUtils._getName(element, transProps[i]);

      var hyphenatedName = oj.AnimationUtils._getHyphenatedPropName(propName);

      transValue += (i > 0 ? ', ' : '') + hyphenatedName + ' ' + options.duration;

      if (options.timingFunction) {
        transValue += ' ' + options.timingFunction;
      }

      if (options.delay) {
        transValue += ' ' + options.delay;
      }
    }
  }

  return transValue;
};

oj.AnimationUtils._fade = function (element, _options, effect, startOpacity, endOpacity) {
  var options = oj.AnimationUtils._mergeOptions(effect, _options);

  var fromState = {
    css: {
      opacity: startOpacity
    }
  };
  var toState = {
    css: {
      opacity: endOpacity
    }
  };

  if (options) {
    if (options.startOpacity) {
      fromState.css.opacity = options.startOpacity;
    }

    if (options.endOpacity) {
      toState.css.opacity = options.endOpacity;
    }
  }

  return oj.AnimationUtils._animate(element, fromState, toState, options, ['opacity']);
};
/**
 * Animaton effect method for fading in a HTML element.
 *
 * @param {Element} element  the HTML element to animate
 * @param {Object=} options Options applicable to the specific animation effect.
 * @param {string=} options.delay  The delay from the time the animation is applied to time the
 * animation should begin. This may be specified in either seconds (by specifying s as the unit) or milliseconds
 * (by specifying ms as the unit). Default is "0s".
 * @param {string=} options.duration The duration that an animation should take to complete. This may be
 * specified in either seconds (by specifying s as the unit) or milliseconds (by specifying ms as the unit).
 * Default is "400ms".
 * @param {string=} options.timingFunction  One of the valid values for either CSS transition-timing-function or CSS
 * animation-timing-function. Default is "ease".
 * @param {string=} options.persist  Valid values are "none" and "all".  Set to "none" to remove the inline style being animated at the end of animation.
 *                                    Set to "all" to persist the inline style.  Default is "none".
 * @param {number=} options.startOpacity starting opacity. Default is 0.
 * @param {number=} options.endOpacity  ending opacity. Default is 1.
 * @return {Promise.<boolean>} a promise that will be resolved when the animation ends
 *
 * @export
 * @memberof oj.AnimationUtils
 */


oj.AnimationUtils.fadeIn = function (element, options) {
  return oj.AnimationUtils._fade(element, options, 'fadeIn', 0, 1);
};
/**
 * Animaton effect method for fading out a HTML element.
 *
 * @param {Element} element  the HTML element to animate
 * @param {Object=} options Options applicable to the specific animation effect.
 * @param {string=} options.delay  The delay from the time the animation is applied to time the
 * animation should begin. This may be specified in either seconds (by specifying s as the unit) or milliseconds
 * (by specifying ms as the unit). Default is "0s".
 * @param {string=} options.duration The duration that an animation should take to complete. This may be
 * specified in either seconds (by specifying s as the unit) or milliseconds (by specifying ms as the unit).
 * Default is "400ms".
 * @param {string=} options.timingFunction  One of the valid values for either CSS transition-timing-function or CSS
 * animation-timing-function. Default is "ease".
 * @param {string=} options.persist  Valid values are "none" and "all".  Set to "none" to remove the inline style being animated at the end of animation.
 *                                    Set to "all" to persist the inline style.  Default is "none".
 * @param {number=} options.startOpacity starting opacity. Default is 1.
 * @param {number=} options.endOpacity  ending opacity. Default is 0.
 * @return {Promise.<boolean>} a promise that will be resolved when the animation ends
 *
 * @export
 * @memberof oj.AnimationUtils
 */


oj.AnimationUtils.fadeOut = function (element, options) {
  return oj.AnimationUtils._fade(element, options, 'fadeOut', 1, 0);
};
/**
 * Animaton effect method for expanding a HTML element.
 *
 * @param {Element} element  the HTML element to animate
 * @param {Object=} options Options applicable to the specific animation effect.
 * @param {string=} options.delay  The delay from the time the animation is applied to time the
 * animation should begin. This may be specified in either seconds (by specifying s as the unit) or milliseconds
 * (by specifying ms as the unit). Default is "0s".
 * @param {string=} options.duration The duration that an animation should take to complete. This may be
 * specified in either seconds (by specifying s as the unit) or milliseconds (by specifying ms as the unit).
 * Default is "400ms".
 * @param {string=} options.timingFunction  One of the valid values for either CSS transition-timing-function or CSS
 * animation-timing-function. Default is "ease".
 * @param {string=} options.persist  Valid values are "none" and "all".  Set to "none" to remove the inline style being animated at the end of animation.
 *                                    Set to "all" to persist the inline style.  Default is "none".
 * @param {string=} options.direction direction to expand. Valid values are "height", "width", or "both". Default is "height".
 * @param {string=} options.startMaxHeight starting max-height value to expand from.  Default is "0".
 * @param {string=} options.endMaxHeight ending max-height value to expand to.  Default is natural element height.
 * @param {string=} options.startMaxWidth starting max-width value to expand from.  Default is "0".
 * @param {string=} options.endMaxWidth starting max-width value to expand to.  Default is natural element width.
 * @return {Promise.<boolean>} a promise that will be resolved when the animation ends
 *
 * @export
 * @memberof oj.AnimationUtils
 */


oj.AnimationUtils.expand = function (element, options) {
  return oj.AnimationUtils._expandCollapse(element, options, true);
};
/**
 * Animaton effect method for collapsing a HTML element.
 * <p>When using this method to hide an element, the element should not have any border
 * or padding, because border and padding are visible even if the element's height
 * is set to 0. The use of "box-sizing: border-box" style doesn't change this behavior.
 * If the element needs border and padding, create a wrapper element around it and
 * call this method on the wrapper element instead.</p>
 *
 * @param {Element} element  the HTML element to animate
 * @param {Object=} options Options applicable to the specific animation effect.
 * @param {string=} options.delay  The delay from the time the animation is applied to time the
 * animation should begin. This may be specified in either seconds (by specifying s as the unit) or milliseconds
 * (by specifying ms as the unit). Default is "0s".
 * @param {string=} options.duration The duration that an animation should take to complete. This may be
 * specified in either seconds (by specifying s as the unit) or milliseconds (by specifying ms as the unit).
 * Default is "400ms".
 * @param {string=} options.timingFunction  One of the valid values for either CSS transition-timing-function or CSS
 * animation-timing-function. Default is "ease".
 * @param {string=} options.persist  Valid values are "none" and "all".  Set to "none" to remove the inline style being animated at the end of animation.
 *                                    Set to "all" to persist the inline style.  Default is "none".
 * @param {string=} options.direction direction to collapse. Valid values are "height", "width", or "both". Default is "height".
 * @param {string=} options.startMaxHeight starting max-height value to collapse from.  Default is natural element height.
 * @param {string=} options.endMaxHeight ending max-height value to collapse to.  Default is "0".
 * @param {string=} options.startMaxWidth starting max-width value to collapse from.  Default is natural element width.
 * @param {string=} options.endMaxWidth starting max-width value to collapse to.  Default is "0".
 * @return {Promise.<boolean>} a promise that will be resolved when the animation ends
 *
 * @export
 * @memberof oj.AnimationUtils
 */


oj.AnimationUtils.collapse = function (element, options) {
  return oj.AnimationUtils._expandCollapse(element, options, false);
}; // Wrap table row content and return an array of wrapper elements to animate


oj.AnimationUtils._wrapRowContent = function (row, rowHeight) {
  var wrappers = [];
  var cell;
  var cells = row.children;
  var cellsPadding = [];
  var cellsTextAlign = [];
  var i; // Collect all the needed style before modifying the DOM.  Otherwise it
  // causes additional reflow and takes more time.
  // eslint-disable-next-line no-param-reassign

  row._ojSavedHeight = row.style.height;

  for (i = 0; i < cells.length; i++) {
    cell = cells[i];
    var cellStyle = window.getComputedStyle(cell);
    cellsPadding.push(cellStyle.padding);
    cellsTextAlign.push(cellStyle.textAlign); // Remember the inline padding style (not computed style)

    cell._ojSavedPadding = cell.style.padding;
  } // Start modifying the DOM


  for (i = 0; i < cells.length; i++) {
    cell = cells[i]; // Create the outer wrapper

    var outerWrapper = document.createElement('div');
    outerWrapper.style.overflow = 'hidden;'; // Create the inner wrapper

    var innerWrapper = document.createElement('div');
    innerWrapper.style.display = 'table-cell';
    innerWrapper.style.verticalAlign = 'middle';
    innerWrapper.style.boxSizing = 'border-box';
    innerWrapper.style.height = rowHeight;
    innerWrapper.style.padding = cellsPadding[i];
    innerWrapper.style.textAlign = cellsTextAlign[i]; // Append inner wrapper to outer wrapper

    outerWrapper.appendChild(innerWrapper); // @HTMLUpdateOK innerWrapper is constructed by component code and is not using string passed in through any APIs.
    // Transfer children of cell to inner wrapper

    while (cell.firstChild) {
      innerWrapper.appendChild(cell.firstChild); // @HTMLUpdateOK cell.firstChild is constructed by component code and is not using string passed in through any APIs.
    } // Finally append the outer wrapper back to the cell


    cell.appendChild(outerWrapper); // @HTMLUpdateOK outerWrapper is constructed by component code and is not using string passed in through any APIs.
    // Set the cell padding to 0 so that it can be completely collapsed

    cell.style.padding = '0';
    wrappers.push(outerWrapper);
  } // Set the row height to 0 so that it can be completely collapsed
  // eslint-disable-next-line no-param-reassign


  row.style.height = '0';
  return wrappers;
}; // Unwrap table row content


oj.AnimationUtils._unwrapRowContent = function (row) {
  var cells = row.children;

  for (var i = 0; i < cells.length; i++) {
    var cell = cells[i];
    var outerWrapper = cell.children[0];

    if (outerWrapper) {
      var innerWrapper = outerWrapper.children[0];

      if (innerWrapper) {
        while (innerWrapper.firstChild) {
          cell.appendChild(innerWrapper.firstChild); // @HTMLUpdateOK innerWrapper.firstChild is constructed by component code and is not using string passed in through any APIs.
        }
      } // Remove the outer wrapper will also remove the inner wrapper


      cell.removeChild(outerWrapper);
    } // Restore any inline padding style to the cell


    cell.style.padding = cell._ojSavedPadding;
    delete cell._ojSavedPadding;
  } // Restore any inline height style to the row
  // eslint-disable-next-line no-param-reassign


  row.style.height = row._ojSavedHeight; // eslint-disable-next-line no-param-reassign

  delete row._ojSavedHeight;
}; // Expand or collapse a table row


oj.AnimationUtils._expandCollapseRow = function (element, options, isExpand) {
  var promise;
  var rowHeight = element.offsetHeight + 'px';

  var wrappers = oj.AnimationUtils._wrapRowContent(element, rowHeight);

  var wrapperOptions = $.extend({}, options); // Set the known max height into the options so that each cell doesn't
  // have to recalculate it

  if (isExpand) {
    if (!wrapperOptions.endMaxHeight) {
      wrapperOptions.endMaxHeight = rowHeight;
    }
  } else if (!wrapperOptions.startMaxHeight) {
    wrapperOptions.startMaxHeight = rowHeight;
  } // Set persist option so that we don't need to restore the style after
  // animation.  The wrapper will be removed anyway.


  wrapperOptions.persist = 'all'; // Set internal _noReflow option so that we don't force reflow on Firefox.
  // New elements will naturally cause reflow.

  wrapperOptions._noReflow = true;

  if (wrappers.length) {
    // Animate all the cells
    for (var i = 0; i < wrappers.length; i++) {
      // We only need one promise/row.  Skip promise for all cells except first.
      if (i === 0) {
        wrapperOptions._skipPromise = false;
        promise = oj.AnimationUtils._expandCollapse(wrappers[i], wrapperOptions, isExpand);
      } else {
        wrapperOptions._skipPromise = true;

        oj.AnimationUtils._expandCollapse(wrappers[i], wrapperOptions, isExpand);
      }
    }
  } else {
    promise = Promise.resolve();
  }

  return promise.then(function () {
    if (options == null || options.persist !== 'all') {
      oj.AnimationUtils._unwrapRowContent(element);
    }
  });
}; // Determine the min/max width/height used for animation


oj.AnimationUtils._getSizeLimit = function (element, style, optionValue, isLower, isWidth) {
  var limitValue = optionValue;

  if (!limitValue) {
    if (isLower) {
      limitValue = '0';
    } else {
      var cssValue = isWidth ? style.maxWidth : style.maxHeight;

      if (cssValue !== 'none') {
        limitValue = cssValue;
      } else {
        limitValue = (isWidth ? element.offsetWidth : element.offsetHeight) + 'px';
      }
    }
  }

  return limitValue;
};

oj.AnimationUtils._expandCollapse = function (element, _options, isExpand) {
  // Handle the case where the element is a <tr> element.  We need to wrap the
  // content of every child <td> and animate the wrappers because the min height
  // of <tr> and <td> are limited by their contents.
  if (element && element.tagName === 'TR') {
    return oj.AnimationUtils._expandCollapseRow(element, _options, isExpand);
  }

  var options = oj.AnimationUtils._mergeOptions(isExpand ? 'expand' : 'collapse', _options);

  var fromState = {
    css: {}
  };
  var toState = {
    css: {}
  };
  var direction = options.direction || 'height';
  var fromCSS = fromState.css;
  var toStateCSS = toState.css;
  var style = window.getComputedStyle(element);
  var transProps = [];

  if (direction === 'both' || direction === 'height') {
    var startMaxHeight = oj.AnimationUtils._getSizeLimit(element, style, options.startMaxHeight, isExpand, false);

    var endMaxHeight = oj.AnimationUtils._getSizeLimit(element, style, options.endMaxHeight, !isExpand, false);

    fromCSS.maxHeight = startMaxHeight;
    toStateCSS.maxHeight = endMaxHeight;
    transProps.push('maxHeight');
  }

  if (direction === 'both' || direction === 'width') {
    var startMaxWidth = oj.AnimationUtils._getSizeLimit(element, style, options.startMaxWidth, isExpand, true);

    var endMaxWidth = oj.AnimationUtils._getSizeLimit(element, style, options.endMaxWidth, !isExpand, true);

    fromCSS.maxWidth = startMaxWidth;
    toStateCSS.maxWidth = endMaxWidth;
    transProps.push('maxWidth');
  } // expand and collapse needs overflow hidden to hide the content


  fromCSS.overflow = options.overflow ? options.overflow : 'hidden';
  var persistProps = [].concat(transProps);
  persistProps.push('overflow');
  return oj.AnimationUtils._animate(element, fromState, toState, options, transProps, persistProps);
};
/**
 * Animaton effect method for zooming in a HTML element.
 *
 * @param {Element} element  the HTML element to animate
 * @param {Object=} options Options applicable to the specific animation effect.
 * @param {string=} options.delay  The delay from the time the animation is applied to time the
 * animation should begin. This may be specified in either seconds (by specifying s as the unit) or milliseconds
 * (by specifying ms as the unit). Default is "0s".
 * @param {string=} options.duration The duration that an animation should take to complete. This may be
 * specified in either seconds (by specifying s as the unit) or milliseconds (by specifying ms as the unit).
 * Default is "400ms".
 * @param {string=} options.timingFunction  One of the valid values for either CSS transition-timing-function or CSS
 * animation-timing-function. Default is "ease".
 * @param {string=} options.persist  Valid values are "none" and "all".  Set to "none" to remove the inline style being animated at the end of animation.
 *                                    Set to "all" to persist the inline style.  Default is "none".
 * @param {string=} options.axis the axis along which to scale the element. Valid values are "x", "y", or "both". Default is "both".
 * @param {string=} options.transformOrigin set the CSS transform-origin property, which controls the anchor point for the zoom. Default is "center".
 * @return {Promise.<boolean>} a promise that will be resolved when the animation ends
 *
 * @export
 * @memberof oj.AnimationUtils
 */


oj.AnimationUtils.zoomIn = function (element, options) {
  return oj.AnimationUtils._zoom(element, options, true);
};
/**
 * Animaton effect method for zooming out a HTML element.
 *
 * @param {Element} element  the HTML element to animate
 * @param {Object=} options Options applicable to the specific animation effect.
 * @param {string=} options.delay  The delay from the time the animation is applied to time the
 * animation should begin. This may be specified in either seconds (by specifying s as the unit) or milliseconds
 * (by specifying ms as the unit). Default is "0s".
 * @param {string=} options.duration The duration that an animation should take to complete. This may be
 * specified in either seconds (by specifying s as the unit) or milliseconds (by specifying ms as the unit).
 * Default is "400ms".
 * @param {string=} options.timingFunction  One of the valid values for either CSS transition-timing-function or CSS
 * animation-timing-function. Default is "ease".
 * @param {string=} options.persist  Valid values are "none" and "all".  Set to "none" to remove the inline style being animated at the end of animation.
 *                                    Set to "all" to persist the inline style.  Default is "none".
 * @param {string=} options.axis the axis along which to scale the element. Valid values are "x", "y", or "both". Default is "both".
 * @param {string=} options.transformOrigin set the CSS transform-origin property, which controls the anchor point for the zoom. Default is "center".
 * @return {Promise.<boolean>} a promise that will be resolved when the animation ends
 *
 * @export
 * @memberof oj.AnimationUtils
 */


oj.AnimationUtils.zoomOut = function (element, options) {
  return oj.AnimationUtils._zoom(element, options, false);
};

oj.AnimationUtils._zoom = function (element, _options, isIn) {
  var options = oj.AnimationUtils._mergeOptions(isIn ? 'zoomIn' : 'zoomOut', _options);

  var fromState = {
    css: {}
  };
  var toState = {
    css: {}
  };
  var axis = options.axis || 'both';
  var scale;

  if (axis === 'both') {
    scale = 'scale';
  } else if (axis === 'x') {
    scale = 'scaleX';
  } else {
    scale = 'scaleY';
  }

  var fromCSS = fromState.css;
  var toStateCSS = toState.css;
  var transformPropName = 'transform';
  var transformOriginPropName = 'transformOrigin';
  fromCSS[transformPropName] = scale + '(' + (isIn ? 0 : 1) + ') translateZ(0)';
  toStateCSS[transformPropName] = scale + '(' + (isIn ? 1 : 0) + ') translateZ(0)';
  fromCSS[transformOriginPropName] = options.transformOrigin || 'center';
  return oj.AnimationUtils._animate(element, fromState, toState, options, [transformPropName]);
};
/**
 * Animaton effect method for sliding in a HTML element.
 *
 * @param {Element} element  the HTML element to animate
 * @param {Object=} options Options applicable to the specific animation effect.
 * @param {string=} options.delay  The delay from the time the animation is applied to time the
 * animation should begin. This may be specified in either seconds (by specifying s as the unit) or milliseconds
 * (by specifying ms as the unit). Default is "0s".
 * @param {string=} options.duration The duration that an animation should take to complete. This may be
 * specified in either seconds (by specifying s as the unit) or milliseconds (by specifying ms as the unit).
 * Default is "400ms".
 * @param {string=} options.timingFunction  One of the valid values for either CSS transition-timing-function or CSS
 * animation-timing-function. Default is "ease".
 * @param {string=} options.persist  Valid values are "none" and "all".  Set to "none" to remove the inline style being animated at the end of animation.
 *                                    Set to "all" to persist the inline style.  Default is "none".
 * @param {string=} options.direction Direction of the slide. Valid values are "left", "top", "right", "bottom", "start", and "end". Default is "start".
 *                                    This option is ignored if either offsetX or offsetY is specified.
 * @param {string=} options.offsetX The offset on the x-axis to translate from. This value must be a number followed by a unit such as "px", "em", etc.
 *                                  If moving in a horizontal direction, default to element width. Otherwise, default to "0px".
 * @param {string=} options.offsetY The offset on the y-axis to translate from. This value must be a number followed by a unit such as "px", "em", etc.
 *                                  If moving in a vertical direction, default to element height. Otherwise, default to "0px".
 * @return {Promise.<boolean>} a promise that will be resolved when the animation ends
 *
 * @export
 * @memberof oj.AnimationUtils
 */


oj.AnimationUtils.slideIn = function (element, options) {
  return oj.AnimationUtils._slide(element, options, true);
};
/**
 * Animaton effect method for sliding out a HTML element.
 *
 * @param {Element} element  the HTML element to animate
 * @param {Object=} options Options applicable to the specific animation effect.
 * @param {string=} options.delay  The delay from the time the animation is applied to time the
 * animation should begin. This may be specified in either seconds (by specifying s as the unit) or milliseconds
 * (by specifying ms as the unit). Default is "0s".
 * @param {string=} options.duration The duration that an animation should take to complete. This may be
 * specified in either seconds (by specifying s as the unit) or milliseconds (by specifying ms as the unit).
 * Default is "400ms".
 * @param {string=} options.timingFunction  One of the valid values for either CSS transition-timing-function or CSS
 * animation-timing-function. Default is "ease".
 * @param {string=} options.persist  Valid values are "none" and "all".  Set to "none" to remove the inline style being animated at the end of animation.
 *                                    Set to "all" to persist the inline style.  Default is "none".
 * @param {string=} options.direction Direction of the slide. Valid values are "left", "top", "right", "bottom", "start", and "end". Default is "start".
 *                                    This option is ignored if either offsetX or offsetY is specified.
 * @param {string=} options.offsetX The offset on the x-axis to translate to. This value must be a number followed by a unit such as "px", "em", etc.
 *                                  If moving in a horizontal direction, default to element width. Otherwise, default to "0px".
 * @param {string=} options.offsetY The offset on the y-axis to translate to. This value must be a number followed by a unit such as "px", "em", etc.
 *                                  If moving in a vertical direction, default to element height. Otherwise, default to "0px".
 * @return {Promise.<boolean>} a promise that will be resolved when the animation ends
 *
 * @export
 * @memberof oj.AnimationUtils
 */


oj.AnimationUtils.slideOut = function (element, options) {
  return oj.AnimationUtils._slide(element, options, false);
};

oj.AnimationUtils._slide = function (element, _options, isIn) {
  var options = oj.AnimationUtils._mergeOptions(isIn ? 'slideIn' : 'slideOut', _options);

  var fromState = {
    css: {}
  };
  var toState = {
    css: {}
  };
  var direction = options.direction || 'start';
  var offsetX = '0';
  var offsetY = '0';
  var fromCSS = fromState.css;
  var toStateCSS = toState.css;

  if (options.offsetX || options.offsetY) {
    if (options.offsetX) {
      offsetX = options.offsetX;
    }

    if (options.offsetY) {
      offsetY = options.offsetY;
    }
  } else {
    var isRTL = oj.DomUtils.getReadingDirection() === 'rtl';

    switch (direction) {
      case 'left':
        offsetX = (isIn ? element.offsetWidth : -element.offsetWidth) + 'px';
        break;

      case 'right':
        offsetX = (isIn ? -element.offsetWidth : element.offsetWidth) + 'px';
        break;

      case 'top':
        offsetY = (isIn ? element.offsetHeight : -element.offsetHeight) + 'px';
        break;

      case 'bottom':
        offsetY = (isIn ? -element.offsetHeight : element.offsetHeight) + 'px';
        break;

      case 'end':
        offsetX = (isIn ? -element.offsetWidth : element.offsetWidth) * (isRTL ? -1 : 1) + 'px';
        break;

      default:
        // 'start'
        offsetX = (isIn ? element.offsetWidth : -element.offsetWidth) * (isRTL ? -1 : 1) + 'px';
        break;
    }
  }

  var transformPropName = 'transform';

  if (isIn) {
    fromCSS[transformPropName] = 'translate(' + offsetX + ',' + offsetY + ') translateZ(0)';
    toStateCSS[transformPropName] = 'translate(0,0) translateZ(0)';
  } else {
    fromCSS[transformPropName] = 'translate(0,0) translateZ(0)';
    toStateCSS[transformPropName] = 'translate(' + offsetX + ',' + offsetY + ') translateZ(0)';
  }

  return oj.AnimationUtils._animate(element, fromState, toState, options, [transformPropName]);
};
/**
 * Animaton effect method for rippling a HTML element.
 *
 * @param {Element} element  the HTML element to animate
 * @param {Object=} options Options applicable to the specific animation effect.
 * @param {string=} options.delay  The delay from the time the animation is applied to time the
 * animation should begin. This may be specified in either seconds (by specifying s as the unit) or milliseconds
 * (by specifying ms as the unit). Default is "0s".
 * @param {string=} options.duration The duration that an animation should take to complete. This may be
 * specified in either seconds (by specifying s as the unit) or milliseconds (by specifying ms as the unit).
 * Default is "400ms".
 * @param {string=} options.timingFunction  One of the valid values for either CSS transition-timing-function or CSS
 * animation-timing-function. Default is "ease".
 * @param {string=} options.offsetX Horizontal offset of the ripple center, with a unit of either "px" or "%".
 *                                  If the unit is "px", it specifies the offset in pixels.
 *                                  If the unit is "%", it specifies the offset as a percentage of the element's width.
 * @param {string=} options.offsetY Vertical offset of the ripple center, with a unit of either "px" or "%".
 *                                  If the unit is "px", it specifies the offset in pixels.
 *                                  If the unit is "%", it specifies the offset as a percentage of the element's height.
 * @param {string=} options.color Color of the ripple. Default is specified in the "oj-animation-effect-ripple" CSS class.
 * @param {string=} options.diameter Diameter of the ripple, with a unit of either "px" or "%".
 *                                   If the unit is "px", it specifies the diameter in pixels.
 *                                   If the unit is "%", it specifies the diameter as a percentage of either the element's width or height, whichever is less.
 *                                   Default is specified in the "oj-animation-effect-ripple" CSS class.
 * @param {number=} options.startOpacity start opacity of the ripple. Default is specified in the "oj-animation-effect-ripple" CSS class.
 * @param {number=} options.endOpacity end opacity of the ripple. Default is 0.
 * @return {Promise.<boolean>} a promise that will be resolved when the animation ends
 *
 * @export
 * @memberof oj.AnimationUtils
 */


oj.AnimationUtils.ripple = function (element, options) {
  var _options = oj.AnimationUtils._mergeOptions('ripple', options);

  var fromState = {
    css: {}
  };
  var toState = {
    css: {}
  };
  var width = element.offsetWidth;
  var height = element.offsetHeight; // The rippler need its own container since setting overflow on the target
  // element may not work if the element has no explicit height, which can be
  // the case on buton, listitem, etc.

  var container = $('<div>').css({
    position: 'absolute',
    overflow: 'hidden'
  });
  var rippler = $("<div class='oj-animation-effect-ripple oj-animation-rippler'>"); // prepend the rippler instead of append so that it doesn't obscure other children

  var style = window.getComputedStyle(element);
  var position = style.position === 'static' ? {
    left: element.offsetLeft,
    top: element.offsetTop
  } : {
    left: 0,
    top: 0
  };
  element.insertBefore(container[0], element.firstChild); // @HTMLUpdateOK container is constructed by component code and is not using string passed in through any APIs.

  container.css({
    left: position.left + 'px',
    top: position.top + 'px',
    width: width + 'px',
    height: height + 'px'
  });
  container.prepend(rippler); // @HTMLUpdateOK rippler is constructed by component code and is not using string passed in through any APIs.

  var fromCSS = fromState.css;
  var toStateCSS = toState.css;
  var transformPropName = 'transform';

  oj.AnimationUtils._setRippleOptions(fromCSS, rippler, container, _options);

  fromCSS[transformPropName] = 'scale(0) translateZ(0)';
  fromCSS.opacity = _options.startOpacity || rippler.css('opacity');
  toStateCSS[transformPropName] = 'scale(1) translateZ(0)';
  toStateCSS.opacity = _options.endOpacity || 0; // Always persist the ripple state so that it remains invisible until removed.
  // Otherwise it may re-appear briefly on mobile Safari.

  _options.persist = 'all';
  return oj.AnimationUtils._animate(rippler[0], fromState, toState, _options, [transformPropName, 'opacity']).then(function () {
    container.remove();
  });
};

oj.AnimationUtils._setRippleOptions = function (_css, rippler, parent, options) {
  var css = _css;
  var diameter = rippler.width();
  var parentWidth = parent.width();
  var parentHeight = parent.height();

  if (options.diameter) {
    var diameterStr = options.diameter;
    var value = parseInt(diameterStr, 10);

    if (!isNaN(value)) {
      if (diameterStr.charAt(diameterStr.length - 1) === '%') {
        diameter = Math.floor(Math.min(parentWidth, parentHeight) * (value / 100));
      } else {
        diameter = value;
      }

      css.width = diameter + 'px';
      css.height = diameter + 'px';
    }
  }

  var position = parent.css('position') === 'static' ? parent.position() : {
    left: 0,
    top: 0
  };
  var offset;
  offset = oj.AnimationUtils._calcRippleOffset(options.offsetX, diameter, parentWidth, position.left);

  if (offset != null) {
    css.left = offset + 'px';
  }

  offset = oj.AnimationUtils._calcRippleOffset(options.offsetY, diameter, parentHeight, position.top);

  if (offset != null) {
    css.top = offset + 'px';
  }

  if (options.color) {
    css.backgroundColor = options.color;
  }
};

oj.AnimationUtils._calcRippleOffset = function (_offsetOption, diameter, parentSize, parentOffset) {
  var offset;
  var offsetOption = _offsetOption || '50%';
  var offsetInt = parseInt(offsetOption, 10);

  if (!isNaN(offsetInt)) {
    if (offsetOption.charAt(offsetOption.length - 1) === '%') {
      offset = parentSize * (offsetInt / 100) - diameter / 2;
    } else {
      offset = offsetInt - diameter / 2;
    } // offset should be relative to the rippler's offsetParent, which is not
    // the parent element if the parent element has static position.


    offset = Math.floor(offset + parentOffset);
  }

  return offset;
};

oj.AnimationUtils._removeRipple = function (element, _options) {
  var options = _options || {};
  var possibleEffects = {
    fadeOut: 1,
    collapse: 1,
    zoomOut: 1,
    slideOut: 1
  };
  var removeEffect = options.removeEffect || 'fadeOut';
  var rippler = $('.oj-animation-rippler', element);

  if (rippler.length === 0) {
    Logger.warn('No rippler so returning');
    return undefined;
  }

  if (!(removeEffect in possibleEffects)) {
    return rippler.remove();
  }

  return oj.AnimationUtils[removeEffect](rippler, options).then(function () {
    rippler.remove();
  });
};

oj.AnimationUtils._calcBackfaceAngle = function (angle) {
  var backfaceAngle;
  var expr = /^([+-]?\d*\.?\d*)(.*)$/;
  var matchArray = angle.match(expr);
  var amount = parseFloat(matchArray[1]);
  var unit = matchArray[2];

  switch (unit) {
    case 'deg':
      backfaceAngle = amount - 180 + unit;
      break;

    case 'grad':
      backfaceAngle = amount - 200 + unit;
      break;

    case 'rad':
      backfaceAngle = amount - 3.1416 + unit;
      break;

    case 'turn':
      backfaceAngle = amount - 0.5 + unit;
      break;

    default:
      Logger.error('Unknown angle unit in flip animation: ' + unit);
      break;
  }

  return backfaceAngle;
};

oj.AnimationUtils._flip = function (element, options, effect, startAngle, endAngle) {
  // Handle the case where the element has children to represent front and back
  // faces.  We need to flip the children instead of the parent since IE doesn't
  // support preserve-3d style, which works on other browsers.
  if (options && options.flipTarget === 'children') {
    var promises = [];
    var children = $(element).children();
    var childOptions;
    var frontOptions = $.extend({}, options);
    delete frontOptions.flipTarget;
    var backOptions = $.extend({}, frontOptions);
    backOptions.startAngle = oj.AnimationUtils._calcBackfaceAngle(options.startAngle || startAngle);
    backOptions.endAngle = oj.AnimationUtils._calcBackfaceAngle(options.endAngle || endAngle);

    for (var i = 0; i < children.length; i++) {
      childOptions = $(children[i]).hasClass('oj-animation-backface') ? backOptions : frontOptions;
      promises.push(oj.AnimationUtils._flip(children[i], childOptions, effect, startAngle, endAngle));
    }

    return Promise.all(promises);
  } // eslint-disable-next-line no-param-reassign


  options = oj.AnimationUtils._mergeOptions(effect, options);
  var fromCss = {};
  var toCss = {};
  var fromState = {
    css: fromCss
  };
  var toState = {
    css: toCss
  };
  var rotateFunc = 'rotateY(';
  var perspective = '2000px';
  var backfaceVisibility = 'hidden';
  var transformOrigin = 'center';
  var transform;

  if (options) {
    if (options.axis === 'x') {
      rotateFunc = 'rotateX(';
    }

    if (options.startAngle) {
      // eslint-disable-next-line no-param-reassign
      startAngle = options.startAngle;
    }

    if (options.endAngle) {
      // eslint-disable-next-line no-param-reassign
      endAngle = options.endAngle;
    }

    if (options.perspective) {
      perspective = options.perspective;
    }

    if (options.backfaceVisibility) {
      backfaceVisibility = options.backfaceVisibility;
    }

    if (options.transformOrigin) {
      transformOrigin = options.transformOrigin;
    }
  } // perspective() must precede rotate() in the transform value in order for it to work


  transform = 'perspective(' + perspective + ') ' + rotateFunc; // Safari still requires webkit prefix for backfaceVisibility property

  var backfaceVisPropName = 'backfaceVisibility';
  var transformPropName = 'transform';
  var transformOriginPropName = 'transformOrigin';
  fromCss[transformPropName] = transform + startAngle + ')';
  fromCss[backfaceVisPropName] = backfaceVisibility;
  fromCss[transformOriginPropName] = transformOrigin;
  toCss[transformPropName] = transform + endAngle + ')'; // backfaceVisibility and transformOrigin affects the final look of the element,
  // so they should be persisted if the persist option is set.

  return oj.AnimationUtils._animate(element, fromState, toState, options, [transformPropName], [transformPropName, backfaceVisPropName, transformOriginPropName]);
};
/**
 * Animaton effect method for rotating a HTML element into view.
 *
 * @param {Element} element  the HTML element to animate
 * @param {Object=} options Options applicable to the specific animation effect.
 * @param {string=} options.delay  The delay from the time the animation is applied to time the
 * animation should begin. This may be specified in either seconds (by specifying s as the unit) or milliseconds
 * (by specifying ms as the unit). Default is "0s".
 * @param {string=} options.duration The duration that an animation should take to complete. This may be
 * specified in either seconds (by specifying s as the unit) or milliseconds (by specifying ms as the unit).
 * Default is "400ms".
 * @param {string=} options.timingFunction  One of the valid values for either CSS transition-timing-function or CSS
 * animation-timing-function. Default is "ease".
 * @param {string=} options.persist  Valid values are "none" and "all".  Set to "none" to remove the inline style being animated at the end of animation.
 *                                    Set to "all" to persist the inline style.  Default is "none".
 * @param {string=} options.axis  The axis of the rotation. Valid values are "x" and "y". Default is "y".
 * @param {string=} options.startAngle  The starting angle of the rotation. Refer to CSS rotate() transform for valid values. Default is "-180deg", which shows the back face of the element.
 * @param {string=} options.endAngle  The ending angle of the rotation. Refer to CSS rotate() transform for valid values. Default is "0deg", which shows the front face of the element.
 * @param {string=} options.backfaceVisibility  The visibility of the back face when facing the user. Valid values are "visible" and "hidden". If set to "visible", the back face shows a
 *                                              mirrored image of the front face. If set to "hidden", the back face is invisible.  Default is "hidden".
 * @param {string=} options.perspective  The 3D perspective for the element. Default is "2000px". A smaller value makes the 3D effect more pronounced during rotation.
 * @param {string=} options.transformOrigin  The axis location for the rotation. Refer to CSS transform-origin for valid values. Default is "center".
 * @param {string=} options.flipTarget  The target for flipping.  Valid values are "element" and "children".  Default is "element".
 *                                      <p>Set to "element" to flip the element itself.</p>
 *                                      <p>Set to "children" to flip the children of the element.  This is used when the element is a card-like structure that
 *                                         has children to represent the front and back faces of a card.  The child that represents the back face must have
 *                                         the "oj-animation-backface" marker class.  Use this option instead of the "transform-style: preserve-3d" CSS style because
 *                                         some browsers do not support "transform-style".  See the cookbook for a Card Flip example of using this option.</p>
 * @return {Promise.<boolean>} a promise that will be resolved when the animation ends
 *
 * @export
 * @memberof oj.AnimationUtils
 */


oj.AnimationUtils.flipIn = function (element, options) {
  return oj.AnimationUtils._flip(element, options, 'flipIn', '-180deg', '0deg');
};
/**
 * Animaton effect method for rotating a HTML element out of view.
 *
 * @param {Element} element  the HTML element to animate
 * @param {Object=} options Options applicable to the specific animation effect.
 * @param {string=} options.delay  The delay from the time the animation is applied to time the
 * animation should begin. This may be specified in either seconds (by specifying s as the unit) or milliseconds
 * (by specifying ms as the unit). Default is "0s".
 * @param {string=} options.duration The duration that an animation should take to complete. This may be
 * specified in either seconds (by specifying s as the unit) or milliseconds (by specifying ms as the unit).
 * Default is "400ms".
 * @param {string=} options.timingFunction  One of the valid values for either CSS transition-timing-function or CSS
 * animation-timing-function. Default is "ease".
 * @param {string=} options.persist  Valid values are "none" and "all".  Set to "none" to remove the inline style being animated at the end of animation.
 *                                    Set to "all" to persist the inline style.  Default is "none".
 * @param {string=} options.axis  The axis of the rotation. Valid values are "x" and "y". Default is "y".
 * @param {string=} options.startAngle  The starting angle of the rotation. Refer to CSS rotate() transform for valid values. Default is "0deg", which shows the front face of the element.
 * @param {string=} options.endAngle  The ending angle of the rotation. Refer to CSS rotate() transform for valid values. Default is "180deg", which shows the back face of the element.
 * @param {string=} options.backfaceVisibility  The visibility of the back face when facing the user. Valid values are "visible" and "hidden". If set to "visible", the back face shows a
 *                                              mirrored image of the front face. If set to "hidden", the back face is invisible.  Default is "hidden".
 * @param {string=} options.perspective  The 3D perspective for the element. Default is "2000px". A smaller value makes the 3D effect more pronounced during rotation.
 * @param {string=} options.transformOrigin  The axis location for the rotation. Refer to CSS transform-origin for valid values. Default is "center".
 * @param {string=} options.flipTarget  The target for flipping.  Valid values are "element" and "children".  Default is "element".
 *                                      <p>Set to "element" to flip the element itself.</p>
 *                                      <p>Set to "children" to flip the children of the element.  This is used when the element is a card-like structure that
 *                                         has children to represent the front and back faces of a card.  The child that represents the back face must have
 *                                         the "oj-animation-backface" marker class.  Use this option instead of the "transform-style: preserve-3d" CSS style because
 *                                         some browsers do not support "transform-style".  See the cookbook for a Card Flip example of using this option.</p>
 * @return {Promise.<boolean>} a promise that will be resolved when the animation ends
 *
 * @export
 * @memberof oj.AnimationUtils
 */


oj.AnimationUtils.flipOut = function (element, options) {
  return oj.AnimationUtils._flip(element, options, 'flipOut', '0deg', '180deg');
};
/**
 * Animaton effect method for adding transition to a HTML element.  Caller should
 * set the new style immediately before calling this method.  This is for internal
 * use only.
 *
 * @param {Element} element  the HTML element to animate
 * @param {Object} options Options applicable to the specific animation effect.
 * @param {string=} options.delay  The delay from the time the animation is applied to time the
 * animation should begin. This may be specified in either seconds (by specifying s as the unit) or milliseconds
 * (by specifying ms as the unit). Default is "0s".
 * @param {string=} options.duration The duration that an animation should take to complete. This may be
 * specified in either seconds (by specifying s as the unit) or milliseconds (by specifying ms as the unit).
 * Default is "400ms".
 * @param {string=} options.timingFunction  One of the valid values for either CSS transition-timing-function or CSS
 * animation-timing-function. Default is "ease".
 * @param {Array} options.transitionProperties  An array of properties to transition.
 * @return {Promise|IThenable} a promise that will be resolved when the animation ends
 *
 * @export
 * @ignore
 */


oj.AnimationUtils.addTransition = function (element, options) {
  var _options = oj.AnimationUtils._mergeOptions('addTransition', options);

  return oj.AnimationUtils._animate(element, null, null, _options, _options.transitionProperties);
};

oj.AnimationUtils._createHeroParent = function () {
  var viewport = document.createElement('div');
  var body = document.body;
  body.appendChild(viewport); // @HTMLUpdateOK viewPort constructed above

  viewport.style.position = 'absolute';
  viewport.style.height = body.offsetHeight + 'px';
  viewport.style.width = body.offsetWidth + 'px';
  viewport.style.left = body.offsetLeft + 'px';
  viewport.style.top = body.offsetTop + 'px';
  viewport.style.zIndex = 2000;
  viewport.className = 'oj-animation-host-viewport';
  var host = document.createElement('div');
  host.className = 'oj-animation-host';
  viewport.appendChild(host); // @HTMLUpdateOK host is constructed above

  return host;
};

oj.AnimationUtils._removeHeroParent = function (heroParent) {
  if (heroParent) {
    var viewport = heroParent.parentNode;

    if (viewport && viewport.parentNode) {
      viewport.parentNode.removeChild(viewport);
    }
  }
};

oj.AnimationUtils._defaultHeroCreateClonedElement = function (context) {
  return context.fromElement.cloneNode(true);
};

oj.AnimationUtils._defaultHeroHideFromAndToElements = function (context) {
  var fromElement = context.fromElement;
  var toElement = context.toElement;
  fromElement.style.visibility = 'hidden';
  toElement.style.visibility = 'hidden';
};

oj.AnimationUtils._defaultHeroAnimateClonedElement = function (context) {
  return new Promise(function (resolve) {
    var heroStyle = context.clonedElement.style;
    heroStyle.transformOrigin = 'left top';
    heroStyle.transform = 'translate(0, 0) scale(1, 1)';
    requestAnimationFrame(function () {
      heroStyle.transitionDelay = context.delay;
      heroStyle.transitionDuration = context.duration;
      heroStyle.transitionTimingFunction = context.timingFunction;
      heroStyle.transitionProperty = 'transform'; // Put translate before scale because otherwise the scale factor will affect the translate value

      var transform = 'translate(' + context.translateX + 'px,' + context.translateY + 'px)';
      transform += ' scale(' + context.scaleX.toFixed(2) + ',' + context.scaleY.toFixed(2) + ')';
      heroStyle.transform = transform;

      var waitTime = oj.AnimationUtils._getTimingValue(context.delay) + oj.AnimationUtils._getTimingValue(context.duration);

      setTimeout(function () {
        resolve();
      }, waitTime);
    });
  });
};

oj.AnimationUtils._defaultHeroShowToElement = function (context) {
  var toElement = context.toElement;
  toElement.style.visibility = 'visible';
};

oj.AnimationUtils._doAnimateHero = function (fromElement, toElementSelector, resolvedOptions, toElementElapsedTime, resolve, reject) {
  var toElement = document.querySelector(toElementSelector); // Wait for toElement to appear to DOM if it is not there yet

  if (toElement == null) {
    var interval = 100;

    if (toElementElapsedTime + interval > resolvedOptions.toElementWaitTime) {
      reject('toElement not found in DOM after toElementWaitTime has expired');
    } else {
      setTimeout(function () {
        oj.AnimationUtils._doAnimateHero(fromElement, toElementSelector, resolvedOptions, toElementElapsedTime + interval, resolve, reject);
      }, interval);
    }

    return;
  }

  var fromRect = fromElement.getBoundingClientRect();
  var toRect = toElement.getBoundingClientRect();
  var translateX = toRect.left - fromRect.left;
  var translateY = toRect.top - fromRect.top;
  var scaleX = toRect.width / fromRect.width;
  var scaleY = toRect.height / fromRect.height;
  var heroContext = {
    fromElement: fromElement,
    toElement: toElement,
    clonedElement: null,
    translateX: translateX,
    translateY: translateY,
    scaleX: scaleX,
    scaleY: scaleY,
    toElementElapsedTime: toElementElapsedTime,
    delay: resolvedOptions.delay,
    duration: resolvedOptions.duration,
    timingFunction: resolvedOptions.timingFunction
  };
  var clonedElement = resolvedOptions.createClonedElement(heroContext);
  heroContext.clonedElement = clonedElement;

  var heroParent = oj.AnimationUtils._createHeroParent();

  var parentRect = heroParent.getBoundingClientRect();
  heroParent.appendChild(clonedElement);
  clonedElement.style.position = 'absolute';
  clonedElement.style.left = fromRect.left - parentRect.left + 'px';
  clonedElement.style.top = fromRect.top - parentRect.top + 'px';
  resolvedOptions.hideFromAndToElements(heroContext); // Make sure clonedElement is visible in case createClonedElement return fromElement or toElement

  clonedElement.style.visibility = 'visible';

  function _postAnimation() {
    resolvedOptions.showToElement(heroContext);

    oj.AnimationUtils._removeHeroParent(heroParent);
  }

  resolvedOptions.animateClonedElement(heroContext).then(function () {
    _postAnimation();

    resolve();
  }).catch(function (reason) {
    _postAnimation();

    reject(reason);
  });
};
/**
 * Animation effect method for animating a hero element from one location to another.
 * A hero element is an element that appears to be shared between a source location and a destination location,
 * even though there are separate source element and destination element.
 * <p>
 * The following steps are taken by this method:
 * </p>
 * <ol>
 *   <li>Create a temporary div that has a z-index higher than that of the source and destination elements.
 *   <li>Clone the source element.
 *   <li>Position the cloned element on the temporary div at the same position as the source element.
 *   <li>Hide the source and destination elements.
 *   <li>Animate the cloned element by translating and scaling its position and size towards the destination element.
 *   <li>Show the destination element.
 *   <li>Remove the temporary div together with the cloned element that is on it.
 * </ol>
 * This method provides callback parameters that can be used to override some of the steps.
 *
 * @param {Element} element The source element for the hero animation.
 * @param {Object} options Options applicable to the specific animation effect.
 * @param {string} options.toElementSelector  A CSS selector which specifies the destination element that occupies the location to animate to.
 * @param {number=} options.toElementWaitTime  The time in millisecond to wait for the destination element to become present in the DOM tree.
 * The default is 5000, which is equal to 5 seconds. No animation occurs and the promise returned by this function will be rejected if the
 * destination element is not present when toElementWaitTime expires.
 * @param {(function(AnimationUtils.HeroContext):Element)=} options.createClonedElement An optional application-provided function that returns the element used in animation.
 * <p>By default animateHero will clone the source element specified by the "fromElement" parameter. Application can override this by returning a different element.</p>
 * @param {(function(AnimationUtils.HeroContext):void)=} options.hideFromAndToElements An optional application-provided function that controls the visibility of the source and destination elements during animation.
 * <p>By default animateHero will hide both the source element and destination element while animating the cloned element.</p>
 * @param {(function(AnimationUtils.HeroContext):Promise)=} options.animateClonedElement An optional application-provided function that animates the cloned element.
 * <p>By default animateHero will move and scale the cloned element to the position and size of the destination element.</p>
 * @param {(function(AnimationUtils.HeroContext):void)=} options.showToElement An optional application-provided function that controls the visibility of the destination element after animation.
 * <p>By default animateHero will show the destination element after animation ends.</p>
 * @param {string=} options.delay  The delay from the time the animation is applied to time the
 * animation should begin. This may be specified in either seconds (by specifying s as the unit) or milliseconds
 * (by specifying ms as the unit). Default is "0s".
 * @param {string=} options.duration The duration that an animation should take to complete. This may be
 * specified in either seconds (by specifying s as the unit) or milliseconds (by specifying ms as the unit).
 * Default is "400ms".
 * @param {string=} options.timingFunction  One of the valid values for either CSS transition-timing-function or CSS
 * animation-timing-function. Default is "ease".
 * @return {Promise.<boolean>} a promise that will be resolved when the animation ends
 *
 * @export
 * @memberof oj.AnimationUtils
 */


oj.AnimationUtils.animateHero = function (element, options) {
  var fromElement = element;
  var resolvedOptions = {
    toElementWaitTime: 5000,
    createClonedElement: oj.AnimationUtils._defaultHeroCreateClonedElement,
    hideFromAndToElements: oj.AnimationUtils._defaultHeroHideFromAndToElements,
    animateClonedElement: oj.AnimationUtils._defaultHeroAnimateClonedElement,
    showToElement: oj.AnimationUtils._defaultHeroShowToElement,
    delay: '0s',
    duration: '400ms',
    timingFunction: 'ease'
  };
  var toElementElapsedTime = 0;
  Object.assign(resolvedOptions, options);
  return new Promise(function (resolve, reject) {
    if (!fromElement) {
      reject('No element specified');
    } else if (!options.toElementSelector) {
      reject('No options.toElementSelector specified');
    } else {
      oj.AnimationUtils._doAnimateHero(fromElement, options.toElementSelector, resolvedOptions, toElementElapsedTime, resolve, reject);
    }
  });
};
/**
 * All the available animation methods supported in oj.AnimationUtils
 * @typedef {Object} oj.AnimationUtils.AnimationMethods
 * @ojvalue {string} "collapse"
 * @ojvalue {string} "expand"
 * @ojvalue {string} "fadeIn"
 * @ojvalue {string} "fadeOut"
 * @ojvalue {string} "flipIn"
 * @ojvalue {string} "flipOut"
 * @ojvalue {string} "ripple"
 * @ojvalue {string} "slideIn"
 * @ojvalue {string} "slideOut"
 * @ojvalue {string} "zoomIn"
 * @ojvalue {string} "zoomOut"
 */

/**
 * The context object passed to callback functions in the animateHero method
 * @typedef {Object} oj.AnimationUtils.HeroContext
 * @property {Element} fromElement The source element
 * @property {Element} toElement The destination element
 * @property {Element|null} clonedElement The cloned element.  This property is null when createClonedElement is called.
 * It will be the value returned by createClonedElement in other callback functions.
 * @property {number} translateX The x offset of the toElement from the fromElement
 * @property {number} translateY The y offset of the toElement from the fromElement
 * @property {number} scaleX The horizontal size ratio of the toElement to the fromElement
 * @property {number} scaleY The vertical size ratio of the toElement to the fromElement
 * @property {number} toElementElapsedTime The elapsed time in millisecond that the destination element becomes present
 * in the DOM tree after animateHero is called. If desired, applications can use this information to adjust the animation.
 * For example, if the destination element takes a long time to appear, a shorter animation may be used.
 */
// --------------------------------------------------- oj.AnimationUtils Styling Start -----------------------------------------------------------
// ---------------- oj-animation-backface --------------

/**
* This is used by the "flipIn" and "flipOut" methods when the "flipTarget" option is set to "children" to flip the children of an element that represents the two faces of a card. <br/>
* The child element that represents the back face must have the "oj-animation-backface" marker class.
* @ojstyleclass oj-animation-backface
* @ojdisplayname Animation Backface
* @ojshortdesc Apply to the child element representing the back face of a card element that can be flipped. See the Help documentation for more information.
* @ojstyleselector div
* @memberof oj.AnimationUtils
*/
// --------------------------------------------------- oj.AnimationUtils Styling End -----------------------------------------------------------

  return oj.AnimationUtils;
});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojconverterutils',['ojs/ojlogger'], 
 function(Logger)
{
  "use strict";
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ConverterUtils = function ConverterUtils() {
  _classCallCheck(this, ConverterUtils);
};

ConverterUtils.getConverterInstance = function (converterOption) {
  var cTypeStr = '';
  var cOptions = {};
  var converterInstance = null;

  if (converterOption) {
    if (_typeof(converterOption) === 'object') {
      // TODO: Should we check that it duck types Converter?
      if (converterOption.parse && typeof converterOption.parse === 'function' || converterOption.format && typeof converterOption.format === 'function') {
        // we are dealing with a converter instance
        converterInstance = converterOption;
      } else {
        // check if there is a type set
        cTypeStr = converterOption.type;
        cOptions = converterOption.options || {};
      }
    }

    if (!converterInstance) {
      // either we have an object literal or just plain string.
      cTypeStr = cTypeStr || converterOption;

      if (cTypeStr && typeof cTypeStr === 'string') {
        // if we are passed a string get registered type.
        if (oj.Validation && oj.Validation.converterFactory) {
          var cf = oj.Validation.converterFactory(cTypeStr);
          return cf.createConverter(cOptions);
        } else {
          Logger.error('oj.Validation.converterFactory is not available and it is needed to support the deprecated json format for the converters property. Please include the backward compatibility "ojvalidation-base" module.');
        }
      }
    }
  }

  return converterInstance;
};

  ;return ConverterUtils;
});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojvalidator',['ojs/ojcore'], 
function(oj)
{
  "use strict";


/**
 * Validator Contract
 * @ignore
 */

/**
 *  @example <caption>Create a Validator and implement its methods.</caption>
 *
 *  //Validator to ensure that the selected time is a multiple of 15 minute interval.
 *  //This converter takes in a converter option which will be used to format the hint/error
 *  //message shown to the user. It is mandatory to pass the converter option.
 *  var TimeIncrementValidator = function (options) {
 *    if(options && options.converter){
 *      this._converter = options.converter;
 *    }
 *  };
 *  //Need to be a subclass of Validator
 *  oj.Object.createSubclass(TimeIncrementValidator, Validator, "TimeIncrementValidator");
 *
 *  // Validates if the passed in value is a multiple of 15 minute interval.
 *  // Throws an error if the validation fails.
 *  TimeIncrementValidator.prototype.validate = function (value)
 *  {
 *    if (value)
 *    {
 *      var currentTime = oj.IntlConverterUtils.isoToLocalDate(value);
 *      var previousValidValue, nextValidValue, sampleMinutes;
 *      var minutes = currentTime.getMinutes();
 *      //Check if the minute is in increment of 15 by taking a modulo
 *      if ((minutes % 15) !== 0)
 *      {
 *        sampleMinute = Math.floor((minutes / 15))*15;
 *        currentTime.setMinutes(sampleMinute);
 *        previousValidValue = oj.IntlConverterUtils.dateToLocalIso(currentTime);
 *        sampleMinute = sampleMinute+ 15;
 *        if(sampleMinute >= 60){
 *          sampleMinute = 0;
 *          currentTime.setTime(currentTime.getTime() + (60*60*1000));
 *        }
 *        currentTime.setMinutes(sampleMinute);
 *        nextValidValue = oj.IntlConverterUtils.dateToLocalIso(currentTime);
 *        throw new ValidatorError("Only multiples of 15 minute intervals are allowed.", "For example, " + this._converter.format(previousValidValue) +
 *                                     " or "+ this._converter.format(nextValidValue));
 *      }
 *    }
 *  };
 *
 *  //Generates a hint message with 4 different samples of valid values.
 *  TimeIncrementValidator.prototype.getHint = function ()
 *  {
 *    var currentTime = new Date();
 *    var hintMessage = "Only 15 minute intervals accepted, for example";
 *    //generate 4 sample values
 *    for (var i = 0; i < 4; i++) {
 *      currentTime.setMinutes(i * 15);
 *      hintMessage = hintMessage + ", " + this._converter.format(oj.IntlConverterUtils.dateToLocalIso(currentTime));
 *    }
 *    return hintMessage;
 *  };
 * @example <caption>Create a Validator and implement its methods. Bind it to the
 * JET form component which will call this 'validate' to validate the user's input.</caption>
 *  // Validator that ensures endDate is never less than start date
 *  self.endDateValidator = {
 *    'validate' : function(value)
 *    {
 *      var value =  oj.IntlConverterUtils.isoToLocalDate(value);
 *      var start = oj.IntlConverterUtils.isoToLocalDate(self.startDate());
 *      if (value && !(value.getFullYear() > start.getFullYear() ||
 *      {
 *        throw new ValidatorError('End Date cannot be less than Start Date');
 *      }
 *    },
 *    'getHint' : function() { return "End Date needs to be greater than Start Date");}
 *  };
 *  -- HTML --
 *  &lt;oj-input-date id="nextday" value="{{endDate}}"
 *  validators="{{[weekendDateValidator, endDateValidator]}}">&lt;/oj-input-date>
 * @interface
 * @name oj.Validator
 * @param {Object=} options An object which contains the options for the validator
 * @ojsignature {target: "Type", value: "interface Validator<V>", genericParameters: [{"name": "V", "description": "Type of value to be validated"}]}
 * @ojtsmodule
 * @export
 * @since 0.6.0
 *
 */
var Validator = function Validator(options) {
  this.Init(options);
}; // Subclass from oj.Object


oj.Object.createSubclass(Validator, oj.Object, 'oj.Validator');
/**
 * Initializes validator instance with the set options
 * @export
 * @ignore
 */
// eslint-disable-next-line no-unused-vars

Validator.prototype.Init = function (options) {
  Validator.superclass.Init.call(this);
};
/**
 * Validates the value.
 * The function typically returns if the validation passes and throws an error if it fails.
 *
 * @example <caption>Create a Validator and implement the validate method. Bind it to the
 * JET form component which will call this 'validate' to validate the user's input.</caption>
 *  // Validator that ensures endDate is never less than start date
 *  self.endDateValidator = {
 *    'validate' : function(value)
 *    {
 *      var value =  oj.IntlConverterUtils.isoToLocalDate(value);
 *      var start = oj.IntlConverterUtils.isoToLocalDate(self.startDate());
 *      if (value && !(value.getFullYear() > start.getFullYear() ||
 *      {
 *        throw new ValidatorError('End Date cannot be less than Start Date');
 *      }
 *    },
 *    'getHint' : function() { return "End Date needs to be greater than Start Date");}
 *  };
 *  -- HTML --
 *  &lt;oj-input-date id="nextday" value="{{endDate}}"
 *  validators="{{[weekendDateValidator, endDateValidator]}}">&lt;/oj-input-date>
 * @param {any} value to be validated
 * @return {void}
 * @throws {Error} if validation fails
 * @method validate
 * @ojsignature [{target: "Type",
 *                value: "V",
 *                for: "value"},
 *                {target: "Type",
 *                value: "void",
 *                for: "returns"}]
 * @memberof oj.Validator
 * @instance
 */

/**
 * Returns a hint that describes the validator rule.
 * @example <caption>Create a Validator and implement the getHint method. Bind it to the
 * JET form component which will show the hint.</caption>
 *  // Validator that ensures endDate is never less than start date
 *  self.endDateValidator = {
 *    'validate' : function(value)
 *    {
 *      ...
 *    },
 *    'getHint' : function() { return "End Date needs to be greater than Start Date");}
 *  };
 *  -- HTML --
 *  &lt;oj-input-date id="nextday" value="{{endDate}}"
 *  validators="{{[weekendDateValidator, endDateValidator]}}">&lt;/oj-input-date>
 * @returns {string|null} a hint string or null
 * @method getHint
 * @memberof oj.Validator
 * @ojsignature {target: "Type", value: "?(): string|null"}
 * @instance
 */

  return Validator;
});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojvalidation-error',['ojs/ojcore', 'ojs/ojmessaging'], 
function(oj, Message)
{
  "use strict";


/* global Message:false */
// oj.ConverterError

/**
 * Constructs a ConverterError instance from a summary and detail
 *
 * @param {string} summary a localized String that provides a summary of the error
 * @param {string} detail a localized String that provides a detail of the error
 * @constructor
 * @final
 * @ojtsnoexport
 * @ojtsexportastype
 * @since 0.6.0
 * @export
 */
oj.ConverterError = function (summary, detail) {
  var message = {
    summary: summary,
    detail: detail,
    severity: Message.SEVERITY_LEVEL.ERROR
  };
  this.Init(message);
};

oj.ConverterError.prototype = new Error();
/**
 * Initializes the instance.
 * @param {Object} message an Object that duck-types oj.Message which is an
 * Object with summary, detail, and severity properties.
 * @export
 * @ignore
 */

oj.ConverterError.prototype.Init = function (message) {
  var detail = message.detail;
  var summary = message.summary;
  this._message = message; // so browser can get to e.name and e.message

  this.name = 'Converter Error';
  this.message = detail || summary;
};
/**
 * Returns an Object that duck-types oj.Message which is an
 * Object with summary, detail, and severity properties.
 *
 * @return {Object} an Object that duck-types oj.Message which is an
 * Object with summary, detail, and severity properties.
 * @ojsignature {target: "Type", value: "oj.Message", for: "returns"}
 * @export
 */


oj.ConverterError.prototype.getMessage = function () {
  return this._message;
};



/* global Message:false */
// ValidatorError

/**
 * Constructs a ValidatorError instance from a summary and detail
 *
 * @param {string} summary a localized String that provides a summary of the error
 * @param {string} detail a localized String that provides a detail of the error
 * @example <caption>throw new oj.ValidationError from custom validator's validate method</caption>
 *  // A custom validator whose validate method ensures that the value is not 'junk'.
 *  self.noJunkValidator = {
 *  'validate' : function (value)
 *  {
 *    value = value + "";
 *    if (value && value.toLowerCase()  === "junk")
 *    {
 *      throw new oj.ValidatorError("Invalid value", "You cannot enter a value that is 'junk'!!");
 *    }
 *    return;
 *    }
 *  };
 * @constructor
 * @final
 * @ojtsnoexport
 * @ojtsexportastype
 * @ojtsimport {module: "ojmessaging", type: "AMD", importName: "Message"}
 * @since 0.6.0
 * @export
 */
oj.ValidatorError = function (summary, detail) {
  var message = {
    summary: summary,
    detail: detail,
    severity: Message.SEVERITY_LEVEL.ERROR
  };
  this.Init(message);
};

oj.ValidatorError.prototype = new Error();
/**
 * Initializes the instance.
 * @param {Object} message an Object that duck-types oj.Message which is an
 * Object with summary, detail, and severity keys. The severity is
 * oj.Message.SEVERITY_LEVEL['ERROR'].
 * @export
 * @ignore
 */

oj.ValidatorError.prototype.Init = function (message) {
  var detail = message.detail;
  var summary = message.summary;
  this._message = message; // so browser can get to e.name and e.message

  this.name = 'Validator Error';
  this.message = detail || summary;
};
/**
 * Returns an Object that duck-types oj.Message which is an
 * Object with summary, detail, and severity properties. The severity is
 * oj.Message.SEVERITY_LEVEL['ERROR']
 *
 * @example <caption>get the oj.ValidationError that was thrown and get the message</caption>
 * var ojmessage = valError.getMessage();
 * var severity = ojmessage['severity'] || oj.Message.SEVERITY_LEVEL['ERROR'];
 * var summary = ojmessage['summary'];
 * var detail = ojmessage['detail'];
 * @returns {Object} an Object that duck-types oj.Message which is an
 * Object with summary, detail, and severity properties.
 * The severity is
 * oj.Message.SEVERITY_LEVEL['ERROR']
 * @ojsignature {target: "Type", value: "oj.Message", for: "returns"}
 * @export
 */


oj.ValidatorError.prototype.getMessage = function () {
  return this._message;
};

});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojvalidator-required',['ojs/ojcore', 'ojs/ojtranslation', 'ojs/ojvalidator', 'ojs/ojvalidation-error'], 
function(oj, Translations, Validator)
{
  "use strict";


/* global Translations:false, Validator:false */

/**
 * Constructs a RequiredValidator that ensures that the value provided is not empty.
 * @param {Object=} options an object literal used to provide an optional hint and error message.<p>
 *
 * @export
 * @constructor
 * @final
 * @augments oj.Validator
 * @name oj.RequiredValidator
 * @ojtsimport {module: "ojvalidator", type: "AMD", importName: "Validator"}
 * @ojtsmodule
 * @ojsignature [{target: "Type", value: "class RequiredValidator implements Validator<object|string|number>"},
 *               {target: "Type", value: "oj.RequiredValidator.ValidatorOptions", for: "options", jsdocOverride: true}]
 * @since 0.6.0
 * @see oj.AsyncRequiredValidator
 *
 */
var RequiredValidator = function RequiredValidator(options) {
  this.Init(options);
}; // Subclass from oj.Object or oj.Validator. It does not matter


oj.Object.createSubclass(RequiredValidator, Validator, 'oj.RequiredValidator'); // key to access required validator specific resources in the bundle

RequiredValidator._BUNDLE_KEY_DETAIL = 'oj-validator.required.detail';
RequiredValidator._BUNDLE_KEY_SUMMARY = 'oj-validator.required.summary';
/**
 * @typedef {object} oj.RequiredValidator.ValidatorOptions
 * @property {string=} hint an optional hint text. There is no default hint provided by this
 * validator.
 * @property {string=} label - an optional label text used when the {label} token is passed
 * into messageSummary or messageDetail.
 * @property {string=} messageSummary - an optional custom error message summarizing the
 * error. When not present, the default message summary is the resource defined with the key
 * <code class="prettyprint">oj-validator.required.summary</code>.<p>
 * <p>The messageSummary string is passed as the 'pattern' parameter to
 * [oj.Translations.html#applyParameters]{@link oj.Translations}. As stated in
 * that documentation, if you are using a reserved character, you need to escape it with
 * a dollar character ('$').
 * </p>
 * Tokens: {label} - this token can be used to substitute the label of the component at runtime. </p>
 * <p>
 * Example:<br/>
 * "'{label}' Required"<br/>
 * </p>
 * @property {string=} messageDetail - a custom error message used for creating detail part
 * of message, when the value provided is empty. When not present, the default message detail is the
 * resource defined with the key <code class="prettyprint">oj-validator.required.detail</code>.
 * <p>The messageDetail string is passed as the 'pattern' parameter to
 * [oj.Translations.html#applyParameters]{@link oj.Translations}. As stated in
 * that documentation, if you are using a reserved character, you need to escape it with
 * a dollar character ('$').
 * </p>
 * <p>Tokens: {label} - this token can be used to substitute the label of the component at runtime.</p>
 * <p>
 * Example:<br/>
 * "A value is required for the field '{label}'."<br/>
 * </p>
 */

/**
 * Initializes validator instance with the set options
 * @param {Object=} options
 * @memberof oj.RequiredValidator
 * @instance
 * @ignore
 */

RequiredValidator.prototype.Init = function (options) {
  RequiredValidator.superclass.Init.call(this);
  this._options = options;
};
/**
 * Validates value to be non-empty
 *
 * @param {any} value value that is being validated
 * @returns {void}
 * @throws {Error} when fails required-ness check
 * @ojsignature {target: "Type", for: "returns",
 *                value: "void"}
 * @memberof oj.RequiredValidator
 * @instance
 * @export
 * @method validate
 */


RequiredValidator.prototype.validate = function (value) {
  var detail;
  var label = '';
  var localizedDetail;
  var localizedSummary;
  var summary;
  var params = {}; // checks for empty arrays and String. Objects are considered non-null.

  if (value !== undefined && value !== null && !((typeof value === 'string' || value instanceof Array) && value.length === 0)) {
    return;
  }

  if (this._options) {
    // we have deprecated support for message param and instead use messageDetail.
    detail = this._options.messageDetail || this._options.message || null;
    summary = this._options.messageSummary || null;
    label = this._options.label || '';
  }

  params = {
    label: label
  };
  localizedSummary = summary ? Translations.applyParameters(summary, params) : Translations.getTranslatedString(this._getSummaryKey(), params);
  localizedDetail = detail ? Translations.applyParameters(detail, params) : Translations.getTranslatedString(this._getDetailKey(), params);
  throw new oj.ValidatorError(localizedSummary, localizedDetail);
};
/**
 * A message to be used as hint, when giving a hint on the expected pattern. There is no default
 * hint for this property.
 *
 * @returns {string|null} a hint message or null if no hint is available in the options
 * @memberof oj.RequiredValidator
 * @instance
 * @export
 * @method getHint
 */


RequiredValidator.prototype.getHint = function () {
  var hint = '';

  if (this._options && this._options.hint) {
    hint = Translations.getTranslatedString(this._options.hint);
  }

  return hint;
};

RequiredValidator.prototype._getSummaryKey = function () {
  return RequiredValidator._BUNDLE_KEY_SUMMARY;
};

RequiredValidator.prototype._getDetailKey = function () {
  return RequiredValidator._BUNDLE_KEY_DETAIL;
};

  return RequiredValidator;
});
/*! jQuery UI - v1.12.1 - 2016-09-15
* http://jqueryui.com
* Copyright jQuery Foundation and other contributors; Licensed  */
!function(t){"function"==typeof define&&define.amd?define('jqueryui-amd/position',["jquery","./version"],t):t(jQuery)}(function(t){return function(){function i(t,i,o){return[parseFloat(t[0])*(c.test(t[0])?i/100:1),parseFloat(t[1])*(c.test(t[1])?o/100:1)]}function o(i,o){return parseInt(t.css(i,o),10)||0}function e(i){var o=i[0];return 9===o.nodeType?{width:i.width(),height:i.height(),offset:{top:0,left:0}}:t.isWindow(o)?{width:i.width(),height:i.height(),offset:{top:i.scrollTop(),left:i.scrollLeft()}}:o.preventDefault?{width:0,height:0,offset:{top:o.pageY,left:o.pageX}}:{width:i.outerWidth(),height:i.outerHeight(),offset:i.offset()}}var l,n=Math.max,f=Math.abs,s=/left|center|right/,h=/top|center|bottom/,r=/[\+\-]\d+(\.[\d]+)?%?/,p=/^\w+/,c=/%$/,a=t.fn.position;t.position={scrollbarWidth:function(){if(void 0!==l)return l;var i,o,e=t("<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"),n=e.children()[0];return t("body").append(e),i=n.offsetWidth,e.css("overflow","scroll"),o=n.offsetWidth,i===o&&(o=e[0].clientWidth),e.remove(),l=i-o},getScrollInfo:function(i){var o=i.isWindow||i.isDocument?"":i.element.css("overflow-x"),e=i.isWindow||i.isDocument?"":i.element.css("overflow-y"),l="scroll"===o||"auto"===o&&i.width<i.element[0].scrollWidth,n="scroll"===e||"auto"===e&&i.height<i.element[0].scrollHeight;return{width:n?t.position.scrollbarWidth():0,height:l?t.position.scrollbarWidth():0}},getWithinInfo:function(i){var o=t(i||window),e=t.isWindow(o[0]),l=!!o[0]&&9===o[0].nodeType,n=!e&&!l;return{element:o,isWindow:e,isDocument:l,offset:n?t(i).offset():{left:0,top:0},scrollLeft:o.scrollLeft(),scrollTop:o.scrollTop(),width:o.outerWidth(),height:o.outerHeight()}}},t.fn.position=function(l){if(!l||!l.of)return a.apply(this,arguments);l=t.extend({},l);var c,d,g,u,m,w,W=t(l.of),v=t.position.getWithinInfo(l.within),y=t.position.getScrollInfo(v),H=(l.collision||"flip").split(" "),b={};return w=e(W),W[0].preventDefault&&(l.at="left top"),d=w.width,g=w.height,u=w.offset,m=t.extend({},u),t.each(["my","at"],function(){var t,i,o=(l[this]||"").split(" ");1===o.length&&(o=s.test(o[0])?o.concat(["center"]):h.test(o[0])?["center"].concat(o):["center","center"]),o[0]=s.test(o[0])?o[0]:"center",o[1]=h.test(o[1])?o[1]:"center",t=r.exec(o[0]),i=r.exec(o[1]),b[this]=[t?t[0]:0,i?i[0]:0],l[this]=[p.exec(o[0])[0],p.exec(o[1])[0]]}),1===H.length&&(H[1]=H[0]),"right"===l.at[0]?m.left+=d:"center"===l.at[0]&&(m.left+=d/2),"bottom"===l.at[1]?m.top+=g:"center"===l.at[1]&&(m.top+=g/2),c=i(b.at,d,g),m.left+=c[0],m.top+=c[1],this.each(function(){var e,s,h=t(this),r=h.outerWidth(),p=h.outerHeight(),a=o(this,"marginLeft"),w=o(this,"marginTop"),x=r+a+o(this,"marginRight")+y.width,T=p+w+o(this,"marginBottom")+y.height,L=t.extend({},m),P=i(b.my,h.outerWidth(),h.outerHeight());"right"===l.my[0]?L.left-=r:"center"===l.my[0]&&(L.left-=r/2),"bottom"===l.my[1]?L.top-=p:"center"===l.my[1]&&(L.top-=p/2),L.left+=P[0],L.top+=P[1],e={marginLeft:a,marginTop:w},t.each(["left","top"],function(i,o){t.ui.position[H[i]]&&t.ui.position[H[i]][o](L,{targetWidth:d,targetHeight:g,elemWidth:r,elemHeight:p,collisionPosition:e,collisionWidth:x,collisionHeight:T,offset:[c[0]+P[0],c[1]+P[1]],my:l.my,at:l.at,within:v,elem:h})}),l.using&&(s=function(t){var i=u.left-L.left,o=i+d-r,e=u.top-L.top,s=e+g-p,c={target:{element:W,left:u.left,top:u.top,width:d,height:g},element:{element:h,left:L.left,top:L.top,width:r,height:p},horizontal:o<0?"left":i>0?"right":"center",vertical:s<0?"top":e>0?"bottom":"middle"};d<r&&f(i+o)<d&&(c.horizontal="center"),g<p&&f(e+s)<g&&(c.vertical="middle"),n(f(i),f(o))>n(f(e),f(s))?c.important="horizontal":c.important="vertical",l.using.call(this,t,c)}),h.offset(t.extend(L,{using:s}))})},t.ui.position={fit:{left:function(t,i){var o,e=i.within,l=e.isWindow?e.scrollLeft:e.offset.left,f=e.width,s=t.left-i.collisionPosition.marginLeft,h=l-s,r=s+i.collisionWidth-f-l;i.collisionWidth>f?h>0&&r<=0?(o=t.left+h+i.collisionWidth-f-l,t.left+=h-o):r>0&&h<=0?t.left=l:h>r?t.left=l+f-i.collisionWidth:t.left=l:h>0?t.left+=h:r>0?t.left-=r:t.left=n(t.left-s,t.left)},top:function(t,i){var o,e=i.within,l=e.isWindow?e.scrollTop:e.offset.top,f=i.within.height,s=t.top-i.collisionPosition.marginTop,h=l-s,r=s+i.collisionHeight-f-l;i.collisionHeight>f?h>0&&r<=0?(o=t.top+h+i.collisionHeight-f-l,t.top+=h-o):r>0&&h<=0?t.top=l:h>r?t.top=l+f-i.collisionHeight:t.top=l:h>0?t.top+=h:r>0?t.top-=r:t.top=n(t.top-s,t.top)}},flip:{left:function(t,i){var o,e,l=i.within,n=l.offset.left+l.scrollLeft,s=l.width,h=l.isWindow?l.scrollLeft:l.offset.left,r=t.left-i.collisionPosition.marginLeft,p=r-h,c=r+i.collisionWidth-s-h,a="left"===i.my[0]?-i.elemWidth:"right"===i.my[0]?i.elemWidth:0,d="left"===i.at[0]?i.targetWidth:"right"===i.at[0]?-i.targetWidth:0,g=-2*i.offset[0];p<0?(o=t.left+a+d+g+i.collisionWidth-s-n,(o<0||o<f(p))&&(t.left+=a+d+g)):c>0&&(e=t.left-i.collisionPosition.marginLeft+a+d+g-h,(e>0||f(e)<c)&&(t.left+=a+d+g))},top:function(t,i){var o,e,l=i.within,n=l.offset.top+l.scrollTop,s=l.height,h=l.isWindow?l.scrollTop:l.offset.top,r=t.top-i.collisionPosition.marginTop,p=r-h,c=r+i.collisionHeight-s-h,a="top"===i.my[1],d=a?-i.elemHeight:"bottom"===i.my[1]?i.elemHeight:0,g="top"===i.at[1]?i.targetHeight:"bottom"===i.at[1]?-i.targetHeight:0,u=-2*i.offset[1];p<0?(e=t.top+d+g+u+i.collisionHeight-s-n,(e<0||e<f(p))&&(t.top+=d+g+u)):c>0&&(o=t.top-i.collisionPosition.marginTop+d+g+u-h,(o>0||f(o)<c)&&(t.top+=d+g+u))}},flipfit:{left:function(){t.ui.position.flip.left.apply(this,arguments),t.ui.position.fit.left.apply(this,arguments)},top:function(){t.ui.position.flip.top.apply(this,arguments),t.ui.position.fit.top.apply(this,arguments)}}}}(),t.ui.position});
(function() {function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

define('ojs/ojvcomponent',['exports', 'ojs/ojcore-base', 'ojs/ojcontext', 'ojs/ojdefaultsutils', 'ojs/ojcustomelement'], function (exports, oj, Context, ojdefaultsutils, ojcustomelement) {
  'use strict';
  /**
   * @license
   * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
   * The Universal Permissive License (UPL), Version 1.0
   * as shown at https://oss.oracle.com/licenses/upl/
   * @ignore
   */

  /**
   * Class decorator for VComponent custom elements. Takes the tag name
   * of the custom element.
   * @param {string} tagName The custom element tag name
   * @name customElement
   * @function
   * @memberof! VComponent
   * @ojdecorator
   */

  /**
   * Property decorator for VComponent properties whose default value is determined at
   * runtime and returned via the getter method passed to the decorator.
   * @param {Function} defaultGetter The method to call to retrieve the default value
   * @name dynamicDefault
   * @function
   * @memberof! VComponent
   * @ojdecorator
   */

  /**
   * Property decorator for VComponent properties which the component may update with
   * new values. Takes an optional object with a readOnly key that should be true if the
   * property is only updated by the component.
   * @param {object=} options The options for this decorator
   * @param {boolean} options.readOnly True if only the component can update the property
   * @name _writeback
   * @function
   * @memberof! VComponent
   * @ojdecorator
   * @ignore
   */

  /**
   * Method decorator for VComponent methods that should be exposed on the custom element.
   * Non decorated VComponent methods will not be made available on the custom element.
   * @name method
   * @function
   * @memberof! VComponent
   * @ojdecorator
   */

  /**
   * Property decorator for VComponent properties which are not component properties,
   * but are global properties that the VComponent wishes to get updates for, e.g. tabIndex or aria-label.
   * @name rootProperty
   * @function
   * @memberof! VComponent
   * @ojdecorator
   */

  /**
   * Method decorator for VComponent that binds a specified method to the component instance 'this'
   * and passes provided options to the addEventListener()/removeEventListener() calls, when the method is used as a listener.
   * @param {object=} options The options for this decorator
   * @param {boolean=} options.passive True indicates that the listener will never call preventDefault().
   * @param {boolean=} options.capture True indicates that events of this type will be dispatched to the registered listener
   *                                  before being dispatched to any target beneath it in the DOM tree.
   * @name listener
   * @function
   * @memberof! VComponent
   * @ojdecorator
   */

  /**
   * Property decorator for VComponent event callback properties to indicate they bubble.
   * @param {object=} options The options for this decorator
   * @param {boolean} options.bubbles True if only the component can update the property
   * @name event
   * @function
   * @memberof! VComponent
   * @ojdecorator
   */

  /**
   * @license
   * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
   * The Universal Permissive License (UPL), Version 1.0
   * as shown at https://oss.oracle.com/licenses/upl/
   * @ignore
   */

  /**
   * @class VComponent
   * @param {Object} props The passed in component properties
   * @ojsignature [{
   *                target: "Type",
   *                value: "abstract class VComponent<P extends object = any, S extends object = any>",
   *                genericParameters: [{"name": "P", "description": "Type of the props object"},
   *                                    {"name": "S", "description": "Type of the state object"}]
   *               },
   *               {target: "Type", value: "Readonly<P>", for: "props"}]
   * @constructor
   * @since 9.0.0
   * @ojtsimport {module: "ojmetadata", type: "AMD", importName:"MetadataTypes"}
   * @ojmodule ojvcomponent
   * @classdesc <p>
   * <b>Note: the VComponent API is currently in Experimental status.</b>
   * The APIs discussed in this documentation are subject to change.  More specifically,
   * VComponent authors may be required to make changes to their component implementations
   * when upgrading to future versions of JET.
   * </p>
   * <p>
   * The VComponent base class provides a mechanism for defining JET
   * <a href="CompositeOverview.html">Custom Components</a>.
   * Like the JET <a href="ComponentTypeOverview.html#corecomponents">Core Components</a>
   * and composite components, VComponent-based components
   * are exposed as custom elements. From the application developerâs perspective, these
   * custom elements are (essentially) indistinguishable from JETâs other component types.
   * Where VComponents differ is in the component implementation strategy: VComponents produce
   * content via virtual DOM rendering.
   * </p>
   * <p>
   * To create a new VComponent-based custom component, the component author typically does the following:
   * <ul>
   *   <li>Implements a class that extends VComponent. This class must be authored in TypeScript.</li>
   *   <li>Overrides the <a href="#render">render()</a> method to return a virtual DOM representation
   *       of the componentâs content.</li>
   *   <li>Sets the &#64;customElement() decorator with the custom element tag name passed in as a parameter.</li>
   *   <li>Defines the public contract of the custom element.
   *   <ul>
   *     <li><b>Properties: </b>defined as members of the Props class.</li>
   *     <li><b>Methods: </b>defined as methods of the VComponent class and marked for exposure on the custom element using the &#64;method decorator.</li>
   *     <li><b>Events: </b>defined as members of the Props class using the naming convention on[EventName] and having type
   *     <a href="#Action">Action</a> or <a href="#CancelableAction">CancelableAction</a>.</li>
   *     <li><b>Slots: </b>defined as members of the Props class having type <a href="#Slot">Slot</a>.</li>
   *   </ul>
   * </ul>
   * </p>
   * <p>
   * Given the above, JET generates an HTMLElement subclass and registers this as a custom
   * element with the browser. These VComponent-based custom elements can then be used anywhere
   * that other JET components are used, and application developers can leverage typical JET
   * functionality such as data binding, slotting, etc.
   * </p>
   * <p>
   * A minimal VComponent subclass is shown below:
   * </p>
   * <pre class="prettyprint"><code>
   * import { h, VComponent, customElement } from "ojs/ojvcomponent";
   * import "ojs/ojavatar";
   *
   * class Props {
   *   initials?: string = '';
   *   fullName?: string = '';
   *   department?: 'Billing' | 'Sales' | 'Engineering';
   *   rank?: Rank = { level: 1, title: 'entry level' };
   * }
   *
   * type Rank = {
   *   level: number,
   *   title: string
   * };
   *
   * &#64;customElement('oj-sample-employee')
   * export class SampleEmployee extends VComponent&lt;Props> {
   *
   *   protected render(): VComponent.VNode {
   *     return (
   *       &lt;div>
   *         &lt;oj-avatar initials={this.props.initials} />
   *         &lt;span>{this.props.fullName}&lt;/span>
   *       &lt;/div>
   *     );
   *   }
   * }
   * </code></pre>
   *
   * <h3 id="rendering">
   *  Rendering
   *  <a class="bookmarkable-link" title="Bookmarkable Link" href="#rendering"></a>
   * </h3>
   * <p>
   * Every VComponent class must provide an implementation of the <a href="#render">render()</a> method.
   * This method returns a tree of virtual DOM nodes that represents the component's content.
   * The return value can take one of two forms:
   * <ol>
   *   <li>The render function can return a single virtual DOM node representing the root
   *       custom element and any child content specified as virtual DOM children.  If the
   *       component needs to modify root attributes, needs to set a ref callback on the root
   *       custom element, or contains multiple virtual DOM children, this return value form
   *       <i>must</i> be used.
   *   <li>If the component's content consists of a single virtual DOM child, a single virtual
   *       DOM node representing the child node may be returned, omitting a node representing
   *       the root custom element.</li>
   * </ol>
   * While it is always acceptable to include a virtual DOM node representing the root
   * custom element as in #1, the return form in #2 is supported as a convenience.  In many cases, the root
   * virutal DOM node can be omitted.
   * </p>
   * <p>
   * Virtual DOM nodes are plain old JavaScript objects that specify the node type
   * (typically the elementâs tag name), properties and children. This information is
   * used by the underlying virtual DOM engine to produce live DOM (i.e. by calling
   * document.createElement()).
   * </p>
   * <p>
   * Virtual DOM nodes can be created in one of two ways:
   * <ul>
   *   <li>By calling the virtual DOM node factory function, which is exported
   *    from the ojs/ojvcomponent module under the name "h".  The <code>h</code>
   *    factory function takes the type, properties and children and returns a
   *    virtual DOM node.</li>
   *   <li>Declaratively via TSX (a TypeScript flavor of JSX).</li>
   * </ul>
   * </p>
   * <p>
   * The latter approach is strongly preferred as it results in more readable code. A build-time transformation step
   * will ultimately convert the TSX markup into calls to <code>h()</code> that will be executed at run-time.
   * </p>
   * <p>
   * Note that in either case, the virtual DOM factory function must be imported as
   * an import named "h".
   * </p>
   * <p>
   * The <a href="#render">render()</a> method will be called whenever component state or properties change to return the new VDOM. The virtual
   * component will then diff the VDOM and patch the live DOM with updates. As custom elements,
   * these virtual components are used in the same way as other JET components, supporting data binding
   * and slotting.
   * </p>
   * <p>
   *
   * <h3 id="jsx">
   *  JSX Syntax
   *  <a class="bookmarkable-link" title="Bookmarkable Link" href="#jsx"></a>
   * </h3>
   * <p>
   * Virtual component render functions support the use of JSX which is an XML
   * syntax that looks similar to HTML, but supports a different attribute syntax.
   * </p>
   *
   * <h4>JSX Attributes</h4>
   * <p>
   * Component properties, global HTMLElement properties, event listeners, ref, and key attributes
   * can all be specified using the virtual component JSX attribute syntax. JSX expects the
   * <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement">HTMLElement</a>
   * property names for all JSX attributes except for class and for. In cases where an attribute does not have an
   * equivalent property on the HTMLElement (data-, aria-, role, etc), the attribute name
   * should be used. The style attribute is special cased and only supports object values
   * e.g. style={ {color: 'blue', fontSize: '12px'} }. Primitive JSX attribute values can
   * be set directly using the equal operator, or within {...} brackets for JavaScript values
   * e.g. the style example above.</p>
   *
   * The JET <a href="CustomElementOverview.html#ce-databind-syntax-section">data binding syntax</a>
   * using double curly or square brackets is not supported when using JSX.  Additionally, subproperty
   * syntax (e.g. complexProperty.subProperty={...}) is not supported; when dealing with complex-typed properties,
   * the full value must be specified (i.e. complexProperty={ {subProperty: ...} }).
   * </p>
   *
   * <h4>class</h4>
   * <p>
   * The class JSX attribute supports space delimited class names in addition to an
   * Object whose keys are individual style classes and whose values are booleans to determine
   * whether those style classes should be present in the DOM.
   * (e.g. class={ {'oj-hover': isHovered} }).
   * </p>
   *
   * <h4>Event Listeners</h4>
   * <p>
   * Event listeners follow a 'on'[EventName] naming syntax e.g.
   * onClick={clickListener} and unlike data bound on-click listeners set on the root
   * custom element, JSX event listeners will only receive a single event parameter.
   * Use the &#64;listener decorator to bind an event listener to the component instance - 'this'.
   * The &#64;listener decorator accepts an options object that would be passed to the
   * DOM addEventListener() method for specifying capture or passive listeners.
   *
   * </p>
   * <pre class="prettyprint"><code>
   * import { h, VComponent, customElement, listener } from "ojs/ojvcomponent";
   *
   * &#64;customElement('oj-sample-component')
   * export class SampleComponent extends VComponent {
   *
   *   &#64;listener({ passive: true })
   *   private _touchStartHandler(event) {
   *     // handler code
   *   }
   *
   *   protected render(): VComponent.VNode {
   *     return (
   *       &lt;div onTouchstart={this._touchStartHandler}>
   *         &hellip;
   *       &lt;/div>
   *     );
   *   }
   * }
   * </code></pre>
   *
   * <h4 id="refs">
   *  Refs
   *  <a class="bookmarkable-link" title="Bookmarkable Link" href="#refs"></a>
   * </h4>
   * <p>
   * While we recommend that rendering is done declaratively, for use cases where
   * a reference to a DOM node is necessary, a ref attribute
   * along with a callback can be set on the virtual node within the render function.
   * The callback function will be called with either a DOM node when using the element syntax
   * or a VComponent instance when using the class syntax after the node has been inserted
   * into the DOM. The ref callback will be called again with null when the node has been
   * unmounted. See the <a href="#lifecycle">lifecycle doc</a> for ref callback
   * ordering in relation to other lifecycle methods.
   * </p>
   * <pre class="prettyprint"><code>
   * import { h, VComponent, customElement } from "ojs/ojvcomponent";
   *
   * &#64;customElement('oj-sample-component')
   * export class SampleComponent extends VComponent {
   *   private _scrollingDiv: HTMLDivElement;
   *
   *   protected render(): VComponent.VNode {
   *     return (
   *       &lt;div ref={this._setScrollingDiv}>
   *         &hellip;
   *       &lt;/div>
   *     );
   *   }
   *
   *   protected mounted(): void {
   *     this._adjustScrollingDiv();
   *   }
   *
   *   protected updated(oldProps: Readonly&lt;Props>, oldState: Readonly&lt;State>): void
   *     this._adjustScrollingDiv();
   *   }
   *
   *   private _setScrollingDiv = (elem) => {
   *     this._scrollingDiv = elem as HTMLDivElement;
   *   }
   *
   *   private _adjustScrollingDiv(): void {
   *     // Perform some calculations
   *     &hellip;
   *     this._scrollingDiv.style.height = calculatedValue;
   *   }
   *
   * }
   * </code></pre>
   *
   * <h4>Keys</h4>
   * <p>
   * When rendering lists of virtual nodes, it may be beneficial to set key attributes
   * in JSX to help distinguish between insertions, deletions, and updates. Without keys,
   * the VComponent diffing logic will compare the old and new virtual node lists in order,
   * so an insertion before the first virtual node will result in a diff for all subsequent
   * virtual nodes without the key attribute. The key can be of type string or number.
   * </p>
   *
   * <h4>Root Attributes</h4>
   * <p>
   * In general, we do not recommend modifying core HTML properties on the custom element to
   * avoid overriding application set values. However in cases where this is necessary
   * (e.g. moving or copying attributes for accessibility), authors should register properties
   * they plan to update or listen to changes from as members of their Props class, marked with the &#64;rootProperty decorator.
   * These root properties will then be populated in the component's <code>this.props</code> object as
   * long as they are present in the live DOM; unlike component properties, no default values will be made available
   * in <code>this.props</code> for root properties. When rendering, only core HTML properties that are specifically marked with the &#64;rootProperty decorator will be
   * reflected in the live DOM on the root custom element; any other core HTML properties will be ignored.
   * Components will be notified of changes to root properties similar to component properties and trigger a rerender.
   * </p>
   *
   * <p>
   * Style and class properties can be set on the root custom element and are applied additively to the application-provided
   * style and class.  Event listeners can be added using the on[PropertyName] syntax in the root element within the component's
   * <a href="#render">render()</a> method and will be added or removed using the DOM's addEventListener and removeEventListener methods.
   * Style, class, and event listeners can always be specified on the root custom element and do not need to be declared
   * as members of the Props class unlike other root properties.
   * </p>
   *
   * <pre class="prettyprint"><code>
   *   protected render(): VComponent.VNode {
   *     return (
   *       &lt;oj-sample-component onClick={this._clickListener} style={ {color: red} } class='my-class-name'>
   *         &lt;div>&hellip;&lt;/div>
   *       &lt;/oj-sample-component>
   *     );
   *   }
   * </code></pre>
   *
   * <p>
   * Components often need to generate unique IDs for internal DOM. The <a href="#uniqueId">uniqueId()</a> method can
   * be called to retrieve an id that is unique to the component instance (matching the live DOM if it has been specified)
   * that can be used e.g. as a prefix for IDs on internal DOM.
   * </p>
   *
   * <h3 id="updates">
   *  State Updates
   *  <a class="bookmarkable-link" title="Bookmarkable Link" href="#updates"></a>
   * </h3>
   * <p>
   * Components may track internal state that is not reflected through their
   * properties. There is a state mechanism for supporting this. Components
   * should initialize their state objects in their constructors. After that,
   * components should treat their <code>this.state</code> objects as immutable
   * and call <a href="#updateState">updateState</a> to request a
   * state update.
   * </p>
   * <p> The updateState() method does not immediately update the state of the component,
   * it just puts the update in a queue to be processed later. The framework will batch
   * multiple updates together to make rendering more efficient. It will schedule
   * the change and rerender the component. Consider using function callback instead
   * of an object when updating the state in order to avoid stale data for the state.
   * Calls to updateState() will only cause the component to rerender if the end result
   * differs from the original state.
   * </p>
   * <pre class="prettyprint"><code>
   * import { h, VComponent, customElement } from "ojs/ojvcomponent";
   *
   * class Props { &hellip; }
   *
   * type State = {
   *   foo: boolean,
   *   bar: boolean
   * }
   *
   * &#64;customElement('oj-sample-component')
   * export class SampleComponent extends VComponent&lt;Props, State> {
   *   constructor(props: Readonly&lt;Props>) {
   *     // State should be instantiated in the constructor
   *     this.state = {
   *       foo: true,
   *       bar: false
   *     }
   *   }
   *
   *   &#64;listener()
   *   private _handleClick() {
   *     // Update state in response to user interaction, triggering a
   *     // re-render.
   *     this.updateState({ foo: false });
   *   }
   * }
   * </code></pre>
   *
   * <h3 id="defaults">
   *  Default Values
   *  <a class="bookmarkable-link" title="Bookmarkable Link" href="#defaults"></a>
   * </h3>
   * <p>
   * Static default values for components can be provided using direct value assignments
   * on the corresponding members in the Props class.  In addition, dynamic default values
   * can be specified using the &#64;dynamicDefault() decorator with a parameter representing
   * a method that should be called to retrieve the default value at runtime.</p>
   *
   * <p>Object- or Array-typed default values will recursively frozen before being returned
   * as property values to prevent subsequent modification.  Any Objects that are not POJOs
   * <i>will not be frozen</i> (including references to them inside other Objects or Arrays) and
   * it is the component's responsibility to ensure that default values of this type (e.g. class instances)
   * are immutable.
   * </p>
   * <pre class="prettyprint"><code>
   * import { h, VComponent, customElement, dynamicDefault } from "ojs/ojvcomponent";
   *
   * function computeDynamicDefault(): string { &hellip; }
   *
   * class Props {
   *   primitiveProperty?: number = 0;
   *   complexProperty?: {index: number} = {index: 0};
   *   classProperty?: MyType = new ImmutableMyTypeImpl();
   *   &#64;dynamicDefault(computeDynamicDefault) dynamicProperty?: string;
   * }
   *
   * &#64;customElement('oj-sample-component')
   * export class SampleComponent extends VComponent&lt;Props> {
   *   &hellip;
   * }
   * </code></pre>
   *
   * <h3 id="lifecycle">
   *  Lifecycle Methods
   *  <a class="bookmarkable-link" title="Bookmarkable Link" href="#lifecycle"></a>
   * </h3>
   * <p>
   * In addition to the required render method, virtual components have several optional lifecycle
   * methods that give the component hooks to setup/cleanup global listeners, do geometry management,
   * and update state. See the API doc for each lifecycle method for details.
   * </p>
   *
   * <h4>Mount</h4>
   * <ul>
   *   <li><a href="#VComponent">constructor()</a></li>
   *   <li>(static) <a href="#initStateFromProps">initStateFromProps()</a></li>
   *   <li><a href="#render">render()</a></li>
   *   <li><a href="#refs">ref callbacks</a></li>
   *   <li><a href="#mounted">mounted()</a></li>
   * </ul>
   *
   * <h4>Update</h4>
   * <ul>
   *   <li>(static) <a href="#updateStateFromProps">updateStateFromProps()</a></li>
   *   <li><a href="#render">render()</a></li>
   *   <li><a href="#refs">ref callbacks</a></li>
   *   <li><a href="#update">updated()</a></li>
   * </ul>
   *
   * <h4>Unmount</h4>
   * <ul>
   *   <li><a href="#unmounted">unmounted()</a></li>
   *   <li><a href="#refs">ref callbacks</a></li>
   *
   * </ul>
   *
   * <h3 id="slots">
   *  Slotting
   *  <a class="bookmarkable-link" title="Bookmarkable Link" href="#slots"></a>
   * </h3>
   * <p>
   * Component authors declare their expected slots as members of their Props class.  The various slot types are exposed as follows:
   * <ul>
   *   <li>Default slot - exposed through the <code>children</code> member with type <code><a href="#VNode">VNode</a>[]</code>.</li>
   *   <li>Ordinary slot - exposed through a member with type <code><a href="#Slot">Slot</a></code> whose name corresponds to the slot name.</li>
   *   <li>Template slots - exposed through a member with type <code><a href="#Slot">Slot&lt;SlotContextType></a></code> whose name corresponds to the slot name.  <code>SlotContextType</code> represents the data type for this template slot (corresponding to the type of the $current object).</li>
   *   <li>Dynamic slots - any slots that are not explicitly declared as one of the three previous types will be exposed in a Map of type <code><a href="#DynamicSlots">DynamicSlots</a></code>.  This may be useful in cases where the set of expected slots cannot be statically defined, but is determined
   *       by the component through other means at runtime.  The dynamic slot map may contain either ordinary slots or template slots.</li>
   * </ul>
   * Note that in all of the cases above, the component author must declare the corresponding properties in their Props class in order to receive access to slot content.
   * </p>
   * <p>
   * During component rendering, default slot content can simply be inlined as with any other virtual DOM content.  Components can test for the existence of the <code>children</code> property to decide whether to render default content.
   * </p>
   * <pre class="prettyprint"><code>
   * class Props {
   *   children?: VNode[];
   * }
   *
   * &#64;customElement('oj-sample-component')
   * export class SampleComponent extends VComponent&lt;Props> {
   *
   *   protected render(): VComponent.VNode {
   *     return (
   *       &lt;div style="border-style: solid; width:200px;">
   *         { this.props.children || &lt;span>Default Content&lt;/span> }
   *       &lt;/div>
   *     );
   *   }
   * }
   * </code></pre>
   * <p>
   * Ordinary slots are exposed as render functions at runtime and can simply be called to retrieved the corresponding content.
   * </p>
   * <pre class="prettyprint"><code>
   * class Props {
   *   header?: Slot;
   * }
   *
   * &#64;customElement('oj-sample-component')
   * export class SampleComponent extends VComponent&lt;Props> {
   *
   *   protected render(): VComponent.VNode {
   *     return (
   *       &lt;div style="border-style: solid; width:200px;">
   *         { this.props.header?.() || &lt;span>Default Header Content&lt;/span> }
   *       &lt;/div>
   *     );
   *   }
   * }
   * </code></pre>
   * <p>
   * Template slots are also exposed as render functions at runtime, but additional take an argument representing the template data.
   * </p>
   * <pre class="prettyprint"><code>
   * type Item {
   *   index: number;
   *   text: string;
   * }
   *
   * class Props {
   *   itemTemplate?: Slot&lt;Item>;
   *   items?: string[];
   * }
   *
   * &#64;customElement('oj-sample-component')
   * export class SampleComponent extends VComponent&lt;Props> {
   *
   *   protected render(): VComponent.VNode {
   *     return (
   *       const templateFunction = this.itemTemplate || this._defaultTemplate;
   *       &lt;ul>
   *         items.map( (item, index) =>
   *           &lt;li>
   *             { templateFunction({index: index, text: item}) }
   *           &lt;/li>);
   *       &lt;/ul>
   *     );
   *   }
   * }
   * </code></pre>
   * <p>
   * Dynamic slots are rendered exactly like ordinary and template slots once the component determines what slot to render.
   * </p>
   * <pre class="prettyprint"><code>
   * class Props {
   *   cards?: DynamicSlots;
   *   currentCard: string;
   * }
   *
   * &#64;customElement('oj-sample-component')
   * export class SampleComponent extends VComponent&lt;Props> {
   *
   *   protected render(): VComponent.VNode {
   *     return (
   *       &lt;div style="border-style: solid; width:200px;">
   *         { this.props.cards?.[this.props.currentCard]?.() }
   *       &lt;/div>
   *     );
   *  }
   * }
   * </code></pre>
   *
   * <h3 id="perf">
   *  Performance Considerations
   *  <a class="bookmarkable-link" title="Bookmarkable Link" href="#perf"></a>
   * </h3>
   * <p>
   * Every time a component's render function is called, everything contained is created anew.
   * As a result, complex properties (e.g. non-primitive values like Object types, event listeners),
   * should be created outside of the render function's scope. Otherwise, e.g. the component would
   * be specifying a different instance of an event listener each time the component is rendered
   * which would result in unnecessary DOM changes. Event listeners should be declared as instance functions
   * marked with the &#64;listener decorator which will ensure that they are property bound.
   * Non-primitive values should be saved in variables
   * outside of the render function.
   * </p>
   * <pre class="prettyprint"><code>
   * import { h, VComponent, customElement, listener } from "ojs/ojvcomponent";
   *
   * class Props {&hellip;}
   *
   * &#64;customElement('oj-sample-collection')
   * export class SampleCollection extends VComponent&lt;Props> {
   *   constructor(props: Readonly&lt;Props>) {
   *     super(props);
   *   }
   *
   *   &#64;listener()
   *   private _handleClick(event) { &hellip; }
   *
   *   protected render(): VComponent.VNode {
   *     return (
   *       &lt;div onClick={this._handleClick}/>
   *     );
   *   }
   * }
   * </code></pre>
   */
  // TYPEDEFS

  /**
  * @typedef {Function} VComponent.Action
  * @ojsignature [{target:"Type", value:"<Detail extends object = {}>", for:"genericTypeParameters"},
  *               {target: "Type", value: "(detail?: Detail) => void"}]
  */

  /**
  * @typedef {Function} VComponent.CancelableAction
  * @ojsignature [{target:"Type", value:"<Detail extends object = {}>", for:"genericTypeParameters"},
  *               {target: "Type", value: "(detail?: Detail) => Promise<void>"}]
  */

  /**
  * @typedef {Object} VComponent.DynamicSlots
  * @ojsignature [{target:"Type", value:"<Data = undefined>", for:"genericTypeParameters"},
  *               {target: "Type", value: "Record<string, VComponent.Slot<Data>" }]
  */

  /**
  * @typedef {Function} VComponent.Slot
  * @ojsignature [{target:"Type", value:"<Data = undefined>", for:"genericTypeParameters"},
  *               {target: "Type", value: "(data?: Data) => VComponent.VNode[]"}]
  */

  /**
   * @typedef {Object} VComponent.VComponentClass
   * @ojsignature [{target:"Type", value:"<P>", for:"genericTypeParameters"},
   *               {target: "Type", value: "new (props: P) => VComponent<P, any>"}]
   */

  /**
   * @typedef {Object} VComponent.RenderFunction
   * @ojsignature [{target:"Type", value:"<P>", for:"genericTypeParameters"},
   *               {target: "Type", value: "(props: P, content: VComponent.VNode[]) => VComponent.VNode"}]
   */

  /**
   * @typedef {Object} VComponent.VNodeType
   * @ojsignature [{target:"Type", value:"<P>", for:"genericTypeParameters"},
   *               {target: "Type", value: "string | VComponent.VComponentClass<P> | VComponent.RenderFunction<P>"}]
   */
  // STATIC METHODS

  /**
   * Creates a virtual node for an HTML element of the given type, props, and children.
   * @function h
   * @memberof VComponent
   * @param {any} type An HTML or SVG tag name
   * @param {Object} props The properties to set in the real DOM node
   * @param {...Object} children Optional child DOM
   * @ojsignature [{target:"Type", value:"<P>", for:"genericTypeParameters"},
   *               {target: "Type", value: "VComponent.VNodeType<P>", for: "type"},
   *               {target: "Type", value: "P", for: "props"},
   *               {target: "Type", value: "Array<VComponent.VNode|Node>", for: "children"},
   *               {target: "Type", value: "VComponent.VNode", for: "returns"}]
   * @return {Object}
   * @expose
   * @ignore
   */

  /**
   * Utility to convert a JSX 'class' attribute value to an object for easier component
   * manipulation.
   * <pre class="prettyprint"><code>
   * import { h, VComponent, classPropToObject } from "ojs/ojvcomponent";
   *
   * class Props {
   *   class?: string | object = {};
   * }
   *
   * export class SampleComponent extends VComponent&lt;Props> {
   *   protected render(): VComponent.VNode {
   *     // Make a copy of the readonly return value from classPropToObject and add additional classes
   *     const classObj = Object.assign({}, classPropToObject(this.props.class), { newClass: true }
   *     return (
   *       &lt;div class={ classObj } />
   *     );
   *   }
   * }
   * </code></pre>
   * @function classPropToObject
   * @memberof VComponent
   * @param {string|object|null} classProp An HTML or SVG tag name
   * @ojsignature [{target: "Type", value: "Readonly<object>", for: "returns"}]
   * @return {Object}
   * @expose
   * @ignore
   */

  /**
   * An optional static lifecycle method used to initialize derived state.
   * Called before the render method on the first flow through the
   * lifecycle. Components should return a partial state that will be merged
   * into any state that was initialized in the constructor, or null if
   * no changes are needed.
   *
   * @function initStateFromProps
   * @memberof VComponent
   * @param {Object} props The component's initial properties
   * @param {Object} state The component's initial state
   * @return {Object|null}
   * @ojsignature [{target: "Type", value: "Readonly<P>", for: "props"},
   *              {target: "Type", value: "Readonly<S>", for: "state"},
   *              {target: "Type", value: "Partial<S>|null", for: "returns"}]
   * @ojprotected
   * @expose
   */

  /**
   * An optional static lifecycle method used to update derived state.
   * Called before the render method on update flows through the lifecycle.
   * Components should return either a partial state that will be merged
   * into component state or null if no changes are needed. Logic that relies on old
   * and new state or property values should be done in <a href="#update">updated()</a>
   * instead.
   * @function updateStateFromProps
   * @memberof VComponent
   * @param {Object} props The new component properties
   * @param {Object} state The new state
   * @return {Object|null}
   * @ojsignature [{target: "Type", value: "Readonly<P>", for: "props"},
   *              {target: "Type", value: "Readonly<S>", for: "state"},
   *              {target: "Type", value: "Partial<S>|null", for: "returns"}]
   * @ojprotected
   * @expose
   */
  // INSTANCE PROPERTIES

  /**
   * The passed in component properties. This property should not be directly modified e.g.
   * this.props = {} or this.props.someProp = 'foo'.
   * @name props
   * @memberof VComponent
   * @type {Object}
   * @default {}
   * @ojsignature [{target: "Type", value: "Readonly<P>"}]
   * @ojprotected
   * @instance
   * @expose
   */

  /**
   * The component state. State updates should be done through the updateState or updateStateFromProps methods
   * and not by direct modification of this property in order to ensure that the component
   * is rerendered.
   * @expose
   * @name state
   * @memberof VComponent
   * @type {Object}
   * @default {}
   * @ojsignature [{target: "Type", value: "Readonly<S>"}]
   * @ojprotected
   * @instance
   */
  // INSTANCE METHODS

  /**
   * Required lifecycle method which returns the component's virtual subtree.
   * @function render
   * @return {VComponent.VNode}
   *
   * @memberof VComponent
   * @ojprotected
   * @abstract
   * @instance
   * @expose
   */

  /**
   * An optional lifecycle method called after the
   * virtual component has been initially rendered and inserted into the
   * DOM. Data fetches and global listeners can be added here.
   * This will not be called for reparenting cases. State and property
   * updates should be done here instead of the constructor.
   * @function mounted
   * @return {void}
   *
   * @memberof VComponent
   * @ojprotected
   * @instance
   * @expose
   */

  /**
   * An optional component lifecycle method called after the
   * render method in updating (state or property change) cases.
   * Additional DOM manipulation can be done here. State and property
   * updates that need access to old and values should also be done here.
   * Note that when updating state or property in updated(),
   * the component should compare old and new values.
   * @function updated
   * @param {Object} oldProps The previous value of the component properties.
   * @param {Object} oldState The previous value of the component state.
   * @return {void}
   * @ojsignature [{target: "Type", value: "Readonly<P>", for: "oldProps"},
   *               {target: "Type", value: "Readonly<S>", for: "oldState"},
   *              {target: "Type", value: "void", for: "returns"}]
   *
   * @memberof VComponent
   * @ojprotected
   * @instance
   * @expose
   */

  /**
   * An optional component lifecycle method called after the
   * virtual component has been removed from the DOM. This will not
   * be called for reparenting cases. Global listener cleanup can
   * be done here.
   * @function unmounted
   * @return {void}
   *
   * @memberof VComponent
   * @ojprotected
   * @instance
   * @expose
   */

  /**
   * The <a href="#uniqueId">uniqueId()</a> method can
   * be called to retrieve an id that is unique to the component instance (matching the live DOM if it has been specified)
   * that can be used e.g. as a prefix for IDs on internal DOM.
   *
   * For components needing to generate a unique ID for internal DOM, this utility method
   * will return either the id set on the VComponent by the parent or a unique string that
   * can be used for a prefix for child elements if one wasn't set by the parent.
   * This method can only be called after the VComponent
   * has been instantiated and will return undefined if called from the constructor.
   * @function uniqueId
   * @return {string}
   *
   * @memberof VComponent
   * @ojprotected
   * @instance
   * @expose
   */

  /**
   * Updates an internal component state. State updates always trigger an asynchronous rerender.<br/>
   * Note that the method accepts either partial state for the component or a callback that
   * returns a partial state.
   * The callback receives up-to-date component state and property values and can be
   * used to dynamically compute the next state. State updates that rely on state or
   * property values should use the callback form to ensure the latest values are used.
   * @function updateState
   * @param {Object | function} state Accepts a partial state object or a callback that returns
   *                  a partial state object that will be merged into component state.
   *                  The updater function takes a reference to the component state
   *                  at the time the change is being applied and the component properties object.
   * @return {void}
   * @ojsignature {target: "Type", value: "((state: Readonly<S>, props: Readonly<P>) => Partial<S>) | Partial<S>", for: "state"}
   * @memberof VComponent
   * @ojprotected
   * @instance
   * @expose
   */

  /**
   * Updates a writeback component property. Note that a property update does not
   * trigger a component render.
   * @function _updateProperty
   * @param {string} prop The name of the property
   * @param {any} value The new property value
   * @return {void}
   * @ojsignature [{target: "Type", value: "keyof P", for: "prop"},
   *               {target: "Type", value: "P[keyof P]", for: "value"}]
   *
   * @memberof VComponent
   * @ojprotected
   * @instance
   * @ignore
   */

  var EMPTYO = Object.freeze({});

  function classPropToObject(classProp) {
    if (!classProp) {
      return EMPTYO;
    }

    if (typeof classProp === 'string') {
      return classProp.split(' ').reduce(function (acc, val) {
        if (val) {
          acc[val] = true;
        }

        return acc;
      }, {});
    }

    return classProp;
  }

  var PetitDom;

  (function (PetitDom) {
    PetitDom.LISTENER_OPTIONS_SYMBOL = Symbol();
    var SKIPKEYS = new Set(['key', 'ref', 'children']);
    var isArray = Array.isArray;

    var isVNode = function isVNode(c) {
      return c && (c.type != null || c._text != null || c._node);
    };

    var isComponent = function isComponent(c) {
      return (c === null || c === void 0 ? void 0 : c.mount) && (c === null || c === void 0 ? void 0 : c.patch) && (c === null || c === void 0 ? void 0 : c.notifyUnmounted) && (c === null || c === void 0 ? void 0 : c.notifyMounted);
    };

    function h(type, props) {
      var content,
          isSVG = false,
          isVComponent = false,
          isCustomElement;

      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }

      if (typeof type !== 'string') {
        isVComponent = typeof type === 'function' && isComponent(type.prototype);
        isCustomElement = isVComponent && type.prototype.mountContent;
        content = args;
      } else {
        isSVG = type === 'svg';
        isCustomElement = !isSVG && oj.ElementUtils.isValidCustomElementName(type);
        var len = args.length;

        if (len === 1) {
          var contArg = args[0];

          if (isArray(contArg)) {
            content = maybeFlatten(contArg, isSVG);
          } else if (isVNode(contArg)) {
            contArg.isSVG = isSVG;
            content = [contArg];
          } else {
            content = [{
              _text: contArg == null ? '' : contArg
            }];
          }
        } else if (len > 1) {
          content = maybeFlatten(args, isSVG);
        } else {
          content = args;
        }
      }

      var needsWritableProps = isVComponent || isCustomElement;
      return {
        type: type,
        isSVG: isSVG,
        isComponent: isVComponent,
        isCustomElement: isCustomElement,
        key: props === null || props === void 0 ? void 0 : props.key,
        props: props || (needsWritableProps ? Object.create(null) : EMPTYO),
        content: content,
        ref: props === null || props === void 0 ? void 0 : props.ref
      };
    }

    PetitDom.h = h;

    function maybeFlatten(arr, isSVG) {
      for (var i = 0; i < arr.length; i++) {
        var ch = arr[i];

        if (isArray(ch)) {
          return flattenChildren(arr, i, arr.slice(0, i), isSVG);
        } else if (!isVNode(ch)) {
          arr[i] = {
            _text: ch == null ? '' : ch
          };
        } else if (isSVG && !ch.isSVG) {
          ch.isSVG = true;
        }
      }

      return arr;
    }

    function flattenChildren(children, start, arr, isSVG) {
      for (var i = start; i < children.length; i++) {
        var ch = children[i];

        if (isArray(ch)) {
          flattenChildren(ch, 0, arr, isSVG);
        } else if (isVNode(ch)) {
          if (isSVG && !ch.isSVG) {
            ch.isSVG = true;
          }

          arr.push(ch);
        } else if (ch == null || typeof ch === 'string') {
          arr.push({
            _text: ch == null ? '' : ch
          });
        } else {
          arr.push(ch);
        }
      }

      return arr;
    }

    var SVG_NS = 'http://www.w3.org/2000/svg';
    var XLINK_NS = 'http://www.w3.org/1999/xlink';
    var NS_ATTRS = {
      show: XLINK_NS,
      actuate: XLINK_NS,
      href: XLINK_NS
    };

    function defShouldUpdate(p1, p2, c1, c2) {
      if (c1 !== c2) return true;

      for (var key in p1) {
        if (p1[key] !== p2[key]) return true;
      }

      return false;
    }

    function mountCustomElement(vnode, uncontrolledRootProps) {
      var type = vnode.type,
          props = vnode.props,
          content = vnode.content;
      var node = document.createElement(type);
      patchDOM(node, uncontrolledRootProps, null, true);
      patchDOM(node, props, null, true);
      appendChildren(node, content);
      vnode._node = node;
      return node;
    }

    PetitDom.mountCustomElement = mountCustomElement;

    function mountCustomElementContent(vnode, controlledRootProps) {
      var node = vnode._node;
      patchDOM(node, vnode.props, controlledRootProps, true);
      appendChildren(node, vnode.content);
      patchRef(vnode.ref, node);
    }

    PetitDom.mountCustomElementContent = mountCustomElementContent;

    function mount(c) {
      var isVComponent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var node;

      if (c._node) {
        return c._node;
      } else if (c._text != null) {
        node = document.createTextNode(c._text);
      } else {
        var type = c.type,
            props = c.props,
            content = c.content,
            isSVG = c.isSVG;

        if (typeof type === 'string') {
          if (!isSVG) {
            node = document.createElement(type);
          } else {
            node = document.createElementNS(SVG_NS, type);
          }

          patchDOM(node, props, null, isVComponent || c.isCustomElement);

          if (isTemplateElement(node)) {
            appendChildrenForTemplate(node, content);
          } else {
            appendChildren(node, content);
          }
        } else if (typeof type === 'function') {
          if (c.isComponent) {
            var instance;
            var constr = type;
            var splitProps = sortControlled(constr, props, c.isCustomElement);
            c._uncontrolled = splitProps.uncontrolled;
            instance = new constr(splitProps.controlled);
            instance._uniqueId = oj.__AttributeUtils.getUniqueId(props.id);
            node = instance.mount(splitProps.controlled, content, splitProps.uncontrolled);
            c._data = instance;
          } else {
            var render = type;
            var vnode = render(props, content);
            node = mount(vnode);
            c._data = vnode;
          }
        }
      }

      if (node == null) {
        throw new Error('Unknown node type!');
      }

      c._node = node;
      return node;
    }

    PetitDom.mount = mount;

    function mountForTemplate(c) {
      var node;

      if (c._text != null) {
        node = document.createTextNode(c._text);
      } else {
        var type = c.type,
            props = c.props,
            content = c.content,
            isSVG = c.isSVG;

        if (typeof type === 'string') {
          if (!isSVG) {
            node = document.createElement(type);
          } else {
            node = document.createElementNS(SVG_NS, type);
          }

          patchDOMForTemplate(node, props, null, c.isCustomElement);
          appendChildrenForTemplate(node, content);
        }
      }

      if (node == null) {
        throw new Error('content inside <template> elements is limited to HTML elements and text');
      }

      c._node = node;
      return node;
    }

    function isTemplateElement(node) {
      return node.nodeName === 'TEMPLATE';
    }

    function afterMountHooks(vnode) {
      if (vnode.isComponent) {
        var vcomp = vnode._data;
        patchRef(vnode.ref, vcomp);
        patchRef(vcomp._vnode.props.ref, vnode._node);

        if (!vnode.isCustomElement) {
          vcomp.notifyMounted();
        }
      } else if (typeof vnode.type !== 'function') {
        patchRef(vnode.ref, vnode._node);
      }
    }

    function appendChildren(parent, children) {
      var start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var end = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : children.length - 1;
      var oldch = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;

      while (start <= end) {
        var ch = children[start++];

        if (ch._node) {
          var node = ch._node;
          insertBeforeChild(parent, ch, oldch);

          if (node.nodeType === 1 && oj.Components) {
            oj.Components.subtreeShown(node);
          }
        } else {
          insertBeforeChild(parent, ch, oldch);
        }
      }
    }

    function appendChildrenForTemplate(parent, children) {
      var start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var end = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : children.length - 1;
      var oldch = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;

      while (start <= end) {
        var ch = children[start++];
        mountForTemplate(ch);
        insertBeforeChild(parent, ch, oldch);
      }
    }

    function removeChildren(parent, children) {
      var start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var end = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : children.length - 1;
      var cleared = void 0;

      if (parent.childNodes.length === end - start + 1) {
        parent.textContent = '';
        cleared = true;
      }

      while (start <= end) {
        var ch = children[start++];

        if (!cleared) {
          removeAndUnmountChild(parent, ch);
        }
      }
    }

    function mounted(ch) {
      if (isArray(ch)) {
        for (var i = 0; i < ch.length; i++) {
          mounted(ch[i]);
        }
      } else {
        if (ch.isComponent) {
          var vcomp = ch._data;
          vcomp.notifyMounted();
        } else if (ch.content != null) {
          mounted(ch.content);
        }
      }
    }

    PetitDom.mounted = mounted;

    function unmount(ch) {
      if (isArray(ch)) {
        for (var i = 0; i < ch.length; i++) {
          unmount(ch[i]);
        }
      } else {
        if (ch.isComponent) {
          var vcomp = ch._data;
          vcomp.notifyUnmounted(ch._node);
        } else if (ch.content != null) {
          unmount(ch.content);
        }

        if (ch.isComponent || typeof ch.type !== 'function') {
          patchRef(ch.ref, null);
        }
      }
    }

    PetitDom.unmount = unmount;

    function isControlledProp(constr, prop) {
      var _a, _b;

      var meta = constr.metadata;
      return ((_b = (_a = meta === null || meta === void 0 ? void 0 : meta.extension) === null || _a === void 0 ? void 0 : _a._ROOT_PROPS_MAP) === null || _b === void 0 ? void 0 : _b[prop]) != null;
    }

    function isListener(prop) {
      return oj.__AttributeUtils.eventListenerPropertyToEventType(prop) !== null;
    }

    function sortControlled(constr, props, isCustomElement) {
      var staticDefaults = ojdefaultsutils.DefaultsUtils.getStaticDefaults(constr, constr.metadata, true);
      var splitProps = {
        controlled: Object.create(staticDefaults),
        uncontrolled: {}
      };

      for (var propName in props) {
        var value = props[propName];

        if (value !== undefined) {
          if (!isCustomElement || !oj.__AttributeUtils.isGlobalOrData(propName) || isControlledProp(constr, propName)) {
            splitProps.controlled[propName] = value;
          } else {
            splitProps.uncontrolled[propName] = value;
          }
        }
      }

      return splitProps;
    }

    function patchDOM(el, props, oldProps, isVComponent) {
      if (props) {
        addOrUpdateProps(el, props, oldProps || EMPTYO, isVComponent);
      }

      if (oldProps) {
        removeOldProps(el, props || EMPTYO, oldProps, isVComponent);
      }
    }

    function patchDOMForTemplate(el, props, oldProps, isCustomElement) {
      if (props) {
        var propKeys = Object.keys(props);
        propKeys.forEach(function (key) {
          if (SKIPKEYS.has(key)) {
            return;
          }

          var value = props[key];
          el.setAttribute(key, value);
        });
      }

      if (oldProps) {}
    }

    function addOrUpdateProps(el, props, oldProps, isVComponent) {
      var propKeys = Object.keys(props);
      propKeys.forEach(function (key) {
        if (SKIPKEYS.has(key)) {
          return;
        }

        var value = props[key];
        var oldValue = oldProps[key];

        if (value !== oldValue) {
          if (key === 'style') {
            patchProperties(el.style, value || EMPTYO, oldValue || EMPTYO, '');
          } else if (key === 'class') {
            patchClassName(el, value, oldValue, isVComponent);
          } else if (!maybePatchListener(el, key, value, oldValue) && !maybePatchAttribute(el, key, value, isVComponent)) {
            el[key] = value;
          }
        }
      });
    }

    function removeOldProps(el, props, oldProps, isVComponent) {
      var propKeys = Object.keys(oldProps);
      propKeys.forEach(function (key) {
        if (key === 'key' || key === 'ref') {
          return;
        }

        var oldValue = oldProps[key];

        if (!(key in props)) {
          if (key === 'style') {
            patchProperties(el.style, EMPTYO, oldValue || EMPTYO, '');
          } else if (key === 'class') {
            patchClassName(el, null, oldValue, isVComponent);
          } else if (!maybePatchListener(el, key, null, oldValue) && !maybePatchAttribute(el, key, null, isVComponent)) {
            el[key] = undefined;
          }
        }
      });
    }

    function patchProperties(propertyHolder, props, oldProps, unsetValue) {
      for (var key in props) {
        var oldv = oldProps[key];
        var newv = props[key];

        if (oldv !== newv) {
          propertyHolder[key] = newv;
        }
      }

      for (var _key2 in oldProps) {
        if (!(_key2 in props)) {
          propertyHolder[_key2] = unsetValue;
        }
      }
    }

    function patchClassName(el, value, oldValue, isVComponent) {
      if (isVComponent) {
        patchClassNameAsMap(el, value, oldValue);
      } else {
        patchClassNameAsString(el, value);
      }
    }

    function patchClassNameAsString(el, value) {
      if (value) {
        var classStr = _typeof(value) === 'object' ? Object.keys(value).filter(function (key) {
          return value[key];
        }).join(' ') : value;
        el.setAttribute('class', classStr);
      } else {
        el.removeAttribute('class');
      }
    }

    function patchClassNameAsMap(el, value, oldValue) {
      var oldValueMap = classPropToObject(oldValue);
      var valueMap = classPropToObject(value);

      for (var key in oldValueMap) {
        if (oldValueMap[key] && !valueMap[key]) {
          el.classList.remove(key);
        }
      }

      for (var _key3 in valueMap) {
        if (valueMap[_key3] && !oldValueMap[_key3]) {
          el.classList.add(_key3);
        }
      }
    }

    function maybePatchListener(el, key, value, oldValue) {
      if (value || oldValue) {
        var eventType = eventListenerPropertyToEventType(key);

        if (eventType) {
          patchListener(el, eventType, value, oldValue);
          return true;
        }
      }

      return false;
    }

    function patchListener(el, eventType, value, oldValue) {
      if (oldValue) {
        el.removeEventListener(eventType, oldValue, oldValue[PetitDom.LISTENER_OPTIONS_SYMBOL]);
      }

      if (value) {
        el.addEventListener(eventType, value, value[PetitDom.LISTENER_OPTIONS_SYMBOL]);
      }
    }

    function maybePatchAttribute(el, key, value, isVComponent) {
      if (isVComponent && oj.__AttributeUtils.isGlobalOrData(key) || !isVComponent && key !== 'value' && key !== 'checked') {
        var attr = oj.__AttributeUtils.getNativeAttr(key);

        if (value === true) {
          el.setAttribute(attr, '');
        } else if (value === false) {
          el.removeAttribute(attr);
        } else {
          if (value != null) {
            var ns = NS_ATTRS[attr];

            if (ns !== undefined) {
              el.setAttributeNS(ns, attr, value);
            } else {
              el.setAttribute(attr, value);
            }
          } else {
            el.removeAttribute(attr);
          }
        }

        return true;
      }

      return false;
    }

    function eventListenerPropertyToEventType(property) {
      if (/^on[A-Z]/.test(property)) {
        return property.substr(2, 1).toLowerCase() + property.substr(3);
      }

      return null;
    }

    function patchCustomElement(newch, oldch, uncontrolledRootProps, oldUncontrolledRootProps) {
      var parentNode = oldch._node;

      if (oldch === newch) {
        return;
      }

      patchDOM(parentNode, uncontrolledRootProps, oldUncontrolledRootProps, true);
      patchDOM(parentNode, newch.props, oldch.props, true);
      diffChildren(parentNode, newch.content, oldch.content);
      patchRef(newch.ref, parentNode, oldch.ref);
    }

    PetitDom.patchCustomElement = patchCustomElement;

    function patchCustomElementContent(newch, oldch, controlledRootProps) {
      var parentNode = oldch._node;

      if (oldch === newch) {
        return;
      }

      var oldRootProps = {};
      var oldProps = oldch.props;

      for (var prop in oldProps) {
        if (isListener(prop) || prop === 'class' || prop === 'style') {
          oldRootProps[prop] = oldProps[prop];
        }
      }

      Object.assign(oldRootProps, controlledRootProps);
      patchDOM(parentNode, newch.props, oldRootProps, true);
      diffChildren(parentNode, newch.content, oldch.content);
      patchRef(newch.ref, parentNode, oldch.ref);
    }

    PetitDom.patchCustomElementContent = patchCustomElementContent;

    function patch(newch, oldch, parent) {
      var isVComponent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var childNode = oldch._node;

      if (oldch === newch) {
        return childNode;
      }

      if (isTemplateElement(childNode)) {
        newch._node = childNode;
        return childNode;
      }

      if (newch._node) {
        if (childNode !== newch._node) {
          replaceAndUnmountChild(parent, newch, oldch);
        }

        return newch._node;
      }

      var t1, t2;

      if ((t1 = oldch._text) != null && (t2 = newch._text) != null) {
        if (t1 !== t2) {
          childNode.nodeValue = t2;
        }
      } else if (oldch.type === newch.type && oldch.isSVG === newch.isSVG) {
        var type = oldch.type;

        if (typeof type === 'function') {
          if (oldch.isComponent) {
            var vcomp = oldch._data;
            var constr = type;
            var splitProps = sortControlled(constr, newch.props, newch.isCustomElement);
            newch._uncontrolled = splitProps.uncontrolled;
            vcomp.patch(splitProps.controlled, newch.content, splitProps.uncontrolled, oldch._uncontrolled);
            newch._data = vcomp;
            patchRef(newch.ref, vcomp, oldch.ref);
          } else {
            var shouldUpdateFn = type['shouldUpdate'] || defShouldUpdate;

            if (shouldUpdateFn(newch.props, oldch.props, newch.content, oldch.content)) {
              var render = type;
              var vnode = render(newch.props, newch.content);
              childNode = patch(vnode, oldch._data, parent);
              newch._data = vnode;
            } else {
              newch._data = oldch._data;
            }
          }
        } else if (typeof type === 'string') {
          if (oldch.isCustomElement && contentChangeRequiresRemount(newch.content, oldch.content)) {
            childNode = replaceAndUnmountChild(parent, newch, oldch);
          } else {
            patchDOM(childNode, newch.props, oldch.props, isVComponent || oldch.isCustomElement);
            diffChildren(childNode, newch.content, oldch.content);
            patchRef(newch.ref, childNode, oldch.ref);
          }
        } else {
          throw new Error("Error while patching. Unknown node type '".concat(type, "'."));
        }
      } else {
        if (parent) {
          childNode = replaceAndUnmountChild(parent, newch, oldch);
        }
      }

      newch._node = childNode;
      return childNode;
    }

    PetitDom.patch = patch;

    function canPatch(v1, v2) {
      return v1.key == null && v2.key == null || v1.key === v2.key;
    }

    function diffChildren(parent, children, oldChildren) {
      var newStart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var newEnd = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : children.length - 1;
      var oldStart = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
      var oldEnd = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : oldChildren.length - 1;
      if (children === oldChildren) return;
      var oldCh;
      var k = diffCommonPrefix(children, oldChildren, newStart, newEnd, oldStart, oldEnd, canPatch, parent);
      newStart += k;
      oldStart += k;
      k = diffCommonSufffix(children, oldChildren, newStart, newEnd, oldStart, oldEnd, canPatch, parent);
      newEnd -= k;
      oldEnd -= k;

      if (newStart > newEnd && oldStart > oldEnd) {
        return;
      }

      if (newStart <= newEnd && oldStart > oldEnd) {
        oldCh = oldChildren[oldStart];
        appendChildren(parent, children, newStart, newEnd, oldCh);
        return;
      }

      if (oldStart <= oldEnd && newStart > newEnd) {
        removeChildren(parent, oldChildren, oldStart, oldEnd);
        return;
      }

      var oldRem = oldEnd - oldStart + 1;
      var newRem = newEnd - newStart + 1;
      k = -1;

      if (oldRem < newRem) {
        k = indexOf(children, oldChildren, newStart, newEnd, oldStart, oldEnd, canPatch);

        if (k >= 0) {
          oldCh = oldChildren[oldStart];
          appendChildren(parent, children, newStart, k - 1, oldCh);
          var upperLimit = k + oldRem;
          newStart = k;

          while (newStart < upperLimit) {
            patch(children[newStart++], oldChildren[oldStart++], parent);
          }

          var oldChSibling = oldChildren[oldEnd + 1];
          appendChildren(parent, children, newStart, newEnd, oldChSibling);
          return;
        }
      } else if (oldRem > newRem) {
        k = indexOf(oldChildren, children, oldStart, oldEnd, newStart, newEnd, canPatch);

        if (k >= 0) {
          removeChildren(parent, oldChildren, oldStart, k - 1);

          var _upperLimit = k + newRem;

          oldStart = k;

          while (oldStart < _upperLimit) {
            patch(children[newStart++], oldChildren[oldStart++], parent);
          }

          removeChildren(parent, oldChildren, oldStart, oldEnd);
          return;
        }
      }

      if (oldStart === oldEnd) {
        removeAndUnmountChild(parent, oldChildren[oldStart]);
        appendChildren(parent, children, newStart, newEnd, oldChildren[oldStart + 1]);
        return;
      }

      if (newStart === newEnd) {
        removeChildren(parent, oldChildren, oldStart, oldEnd);
        insertBeforeChild(parent, children[newStart], oldChildren[oldEnd + 1]);
        return;
      }

      var failed = diffOND(parent, children, oldChildren, newStart, newEnd, oldStart, oldEnd);
      if (failed) diffWithMap(parent, children, oldChildren, newStart, newEnd, oldStart, oldEnd);
    }

    function diffCommonPrefix(s1, s2, start1, end1, start2, end2, eq, parent) {
      var k = 0,
          c1,
          c2;

      while (start1 <= end1 && start2 <= end2 && eq(c1 = s1[start1], c2 = s2[start2])) {
        if (parent) patch(c1, c2, parent);
        start1++;
        start2++;
        k++;
      }

      return k;
    }

    function diffCommonSufffix(s1, s2, start1, end1, start2, end2, eq, parent) {
      var k = 0,
          c1,
          c2;

      while (start1 <= end1 && start2 <= end2 && eq(c1 = s1[end1], c2 = s2[end2])) {
        if (parent) patch(c1, c2, parent);
        end1--;
        end2--;
        k++;
      }

      return k;
    }

    var PATCH = 2;
    var INSERTION = 4;
    var DELETION = 8;

    function diffOND(parent, children, oldChildren) {
      var newStart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var newEnd = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : children.length - 1;
      var oldStart = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
      var oldEnd = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : oldChildren.length - 1;
      var rows = newEnd - newStart + 1;
      var cols = oldEnd - oldStart + 1;
      var dmax = rows + cols;
      var v = [];
      var d, k, r, c, pv, cv, pd;

      outer: for (d = 0; d <= dmax; d++) {
        if (d > 50) return true;
        pd = d - 1;
        pv = d ? v[d - 1] : [0, 0];
        cv = v[d] = [];

        for (k = -d; k <= d; k += 2) {
          if (k === -d || k !== d && pv[pd + k - 1] < pv[pd + k + 1]) {
            c = pv[pd + k + 1];
          } else {
            c = pv[pd + k - 1] + 1;
          }

          r = c - k;

          while (c < cols && r < rows && canPatch(oldChildren[oldStart + c], children[newStart + r])) {
            c++;
            r++;
          }

          if (c === cols && r === rows) {
            break outer;
          }

          cv[d + k] = c;
        }
      }

      var diff = Array(d / 2 + dmax / 2);
      var deleteMap = {};
      var oldCh;
      var diffIdx = diff.length - 1;

      for (d = v.length - 1; d >= 0; d--) {
        while (c > 0 && r > 0 && canPatch(oldChildren[oldStart + c - 1], children[newStart + r - 1])) {
          diff[diffIdx--] = PATCH;
          c--;
          r--;
        }

        if (!d) break;
        pd = d - 1;
        pv = d ? v[d - 1] : [0, 0];
        k = c - r;

        if (k === -d || k !== d && pv[pd + k - 1] < pv[pd + k + 1]) {
          r--;
          diff[diffIdx--] = INSERTION;
        } else {
          c--;
          diff[diffIdx--] = DELETION;
          oldCh = oldChildren[oldStart + c];

          if (oldCh.key != null) {
            deleteMap[oldCh.key] = oldStart + c;
          }
        }
      }

      applyDiff(parent, diff, children, oldChildren, newStart, oldStart, deleteMap);
    }

    function applyDiff(parent, diff, children, oldChildren, newStart, oldStart, deleteMap) {
      var moveMap = {};

      for (var i = 0, oldChIdx = oldStart; i < diff.length; i++) {
        var _op = diff[i];

        if (_op === PATCH) {
          oldChIdx++;
        } else if (_op === DELETION) {
          var oldCh = oldChildren[oldChIdx++];

          if (oldCh.key == null || moveMap[oldCh.key] == null) {
            removeAndUnmountChild(parent, oldCh);
          }
        }
      }

      for (var _i = 0, chIdx = newStart, _oldChIdx = oldStart; _i < diff.length; _i++) {
        var op = diff[_i];
        var _mounted = false;

        if (op === PATCH) {
          patch(children[chIdx++], oldChildren[_oldChIdx++], parent);
        } else if (op === INSERTION) {
          var ch = children[chIdx++];
          var oldMatchIdx = null;

          if (ch.key != null) {
            oldMatchIdx = deleteMap[ch.key];
          }

          if (oldMatchIdx != null) {
            patch(ch, oldChildren[oldMatchIdx], parent);
            moveMap[ch.key] = oldMatchIdx;
          }

          insertBeforeChild(parent, ch, _oldChIdx < oldChildren.length ? oldChildren[_oldChIdx] : null);
        } else if (op === DELETION) {
          _oldChIdx++;
        }
      }
    }

    function diffWithMap(parent, children, oldChildren, newStart, newEnd, oldStart, oldEnd) {
      var newLen = newEnd - newStart + 1;
      var oldLen = oldEnd - oldStart + 1;
      var minLen = Math.min(newLen, oldLen);
      var tresh = Array(minLen + 1);
      tresh[0] = -1;

      for (var i = 1; i < tresh.length; i++) {
        tresh[i] = oldEnd + 1;
      }

      var link = Array(minLen);
      var keymap = {},
          unkeyed = [];

      for (var _i2 = oldStart; _i2 <= oldEnd; _i2++) {
        var oldCh = oldChildren[_i2];
        var key = oldCh.key;

        if (key != null) {
          keymap[key] = _i2;
        } else {
          unkeyed.push(_i2);
        }
      }

      var idxUnkeyed = 0;

      for (var _i3 = newStart; _i3 <= newEnd; _i3++) {
        var ch = children[_i3];
        var idxInOld = ch.key == null ? unkeyed[idxUnkeyed++] : keymap[ch.key];

        if (idxInOld != null) {
          var _k = findK(tresh, idxInOld);

          if (_k >= 0) {
            tresh[_k] = idxInOld;
            link[_k] = {
              newi: _i3,
              oldi: idxInOld,
              prev: link[_k - 1]
            };
          }
        }
      }

      var k = tresh.length - 1;

      while (tresh[k] > oldEnd) {
        k--;
      }

      var ptr = link[k];
      var diff = Array(oldLen + newLen - k);
      var curNewi = newEnd,
          curOldi = oldEnd;
      var d = diff.length - 1;

      while (ptr) {
        var _ptr = ptr,
            newi = _ptr.newi,
            oldi = _ptr.oldi;

        while (curNewi > newi) {
          diff[d--] = INSERTION;
          curNewi--;
        }

        while (curOldi > oldi) {
          diff[d--] = DELETION;
          curOldi--;
        }

        diff[d--] = PATCH;
        curNewi--;
        curOldi--;
        ptr = ptr.prev;
      }

      while (curNewi >= newStart) {
        diff[d--] = INSERTION;
        curNewi--;
      }

      while (curOldi >= oldStart) {
        diff[d--] = DELETION;
        curOldi--;
      }

      applyDiff(parent, diff, children, oldChildren, newStart, oldStart, keymap);
    }

    function findK(ktr, j) {
      var lo = 1;
      var hi = ktr.length - 1;

      while (lo <= hi) {
        var mid = Math.ceil((lo + hi) / 2);
        if (j < ktr[mid]) hi = mid - 1;else lo = mid + 1;
      }

      return lo;
    }

    function indexOf(a, suba, aStart, aEnd, subaStart, subaEnd, eq) {
      var j = subaStart,
          k = -1;
      var subaLen = subaEnd - subaStart + 1;

      while (aStart <= aEnd && aEnd - aStart + 1 >= subaLen) {
        if (eq(a[aStart], suba[j])) {
          if (k < 0) k = aStart;
          j++;
          if (j > subaEnd) return k;
        } else {
          k = -1;
          j = subaStart;
        }

        aStart++;
      }

      return -1;
    }

    function contentChangeRequiresRemount(content, oldContent) {
      if (content === oldContent) {
        return false;
      }

      if (content.length !== oldContent.length) {
        return true;
      }

      return content.some(function (node, index) {
        var _a, _b;

        var oldNode = oldContent[index];

        if (node.type !== oldNode.type) {
          return true;
        }

        return ((_a = node.props) === null || _a === void 0 ? void 0 : _a.slot) !== ((_b = oldNode.props) === null || _b === void 0 ? void 0 : _b.slot);
      });
    }

    function replaceAndUnmountChild(parent, newch, oldch) {
      if (oldch._clean) {
        oldch._clean();
      }

      var needsMount = newch._node == null;

      if (needsMount) {
        mount(newch);
      }

      var newNode = newch._node;
      getDomContainer(parent).replaceChild(newNode, oldch._node);
      unmount(oldch);
      oldch._node = newNode;

      if (needsMount) {
        afterMountHooks(newch);
      }

      return newNode;
    }

    function removeAndUnmountChild(parent, oldch) {
      if (oldch._clean) {
        oldch._clean();
      }

      getDomContainer(parent).removeChild(oldch._node);
      unmount(oldch);
    }

    function insertBeforeChild(parent, newch, oldch) {
      var needsMount = newch._node == null;

      if (needsMount) {
        mount(newch);
      }

      var newNode = newch._node;
      getDomContainer(parent).insertBefore(newNode, (oldch === null || oldch === void 0 ? void 0 : oldch._node) || null);

      if (needsMount) {
        afterMountHooks(newch);
      }
    }

    function patchRef(newRefCallback, ref) {
      var oldRefCallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      if (oldRefCallback !== newRefCallback) {
        if (typeof oldRefCallback === 'function') {
          oldRefCallback(null);
        }

        if (typeof newRefCallback === 'function') {
          newRefCallback(ref);
        }
      }
    }

    function getDomContainer(node) {
      if (isTemplateElement(node)) {
        var content = node.content;

        if (content) {
          return content;
        }
      }

      return node;
    }
  })(PetitDom || (PetitDom = {}));

  var VComponent = /*#__PURE__*/function () {
    function VComponent(props) {
      _classCallCheck(this, VComponent);

      this._pendingPropsUpdate = false;
      this.props = props;
    }

    _createClass(VComponent, [{
      key: "updated",
      value: function updated(oldProps, oldState) {}
    }, {
      key: "mounted",
      value: function mounted() {}
    }, {
      key: "unmounted",
      value: function unmounted() {}
    }, {
      key: "uniqueId",
      value: function uniqueId() {
        return this._uniqueId;
      }
    }, {
      key: "_updateProperty",
      value: function _updateProperty(prop, value) {
        var shouldRender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        if (this.props[prop] !== value) {
          this._getCallback('_updateProperty')(prop, value, shouldRender);
        }
      }
    }, {
      key: "updateState",
      value: function updateState(state) {
        if (!this._pendingStateUpdaters) {
          this._pendingStateUpdaters = [];
        }

        this._pendingStateUpdaters.push(state);

        this.queueRender(this._ref, 'stateUpdate');
      }
    }, {
      key: "mount",
      value: function mount(props, content) {
        var uncontrolledRootProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        this._vnode = this._renderForMount(props, content);
        return this._ref = PetitDom.mount(this._vnode, true);
      }
    }, {
      key: "patch",
      value: function patch(props, content, uncontrolledRootProps, oldUncontrolledRootProps) {
        var oldProps = this.props;
        var oldState = this.state;
        var oldVnode = this._vnode;
        this._vnode = this._renderForPatch(props, content);
        PetitDom.patch(this._vnode, oldVnode, this._ref.parentNode, true);
        this.updated(oldProps, oldState);
      }
    }, {
      key: "notifyMounted",
      value: function notifyMounted() {
        PetitDom.mounted(this._vnode);
        this.mounted();
      }
    }, {
      key: "notifyUnmounted",
      value: function notifyUnmounted(node) {
        PetitDom.unmount(this._vnode);
        this.unmounted();
      }
    }, {
      key: "queueRender",
      value: function queueRender(element, reason) {
        var _this = this;

        if (reason === 'propsUpdate') {
          this._pendingPropsUpdate = true;
        }

        if (!this._busyStateCallbackForRender) {
          var busyContext = Context.getContext(element).getBusyContext();
          this._busyStateCallbackForRender = busyContext.addBusyState({
            description: this.uniqueId() + ' is waiting to render.'
          });
          window.requestAnimationFrame(function () {
            var busyStateCallbackForRender = _this._busyStateCallbackForRender;
            var pendingPropsUpdate = _this._pendingPropsUpdate;
            var pendingStateUpdaters = _this._pendingStateUpdaters;
            _this._busyStateCallbackForRender = null;
            _this._pendingPropsUpdate = false;
            _this._pendingStateUpdaters = null;

            try {
              var props = _this._getCallback('getPropsForRender')();

              var newState = _this._doUpdateState(props, pendingStateUpdaters);

              if (pendingPropsUpdate || newState && !_this._areStatesEqual(_this.state, newState)) {
                _this._pendingState = newState;

                _this._getCallback('patch')(props, _this._ref.parentNode);
              }
            } catch (error) {
              throw error;
            } finally {
              busyStateCallbackForRender();
              _this._pendingState = null;
            }
          });
        }
      }
    }, {
      key: "_renderForMount",
      value: function _renderForMount(props, content) {
        if (this.state) {
          var initStateFromProps = this.constructor.initStateFromProps;

          if (initStateFromProps) {
            var newPartialState = initStateFromProps.call(this.constructor, props, this.state);
            this.state = this._getNewState(newPartialState);
          }
        }

        return this._render(props, content);
      }
    }, {
      key: "_renderForPatch",
      value: function _renderForPatch(props, content) {
        if (this.state) {
          var updateStateFromProps = this.constructor.updateStateFromProps;
          var newPartialState;

          if (updateStateFromProps) {
            newPartialState = updateStateFromProps.call(this.constructor, props, this._pendingState || this.state, this.props);
          }

          this.state = this._getNewState(newPartialState, this._pendingState);
        }

        var vnode = this._render(props, content);

        return vnode;
      }
    }, {
      key: "_render",
      value: function _render(props, content) {
        if (content && content.length) {
          Object.assign(props, this._getCallback('convertChildrenToSlotProps')(content));
        }

        this.props = props;
        return this.render();
      }
    }, {
      key: "_doUpdateState",
      value: function _doUpdateState(props, updaters) {
        if (!updaters || updaters.length === 0) {
          return null;
        }

        var newState = updaters.reduce(function (acc, updater) {
          var updatedState = typeof updater === 'function' ? updater(acc, props) : updater;
          return Object.assign(acc, updatedState);
        }, Object.assign({}, this.state));
        return newState;
      }
    }, {
      key: "_areStatesEqual",
      value: function _areStatesEqual(oldState, newState) {
        return Object.keys(newState).every(function (key) {
          return oldState[key] === newState[key];
        });
      }
    }, {
      key: "_getCallback",
      value: function _getCallback(name) {
        if (!this._callbacks) {
          this._callbacks = this._getBuiltInCallbacks();
        }

        return this._callbacks[name];
      }
    }, {
      key: "_getBuiltInCallbacks",
      value: function _getBuiltInCallbacks() {
        var _this2 = this;

        var callbacks = {
          _updateProperty: function _updateProperty(prop, value) {
            var _a, _b;

            var changedEvent = oj.__AttributeUtils.propertyNameToChangeEventType(prop);

            var changedProp = oj.__AttributeUtils.eventTypeToEventListenerProperty(changedEvent);

            (_b = (_a = _this2.props)[changedProp]) === null || _b === void 0 ? void 0 : _b.call(_a, {
              value: value,
              previousValue: _this2.props[prop],
              updatedFrom: 'internal'
            });
          },
          getPropsForRender: function getPropsForRender() {
            return _this2.props;
          },
          patch: function patch(props, parent) {
            _this2.patch(props, parent);
          },
          convertChildrenToSlotProps: function convertChildrenToSlotProps(children) {
            return {
              children: children
            };
          }
        };
        callbacks['_vcomp'] = true;
        return callbacks;
      }
    }, {
      key: "_getNewState",
      value: function _getNewState(newPartialState) {
        var pendingState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        if (newPartialState || pendingState) {
          return Object.assign({}, pendingState || this.state, newPartialState);
        }

        return this.state;
      }
    }]);

    return VComponent;
  }();

  var h = PetitDom.h;
  /**
   * @license
   * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
   * The Universal Permissive License (UPL), Version 1.0
   * as shown at https://oss.oracle.com/licenses/upl/
   * @ignore
   */

  /**
   * @class
   * @ignore
   */

  var VirtualElementBridge = {};
  VirtualElementBridge._DEFAULT_SLOT_PROP = 'children';
  /**
   * Prototype for the JET component definitional bridge instance
   */

  VirtualElementBridge.proto = Object.create(oj.BaseCustomElementBridge.proto);
  oj.CollectionUtils.copyInto(VirtualElementBridge.proto, {
    AddComponentMethods: function AddComponentMethods(proto) {
      // eslint-disable-next-line no-param-reassign
      proto.setProperty = function (prop, value) {
        var bridge = oj.BaseCustomElementBridge.getInstance(this);

        if (!bridge.SaveEarlyPropertySet(prop, value)) {
          bridge.SetProperty(this, prop, value, this, true);
        }
      }; // eslint-disable-next-line no-param-reassign


      proto.getProperty = function (prop) {
        // 'this' is the property object we pass to the definitional element contructor to track internal property changes
        var bridge = oj.BaseCustomElementBridge.getInstance(this);
        return bridge.GetProperty(this, prop, this);
      };
    },
    AttributeChangedCallback: function AttributeChangedCallback(attr, oldValue, newValue) {
      // Invoke callback on the superclass
      oj.BaseCustomElementBridge.proto.AttributeChangedCallback.call(this, attr, oldValue, newValue); // The browser triggers this callback even if old and new values are the same
      // so we should do an equality check ourselves to prevent extra work

      if (oldValue !== newValue) {
        // VComponents need to update _LIVE_CONTROLLED_PROPS even during the patching case
        var bridge = oj.BaseCustomElementBridge.getInstance(this); // If we haven't already called HandleAttributeChanged in superclass, check to see
        // if we should call it to update _LIVE_CONTROLLED_PROPS for attributes updated during
        // the VComponent render() patching cycle

        if (!bridge.ShouldHandleAttributeChanged(this) && oj.BaseCustomElementBridge.proto.ShouldHandleAttributeChanged.call(bridge, this)) {
          var vcomp = this._vcomp;

          if (!vcomp || vcomp.isCustomElementFirst()) {
            bridge.HandleAttributeChanged(this, attr, oldValue, newValue);
          }
        }
      }
    },
    CreateComponent: function CreateComponent(element) {
      if (!element._vcomp) {
        if (oj.Components) {
          oj.Components.unmarkPendingSubtreeHidden(element);
        }

        var descriptor = oj.BaseCustomElementBridge.__GetDescriptor(element.tagName);

        var slotMap = oj.BaseCustomElementBridge.getSlotMap(element); // Initialize controlled root properties now that we know bindings have resolved and
        // data bound global attributes should be resolved.

        this._initializeControlledProps(element);

        var vprops = this._getVComponentProps();

        var vcomp = new descriptor._CONSTRUCTOR(vprops); // Cache a uniqueID on the vcomponent instance

        vcomp._uniqueId = oj.__AttributeUtils.getUniqueId(element.id);
        Object.defineProperty(element, '_vcomp', {
          value: vcomp,
          enumerable: false
        });
        vcomp.setCallbacks(this._getCallbacks(element));

        this._mountCustomElement(element, element._vcomp, vprops, slotMap);
      }

      element._vcomp.mounted(); // Set flag when we can fire property change events


      this.__READY_TO_FIRE = true; // Resolve the component busy state

      this.resolveDelayedReadyPromise();
    },
    // eslint-disable-next-line no-unused-vars
    DefineMethodCallback: function DefineMethodCallback(proto, method, methodMeta) {
      // eslint-disable-next-line no-param-reassign
      proto[method] = function () {
        // The VComponent is asynchronously instantiated by CreateComponent so we
        // need to check that this has happened before we call any methods defined on it.
        // Custom elements are upgraded synchronously meaning the method will be available
        // on the HTMLElement, but we tell applications to wait on the component busy context
        // before accessing properties and methods due to the asynch CreateComponent call.
        if (!this._vcomp) {
          var bridge = oj.BaseCustomElementBridge.getInstance(this);
          bridge.throwError(this, 'Cannot access methods before element is upgraded.');
        }

        return this._vcomp[method].apply(this._vcomp, arguments);
      };
    },
    DefinePropertyCallback: function DefinePropertyCallback(proto, property, propertyMeta) {
      /**
       * Property sets are processed differently whether they are coming from the application
       * or interally from the component. All outer application sets will be processed synchronously
       * since that would be the expected behavior, while internal component sets will be processed
       * asynchronously. This allows the application to update a property, like oj-table's selection,
       * which will then cause the component to update an associated property first-selected-row and
       * trigger the [property]Changed events after all the properties have been updated. Otherwise,
       * the application will receive a selectionChanged event when the firstSelectedRow property could
       * be out of sync. Rendering is done asynchronously regardless of whether an application or component update
       * occured.
       * @param {any} value The property value to set
       * @param {boolean} bOuterSet True if the set is coming from the custom element
       *                            instead of the bridge's _PROPS_PROXY
       */
      function set(value, bOuterSet) {
        var propertyUpdate = {
          isOuter: bOuterSet,
          name: property,
          value: value,
          meta: propertyMeta
        }; // For 9.0.0, making property mutations synchronous whether they're internal or external
        // (renders will still be async).  This means when updating multiple properties that the
        // property change events will be fired after each mutation rather than after all mutations
        // This will be revisited in the future.

        this._BRIDGE._updateProperty(this._ELEMENT, propertyUpdate, true);
      }

      function innerSet(value) {
        set.bind(this)(value, false);
      } // Called on the custom element


      function outerSet(value) {
        // VComponent-first elements should only be updated by its parent during rendering
        // and not through the live DOM updates. We will ignore outer sets
        // for VComponent-first elements to avoid being out of sync with the
        // state the parent believes its child to be in.
        var vcomp = this._vcomp;
        var bridge = oj.BaseCustomElementBridge.getInstance(this);

        if (!vcomp || vcomp.isCustomElementFirst()) {
          set.bind(bridge._PROPS_PROXY)(value, true);
        } else if (vcomp && !vcomp.isCustomElementFirst()) {
          bridge.throwError(this, 'Cannot set properties on a VComponent-first element.');
        }
      }

      function get() {
        // See note in below in outerGet() about accessing properties from the
        // custom element for the VComponent-first case
        var value = this._BRIDGE._PROPS[property]; // If the attribute has not been set, return the default value

        if (value === undefined) {
          value = this._BRIDGE._getDefaultValue(property, propertyMeta);
          this._BRIDGE._PROPS[property] = value;
        }

        return value;
      }

      function innerGet() {
        return get.bind(this)();
      } // Called on the custom element


      function outerGet() {
        var vcomp = this._vcomp; // VComponent-first elements should only be updated by its parent during rendering
        // and not through the live DOM updates. We will ignore outer gets
        // for VComponent-first elements, since they are an implementation detail of the parent element
        // and should not be interacted with in the DOM. This case will be treated as an unsupported error case
        // and always return undefined.

        if (vcomp && !vcomp.isCustomElementFirst()) {
          return undefined;
        }

        var bridge = oj.BaseCustomElementBridge.getInstance(this);
        return get.bind(bridge._PROPS_PROXY)();
      } // Don't add event listener properties for inner props


      if (!propertyMeta._derived) {
        oj.BaseCustomElementBridge.__DefineDynamicObjectProperty(proto._propsProto, property, innerGet, innerSet);
      }

      oj.BaseCustomElementBridge.__DefineDynamicObjectProperty(proto, property, outerGet, outerSet);
    },
    GetAttributes: function GetAttributes(metadata) {
      var attrs = oj.BaseCustomElementBridge.proto.GetAttributes.call(this, metadata); // Components can indicate additional global attributes they want to be notified about
      // via metadata. These attributes can be used by the component to then update the root
      // global attributes.

      var rootPropsMap = metadata.extension && metadata.extension._ROOT_PROPS_MAP;

      if (rootPropsMap) {
        Object.keys(rootPropsMap).forEach(function (prop) {
          attrs.push(oj.__AttributeUtils.getGlobalAttrForProp(prop));
        });
      }

      return attrs;
    },
    // This setting is involved in tracking child elements used for slots
    // for VComponents created as custom elements. The method is called when the
    // element is connected to the DOM, but it is not created yet.
    // Tracking children is prevented for vcomp-first elements, since such elements are
    // rendered first and children are already passed to them through props.
    // The GetTrackChildrenOption() is called on mount operation for already rendered component.
    // If tracking is not prevented at this point, the component would wait for its internal content.
    GetTrackChildrenOption: function GetTrackChildrenOption(element) {
      return element._vcomp ? 'none' : 'immediate';
    },
    ShouldHandleAttributeChanged: function ShouldHandleAttributeChanged(element) {
      if (!oj.BaseCustomElementBridge.proto.ShouldHandleAttributeChanged.call(this, element)) {
        return false;
      } // We only care about attribute change notifications if we're CustomElement-first,
      // since we need to re-render if the application has modified a controlled root property
      // directly on a custom element.
      //
      // Note that if the vcomp has not yet been created, we allow attribute changed
      // processing to continue, as BaseCustomElementBridge has binding-related work
      // that it may need to perform.


      var vcomp = element._vcomp;
      return !vcomp || vcomp.isCustomElementFirst() && !vcomp.isPatching();
    },
    HandleAttributeChanged: function HandleAttributeChanged(element, attr, oldValue, newValue) {
      var vcomp = element._vcomp;
      var rootPropsMap = this._EXTENSION._ROOT_PROPS_MAP;

      if (vcomp && rootPropsMap) {
        var prop = oj.__AttributeUtils.getGlobalPropForAttr(attr) || attr;

        if (rootPropsMap[prop] && oldValue !== newValue) {
          // Get the property value if there is one so we pass the correctly typed value
          // to the VComponent unless that value is null in which case we should remove
          // the property from controlled props since this will get merged to the VComponent's
          // this.props and we don't pass values into this.props if undefined.
          if (newValue == null) {
            delete this._LIVE_CONTROLLED_PROPS[prop]; // Only update the _VCOMP_CONTROLLED_PROPS if the update was not triggered
            // by the vcomponent during patching

            if (!vcomp.isPatching()) {
              delete this._VCOMP_CONTROLLED_PROPS[prop];
            }
          } else {
            var propValue = element[prop];
            this._LIVE_CONTROLLED_PROPS[prop] = propValue != null ? propValue : newValue;

            if (!vcomp.isPatching()) {
              this._VCOMP_CONTROLLED_PROPS[prop] = this._LIVE_CONTROLLED_PROPS[prop];
            }
          } // Only rerender if we're not updating during a VComponent patching of controlled
          // global properties


          if (!vcomp.isPatching()) {
            this._queueRender(element);
          }
        }
      }
    },
    // eslint-disable-next-line no-unused-vars
    HandleReattached: function HandleReattached(element) {
      this._verifyConnectDisconnect(element, 1);
    },
    // eslint-disable-next-line no-unused-vars
    HandleDetached: function HandleDetached(element) {
      this._verifyConnectDisconnect(element, 0);
    },
    _verifyConnectDisconnect: function _verifyConnectDisconnect(element, state) {
      if (this._verifyingState === -1) {
        window.queueMicrotask(function () {
          // This checks that we don't call any lifecycle hooks
          // for reparent case where _verifyingState has been
          // updated but the initial state we called
          // this Promise with is different
          if (this._verifyingState === state) {
            if (this._verifyingState === 0) {
              element._vcomp.unmounted();
            } else {
              element._vcomp.mounted();
            }
          }

          this._verifyingState = -1;
        }.bind(this));
      }

      this._verifyingState = state;
    },
    InitializeElement: function InitializeElement(element) {
      if (!element._vcomp) {
        if (oj.Components) {
          oj.Components.markPendingSubtreeHidden(element);
        }

        oj.BaseCustomElementBridge.__InitProperties(element, element); // After initializing properties from DOM attributes, go through
        // event metadata and add appropriate callbacks


        this.InitializeEventCallbacks(element);
      }
    },
    InitializePrototype: function InitializePrototype(proto) {
      // Invoke callback on the superclass
      oj.BaseCustomElementBridge.proto.InitializePrototype.call(this, proto);
      Object.defineProperty(proto, '_propsProto', {
        value: {}
      });
    },
    InitializeBridge: function InitializeBridge(element, descriptor) {
      // Invoke callback on the superclass
      oj.BaseCustomElementBridge.proto.InitializeBridge.call(this, element, descriptor); // Flag used to detect a verified connected/disconnected state
      // -1 = not verifying
      // 0 = disconnected
      // 1 = connected

      this._verifyingState = -1;
      this._EXTENSION = this.METADATA.extension || {};
      this._CONSTRUCTOR = descriptor._CONSTRUCTOR; // For tracking all properties (source of truth for property storage)

      this._PROPS = {}; // Stores any requested property updates, gets processed synchronously for outer sets, but asynch for inner sets

      this._PROP_CHANGE_QUEUE = []; // Stores property change events that are waiting to be fired.  When multiple property updates are being processed in _PROP_CHANGE_QUEUE,
      // events are stored in _PROP_CHANGE_EVENT_QUEUE until property updates have been reflected, then all events are fired

      this._PROP_CHANGE_EVENT_QUEUE = []; // Has getters/setters and calls to set properties on this._PROPS

      if (element._propsProto) {
        this._PROPS_PROXY = Object.create(element._propsProto);
        this._PROPS_PROXY._BRIDGE = this;
        this._PROPS_PROXY._ELEMENT = element;
      } // We need to maintain two sets of controlled properties in the bridge. One set of controlled properties
      // should always reflect the current state of the DOM even after internal changes that occur during
      // patching and a second version that does not reflect the internal changes that we merge to the props
      // we pass to the VComponent for rendering. This former collection is what petit-dom will use as the
      // 'old' root props for patching. This will allow petit-dom to correctly respond to both application and
      // VComponent updates to controlled properties.


      this._LIVE_CONTROLLED_PROPS = {};
      this._VCOMP_CONTROLLED_PROPS = {};
    },
    InitializeEventCallbacks: function InitializeEventCallbacks(element) {
      var _this3 = this;

      var eventsMeta = this.METADATA.events;

      if (eventsMeta) {
        Object.keys(eventsMeta).forEach(function (event) {
          var eventMeta = eventsMeta[event];

          var eventProp = oj.__AttributeUtils.eventTypeToEventListenerProperty(event);

          _this3._PROPS[eventProp] = function (detailObj) {
            var detail = Object.assign({}, detailObj); // If we're firing a cancelable event, inject an accept function into
            // the event detail so the consumer can asynchronously cancel the event.
            // We only support an asynchronously cancelable event at the moment.

            var cancelable = !!eventMeta.cancelable;
            var acceptPromises = [];

            if (cancelable) {
              detail.accept = function (promise) {
                acceptPromises.push(promise);
              };
            }

            var eventDescriptor = {
              detail: detail,
              bubbles: !!eventMeta.bubbles,
              cancelable: cancelable
            };
            var customEvent = new CustomEvent(event, eventDescriptor);
            element.dispatchEvent(customEvent);

            if (cancelable) {
              return customEvent.defaultPrevented ? Promise.reject() : Promise.all(acceptPromises).then(function () {
                return Promise.resolve();
              }, function (reason) {
                return Promise.reject(reason);
              });
            }

            return undefined;
          };
        });
      }
    },
    PlaybackEarlyPropertySets: function PlaybackEarlyPropertySets(element) {
      if (!element._vcomp) {
        oj.BaseCustomElementBridge.proto.PlaybackEarlyPropertySets.call(this, element);
      }
    },
    GetPreCreatePromise: function GetPreCreatePromise(element) {
      var promise = oj.BaseCustomElementBridge.proto.GetPreCreatePromise.call(this, element); // If the template engine has not yet been loaded, and we have have some template elements as direct children,
      // chain the base class's pre-create promise with the promise for the template engine becoming
      // loaded and cached
      // eslint-disable-next-line no-use-before-define

      if (!_cachedTemplateEngine && _hasDirectTemplateChildren(element)) {
        promise = promise.then(function () {
          return _getTemplateEnginePromise();
        });
      }

      return promise;
    },
    ValidateAndSetProperty: function ValidateAndSetProperty(propNameFun, componentProps, property, value, element) {
      var _value = this.ValidatePropertySet(element, property, value);

      VirtualElementBridge.__SetProperty(propNameFun, componentProps, property, _value);
    },
    _mountCustomElement: function _mountCustomElement(element, vcomp, vprops, slotMap) {
      // Cache the slot content because custom elements don't support reslotting
      this._content = VirtualElementBridge._processSlotContent(element, slotMap); // Make a copy of the controlled props so we get a snapshot before mounting.
      // We want to avoid the case where a VComponent updates the custom element
      // controlled properties during mount and the controlled props are updated
      // before a queued render is called.

      var controlledPropsCopy = Object.assign({}, this._LIVE_CONTROLLED_PROPS); // mountContent appends child nodes to element

      vcomp.mountContent(vprops, this._content, element, controlledPropsCopy);
    },

    /**
     * Property update callback to pass to VComponent.  Delegates to _PROPS_PROXY
     * which calls the inner set methods
     * @param {HTMLElement} element The custom element to process a property change for
     * @param {string} prop The property to update
     * @param {any} value The new property value
     * @return void
     * @private
     */
    _queuePropertyUpdate: function _queuePropertyUpdate(element, prop, value, queueRender) {
      this._PROPS_PROXY[prop] = value;

      if (queueRender) {
        this._queueRender(element);
      }
    },

    /**
     * Pushes a property update to the queue. Processes the queue synchronously or asynchronously based on the specified flag.
     * Called by both inner and outer sets.
     *
     * @param {HTMLElement} element The custom element to process a property change for
     * @param {Object} propertyUpdate An object containing isOuter, name, value, meta keys
     * @param {boolean} sync whether to process the property synchronously
     * @private
     */
    _updateProperty: function _updateProperty(element, propertyUpdate, sync) {
      this._PROP_CHANGE_QUEUE.push(propertyUpdate); // Process the property set queue immediately for outer sets, but asynchronously for inner sets


      if (sync) {
        this._processPropertyQueue(element);
      } else if (!this._propsProcessingQueued) {
        // We do not need to add a busy state here because
        // the properties are processed as microtasks and
        // should be completed by the time the application
        // needs to interact with the component
        this._propsProcessingQueued = true;
        window.queueMicrotask(function () {
          this._processPropertyQueue(element);

          this._propsProcessingQueued = false;
        }.bind(this));
      }
    },

    /**
     * Process and apply the current set of property updates.
     * @param {HTMLElement} element The custom element to process a property change for
     * @return void
     * @private
     */
    _processPropertyQueue: function _processPropertyQueue(element) {
      var propertyUpdate = this._PROP_CHANGE_QUEUE.shift();

      while (propertyUpdate) {
        var name = propertyUpdate.name;
        var value = propertyUpdate.value;
        var meta = propertyUpdate.meta; // Properties can be set before the component is created. These early
        // sets are actually saved until after component creation and played back.

        if (!this.SaveEarlyPropertySet(name, value)) {
          var previousValue = this._PROPS[name];

          if (!oj.BaseCustomElementBridge.__CompareOptionValues(name, meta, value, previousValue)) {
            // Skip validation for inner sets so we don't throw an error when updating readOnly
            // writeable properties
            if (propertyUpdate.isOuter) {
              value = this.ValidatePropertySet(element, name, value);
            } // Instead of updating undefined in our property bag, delete the key
            // so later when we copy props for vcomponent rendering, we can use
            // Object.assign without overriding default values when the value is undefined


            if (value === undefined) {
              delete this._PROPS[name];
            } else {
              this._PROPS[name] = value;
            } // Queue a property change event to fire


            propertyUpdate.previousValue = previousValue;

            this._PROP_CHANGE_EVENT_QUEUE.push(propertyUpdate); // This will get called before connected callback so short circuit render for that case
            // Only force render for outer sets, internal sets can optionally trigger renders and will
            // be queued separately by the VComponent


            if (element._vcomp && propertyUpdate.isOuter) {
              this._queueRender(element);
            }
          }
        }

        propertyUpdate = this._PROP_CHANGE_QUEUE.shift();
      }

      this._firePropertyChangeEvents(element);
    },

    /**
     * Processes the current property changed queue and fires the appropriate
     * [property]Changed event from the custom element.
     * @param {HTMLElement} element The custom element to fire a [property]Changed event for
     * @return void
     * @private
     */
    _firePropertyChangeEvents: function _firePropertyChangeEvents(element) {
      var propertyUpdate = this._PROP_CHANGE_EVENT_QUEUE.shift();

      while (propertyUpdate) {
        oj.BaseCustomElementBridge.__FirePropertyChangeEvent(element, propertyUpdate.name, propertyUpdate.value, propertyUpdate.previousValue, propertyUpdate.isOuter ? 'external' : 'internal');

        propertyUpdate = this._PROP_CHANGE_EVENT_QUEUE.shift();
      }
    },

    /**
     * Registers an asynchronous component render as a result of a state or property update.
     * @param {HTMLElement} element The custom element to queue a render for
     * @return void
     * @private
     */
    _queueRender: function _queueRender(element) {
      element._vcomp.queueRender(element, 'propsUpdate');
    },

    /**
     * We need to make a copy of the properties any time we hand off props to the vcomp,
     * as we mutate our own copy and vcomp should not be exposed to these changes
     * (until we hand off a new copy). We will also augment the props we pass to the vcomp
     * with any controlled properties and slots the component has registered.
     * @private
     */
    _getVComponentProps: function _getVComponentProps() {
      var staticDefaults = ojdefaultsutils.DefaultsUtils.getStaticDefaults(this._CONSTRUCTOR, this.METADATA, true);
      var propsCopy = Object.create(staticDefaults); // Copy the current root props into this.props so component can initialize property dependent state

      return Object.assign(propsCopy, this._PROPS, this._VCOMP_CONTROLLED_PROPS);
    },

    /**
     * Returns an object containing override callbacks for VComponent functionality so that we can
     * cause different behavior for the custom element-first case.
     *
     * @private
     */
    _getCallbacks: function _getCallbacks(element) {
      var _this4 = this;

      return {
        _updateProperty: this._queuePropertyUpdate.bind(this, element),
        getPropsForRender: function getPropsForRender() {
          return _this4._getVComponentProps();
        },
        patch: function patch(props) {
          // The errors thrown by the VComponent logic after a busy state
          // is registered in the queueRender() method will be caught by queueRender()
          // try-catch block. The caller will resolve the busy state for that case.
          var controlledPropsCopy = Object.assign({}, _this4._LIVE_CONTROLLED_PROPS);

          element._vcomp.patchContent(props, controlledPropsCopy, _this4._content); // Store unslotted nodes


          VirtualElementBridge._storeUnslottedNodes(element, _this4._slotVNodes);
        },
        convertChildrenToSlotProps: function convertChildrenToSlotProps(children) {
          // Only process children after initial render for the custom element first case
          if (!_this4._slotProps) {
            // Save the slot nodes so we can store unslotted nodes after render
            _this4._slotVNodes = children; // Generate the map of slot property names to vnode arrays

            var slotMap = _generateSlotMap(children, _this4.METADATA, _this4._EXTENSION); // Convert to map of slot property names as the right types
            // 1) VNode[] for default children property
            // 2) () => VNode[] for named non template slots
            // 3) (context) => VNode[] for template slots


            _this4._slotProps = _generateSlotPropsMap(element, slotMap);
          }

          return _this4._slotProps;
        }
      };
    },

    /**
     * Initializes controlled roop props based on the controlled properties specified in the metadata
     * and the attributes of the specified element
     * @param {HTMLElement} element
     * @private
     */
    _initializeControlledProps: function _initializeControlledProps(element) {
      var rootPropsMap = this._EXTENSION._ROOT_PROPS_MAP;

      if (rootPropsMap) {
        var liveRootProps = this._LIVE_CONTROLLED_PROPS;
        var vcompRootProps = this._VCOMP_CONTROLLED_PROPS;
        Object.keys(rootPropsMap).forEach(function (prop) {
          var attr = oj.__AttributeUtils.getGlobalAttrForProp(prop);

          if (element.hasAttribute(attr)) {
            // Try and get the property so the type is correct, if not available
            // get the attribute value, e.g. data-, aria-, tabindex (since property is tabIndex)
            var propValue = element[prop];
            liveRootProps[prop] = propValue != null ? propValue : element.getAttribute(attr);
            vcompRootProps[prop] = liveRootProps[prop];
          }
        });
      }
    },
    _getDefaultValue: function _getDefaultValue(property) {
      // A read only copy of the default value
      return ojdefaultsutils.DefaultsUtils.getFrozenDefault(property, this._CONSTRUCTOR, this.METADATA);
    }
  });
  /**
   * @export
   */

  VirtualElementBridge.register = function (tagName, constr) {
    var metadata = constr.metadata;
    var descriptor = {};
    descriptor[oj.BaseCustomElementBridge.DESC_KEY_META] = metadata;
    descriptor._CONSTRUCTOR = constr;

    if (oj.BaseCustomElementBridge.__Register(tagName, descriptor, VirtualElementBridge.proto)) {
      customElements.define(tagName.toLowerCase(), VirtualElementBridge.proto.getClass(descriptor));
    }
  };
  /**
   * @private
   */


  function _hasDirectTemplateChildren(element) {
    var childNodeList = element.childNodes;

    for (var i = 0; i < childNodeList.length; i++) {
      var child = childNodeList[i];

      if (child.localName === 'template') {
        return true;
      }
    }

    return false;
  }
  /**
   * @private
   */


  var _cachedTemplateEngine;
  /**
   * @private
   */


  function _getTemplateEnginePromise() {
    return new Promise(function (resolve, reject) {
      require(['ojs/ojtemplateengine'], function (eng) {
        _cachedTemplateEngine = eng;
        resolve(eng);
      }, reject);
    });
  }
  /**
   * Creates a storage node for a custom element, moves all slot content to
   * the storage node and returns an Array of virtual nodes representing the
   * slot content or null if the custom element has no slot content.
   * @param {Element} element The custom element
   * @param {Object} slotMap
   * @return {Array}
   * @private
   */


  VirtualElementBridge._processSlotContent = function (element, slotMap) {
    var content = [];

    if (element.childNodes) {
      // Needed to replicate what shadow DOM does since we don't have a
      // shadow root to hide slot content that do not map to a component
      // defined slot.
      if (!element._nodeStorage) {
        // eslint-disable-next-line no-param-reassign
        element._nodeStorage = document.createElement('div'); // eslint-disable-next-line no-param-reassign

        element._nodeStorage.style.display = 'none';
        element.appendChild(element._nodeStorage);
      } // Array of virtual nodes we will pass to the VComponent mountContent method


      var assignableNodes = [];
      var entries = Object.entries(slotMap);
      entries.forEach(function (entry) {
        var slot = entry[0];
        entry[1].forEach(function (node) {
          // Create a lightweight virtual node that contains a reference
          // back to the original slot content and slot value
          content.push(_wrapNode(node, slot));
          assignableNodes.push(node);
        });
      });
      assignableNodes.forEach(function (assignableNode) {
        element._nodeStorage.appendChild(assignableNode); // @HTMLUpdateOK
        // Notifies JET components inside nodeStorage that they have been hidden
        // For upstream or indirect dependency we will still rely components being registered on the oj namespace.


        if (oj.Components) {
          oj.Components.subtreeHidden(assignableNode);
        }
      });
    }

    return content;
  };
  /**
   * @param {function} propNameFun A function that returns the actual property name to use, e.g. an alias
   * @param {Object} componentProps The object to set the new property value on which is the
   *                                element for outer property sets and the property bag for inner sets.
   * @param {string} property The property name
   * @param {Object} value The value to set for the property
   * @ignore
   */


  VirtualElementBridge.__SetProperty = function (propNameFun, componentProps, property, value) {
    var propsObj = componentProps;
    var propPath = property.split('.');
    var branchedProps; // Set subproperty, initializing parent objects along the way unless the top level
    // property is not defined since setting it to an empty object will trigger a property changed
    // event. Instead, branch and set at the end. We only have listeners on top level properties
    // so setting a subproperty will not trigger a property changed event along the way.

    var topProp = propNameFun(propPath[0]);

    if (propPath.length > 1 && !componentProps[topProp]) {
      branchedProps = {};
      propsObj = branchedProps;
    } // Walk to the correct location


    for (var i = 0; i < propPath.length; i++) {
      var subprop = propNameFun(propPath[i]);
      var objValue = propsObj[subprop];

      if (i === propPath.length - 1) {
        propsObj[subprop] = value;
      } else if (!objValue) {
        propsObj[subprop] = {};
      } else if (Object.isFrozen(objValue)) {
        // If value is frozen, make a copy since we freeze default values
        propsObj[subprop] = oj.CollectionUtils.copyInto({}, objValue, undefined, true);
      }

      propsObj = propsObj[subprop];
    } // Update the original component properties if we branched


    if (branchedProps) {
      // eslint-disable-next-line no-param-reassign
      componentProps[topProp] = branchedProps[topProp];
    }
  };
  /**
   * Given a custom element and its slotMap, checks all slotted nodes to see
   * if they were removed during patching and moves that node to the storage node.
   * Otherwise, unslotted content will get an unmounted call and knockout variables
   * receiving updates when not attached to the DOM will become out of sync.
   * @param {Element} element The custom element
   * @param {Array} slotVNodes The current array of slot vnodes for the element
   * @return {void}
   * @private
   */


  VirtualElementBridge._storeUnslottedNodes = function (element, slotVNodes) {
    if (slotVNodes && element._nodeStorage) {
      slotVNodes.forEach(function (vnode) {
        var node = vnode._node; // Check to see if the node has been disconnected in the last rerender
        // and move to the storage node and notify that node that it's been hidden.
        // Petit-dom handles calling subtreeShown when appending children into DOM.

        if (!node.isConnected) {
          element._nodeStorage.appendChild(node);

          if (oj.Components) {
            oj.Components.subtreeHidden(node);
          }
        }
      });
    }
  };
  /**
   * Helper function that takes a DOM node and wraps it in a lightweight vnode object
   * @param {Element} node The DOM node to wrap
   * @param {string?} slot An optional slot name for the vnode props. This can be different
   *                       from the slot attribute value and is only needed for children that
   *                       will be passed as content to the VComponent mount/patch methods
   *                       See oj.BaseCustomElementBridge.getSlotAssignment() for slot name details.
   * @return {object}
   * @private
   */


  function _wrapNode(node, slot) {
    switch (node.nodeType) {
      // Comment nodes are not considered slottable, but
      // we need these in the template case. For normal slots,
      // the map we get from the bridge shouldn't contain any comment
      // nodes. We don't care about DOM updates in that case since it's
      // not supported. For template slots, if the root node is an
      // oj-bind-if for example, we want that to work correctly when udpates
      // occur.
      case Node.COMMENT_NODE:
        return {
          _node: node
        };

      case Node.TEXT_NODE:
        return {
          _text: node.nodeValue,
          _node: node
        };

      case Node.ELEMENT_NODE:
        var content = []; // Wrap child nodes for petit-dom patching.
        // There is no reslotting, but the component may slot
        // a different child node on subsequent renders (e.g. oj-switcher tab switching)
        // so we need to ensure the vnode is as 'real' as possible to ensure the DOM
        // will be updated correctly during patching.

        node.childNodes.forEach(function (childNode) {
          // These are just child nodes of the slotted parent node so we don't need to pass
          // a slot for the child
          var wrappedChild = _wrapNode(childNode); // Skip non text/element nodes like comment nodes


          if (wrappedChild) {
            content.push(wrappedChild);
          }
        });
        var vnode = {
          type: node.tagName.toLowerCase(),
          _node: node,
          props: node,
          content: content
        }; // IE does not have slot property support so the slot attribute will not
        // get mapped to a slot property. We will need to populate it ourselves.

        if (slot != null && vnode.props.slot !== slot) {
          vnode.props.slot = slot;
        }

        return vnode;

      default:
        return null;
    }
  }
  /**
   * Helper function that unwraps a DOM node from a vnode
   * @param {object} vnode The vnode to unwrap
   * @return {Element}
   * @private
   */


  function _unwrapNode(vnode) {
    return vnode && vnode._node;
  }
  /**
   * Generates a slot property map of VNode[]
   * @param {Array} children The vnodes to process
   * @param {object} metadata The component metadata
   * @return {object}
   * @private
   */


  function _generateSlotMap(children, metadata, ext) {
    var slots = metadata.slots || {};
    var dynamicSlotProp = ext._DYNAMIC_SLOT_PROP;
    var slotMap = {};
    children.forEach(function (vnode) {
      // Text nodes and comment nodes don't have a vnode.props
      // field and always map to the default slot. Note that normally
      // comment nodes aren't slottable, but we need them for the template case.
      var slot = vnode.props ? vnode.props.slot : ''; // If slot name is defined check to see if it exists in the metadata as a named slot. If it doesn't
      // then it may be a dynamic slot so stash it as under the slot property for dynamic slots.

      var slotProp = VirtualElementBridge._DEFAULT_SLOT_PROP;

      if (slot) {
        slotProp = slots[slot] ? slot : dynamicSlotProp;
      }

      if (slotProp === dynamicSlotProp) {
        // Stop processing if node doesn't match any named slots and component
        // does not define a dynamic slot.
        if (!dynamicSlotProp) {
          return;
        } // Dynamic slots


        if (!slotMap[slotProp]) {
          slotMap[slotProp] = _defineProperty({}, slot, []);
        }

        if (!slotMap[slotProp][slot]) {
          slotMap[slotProp][slot] = [];
        }

        slotMap[slotProp][slot].push(vnode);
      } else if (slotProp) {
        // Named and default slots
        if (!slotMap[slotProp]) {
          slotMap[slotProp] = [];
        }

        slotMap[slotProp].push(vnode);
      }
    });
    return slotMap;
  }
  /**
   * Converts a slot map to the correct slot property types
   * @param {Element} element The custom element
   * @param {object} slotMap The slot map to process
   * @return {object}
   * @private
   */


  function _generateSlotPropsMap(element, slotMap) {
    var propsMap = {};
    Object.keys(slotMap).forEach(function (slot) {
      var slotContent = slotMap[slot]; // The default slot is returned as VNode[], but all others are returned as render functions

      if (slot === VirtualElementBridge._DEFAULT_SLOT_PROP) {
        propsMap[slot] = slotContent;
      } else if (Array.isArray(slotContent)) {
        propsMap[slot] = getSlotRenderFunc(element, slotContent);
      } else {
        // Dynamic slot case
        if (!propsMap[slot]) {
          propsMap[slot] = {};
        }

        Object.keys(slotContent).forEach(function (dynSlot) {
          propsMap[slot][dynSlot] = getSlotRenderFunc(element, slotContent[dynSlot]);
        });
      }
    });
    return propsMap;
  }
  /**
   * Helper to create a slot render function and lazily execute a template engine
   * if a context object is passed to the slot render, returning the vnodes otherwise.
   * @param {Element} element The custom element
   * @param {object} vnodes The vnode array to return/process for the slot
   * @return {object}
   * @private
   */


  function getSlotRenderFunc(element, vnodes) {
    return function (context) {
      // Dynamically check to see if the slot render function was called with
      // a context object. If it was and the slot node is a template node,
      // execute the template engine and wrap the resulting DOM nodes. Otherwise
      // return the vnodes directly.
      if (context) {
        var templateNode = _unwrapNode(vnodes[0]);

        if (templateNode.nodeName === 'TEMPLATE') {
          if (!_cachedTemplateEngine) {
            throw new Error('Unexpected call to render a template slot');
          }

          var domNodes = _cachedTemplateEngine.execute(element, templateNode, context);

          return domNodes.map(function (node) {
            var vnode = _wrapNode(node); // Pass a reference to the template engine's clean method so
            // petit-dom can call it before removing any template nodes from the DOM


            vnode._clean = _cachedTemplateEngine.clean.bind(null, node);
            return vnode;
          });
        }
      }

      return vnodes;
    };
  }

  function customElement(tagName) {
    return function (constructor) {
      var componentRender = constructor.prototype.render;

      constructor.prototype.render = function () {
        var vnode = componentRender.call(this);

        if (vnode.type !== tagName) {
          vnode = PetitDom.h(tagName, null, vnode);
        }

        _verifyProps(vnode.props, constructor['metadata']);

        return vnode;
      };

      constructor.prototype.mount = function (props, content, uncontrolledRootProps) {
        this._vnode = this._renderForMount(props, content);
        var mountNode = this._ref = PetitDom.mountCustomElement(this._vnode, uncontrolledRootProps);
        Object.defineProperty(mountNode, '_vcomp', {
          value: this,
          enumerable: false
        });
        return mountNode;
      };

      constructor.prototype.patch = function (props, content, uncontrolledRootProps, oldUncontrolledRootProps) {
        var oldProps = this.props;
        var oldState = this.state;
        var oldVnode = this._vnode;
        this._vnode = this._renderForPatch(props, content);
        this._vnode['_node'] = this._ref;
        this._patching = true;

        try {
          PetitDom.patchCustomElement(this._vnode, oldVnode, uncontrolledRootProps, oldUncontrolledRootProps);
        } finally {
          this._patching = false;
        }

        this.updated(oldProps, oldState);
      };

      constructor.prototype.mountContent = function (props, content, rootElem, controlledRootProps) {
        this._isCustomElementFirst = true;
        this._ref = rootElem;
        this._vnode = this._renderForMount(props, content);
        this._vnode._node = rootElem;
        this._patching = true;

        try {
          PetitDom.mountCustomElementContent(this._vnode, controlledRootProps);
        } finally {
          this._patching = false;
        }
      };

      constructor.prototype.patchContent = function (props, controlledRootProps, content) {
        var oldProps = this.props;
        var oldState = this.state;
        var oldVnode = this._vnode;
        this._vnode = this._renderForPatch(props, content);
        this._vnode['_node'] = this._ref;
        this._patching = true;

        try {
          PetitDom.patchCustomElementContent(this._vnode, oldVnode, controlledRootProps);
        } finally {
          this._patching = false;
        }

        this.updated(oldProps, oldState);
      };

      constructor.prototype.setCallbacks = function (callbacks) {
        this._callbacks = callbacks;
      };

      constructor.prototype.isCustomElementFirst = function () {
        return this._isCustomElementFirst === true;
      };

      constructor.prototype.isPatching = function () {
        return this._patching;
      };

      function _isValidRootProp(prop, metadata) {
        var _a;

        var allowedProps = {
          class: true,
          style: true,
          ref: true,
          key: true
        };
        var verifiedRootPropMap = ((_a = metadata.extension) === null || _a === void 0 ? void 0 : _a['_ROOT_PROPS_MAP']) || {};
        return allowedProps[prop] || verifiedRootPropMap[prop] || oj.__AttributeUtils.eventListenerPropertyToEventType(prop) !== null;
      }

      function _verifyProps(props, metadata) {
        for (var prop in props) {
          if (!_isValidRootProp(prop, metadata)) {
            throw new Error('Component can only render controlled global properties or DOM event listeners on the root custom element. ' + prop + ' will not be rendered.');
          }
        }
      }

      VirtualElementBridge.register(tagName, constructor);
    };
  }

  function listener(options) {
    return function (target, key, descriptor) {
      var fn = descriptor === null || descriptor === void 0 ? void 0 : descriptor.value;
      return {
        configurable: true,
        get: function get() {
          var boundFn = fn.bind(this);
          boundFn[PetitDom.LISTENER_OPTIONS_SYMBOL] = options;
          Object.defineProperty(this, key, {
            configurable: true,
            get: function get() {
              return boundFn;
            },
            set: function set(value) {
              fn = value;
              delete this[key];
            }
          });
          return boundFn;
        },
        set: function set(value) {
          fn = value;
        }
      };
    };
  }

  function dynamicDefault(defaultGetter) {
    return function (target, propertyKey) {
      var key = Symbol();
      return {
        get: function get() {
          var value = this[key];
          return value === undefined ? defaultGetter() : value;
        },
        set: function set(value) {
          this[key] = value;
        }
      };
    };
  }

  function method() {
    return function (target, propertyKey, descriptor) {};
  }

  function rootProperty() {
    return function (target, propertyKey) {};
  }

  function _writeback() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      readOnly: false
    },
        boolean = _ref.readOnly;

    return function (target, propertyKey) {};
  }

  function event() {
    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      bubbles: false
    },
        boolean = _ref2.bubbles;

    return function (target, propertyKey) {};
  }

  exports.VComponent = VComponent;
  exports._writeback = _writeback;
  exports.classPropToObject = classPropToObject;
  exports.customElement = customElement;
  exports.dynamicDefault = dynamicDefault;
  exports.event = event;
  exports.h = h;
  exports.listener = listener;
  exports.method = method;
  exports.rootProperty = rootProperty;
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
});
}());
(function() {function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

define('ojs/ojpopupcore',['exports', 'ojs/ojcore-base', 'jquery', 'ojs/ojcomponentcore', 'ojs/ojlogger', 'jqueryui-amd/position', 'ojs/ojcontext', 'ojs/ojvcomponent'], function (exports, oj, $, Components, Logger, position, Context, ojvcomponent) {
  'use strict';

  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;
  /**
   * @license
   * Copyright (c) 2004 2020, Oracle and/or its affiliates.
   * The Universal Permissive License (UPL), Version 1.0
   * as shown at https://oss.oracle.com/licenses/upl/
   * @ignore
   */

  /**
   * Invokes the callback function with the touchstart event if the touch sequence
   * resulted in a "Tap".  The goal is to distinguish a touchstart that doesn't result
   * in scroll.
   * @extends {oj.Object}
   * @public
   * @constructor
   * @class SimpleTapRecognizer
   * @since 1.1.0
   * @param {function(!Event)} tapCallback function invoked when a Tap is detected
   * @ignore
   * @ojtsignore
   */

  var SimpleTapRecognizer = function SimpleTapRecognizer(tapCallback) {
    this._tapCallback = tapCallback;
    this.Init();
  };

  oj._registerLegacyNamespaceProp('SimpleTapRecognizer', SimpleTapRecognizer);

  oj.Object.createSubclass(SimpleTapRecognizer, oj.Object, 'oj.SimpleTapRecognizer');
  /**
   * Sets up the touch listeners ready to fire the callback.
   * @override
   * @instance
   * @protected
   */

  SimpleTapRecognizer.prototype.Init = function () {
    SimpleTapRecognizer.superclass.Init.call(this);

    var eventHandlerCallback = this._eventHandler.bind(this);

    this._eventHandlerCallback = eventHandlerCallback;
    var docElement = document.documentElement;
    var eventType;

    for (var i = 0; i < SimpleTapRecognizer._TOUCHEVENTS.length; i++) {
      eventType = SimpleTapRecognizer._TOUCHEVENTS[i];

      if (eventType === 'touchstart' || eventType === 'touchmove') {
        docElement.addEventListener(eventType, eventHandlerCallback, {
          passive: false,
          capture: true
        });
      } else {
        docElement.addEventListener(eventType, eventHandlerCallback, true);
      }
    }
  };
  /**
   * Keeps reference to the last touchstart event.  If at touchend is encountered before a
   * touchmove or touchcancel, then fire the tap callback with the touchstart event.
   * @private
   * @param {Event} event native touch event
   */


  SimpleTapRecognizer.prototype._eventHandler = function (event) {
    var tapCallback = this._tapCallback;
    var eventType = event.type;

    if (eventType === 'touchstart') {
      this._touchStartEvent = event;
      this._touchStartEvent._tapStart = new Date().getTime();
    } else if (eventType === 'touchmove' || eventType === 'touchcancel') {
      this._touchStartEvent = null;
    } else if (eventType === 'touchend') {
      if (this._touchStartEvent) {
        var tapStart = this._touchStartEvent._tapStart;

        if (!isNaN(tapStart)) {
          var now = new Date().getTime(); // if the period of ms between touchstart and touchend is less than the long touch
          // thresshold, invoke the callback

          if (now - tapStart < SimpleTapRecognizer._PRESSHOLDTHRESSHOLD) {
            tapCallback(this._touchStartEvent);
          }
        } else {
          tapCallback(this._touchStartEvent);
        }
      }

      this._touchStartEvent = null;
    }
  };
  /**
   * Unregisters touch listeners and deletes references to callbacks.
   * @public
   */


  SimpleTapRecognizer.prototype.destroy = function () {
    this._tapCallback = null;
    var eventHandlerCallback = this._eventHandlerCallback;
    this._eventHandlerCallback = null;
    var docElement = document.documentElement;
    var eventType;

    for (var i = 0; i < SimpleTapRecognizer._TOUCHEVENTS.length; i++) {
      eventType = SimpleTapRecognizer._TOUCHEVENTS[i];

      if (eventType === 'touchstart' || eventType === 'touchmove') {
        docElement.removeEventListener(eventType, eventHandlerCallback, {
          passive: false,
          capture: true
        });
      } else {
        docElement.removeEventListener(eventType, eventHandlerCallback, true);
      }
    }
  };
  /**
   * Touch events that we are interested in listening for.
   *
   * @const
   * @private
   * @type {Array.<string>}
   */


  SimpleTapRecognizer._TOUCHEVENTS = ['touchstart', 'touchmove', 'touchcancel', 'touchend'];
  /**
   * Period of milliseconds for determining a long tap.  The normal threshold is 750ms.
   * The auto dismissal listeners for capture events versus bubble by the rest of the
   * framework.  Make the window for determining a long tap shorter than normal
   *
   * @const
   * @private
   * @type {number}
   */

  SimpleTapRecognizer._PRESSHOLDTHRESSHOLD = 700;
  /* jslint browser: true*/

  /**
   * Internal framework service for managing popup instances.
   *
   * @extends {oj.Object}
   * @protected
   * @constructor
   * @since 1.1.0
   * @class oj.PopupService
   * @ignore
   * @ojtsignore
   */

  var PopupService = function PopupService() {
    this.Init();
  };

  oj._registerLegacyNamespaceProp('PopupService', PopupService);

  oj.Object.createSubclass(PopupService, oj.Object, 'oj.PopupService'); // Classes defined here to avoid ESLint no-use-before-define requirement

  var PopupServiceImpl = function PopupServiceImpl() {
    this.Init();
  };

  var ZOrderUtils = {};
  /**
   * @override
   * @instance
   * @protected
   */

  PopupService.prototype.Init = function () {
    PopupService.superclass.Init.call(this);
  };
  /**
   * @param {Object=} options used by the factory method for service instantiation
   * @return {!oj.PopupService} singleton instance of the manager
   * @public
   */
  // eslint-disable-next-line no-unused-vars


  PopupService.getInstance = function (options) {
    // in the future we might need a JET Island impl
    if (!PopupService._popupService) {
      PopupService._popupService = new PopupServiceImpl();
    }

    return PopupService._popupService;
  };
  /**
   * @param {!Object.<PopupService.OPTION, ?>} options property bag for opening the popup
   * @return {void}
   * @instance
   * @public
   */
  // eslint-disable-next-line no-unused-vars


  PopupService.prototype.open = function (options) {
    oj.Assert.failedInAbstractFunction();
  };
  /**
   * @param {!Object.<PopupService.OPTION, ?>} options property bag for closing the popup
   * @return {void}
   * @instance
   * @public
   */
  // eslint-disable-next-line no-unused-vars


  PopupService.prototype.close = function (options) {
    oj.Assert.failedInAbstractFunction();
  };
  /**
   * @param {!Object.<PopupService.OPTION, ?>} options property bag to change
   * the state of the target popup.
   * @return {void}
   * @instance
   * @public
   */
  // eslint-disable-next-line no-unused-vars


  PopupService.prototype.changeOptions = function (options) {
    oj.Assert.failedInAbstractFunction();
  };
  /**
   * @param {!jQuery} popup to target triggering the event on decendents
   * @param {!PopupService.EVENT} event to trigger
   * @param {Array=} argsArray to pass to the associated callback for the event
   * @return {void}
   * @instance
   * @public
   */
  // eslint-disable-next-line no-unused-vars


  PopupService.prototype.triggerOnDescendents = function (popup, event, argsArray) {
    oj.Assert.failedInAbstractFunction();
  };
  /**
   * @return {void}
   * @instance
   * @public
   */


  PopupService.prototype.destroy = function () {
    PopupService._popupService = null;
  };
  /**
   * Dialog modality states.
   * @enum {string}
   * @public
   * @ojtsignore
   */


  PopupService.MODALITY = {
    /** Type of popup that doesn't support modality */
    NONE: 'none',

    /** Dialog that that blocks user input of the primary window.*/
    MODAL: 'modal',

    /** Type of dialog that doesn't block user input of the primary window */
    MODELESS: 'modeless'
  };
  /**
   * Event names used to identify the {@link PopupService.OPTION.EVENT} option
   * property.
   * @enum {string}
   * @public
   * @ojtsignore
   */

  PopupService.EVENT = {
    /**
     * Event called by the popup service when the surrogate is removed in the document
     * resulting in the popup getting implicitly closed and associated bound element
     * is removed */
    POPUP_REMOVE: 'ojPopupRemove',

    /**
     * Event called when a parent popup is closed causing implicit closure of
     * descendent popups.
     */
    POPUP_CLOSE: 'ojPopupClose',

    /**
     * Event called on when a parent popup is refreshed triggering a cascade
     * refresh on children.
     */
    POPUP_REFRESH: 'ojPopupRefresh',

    /**
     * Event called to enforce auto dismissal rules specific to each popup category.
     */
    POPUP_AUTODISMISS: 'ojPopupAutoDismiss',

    /**
     * Event called before the popup is open but after it has been reparented into the
     * zorder container.  The callback should be used for implementing open animation.
     * The callback function should return a Promise if animation is reqired or void/undefined
     * if no animation is necessary. The callback is passed the open options
     * {!Object.<PopupService.OPTION, ?>} as the only argument.
     * @since 3.0.0
     */
    POPUP_BEFORE_OPEN: 'ojPopupBeforeOpen',

    /**
     * Event called after the popup is open. The callback should implement component
     * open finalization actions such as triggering an open event.  The resultant of
     * the callback function is void.  The callback is passed the
     * open options {!Object.<PopupService.OPTION, ?>} as the only argument.
     */
    POPUP_AFTER_OPEN: 'ojPopupAfterOpen',

    /**
     * Event called before the popup is close.  When invoked, the popup dom is still
     * located within the zorder container.  The callback is a good place to implement
     * close animation. The callback should return a Promise if animation is required
     * or void/undefined if no animation is required.  The callback is passed the
     * close options {!Object.<PopupService.OPTION, ?>} as the only argument.
     * @since 3.0.0
     */
    POPUP_BEFORE_CLOSE: 'ojPopupBeforeClose',

    /**
     * Event called after the popup is closed and reparented back into its original
     * location within the document.  The callback is for close finalization logic.
     * It's a good places to trigger a component close event. The resultant of the
     * callback is expected to be void. The callback is passed the
     * close options {!Object.<PopupService.OPTION, ?>} as the only argument.
     * @since 3.0.0
     */
    POPUP_AFTER_CLOSE: 'ojPopupAfterClose'
  };
  /**
   * Layer level used to identify the {@link PopupService.OPTION.LAYER_LEVEL} option
   * property.
   * @enum {string}
   * @public
   * @ojtsignore
   */

  PopupService.LAYER_LEVEL = {
    /**
     * Option used by dialogs.  Dialogs are always top rooted.
     */
    TOP_LEVEL: 'topLevel',

    /**
     * The default layer option.  Popups will be reparented to the nearest ancestor layer defined
     * relative to the associated {@link PopupService.OPTION.LAUNCHER}.
     */
    NEAREST_ANCESTOR: 'nearestAncestor'
  };
  /**
   * Property names in the options property bag passed to popup service api.
   * @enum {string}
   * @public
   * @see oj.PopupService#close
   * @see oj.PopupService#open
   * @ojtsignore
   */

  PopupService.OPTION = {
    /**
     * Parameter holding the jQuery element that is the root of the popup.  This
     * element is reparented into the zorder container when open. It is a required
     * option.
     */
    POPUP: 'popup',

    /**
     * Map of event names to callbacks.  The event names are defined by the
     * {@link PopupService.EVENT} enumerated type.
     */
    EVENTS: 'events',

    /**
     * Defines the modal state of a popup.  The value of this attribute is defined
     * by the {@link PopupService.MODALITY} enumeration.
     */
    MODALITY: 'modality',

    /**
     * The jQuery element that is associated with the popup being open.  The launcher
     * is used to find the target popups reparented location within the zorder
     * container when open.  This is an optional parameter.  Dialogs don't require a launcher.
     */
    LAUNCHER: 'launcher',

    /**
     * The jQuery UI position object that defines where the popup should be aligned.
     * This is an optional parameter.
     */
    POSITION: 'position',

    /**
     * The CSS selector names applied to the layer for the target type of popup.  These
     * selectors will define the stacking context for the popup and its children.  Multiple
     * selector names should be delimited by a space similar to the syntax for the jquery
     * addClass API.  This option is required.
     */
    LAYER_SELECTORS: 'layerSelectors',

    /**
     * The initial level that the popup will be reparented to when open.  Dialogs are reparented
     * into the top level.  Other types of popups will be parented to their nearest ancestor layer.
     * The values of this attribute are defined by {@link PopupService.LAYER_LEVEL}.
     */
    LAYER_LEVEL: 'layerLevel',

    /**
     * General purpose context that the "open" and "close" can add to the options and it will be
     * passed thru to the corresponding "before" and "after" operations. Use this context to pass
     * variables declared locally in the open to the associated before and after
     * callbacks.
     * @since 3.0.0
     */
    CONTEXT: 'context',

    /**
     * Indicates the component with the associated popup was instantiated as a custom element.
     * This switch determines how the associated surrogate will be created.
     * @since 4.0.0
     */
    CUSTOM_ELEMENT: 'customElement'
  };

  oj.__registerWidget('oj.ojSurrogate', $.oj.baseComponent, {
    version: '1.0.0',
    widgetEventPrefix: 'oj',
    options: {
      beforeDestroy: null
    },
    _ComponentCreate: function _ComponentCreate() {
      this._super();

      this.element.uniqueId();
    },
    _invokeBeforeDestroy: function _invokeBeforeDestroy() {
      var callback = this.options.beforeDestroy;
      this.options.beforeDestroy = null;

      if (callback) {
        callback();
      }
    },
    _destroy: function _destroy() {
      this._invokeBeforeDestroy();

      this.element.removeUniqueId();

      this._super();
    },
    _NotifyDetached: function _NotifyDetached() {
      this._invokeBeforeDestroy();

      this._super();
    }
  });

  var ojSurrogateMeta = {
    properties: {
      beforeDestroy: {
        type: 'function'
      }
    },
    extension: {
      _WIDGET_NAME: 'ojSurrogate'
    }
  };
  oj.CustomElementBridge.register('oj-surrogate', {
    metadata: ojSurrogateMeta
  });

  oj._registerLegacyNamespaceProp('PopupServiceImpl', PopupServiceImpl);

  oj.Object.createSubclass(PopupServiceImpl, PopupService, 'oj.PopupServiceImpl');
  /**
   * Establishes a popup to be open and managed by the framework.  Managed popups will
   * by reparented to the zorder container appended to the document body.  The
   * location within that container is determined by the launcher or modality options.
   *
   * @param {!Object.<PopupService.OPTION, ?>} options property bag for opening the popup
   * @return {void}
   * @instance
   * @public
   * @override
   */

  PopupServiceImpl.prototype.open = function (options) {
    oj.Assert.assertObject(options);
    /** @type {!jQuery} */

    var popup = options[PopupService.OPTION.POPUP];
    oj.Assert.assertPrototype(popup, $); // Trying to open a popup that is either already opening, open or closing.
    // Evaulate if global dom listeners are still needed and ignore the request.
    // This is generally and indicator something wacky has happened that needs recovery.

    var status = ZOrderUtils.getStatus(popup);

    if (!(status === ZOrderUtils.STATUS.UNKNOWN || status === ZOrderUtils.STATUS.BEFORE_OPEN || status === ZOrderUtils.STATUS.CLOSE)) {
      this._assertEventSink();

      return;
    }
    /** @type {jQuery} */


    var launcher = options[PopupService.OPTION.LAUNCHER];
    oj.Assert.assertPrototype(launcher, $);
    /** @type {Object} */

    var position = options[PopupService.OPTION.POSITION];
    oj.Assert.assertObjectOrNull(position);
    /** @type {!Object.<PopupService.EVENT, function(...)>} **/

    var events = options[PopupService.OPTION.EVENTS];
    oj.Assert.assertObject(events);
    var modality = options[PopupService.OPTION.MODALITY];

    if (!modality || !(PopupService.MODALITY.MODELESS === modality || PopupService.MODALITY.MODAL === modality)) {
      modality = PopupService.MODALITY.NONE;
    }

    var layerClass = options[PopupService.OPTION.LAYER_SELECTORS];
    oj.Assert.assertString(layerClass);
    var isCustomElement = options[PopupService.OPTION.CUSTOM_ELEMENT];
    var layerLevel = options[PopupService.OPTION.LAYER_LEVEL];

    if (!layerLevel || !(PopupService.LAYER_LEVEL.TOP_LEVEL === layerLevel || PopupService.LAYER_LEVEL.NEAREST_ANCESTOR === layerLevel)) {
      layerLevel = PopupService.LAYER_LEVEL.NEAREST_ANCESTOR;
    }

    var beforeOpenCallback = events[PopupService.EVENT.POPUP_BEFORE_OPEN];

    if (!beforeOpenCallback || !$.isFunction(beforeOpenCallback)) {
      beforeOpenCallback = PopupServiceImpl._defaultBeforeOpenCallback;
    }

    var afterOpenCallback = events[PopupService.EVENT.POPUP_AFTER_OPEN];
    ZOrderUtils.setStatus(popup, ZOrderUtils.STATUS.OPENING); // set logical parent

    oj.DomUtils.setLogicalParent(popup, launcher);
    ZOrderUtils.addToAncestorLayer(popup, launcher, modality, layerClass, layerLevel, isCustomElement);

    var _finalize = function _finalize() {
      try {
        popup.removeAttr('aria-hidden');

        this._assertEventSink();

        Components.subtreeShown(popup[0]);
      } catch (e) {
        Logger.error('Error opening popup:\n%o', e);
      } finally {
        ZOrderUtils.setStatus(popup, ZOrderUtils.STATUS.OPEN); // invoke the after open callback if one is provided.

        if (afterOpenCallback) {
          afterOpenCallback(options);
        } // delay activating event callbacks until after open is resolved
        // preventing a race condition


        var layer = ZOrderUtils.getFirstAncestorLayer(popup);
        oj.Assert.assertPrototype(layer, $);
        ZOrderUtils.applyEvents(layer, events); // if the originating subtree where the popup was defined is removed during
        // open animation, invoke the popup remove event callback.  It's registered
        // late (applyEvents above) to prevent removing the popup while it's animating open.

        if (!ZOrderUtils._getSurrogate(layer) && $.isFunction(events[PopupService.EVENT.POPUP_REMOVE])) {
          var surrogateRemoveCallback = events[PopupService.EVENT.POPUP_REMOVE];
          surrogateRemoveCallback();
        }
      }
    };

    _finalize = _finalize.bind(this);
    var resultant;

    try {
      resultant = beforeOpenCallback(options);
    } catch (e) {
      Logger.error('Error before open popup:\n%o', e);
    } finally {
      if (resultant && resultant instanceof Promise) {
        resultant.then(_finalize);
      } else {
        _finalize();
      }
    }
  };
  /**
   * Default {@link PopupService.EVENT.POPUP_BEFORE_OPEN} if one is not provided.
   * @private
   * @since 3.0.0
   * @param {!Object.<PopupService.OPTION, ?>} options property bag for closing the popup
   * @return {Promise|void}
   */


  PopupServiceImpl._defaultBeforeOpenCallback = function (options) {
    /** @type {!jQuery} */
    var popup = options[PopupService.OPTION.POPUP];
    oj.Assert.assertPrototype(popup, $);
    /** @type {Object} */

    var position = options[PopupService.OPTION.POSITION];
    popup.show();

    if (position) {
      popup.position(position);
    }

    return undefined;
  };
  /**
   * Closes a open popup managed by the framework.  The popup element is reparented
   * to its original location within the document.  Any open descendent popups are
   * implicitly closed.
   *
   * @param {!Object.<PopupService.OPTION, ?>} options property bag for closing the popup
   * @return {void}
   * @instance
   * @public
   * @override
   */


  PopupServiceImpl.prototype.close = function (options) {
    oj.Assert.assertObject(options);
    /** @type {!jQuery} */

    var popup = options[PopupService.OPTION.POPUP];
    oj.Assert.assertPrototype(popup, $);
    /** @type {!jQuery} */

    var layer = ZOrderUtils.getOpenPopupLayer(popup);
    oj.Assert.assertPrototype(layer, $);
    /** @type {!Object.<PopupService.EVENT, function(...)>} **/

    var events = options[PopupService.OPTION.EVENTS];

    if (!events) {
      events = ZOrderUtils.getEvents(layer); // eslint-disable-next-line no-param-reassign

      options[PopupService.OPTION.EVENTS] = events;
    } else {
      events = $.extend(ZOrderUtils.getEvents(layer), events);
    } // Popup is not in a open status or there are no events registered for the popup,
    // then it is opening, closing or already closed. Evaluate if the document level
    // dom listeners are still needed and ignore the request.


    var status = ZOrderUtils.getStatus(popup);

    if (!(status === ZOrderUtils.STATUS.OPEN || status === ZOrderUtils.STATUS.BEFORE_CLOSE) || !events) {
      this._assertEventSink();

      return;
    }

    var beforeCloseCallback = events[PopupService.EVENT.POPUP_BEFORE_CLOSE];

    if (!beforeCloseCallback || !$.isFunction(beforeCloseCallback)) {
      beforeCloseCallback = PopupServiceImpl._defaultBeforeCloseCallback;
    }

    var afterCloseCallback = events[PopupService.EVENT.POPUP_AFTER_CLOSE];
    ZOrderUtils.setStatus(popup, ZOrderUtils.STATUS.CLOSING); // Unregister events during before close callback

    ZOrderUtils.applyEvents(layer, {});

    var _finalize = function _finalize() {
      try {
        popup.hide();
        popup.attr('aria-hidden', 'true'); // reset position units

        popup.css({
          top: 'auto',
          bottom: 'auto',
          left: 'auto',
          right: 'auto'
        });
        ZOrderUtils.removeFromAncestorLayer(popup); // remove the logical parent

        oj.DomUtils.setLogicalParent(popup, null);

        this._assertEventSink();

        Components.subtreeHidden(popup[0]);
      } catch (e) {
        Logger.error('Error closing popup:\n%o', e);
      } finally {
        ZOrderUtils.setStatus(popup, ZOrderUtils.STATUS.CLOSE);

        if (afterCloseCallback && $.isFunction(afterCloseCallback)) {
          afterCloseCallback(options);
        }
      }
    };

    _finalize = _finalize.bind(this);
    var resultant;

    try {
      resultant = beforeCloseCallback(options);
    } catch (e) {
      Logger.error('Error before close popup:\n%o', e);
    } finally {
      if (resultant && resultant instanceof Promise) {
        resultant.then(_finalize);
      } else {
        _finalize();
      }
    }
  };
  /**
   * Default {@link PopupService.EVENT.POPUP_BEFORE_CLOSE} if one is not provided.
   *
   * @private
   * @since 3.0.0
   * @param {!Object.<PopupService.OPTION, ?>} options property bag for closing the popup
   * @return {Promise|void} undefined is returned indicating no animation (sync operation)
   */


  PopupServiceImpl._defaultBeforeCloseCallback = function (options) {
    /** @type {!jQuery} */
    var popup = options[PopupService.OPTION.POPUP];
    oj.Assert.assertPrototype(popup, $);
    popup.hide();
    return undefined;
  };
  /**
   * Applies a new {@link PopupService.OPTION.EVENTS} callback linkage or
   * applies changes a popup dialogs {@link PopupService.OPTION.MODALITY},
   * {@link PopupService.OPTION.EVENTS}, or {@link PopupService.OPTION.LAYER_SELECTORS}.
   * @param {!Object.<PopupService.OPTION, ?>} options property bag including target popup
   * @return {void}
   * @instance
   * @public
   * @override
   */


  PopupServiceImpl.prototype.changeOptions = function (options) {
    oj.Assert.assertObject(options);
    /** @type {!jQuery} */

    var popup = options[PopupService.OPTION.POPUP];
    oj.Assert.assertPrototype(popup, $);

    if (ZOrderUtils.getStatus(popup) !== ZOrderUtils.STATUS.OPEN) {
      return;
    }
    /** @type {!jQuery} */


    var layer = ZOrderUtils.getOpenPopupLayer(popup);
    oj.Assert.assertPrototype(layer, $);
    /** @type Object.<PopupService.EVENT, function(...)> */

    var events = options[PopupService.OPTION.EVENTS];

    if (events) {
      ZOrderUtils.applyEvents(layer, events);
    }
    /** @type {PopupService.MODALITY} */


    var modality = options[PopupService.OPTION.MODALITY];

    if (modality) {
      ZOrderUtils.applyModality(layer, modality);
    }
    /** @type {?} */


    var layerClass = options[PopupService.OPTION.LAYER_SELECTORS];

    if (!oj.StringUtils.isEmptyOrUndefined(layerClass)) {
      layer.attr('class', layerClass);
    }
  };
  /**
   * Triggers the target event defined on all open descendent popups.
   * @param {!jQuery} popup to target triggering the event on decendents
   * @param {!PopupService.EVENT} event to trigger
   * @param {Array=} argsArray to pass "apply" to the associated callback for the event
   * @return {void}
   * @instance
   * @override
   * @public
   */


  PopupServiceImpl.prototype.triggerOnDescendents = function (popup, event, argsArray) {
    // if the popup is not open, there are not descendents
    if (!ZOrderUtils.isPopupOpen(popup)) {
      return;
    }

    var context = {};
    context.event = event;
    context.argsArray = argsArray;
    /** @type {!jQuery} */

    var layer = ZOrderUtils.getFirstAncestorLayer(popup);
    ZOrderUtils.postOrderVisit(layer, this._triggerOnDescendentsVisitCallback, context);
  };
  /**
   * The {@link ZOrderUtils.postOrderVisit} callback implementation for
   * {@link PopupServiceImpl#triggerOnDescendents}.
   *
   * @param {!jQuery} layer
   * @param {!Object} context
   * @instance
   * @return {ZOrderUtils.VISIT_RESULT}
   * @private
   * @see PopupServiceImpl#triggerOnDescendents
   */


  PopupServiceImpl.prototype._triggerOnDescendentsVisitCallback = function (layer, context) {
    var event = context.event;
    var argsArray = context.argsArray;
    var events = ZOrderUtils.getEvents(layer);

    if (events && $.isFunction(events[event])) {
      events[event].apply(this, argsArray);
    }

    return ZOrderUtils.VISIT_RESULT.ACCEPT;
  };
  /**
   * Depending on if popups are open, adds or removes event listeners redistributed
   * to open popups.
   * @return {void}
   * @instance
   * @private
   */


  PopupServiceImpl.prototype._assertEventSink = function () {
    var hasPopupsOpen = ZOrderUtils.hasPopupsOpen();
    var callbackEventFilter = this._callbackEventFilter;
    var i;
    var docElement;
    var event;

    if (!hasPopupsOpen && callbackEventFilter) {
      window.removeEventListener('resize', PopupServiceImpl._refreshCallback, true);
      window.removeEventListener('scroll', PopupServiceImpl._refreshCallback, true);
      docElement = document.documentElement;
      docElement.removeEventListener('mousewheel', PopupServiceImpl._refreshCallback, {
        passive: true,
        capture: true
      });
      docElement.removeEventListener('DOMMouseScroll', PopupServiceImpl._refreshCallback, true);
      this._callbackEventFilter = null;

      for (i = 0; i < PopupServiceImpl._REDISTRIBUTE_EVENTS.length; i++) {
        event = PopupServiceImpl._REDISTRIBUTE_EVENTS[i];
        docElement.removeEventListener(event, callbackEventFilter, true);
      }

      var simpleTapRecognizer = this._simpleTapRecognizer;

      if (simpleTapRecognizer) {
        simpleTapRecognizer.destroy();
        this._simpleTapRecognizer = null;
      }
    } else if (hasPopupsOpen && !callbackEventFilter) {
      window.addEventListener('resize', PopupServiceImpl._refreshCallback, true);
      window.addEventListener('scroll', PopupServiceImpl._refreshCallback, true);
      docElement = document.documentElement;
      docElement.addEventListener('mousewheel', PopupServiceImpl._refreshCallback, {
        passive: true,
        capture: true
      });
      docElement.addEventListener('DOMMouseScroll', PopupServiceImpl._refreshCallback, true);
      callbackEventFilter = this._eventFilterCallback.bind(this);
      this._callbackEventFilter = callbackEventFilter;

      for (i = 0; i < PopupServiceImpl._REDISTRIBUTE_EVENTS.length; i++) {
        event = PopupServiceImpl._REDISTRIBUTE_EVENTS[i];
        docElement.addEventListener(event, callbackEventFilter, true);
      }

      if (oj.DomUtils.isTouchSupported()) {
        this._simpleTapRecognizer = new SimpleTapRecognizer(callbackEventFilter);
      }
    }
  };
  /**
   * Event callback for events defined by {@link PopupServiceImpl._REDISTRIBUTE_EVENTS}.
   * This callback handles applying the ".oj-focus-within" selector to the popup that
   * is active.  It also handles redistributing events to open popups.
   *
   * @param {Event} event from document capture listeners
   * @return {void}
   * @instance
   * @private
   */


  PopupServiceImpl.prototype._eventFilterCallback = function (event) {
    var target = $(event.target);
    var hasPopupsOpen = ZOrderUtils.hasPopupsOpen();

    if (!hasPopupsOpen) {
      this._assertEventSink();

      return;
    } // Ignore mouse events on the scrollbar. FF and Chrome, raises focus events on the
    // scroll container too.


    if (oj.DomUtils.isChromeEvent(event) || event.type === 'focus' && !target.is(':focusable')) {
      return;
    }

    var defaultLayer = ZOrderUtils.getDefaultLayer();

    if (event.type === 'keydown' && ZOrderUtils.hasModalDialogOpen() && !oj.DomUtils.isAncestor(defaultLayer[0], target[0])) {
      // Inexpensive check to make sure that if a modal dialog is open,
      // we prevent a keydown outside the zorder layer that contains all
      // popups.  This handles the scenario where focus is placed in the
      // location bar and you start tabbing.  The browser will try to tab to
      // the first tabstop in the document.  Eat this event if it's under the
      // modal glass (not within the zorder container) and don't redistribute.
      ZOrderUtils.eatEvent(event);
      return;
    }

    var targetWitinLayer = ZOrderUtils.getFirstAncestorLayer(target);
    var lastFocusLayer; // toggle the oj-focus-within pseudo state

    if (defaultLayer[0] !== targetWitinLayer[0]) {
      if (!targetWitinLayer.hasClass(PopupServiceImpl._FOCUS_WITHIN_SELECTOR)) {
        lastFocusLayer = this._lastFocusLayer;

        if (lastFocusLayer) {
          lastFocusLayer.removeClass(PopupServiceImpl._FOCUS_WITHIN_SELECTOR);
        }

        targetWitinLayer.addClass(PopupServiceImpl._FOCUS_WITHIN_SELECTOR);
        this._lastFocusLayer = targetWitinLayer;
      }
    } else {
      // focus relinquished outside any managed popup
      lastFocusLayer = this._lastFocusLayer;

      if (lastFocusLayer) {
        lastFocusLayer.removeClass(PopupServiceImpl._FOCUS_WITHIN_SELECTOR);
        this._lastFocusLayer = null;
      }
    } // Don't redistribute a focus event targeted for an element that doesn't normally take focus.
    // Clicking on the scrollbars sometimes targets focus on containers with a -1 tabindex.
    // However, we still need to process the focus-within logic for this scenario.


    if (event.type === 'focus' && target.attr('tabindex') === '-1') {
      return;
    } // redistribute events for auto dismissal


    var context = {}; // Capture all interesting event properties.  Similar to jQuery.event.fix.

    var _COPY_SAFE_EVENT_PROPERTIES = PopupServiceImpl._COPY_SAFE_EVENT_PROPERTIES;
    var props = {};

    for (var i = 0; i < _COPY_SAFE_EVENT_PROPERTIES.length; i++) {
      var key = _COPY_SAFE_EVENT_PROPERTIES[i];
      var value = event[key];

      if (value !== undefined && !$.isFunction(value)) {
        props[key] = value;
      }
    } // Wrap a native event in a jQuery.Event


    context.event = $.Event(event, props);
    ZOrderUtils.postOrderVisit(defaultLayer, PopupServiceImpl._redistributeVisitCallback, context);
  };
  /**
   * The {@link ZOrderUtils.postOrderVisit} callback for redistributing
   * {@link PopupService.EVENT.POPUP_AUTODISMISS} events to open popups.
   * @param {!jQuery} layer
   * @param {!Object} context
   * @return {ZOrderUtils.VISIT_RESULT}
   * @instance
   * @private
   * @see PopupServiceImpl#_eventFilterCallback
   */


  PopupServiceImpl._redistributeVisitCallback = function (layer, context) {
    var events = ZOrderUtils.getEvents(layer);
    var event = context.event;

    if (events && $.isFunction(events[PopupService.EVENT.POPUP_AUTODISMISS])) {
      events[PopupService.EVENT.POPUP_AUTODISMISS](event);
    }

    return ZOrderUtils.VISIT_RESULT.ACCEPT;
  };
  /**
   * Event listener added to the window for the resize and scroll events.
   *
   * @param {Event} event resize,scroll or mousewheel event
   * @return {void}
   * @private
   */
  // eslint-disable-next-line no-unused-vars


  PopupServiceImpl._refreshCallback = function (event) {
    var refreshTimerId = PopupServiceImpl._refreshTimerId;

    if (!isNaN(refreshTimerId)) {
      return;
    } // Throttle redistributing the refresh listener to intervals of ? ms.
    // This will help performance for chatty events such as scroll.


    PopupServiceImpl._refreshTimerId = window.setTimeout(function () {
      PopupServiceImpl._refreshTimerId = Number.NaN;
      var defaultLayer = ZOrderUtils.getDefaultLayer();

      if ($.isFunction(window.requestAnimationFrame)) {
        PopupServiceImpl._afRequestId = window.requestAnimationFrame(function () {
          PopupServiceImpl._afRequestId = null;
          ZOrderUtils.postOrderVisit(defaultLayer, PopupServiceImpl._refreshVisitCallback);
        });
      } else {
        ZOrderUtils.postOrderVisit(defaultLayer, PopupServiceImpl._refreshVisitCallback);
      }
    }, PopupServiceImpl._REFRESH_DELAY);
  };
  /**
   * The {@link ZOrderUtils.postOrderVisit} callback for invoking the
   * {@link PopupService.EVENT.POPUP_REFRESH} function for open popups.
   *
   * @param {!jQuery} layer
   * @param {!Object} context
   * @return {ZOrderUtils.VISIT_RESULT}
   * @private
   * @see PopupServiceImpl._refreshCallback
   */


  PopupServiceImpl._refreshVisitCallback = function (layer, context) {
    // Only need to call on the first level of popups as they will recursively
    // call on children.
    var level = context.level;

    if (level > 0) {
      return ZOrderUtils.VISIT_RESULT.REJECT;
    }

    var events = ZOrderUtils.getEvents(layer);

    if (events && $.isFunction(events[PopupService.EVENT.POPUP_REFRESH])) {
      events[PopupService.EVENT.POPUP_REFRESH]();
    }

    return ZOrderUtils.VISIT_RESULT.ACCEPT;
  };
  /**
   * @return {void}
   * @instance
   * @public
   * @override
   */


  PopupServiceImpl.prototype.destroy = function () {
    PopupServiceImpl.superclass.destroy.call(this);
  };
  /**
   * The pseudo select name applied to the popup that has focus.
   *
   * @const
   * @private
   * @type {string}
   */


  PopupServiceImpl._FOCUS_WITHIN_SELECTOR = 'oj-focus-within';
  /**
   * Array of events that are redistributed to open popups.
   *
   * @const
   * @private
   * @type {Array.<string>}
   */

  PopupServiceImpl._REDISTRIBUTE_EVENTS = ['focus', 'mousedown', 'keydown'];
  /**
   * Map of event properties that are interesting to capture when creating a jQuery.Event
   * wrapper from a native event.  This is similar to what is done in jQuery.event.fix.
   * This list is needed to prevent warning messages for event properties that have been
   * deprecated.
   *
   * @const
   * @private
   * @type {Object}
   */

  PopupServiceImpl._COPY_SAFE_EVENT_PROPERTIES = ['altKey', 'bubbles', 'cancelable', 'ctrlKey', 'currentTarget', 'eventPhase', 'metaKey', 'relatedTarget', 'shiftKey', 'target', 'timeStamp', 'view', 'which', 'button', 'buttons', 'clientX', 'clientY', 'offsetX', 'offsetY', 'pageX', 'pageY', 'screenX', 'screenY', 'toElement', 'char', 'charCode', 'key', 'keyCode'];
  /**
   * Milliseconds that is used to throttle processing of native resize, scroll and mousewheel
   * events. Dispatching refresh events to open popups will happen after the delay.
   * This is to guard against chatty events.
   *
   * @const
   * @private
   * @type {number}
   */

  PopupServiceImpl._REFRESH_DELAY = 10;
  /**
   * Utilities used by the popup framework.
   * @since 1.1.0
   * @ignore
   * @ojtsignore
   */

  oj._registerLegacyNamespaceProp('ZOrderUtils', ZOrderUtils);
  /**
   * Operation status for a target popup.
   * @enum {number}
   * @public
   * @see ZOrderUtils.getStatus
   * @see ZOrderUtils.setStatus
   * @ojtsignore
   */


  ZOrderUtils.STATUS = {
    /** Node has not interacted with the popup service. */
    UNKNOWN: 0,

    /** triggering the before open event */
    BEFORE_OPEN: 0.5,

    /** Popup is in the process of opening. */
    OPENING: 1,

    /** Popup is currently open. */
    OPEN: 2,

    /** triggering the before close event */
    BEFORE_CLOSE: 2.5,

    /** Popup is in the process of closing */
    CLOSING: 3,

    /** Popup previously open is now closed **/
    CLOSE: 4
  };
  /**
   * Key to store the current operation status of the popup.
   * @const
   * @private
   * @type {string}
   * @see ZOrderUtils.getStatus
   * @see ZOrderUtils.setStatus
   */

  ZOrderUtils._STATUS_DATA = 'oj-popup-status';
  /**
   * Returns the current operation status of the target popup element.
   * @param {jQuery|Element} popup
   * @returns {ZOrderUtils.STATUS}
   * @see ZOrderUtils.setStatus
   */

  ZOrderUtils.getStatus = function (popup) {
    if (popup instanceof Element) {
      // eslint-disable-next-line no-param-reassign
      popup = $(popup);
    }
    /** @type {?} */


    var status = popup.data(ZOrderUtils._STATUS_DATA);

    if (isNaN(status)) {
      return ZOrderUtils.STATUS.UNKNOWN;
    }

    return status;
  };
  /**
   * Sets the current operational status of the popup element.
   * @param {jQuery|Element} popup
   * @param {ZOrderUtils.STATUS} status
   * @see ZOrderUtils.getStatus
   */


  ZOrderUtils.setStatus = function (popup, status) {
    if (popup instanceof Element) {
      // eslint-disable-next-line no-param-reassign
      popup = $(popup);
    }

    if (status > ZOrderUtils.STATUS.UNKNOWN && status <= ZOrderUtils.STATUS.CLOSE) {
      popup.data(ZOrderUtils._STATUS_DATA, status);
    }
  };
  /**
   * Accepts a launcher associated with the target popup being open.  The
   * resultant is the nearest layer or default zorder container that the
   * popup should be reparented to when open.  It can also return the
   * layer "stacking context" of a popup that is already open.
   *
   * @param {jQuery=} launcher associated with the target popup
   * @return {!jQuery}
   * @public
   */


  ZOrderUtils.getFirstAncestorLayer = function (launcher) {
    // dialogs will not have launchers and will be top rooted
    if (!launcher) {
      return ZOrderUtils.getDefaultLayer();
    }

    var parent = launcher;

    while (parent && parent.length > 0 && parent.attr(ZOrderUtils._SURROGATE_ATTR) !== ZOrderUtils._DEFAULT_LAYER_ID) {
      if (ZOrderUtils._hasSurrogate(parent[0])) {
        return parent;
      }

      parent = parent.parent();
    }

    return ZOrderUtils.getDefaultLayer();
  };
  /**
   * Returns the jQuery DIV element that represents the zorder container prepended to the
   * document body.  All open popups will be a descendent of the resultant node.
   *
   * @return {!jQuery}
   * @public
   */


  ZOrderUtils.getDefaultLayer = function () {
    /** @type {jQuery} */
    var defaultLayer = $(document.getElementById(ZOrderUtils._DEFAULT_LAYER_ID));

    if (defaultLayer.length > 0) {
      return defaultLayer;
    }

    defaultLayer = $('<div>');
    defaultLayer.attr('role', 'presentation');
    defaultLayer.attr('id', ZOrderUtils._DEFAULT_LAYER_ID);
    defaultLayer.prependTo($(document.body)); // @HTMLUpdateOK attach programmatic generated node

    return defaultLayer;
  };
  /**
   * Adds the target popup to the nearest ancestor layer within the zorder container.
   * A surrogate script element will be added to mark where the popup root element
   * was prior to reparenting.
   *
   * @param {!jQuery} popup root widget
   * @param {?jQuery} launcher associated with a popup
   * @param {!PopupService.MODALITY} modality of the popup being open
   * @param {string} layerClass selector that defines the stacking context "z-index" of the popup
   * @param {PopupService.LAYER_LEVEL} layerLevel defines where the popup will be reparented
   * @param {boolean} isCustomElement indicates if the owning component is a custom element
   * @return {void}
   * @public
   */


  ZOrderUtils.addToAncestorLayer = function (popup, launcher, modality, layerClass, layerLevel, isCustomElement) {
    var popupDom = popup[0];

    if (ZOrderUtils._hasSurrogate(popupDom.parentNode)) {
      throw new Error('JET Popup is already open - id: ' + popupDom.getAttribute('id'));
    }

    var ancestorLayer = ZOrderUtils.getFirstAncestorLayer(layerLevel === PopupService.LAYER_LEVEL.TOP_LEVEL ? null : launcher);
    var layer = $('<div>');
    /** @type {?} */

    var popupId = popup.attr('id');

    if (oj.StringUtils.isEmptyOrUndefined(popupId)) {
      layer.uniqueId();
    } else {
      layer.attr('id', [popupId, 'layer'].join('_'));
    }

    layer.attr('role', 'presentation');
    layer.addClass(layerClass);
    popup.after(layer); // @HTMLUpdateOK

    ZOrderUtils._createSurrogate(layer, isCustomElement);

    Components.subtreeDetached(popupDom);
    popup.appendTo(layer); // @HTMLUpdateOK
    // link the popup to the layer @see ZOrderUtils.getOpenPopupLayer

    popup.data(ZOrderUtils._LAYER_ID_DATA, layer.attr('id'));
    layer.appendTo(ancestorLayer); // @HTMLUpdateOK

    Components.subtreeAttached(popupDom);
    ZOrderUtils.applyModality(layer, modality);
  };
  /**
   * @param {!jQuery} layer of the target popup
   * @return {jQuery} surrogate element associated with the layer
   * @private
   */


  ZOrderUtils._getSurrogate = function (layer) {
    var surrogateId = layer.attr(ZOrderUtils._SURROGATE_ATTR);

    if (surrogateId) {
      return document.getElementById(surrogateId);
    }

    return undefined;
  };
  /**
   * Replaces the event callback map associated with an open popup.  The event
   * callbacks are used for auto dismissal or handling implicit dismissal when
   * the surrogate element associated with a layer is removed from the document.
   *
   * @param {!jQuery} layer of the target popup
   * @param {!Object.<PopupService.EVENT, function(...)>} events map of event name to callback
   * @param {?Object=} surrogate saves position within the document where popup is
   *             defined
   * @return {void}
   * @public
   */


  ZOrderUtils.applyEvents = function (layer, events, surrogate) {
    if (!surrogate) {
      // eslint-disable-next-line no-param-reassign
      surrogate = $(ZOrderUtils._getSurrogate(layer));
    }

    layer.data(ZOrderUtils._EVENTS_DATA, events);

    if (surrogate.length > 0 && events && $.isFunction(events[PopupService.EVENT.POPUP_REMOVE])) {
      // if the surrogate script element gets replaced in the dom it will trigger closure of the
      // popup.
      Components.setComponentOption(surrogate[0], 'beforeDestroy', events[PopupService.EVENT.POPUP_REMOVE]);
    }
  };
  /**
   * Returns the map of event callbacks associated with an open popup.
   *
   * @param {!jQuery} layer of an open popup
   * @return {!Object.<PopupService.EVENT, function(...)>}
   * @public
   */


  ZOrderUtils.getEvents = function (layer) {
    /** @type {?} */
    var events = layer.data(ZOrderUtils._EVENTS_DATA);
    return events;
  };
  /**
   * Creates a script element before the target layer bound to the simple jquery UI
   * surrogate component.  Links this element to the layer by attribute named
   * {@link ZOrderUtils._SURROGATE_ATTR}.
   *
   * @param {!jQuery} layer stacking context
   * @param {boolean} isCustomElement
   * @return {jQuery}
   * @private
   * @see ZOrderUtils.addToAncestorLayer
   */


  ZOrderUtils._createSurrogate = function (layer, isCustomElement) {
    var nodeName = 'script'; // @HTMLUpdateOK

    if (isCustomElement) {
      nodeName = 'oj-surrogate';
    }
    /** @type {?} */


    var surrogate = $(document.createElement(nodeName)); // @HTMLUpdateOK

    /** @type {?} */

    var layerId = layer.attr('id');

    if (!oj.StringUtils.isEmptyOrUndefined(layerId)) {
      surrogate.attr('id', [layerId, 'surrogate'].join('_'));
    }

    if (isCustomElement) {
      // programmatically created elements not managed by a binding stratagy like knockout
      // needs this attribute to signal the component should be created.
      surrogate.attr('data-oj-binding-provider', 'none');
    }

    surrogate.insertBefore(layer); // @HTMLUpdateOK

    if (!isCustomElement) {
      // create the jquery ui component bound to the script node
      surrogate.ojSurrogate();
    }
    /** @type {?} */


    var surrogateId = surrogate.attr('id'); // loosely associate the popup to the surrogate element

    layer.attr(ZOrderUtils._SURROGATE_ATTR, surrogateId); // @HTMLUpdateOK

    return surrogate;
  };
  /**
   * Reparents the layer after the associated surrogate script element removing
   * the surrogate script element.
   *
   * @param {!jQuery} layer stacking context of the popup
   * @return {boolean} true if the original location the popup was defined still exists
   * @private
   * @see ZOrderUtils.removeFromAncestorLayer
   */


  ZOrderUtils._removeSurrogate = function (layer) {
    /** @type {?} */
    var surrogateId = layer.attr(ZOrderUtils._SURROGATE_ATTR);
    layer.removeAttr(ZOrderUtils._SURROGATE_ATTR);
    /** @type {jQuery} */

    var surrogate = $(document.getElementById(surrogateId));
    var originatingSubtreeExists = surrogate.length > 0;

    if (originatingSubtreeExists) {
      layer.insertAfter(surrogate); // @HTMLUpdateOK

      Components.setComponentOption(surrogate[0], 'beforeDestroy', null);
      surrogate.remove();
    }

    return originatingSubtreeExists;
  };
  /**
   * Returns the layer associated with a popup.  The layer should be the immediate parent of an open
   * popup unless it was disconnected from the document.
   *
   * @param {!jQuery} popup
   * @returns {!jQuery} open popup's layer
   * @public
   */


  ZOrderUtils.getOpenPopupLayer = function (popup) {
    /** @type {?} */
    var layer = popup.parent();

    if (!layer || layer.length === 0) {
      // the open popup has been detached from the layer before it was closed
      // use the backup pointer for better cleanup

      /** @type {?} */
      var layerId = popup.data(ZOrderUtils._LAYER_ID_DATA);
      layer = $(document.getElementById(layerId));
    }

    return layer;
  };
  /**
   * Closes a open popup by reparenting it back to its original location within
   * the document marked by the surrogate.  Recursively calls the
   * {@link PopupService.EVENT.POPUP_CLOSE} event callback on descendent popups.
   * @param {!jQuery} popup root widget
   * @return {void}
   * @public
   */


  ZOrderUtils.removeFromAncestorLayer = function (popup) {
    var layer = ZOrderUtils.getOpenPopupLayer(popup);
    ZOrderUtils.preOrderVisit(layer, ZOrderUtils._closeDescendantPopupsCallback);

    ZOrderUtils._removeOverlayFromAncestorLayer(layer);

    layer.removeData(ZOrderUtils._EVENTS_DATA);
    layer.removeData(ZOrderUtils._MODALITY_DATA);
    popup.removeData(ZOrderUtils._LAYER_ID_DATA);
    var popupDom = popup[0];
    Components.subtreeDetached(popupDom);

    var originatingSubtreeExists = ZOrderUtils._removeSurrogate(layer); // if the popup is not orphaned


    if (originatingSubtreeExists && popupDom && popupDom.parentElement) {
      oj.DomUtils.unwrap(popup, layer);
      Components.subtreeAttached(popupDom);
    } else {
      layer.remove();
    }
  };
  /**
   * The {@link ZOrderUtils.preOrderVisit} callback that invokes the
   * {@link PopupService.EVENT.POPUP_CLOSE} function for descendent
   * popups.
   * @param {!jQuery} layer to be dismissed
   * @param {!Object} context for visit tree
   * @return {ZOrderUtils.VISIT_RESULT}
   * @private
   * @see ZOrderUtils.removeFromAncestorLayer
   */


  ZOrderUtils._closeDescendantPopupsCallback = function (layer, context) {
    var level = context.level; // Only need to visit the immediate children as the children will recursively
    // close any open child popups.

    if (level > 0) {
      return ZOrderUtils.VISIT_RESULT.REJECT;
    }

    var events = layer.data(ZOrderUtils._EVENTS_DATA);

    if (events && $.isFunction(events[PopupService.EVENT.POPUP_CLOSE])) {
      events[PopupService.EVENT.POPUP_CLOSE]();
    }

    return ZOrderUtils.VISIT_RESULT.ACCEPT;
  };
  /**
   * Handles adding or removing a sibling overlay blocking pane before the dialog
   * based on the modality option.  The overlay pane is associated with the dialog
   * vai a attribute pointing to the id of the overlay.
   *
   * @param {!jQuery} layer for the target popup
   * @param {PopupService.MODALITY} modality
   * @return {void}
   * @public
   */


  ZOrderUtils.applyModality = function (layer, modality) {
    /** @type {?} */
    var currModality = layer.data(ZOrderUtils._MODALITY_DATA);
    layer.data(ZOrderUtils._MODALITY_DATA, modality);

    if (oj.StringUtils.isEmptyOrUndefined(currModality)) {
      if (PopupService.MODALITY.MODAL === modality) {
        ZOrderUtils._addOverlayToAncestorLayer(layer);
      } else {
        ZOrderUtils._removeOverlayFromAncestorLayer(layer);
      }
    } else if (currModality !== modality) {
      if (modality !== currModality && modality === PopupService.MODALITY.MODAL) {
        ZOrderUtils._addOverlayToAncestorLayer(layer);
      } else {
        ZOrderUtils._removeOverlayFromAncestorLayer(layer);
      }
    }

    if (modality === PopupService.MODALITY.MODAL) {
      layer.attr('aria-modal', 'true');
    } else {
      // saw a tech note that a "false" value doesn't convey the same information as
      // if the attribute wasnât present at all screen readers.
      layer.removeAttr('aria-modal');
    }
  };
  /**
   * @return {boolean} <code>true</code> if one or more modal dialogs are open
   * @public
   */


  ZOrderUtils.hasModalDialogOpen = function () {
    var defaultLayer = ZOrderUtils.getDefaultLayer();
    var children = defaultLayer.children();
    var childrenCount = children.length;

    for (var i = childrenCount - 1; i > -1; i--) {
      var child = $(children[i]);

      if (child.hasClass(ZOrderUtils._OVERLAY_SELECTOR)) {
        return true;
      }
    }

    return false;
  };
  /**
   * Creates a overlay div assigned the {@link ZOrderUtils._OVERLAY_SELECTOR}
   * selector inserted before the dialog layer.  The layer is associated to the
   * overlay by the {@link ZOrderUtils._OVERLAY_ATTR} assigned to the root layer
   * element.
   * @param {!jQuery} layer root widget
   * @return {void}
   * @private
   * @see ZOrderUtils.applyModality
   */


  ZOrderUtils._addOverlayToAncestorLayer = function (layer) {
    /** @type {jQuery} */
    var overlay = $('<div>');
    overlay.addClass(ZOrderUtils._OVERLAY_SELECTOR);
    overlay.addClass(layer[0].className);
    overlay.attr('role', 'presentation');
    /** @type {?} */

    var layerId = layer.attr('id');

    if (oj.StringUtils.isEmptyOrUndefined(layerId)) {
      overlay.uniqueId();
    } else {
      overlay.attr('id', [layerId, 'overlay'].join('_'));
    }

    layer.before(overlay); // @HTMLUpdateOK

    /** @type {?} */

    var overlayId = overlay.attr('id');
    layer.attr(ZOrderUtils._OVERLAY_ATTR, overlayId); // @HTMLUpdateOK
  };
  /**
   * Removes the overlay associated with a modal dialog and removes the the attribute
   * that associates the popup with the overlay.
   *
   * @param {!jQuery} layer root widget
   * @return {void}
   * @private
   * @see ZOrderUtils.applyModality
   */


  ZOrderUtils._removeOverlayFromAncestorLayer = function (layer) {
    /** @type {?} */
    var overlayId = layer.attr(ZOrderUtils._OVERLAY_ATTR);

    if (!oj.StringUtils.isEmptyOrUndefined(overlayId)) {
      layer.removeAttr(ZOrderUtils._OVERLAY_ATTR);
      var overlay = $(document.getElementById(overlayId));
      overlay.remove();
    }
  };
  /**
   * Resultant enumerated type used to control the popup visit (pre/post order)
   * traversal.
   * @enum {number}
   * @public
   * @see ZOrderUtils.postOrderVisit
   * @see ZOrderUtils.preOrderVisit
   * @ojtsignore
   */


  ZOrderUtils.VISIT_RESULT = {
    /** Continue to descend into current subtree. */
    ACCEPT: 0,

    /** Halt processing the subtree but contine visiting */
    REJECT: 1,

    /** Halt tree visit **/
    COMPLETE: 2
  };
  /**
   * Defines the visit traversal type.
   * @enum {number}
   * @private
   */

  ZOrderUtils._VISIT_TRAVERSAL = {
    /** The callback is invoked on the target popup before any children. */
    PRE_ORDER: 0,

    /** The callback is invoked on the target popup after first visiting all descendents. */
    POST_ORDER: 1
  };
  /**
   * Visits all open popups invoking the callback function on the target popup after first
   * visiting all children in order of last open.
   * @param {!jQuery} layer to begin searching for popups
   * @param {function(!jQuery, !Object) : ZOrderUtils.VISIT_RESULT} callback invoked for each
   *        child popup
   * @param {Object=} context passed to the visit
   * @return {void}
   * @public
   */

  ZOrderUtils.postOrderVisit = function (layer, callback, context) {
    var _context = context;

    if (!context) {
      _context = {};
    }

    _context.level = 0;
    _context.type = ZOrderUtils._VISIT_TRAVERSAL.POST_ORDER;

    ZOrderUtils._visitTree(layer, callback, _context);
  };
  /**
   * Visits all open popups invoking the callback on the target popup before any
   * popups that are descendents.
   * @param {!jQuery} layer to begin searching for popups
   * @param {function(!jQuery, !Object) : ZOrderUtils.VISIT_RESULT} callback invoked for each child
   *         popup
   * @param {Object=} context passed to the visit
   * @return {void}
   * @public
   */


  ZOrderUtils.preOrderVisit = function (layer, callback, context) {
    var _context = context;

    if (!context) {
      _context = {};
    }

    _context.level = 0;
    _context.type = ZOrderUtils._VISIT_TRAVERSAL.PRE_ORDER;

    ZOrderUtils._visitTree(layer, callback, _context);
  };
  /**
   * Visits popups in order defined by {@link ZOrderUtils._VISIT_TRAVERSAL.PRE_ORDER}
   * invoking the callback for each popup.
   * @param {!jQuery} layer to begin searching for popups
   * @param {function(!jQuery, !Object) : ZOrderUtils.VISIT_RESULT} callback
   *        invoked for each child popup
   * @param {!Object} context passed to the visit
   * @return {ZOrderUtils.VISIT_RESULT} instructions on how to proceed
   * @private
   * @see ZOrderUtils.preOrderVisit
   * @see ZOrderUtils.postOrderVisit
   */


  ZOrderUtils._visitTree = function (layer, callback, context) {
    // Patterned from the RC visit APIs
    var level = context.level;
    var children = layer.children();
    var childrenCount = children.length;

    for (var i = childrenCount - 1; i > -1; i--) {
      var child = $(children[i]);

      if (ZOrderUtils._hasSurrogate(child[0])) {
        var vrtn; // handle visit pre-order

        if (context.type === ZOrderUtils._VISIT_TRAVERSAL.PRE_ORDER) {
          vrtn = callback(child, context);

          if (vrtn === ZOrderUtils.VISIT_RESULT.COMPLETE) {
            return vrtn;
          } else if (vrtn === ZOrderUtils.VISIT_RESULT.REJECT) {
            break;
          }
        } // visit children
        // eslint-disable-next-line no-param-reassign


        context.level = level + 1;
        vrtn = ZOrderUtils._visitTree(child, callback, context); // eslint-disable-next-line no-param-reassign

        context.level = level;

        if (vrtn === ZOrderUtils.VISIT_RESULT.COMPLETE) {
          return vrtn;
        } // handle visit post-order


        if (context.type === ZOrderUtils._VISIT_TRAVERSAL.POST_ORDER) {
          vrtn = callback(child, context);

          if (vrtn === ZOrderUtils.VISIT_RESULT.COMPLETE) {
            return vrtn;
          } else if (vrtn === ZOrderUtils.VISIT_RESULT.REJECT) {
            break;
          }
        }
      }
    }

    return ZOrderUtils.VISIT_RESULT.ACCEPT;
  };
  /**
   * Determines the target element is an open popup by checking for the
   * {@link ZOrderUtils._SURROGATE_ATTR} attribute assigned to open popup layers.
   *
   * @param {!Element} element to check for a stand-in component
   * @return {boolean} <code>true</code> if the element is associated with a placeholder element
   * @private
   */


  ZOrderUtils._hasSurrogate = function (element) {
    if (element && element.nodeType === 1 && element.hasAttribute(ZOrderUtils._SURROGATE_ATTR)) {
      return true;
    }

    return false;
  };
  /**
   * @return {boolean} <code>true</code> if one or more popups are open
   * @public
   */


  ZOrderUtils.hasPopupsOpen = function () {
    var defaultLayer = ZOrderUtils.getDefaultLayer();
    return defaultLayer.children().length > 0;
  };
  /**
   * @return {number} total number of open popups
   * @public
   */


  ZOrderUtils.getOpenPopupCount = function () {
    var context = {};
    context.popupCount = 0;
    var defaultLayer = ZOrderUtils.getDefaultLayer();
    ZOrderUtils.preOrderVisit(defaultLayer, ZOrderUtils._openPopupCountCallback, context);
    return context.popupCount;
  };
  /**
   * The {@link ZOrderUtils.preOrderVisit} callback for counting the total number of
   * open popups.
   * @param {!jQuery} layer
   * @param {!Object} context for visit tree
   * @return {ZOrderUtils.VISIT_RESULT}
   * @private
   * @see ZOrderUtils.getOpenPopupCount
   */


  ZOrderUtils._openPopupCountCallback = function (layer, context) {
    // eslint-disable-next-line no-param-reassign
    context.popupCount += 1;
    return ZOrderUtils.VISIT_RESULT.ACCEPT;
  };
  /**
   * Returns a jQuery set of all open popup layer dom elements.  Popups open last will appear at the
   * end of the set. Used by automated testing.
   * @return {!jQuery} set of all open popup root elements managed by the popup service
   * @public
   */


  ZOrderUtils.findOpenPopups = function () {
    var context = {};
    /** @type {Array.<Element>} */

    var popups = [];
    context.popups = popups;
    var defaultLayer = ZOrderUtils.getDefaultLayer();
    ZOrderUtils.preOrderVisit(defaultLayer, ZOrderUtils._openPopupsCallback, context);
    popups = context.popups;
    return $(popups);
  };
  /**
   * The {@link ZOrderUtils.preOrderVisit} callback that collects a set of open
   * popups.
   * @param {!jQuery} layer
   * @param {!Object} context for visit tree
   * @return {ZOrderUtils.VISIT_RESULT}
   * @private
   * @see ZOrderUtils.findOpenPopups
   */


  ZOrderUtils._openPopupsCallback = function (layer, context) {
    /** @type {Array.<Element>} */
    var popups = context.popups;
    popups.push(layer[0]);
    return ZOrderUtils.VISIT_RESULT.ACCEPT;
  };
  /**
   * @public
   * @param {!Element} element to determine if it's above the top modal popup
   * @returns {boolean} returns <code>true</code> if the element is above the top modal popup
   */


  ZOrderUtils.isAboveTopModalLayer = function (element) {
    /**
     * @return {Element|undefined}
     */
    function getTopLayer() {
      // traverses the first level of popups looking for the popup with the highest
      // stacking context.
      // pre-order traversal
      function callback(layer, context) {
        var level = context.level; // first level traversal only

        if (level > 0) {
          return ZOrderUtils.VISIT_RESULT.REJECT;
        }

        var prevLayer = context.topLayer;

        if (prevLayer) {
          // if the current layer has a higher context than the prev, it becomes the top
          if (ZOrderUtils.compareStackingContexts($(layer), $(prevLayer)) > 0) {
            // eslint-disable-next-line no-param-reassign
            context.topLayer = layer;
          }
        } else {
          // eslint-disable-next-line no-param-reassign
          context.topLayer = layer;
        }

        return ZOrderUtils.VISIT_RESULT.ACCEPT;
      }

      var context = {
        topLayer: null
      };
      var defaultLayer = ZOrderUtils.getDefaultLayer();
      ZOrderUtils.preOrderVisit(defaultLayer, callback, context);

      if (context.topLayer) {
        return context.topLayer[0];
      }

      return undefined;
    }
    /**
     *
     * @param {!Element} topLayer
     * @return {Element|undefined}
     */


    function getTopModalLayer(topLayer) {
      // post-order traversal starting at the topLayer.  Retuns the modal popup at the
      // highest deepest level.
      function callback(layer, context) {
        if (layer[0].hasAttribute(ZOrderUtils._OVERLAY_ATTR)) {
          // eslint-disable-next-line no-param-reassign
          context.topModalPopup = layer;
          return ZOrderUtils.VISIT_RESULT.COMPLETE;
        }

        return ZOrderUtils.VISIT_RESULT.ACCEPT;
      }

      var context = {
        topModalPopup: null
      };

      if (topLayer.hasAttribute(ZOrderUtils._OVERLAY_ATTR)) {
        context.topModalPopup = $(topLayer);
      }

      ZOrderUtils.postOrderVisit($(topLayer), callback, context);

      if (context.topModalPopup) {
        return context.topModalPopup[0];
      }

      return undefined;
    } // inexpensive prerequisite check


    if (!element || !ZOrderUtils.hasPopupsOpen()) {
      return true;
    } // Popups closest to the body will have the greatest stacking context weight.
    // Find the top first level layer.


    var topLayer = getTopLayer();

    if (!topLayer) {
      return true;
    } // look for the last modal popup open starting from the top layer


    var topModalLayer = getTopModalLayer(topLayer);

    if (!topModalLayer) {
      return true;
    } // Returns true if the target element is a child of the top most modal layer.


    return oj.DomUtils.isAncestorOrSelf(topModalLayer, element) || ZOrderUtils.compareStackingContexts($(topModalLayer), $(element)) < 0;
  };
  /**
   * Utility used for testing. Compares two jquery singleton wappered elements
   * determining which element has the greatest stacking context.
   * @public
   * @param {jQuery} el1 first element to compare
   * @param {jQuery} el2 second element to compare
   * @return {number} 0 if elements have the same stacking context;
   *                  1 if the first element has a greater stacking context;
   *                 -1 when the second element has a greater stacking context;
   */


  ZOrderUtils.compareStackingContexts = function (el1, el2) {
    oj.Assert.assertPrototype(el1, $);
    oj.Assert.assertPrototype(el2, $);

    function describeStackingContext(element, allLevels) {
      var positions = ['absolute', 'relative', 'fixed'];
      var parents = element.parents();
      var tmp = [];
      var i;

      for (i = parents.length - 1; i > -1; i--) {
        tmp.push($(parents[i]));
      }

      parents = tmp;
      parents.push(element);
      var stack = [];
      var level = 0;

      for (i = 0; i < parents.length; i++) {
        var parent = parents[i];
        var position = parent.css('position');
        var opacity = oj.DomUtils.getCSSLengthAsFloat(parent.css('opacity'));
        var zindex = oj.DomUtils.getCSSLengthAsInt(parent.css('z-index'));
        var order = $.inArray(parent[0], parent.parent().children());

        if ($.inArray(position, positions) > -1 && zindex > 0) {
          stack.push({
            weight: [level, zindex, order],
            order: [order]
          });
          level += 1;
        } else if (opacity < 1) {
          stack.push({
            weight: [level, 1, order],
            order: [order]
          });
          level += 1;
        } else if (allLevels) {
          stack.push({
            weight: [0, 0, order],
            order: [order]
          });
        }
      }

      return stack;
    }

    function compareSets(n1, n2) {
      var maxLen = Math.max(n1.length, n2.length);

      for (var i = 0; i < maxLen; i++) {
        var _e1 = i < n1.length ? n1[i] : 0;

        var _e2 = i < n2.length ? n2[i] : 0;

        if (_e1 !== _e2) {
          if (_e1 < _e2) {
            return -1;
          }

          return 1;
        }
      }

      return 0;
    }

    var n1 = describeStackingContext(el1, false);
    var n2 = describeStackingContext(el2, false);
    var i;
    var c;
    var e1;
    var e2;
    var maxLen = Math.max(n1.length, n2.length);

    for (i = 0; i < maxLen; i++) {
      e1 = i < n1.length ? n1[i].weight : [-1];
      e2 = i < n2.length ? n2[i].weight : [-1];
      c = compareSets(e1, e2);

      if (c !== 0) {
        return c;
      }
    } // include all elements for tie breaker


    n1 = describeStackingContext(el1, true);
    n2 = describeStackingContext(el2, true);
    maxLen = Math.max(n1.length, n2.length); // tie breaker based on document order

    for (i = 0; i < maxLen; i++) {
      e1 = i < n1.length ? n1[i].order : [-1];
      e2 = i < n2.length ? n2[i].order : [-1];
      c = compareSets(e1, e2);

      if (c !== 0) {
        return c;
      }
    }

    return 0;
  };
  /**
   * Event listener that will stop propagation and prevent default on the event.
   * @param {jQuery.Event|Event} event
   * @return {void}
   * @public
   */


  ZOrderUtils.eatEvent = function (event) {
    event.stopPropagation();
    event.preventDefault();
  };
  /**
   * @public
   * @param {jQuery} popup jQuery element
   * @return {boolean} <code>true</code> if the popup is reparented into the zorder container
   */


  ZOrderUtils.isPopupOpen = function (popup) {
    // only open popups will be associated with a surrogate via parent layer
    var parent = popup.parent();

    if (parent && parent.length === 1 && ZOrderUtils._hasSurrogate(parent[0])) {
      return true;
    }

    return false;
  };
  /**
   * Key used to store the popup event callbacks on the popup layer
   * as a jQuery data property.
   * @const
   * @private
   * @type {string}
   */


  ZOrderUtils._EVENTS_DATA = 'oj-popup-events';
  /**
   * Key used to store the modality of a popup layer as a jQuery data property.
   * @const
   * @private
   * @type {string}
   */

  ZOrderUtils._MODALITY_DATA = 'oj-popup-modality';
  /**
   * The id assigned to the zorder container that will house all open popups.
   * The zorder container will be appended to the document body.
   * @const
   * @private
   * @type {string}
   */

  ZOrderUtils._DEFAULT_LAYER_ID = '__oj_zorder_container';
  /**
   * The attribute name assigned to the associated layer of open popups.  The value of the
   * attribute will point to the script element that holds the place in the document
   * that the popup originated from prior to being open.
   * @const
   * @private
   * @type {string}
   */

  ZOrderUtils._SURROGATE_ATTR = 'data-oj-surrogate-id';
  /**
   * This key that captures the popups layer id.  The layer should always be the immediate parent
   * of the popup after open but if the popup is disconnected from the layer, this is a secondary
   * link to the layer for better cleanup.
   *
   * @const
   * @private
   * @type {string}
   * @see ZOrderUtils.getOpenPopupLayer
   */

  ZOrderUtils._LAYER_ID_DATA = 'oj-popup-layer-id';
  /**
   * The attribute name assigned to the popup layer for open dialogs that have a
   * modality state of "modal".  The value of the attribute points to the associated
   * overlay element.
   * @const
   * @private
   * @type {string}
   */

  ZOrderUtils._OVERLAY_ATTR = 'data-oj-overlayid';
  /**
   * The CSS selector name assigned to the modal overlay DIV.
   * @const
   * @private
   * @type {string}
   */

  ZOrderUtils._OVERLAY_SELECTOR = 'oj-component-overlay';
  /* jslint browser: true*/

  /**
   * Utilities used in conjunction with the jquery positon utility.
   * @ignore
   * @class PositionUtils
   * @ojtsignore
   */

  var PositionUtils = {};

  oj._registerLegacyNamespaceProp('PositionUtils', PositionUtils);
  /**
   * <p>Of the properties on the position object, "my" and "at" are of interest. The base jQuery
   * horizontal alignment mnemonics are "right", "center" and "left". For better JET RTL
   * support we have added "start" and "end".  Depending on the rtl direction, "start" and
   * "end" will be replaced with "left" or "right". The resultant postion object will
   * be a new instance that extends the position passed as the first argument.
   *
   * <p>Likewise, JET supports "<" and ">" operators wherever "-" and "+" are supported.
   * The "<" value means "- in LTR; + in RTL", while the ">" value means "+ in LTR; - in RTL".
   * E.g. a "my" value of "start<40" shifts the menu 40px "startward," while a "my" value of
   * "start>40" shifts the menu 40px "endward."
   *
   * @param {Object} position source position object
   * @param {boolean} isRtl
   * @return {Object} position object that has normalized jquery horizontal mnemonics.
   */


  PositionUtils.normalizeHorizontalAlignment = function (position, isRtl) {
    // This assertion prevents security testing: someone could pass in a bogus position
    // oj.Assert.assertObject(position, "position");
    var target = $.extend({}, position);

    for (var i = 0; i < PositionUtils._ALIGN_RULE_PROPERTIES.length; i++) {
      var propName = PositionUtils._ALIGN_RULE_PROPERTIES[i];
      var align = target[propName];

      if (align) {
        if (oj.StringUtils.isString(align)) {
          target[propName] = align.replace('start', isRtl ? 'right' : 'left').replace('end', isRtl ? 'left' : 'right').replace('<', isRtl ? '+' : '-').replace('>', isRtl ? '-' : '+');
        } else {
          for (var s = 0; s < PositionUtils._SUB_ALIGN_RULE_PROPERTIES.length; s++) {
            var subPropName = PositionUtils._SUB_ALIGN_RULE_PROPERTIES[s];
            var subAlign = align[subPropName];

            if (oj.StringUtils.isString(subAlign)) {
              align[subPropName] = subAlign.replace('start', isRtl ? 'right' : 'left').replace('end', isRtl ? 'left' : 'right').replace('<', isRtl ? '+' : '-').replace('>', isRtl ? '-' : '+');
            }
          }
        }
      }
    }

    return target;
  };
  /**
   * <p>In the jQuery UI [Position]{@link http://api.jqueryui.com/position/} utility,
   * the "of" field specifies the element or event relative to which the popup should
   * be positioned.
   *
   * <p>Popup components like Menu often need to position themselves relative to their
   * launcher (e.g. MenuButton), or the launching event (e.g. right-click event), both
   * of which can vary on a per-launch basis.  To facilitate specifying these policies
   * in advance, in a component option, it's useful to support "launcher" and "event"
   * keywords in the "of" field.  Without these keywords, the app would have to set
   * this field at each popup launch, via either the open() method or a beforeOpen listener,
   * at which point they could supply the actual event or launcher element for this
   * particular launch.
   *
   * <p>This method is intended to be called by the popup component at launch time.  It
   * takes an "of" field possibly containing these keywords, and the event and launcher
   * for the current launch, and returns a new "of" value where those keywords have
   * been replaced by the event or launcher, so that the resulting "position" object
   * is ready to be passed to the JQUI utility.
   *
   * <p>Since callers may have different needs, this method does not log if, say,
   * of==="event" && event==null.  Callers should log or throw if this condition
   * indicates application error.
   *
   * <p>While the code is simple, it's useful to centralize the logic to avoid subtle
   * differences in behavior among JET popup components.
   *
   * @param of the "of" field of a position object.  Defaults to "launcher" if null/undefined.
   * @param launcher launcher element
   * @param event event that opened the popup
   * @return normalized "of" value
   */


  PositionUtils.normalizePositionOf = function (of, launcher, event) {
    if (of === 'event') {
      return event;
    } else if (of == null || of === 'launcher') {
      return launcher;
    }

    return of;
  }; // TODO: file a JQ bug and link to it here.

  /**
   * On iOS and Android, the JQ Event object wrapping touch* events lacks pageX and pageY properties, which is contrary to the
   * contract [1].  This breaks JQ's position() API [2], which assumes that the contract is obeyed.  Specifically, it
   * relies on the pageX/Y fields of the Event object passed as the "of" field (and publicly docs that it does so).
   *
   * Per W3C [3], pageX/Y are found in originalEvent.touches[i] or originalEvent.changedTouches[i], where originalEvent is
   * the native (not JQ) event, and i is 0 for us.  In practice, for touchstart at least, iOS7 and 8 Mobile Safari, but
   * apparently not Android Chrome, also put pageX and pageY on the top-level native event, and the values seem to be the
   * same as those in the touches array.  We'll use the cross-platform W3C location.
   *
   * To workaround the JQ bug, popup components like Menu can call this method at open() time.  This method copies the properties
   * to the wrapper JQ event.
   *
   * [1] http://api.jquery.com/category/events/event-object/
   * [2] http://api.jqueryui.com/position/
   * [3] http://www.w3.org/TR/touch-events/#touch-interface et. seq.
   *
   * @private
   * @param event
   */


  PositionUtils._normalizeEventForPosition = function (event) {
    $.each(['pageX', 'pageY'], function (index, pagePos) {
      if (event && event[pagePos] === undefined && event.originalEvent) {
        var originalEvent = event.originalEvent;
        var type = originalEvent.type;
        var touchList;

        if (type === 'touchstart' || type === 'touchmove') {
          touchList = 'touches';
        } else if (type === 'touchend') {
          touchList = 'changedTouches';
        } else {
          touchList = null;
        }

        if (touchList) {
          var firstTouch = originalEvent[touchList][0];

          if (firstTouch) {
            // eslint-disable-next-line no-param-reassign
            event[pagePos] = firstTouch[pagePos];
          }
        }
      }
    });
  };
  /**
   * @private
   * @const
   */


  PositionUtils._ALIGN_RULE_PROPERTIES = ['my', 'at'];
  /**
   * @private
   * @const
   */

  PositionUtils._SUB_ALIGN_RULE_PROPERTIES = ['vertical', 'horizontal'];
  /**
   * A common utilty that is designed be be called for a jquery ui position "using" callback
   * that will check to see if the target aligning "of" position is clipped in an overflow
   * container.  Used by popups that should auto dismiss when what they are aligning to is
   * no longer visible.  The aligning position can be either an element, event or a rect.
   *
   * @param {Object} props second argument to the jquery ui position "using" callback.
   * @returns {boolean} <code>true</code> if the point aligned is not totally visible in and overflow container
   */

  PositionUtils.isAligningPositionClipped = function (props) {
    // Alignment can be to an element, event or a rect but we only care to make this
    // check if alignment is to an element - .
    if (props.target && props.target.height > 0 && props.target.width > 0) {
      // if the target has a width and height greater than zero then it's an element

      /** @type {jQuery} */
      var positionOf = props.target.element;
      return !PositionUtils.isWithinViewport(positionOf);
    }

    return false;
  };
  /**
   * Returns <code>true</code> if the jquery element is visible within overflow an
   * overflow container. The check only considers statically positioned elements and
   * stops short of the body.
   *
   * The first positioned ancestor is treated as the root viewport. Positioned elements need be
   * compared with the window viewport versus its ancestors.  Visibility of positioned
   * elements also need to compare stacking contexts within the document to determine
   * what is on top "visible" - thus excluded from this check.
   *
   * @param {jQuery} element jquery element to test
   * @returns {boolean}
   */


  PositionUtils.isWithinViewport = function (element) {
    function isVisible(alignBox, containerBox) {
      var scrollBarWidth;

      if (['hidden', 'scroll', 'auto'].indexOf(containerBox.overflowY) > -1) {
        // 1px fudge factor for rounding errors
        if (alignBox.bottom - containerBox.top < -1) {
          return false;
        } // find horizontal scrollbar size. always present when "scroll", or when "auto" and scrollWidth > innerWidth


        scrollBarWidth = containerBox.overflowX === 'auto' && containerBox.scrollWidth > containerBox.innerWidth || containerBox.overflowX === 'scroll' ? oj.DomUtils.getScrollBarWidth() : 0;

        if (containerBox.bottom - scrollBarWidth - alignBox.top < 1) {
          return false;
        }
      }

      if (['hidden', 'scroll', 'auto'].indexOf(containerBox.overflowX) > -1) {
        // find vertical scrollbar width. always present when "scroll", or when "auto" and scrollHeight > innerHeight
        scrollBarWidth = containerBox.overflowY === 'auto' && containerBox.scrollHeight > containerBox.innerHeight || containerBox.overflowY === 'scroll' ? oj.DomUtils.getScrollBarWidth() : 0; // depending on ltr vs rtl, the vertical scrollbar can be on either side of the container, so only include the side its on

        if (alignBox.right - (containerBox.left + (oj.DomUtils.getReadingDirection() === 'rtl' ? scrollBarWidth : 0)) < -1 || alignBox.left - (containerBox.right - (oj.DomUtils.getReadingDirection() === 'ltr' ? scrollBarWidth : 0)) > -1) {
          return false;
        }
      }

      return true;
    }

    function hasOverflow(_element) {
      return _element.css('overflow-x') !== 'visible' || _element.css('overflow-y') !== 'visible';
    }

    function getRect(_element) {
      var domElement = _element[0];

      if (domElement.nodeType === 1) {
        var rec = $.extend({}, domElement.getBoundingClientRect());
        rec.overflowX = _element.css('overflow-x');
        rec.overflowY = _element.css('overflow-y');
        rec.innerHeight = _element.innerHeight();
        rec.innerWidth = _element.innerWidth();
        rec.scrollHeight = domElement.scrollHeight;
        rec.scrollWidth = domElement.scrollWidth;
        return rec;
      }

      return {
        height: 0,
        width: 0
      };
    }

    function isPositioned(_element) {
      return ['fixed', 'absolute', 'relative'].indexOf(_element.css('position')) > -1 && (Math.abs(oj.DomUtils.getCSSLengthAsInt(_element.css('top'))) > 0 || Math.abs(oj.DomUtils.getCSSLengthAsInt(_element.css('bottom'))) > 0 || Math.abs(oj.DomUtils.getCSSLengthAsInt(_element.css('left'))) > 0 || Math.abs(oj.DomUtils.getCSSLengthAsInt(_element.css('right'))) > 0);
    }

    if (!element) {
      return false;
    } else if ($.isWindow(element[0]) || isPositioned(element)) {
      return true;
    }

    var alignBox = getRect(element); // check that the element is not hidden in overflow

    var isWithinViewPort = true;
    var parent = element.parent();

    while (isWithinViewPort && parent && parent.length > 0 && parent[0].nodeName !== 'BODY' && parent[0].nodeType === 1 && !isPositioned(parent)) {
      if (hasOverflow(parent)) {
        var parentBox = getRect(parent); // ignore elements with empty border-boxes

        if (parentBox.height > 0 && parentBox.width > 0) {
          isWithinViewPort = isVisible(alignBox, parentBox);
        }
      }

      parent = parent.parent();
    }

    return isWithinViewPort;
  };
  /**
   * Mapping of horizontal-vertical (x,y) alignment positon to the corresponding css
   * "transform-origin" attribute.
   *
   * horizontal: right, left, center
   * vertical: top, bottom, middle
   *
   * @private
   * @const
   */


  PositionUtils._ANIMATION_TRANSFORM_ORIGIN_RULES = {
    'right-top': 'right top',
    'right-middle': 'right center',
    'right-bottom': 'right bottom',
    'left-top': 'left top',
    'left-middle': 'left center',
    'left-bottom': 'left bottom',
    'center-top': 'center top',
    'center-middle': 'center center',
    'center-bottom': 'center bottom'
  };
  /**
   * Data attribute key used to store the alignment of the popup relative
   * to the aligning element - position.of
   *
   * @private
   * @const
   * @type {string}
   */

  PositionUtils._ALIGN_MNEMONIC_DATA = 'oj-popup-align-mnemonic';
  /**
   * Pass the root popup element and the second argument of the jquery ui position utils using
   * callback.  Stashes away the alignment hints returned by the position utility as a data property
   * on the target jquery element.  The alignment hints are used to define the transform-origin
   * of animation effects.
   *
   * @see PositionUtils.addTransformOriginAnimationEffectsOption
   * @param {jQuery} element popup root node
   * @param {Object} props second argument to the jquery ui position "using" callback.
   * @return {void}
   */

  PositionUtils.captureTransformOriginAnimationEffectsOption = function (element, props) {
    var alignMnemonic = [props.horizontal, props.vertical].join('-');
    element.data(PositionUtils._ALIGN_MNEMONIC_DATA, alignMnemonic);
  };
  /**
   * Pass "open" or "close" animation effects.  Replaces occurances of
   * "transformOrigin":"#myPositon" with a value that represents the popups alignment.
   *
   * @see PositionUtils.captureTransformOriginAnimationEffectsOption
   * @param {jQuery} element popup root node
   * @param {string|Object|Array} effects animation instructions
   * @returns {string|Object|Array} effects with the transformOrign property resolved
   */


  PositionUtils.addTransformOriginAnimationEffectsOption = function (element, effects) {
    var effectsAsString;
    var isEffectsTypeofString;

    if (!oj.StringUtils.isString(effects)) {
      isEffectsTypeofString = false;
      effectsAsString = JSON.stringify(effects);
    } else {
      isEffectsTypeofString = true;
      effectsAsString = effects;
    }

    var exp = /#myPosition/g;

    if (effectsAsString.match(exp)) {
      var alignMnemonic =
      /** @type {string} */
      element.data(PositionUtils._ALIGN_MNEMONIC_DATA);

      if (oj.StringUtils.isEmptyOrUndefined(alignMnemonic)) {
        alignMnemonic = 'center-middle';
      }

      var transformOrigin = PositionUtils._ANIMATION_TRANSFORM_ORIGIN_RULES[alignMnemonic];
      effectsAsString = effectsAsString.replace(exp, transformOrigin); // eslint-disable-next-line no-param-reassign

      effects = isEffectsTypeofString ? effectsAsString :
      /** @type {Object} */
      JSON.parse(effectsAsString);
    }

    return effects;
  };
  /**
   * Splits the jquery UI vertical mnemonic into 3 groups.
   * @private
   * @constant {RegExp}
   */


  PositionUtils._JQUI_MNEMONIC_GRP_REGX = /^(\w+)(\+|-)?(\d+)?/;
  /**
   * Verify vertical mnemonic.
   * @private
   * @constant {RegExp}
   */

  PositionUtils._VERTICAL_ENUM_TST_REGX = /^top$|^center$|^bottom$/;
  /**
   * Verify horizontal mnemonic.
   * @private
   * @constant {RegExp}
   */

  PositionUtils._HORIZONTAL_ENUM_TST_REGX = /^start$|^left$|^center$|^end$|^right$/;
  /**
   * Verify collision mnemonic.
   * @private
   * @constant {RegExp}
   */

  PositionUtils._COLLISION_ENUM_TST_REGX = /^none$|^flip$|^flipfit$|^fit$|^flipcenter$/;
  /**
   * @private
   * @param {string} token containing a position alignment rule
   * @param {RegExp} testRegX regular expression to verify the token enumerations
   * @returns {Array} array of two values [alignment, offset].
   */

  PositionUtils._parsePositionNmnemonic = function (token, testRegX) {
    var data = [null, Number.NaN];

    var groups = PositionUtils._JQUI_MNEMONIC_GRP_REGX.exec(token);

    if (groups[1] && testRegX.test(groups[1])) {
      data[0] = groups[1]; // has an offset prefiex by +|-

      if (groups[2]) {
        var offset = parseInt(groups[3], 10);

        if (!isNaN(offset)) {
          offset *= groups[2] === '-' ? -1 : 1;
          data[1] = offset;
        }
      }
    }

    return data;
  };
  /**
   *
   * @private
   * @param {?} value that might be a json string
   * @returns {?} returns an object if the value is a json string; otherwise,
   *          a null value is returned.
   */


  PositionUtils._parseJSON = function (value) {
    if (oj.StringUtils.isString(value) && /^{/.test(value) && /}$/.test(value)) {
      try {
        return JSON.parse(value);
      } catch (e) {// Ignore errors
      }
    }

    return null;
  };
  /**
   * Converts a source "position.my" or "position.at" into a suitable state held by jet components.
   *
   * @param {string} type "my" or "at"
   * @param {Object} source postion.my or position.at to shape into a Jet position object
   * @param {Object=} offsetSource position.offset
   * @param {Object=} sourceDefault default values
   * @returns {Object} internal position impl
   * @private
   */


  PositionUtils._coerceMyAtToJet = function (type, source, offsetSource, sourceDefault) {
    var obj = PositionUtils._parseJSON(source);

    if (obj) {
      // eslint-disable-next-line no-param-reassign
      source = obj;
    }

    obj = PositionUtils._parseJSON(offsetSource);

    if (obj) {
      // eslint-disable-next-line no-param-reassign
      offsetSource = obj;
    }

    if (!sourceDefault) {
      // eslint-disable-next-line no-param-reassign
      sourceDefault = {};
    }

    var target = $.extend({}, sourceDefault);
    var offsetTarget = {
      x: 0,
      y: 0
    };

    if (offsetSource && 'x' in offsetSource && 'y' in offsetSource) {
      offsetTarget.x = oj.DomUtils.getCSSLengthAsInt(offsetSource.x);
      offsetTarget.y = oj.DomUtils.getCSSLengthAsInt(offsetSource.y);
    }

    var groups;

    if (oj.StringUtils.isString(source)) {
      // jquery ui
      // split horizontal and vertical tokens
      var tokens = source.split(/\s/); // parse horizontal

      if (tokens.length > 0 && !oj.StringUtils.isEmpty(tokens[0])) {
        groups = PositionUtils._parsePositionNmnemonic(tokens[0], PositionUtils._HORIZONTAL_ENUM_TST_REGX); // verify horizontal enum

        if (groups[0]) {
          target.horizontal = groups[0];

          if (!isNaN(groups[1])) {
            offsetTarget.x = groups[1];
          }
        }
      } // parse vertical


      if (tokens.length > 1 && !oj.StringUtils.isEmpty(tokens[1])) {
        groups = PositionUtils._parsePositionNmnemonic(tokens[1], PositionUtils._VERTICAL_ENUM_TST_REGX); // verify vertical enum

        if (groups[0]) {
          target.vertical = groups[0];

          if (!isNaN(groups[1])) {
            offsetTarget.y = groups[1];
          }
        }
      }
    } else if (source) {
      // my is is in the jet position format
      if ('horizontal' in source) {
        groups = PositionUtils._parsePositionNmnemonic(source.horizontal, PositionUtils._HORIZONTAL_ENUM_TST_REGX);

        if (groups[0]) {
          target.horizontal = groups[0];

          if (!isNaN(groups[1])) {
            offsetTarget.x = groups[1];
          }
        }
      }

      if ('vertical' in source) {
        groups = PositionUtils._parsePositionNmnemonic(source.vertical, PositionUtils._VERTICAL_ENUM_TST_REGX);

        if (groups[0]) {
          target.vertical = groups[0];

          if (!isNaN(groups[1])) {
            offsetTarget.y = groups[1];
          }
        }
      }
    }

    var targetPosition = {};
    targetPosition[type] = target;
    targetPosition.offset = offsetTarget;
    return targetPosition;
  };
  /**
   * Converts a source "position.collision" into a suitable state held by jet components.
   *
   * @param {string} collisionSource postion.collision to shape into a Jet position object
   * @param {string=} collisionDefault default values
   * @returns {Object} internal position impl
   * @private
   */


  PositionUtils._coerceCollisionToJet = function (collisionSource, collisionDefault) {
    var collisionTarget = collisionDefault;

    if (PositionUtils._COLLISION_ENUM_TST_REGX.test(collisionSource)) {
      collisionTarget = collisionSource;
    }

    return {
      collision: collisionTarget
    };
  };
  /**
   * Converts a source "position.of" into a suitable state held by jet components.
   *
   * @param {Object} ofSource position.of
   * @param {Object=} ofDefault default value
   * @return {Object} internal postion object
   * @private
   */


  PositionUtils._coerceOfToJet = function (ofSource, ofDefault) {
    function _escapeId(id) {
      var targetId = [];
      var regex = /\w|_|-/;

      for (var i = 0; i < id.length; i++) {
        var c = id.substring(i, i + 1);

        if (regex.test(c)) {
          targetId.push(c);
        } else {
          targetId.push('\\' + c);
        }
      }

      return targetId.join('');
    }

    var obj = PositionUtils._parseJSON(ofSource);

    if (obj) {
      // eslint-disable-next-line no-param-reassign
      ofSource = obj;
    }

    var targetOf = ofDefault;

    if (oj.StringUtils.isString(ofSource)) {
      targetOf = ofSource; // assume a valid selector
    } else if ($.isWindow(ofSource)) {
      targetOf = 'window';
    } else if (ofSource instanceof Element || ofSource instanceof $) {
      // eslint-disable-next-line no-param-reassign
      ofSource = $(ofSource);
      ofSource.uniqueId();
      var id = ofSource.attr('id');
      targetOf = '#' + _escapeId(id);
    } else if (ofSource instanceof Event || ofSource instanceof $.Event) {
      if ('pageX' in ofSource || 'pageY' in ofSource) {
        targetOf = {};
        targetOf.x = oj.DomUtils.getCSSLengthAsFloat(ofSource.pageX);
        targetOf.y = oj.DomUtils.getCSSLengthAsFloat(ofSource.pageY);
      }
    } else if (ofSource) {
      if ('x' in ofSource || 'y' in ofSource) {
        targetOf = {};
        targetOf.x = oj.DomUtils.getCSSLengthAsFloat(ofSource.x);
        targetOf.y = oj.DomUtils.getCSSLengthAsFloat(ofSource.y);
      }
    }

    return {
      of: targetOf
    };
  };
  /**
   * Converts a source "position" into a suitable state held by jet components.
   *
   * @param {Object} source position
   * @param {Object=} defaults for target position
   * @return {Object} internal postion object
   */


  PositionUtils.coerceToJet = function (source, defaults) {
    if (!source) {
      // eslint-disable-next-line no-param-reassign
      source = {};
    }

    var obj = PositionUtils._parseJSON(source);

    if (obj) {
      // eslint-disable-next-line no-param-reassign
      source = obj;
    }

    if (!defaults) {
      // eslint-disable-next-line no-param-reassign
      defaults = {};
    }

    function _coerceUsingToJet(usingSource, usingDefault) {
      var targetUsing = $.isFunction(usingSource) ? usingSource : usingDefault;
      return {
        using: targetUsing
      };
    }

    var myDefault = defaults.my;
    var atDefault = defaults.at;
    var collisionDefault = defaults.collision;
    var ofDefault = defaults.of;
    var usingDefault; // to dangerous to inherit

    var targetMy = PositionUtils._coerceMyAtToJet('my', source.my, source.offset, myDefault);

    var targetAt = PositionUtils._coerceMyAtToJet('at', source.at, null, atDefault); // sum the "at" and "my" offsets


    var targetOffset = {
      offset: {
        x: targetMy.offset.x + targetAt.offset.x,
        y: targetMy.offset.y + targetAt.offset.y
      }
    };
    delete targetMy.offset;
    delete targetAt.offset;
    var target = $.extend({}, targetMy, targetAt, targetOffset, PositionUtils._coerceCollisionToJet(source.collision, collisionDefault), PositionUtils._coerceOfToJet(source.of, ofDefault), _coerceUsingToJet(source.using, usingDefault));
    return target;
  };
  /**
   * Converts the jet position object into the jQuery UI object used by the position utility.
   *
   * @param {Object} source internal position object
   * @return {Object} jQuery UI position Object
   */


  PositionUtils.coerceToJqUi = function (source) {
    function alignToJqUi(align, direction) {
      var tokens = [];

      if (source[align][direction]) {
        tokens.push(source[align][direction]);
      } else {
        tokens.push('center');
      }

      if (align === 'my' && source.offset) {
        var offsetDirection = direction === 'horizontal' ? 'x' : 'y';
        var offset = source.offset[offsetDirection];

        if (!isNaN(offset) && offset !== 0) {
          tokens.push(offset > 0 ? '+' : '');
          tokens.push(Math.floor(offset).toString());
        }
      }

      return tokens.join('');
    }

    var target = {}; // convert my and at

    ['my', 'at'].forEach(function (align) {
      if (source[align]) {
        var tokens = [];
        tokens.push(alignToJqUi(align, 'horizontal'));
        tokens.push(' ');
        tokens.push(alignToJqUi(align, 'vertical'));
        target[align] = tokens.join('');
      }
    }); // convert of

    var ofSource = source.of;

    if (oj.StringUtils.isString(ofSource)) {
      if (ofSource === 'window') {
        target.of = window;
      } else {
        target.of = ofSource;
      }
    } else if (ofSource && !oj.StringUtils.isString(ofSource) && 'x' in ofSource && 'y' in ofSource) {
      var x = ofSource.x;
      var y = ofSource.y;
      var nativeEvent = document.createEvent('MouseEvents');
      nativeEvent.initMouseEvent('click', true, true, window, 1, x, y, x, y, false, false, false, false, 0, null);
      target.of = $.Event(nativeEvent, {
        pageX: x,
        pageY: y
      });
    } else {
      target.of = ofSource;
    }

    if (source.collision) {
      target.collision = source.collision;
    } // convert using


    if (source.using) {
      target.using = source.using;
    }

    return target;
  };
  /**
   * Custom jquery UI position collision rule that will first apply the "flip" rule and follow with "center" alignment.
   * @ojtsignore
   */


  $.ui.position.flipcenter = {
    /**
     * @param {{top: number, left: number}} position
     * @param {{targetWidth: number,
     *         targetHeight: number,
     *         elemWidth: number,
     *         elemHeight: number,
     *         collisionPosition: {marginLeft: number, marginTop: number},
     *         collisionWidth: number,
     *         collisionHeight: number,
     *         offset: Array.<number>,
     *         my: Array.<string>,
     *         at: Array.<string>,
     *         within: {element: jQuery, isWindow: boolean, isDocument: boolean, offset: {left: number, top: number}, scrollLeft: number, scrollTop: number, width: number, height: number},
     *         elem: jQuery
     *        }} data
     * @returns {undefined}
     */
    left: function left(position, data) {
      // stash away the initial position calculated from the at alignment
      var posLeft = position.left; // call on the flip rule

      $.ui.position.flip.left.call(this, position, data); // These calcs were taken from the "fit" rule.

      var within = data.within;
      var withinOffset = within.isWindow ? within.scrollLeft : within.offset.left;
      var outerWidth = within.width;
      var collisionPosLeft = position.left - data.collisionPosition.marginLeft;
      var overLeft = withinOffset - collisionPosLeft;
      var overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset; // if popup is not within, center align it

      if (overLeft > 0 || overRight > 0) {
        // find the center of the target element
        if (data.at[0] === 'right') {
          posLeft -= data.targetWidth / 2;
        } else if (data.at[0] === 'left') {
          posLeft += data.targetWidth / 2;
        }

        var isRTL = oj.DomUtils.getReadingDirection() === 'rtl';
        var dirFactor = isRTL ? -1 : 1; // factor in half the width of the popup

        posLeft -= dirFactor * (data.elemWidth / 2); // Force the popup start to be within the viewport.
        // This collision rule is only used by input components internally. The notewindow will auto dismiss when
        // what it is aligned to is hidden in a scroll container.
        // eslint-disable-next-line no-param-reassign

        position.left = Math.max(0, posLeft);
      }
    },

    /**
     * @param {{top: number, left: number}} position
     * @param {{targetWidth: number,
     *         targetHeight: number,
     *         elemWidth: number,
     *         elemHeight: number,
     *         collisionPosition: {marginLeft: number, marginTop: number},
     *         collisionWidth: number,
     *         collisionHeight: number,
     *         offset: Array.<number>,
     *         my: Array.<string>,
     *         at: Array.<string>,
     *         within: {element: jQuery, isWindow: boolean, isDocument: boolean, offset: {left: number, top: number}, scrollLeft: number, scrollTop: number, width: number, height: number},
     *         elem: jQuery
     *        }} data
     * @returns {undefined}
     */
    top: function top(position, data) {
      // stash away the initial position calculated from the at alignment
      var posTop = position.top;
      $.ui.position.flip.top.call(this, position, data); // These calcs were taken from the "fit" rule.

      var within = data.within;
      var withinOffset = within.isWindow ? within.scrollTop : within.offset.top;
      var outerHeight = data.within.height;
      var collisionPosTop = position.top - data.collisionPosition.marginTop;
      var overTop = withinOffset - collisionPosTop;
      var overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset;

      if (overTop > 0 || overBottom > 0) {
        // find the center of the target element
        if (data.at[1] === 'top') {
          posTop += data.targetHeight / 2;
        } else if (data.at[1] === 'bottom') {
          posTop -= data.targetHeight / 2;
        } // factor in half the height of the popup


        posTop += data.elemHeight / 2; // Force the popup top to be within the viewport.
        // This collision rule is only used by input components internally. The notewindow will auto dismiss when
        // what it is aligned to is hidden in a scroll container.
        // eslint-disable-next-line no-param-reassign

        position.top = Math.max(0, posTop);
      }
    }
  };
  /**
   * Forked the jquery UI "flip" position collision rule in version 1.11.4.
   * The jquery version doesn't consider the best fit in terms of
   * top/bottom. The rule favors top when there is no fit versus choosing the
   * best fit, lesser of two evils. The new JET spin of this rule will pick
   * the better fit versus favoring top when there is no fit.
   *
   * Outside of making the code closure compiler friendly, there is only
   * a single line difference.  It's noted with a bug number.
   * @private
   */

  var _origLeftFlipCollisionRule = $.ui.position.flip.left; // stash away the original left flip rule

  /**
   * @ojtsignore
   */

  $.ui.position.flip = {
    left: _origLeftFlipCollisionRule.bind(null),

    /**
     * @param {{top: number, left: number}} position
     * @param {{targetWidth: number,
     *         targetHeight: number,
     *         elemWidth: number,
     *         elemHeight: number,
     *         collisionPosition: {marginLeft: number, marginTop: number},
     *         collisionWidth: number,
     *         collisionHeight: number,
     *         offset: Array.<number>,
     *         my: Array.<string>,
     *         at: Array.<string>,
     *         within: {element: jQuery, isWindow: boolean, isDocument: boolean, offset: {left: number, top: number}, scrollLeft: number, scrollTop: number, width: number, height: number},
     *         elem: jQuery
     *        }} data
     * @returns {undefined}
     */
    top: function top(position, data) {
      var within = data.within;
      var withinOffset = within.offset.top + within.scrollTop;
      var outerHeight = within.height;
      var offsetTop = within.isWindow ? within.scrollTop : within.offset.top;
      var collisionPosTop = position.top - data.collisionPosition.marginTop;
      var overTop = collisionPosTop - offsetTop;
      var overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop;
      var top = data.my[1] === 'top';
      var myOffset;

      if (top) {
        myOffset = -data.elemHeight;
      } else if (data.my[1] === 'bottom') {
        myOffset = data.elemHeight;
      } else {
        myOffset = 0;
      }

      var atOffset;

      if (data.at[1] === 'top') {
        atOffset = data.targetHeight;
      } else if (data.at[1] === 'bottom') {
        atOffset = -data.targetHeight;
      } else {
        atOffset = 0;
      }

      var offset = -2 * data.offset[1];
      var newOverBottom;
      var newOverTop;

      if (overTop < 0) {
        newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;

        if (newOverBottom < 0 || newOverBottom < Math.abs(overTop)) {
          //  - only flip up if there is more "over" on top than bottom
          if (overBottom < 0 && overTop > overBottom) {
            // eslint-disable-next-line no-param-reassign
            position.top += myOffset + atOffset + offset;
          }
        }
      } else if (overBottom > 0) {
        newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;

        if (newOverTop > 0 || Math.abs(newOverTop) < overBottom) {
          // eslint-disable-next-line no-param-reassign
          position.top += myOffset + atOffset + offset;
        }
      }
    }
  };
  /**
   * @license
   * Copyright (c) 2004 2020, Oracle and/or its affiliates.
   * The Universal Permissive License (UPL), Version 1.0
   * as shown at https://oss.oracle.com/licenses/upl/
   * @ignore
   */

  /**
   * Utility for handling popup voice over messages sent to a aria live region.
   * @extends {oj.Object}
   * @public
   * @constructor
   * @since 1.1
   * @class PopupLiveRegion
   * @ignore
   * @ojtsignore
   */

  var PopupLiveRegion = function PopupLiveRegion() {
    this.Init();
  };

  oj._registerLegacyNamespaceProp('PopupLiveRegion', PopupLiveRegion);

  oj.Object.createSubclass(PopupLiveRegion, oj.Object, 'oj.PopupLiveRegion');
  /**
   * Adds one to the reference counter instance.
   * @override
   * @instance
   * @protected
   */

  PopupLiveRegion.prototype.Init = function () {
    PopupLiveRegion.superclass.Init.call(this);

    if (isNaN(PopupLiveRegion._refCounter)) {
      PopupLiveRegion._refCounter = 1;
    } else {
      PopupLiveRegion._refCounter += 1;
    }
  };
  /**
   * Decrements the reference counter destroying the assocaited shared DOM aria
   * live region element when there are no longer any popups using it.
   * @instance
   * @public
   */


  PopupLiveRegion.prototype.destroy = function () {
    if (!isNaN(PopupLiveRegion._refCounter)) {
      PopupLiveRegion._refCounter -= 1;

      if (PopupLiveRegion._refCounter < 1) {
        var liveRegion = $(document.getElementById(PopupLiveRegion._POPUP_LIVE_REGION_ID));

        if (liveRegion.length > 0) {
          liveRegion.remove();
        }
      }
    }
  };
  /**
   * Sends a message to the aria live region for voice over mode.
   * @instance
   * @public
   * @param {string} message to be announce in the live region
   */


  PopupLiveRegion.prototype.announce = function (message) {
    if (!oj.StringUtils.isEmpty(message)) {
      var liveRegion = PopupLiveRegion._getLiveRegion();

      liveRegion.children().remove();
      $('<div>').text(message).appendTo(liveRegion); // @HTMLUpdateOK the "messsage" comes from a
      // translated string that can be overridden by
      // an option on the ojPopup.  The jquery "text"
      // function will escape script.
    }
  };
  /**
   * Creates or returns an existing aria live region used by popups.
   * @returns {jQuery} aria live region
   * @private
   */


  PopupLiveRegion._getLiveRegion = function () {
    var liveRegion = $(document.getElementById(PopupLiveRegion._POPUP_LIVE_REGION_ID));

    if (liveRegion.length === 0) {
      liveRegion = $('<div>');
      liveRegion.attr({
        id: PopupLiveRegion._POPUP_LIVE_REGION_ID,
        role: 'log',
        'aria-live': 'polite',
        'aria-relevant': 'additions'
      });
      liveRegion.addClass('oj-helper-hidden-accessible');
      liveRegion.appendTo(document.body); // @HTMLUpdateOK
    }

    return liveRegion;
  };
  /**
   * Id assigned to the popup aria live region dom element.
   * @const
   * @private
   * @type {string}
   */


  PopupLiveRegion._POPUP_LIVE_REGION_ID = '__oj_popup_arialiveregion';
  /**
   * @license
   * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
   * The Universal Permissive License (UPL), Version 1.0
   * as shown at https://oss.oracle.com/licenses/upl/
   * @ignore
   */

  /**
   * Utility that injects a hidden link relative to another for voice support
   * @class PopupSkipLink
   * @extends {oj.Object}
   * @public
   * @constructor
   * @since 1.1
   * @ignore
   * @param {jQuery} sibling element to the new skip link element
   * @param {string} message text assigned to the skip link
   * @param {function(!Event)} callback fired for activation of the skip link
   * @param {string=} id assigned to the skiplink component
   * @param {{insertBefore:boolean, preventKeyEvents: boolean}=} options overrides default behaviors
   * @ojtsignore
   */

  var PopupSkipLink = function PopupSkipLink(sibling, message, callback, id, options) {
    oj.Assert.assertPrototype(sibling, $);
    oj.Assert.assertString(message);
    oj.Assert.assertFunction(callback);
    oj.Assert.assertStringOrNull(id);
    this._options = {
      insertBefore: false,
      preventKeyEvents: true
    };

    if (options) {
      this._options = Object.assign({}, this._options, options);
    }

    this._sibling = sibling;
    this._message = message;
    this._callback = callback;
    this._id = id;
    this.Init();
  };

  oj._registerLegacyNamespaceProp('PopupSkipLink', PopupSkipLink);

  oj.Object.createSubclass(PopupSkipLink, oj.Object, 'oj.PopupSkipLink');
  /**
   * Creates an invisible anchor relative to the sibling and hooks up the activation callack.
   * @override
   * @instance
   * @protected
   */

  PopupSkipLink.prototype.Init = function () {
    PopupSkipLink.superclass.Init.call(this);
    var sibling = this._sibling;
    var callback = this._callback;
    var message = this._message;
    var insertBefore = this._options.insertBefore;
    var preventKeyEvents = this._options.preventKeyEvents;
    this._message = null;
    var id = this._id;
    this._id = null;
    var link = $(document.getElementById(id));

    if (link.length < 1) {
      link = $('<a>').attr({
        tabindex: '-1',
        href: '#',
        role: 'link'
      });
    }

    link.attr('id', id);
    link.addClass('oj-helper-hidden-accessible');
    link.text(message);

    if (!insertBefore) {
      link.insertAfter(sibling); // @HTMLUpdateOK
    } else {
      link.insertBefore(sibling); // @HTMLUpdateOK
    }

    link.on('click', PopupSkipLink._activateHandler.bind(this, callback));

    if (preventKeyEvents) {
      // This could only happen in some kind of simulator as this skip link is only used on the iOS
      // platform. Prevent click generated from an "enter" key press by eating the event.
      link.on('keydown keyup keypress', PopupSkipLink._keyHandler);
    }

    sibling.data(PopupSkipLink._SKIPLINK_ATTR, link);
  };
  /**
   * Handles activation of the skiplink.  Cancels the click event.
   * @private
   * @param {?} listener
   * @param {Event} event
   */


  PopupSkipLink._activateHandler = function (listener, event) {
    ZOrderUtils.eatEvent(event);
    window.setImmediate(listener);
  };
  /**
   * Listener registered on the skip link element to prevent an enter key from generating a click
   * @private
   * @param {jQuery.Event|Event} event
   */


  PopupSkipLink._keyHandler = function (event) {
    if (event.keyCode === $.ui.keyCode.ENTER) {
      ZOrderUtils.eatEvent(event);
    }
  };
  /**
   * Removes the voice over skip link.
   * @instance
   * @public
   */


  PopupSkipLink.prototype.destroy = function () {
    var sibling = this._sibling;
    delete this._sibling;
    delete this._callback;

    if (sibling) {
      var link = sibling.data(PopupSkipLink._SKIPLINK_ATTR);
      sibling.removeData(PopupSkipLink._SKIPLINK_ATTR);

      if (link) {
        link.off('click keydown keyup keypress');
        link.remove();
      }
    }
  };
  /**
   * Returns the skip link jQuery element.
   * @instance
   * @public
   * @return {jQuery} skip link
   */


  PopupSkipLink.prototype.getLink = function () {
    /** @type {?} */
    var sibling = this._sibling;
    /** @type {jQuery} */

    var link;

    if (sibling) {
      link = sibling.data(PopupSkipLink._SKIPLINK_ATTR);
    }

    return link;
  };
  /**
   * Data attribute name assigned to the sibling element that tracks a
   * reference for the associated skip link.
   * @const
   * @private
   * @type {string}
   */


  PopupSkipLink._SKIPLINK_ATTR = 'oj-skiplink';
  /**
   * @license
   * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
   * The Universal Permissive License (UPL), Version 1.0
   * as shown at https://oss.oracle.com/licenses/upl/
   * @ignore
   */

  /**
   * Coordinate communications between an event being fulfilled and one or more promises
   * being resolved.  The window of time between the instance creation and the associated event
   * triggered is guarded by the {@link oj.BusyContext}.  The
   * @link{PopupWhenReadyMediator#getWhenReadyPromise} promise will resolve when either the
   * target event is triggered or instance destroyed.
   * @class PopupWhenReadyMediator
   * @extends {oj.Object}
   * @constructor
   * @since 3.0.0
   * @ignore
   * @param {jQuery} element to subscribe on the event type triggered on completion of the operation
   * @param {string} operation that completion will resolve one or more promises
   * @param {string} widgetName component constructor
   * @param {boolean} isCustomElement <code>true</code> if the widget is created as a custom element
   * @ojtsignore
   */

  var PopupWhenReadyMediator = function PopupWhenReadyMediator(element, operation, widgetName, isCustomElement) {
    this._element = element;
    this._operation = operation;
    this._widgetName = widgetName;
    this._isCustomElement = !!isCustomElement;
    this.Init();
  };

  oj._registerLegacyNamespaceProp('PopupWhenReadyMediator', PopupWhenReadyMediator);

  oj.Object.createSubclass(PopupWhenReadyMediator, oj.Object, 'oj.PopupWhenReadyMediator');
  /**
   * Registers an event handler on the element associated with the target operation.
   * The event handler will resolve one or more pending promises.  The convention
   * is the operation will raise a "oj" + operation event upon completion. The
   * event hander is one and done - unregistered after first delivery.
   *
   * @override
   * @instance
   * @protected
   */

  PopupWhenReadyMediator.prototype.Init = function () {
    PopupWhenReadyMediator.superclass.Init.call(this);
    this._resolvedQueue = [];
    this._callback = this._eventHandler.bind(this);
    var operation = this._operation;
    var tokens = ['oj'];

    if (this._isCustomElement) {
      tokens.push(operation.charAt(0).toUpperCase());
      tokens.push(operation.slice(1));
    } else {
      tokens.push(operation);
    }

    var eventType = tokens.join('');
    this._eventType = eventType;

    this._element.on(eventType, this._callback); // Add a busy state for the pending operation.  The busy state resolver will
    // be invoked when the resolved queue is delivered (operation completes).


    var busyContext = Context.getContext(this._element[0]).getBusyContext();
    var options = {
      description: this._getBusyStateDescription.bind(this, this._element, this._operation, this._widgetName)
    };
    var resolve = busyContext.addBusyState(options);
    this.AddPromiseExecutor(resolve); // setup the when ready promise

    this._whenReadyPromise = new Promise(this.AddPromiseExecutor.bind(this));
  };
  /**
   * @private
   * @param {jQuery} element to subscribe on the event type triggered on completion of the operation
   * @param {string} operation that completion will resolve one or more promises
   * @param {string} widgetName component constructor
   * @returns {string} description of the busy state animation operation.
   */


  PopupWhenReadyMediator.prototype._getBusyStateDescription = function (element, operation, widgetName) {
    return widgetName + " identified by '" + element.attr('id') + "' is busy animating on " + "the '" + operation + "' operation.";
  };
  /**
   * Resolves the pending promises.
   *
   * @private
   * @param {string=} operation override sent to the resolverdQueue
   */


  PopupWhenReadyMediator.prototype._deliverResolved = function (operation) {
    // Critical section - the registered resolve queue is disconnect from the
    // instance state so that a race condition will not occur - resolve promoise
    // adding new operations to the same queue.
    var resolvedQueue = this._resolvedQueue;
    this._resolvedQueue = null;

    var _operation = !operation ? this._operation : operation;

    this._operation = null;

    for (var i = 0; i < resolvedQueue.length; i++) {
      try {
        resolvedQueue[i](_operation);
      } catch (e) {
        Logger.error('Error resolving whenReady promises:\n%o', e);
      }
    }

    this._whenReadyPromise = Promise.resolve('none');
  };
  /**
   * Force delivery of unresolved promises.
   */


  PopupWhenReadyMediator.prototype.destroy = function () {
    // If the promise is swapped (component is destroyed)
    // before the event is fired, resolve with a "none" operation.
    if (this._resolvedQueue) {
      this._deliverResolved('none');
    }

    if (this._callback) {
      var eventType = this._eventType;

      this._element.off(eventType, this._callback);
    }

    this._callback = null;
    this._element = null;
    this._operation = null;
    this._whenReadyPromise = null;
    this._widgetName = null;
    this._eventType = null;
  };
  /**
   * @returns {Promise} returns an instance of the current whenReadyPromise
   */


  PopupWhenReadyMediator.prototype.getWhenReadyPromise = function () {
    return this._whenReadyPromise;
  };
  /**
   * Event handler associated with completion of the target operation.
   * @private
   * @param {jQuery.Event} event
   */


  PopupWhenReadyMediator.prototype._eventHandler = function (event) {
    if (event.target === this._element[0]) {
      this._element.off(event.type, this._callback);

      this._deliverResolved();

      this._callback = null;
    }
  };
  /**
   * @private
   * @return {string} Returns the pending operation
   */


  PopupWhenReadyMediator.prototype._getPendingOperation = function () {
    return this._operation ? this._operation : 'none';
  };
  /**
   * A function that will be passed to other functions via the arguments resolve and reject.
   * The resolve function will be invoked when the event associated with completion of the
   * target operation is delivered to the target element.
   *
   * @protected
   * @param {Function} resolve resultant function that will resovle a promise executor
   * @param {Function=} reject (not interested in the reject)
   */
  // eslint-disable-next-line no-unused-vars


  PopupWhenReadyMediator.prototype.AddPromiseExecutor = function (resolve, reject) {
    if (this._resolvedQueue) {
      this._resolvedQueue.push(resolve);
    }
  };
  /**
   * Checks to see if there is a pending "open" or "close" operation.  If pending and it
   * is the same as the requested operation, the request silently fails.  If the current
   * operation is the inverse operation, we queue the current operation after the pending
   * operation is resolved.
   *
   * @param {Object} widgetInstance this mediator is negotiating on behalf of
   * @param {string} operation currently requested
   * @param {string} methodName that should be invoked on the widgetInstance if the operation is the
   *                 inverse of the pending operation
   * @param {Array} methodArgs passed to a queue method invocation
   * @returns {boolean} <code>true</code> if a "close" or "open" operation is pending completion.
   */


  PopupWhenReadyMediator.prototype.isOperationPending = function (widgetInstance, operation, methodName, methodArgs) {
    var isPending = false;
    var widgetName = this._widgetName;

    var pendingOperation = this._getPendingOperation();

    if (operation === pendingOperation) {
      // Same request is already pending. Silently fail.
      Logger.info("An %s instance invoked a '%s' operation while pending animation of " + 'the same type of operation.  The second request will be ignored.', widgetName, operation);
      isPending = true;
    } else if (pendingOperation !== 'none') {
      Logger.info("An %s instance invoked a '%s' operation while pending animation of a " + "'%s' operation. The second request will be invoked after the pending operation " + 'completes.', widgetName, operation, pendingOperation); // Queue the operation after the pending operation has completed
      // register another resolve promise with the mediator that will be
      // call when the pending operation finishes.

      var promise = new Promise(this.AddPromiseExecutor.bind(this));
      promise.then(function () {
        this[methodName].apply(this, methodArgs);
      }.bind(widgetInstance));
      isPending = true;
    }

    return isPending;
  };

  var Props = function Props() {
    _classCallCheck(this, Props);

    this.autoDismiss = null;
    this.layerSelectors = '';
    this.position = {};
  };

  var VPopup = /*#__PURE__*/function (_ojvcomponent$VCompon) {
    _inherits(VPopup, _ojvcomponent$VCompon);

    var _super = _createSuper(VPopup);

    function VPopup(props) {
      var _this;

      _classCallCheck(this, VPopup);

      _this = _super.call(this, props);
      _this._setRootRef = _this._setRootRef.bind(_assertThisInitialized(_this));
      return _this;
    }

    _createClass(VPopup, [{
      key: "render",
      value: function render() {
        return ojvcomponent.h("div", {
          style: {
            display: 'none'
          },
          ref: this._setRootRef
        }, this.props.children);
      }
    }, {
      key: "mounted",
      value: function mounted() {
        var _PopupService$OPTION$, _options;

        this._popup = $(this._rootRef.firstChild);
        var options = (_options = {}, _defineProperty(_options, PopupService.OPTION.POPUP, this._popup), _defineProperty(_options, PopupService.OPTION.EVENTS, (_PopupService$OPTION$ = {}, _defineProperty(_PopupService$OPTION$, PopupService.EVENT.POPUP_AUTODISMISS, this.props.autoDismiss), _defineProperty(_PopupService$OPTION$, PopupService.EVENT.POPUP_REFRESH, function () {
          this._popup.position(this._getPosition());
        }.bind(this)), _PopupService$OPTION$)), _defineProperty(_options, PopupService.OPTION.LAYER_SELECTORS, this.props.layerSelectors), _defineProperty(_options, PopupService.OPTION.CUSTOM_ELEMENT, true), _defineProperty(_options, PopupService.OPTION.LAUNCHER, $(this._rootRef)), _defineProperty(_options, PopupService.OPTION.POSITION, this._getPosition()), _options);
        PopupService.getInstance().open(options);
      }
    }, {
      key: "unmounted",
      value: function unmounted() {
        PopupService.getInstance().close(_defineProperty({}, PopupService.OPTION.POPUP, this._popup));
      }
    }, {
      key: "updated",
      value: function updated() {
        this._popup.position(this._getPosition());
      }
    }, {
      key: "_setRootRef",
      value: function _setRootRef(element) {
        this._rootRef = element;
      }
    }, {
      key: "_getPosition",
      value: function _getPosition() {
        return PositionUtils.normalizeHorizontalAlignment(this.props.position, oj.DomUtils.getReadingDirection() === 'rtl');
      }
    }]);

    return VPopup;
  }(ojvcomponent.VComponent);

  VPopup.metadata = {
    "extension": {
      "_DEFAULTS": Props
    }
  };
  exports.VPopup = VPopup;
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
});
}());
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojpopup',['ojs/ojcore', 'jquery', 'ojs/ojcontext', 'ojs/ojthemeutils', 'ojs/ojcomponentcore', 'ojs/ojanimation', 
        'ojs/ojpopupcore'], 
function(oj, $, Context, ThemeUtils, Components, AnimationUtils)
{
  "use strict";
var __oj_popup_metadata = 
{
  "properties": {
    "autoDismiss": {
      "type": "string",
      "enumValues": [
        "focusLoss",
        "none"
      ],
      "value": "focusLoss"
    },
    "chrome": {
      "type": "string",
      "enumValues": [
        "default",
        "none"
      ],
      "value": "default"
    },
    "initialFocus": {
      "type": "string",
      "enumValues": [
        "auto",
        "firstFocusable",
        "none",
        "popup"
      ],
      "value": "auto"
    },
    "modality": {
      "type": "string",
      "enumValues": [
        "modal",
        "modeless"
      ],
      "value": "modeless"
    },
    "position": {
      "type": "object",
      "properties": {
        "at": {
          "type": "object",
          "properties": {
            "horizontal": {
              "type": "string",
              "enumValues": [
                "center",
                "end",
                "left",
                "right",
                "start"
              ],
              "value": "start"
            },
            "vertical": {
              "type": "string",
              "enumValues": [
                "bottom",
                "center",
                "top"
              ],
              "value": "bottom"
            }
          }
        },
        "collision": {
          "type": "string",
          "enumValues": [
            "fit",
            "flip",
            "flipcenter",
            "flipfit",
            "none"
          ],
          "value": "flip"
        },
        "my": {
          "type": "object",
          "properties": {
            "horizontal": {
              "type": "string",
              "enumValues": [
                "center",
                "end",
                "left",
                "right",
                "start"
              ],
              "value": "start"
            },
            "vertical": {
              "type": "string",
              "enumValues": [
                "bottom",
                "center",
                "top"
              ],
              "value": "top"
            }
          }
        },
        "of": {
          "type": "string|object"
        },
        "offset": {
          "type": "object",
          "properties": {
            "x": {
              "type": "number",
              "value": 0
            },
            "y": {
              "type": "number",
              "value": 0
            }
          }
        }
      }
    },
    "tail": {
      "type": "string",
      "enumValues": [
        "none",
        "simple"
      ],
      "value": "none"
    },
    "translations": {
      "type": "object",
      "value": {},
      "properties": {
        "ariaCloseSkipLink": {
          "type": "string"
        },
        "ariaFocusSkipLink": {
          "type": "string"
        },
        "ariaLiveRegionInitialFocusFirstFocusable": {
          "type": "string"
        },
        "ariaLiveRegionInitialFocusFirstFocusableTouch": {
          "type": "string"
        },
        "ariaLiveRegionInitialFocusNone": {
          "type": "string"
        },
        "ariaLiveRegionInitialFocusNoneTouch": {
          "type": "string"
        }
      }
    }
  },
  "methods": {
    "open": {},
    "close": {},
    "isOpen": {},
    "refresh": {},
    "setProperty": {},
    "getProperty": {},
    "setProperties": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "events": {
    "ojBeforeOpen": {},
    "ojOpen": {},
    "ojBeforeClose": {},
    "ojClose": {},
    "ojFocus": {},
    "ojAnimateStart": {},
    "ojAnimateEnd": {}
  },
  "extension": {}
};


/*!
 * jQuery UI Popup @VERSION
 * http://jqueryui.com
 *
 * Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/menu/
 *
 * Depends:
 *  jquery.ui.core.js
 *  jquery.ui.widget.js
 *  jquery.ui.position.js
 */

/* global Components:false, Context:false, ThemeUtils:false */
(function () {
  /**
   * List of all pseudo marker selectors that defines rules for where a tail is aligned.
   * @private
   * @const
   */
  var _TAIL_STYLES = ['oj-left', 'oj-center', 'oj-right', 'oj-top', 'oj-middle', 'oj-bottom'];
  /**
   * Mapping of horizontal-vertical (x,y) positon using alignment to jet tail pseudo marker
   * selectors.
   *
   * horizontal: right, left, center
   * vertical: top, bottom, middle
   *
   * @private
   * @const
   */

  var _TAIL_ALIGN_RULES = {
    'right-top': 'oj-right oj-top',
    'right-middle': 'oj-right oj-middle',
    'right-bottom': 'oj-right oj-bottom',
    'left-top': 'oj-left oj-top',
    'left-middle': 'oj-left oj-middle',
    'left-bottom': 'oj-left oj-bottom',
    'center-top': 'oj-center oj-top',
    'center-middle': 'oj-left oj-middle',
    'center-bottom': 'oj-center oj-bottom'
  };
  /**
   * @typedef {Object} oj.ojPopup.PositionAlign
   * @property {"top"|"bottom"|"center"} [vertical] Vertical alignment.
   * @property {"start"|"end"|"left"|"center"|"bottom"} [horizontal] Horizontal alignment. <p>
   * <ul>
   *  <li><b>"start"</b> evaluates to "left" in LTR mode and "right" in RTL mode.</li>
   *  <li><b>"end"</b> evaluates to "right" in LTR mode and "left" in RTL mode.</li>
   * </ul>
   *
   */

  /**
   * @typedef {Object} oj.ojPopup.PositionPoint
   * @property {number} [x] Horizontal alignment offset.
   * @property {number} [y] Vertical alignment offset.
   */

  /**
   * @typedef {Object} oj.ojPopup.Position
   * @property {Object} [my] Defines which edge on the popup to align with the target ("of") element.
   * @property {Object} [at] Defines which position on the target element ("of") to align the positioned element
   *                                  against.
   * @property {Object} [offset] Defines a point offset in pixels from the ("my") alignment.
   * @property {string|Object} [of] Which element to position the popup against.  The default is the
   * <code class="prettyprint">launcher</code> argument passed to the
   * <code class="prettyprint">open</code> method. <p>
   *
   * If the value is a string, it should be a selector or the literal string value
   * of <code class="prettyprint">window</code>.  Otherwise, a point of x,y.  When a point
   * is used, the values are relative to the whole document.  Page horizontal and vertical
   * scroll offsets need to be factored into this point - see UIEvent
   * <a href="https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/pageX">pageX</a>,
   * <a href="https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/pageY">pageY</a>.
   *
   * @property {"flip"|"fit"|"flipfit"|"flipcenter"|"none"} [collision] Rule for alternate alignment. <p>
   * <ul>
   *  <li><b>"flip"</b> the element to the opposite side of the target and the
   *             collision detection is run again to see if it will fit. Whichever side
   *             allows more of the element to be visible will be used. </li>
   * <li><b>"fit"</b> shift the element away from the edge of the window. </li>
   * <li><b>"flipfit"</b> first applies the flip logic, placing the element
   *  on whichever side allows more of the element to be visible. Then the fit logic
   *  is applied to ensure as much of the element is visible as possible.</li>
   * <li><b>flipcenter</b> first applies the flip rule and follows with center alignment.</li>
   * <li><b>"none"</b> no collision detection.</li>
   * </ul>
   * @ojsignature [{target:"Type", value:"oj.ojPopup.PositionAlign", for:"my", jsdocOverride:true},
   *               {target:"Type", value:"oj.ojPopup.PositionAlign", for:"at", jsdocOverride:true},
   *               {target:"Type", value:"oj.ojPopup.PositionPoint", for:"offset", jsdocOverride:true},
   *               {target:"Type", value:"string|oj.ojPopup.PositionPoint", for:"of", jsdocOverride:true}]
   */

  /**
   * @ojcomponent oj.ojPopup
   * @augments oj.baseComponent
   *
   * @since 1.1.0
   * @ojdisplayname Popup
   * @ojshortdesc A popup temporarily 'pops up' content in the foreground.
   * @ojrole tooltip
   * @ojrole dialog
   * @ojrole alertdialog
   *
   * @ojpropertylayout {propertyGroup: "common", items: ["initalFocus", "modality", "autoDismiss", "tail",
   *                                                     "position.at.horizontal", "position.at.vertical",
   *                                                     "position.collision", "position.my.horizontal",
   *                                                     "position.my.vertical", "position.of",
   *                                                     "position.offset.x", "position.offset.y", "style"]}
   * @ojvbdefaultcolumns 2
   * @ojvbmincolumns 1
   *
   * @ojuxspecs ['popup']
   *
   * @classdesc
   * <h3 id="popupOverview-section">
   *   JET Popup Component
   *  <a class="bookmarkable-link" title="Bookmarkable Link" href="#popupOverview-section"></a></h3>
   *
   * <p>Description: Themeable, WAI-ARIA-compliant popup that can display arbitrary content.</p>
   *
   * <p>A JET popup can be created from custom element
   * <code class="prettyprint">&lt;oj-popup&gt;</code> syntax. This element will become the
   * root - outer chrome of the popup.  The content of the popup will be relocated under an
   * element marked with the <code class="prettyprint">.oj-popup-content</code> selector.
   * Dynamic content can be inserted under the element identified by the
   * <code class="prettyprint">.oj-popup-content</code> selector.  However, page developers
   * are encouraged to create their own content element to anchor dynamic content changes
   * versus using <code class="prettyprint">.oj-popup-content</code> as the marker selector.</p>
   *
   * <pre class="prettyprint">
   * <code>&lt;oj-popup id="popup"&gt;
   *   &lt;span class="mycontent"&gt;
   *     Hello World!
   *   &lt;/span class="mycontent"&gt;
   * &lt;/oj-popup&gt;
   * </code></pre>
   *
   * <p>The following is an example of dynamically changing the content of the popup defined above.
   * </p>
   *
   * <pre class="prettyprint">
   * <code>var content = popup.querySelector( ".mycontent" );
   * content.textContent = "Hello Universe!";
   * </code></pre>
   *
   * <h3 id="touch-section">
   *   Touch End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"touchDoc"}
   *
   * <h3 id="keyboard-section">
   *   Keyboard End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"keyboardDoc"}
   *
   * <br/><br/>
   *
   * <h3 id="accessibility-section">
   *   Accessibility
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#accessibility-section"></a>
   * </h3>
   *
   * <p>For WAI-ARIA compliance, JET automatically adds
   * <code class="prettyprint">role="tooltip"</code> to the root popup dom element if not
   * already specificed. This is not a component property but rather the standard html
   * <a href="https://www.w3.org/WAI/PF/aria/roles">role</a> attribute. Depending on how the
   * popup is used in the page, the page developer should choose from the following:
   * <ul>
   *   <li>"tooltip" defines contextual popup that displays a description for an element.</li>
   *   <li>"dialog" defines an application window that is designed to interrupt the current
   *       processing of an application in order to prompt the user to enter information or
   *       require a response.</li>
   *   <li>"alertdialog" defines type of dialog that contains an alert message, where initial focus
   *       goes to an element within the dialog.</li>
   * </ul>
   * The popup also adds the <code class="prettyprint">aria-describedby="popup-id"</code> attribute
   * to the assocaited launcher while the popup is open.
   * </p>
   *
   * On platforms that support voice over mode (VO), the popup injects anchor tags "skip links"
   * into the document for navigation. Skip links are not visible but read in VO mode.
   * Two skip links are injected into the document when a popup is disclosed:
   *  <ul>
   *    <li>A close link, {@link oj.ojPopup#translations.ariaCloseSkipLink}, is injected as a
   *        sibling to the popup's content. Activation of this link will close the popup.</li>
   *    <li>For cases where the popup doesn't steal focus when it's open, a content navigation
   *        skip link, {@link oj.ojPopup#translations.ariaFocusSkipLink}, is injected as a
   *        sibling to the launcher (first required argument of the open method). If the launcher
   *        selector targets a sub-element of the launcher, the skip link could be injected under
   *        the launcher, which can be problematic for oj-button as skip link activation will
   *        also activate the associated launcher.</li>
   *  </ul>
   *
   * <p>One point often overlooked is making the gestures that launch a popup accessible.
   *   There are no constraints to what events a page developer might choose to trigger opening a
   *   popup.  The choice should be accessible for screen reader users.  Page
   *   developers should take care when using mouse events to trigger opening of a popup.
   *   This is especially important if the content of the popup can't be derived from other
   *   visible areas on the page. In cases that mouseover, mouseout, mouseenter, mouseleave and
   *   hover events are used to launch popups, there needs to be a keyboard functional equivalency.
   * </p>
   *
   * <p>See also the <a href="#styling-section">oj-focus-highlight</a> discussion.
   *
   * <h3 id="reparenting-section">
   *   Reparenting
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#reparenting-section"></a>
   * </h3>
   *
   *  <p id="reparenting-strategy">
   *     When popups are open, they will be reparented in the document and reparented back when
   *     closed. When open, the location of the popup within the document will be in context of
   *     how it's used. Popups open from other popups will be relocated in the document into the
   *     nearest parent popup's layer. The popups layer defines its z-index weight "stacking
   *     context".  The ojPopup's layer is marked with the "oj-popup-layer" style.
   *     The context of opening is defined by the launcher argument passed to the open method.  If
   *     not open from another popup, the popup will be reparented to a container in the document
   *     body. Popups of the same type are assigned the same z-index values.  The layering between
   *     peer popups reflect the opening order. The popup that has active focus will be assigned a
   *     greater z-index value. This is applied to the popup's layer by way of the "oj-focus-within"
   *     pseudo selector applied with "oj-popup-layer" selector. The page author has control over
   *     z-index weights by way of the "oj-popup-layer" selector.
   *  </p>
   *  <p>
   *     There are known caveats with this design. However, these scenarios are considered "bad use"
   *     based on our JET popup strategy.
   *  </p>
   *  <ol>
   *    <li>Events raised within the popup will not bubble up to the popup's original ancestors.
   *        Instead, listeners for popup events should be applied to either the popup's root
   *        element, or the document.</li>
   *    <li>Likewise, developers should not use CSS descendant selectors, or similar logic, that
   *        assumes that the popup will remain a child of its original parent.</li>
   *    <li>Popups containing iframes are problematic.  The iframe elements "may" fire a HTTP GET
   *        request for its src attribute each time the iframe is reparented in the document.</li>
   *    <li>If an iframe is added to the popup's content, it must not be the first or last tab stop
   *        within the popup or keyboard and VoiceOver navigation will not remain within the popup.</li>
   *    <li>In some browsers, reparenting a popup that contains elements having overflow, will cause
   *        these overflow elements to reset their scrollTop.</li>
   *  </ol>
   *
   * <h3 id="eventHandling-section">
   *   Event Handling
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#eventHandling-section"></a>
   * </h3>
   * <ul>
   *  <li>ojBeforeClose(event) - Triggered before a popup closes. Event can prevent closing the
   *      popup; However, there are cases the framework must veto, such as when the popup is
   *      destroyed.</li>
   *  <li>ojBeforeOpen(event) - Triggered before a popup opens. Event can prevent opening the
   *      popup.</li>
   *  <li>ojClose(event) - Triggered after the popup has closed.</li>
   *  <li>ojFocus(event) - Triggered when initial focus is established on opening, depending on
   *      the value of the initalFocus property, or <kbd>F6</kbd> focus toggle from the associated
   *      launcher.</li>
   *  <li>ojOpen(event) - Triggered after the popup has been made visible.</li>
   * </ul>
   */
  // --------------------------------------------------- oj.ojPopup Styling Start -----------------------------------------------------------
  // ---------------- oj-focus-highlight --------------

  /**
  * Under normal circumstances this class is applied automatically.
  * It is documented here for the rare cases that an app developer needs per-instance control.<br/><br/>
  * The oj-focus-highlight class applies focus styling that may not be desirable when the focus results from pointer interaction (touch or mouse), but which is needed for accessibility when the focus occurs by a non-pointer mechanism, for example keyboard or initial page load.<br/><br/>
  * The application-level behavior for this component is controlled in the theme by the <code class="prettyprint"><span class="pln">$focusHighlightPolicy </span></code>SASS variable; however, note that this same variable controls the focus highlight policy of many components and patterns. The values for the variable are:<br/><br/>
  * <code class="prettyprint"><span class="pln">nonPointer: </span></code>oj-focus-highlight is applied only when focus is not the result of pointer interaction. Most themes default to this value.<br/>
  * <code class="prettyprint"><span class="pln">all: </span></code> oj-focus-highlight is applied regardless of the focus mechanism.<br/>
  * <code class="prettyprint"><span class="pln">none: </span></code> oj-focus-highlight is never applied. This behavior is not accessible, and is intended for use when the application wishes to use its own event listener to precisely control when the class is applied (see below). The application must ensure the accessibility of the result.<br/><br/>
  * To change the behavior on a per-instance basis, the application can set the SASS variable as desired and then use event listeners to toggle this class as needed.<br/>
  * @ojstyleclass oj-focus-highlight
  * @ojdisplayname Focus Styling
  * @ojshortdesc Allows per-instance control of the focus highlight policy (not typically required). See the Help documentation for more information.
  * @memberof oj.ojPopup
  * @ojtsexample
  * &lt;oj-popup class="oj-focus-highlight">
  *   &lt;!-- Content -->
  * &lt;/oj-popup>
  */
  // --------------------------------------------------- oj.ojPopup Styling end -----------------------------------------------------------

  oj.__registerWidget('oj.ojPopup', $.oj.baseComponent, {
    widgetEventPrefix: 'oj',
    options: {
      /**
       *
       * @private
       * @memberof oj.ojPopup
       * @instance
       */
      animation: null,

      /**
       * Defines conditions that will cause an open popup to auto close dismiss.  A value of
       * <code class="prettyprint">focusLoss</code> defines the dismissal condition where focus
       * has left the content of the popup or from the associated launcher or if what the popup
       * is aligned to is not fully visible within an overflow area.
       *
       * @expose
       * @memberof oj.ojPopup
       * @ojshortdesc Specifies the auto dismissal behavior.
       * @instance
       * @type {string}
       * @default 'focusLoss'
       * @ojvalue {string} "none" disables auto dismissal behaviors.
       * @ojvalue {string} "focusLoss" defines auto dismissal behavior when focus leaves the
       *   content of the popup or associated launcher.  In addition, if what the popup is
       *   positioned to is not visible within an overflow area, the popup will auto close
       *   dismiss.
       *
       * @example <caption>Initialize the popup with
       *          <code class="prettyprint">auto-dismiss</code> attribute specified:</caption>
       * &lt;oj-popup auto-dismiss="focusLoss" &gt;&lt;/oj-popup&gt;
       *
       * @example <caption>Get or set the <code class="prettyprint">autoDismiss</code> property,
       *          after initialization:</caption>
       * // getter
       * var autoDismiss = myPopup.autoDismiss;
       * // setter
       * myPopup.autoDismiss = "none";
       */
      autoDismiss: 'focusLoss',

      /**
       * Defines the presence of border, shadow and background color of the root popup dom.
       * Value of <code class="prettyprint">none</code> applies the
       * <code class="prettyprint">oj-popup-no-chrome</code> selector defined by the active
       * theme to the root dom of the popup to remove the default chrome.
       *
       * @expose
       * @memberof oj.ojPopup
       * @ojshortdesc Specifies whether to use the border, shadow, and background colors from the active theme.
       * @instance
       * @type {string}
       * @default 'default'
       * @ojvalue {string} "default" describes the popups border, shadow, and background color
       *           defined by the active theme.
       * @ojvalue {string} "none" turns off the outer chrome defined by the active theme.
       *
       * @example <caption>Initialize the popup with <code class="prettyprint">chrome</code>
       *          attribute specified:</caption>
       * &lt;oj-popup chrome="none" &gt;&lt;/oj-popup&gt;
       *
       * @example <caption>Get or set the <code class="prettyprint">chrome</code> property, after
       *          initialization:</caption>
       * // getter
       * var chrome = myPopup.chrome;
       *
       * // setter
       * myPopup.chrome = "none";
       */
      chrome: 'default',

      /**
       * Determines if the popup should steal focus to its content when initially open. A value
       * of <code class="prettyprint">none</code> prevents the popup from grabbing focus when
       * open.
       *
       * @expose
       * @memberof oj.ojPopup
       * @ojshortdesc Specifies whether the popup steals focus to its content when initially opened.
       * @instance
       * @type {string}
       * @default 'auto'
       * @ojvalue {string} "auto" is derived from the values of the modality and
       *          autoDismiss properties
       * @ojvalue {string} "none" prevents the popup from stealing focus when open.
       * @ojvalue {string} "firstFocusable" defines that a popup should grab focus to the first
       *          focusable element within the popup's content.
       * @ojvalue {string} "popup" focus to the root popup container (good choice for touch
       *          platforms).
       *
       * @example <caption>Initialize the popup with
       *           <code class="prettyprint">initial-focus</code> attribute specified:</caption>
       * &lt;oj-popup initial-focus="none" &gt;&lt;/oj-popup&gt;
       *
       * @example <caption>Get or set the <code class="prettyprint">initialFocus</code> property,
       *          after initialization:</caption>
       * // getter
       * var initialFocus = myPopup.initialFocus;
       *
       * // setter
       * myPopup.initialFocus = "none";
       */
      initialFocus: 'auto',

      /**
       * <p>Position property is used to establish the location the popup will appear relative to
       * another element. {@link oj.ojPopup.Position} defines "my" alignment "at" the alignment
       * "of" some other thing which can be "offset" by so many pixels.</p>
       *
       * <p>The "my" and "at" properties defines alignment points relative to the popup and other
       * element.  The "my" property represents the popups alignment where the "at" property
       * represents the other element that can be identified by "of" or defauts to the launcher
       * when the popup opens.  The values of these properties describe horizontal and
       * vertical alignments.</p>
       *
       * <b>Deprecated v3.0.0 jQuery UI position syntax; Use of a percent unit with
       * "my" or "at" is not supported.</b>
       *
       * @expose
       * @memberof oj.ojPopup
       * @instance
       * @type {Object}
       * @ojsignature { target: "Type",
       *                value: "oj.ojPopup.Position",
       *                jsdocOverride: true}
       * @name position
       * @ojshortdesc Specifies the position of a popup when launched. See the Help documentation for more information.
       * @example <caption>Initialize the popup with <code class="prettyprint">position</code>
       *           attribute specified:</caption>
       * &lt;oj-popup position.my.horizontal="left"
       *           position.my.vertical="top"
       *           position.at.horizontal="right"
       *           position.at.vertical="top" &gt;&lt;/oj-popup&gt;
       *
       * @example <caption>Get or set the <code class="prettyprint">position</code> property,
       *          after initialization:</caption>
       * // getter
       * var position = myPopup.position;
       *
       * // setter
       * myPopup.position =
       *    {"my": {"horizontal": "start", "vertical": "bottom"},
       *     "at": {"horizontal": "end", "vertical": "top" },
       *     "offset": {"x": 0, "y":5}};
       */
      position: {
        /**
         * Defines which edge on the popup to align with the target ("of") element.
         *
         * @expose
         * @memberof! oj.ojPopup
         * @instance
         * @alias position.my
         * @name position.my
         * @type {{horizontal:string, vertical:string}}
         */
        my: {
          /**
           * Defines the horizontal alignment of the popup.
           * @expose
           * @memberof! oj.ojPopup
           * @instance
           * @alias position.my.horizontal
           * @name position.my.horizontal
           * @type {string}
           * @default 'start'
           * @ojvalue {string} "start" evaluates to "left" in LTR mode and "right" in RTL mode.
           * @ojvalue {string} "end" evaluates to "right" in LTR mode and "left" in RTL mode.
           * @ojvalue {string} "left"
           * @ojvalue {string} "center"
           * @ojvalue {string} "right"
           */
          horizontal: 'start',

          /**
           * Defines the vertical alignment of the popup.
           * @expose
           * @memberof! oj.ojPopup
           * @instance
           * @alias position.my.vertical
           * @name position.my.vertical
           * @type {string}
           * @default 'top'
           * @ojvalue {string} "top"
           * @ojvalue {string} "center"
           * @ojvalue {string} "bottom"
           */
          vertical: 'top'
        },

        /**
         * Defines a point offset in pixels from the ("my") alignment.
         * @expose
         * @memberof! oj.ojPopup
         * @instance
         * @alias position.offset
         * @name position.offset
         * @type {{x:number, y:number}}
         */
        offset: {
          /**
           * Horizontal alignment offset.
           * @expose
           * @memberof! oj.ojPopup
           * @instance
           * @alias position.offset.x
           * @name position.offset.x
           * @type {number}
           * @default 0
           */
          x: 0,

          /**
           * Vertical alignment offset.
           * @expose
           * @memberof! oj.ojPopup
           * @instance
           * @alias position.offset.y
           * @name position.offset.y
           * @type {number}
           * @default 0
           */
          y: 0
        },

        /**
         * Defines which position on the target element ("of") to align the positioned element
         * against.
         *
         * @expose
         * @memberof! oj.ojPopup
         * @instance
         * @alias position.at
         * @name position.at
         * @type {{horizontal:string, vertical:string}}
         */
        at: {
          /**
           * Defines the horizontal alignment of what the popup is aligned to.
           * @expose
           * @memberof! oj.ojPopup
           * @instance
           * @alias position.at.horizontal
           * @name position.at.horizontal
           * @type {string}
           * @default 'start'
           * @ojvalue {string} "start" evaluates to "left" in LTR mode and "right" in RTL mode.
           * @ojvalue {string} "end" evaluates to "right" in LTR mode and "left" in RTL mode.
           * @ojvalue {string} "left"
           * @ojvalue {string} "center"
           * @ojvalue {string} "right"
           */
          horizontal: 'start',

          /**
           * Defines the vertical alignment of what the popup is aligned to.
           * @expose
           * @memberof! oj.ojPopup
           * @instance
           * @alias position.at.vertical
           * @name position.at.vertical
           * @type {string}
           * @default 'bottom'
           * @ojvalue {string} "top"
           * @ojvalue {string} "center"
           * @ojvalue {string} "bottom"
           */
          vertical: 'bottom'
        },

        /**
         * Which element to position the popup against.  The default is the
         * <code class="prettyprint">launcher</code> argument passed to the
         * <code class="prettyprint">open</code> method.
         *
         * If the value is a string, it should be a selector or the literal string value
         * of <code class="prettyprint">window</code>.  Otherwise, a point of x,y.  When a point
         * is used, the values are relative to the whole document.  Page horizontal and vertical
         * scroll offsets need to be factored into this point - see UIEvent
         * <a href="https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/pageX">pageX</a>,
         * <a href="https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/pageY">pageY</a>.
         *
         * @example <caption>Finding the point for an svg element:</caption>
         * var rect = svgDom.getBoundingClientRect();
         * var position = {of:{x:rect.left + window.pageXOffset, y:rect.top + window.pageYOffset}};
         *
         * @expose
         * @memberof! oj.ojPopup
         * @instance
         * @alias position.of
         * @name position.of
         * @ojshortdesc Which element to position the popup against. See the Help documentation for more information.
         * @type {string|{x: number, y: number}}
         */
        of: undefined,

        /**
         * Rule for alternate alignment.
         *
         * @expose
         * @memberof! oj.ojPopup
         * @instance
         * @alias position.collision
         * @name position.collision
         * @type {string}
         * @default 'flip'
         * @ojvalue {string} "flip" the element to the opposite side of the target and the
         *  collision detection is run again to see if it will fit. Whichever side
         *  allows more of the element to be visible will be used.
         * @ojvalue {string} "fit" shift the element away from the edge of the window.
         * @ojvalue {string} "flipfit" first applies the flip logic, placing the element
         *  on whichever side allows more of the element to be visible. Then the fit logic
         *  is applied to ensure as much of the element is visible as possible.
         * @ojvalue {string} "flipcenter" first applies the flip rule and follow with center
         *  alignment.
         * @ojvalue {string} "none" no collision detection.
         */
        collision: 'flip'
      },

      /**
       * Determines if a decoration will be displayed from the popup that points to the element
       * the popup is aligned to. The <code class="prettyprint">simple</code> value enables the
       * tail defined by the current theme.  In addtion, the
       * <code class="prettyprint">oj-popup-tail-simple</code> selector will be applied to the
       * root dom element.  This is to allow the box-shadow, z-index and other chrome styling to
       * vary per tail decoration.
       *
       * @expose
       * @memberof oj.ojPopup
       * @ojshortdesc Specifies whether to display a decoration pointing from the popup to the launching element. See the Help documentation for more information.
       * @instance
       * @type {string}
       * @default 'none'
       * @ojvalue {string} "none" no decoration will be displayed from the popup pointing to the
       *          launcher.
       * @ojvalue {string} "simple" enables showing the tail defined by the current theme.
       *
       * @example <caption>Initialize the popup with <code class="prettyprint">tail</code>
       *          attribute specified:</caption>
       * &lt;oj-popup tail="simple" &gt;&lt;/oj-popup&gt;
       *
       * @example <caption>Get or set the <code class="prettyprint">tail</code> property, after
       *          initialization:</caption>
       * // getter
       * var tail = myPopup.tail;
       *
       * // setter
       * myPopup.tail = "simple";
       */
      tail: 'none',

      /**
       * Determines if the popup should block user input of the page behind with a blocking
       * overlay pane.
       *
       * <p>The default modality varies by theme.  Each theme can set its default by setting
       * <code class="prettyprint">$popupModalityOptionDefault</code>.
       *
       * @expose
       * @memberof oj.ojPopup
       * @ojshortdesc Specifies whether the popup should block user input to the page.
       * @instance
       * The modality of the popup. Valid values are:
       * @ojvalue {string} "modeless" defines a modeless popup.
       * @ojvalue {string} "modal" The popup is modal. Interactions with other page elements are
       *          disabled. Modal popups overlay other page elements.
       * @type {string}
       * @default 'modeless'
       * @example <caption>Initialize the popup to have modality
       *          <code class="prettyprint">modality</code></caption>
       * &lt;oj-popup modality="modal" &gt;&lt;/oj-popup&gt;
       *
       * @example <caption>Get or set the <code class="prettyprint">modality</code> property,
       *          after initialization:</caption>
       * // getter
       * var modality = myPopup.modality;
       *
       * // setter
       * myPopup.modality = "modal";
       *
       * @example <caption>Set the default in the theme (SCSS) :</caption>
       * $popupModalityOptionDefault: modal !default;
       */
      modality: 'modeless',

      /**
       * @private
       * @memberof oj.ojPopup
       * @instance
       * @type {string}
       */
      role: 'tooltip',
      // Events

      /**
       * Triggered before the popup is launched via the <code class="prettyprint">open()</code>
       * method. The open can be cancelled by calling
       * <code class="prettyprint">event.preventDefault()</code>.
       *
       * @expose
       * @event
       * @memberof oj.ojPopup
       * @ojshortdesc Triggered before the popup is launched.
       * @instance
       * @ojcancelable
       * @ojbubbles
       */
      beforeOpen: null,

      /**
       * Triggered after the popup is launched via the <code class="prettyprint">open()</code>
       * method.
       *
       * @expose
       * @event
       * @memberof oj.ojPopup
       * @ojshortdesc Triggered after the popup is launched.
       * @instance
       * @ojbubbles
       */
      open: null,

      /**
       * Triggered before the popup is dismissed via the
       * <code class="prettyprint">close()</code> method. The close can be cancelled by calling
       * <code class="prettyprint">event.preventDefault()</code>.
       *
       * @expose
       * @event
       * @memberof oj.ojPopup
       * @ojshortdesc Triggered before the popup is dismissed.
       * @instance
       * @ojcancelable
       * @ojbubbles
       */
      beforeClose: null,

      /**
       * Triggered after the popup is dismissed via the
       * <code class="prettyprint">close()</code> method.
       *
       * @expose
       * @event
       * @memberof oj.ojPopup
       * @ojshortdesc Triggered after the popup is dismissed.
       * @instance
       * @ojbubbles
       */
      close: null,

      /**
       * Triggered after focus has been transferred to the popup. This will occur after the
       * <code class="prettyprint">open()</code> method is called, depending on the value
       * of the <code class="prettyprint">initialFocus</code> property.  It's also triggered
       * when using the <kbd>F6</kbd> key to toggle focus from the associated launcher element
       * to the content of the popup.
       *
       * @expose
       * @event
       * @memberof oj.ojPopup
       * @ojshortdesc Triggered after focus has been transferred to the popup.
       * @instance
       * @ojbubbles
       */
      focus: null,

      /**
       * Triggered when a default animation is about to start, such as when the component is
       * being opened/closed or a child item is being added/removed. The default animation can
       * be cancelled by calling <code class="prettyprint">event.preventDefault</code>.
       *
       * @expose
       * @event
       * @memberof oj.ojPopup
       * @ojshortdesc Triggered when a default animation is about to start, such as when the component is being opened/closed or a child item is being added/removed.
       * @instance
       * @ojcancelable
       * @ojbubbles
       * @property {"open"|"close"} action The action that triggers the animation.<br><br>
       *            The number of actions can vary from component to component.
       *            Suggested values are:
       *                    <ul>
       *                      <li>"open" - when a popup component is opened</li>
       *                      <li>"close" - when a popup component is closed</li>
       *                    </ul>
       * @property {!Element} element target of animation
       * @property {!function():void} endCallback If the event listener calls
       *            event.preventDefault to cancel the default animation, It must call the
       *            endCallback function when it finishes its own animation handling and any
       *            custom animation has ended.
       *
       * @example <caption>Add a listener for the
       *          <code class="prettyprint">ojAnimateStart</code> event to override the default
       *          "close" animation:</caption>
       * myPopup.addEventListener("ojAnimateStart", function( event )
       *   {
       *     // verify that the component firing the event is a component of interest and action
       *      is close
       *     if (event.detail.action == "close") {
       *       event.preventDefault();
       *       oj.AnimationUtils.slideOut(event.detail.element).then(event.detail.endCallback);
       *   });
       *
       * @example <caption>The default open and close animations are controlled via the theme
       *          (SCSS) :</caption>
       * $popupOpenAnimation: ((effect: "zoomIn"), "fadeIn")  !default;
       * $popupCloseAnimation: ((effect: "zoomOut"), "fadeOut")  !default;
       */
      animateStart: null,

      /**
       * Triggered when a default animation has ended, such as when the component is being
       * opened/closed or a child item is being added/removed. This event is not triggered if
       * the application has called preventDefault on the animateStart
       * event.
       *
       * @expose
       * @event
       * @memberof oj.ojPopup
       * @ojshortdesc Triggered when a default animation had ended, such as when the component is being opened/closed or a child item is being added/removed.
       * @instance
       * @ojcancelable
       * @ojbubbles
       * @property {!Element} element target of animation
       * @property {"open"|"close"} action The action that triggered the animation.<br><br>
       *                   The number of actions can vary from component to component.
       *                   Suggested values are:
       *                    <ul>
       *                      <li>"open" - when a popup component is opened</li>
       *                      <li>"close" - when a popup component is closed</li>
       *                    </ul>
       *
       * @example <caption>Add a listener for the
       *          <code class="prettyprint">ojAnimateEnd</code> event to listen for the "close"
       *          ending animation:</caption>
       * myPopup.addEventListener("ojAnimateEnd", function( event )
       *   {
       *     // verify that the component firing the event is a component of interest and action
       *      is close
       *     if (event.detail.action == "close") {}
       *   });
       *
       * @example <caption>The default open and close animations are controlled via the theme
       *          (SCSS) :</caption>
       * $popupOpenAnimation: (effect: "zoomIn", fade: true)  !default;
       * $popupCloseAnimation: (effect: "zoomOut", fade: true)  !default;
       */
      animateEnd: null
    },

    /**
     * @memberof oj.ojPopup
     * @instance
     * @protected
     * @override
     */
    _ComponentCreate: function _ComponentCreate() {
      this._super();

      var rootStyle = this._getRootStyle();

      var element = this.element;
      element.hide().addClass(rootStyle).attr('aria-hidden', 'true');
      element.addClass('oj-component'); // Creates a content element and moves the children of the root to the content element
      // and then appends the content element to the root element.

      var content = $('<div>');
      content.addClass([rootStyle, 'content'].join('-'));
      content.attr('role', 'presentation');
      content.append(element[0].childNodes); // @HTMLUpdateOK move app defined children to content wrapper

      content.appendTo(element); // @HTMLUpdateOK attach programmaticly generated node

      this._content = content;

      this._setChrome();

      this._setupFocus(element); // fixup the position option set via the widget constructor


      var options = this.options;
      options.position = oj.PositionUtils.coerceToJet(options.position);
    },

    /**
     * @memberof oj.ojPopup
     * @instance
     * @protected
     * @override
     */
    _AfterCreate: function _AfterCreate() {
      // first apply rootAttributes that might define an id if unspecified
      this._super(); // aria-describedby needs an id.  Assign an id to the popup root if not already defined.


      this.element.uniqueId(); // create the tail with a subid

      this._createTail();
    },

    /**
     * @memberof oj.ojPopup
     * @instance
     * @protected
     * @override
     */
    _destroy: function _destroy() {
      if (oj.ZOrderUtils.getStatus(this.element) === oj.ZOrderUtils.STATUS.OPEN) {
        this._closeImplicitly();
      }

      this._setWhenReady('none');

      this._destroyTail();

      delete this._popupServiceEvents; // make sure the root element is hidden

      var element = this.element;
      element.hide().attr('aria-hidden', 'true').removeUniqueId(); // Move the children back under the root node removing the content node.

      var content = this._content;
      delete this._content;
      element.append(content[0].childNodes); // @HTMLUpdateOK destructor move children back under root

      content.remove();
      var closeDelayTimer = this._closeDelayTimer;

      if (closeDelayTimer) {
        delete this._closeDelayTimer;
        closeDelayTimer();
      }

      this._super();
    },

    /**
     * Opens the popup. This method accepts two arguments. The first argument "launcher" is
     * required but the second "position" is optional.
     *
     * @expose
     * @method
     * @name oj.ojPopup#open
     * @ojshortdesc Opens the popup.
     * @memberof oj.ojPopup
     * @instance
     * @param {!(string|Element)} launcher selector or dom element that is associated with the
     *        popup. Defines the context of how the popup is used. The argument is required.
     * @param {Object=} position {@link oj.ojPopup.Position} an element relative to another
     * @return {void}
     * @ojsignature { target: "Type",
     *                value: "oj.ojPopup.Position",
     *                for: "position",
     *                jsdocOverride: true}
     * @fires oj.ojPopup#ojBeforeOpen
     * @fires oj.ojPopup#ojAnimationStart
     * @fires oj.ojPopup#ojAnimationEnd
     * @fires oj.ojPopup#ojOpen
     *
     * @example <caption>Invoke the <code class="prettyprint">open</code> method:</caption>
     * var open = myPopup.open("#launcher");
     */
    open: function open(launcher, position) {
      if (this._isOperationPending('open', [launcher, position])) {
        return;
      }

      if (oj.ZOrderUtils.getStatus(this.element) === oj.ZOrderUtils.STATUS.OPEN) {
        this._closeImplicitly(); // synchronous close

      }

      var element = this.element;
      var status = oj.ZOrderUtils.getStatus(element);

      if (!(status === oj.ZOrderUtils.STATUS.CLOSE || status === oj.ZOrderUtils.STATUS.UNKNOWN)) {
        return;
      } // status change is needed to prevent calling open from an on before open
      // handler.  The _isOperationPending doens't gurard until this._setWhenReady('open');


      oj.ZOrderUtils.setStatus(element, oj.ZOrderUtils.STATUS.BEFORE_OPEN);

      if (this._trigger('beforeOpen') === false) {
        oj.ZOrderUtils.setStatus(this.element, status);
        return;
      } // activates the _isOperationPending gatekeeper


      this._setWhenReady('open');

      this._setLauncher(launcher);

      var _launcher = this._launcher;
      var options = this.options; // eslint-disable-next-line no-param-reassign

      position = position || options.position;

      if (!position.of) {
        this._hasPositionOfLauncherOverride = true; // eslint-disable-next-line no-param-reassign

        position.of = _launcher;
      }

      this._setPosition(position);

      this._setAutoDismiss(options.autoDismiss);

      this._addDescribedBy();

      if (!this._IsCustomElement() || !element[0].hasAttribute('role')) {
        element.attr('role', options.role);
      } // convert to the jquery ui position format


      var _position = this._getPositionAsJqUi(); // build layer class selectors applied to the popup layer


      var rootStyle = this._getRootStyle();

      var layerClass = [rootStyle, 'layer'].join('-');
      var tailDecoration = options.tail;

      if (tailDecoration !== 'none') {
        layerClass += ' ' + [rootStyle, 'tail', tailDecoration].join('-');
      }
      /** @type {!Object.<oj.PopupService.OPTION, ?>} */


      var psOptions = {};
      psOptions[oj.PopupService.OPTION.POPUP] = element;
      psOptions[oj.PopupService.OPTION.LAUNCHER] = _launcher;
      psOptions[oj.PopupService.OPTION.POSITION] = _position;
      psOptions[oj.PopupService.OPTION.EVENTS] = this._getPopupServiceEvents();
      psOptions[oj.PopupService.OPTION.LAYER_SELECTORS] = layerClass;
      psOptions[oj.PopupService.OPTION.MODALITY] = options.modality;
      psOptions[oj.PopupService.OPTION.CUSTOM_ELEMENT] = this._IsCustomElement();
      oj.PopupService.getInstance().open(psOptions);
    },

    /**
     * Before open callback is called after the popup has been reparented into the
     * zorder container. Open animation is performed here.
     * @memberof oj.ojPopup
     * @instance
     * @private
     * @param {!Object.<oj.PopupService.OPTION, ?>} psOptions property bag for opening the popup
     * @return {Promise|void}
     */
    _beforeOpenHandler: function _beforeOpenHandler(psOptions) {
      var element = psOptions[oj.PopupService.OPTION.POPUP];
      var position = psOptions[oj.PopupService.OPTION.POSITION];
      element.show();
      element.position(position); // TODO might want to add fadeIn for the modal overlay in the future.

      var animationOptions = this.options.animation;

      if (animationOptions && animationOptions.open) {
        var actionPrefix = animationOptions.actionPrefix;
        var action = actionPrefix ? [actionPrefix, 'open'].join('-') : 'open'; // eslint-disable-next-line no-undef

        return AnimationUtils.startAnimation(element[0], action, oj.PositionUtils.addTransformOriginAnimationEffectsOption(element, animationOptions.open), this);
      }

      return undefined;
    },

    /**
     * Called after the popup is shown. Perform open finalization.
     * @memberof oj.ojPopup
     * @instance
     * @private
     * @param {!Object.<oj.PopupService.OPTION, ?>} psOptions property bag for opening the popup
     * @return {void}
     */
    _afterOpenHandler: function _afterOpenHandler(psOptions) {
      var element = psOptions[oj.PopupService.OPTION.POPUP];
      var launcher = psOptions[oj.PopupService.OPTION.LAUNCHER];

      this._initVoiceOverAssist();

      this._trigger('open');

      this._intialFocus();

      this._on(element, {
        keydown: this._keyHandler
      });

      if (launcher && launcher.length > 0) {
        this._on(launcher, {
          keydown: this._keyHandler
        });
      }
    },

    /**
     * Override to retrieve the context menu element from the context area of the popup
     * versus the root.
     * @memberof oj.ojPopup
     * @instance
     * @protected
     * @override
     */
    _GetContextMenu: function _GetContextMenu() {
      if (this._IsCustomElement()) {
        var slotMap = oj.BaseCustomElementBridge.getSlotMap(this._content[0]);
        var slot = slotMap.contextMenu;

        if (slot && slot.length > 0) {
          return slot[0];
        }
      } else {
        return this._super();
      }

      return undefined;
    },

    /**
     * Closes the popup. This method does not accept any arguments.
     *
     * @expose
     * @method
     * @name oj.ojPopup#close
     * @ojshortdesc Closes the popup.
     * @memberof oj.ojPopup
     * @instance
     * @return {void}
     * @fires oj.ojPopup#ojBeforeClose
     * @fires oj.ojPopup#ojAnimationStart
     * @fires oj.ojPopup#ojAnimationEnd
     * @fires oj.ojPopup#ojClose
     *
     * @example <caption>Invoke the <code class="prettyprint">close</code> method:</caption>
     * myPopup.close();
     */
    close: function close() {
      if (this._isOperationPending('close', [])) {
        return;
      }

      var element = this.element;
      var status = oj.ZOrderUtils.getStatus(element);

      if (status !== oj.ZOrderUtils.STATUS.OPEN) {
        return;
      } // Status toggle is needed to prevent a recursive closed callled from a
      // beforeClose handler. The _isOperationPending gatekeeper isn't activated
      // until after the _setWhenReady('close'|'open') call.


      oj.ZOrderUtils.setStatus(element, oj.ZOrderUtils.STATUS.BEFORE_CLOSE);

      if (this._trigger('beforeClose') === false && !this._ignoreBeforeCloseResultant) {
        oj.ZOrderUtils.setStatus(element, status);
        return;
      } // activates the _isOperationPending gatekeeper


      this._setWhenReady('close');

      var launcher = this._launcher;

      this._off(element, 'keydown');

      if (launcher && launcher.length > 0) {
        this._off(launcher, 'keydown');
      } // if the content has focus, restore the the launcher


      this._restoreFocus(); // clean up voice over assist


      this._destroyVoiceOverAssist();
      /** @type {!Object.<oj.PopupService.OPTION, ?>} */


      var psOptions = {};
      psOptions[oj.PopupService.OPTION.POPUP] = element;
      oj.PopupService.getInstance().close(psOptions);
    },

    /**
     * Before callback is invoked while the popup is still visible and still parented in the
     * zorder container. Close animation is performed here.
     * @memberof oj.ojPopup
     * @instance
     * @private
     * @param {!Object.<oj.PopupService.OPTION, ?>} psOptions property bag for closing the popup
     * @return {Promise|void}
     */
    _beforeCloseHandler: function _beforeCloseHandler(psOptions) {
      var element = psOptions[oj.PopupService.OPTION.POPUP]; // TODO might want to add fadeOut for the modal overlay in the future.

      var animationOptions = this.options.animation;

      if (!this._ignoreBeforeCloseResultant && animationOptions && animationOptions.close) {
        var actionPrefix = animationOptions.actionPrefix;
        var action = actionPrefix ? [actionPrefix, 'close'].join('-') : 'close';
        /** @type {?} */
        // eslint-disable-next-line no-undef

        var promise = AnimationUtils.startAnimation(element[0], action, oj.PositionUtils.addTransformOriginAnimationEffectsOption(element, animationOptions.close), this).then(function () {
          element.hide();
        });
        return promise;
      }

      element.hide();
      return undefined;
    },

    /**
     * Close finalization callback.
     *
     * @memberof oj.ojPopup
     * @instance
     * @private
     * @param {!Object.<oj.PopupService.OPTION, ?>} psOptions property bag for closing the popup
     * @return {void}
     */
    // eslint-disable-next-line no-unused-vars
    _afterCloseHandler: function _afterCloseHandler(psOptions) {
      this._removeDescribedBy();

      this._setAutoDismiss();

      delete this._launcher;

      this._trigger('close');

      if (this._hasPositionOfLauncherOverride) {
        var options = this.options;
        options.position.of = null;
        delete this._hasPositionOfLauncherOverride;
      }
    },

    /**
     * <p>Returns the state of whether the popup is currently open. This method does not accept
     * any arguments.</p>
     *
     * The "open" state reflects the period of time the popup is visible, including open and
     * close animations.
     *
     * @expose
     * @method
     * @name oj.ojPopup#isOpen
     * @ojshortdesc Returns the state of whether the popup is currently visible.
     * @memberof oj.ojPopup
     * @instance
     * @return {boolean} <code>true</code> if the popup is open.
     *
     * @example <caption>Invoke the <code class="prettyprint">isOpen</code> method:</caption>
     * var isOpen = myPopup.isOpen();
     */
    isOpen: function isOpen() {
      var status = oj.ZOrderUtils.getStatus(this.element); // the window is visible and reparented to the zorder container for these statuses

      return status === oj.ZOrderUtils.STATUS.OPENING || status === oj.ZOrderUtils.STATUS.OPEN || status === oj.ZOrderUtils.STATUS.BEFORE_CLOSE || status === oj.ZOrderUtils.STATUS.CLOSING;
    },

    /**
     * Causes the popup to reevaluate its position.  Call this function after
     * the content of the popup has dynamically changed while the popup is open.
     *
     * <p>This method does not accept any arguments.</p>
     *
     * @expose
     * @method
     * @name oj.ojPopup#refresh
     * @ojshortdesc Refreshes the popup, causing it to reevaluate its position.
     * @memberof oj.ojPopup
     * @instance
     * @return {void}
     *
     * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
     * myPopup.refresh();
     */
    refresh: function refresh() {
      this._super();

      if (oj.ZOrderUtils.getStatus(this.element) !== oj.ZOrderUtils.STATUS.OPEN) {
        return;
      }

      if (!this._reposition()) {
        return;
      } // trigger refresh of descendents if reposition was successful


      var element = this.element;
      oj.PopupService.getInstance().triggerOnDescendents(element, oj.PopupService.EVENT.POPUP_REFRESH);
    },

    /**
     * @memberof oj.ojPopup
     * @instance
     * @protected
     * @param {string} key option name
     * @param {?Object} value of the target option identified by the key
     * @override
     */
    _setOption: function _setOption(key, value) {
      var options = this.options;

      switch (key) {
        case 'tail':
          if (value !== options.tail) {
            this._setTail(value);
          }

          break;

        case 'chrome':
          if (value !== options.chrome) {
            this._setChrome(value);
          }

          break;

        case 'position':
          this._setPosition(value);

          this.refresh(); // don't call super because setPosition sets the option after creating a new
          // instance.  This prevents the same position instance from getting registered
          // with multiple component instances.

          return;

        case 'autoDismiss':
          if (oj.ZOrderUtils.getStatus(this.element) === oj.ZOrderUtils.STATUS.OPEN && value !== options.autoDismiss) {
            this._setAutoDismiss(value);
          }

          break;

        case 'modality':
          if (oj.ZOrderUtils.getStatus(this.element) === oj.ZOrderUtils.STATUS.OPEN) {
            var element = this.element;
            /** @type {!Object.<oj.PopupService.OPTION, ?>} */

            var psOptions = {};
            psOptions[oj.PopupService.OPTION.POPUP] = element;
            psOptions[oj.PopupService.OPTION.MODALITY] = value;
            oj.PopupService.getInstance().changeOptions(psOptions);
          }

          break;

        default:
          break;
      }

      this._superApply(arguments);
    },

    /**
     * Returns the root selector prefix for the popup components.  In the future if the popup is
     * subcassed, this method can be made protected and override to change the root selector names
     * for the target component.
     *
     * @memberof oj.ojPopup
     * @instance
     * @private
     * @return {string}
     */
    _getRootStyle: function _getRootStyle() {
      return 'oj-popup';
    },

    /**
     * Handles setting up the target tail.
     *
     * @memberof oj.ojPopup
     * @instance
     * @private
     * @param {string} tail option value
     */
    _setTail: function _setTail(tail) {
      this._destroyTail();

      this._createTail(tail);

      this._reposition();
    },

    /**
     * @memberof oj.ojPopup
     * @instance
     * @private
     * @param {string} tail option value
     */
    _createTail: function _createTail(tail) {
      var tailDecoration = tail || this.options.tail;

      if (tailDecoration === 'none') {
        return;
      }

      var rootStyle = this._getRootStyle();

      var tailMarkerStyle = [rootStyle, 'tail'].join('-');
      var tailStyle = [tailMarkerStyle, tailDecoration].join('-');
      var tailDom = $('<div>').hide();
      tailDom.addClass(tailMarkerStyle).addClass(tailStyle);
      tailDom.attr('role', 'presentation'); // id over "marker style" due to nesting popups in popups

      this._tailId = tailDom.attr('id', this._getSubId('tail')).attr('id');
      var element = this.element;
      tailDom.appendTo(element); // @HTMLUpdateOK attach programmaticly generated node
      // tail "value" style is applied to the root dom for shadow and z-index adjustments

      element.addClass(tailStyle); // The tail can change the z-index of the layer that defines the stacking context
      // of the popup.  If the popup is open, update the layers class.

      if (oj.ZOrderUtils.getStatus(this.element) === oj.ZOrderUtils.STATUS.OPEN) {
        var layerClass = [rootStyle, 'layer'].join('-');
        layerClass += ' ' + tailStyle;
        /** @type {!Object.<oj.PopupService.OPTION, ?>} */

        var options = {};
        options[oj.PopupService.OPTION.POPUP] = element;
        options[oj.PopupService.OPTION.LAYER_SELECTORS] = layerClass;
        oj.PopupService.getInstance().changeOptions(options);
      }
    },

    /**
     * @memberof oj.ojPopup
     * @instance
     * @private
     * @return {jQuery}
     */
    _getTail: function _getTail() {
      var tailId = this._tailId;

      if (!tailId) {
        return null;
      }

      return $(document.getElementById(tailId));
    },

    /**
     * @memberof oj.ojPopup
     * @instance
     * @private
     */
    _destroyTail: function _destroyTail() {
      var tail = this._getTail();

      if (tail) {
        tail.remove();
      }

      delete this._tailId;
      var tailDecoration = this.options.tail;

      var rootStyle = this._getRootStyle();

      var tailStyle = [rootStyle, 'tail', tailDecoration].join('-');
      var element = this.element;
      element.removeClass(tailStyle); // if the popup is open, reseed the layer class removing the
      // tail style.

      if (oj.ZOrderUtils.getStatus(this.element) === oj.ZOrderUtils.STATUS.OPEN) {
        var layerClass = [rootStyle, 'layer'].join('-');
        /** @type {!Object.<oj.PopupService.OPTION, ?>} */

        var options = {};
        options[oj.PopupService.OPTION.POPUP] = element;
        options[oj.PopupService.OPTION.LAYER_SELECTORS] = layerClass;
        oj.PopupService.getInstance().changeOptions(options);
      }
    },

    /**
     * @memberof oj.ojPopup
     * @instance
     * @private
     * @param {string} chrome option value
     */
    _setChrome: function _setChrome(chrome) {
      var chromeDecoration = chrome || this.options.chrome;
      var noChromeStyle = [this._getRootStyle(), 'no-chrome'].join('-');
      var element = this.element;

      if (chromeDecoration === 'default' && element.hasClass(noChromeStyle)) {
        element.removeClass(noChromeStyle);
      } else if (chromeDecoration === 'none' && !element.hasClass(noChromeStyle)) {
        element.addClass(noChromeStyle);
      }
    },

    /**
     * @memberof oj.ojPopup
     * @instance
     * @private
     * @param {string|Node|jQuery|null} _launcher provided when the popup is open
     */
    _setLauncher: function _setLauncher(_launcher) {
      var launcher = _launcher;

      if (!launcher) {
        launcher = $(document.activeElement);
      } else if ($.type(launcher) === 'string') {
        // id jquery selector
        launcher = $(launcher);
      } else if (launcher.nodeType === 1) {
        // dom element
        launcher = $(launcher);
      } // if a jquery collection, select the first dom node not in the popups content


      if (launcher instanceof $ && launcher.length > 1) {
        var element = this.element;

        for (var i = 0; i < launcher.length; i++) {
          var target = launcher[0];

          if (!oj.DomUtils.isAncestorOrSelf(element[0], target)) {
            launcher = $(target);
            break;
          }
        }
      } else if (!(launcher instanceof $) || // object is not a jq
      launcher instanceof $ && launcher.length === 0) {
        // empty jq collection
        launcher = $(document.activeElement);
      }

      this._launcher = launcher;
    },

    /**
     * @memberof oj.ojPopup
     * @instance
     * @private
     * @param {?Object} position object set as an option or passed as an argument to the open
     *                  method.
     */
    _setPosition: function _setPosition(position) {
      var options = this.options; // new position extends the existing object
      // covert to jet internal position format

      if (position) {
        options.position = oj.PositionUtils.coerceToJet(position, options.position);
      }
    },

    /**
     * Returns a jQuery UI position object from the internal object.
     * @memberof oj.ojPopup
     * @instance
     * @private
     * @returns {Object}
     */
    _getPositionAsJqUi: function _getPositionAsJqUi() {
      var options = this.options;
      var position = oj.PositionUtils.coerceToJqUi(options.position);
      var isRtl = this._GetReadingDirection() === 'rtl';
      position = oj.PositionUtils.normalizeHorizontalAlignment(position, isRtl);
      var origUsing = position.using;
      origUsing = $.isFunction(origUsing) ? origUsing : null; // override with our proxy to handle positioning of the tail
      // overload the callback arguments forcing the original using as the first argument

      position.using = this._usingHandler.bind(this, origUsing);
      return position;
    },

    /**
     * Resolves a busy state blocking delayed call to implicitly close
     * @memberof oj.ojPopup
     * @instance
     * @private
     * @param {Function} busyStateResolver
     */
    _resolveBusyStateAndCloseImplicitly: function _resolveBusyStateAndCloseImplicitly(busyStateResolver) {
      busyStateResolver();
      delete this._closeDelayTimer;

      this._closeImplicitly();
    },

    /**
     * Cancels the delayed implicit closure.
     * @memberof oj.ojPopup
     * @instance
     * @private
     * @param {number} timer
     * @param {Function} busyStateResolver
     */
    _resolveBusyStateAndCancelDelayedClosure: function _resolveBusyStateAndCancelDelayedClosure(timer, busyStateResolver) {
      window.clearTimeout(timer);
      busyStateResolver();
    },

    /**
     * @memberof oj.ojPopup
     * @instance
     * @private
     * @param {Function} origUsing position using hander if already provided
     * @param {Object} pos "my" element associated with the position object
     * @param {Object} props directions as to where the element should be moved
     */
    _usingHandler: function _usingHandler(origUsing, pos, props) {
      var element = props.element.element; // do nothing if the position is the same

      if (pos.top === element.css('top') && pos.left === element.css('left')) {
        return;
      }

      var tail = this._getTail();

      if (!tail) {
        element.css(pos);
      } else {
        tail.hide();

        for (var i = 0; i < _TAIL_STYLES.length; i++) {
          tail.removeClass(_TAIL_STYLES[i]);
          element.removeClass(_TAIL_STYLES[i]);
        }

        tail.removeAttr('style'); // 
        // Check if "of" alignment is to a x,y versus a dom element.  The horizontal
        // rule returned from jquery UI position defaults to "left" or "right".  The height and
        // width of the target will be zero when the "of" is not a DOM element.
        // Use the position.my alignment rules over what jquery returns when aligned to a point.
        //
        // jQuery 3.1 made changes to the offset.  The basic refactor was to switch over to using
        // "Element.getBoundingClientRect()".  Part of this refactor will return a offset rect of
        // {top: 0, left: 0} for any element that doesn't have a bounding box
        // "Element.getClientRects()". Many types of SVG elements such as <g> fall into this
        // category.  The popup will appear in the top left of the browser.
        //

        if (props.target && props.target.height === 0 && props.target.width === 0) {
          var isRtl = this._GetReadingDirection() === 'rtl';
          var position = oj.PositionUtils.normalizeHorizontalAlignment(this.options.position, isRtl);
          var myrule = position.my;

          if (!oj.StringUtils.isEmptyOrUndefined(myrule)) {
            // If the original horizontal rule is center, use it; otherwise, use the calculated
            // hint. The left/right rules reflect the actual positioning but center is never
            // represented correctly aligned to a point even though the alignment is correct.
            var suggestedHrule = myrule.horizontal === 'center' ? myrule.horizontal : props.horizontal;
            var suggestedVrule = myrule.vertical === 'center' ? 'middle' : myrule.vertical; // eslint-disable-next-line no-param-reassign

            props.horizontal = suggestedHrule; // eslint-disable-next-line no-param-reassign

            props.vertical = suggestedVrule;
          }
        }

        var alignMnemonic = [props.horizontal, props.vertical].join('-');
        var tailStyle = _TAIL_ALIGN_RULES[alignMnemonic];
        tail.addClass(tailStyle);
        element.addClass(tailStyle);
        tail.show(); // adjust the vertical and horizontal positioning to account for the tail
        // so that the page developer doesn't have to factor that in

        var borderFactor = 2; // factor in a little extra so the borders overlap

        var tailHOffset;

        if (props.horizontal === 'left') {
          tailHOffset = tail.outerWidth();
          tailHOffset -= tailHOffset + oj.DomUtils.getCSSLengthAsInt(tail.css('left')); // eslint-disable-next-line no-param-reassign

          pos.left += tailHOffset - borderFactor;
        } else if (props.horizontal === 'right') {
          tailHOffset = tail.outerWidth();
          tailHOffset -= tailHOffset + oj.DomUtils.getCSSLengthAsInt(tail.css('right')); // eslint-disable-next-line no-param-reassign

          pos.left -= tailHOffset - borderFactor;
        }

        var tailVOffset; // tail adjustments when the offset of the image is not the total size of the image

        if (props.vertical === 'top') {
          tailVOffset = tail.outerHeight();
          tailVOffset -= tailVOffset + oj.DomUtils.getCSSLengthAsInt(tail.css(props.vertical)); // eslint-disable-next-line no-param-reassign

          pos.top += tailVOffset - borderFactor;
        } else if (props.vertical === 'bottom') {
          tailVOffset = tail.outerHeight();
          tailVOffset -= tailVOffset + oj.DomUtils.getCSSLengthAsInt(tail.css(props.vertical)); // eslint-disable-next-line no-param-reassign

          pos.top -= tailVOffset - borderFactor;
        }

        element.css(pos); // adjustments to the vertical or horizontal centering.  The 50% alignment is from
        // the edge of the tail versus the center of the image.  The tail can't be located
        // at "center, middle". In this case (dead center), horizintal center looks better
        // on small viewports (_TAIL_ALIGN_RULES["center-middle"] === 'oj-left oj-middle')

        if (props.horizontal === 'center' && props.vertical !== 'middle') {
          var rootWidth = element.width();
          var leftPercent = Math.round((rootWidth / 2 - tail.outerWidth() / 2) / rootWidth * 100);
          tail.css({
            left: leftPercent + '%'
          });
        } else if (props.vertical === 'middle') {
          var rootHeight = element.height();
          var topPercent = Math.round((rootHeight / 2 - tail.outerHeight() / 2) / rootHeight * 100);
          tail.css({
            top: topPercent + '%'
          });
        }
      }

      oj.PositionUtils.captureTransformOriginAnimationEffectsOption(element, props); // call on the original using regardless of the tail

      if (origUsing) {
        origUsing(pos, props);
      }

      var options = this.options; // The "origUsing" could alter the positon.  This check needs to be last.
      // When focusLoss auto dismissal is enabled, implicitly close the popup when the
      // position.of is clipped in an overflow container.

      if (options.autoDismiss === 'focusLoss') {
        if (oj.PositionUtils.isAligningPositionClipped(props)) {
          // Ignore focus back to what had focus before the popup was open. Focus
          // restore could fight scroll if the popup was closed due to the aligning
          // element being clipped.
          this._ignoreRestoreFocus = true; // operation needs to happen in the next stacking frame and guarded by a
          // busy state.

          var busyContext = Context.getContext(this.element[0]).getBusyContext();
          var bsOptions = {
            description: ["ojPopup identified by '", this.element.attr('id'), "' is pending implicit closure."].join('')
          };
          var resolver = busyContext.addBusyState(bsOptions);
          var delayTimer = window.setTimeout(this._resolveBusyStateAndCloseImplicitly // @HTMLUpdateOK
          .bind(this, resolver), 0);
          this._closeDelayTimer = this._resolveBusyStateAndCancelDelayedClosure.bind(this, delayTimer, resolver);
        }
      }
    },

    /**
     * @memberof oj.ojPopup
     * @instance
     * @private
     * @return {boolean} <code>false</code> if the position was skipped
     */
    _reposition: function _reposition() {
      var element = this.element;

      var position = this._getPositionAsJqUi(); // verify selector is valid; otherwise, skip the reposition


      if (oj.StringUtils.isString(position.of)) {
        var jqOf = $(position.of);

        if (jqOf.length === 0) {
          return false;
        }

        position.of = jqOf;
      }

      element.position(position);
      return true;
    },

    /**
     * @memberof oj.ojPopup
     * @instance
     * @private
     * @param {boolean=} waiAriaAssisted focus established via keyboard or voice over versus from
     *        open API
     */
    _intialFocus: function _intialFocus(waiAriaAssisted) {
      var initialFocus = this._deriveInitialFocus();

      if (waiAriaAssisted || initialFocus !== 'none') {
        var element = this.GetFocusElement();
        element.focus();

        this._trigger('focus');
      }
    },

    /**
     * Returns the current focusable element for this component which can be the root custom element
     * or an HTML element like an input or select.
     * @return {Element}
     * @memberof oj.ojPopup
     * @instance
     * @protected
     * @override
     */
    GetFocusElement: function GetFocusElement() {
      var activeElement = document.activeElement;

      if (activeElement && this._isFocusInPopup(activeElement)) {
        return activeElement;
      }

      var initialFocus = this._deriveInitialFocus();

      if (initialFocus === 'none') {
        initialFocus = 'popup';
      }

      var element;

      if (initialFocus === 'firstFocusable') {
        var content = this._content;
        var nodes = content.find(':focusable');

        for (var i = 0; i < nodes.length; i++) {
          if (oj.FocusUtils.isFocusable(nodes[i])) {
            element = $(nodes[i]);
            break;
          }
        }

        if (!element) {
          // nothing to set focus to, default to "popup"
          initialFocus = 'popup';
        }
      } // Establish focus to the root element of the popup.  It's not a natural focus stop


      if (initialFocus === 'popup') {
        var closeSkipLink = this._closeSkipLink;

        if (closeSkipLink) {
          element = closeSkipLink.getLink();
        } else {
          element = this.element;
          element.attr('tabindex', '-1');
        }
      }

      return element[0];
    },

    /**
     * @memberof oj.ojPopup
     * @private
     * @return {string} derives the target initialFocus option when the default is auto
     */
    _deriveInitialFocus: function _deriveInitialFocus() {
      var options = this.options;
      var initialFocus = options.initialFocus;

      if (initialFocus === 'auto') {
        var modality = options.modality;

        if (modality === 'modal') {
          if (oj.DomUtils.isTouchSupported()) {
            initialFocus = 'popup';
          } else {
            initialFocus = 'firstFocusable';
          }
        } else {
          initialFocus = 'none';
        }
      }

      return initialFocus;
    },

    /**
     * @memberof oj.ojPopup
     * @instance
     * @private
     * @param {Element} activeElement from the event being handled
     * @param {boolean!} includeChildren when true the focus test will include the scope of any
     *                   child popups.
     * @return {boolean} <code>true</code> if the active element is within the content of the
     *                   popup
     */
    _isFocusInPopup: function _isFocusInPopup(activeElement, includeChildren) {
      if (!activeElement) {
        // eslint-disable-next-line no-param-reassign
        activeElement = document.activeElement;
      } // added to avoid automation issues where an active element is not established


      if (!activeElement) {
        return false;
      }

      var element = this.element; // popups that are children are siblings to the parent popup within the
      // layer that defines the stacking context.

      if (includeChildren) {
        element = element.parent();
      }

      return oj.DomUtils.isAncestorOrSelf(element[0], activeElement);
    },

    /**
     * @memberof oj.ojPopup
     * @instance
     * @private
     * @param {Element} activeElement from the event being handled
     * @return {boolean} <code>true</code> if the active element the launcher or a decedent of the
     *         launcher
     */
    _isFocusInLauncher: function _isFocusInLauncher(activeElement) {
      if (!activeElement) {
        // eslint-disable-next-line no-param-reassign
        activeElement = document.activeElement;
      }

      var launcher = this._launcher;
      return oj.DomUtils.isAncestorOrSelf(launcher[0], activeElement);
    },

    /**
     * @memberof oj.ojPopup
     * @instance
     * @private
     */
    _restoreFocus: function _restoreFocus() {
      if (this._ignoreRestoreFocus) {
        delete this._ignoreRestoreFocus;
        return;
      } // extend the focus check to include popups that are children


      if (this._isFocusInPopup(null, true)) {
        var launcher = this._launcher;
        launcher.focus();
      }
    },

    /**
     * @memberof oj.ojPopup
     * @instance
     * @private
     * @param {jQuery.Event|Event} event keydown
     */
    _keyHandler: function _keyHandler(event) {
      if (event.isDefaultPrevented()) {
        return;
      }

      var content = this._content;
      var options;
      var launcher;
      /** @type {?} */

      var target = event.target;

      if (event.keyCode === $.ui.keyCode.ESCAPE && (this._isFocusInPopup(target) || this._isFocusInLauncher(target))) {
        event.preventDefault();
        this.close();
      } else if (event.keyCode === 117 || event.key === 'F6') {
        // F6 - toggle focus to launcher or popup
        // keyCode is deprecated and it's not supported on some browsers.
        if (this._isFocusInPopup(target)) {
          // If this is a modeless popup, toggle focus to the launcher;
          // otherwise, close the popup as we can't set focus under the
          // modal glass pane.
          options = this.options;

          if (options.modality === 'modeless') {
            event.preventDefault();
            launcher = this._launcher;
            launcher.focus();
          } else {
            this.close();
          }
        } else if (this._isFocusInLauncher(target)) {
          event.preventDefault();

          this._intialFocus(true);
        }
      } else if (event.keyCode === $.ui.keyCode.TAB && this._isFocusInPopup(target)) {
        // TAB within popup
        var nodes = content.find(':tabbable');

        if (nodes.length > 0) {
          var firstNode = nodes[0];
          var lastNode = nodes[nodes.length - 1];
          var element = this.element;

          if ((firstNode === target || element[0] === target) && event.shiftKey) {
            // tabbing backwards, cycle focus to last node
            event.preventDefault(); // If the first and last tab stops are the same,
            // force focus to the root popup dom.  This will
            // cause the blur to fire on any input components.
            // If we are back tabbing on the popup dom, jump to the
            // last tab stop.

            if (firstNode === lastNode && firstNode === target) {
              element.attr('tabindex', '-1');
              element.focus();
            } else {
              $(lastNode).focus(); // tabbing backwards, cycle focus to last node
            }
          } else if (lastNode === target && !event.shiftKey) {
            event.preventDefault(); // If the first and last tab stops are the same,
            // force focus to the root popup dom.  This will
            // cause the blur to fire on any input components.

            if (lastNode === firstNode) {
              element.attr('tabindex', '-1');
              element.focus();
            } else {
              $(firstNode).focus(); // tabbing forwards, cycle to the first node
            }
          }
        } else {
          event.preventDefault();
          options = this.options;

          if (options.modality === 'modeless') {
            // if there is nothing in the popup that is tabbable, handle as a F6
            // toggle to the launcher
            launcher = this._launcher;
            launcher.focus();
          } else {
            // Modal popup can't set focus to something under the overlay,
            // implicitly close.
            this.close();
          }
        }
      }
    },

    /**
     * @memberof oj.ojPopup
     * @instance
     * @private
     * @param {string|null} autoDismiss option value
     */
    _setAutoDismiss: function _setAutoDismiss(autoDismiss) {
      // unregister any existing handlers, might need to add mouseOut in the future
      var focusLossCallback = this._focusLossCallback;

      var events = this._getPopupServiceEvents();

      if (focusLossCallback) {
        delete events[oj.PopupService.EVENT.POPUP_AUTODISMISS];
        delete this._focusLossCallback;
      }

      if (autoDismiss === 'focusLoss') {
        focusLossCallback = this._dismissalHandler.bind(this);
        this._focusLossCallback = focusLossCallback;
        events[oj.PopupService.EVENT.POPUP_AUTODISMISS] = focusLossCallback;
      }

      if (oj.ZOrderUtils.getStatus(this.element) === oj.ZOrderUtils.STATUS.OPEN) {
        var element = this.element;
        /** @type {!Object.<oj.PopupService.OPTION, ?>} */

        var options = {};
        options[oj.PopupService.OPTION.POPUP] = element;
        options[oj.PopupService.OPTION.EVENTS] = events;
        oj.PopupService.getInstance().changeOptions(options);
      }
    },

    /**
     * @memberof oj.ojPopup
     * @instance
     * @private
     * @param {Event} event native doc
     */
    _dismissalHandler: function _dismissalHandler(event) {
      if (oj.ZOrderUtils.getStatus(this.element) !== oj.ZOrderUtils.STATUS.OPEN) {
        return;
      }

      var launcher = this._launcher;
      var element = this.element; // child popups are siblings to the parent in the layer.

      var layer = element.parent();
      /** @type {?} */

      var target = event.target; // if the target is on the focus skip link next to the launcher, ignore.

      var focusSkipLink = this._focusSkipLink;

      if (focusSkipLink) {
        var link = focusSkipLink.getLink();

        if (link && oj.DomUtils.isAncestorOrSelf(link[0], target)) {
          return;
        }
      } // if event target is not under the laucher or popup root dom subtrees, dismiss


      if (!oj.DomUtils.isAncestorOrSelf(launcher[0], target) && !oj.DomUtils.isAncestorOrSelf(layer[0], target)) {
        if (oj.FocusUtils.isFocusable(target)) {
          // If the dismissal event target can take focus and the
          // event type is a mousedown or touchstart, wait for the focus event
          // to trigger dismissal.  This allows the blur to happen
          // on input components which triggers validation.
          if (event.type === 'mousedown' || event.type === 'touchstart') {
            return;
          }

          this._ignoreRestoreFocus = true;
        } // invoke standard close dismissal that can be canceled via the beforeclose
        // event.


        this.close();
      }
    },

    /**
     * @memberof oj.ojPopup
     * @instance
     * @private
     */
    _addDescribedBy: function _addDescribedBy() {
      var launcher = this._launcher;
      var element = this.element;
      var popupId = element.attr('id');
      var describedby = launcher.attr('aria-describedby');
      var tokens = describedby ? describedby.split(/\s+/) : [];
      tokens.push(popupId);
      describedby = $.trim(tokens.join(' '));
      launcher.attr('aria-describedby', describedby);
    },

    /**
     * @memberof oj.ojPopup
     * @instance
     * @private
     */
    _removeDescribedBy: function _removeDescribedBy() {
      var launcher = this._launcher;
      var element = this.element;

      if (!launcher || launcher.length === 0) {
        return;
      }

      var popupId = element.attr('id');
      var describedby = launcher.attr('aria-describedby');
      var tokens = describedby ? describedby.split(/\s+/) : [];
      var index = $.inArray(popupId, tokens);

      if (index !== -1) {
        tokens.splice(index, 1);
      }

      describedby = $.trim(tokens.join(' '));

      if (describedby) {
        launcher.attr('aria-describedby', describedby);
      } else {
        launcher.removeAttr('aria-describedby');
      }
    },

    /**
     * @memberof oj.ojPopup
     * @instance
     * @private
     */
    _initVoiceOverAssist: function _initVoiceOverAssist() {
      var isVOSupported = oj.AgentUtils.getAgentInfo().os === oj.AgentUtils.OS.IOS || oj.AgentUtils.getAgentInfo().os === oj.AgentUtils.OS.ANDROID;
      var liveRegion = this._liveRegion;

      if (!liveRegion) {
        liveRegion = new oj.PopupLiveRegion();
        this._liveRegion = liveRegion;
      }

      var message;

      var initialFocus = this._deriveInitialFocus();

      if (isVOSupported) {
        message = this.getTranslatedString(initialFocus === 'none' ? 'ariaLiveRegionInitialFocusNoneTouch' : 'ariaLiveRegionInitialFocusFirstFocusableTouch');
      } else {
        message = this.getTranslatedString(initialFocus === 'none' ? 'ariaLiveRegionInitialFocusNone' : 'ariaLiveRegionInitialFocusFirstFocusable');
      }

      liveRegion.announce(message);

      if (isVOSupported) {
        var focusSkipLinkId = this._getSubId('focusSkipLink');

        var launcher = this._launcher;

        var callback = this._intialFocus.bind(this, true);

        message = this.getTranslatedString('ariaFocusSkipLink');
        this._focusSkipLink = new oj.PopupSkipLink(launcher, message, callback, focusSkipLinkId);
        var content = this._content;

        var closeSkipLinkId = this._getSubId('closeSkipLink');

        callback = this._closeImplicitly.bind(this);
        message = this.getTranslatedString('ariaCloseSkipLink');
        this._closeSkipLink = new oj.PopupSkipLink(content, message, callback, closeSkipLinkId);
      }
    },

    /**
     * @memberof oj.ojPopup
     * @instance
     * @private
     */
    _destroyVoiceOverAssist: function _destroyVoiceOverAssist() {
      var liveRegion = this._liveRegion;
      liveRegion.destroy();
      delete this._liveRegion;
      var focusSkipLink = this._focusSkipLink;

      if (focusSkipLink) {
        focusSkipLink.destroy();
        delete this._focusSkipLink;
      }

      var closeSkipLink = this._closeSkipLink;

      if (closeSkipLink) {
        closeSkipLink.destroy();
        delete this._closeSkipLink;
      }
    },

    /**
     * @memberof oj.ojPopup
     * @instance
     * @private
     * @param {string} sub id that will become a composite id prefixed with the components uuid
     * @return {string}
     */
    _getSubId: function _getSubId(sub) {
      /** @type {?} */
      var id = this.element.attr('id');

      if (oj.StringUtils.isEmptyOrUndefined(id)) {
        id = this.uuid;
      }

      return [id, sub].join('_');
    },

    /**
     * @memberof oj.ojPopup
     * @instance
     * @private
     */
    _surrogateRemoveHandler: function _surrogateRemoveHandler() {
      // In all cases except when the dialog is already open, removal of the
      // surrogate during opening or closing will result in implicit removal.
      // 1) CLOSING: Handled in oj.ZOrderUtils.removeFromAncestorLayer.  If the
      //    surrogate doesn't exist the layer containing the popup dom is detached.
      // 2) OPENING: in the PopupServiceImpl#open _finalize, if the surrogate doesn't
      //    exist after in the open state, this remove callback is invoked.
      //
      // Custom element will call _NotifyDetached after element.remove but
      // but jquery UI instances will invoke the _destory method.
      var element = this.element;
      var status = oj.ZOrderUtils.getStatus(element);

      if (status === oj.ZOrderUtils.STATUS.OPEN) {
        element.remove();
      }
    },

    /**
     * @memberof oj.ojPopup
     * @instance
     * @private
     * @return {!Object.<oj.PopupService.EVENT, function(...)>}
     */
    _getPopupServiceEvents: function _getPopupServiceEvents() {
      if (!this._popupServiceEvents) {
        /** @type {!Object.<oj.PopupService.EVENT, function(...)>} **/
        var events = {};
        this._popupServiceEvents = events;
        events[oj.PopupService.EVENT.POPUP_CLOSE] = this._closeImplicitly.bind(this);
        events[oj.PopupService.EVENT.POPUP_REMOVE] = this._surrogateRemoveHandler.bind(this);
        events[oj.PopupService.EVENT.POPUP_REFRESH] = this.refresh.bind(this);
        events[oj.PopupService.EVENT.POPUP_BEFORE_OPEN] = this._beforeOpenHandler.bind(this);
        events[oj.PopupService.EVENT.POPUP_AFTER_OPEN] = this._afterOpenHandler.bind(this);
        events[oj.PopupService.EVENT.POPUP_BEFORE_CLOSE] = this._beforeCloseHandler.bind(this);
        events[oj.PopupService.EVENT.POPUP_AFTER_CLOSE] = this._afterCloseHandler.bind(this);
      }

      return this._popupServiceEvents;
    },

    /**
     * @memberof oj.ojPopup
     * @instance
     * @private
     */
    _closeImplicitly: function _closeImplicitly() {
      this._ignoreBeforeCloseResultant = true;
      this.close();
      delete this._ignoreBeforeCloseResultant;
    },

    /**
     * Creates a Promise exposed by the {@link oj.ojPopup#whenReady} method.
     *
     * @param {string} operation valid values are "open", "close" or "none"
     * @memberof oj.ojPopup
     * @instance
     * @private
     */
    _setWhenReady: function _setWhenReady(operation) {
      /** @type {oj.PopupWhenReadyMediator} */
      var mediator = this._whenReadyMediator;

      if (mediator) {
        mediator.destroy();
        delete this._whenReadyMediator;
      } // operation === none


      if (['open', 'close'].indexOf(operation) < 0) {
        return;
      }

      this._whenReadyMediator = new oj.PopupWhenReadyMediator(this.element, operation, 'ojPopup', this._IsCustomElement());
    },

    /**
     * Checks to see if there is a pending "open" or "close" operation.  If pending and it
     * is the same as the requested operation, the request silently fails.  If the current
     * operation is the inverse operation, we queue the current operation after the pending
     * operation is resolved.
     *
     * @memberof oj.ojPopup
     * @instance
     * @private
     * @param {string} operation currently requested
     * @param {Array} args passed to a queue operation
     * @returns {boolean} <code>true</code> if a close or open operation is pending completion.
     */
    _isOperationPending: function _isOperationPending(operation, args) {
      /** @type {oj.PopupWhenReadyMediator} **/
      var mediator = this._whenReadyMediator;

      if (mediator) {
        return mediator.isOperationPending(this, operation, operation, args);
      }

      return false;
    },

    /**
     * @memberof oj.ojPopup
     * @instance
     * @private
     * @param {jQuery} elem to manage the focus ring on
     */
    _setupFocus: function _setupFocus(elem) {
      var self = this;

      this._focusable({
        applyHighlight: true,
        setupHandlers: function setupHandlers(focusInHandler, focusOutHandler) {
          self._on(elem, {
            focus: function focus(event) {
              focusInHandler($(event.currentTarget));
            },
            blur: function blur(event) {
              focusOutHandler($(event.currentTarget));
            }
          });
        }
      });
    },

    /**
     * Notifies the component that its subtree has been removed from the document
     * programmatically after the component has been created.
     *
     * @memberof oj.ojPopup
     * @instance
     * @protected
     * @override
     */
    _NotifyDetached: function _NotifyDetached() {
      // detaching an open popup results in implicit dismissal
      if (oj.ZOrderUtils.getStatus(this.element) === oj.ZOrderUtils.STATUS.OPEN) {
        this._closeImplicitly();
      }

      this._super();
    }
  }); // sets the default modality option from the current theme


  Components.setDefaultOptions({
    ojPopup: {
      modality: Components.createDynamicPropertyGetter(function () {
        return (ThemeUtils.parseJSONFromFontFamily('oj-popup-option-defaults') || {}).modality;
      }),
      animation: Components.createDynamicPropertyGetter(function () {
        return (ThemeUtils.parseJSONFromFontFamily('oj-popup-option-defaults') || {}).animation;
      })
    }
  });
})(); // Fragments:

/**
 * <p>The <code class="prettyprint">&lt;oj-popup></code> accepts
 * any DOM elements in its Default slot but only tracks the validity
 * state of any JET custom element descendents that contain the valid property.
 * @ojchild Default
 * @memberof oj.ojPopup
 */

/**
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Target</th>
 *       <th>Gesture</th>
 *       <th>Action</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td>Outside popup or launcher</td>
 *       <td><kbd>Tap</kbd></td>
 *       <td>Close the popup.</td>
 *     </tr>
 *   </tbody>
 * </table>
 *
 * <p>Disabled items do not allow any touch interaction.
 *
 * @ojfragment touchDoc - Used in touch gesture section of classdesc, and standalone gesture doc
 * @memberof oj.ojPopup
 */

/**
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Target</th>
 *       <th>Key</th>
 *       <th>Action</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td rowspan = "3">Focus within Popup</td>
 *       <td><kbd>Tab</kbd> or <kbd>Shift + Tab</kbd></td>
 *       <td>Navigate the content of the popup. Close the open popup if there are no tab stops in
 *           the popup.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>F6</kbd></td>
 *       <td>Move focus to the launcher for a popup with modeless modality.  Close the open popup
 *           if the modality is modal.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Esc</kbd></td>
 *       <td>Close the open popup.</td>
 *     </tr>
 *     <tr>
 *       <td rowspan = "1">Popup Launcher</td>
 *       <td><kbd>F6</kbd></td>
 *       <td>Move focus to the first tab stop within the open popup.  If there is not a tab stop
 *           within the content, focus is established on the popup.</td>
 *     </tr>
 *   </tbody>
 * </table>
 *
 * @ojfragment keyboardDoc - Used in keyboard section of classdesc, and standalone gesture doc
 * @memberof oj.ojPopup
 */



/* global __oj_popup_metadata:false */
(function () {
  __oj_popup_metadata.extension._WIDGET_NAME = 'ojPopup';
  oj.CustomElementBridge.register('oj-popup', {
    metadata: __oj_popup_metadata
  });
})();

});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojlabel',['ojs/ojcore', 'jquery', 'hammerjs', 'ojs/ojlogger', 'ojs/ojcontext', 'ojs/ojjquery-hammer', 'ojs/ojcomponentcore', 'ojs/ojpopup'], 
      /*
      * @param {Object} oj 
      * @param {jQuery} $
      * @param {Object} Hammer  
      */
      function(oj, $, Hammer, Logger, Context)
{
  "use strict";
//%COMPONENT_METADATA%
var __oj_label_metadata = 
{
  "properties": {
    "for": {
      "type": "string"
    },
    "help": {
      "type": "object",
      "value": {
        "definition": null,
        "source": null
      },
      "properties": {
        "definition": {
          "type": "string"
        },
        "source": {
          "type": "string"
        }
      }
    },
    "labelId": {
      "type": "string"
    },
    "showRequired": {
      "type": "boolean",
      "value": false
    },
    "translations": {
      "type": "object",
      "value": {},
      "properties": {
        "tooltipHelp": {
          "type": "string"
        },
        "tooltipRequired": {
          "type": "string"
        }
      }
    }
  },
  "methods": {
    "refresh": {},
    "setProperty": {},
    "getProperty": {},
    "setProperties": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "extension": {}
};


/* global Promise:false, Hammer:false, Logger:false, Context:false */
(function () {
  /**
   * String used in the id on the span that surrounds the help icon.
   * @const
   * @private
   * @type {string}
   */
  var _HELP_ICON_ID = '_helpIcon';
  /**
   * String used in the id on the span that surrounds the required icon.
   * @const
   * @private
   * @type {string}
   */

  var _REQUIRED_ICON_ID = '_requiredIcon';
  /**
   * aria-describedby
   * @const
   * @private
   * @type {string}
   */

  var _ARIA_DESCRIBEDBY = 'aria-describedby';
  /**
   * described-by
   * @const
   * @private
   * @type {string}
   */

  var _DESCRIBED_BY = 'described-by';
  /**
   * aria-labelledby
   * @const
   * @private
   * @type {string}
   */

  var _ARIA_LABELLEDBY = 'aria-labelledby';
  /**
   * labelled-by
   * @const
   * @private
   * @type {string}
   */

  var _LABELLED_BY = 'labelled-by';
  /*!
   * JET oj-label. @VERSION
   */

  /**
   * <p>
   * The oj-label component decorates the label text with a required icon and help icon. The user
   * can interact with the help icon (on hover, on focus, etc) to display help description text
   * or to navigate to an url for more help information.
   * </p>
   * <p>For accessibility reasons, you need to associate the oj-label component to its
   * JET form component. For most JET form components you do this
   * using the oj-label's <code class="prettyprint">for</code> attribute and
   * the JET form component's <code class="prettyprint">id</code> attribute.
   * For a few JET form components
   * (oj-radioset, oj-checkboxset, oj-color-palette, and oj-color-spectrum)
   * you associate the oj-label component to its JET form component using
   * the oj-label's <code class="prettyprint">id</code> attribute and the
   * JET form component's <code class="prettyprint">labelled-by</code> attribute.
   * <pre class="prettyprint">
   * <code>
   * &lt;oj-label for="inputtextid" show-required="[[isRequired]]"
   * help.definition="[[helpDef]]" help.source="[[helpSource]]">input label&lt;/oj-label>
   * &lt;oj-input-text id="inputtextid" required="[[isRequired]]">&lt;//oj-input-text>
   *
   * &lt;oj-label id="radiosetlabel" show-required="[[isRequired]]">radioset&lt;/oj-label>
   * &lt;oj-radioset required="[[isRequired]]" labelled-by="radiosetlabel">
   *   &lt;oj-option name="color" value="red">Red&lt;/oj-option>
   *   &lt;oj-option name="color" value="blue">Blue&lt;/oj-option>
   * &lt;/oj-radioset>
   *
   * &lt;!--  You can bind the text as a child comment node or on a span element, but not on the
   * oj-label element. The knockout text binding is not supported on a JET custom element; -->
   * &lt;oj-label for="input2">&lt;!--ko text: input2Label -->&lt;!--/ko-->&lt;/oj-label>
   * </code>
   * </pre>
   * <p>
   * </p>
   * <h3 id="touch-section">
   *   Touch End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"touchDoc"}
   *
   * <h3 id="keyboard-section">
   *   Keyboard End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"keyboardDoc"}
   * <h3 id="a11y-section">
   *   Accessibility
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
   * </h3>
   * <p>For accessibility reasons, you need to associate the oj-label component to its
   * JET form component. For most JET form components you do this
   * using the oj-label's <code class="prettyprint">for</code> attribute and
   * the JET form component's <code class="prettyprint">id</code> attribute. For more examples,
   * refer to the JET form component's API jsdoc.
   * </p>
    *
   * @ojcomponent oj.ojLabel
   * @ojshortdesc A label is a short description of requested input.
   * @since 4.0.0
   * @augments oj.baseComponent
   *
   * @ojpropertylayout {propertyGroup: "common", items: ["for", "showRequired"]}
   * @ojvbdefaultcolumns 3
   * @ojvbmincolumns 1
   *
   * @ojuxspecs ['label']
   */
  // --------------------------------------------------- oj.ojLabel Styling Start -----------------------------------------------------------
  // ---------------- oj-focus-highlight --------------

  /**
  * Under normal circumstances this class is applied automatically.
  * It is documented here for the rare cases that an app developer needs per-instance control.<br/><br/>
  * The oj-focus-highlight class applies focus styling that may not be desirable when the focus results from pointer interaction (touch or mouse), but which is needed for accessibility when the focus occurs by a non-pointer mechanism, for example keyboard or initial page load.<br/><br/>
  * The application-level behavior for this component is controlled in the theme by the <code class="prettyprint"><span class="pln">$focusHighlightPolicy </span></code>SASS variable; however, note that this same variable controls the focus highlight policy of many components and patterns. The values for the variable are:<br/><br/>
  * <code class="prettyprint"><span class="pln">nonPointer: </span></code>oj-focus-highlight is applied only when focus is not the result of pointer interaction. Most themes default to this value.<br/>
  * <code class="prettyprint"><span class="pln">all: </span></code> oj-focus-highlight is applied regardless of the focus mechanism.<br/>
  * <code class="prettyprint"><span class="pln">none: </span></code> oj-focus-highlight is never applied. This behavior is not accessible, and is intended for use when the application wishes to use its own event listener to precisely control when the class is applied (see below). The application must ensure the accessibility of the result.<br/><br/>
  * To change the behavior on a per-instance basis, the application can set the SASS variable as desired and then use event listeners to toggle this class as needed.<br/>
  * @ojstyleclass oj-focus-highlight
  * @ojdisplayname Focus Styling
  * @ojshortdesc Allows per-instance control of the focus highlight policy (not typically required). See the Help documentation for more information.
  * @memberof oj.ojLabel
  * @ojtsexample
  * &lt;oj-label class="oj-focus-highlight">
  *   &lt;!-- Content -->
  * &lt;/oj-label>
  */
  // ---------------- oj-label-accesskey --------------

  /**
  * Use this in a span around a single text character in the oj-label's text. It styles the character in a way that indicates to the user that this character is the accesskey. <br/>
  * Use this in conjunction with the HTML accesskey attribute on the oj-label element.<br/>
  * @ojstyleclass oj-label-accesskey
  * @ojdisplayname AccessKey
  * @memberof oj.ojLabel
  * @ojdeprecated [{since: "6.0.0", description: "JET's accessibility team discourages access keys, so this styleclass has been deprecated."}]
  * @ojtsexample
  * &lt;oj-label class="oj-label-accesskey">
  *   &lt;!-- Content -->
  * &lt;/oj-label>
  */
  // ---------------- oj-label-nowrap --------------

  /**
  * Place on the oj-label element to have it not wrap when you don't want to use the responsive design classes (e.g., oj-md-labels-nowrap or oj-md-label-nowrap).
  * @ojstyleclass oj-label-nowrap
  * @ojdisplayname No Wrap
  * @memberof oj.ojLabel
  * @ojtsexample
  * &lt;oj-label class="oj-label-nowrap">
  *   &lt;!-- Content -->
  * &lt;/oj-label>
  */
  // ---------------- oj-label-inline --------------

  /**
  * Place on the oj-label element to inline the label with the sibling DOM element when you don't want to use the responsive design classes (e.g., oj-md-labels-inline).
  * @ojstyleclass oj-label-inline
  * @ojdisplayname Inline
  * @memberof oj.ojLabel
  * @ojtsexample
  * &lt;oj-label class="oj-label-inline">
  *   &lt;!-- Content -->
  * &lt;/oj-label>
  */
  // ---------------- oj-label-inline-top --------------

  /**
  * Place on the oj-label element together with oj-label-inline to inline the label with the sibling DOM element and have zero margin-top.
  * @ojstyleclass oj-label-inline-top
  * @ojdisplayname Inline Top
  * @memberof oj.ojLabel
  * @ojtsexample
  * &lt;oj-label class="oj-label-inline-top">
  *   &lt;!-- Content -->
  * &lt;/oj-label>
  */

  oj.__registerWidget('oj.ojLabel', $.oj.baseComponent, {
    version: '1.0.0',
    defaultElement: '<label>',
    widgetEventPrefix: 'oj',
    options: {
      /**
       * <p>
       * The <code class="prettyprint">for</code> attribute refers to the id of the
       * element this oj-label element is associated with.
       * Some JET form components support using oj-label's <code class="prettyprint">for</code>
       *  attribute to point to its <code class="prettyprint">id</code> attribute
       * (e.g., oj-input-text, oj-slider), and others do not (e.g., oj-checkboxset).
       * <p>
       * For the oj-radioset, oj-checkboxset, oj-color-palette, and oj-color-spectrum components,
       * instead of the <code class="prettyprint">for</code> attribute, use the
       * <code class="prettyprint">id</code> attribute on oj-label
       * with JET's form element's <code class="prettyprint">labelled-by</code> attribute.
       * </p>
       * <p>
       * Refer to the JET's form element's documentation for more examples showing the
       * use of <code class="prettyprint">for</code>/<code class="prettyprint">id</code>
       * and the use of <code class="prettyprint">id</code>/<code class="prettyprint">labelled-by</code>.
       * </p>
       *
       * @expose
       * @memberof oj.ojLabel
       * @ojshortdesc Specifies the form element associated with this label. See the Help documentation for more information.
       * @instance
       * @type {string|null}
       * @default null
       * @since 4.0.0
       *
       * @example <caption>Associate oj-label to the oj-input-text using the
       * <code class="prettyprint">for</code> attribute on oj-label and the
       * <code class="prettyprint">id</code> attribute on oj-input-text during initialization.</caption>
       * &lt;oj-label for="inputId">Name:&lt;/oj-label>
       * &lt;oj-input-text id="inputId">&lt;/oj-input-text>
       *
       */
      for: null,

      /**
       * The help information that goes on the oj-label.  The help attributes are:
       * <ul>
       * <li><code class="prettyprint">definition</code> - this is the help definition text.
       * It is what shows up
       * when the user hovers over the help icon, or tabs into the help icon, or press
       * and holds the help icon on a mobile device. No formatted text is available for
       * help definition attribute.</li>
       * <li><code class="prettyprint">source</code> - this is the help source url.
       * If present, a help icon will
       * render next to the label. For security reasons
       *  we only support urls with protocol http: or https:.
       * If the url doesn't comply we ignore it and throw an error.
       * Pass in an encoded URL since we do not encode the URL.
       * </ul>
       *
       * @expose
       * @memberof oj.ojLabel
       * @ojshortdesc Help information associated with this label.
       * @instance
       * @type {Object|null}
       * @default {'definition' :null, 'source': null}
       * @since 4.0.0
       *
       * @example <caption>Initialize the label with the help definition and help source:</caption>
       * &lt;!-- Using dot notation -->
       * &lt;oj-label help.definition="some help definition" help.source="some external url">Name:&lt;/oj-label>
       * &lt;!-- Using JSON notation -->
       * &lt;oj-label help='{"definition":"some value", "source":"someurl"}'>Name:&lt;/oj-label>
       * @example <caption>Set the <code class="prettyprint">help</code> attribute, after initialization:</caption>
       *
       * // Set one, leaving the others intact. Use the setProperty API for
       * // subproperties so that a property change event is fired.
       * myComponent.setProperty('help.definition', 'some new value');
       * // Get all
       * var values = myComponent.help;
       * // Set all.  Must list every key, as those not listed are lost.
       * myComponent.help = {
       *   definition: 'some new value',
       *   source: 'some new url'
       * };
       * @property {(string|null)=} definition help definition text
       * @property {(string|null)=} source help source url
       */
      help: {
        definition: null,
        source: null
      },

      /**
       * <code class="prettyprint">label-id</code> sets the <code class="prettyprint">id</code>
       * attribute on the internal label element.  The use case where this may be needed
       * is if you are using a <code class="prettyprint">&lt;div aria-labelledby></code>
       * and for accessibility reasons you need to point to the
       * oj-label's <code class="prettyprint">label</code>
       * element. This should be a corner case. Most often you'd use oj-label's
       * <code class="prettyprint">for</code> attribute to
       * associate with a form component's id attribute or use oj-label's
       * <code class="prettyprint">id</code> attribute to
       * associate with a JET form component's <code class="prettyprint">labelled-by</code> attribute.
       * @expose
       * @type {string|null}
       * @default null
       * @public
       * @instance
       * @since 4.0.0
       * @memberof oj.ojLabel
       * @ojshortdesc Specifies the id to set on the internal label element, if required. See the Help documentation for more information.
       *
       * @example <caption>Initialize the label with the
       * <code class="prettyprint">label-id</code> attribute:</caption>
       * &lt;oj-label label-id="labelId">Name:&lt;/oj-label>
       * @example <caption>Set the attribute, after initialization:</caption>
       * // getter
       * var labelid = myOjLabel.labelId;
       * // setter
       * myOjLabel.labelId = "myLabelId";
       */
      labelId: null,

      /**
       * Whether this label should have a required icon. It is recommended that you
       * bind the <code class="prettyprint">show-required</code> attribute to the same binding
       * as the <code class="prettyprint">required</code> attribute on the
       * associated JET form component to make sure they are in sync.
       * @expose
       * @type {?boolean}
       * @default false
       * @public
       * @instance
       * @memberof oj.ojLabel
       * @ojshortdesc Specifies whether the label should render an icon indicating that the associated form field requires a value. See the Help documentation for more information.
       * @since 4.0.0
       *
       * @example <caption>Initialize the oj-label with the
       * <code class="prettyprint">show-required</code> attribute, binding form component's
       * <code class="prettyprint">required</code> attribute to the same value.</caption>
       * &lt;oj-label show-required="[[isRequired]]">Name:&lt;/oj-label>
       * &lt;oj-input-text required="[[isRequired]]">&lt;/oj-input-text>
       * @example <caption>Set the attribute, after initialization:</caption>
       * // getter
       * var showRequired = myOjLabel.showRequired;
       * // setter
       * myOjLabel.showRequired = false;
       */
      showRequired: false,

      /**
       * Allows you to set certain attributes on the root dom element.
       * For ojLabel, we use 'class' only. The input components (via
       * EditableValue) set a styleclass on the ojLabel's root in case
       * component-specific label styling is needed. For example, ojradioset
       * would pass class: 'oj-radioset-label'. ojinputtext would pass class:
       * 'oj-inputtext-label'.
       *
       * @example <caption>Initialize root dom element with the set of
       * <code class="prettyprint">rootAttributes</code>:</caption>
       * $(".selector").ojLabel("option", "rootAttributes", {
       *   'class': 'oj-inputtext-label'
       * });
       *
       * @expose
       * @access public
       * @memberof oj.ojLabel
       * @instance
       * @type {Object}
       * @default {'id': null, 'class': null, 'style':null}
       * @ignore
       */
      rootAttributes: null
    },

    /**
     * @private
     * @memberof oj.ojLabel
     * @const
     */
    _BUNDLE_KEY: {
      _TOOLTIP_HELP: 'tooltipHelp',
      _TOOLTIP_REQUIRED: 'tooltipRequired'
    },

    /** ** start Public APIs ****/

    /**
     * Returns a jQuery object containing the root dom element of the label
     *
     * <p>This method does not accept any arguments.
     *
     * @expose
     * @memberof oj.ojLabel
     * @instance
     * @return {jQuery} the label
     * @ignore
     */
    widget: function widget() {
      return this.uiLabel;
    },

    /**
     * Refreshes the component with all the current attributes.
     * <p>
     * Call refresh if the <code class="prettyprint">id</code> changes, though
     * changing the <code class="prettyprint">id</code> shouldn't be needed.
     * </p>
     * <p>
     * Also, call refresh after <code class="prettyprint">required</code>
     * or <code class="prettyprint">help</code> changes.
     * The locale could have changed in the meantime, and refresh is needed to update the
     * <code class="prettyprint">required</code> and
     * <code class="prettyprint">help</code> tooltips.
     * </p>
     * There should be no need to call refresh for other attribute changes.
     *
     * @example document.getElementById("label1").setProperty("id","label2");
     * document.getElementById("label2").refresh();
     * @access public
     * @instance
     * @return {void}
     * @expose
     * @memberof oj.ojLabel
     * @ojshortdesc Refreshes the component.
     */
    refresh: function refresh() {
      this._super();

      this._refreshRequired();

      this._refreshHelp();

      this._addIdsToDom();
    },

    /** ** end Public APIs ****/

    /** ** start internal widget functions ****/

    /**
     * Overridden to make sure describedById option is set
     *
     * @memberof oj.ojLabel
     * @instance
     * @protected
     */
    _InitOptions: function _InitOptions(originalDefaults, constructorOptions) {
      this._super(originalDefaults, constructorOptions);

      this._isCustomElement = this._IsCustomElement();

      this._checkRequiredOption();
    },

    /**
     * After _ComponentCreate and _AfterCreate,
     * the widget should be 100% set up. this._super should be called first.
     * @override
     * @protected
     * @instance
     * @memberof oj.ojLabel
     */
    _ComponentCreate: function _ComponentCreate() {
      this._super();

      this._touchEatClickNamespace = this.eventNamespace + 'TouchEatClick';
      this._touchEatContextMenuNamespace = this.eventNamespace + 'TouchEatContextMenu';
      this._helpDefPopupNamespace = this.eventNamespace + 'HelpDefPopup';
      this._bTouchSupported = oj.DomUtils.isTouchSupported();

      this._drawOnCreate();
    },

    /**
     * @protected
     * @override
     * @instance
     * @memberof oj.ojLabel
    */
    _AfterCreate: function _AfterCreate() {
      var self = this;
      var forOption = this.options.for;
      var showRequiredOption = this.options.showRequired;
      var inputIdOption;
      var setIdOption;
      var targetElement;

      if (this.OuterWrapper) {
        inputIdOption = this.OuterWrapper.getAttribute('data-oj-input-id');
        setIdOption = this.OuterWrapper.getAttribute('data-oj-set-id');
      } // To get the 'for' on the <label>, what we do is set labelled-by on the
      // form component (simple document.getElementById search; we want to avoid
      // attribute searches since the performance isn't very good.),
      // which in turn sets the data-oj-input-id on the label, which
      // in turn sets its <label> element
      //


      if (inputIdOption) {
        // get internal label element and set its 'for'
        var labelElement = this.element[0];
        labelElement.setAttribute('for', inputIdOption);
      } else if (setIdOption) {
        // This is set by oj-radioset, oj-checkboxset, etc, so the oj-label can find it fast.
        this._targetElement = document.getElementById(setIdOption);
        targetElement = this._targetElement;

        if (this._needsHelpIcon()) {
          self._addHelpSpanIdOnTarget(self.helpSpanId, targetElement);
        }

        if (self.options.showRequired) {
          self._addRequiredDescribedByOnCustomFormElement(targetElement);
        }
      } // find the target element using document.getElementById, then set described-by
      // on it for helpIcon and requiredIcon accessibility.
      // And if there isn't an data-oj-input-id attribute set on oj-label yet,
      // set that.


      if (forOption && this._isCustomElement) {
        // get the targetElement
        // do this in next tick, otherwise there can be timing issues with bindings resolving
        // and the 'id' on the form component may not be resolved in time for oj-label to find
        // it - if oj-label is before the oj form component.
        // or setting labelled-by on form component which immediately
        // sets data-oj-input-id on oj-label.
        // If we do not do it in a setTimeout, then what we were observing is the data-oj-input-id
        // attribute would be set on the form component, but it wasn't getting the setOption
        // call. E.g., a test case is ojLabel with knockout where order is input and label
        var busyContext = Context.getContext(this.OuterWrapper).getBusyContext();
        var labelledByResolved = busyContext.addBusyState({
          description: "The oj-label id='" + this.OuterWrapper.id + "' is looking for its form component with id " + forOption
        });
        Promise.resolve().then(function () {
          self._targetElement = document.getElementById(forOption);

          if (self._targetElement) {
            targetElement = self._targetElement;

            if (self._needsHelpIcon()) {
              self._addHelpSpanIdOnTarget(self.helpSpanId, targetElement);
            }

            if (showRequiredOption) {
              self._addRequiredDescribedByOnCustomFormElement(targetElement);
            }

            if (!inputIdOption) {
              if (self._isElementCustomElement(targetElement)) {
                var ojLabelId = self.OuterWrapper.id;

                self._addElementAttribute(targetElement, ojLabelId, _LABELLED_BY);
              } else {
                self.element[0].setAttribute('for', forOption);
              }
            }
          } else {
            Logger.info('could not find an element with forOption ' + forOption);
          }

          labelledByResolved();
        });
      } else if (this._isCustomElement && this.options.labelId) {
        // no 'for' option.
        // look for aria-labelledby to support using
        // <oj-label> with a non-JET component, e.g., <div>
        // and this only works if aria-labelledby has only one id.
        // corner-case. For the JET components that link via id/labelled-by, not for/id,
        // the form component writes 'for' on the label, which in turn writes 'described-by'
        // on the JET form component.
        this._targetElement = this._getTargetElementFromLabelledAttr(_ARIA_LABELLEDBY, this.options.labelId);
        targetElement = this._targetElement;

        if (targetElement) {
          if (this._needsHelpIcon()) {
            this._addHelpSpanIdOnTarget(this.helpSpanId, targetElement);
          }
        }
      }
    },

    /**
     * <p>Save only the 'class' attribute since that is what
     * we manipulate. We don't have to save all the attributes.
     * N/A for custom element oj-label, so if custom element, this returns right away.
     *
     * @param {Object} element - jQuery selection to save attributes for
     * @protected
     * @memberof oj.ojLabel
     * @instance
     * @override
     */
    _SaveAttributes: function _SaveAttributes(element) {
      // _SaveAttributes is called before _InitOptions, so we can't use our global _isCustomElement
      // variable here.
      if (this._IsCustomElement()) {
        return;
      }

      this._savedClasses = element.attr('class');
    },

    /**
     * <p>Restore what was saved in _SaveAttributes.
     * N/A for custom element oj-label, so if custom element, this returns right away.
     * </p>
     *
     * @protected
     * @memberof oj.ojLabel
     * @instance
     * @override
     */
    _RestoreAttributes: function _RestoreAttributes() {
      if (this._IsCustomElement()) {
        return;
      } // restore the saved "class" attribute. Setting class attr to undefined is a no/op, so
      // if this._savedClasses is undefined we explicitly remove the 'class' attribute.


      if (this._savedClasses) {
        this.element.attr('class', this._savedClasses);
      } else {
        this.element.removeAttr('class');
      }
    },

    /**
     * Notifies the component that its subtree has been removed from the document programmatically
     * after the component has been created
     * @memberof! oj.ojLabel
     * @instance
     * @protected
     */
    _NotifyDetached: function _NotifyDetached() {
      this._superApply(arguments);

      this._handleCloseHelpDefPopup();
    },

    /**
     * Notifies the component that its subtree has been made hidden programmatically
     * after the component has been created
     * @memberof! oj.ojLabel
     * @instance
     * @protected
     */
    _NotifyHidden: function _NotifyHidden() {
      this._superApply(arguments);

      this._handleCloseHelpDefPopup();
    },

    /**
     * The translation section name for the private ojLabel() is oj-ojLabel.
     * In 4.0.0 and the introduction of the oj-label custom element,
     *  the translation section name is oj-ojLabel.
     * @protected
     * @override
     * @instance
     * @memberof oj.ojLabel
     */
    _GetTranslationsSectionName: function _GetTranslationsSectionName() {
      if (!this._IsCustomElement()) {
        return 'oj-ojLabel';
      }

      return 'oj-ojLabel';
    },

    /**
     * Method for components to override in order to handle changes to watched attributes.
     * @param {string} attr The name of the watched attribute
     * @param {string} oldValue The old attribute value
     * @param {string} newValue The new attribute value
     * @protected
     * @override
     * @instance
     * @memberof oj.ojLabel
     */
    // eslint-disable-next-line no-unused-vars
    _WatchedAttributeChanged: function _WatchedAttributeChanged(attr, oldValue, newValue) {
      this._superApply(arguments);

      switch (attr) {
        case 'data-oj-input-id':
          // set 'for' on the label element to be the value of this inputId.
          this.element[0].setAttribute('for', newValue);
          break;

        case 'data-oj-set-id':
          // This is set by set components like oj-radioset, oj-checkboxset, etc.
          if (oldValue && !newValue) {
            // remove 'data-oj-set-id' from the label so remove the describedby info too.
            var previousTarget = document.getElementById(oldValue);

            this._removeDescribedByWithPrefix(previousTarget, this.OuterWrapper.id);
          } else {
            this._targetElement = document.getElementById(newValue);
            var targetElement = this._targetElement; // we need to wait a tick because for oj-radioset,
            // it sets 'data-oj-set-id' on oj-label
            // which in turn sets 'described-by' on oj-radioset. And if we didn't wait a
            // tick, the attribute is written fine, but the describedBy option change is lost.
            // The testcase is this:
            // create an ojLabel with knockout where order is label and wrapped radioset

            var needsHelpIcon = this._needsHelpIcon();

            var needsRequiredIcon = this.options.showRequired;

            if (needsHelpIcon || needsRequiredIcon) {
              var busyContext = Context.getContext(this.OuterWrapper).getBusyContext();
              var describedByResolved = busyContext.addBusyState({
                description: 'The oj-label is writing described-by on its target.'
              });
              var self = this;
              Promise.resolve().then(function () {
                if (needsHelpIcon) {
                  self._addHelpSpanIdOnTarget(self.helpSpanId, targetElement);
                }

                if (self.options.showRequired) {
                  self._addRequiredDescribedByOnCustomFormElement(targetElement);
                }

                describedByResolved();
              });
            }
          }

          break;

        default:
          break;
      }
    },

    /**
     * Remove the id that starts with the prefix from the element's described-by attribute.
     * @param {Element} element the element, like oj-radioset
     * @param {string} prefix prefix of the described-by value to remove.
     * @private
     * @memberof oj.ojLabel
     */
    _removeDescribedByWithPrefix: function _removeDescribedByWithPrefix(element, prefix) {
      var describedBy;
      var tokens;
      describedBy = element.getAttribute('described-by'); // split into tokens

      tokens = describedBy ? describedBy.split(/\s+/) : [];
      tokens = tokens.filter(function (item) {
        return item.indexOf(prefix) === -1;
      }); // join the tokens back together and trim whitespace

      describedBy = tokens.join(' ').trim();

      if (describedBy) {
        element.setAttribute('described-by', describedBy);
      } else {
        element.removeAttribute('described-by');
      }
    },

    /**
     * set up dom and styles on create
     * @private
     * @memberof oj.ojLabel
     */
    _drawOnCreate: function _drawOnCreate() {
      var helpSpan = null;
      var labelElementId; // custom element is <oj-label>. this.element is the <label> element.
      // <oj-label class="oj-label oj-component">
      //    <div class="oj-label-group">(helpandrequired spans)<label></label>
      // </oj-label>

      if (this.OuterWrapper) {
        this.uiLabel = $(this.OuterWrapper).append( // @HTMLUpdateOK
        this.element.wrap(this._createOjLabelGroupDom()).parent()); // @HTMLUpdateOK

        this.uiLabel.addClass('oj-label oj-component');
      } else {
        // wrap the label with a root dom element (oj-label) and its child
        // (oj-label-group). Then point this.uiLabel to the root dom element <div class=oj-label>
        this.uiLabel = this.element.wrap(this._createRootDomElement()) // @HTMLUpdateOK
        .closest('.oj-component');
      } // adds id to the label element from label-id or id or generates one (in that order).
      // used for both ojLabel and oj-label.


      this._addIdsToDom(); // use the label element's id to create the help span and required span ids


      labelElementId = this.element[0].id;
      this.helpSpanId = labelElementId + _HELP_ICON_ID;
      this.requiredSpanId = labelElementId + _REQUIRED_ICON_ID; // move any oj-label styles off of this.element, and put on the
      // root dom element. They are restored in _destroy

      if (!this._isCustomElement) {
        this._moveLabelStyleClassesToRootDom();
      } // we put a span with an id on it around the help icon and
      // a span with an id on it around the required icon so that
      // the input's aria-describedby can point to it, if needed. Then the screen reader will
      // read the aria-label on the images when focus is on the input, so the user knows
      // that there is help and/or required icons.


      if (this.options.showRequired) {
        this._createRequiredIconSpanDom();
      }

      if (this._needsHelpIcon()) {
        helpSpan = this._createIconSpan(this.helpSpanId, true);

        this._createHelp(helpSpan);
      }
    },

    /**
     * Add described-by for the required icon on the custom form element.
     * This will be oj-checkboxset or oj-radioset only.
     * For all form controls except radioset
     * and checkboxset, aria-required on the form control reads required. So no need to
     * put aria-describedby on those for required icon.
     * @private
     * @memberof oj.ojLabel
     * @instance
     *
     */
    _addRequiredDescribedByOnCustomFormElement: function _addRequiredDescribedByOnCustomFormElement(targetElement) {
      if (targetElement && this._isElementCustomElementAriaRequiredUnsupported(targetElement)) {
        this._addElementAttribute(targetElement, this.requiredSpanId, _DESCRIBED_BY);
      }
    },

    /**
     * @private
     * @instance
     * @memberof oj.ojLabel
     *
     */
    _removeRequiredDescribedByOnCustomFormElement: function _removeRequiredDescribedByOnCustomFormElement(targetElement) {
      if (targetElement && this._isElementCustomElementAriaRequiredUnsupported(targetElement)) {
        this._removeElementAttribute(targetElement, this.requiredSpanId, _DESCRIBED_BY);
      }
    },

    /**
     * Call for custom oj-label element only. Adds aria-describedby on native form element or
     * described-by on JET form element with the help icon span's id or aria-labelledby on
     * div role='group'..
     * @private
     * @instance
     * @memberof oj.ojLabel
     * @param {string} helpSpanId The id of the help span
     *
     */
    _addHelpSpanIdOnTarget: function _addHelpSpanIdOnTarget(helpSpanId, targetElement) {
      var attributeName;
      attributeName = this._getAriaAttributeForTarget(targetElement);

      this._addElementAttribute(targetElement, helpSpanId, attributeName);
    },

    /**
     * Call for custom oj-label element only. Removes aria-describedby on native form element or
     * described-by on JET form element with the help icon span's id or aria-labelledby on
     * div role='group'.
     * @private
     * @memberof oj.ojLabel
     * @instance
     */
    _removeHelpSpanIdOnTarget: function _removeHelpSpanIdOnTarget(helpSpanId, targetElement) {
      var attributeName;
      attributeName = this._getAriaAttributeForTarget(targetElement);

      this._removeElementAttribute(targetElement, helpSpanId, attributeName);
    },

    /**
     * Based on the targetElement, this figures out which attribute we need to write onto
     * the target to make it be able to read out the help definition. E.g., described-by for
     * JET form control, aria-describedby for input, aria-labelled-by for div role='group'
     * @param {Element} targetElement
     * @return {string|null} the attribute, aria-describedby, aria-labelledby, or described-by
     * @private
     * @memberof oj.ojLabel
     * @instance
     */
    _getAriaAttributeForTarget: function _getAriaAttributeForTarget(targetElement) {
      var attributeName;

      if (!this._isElementCustomElement(targetElement)) {
        // We handle the one label to role='group' differently.
        // If a <div aria-labelledby role='group'> points to the
        // <oj-label>'s label-id, then add/remove aria-labelledby, not aria-describedby, since
        // screenreaders don't read aria-describedby on divs.
        if (targetElement.getAttribute('role') === 'group') {
          attributeName = _ARIA_LABELLEDBY;
        } else {
          attributeName = _ARIA_DESCRIBEDBY;
        }
      } else {
        attributeName = _DESCRIBED_BY;
      }

      return attributeName;
    },

    /**
     * Return the element with by using a querySelector to search for the attribute with the id.
     * e.g., aria-labelledby attribute set to labelId.
     * @private
     * @instance
     * @memberof oj.ojLabel
     * @param attrName the attribute name to look for. e.g., labelled-by or aria-labelledby
     * @param {string} id
     * @return {Element|null} is a reference to an Element object,
     * or null if the element is not found.
     *
     */
    _getTargetElementFromLabelledAttr: function _getTargetElementFromLabelledAttr(attrName, id) {
      var attributeSearchString; // The ~ means to look to see if the id is in a list of whitespace-separated
      // values, one of which is exactly equal to id, and labelled-by could have a
      // list of whitespace-separated ids.

      attributeSearchString = '[' + attrName + "~='" + id + "']";
      return document.querySelector(attributeSearchString);
    },

    /**
     * If targetElement's tagName has a "-", return true, else return false.
     * @param {Element} targetElement the HTML element the 'for' attribute is pointing to
     * @private
     * @memberof oj.ojLabel
     * @instance
     * @return {boolean} return true if targetElement's tagName contains "-". Else return false.
     *
     */
    _isElementCustomElement: function _isElementCustomElement(targetElement) {
      oj.Assert.assertDomElement(targetElement);
      return targetElement.tagName.indexOf('-') !== -1;
    },

    /**
     * Checks the targetElement's tagname against oj-checkboxset or oj-radioset, because these
     * are the only components that do not support aria-required.
     * @param {Element} targetElement the HTML element the 'for' attribute is pointing to
     * @private
     * @memberof oj.ojLabel
     * @instance
     * @return {boolean} true if targetElement's tagName is oj-radioset or oj-checkboxset.
     *
     */
    _isElementCustomElementAriaRequiredUnsupported: function _isElementCustomElementAriaRequiredUnsupported(targetElement) {
      oj.Assert.assertDomElement(targetElement);
      var componentName;
      var componentNames = ['oj-radioset', 'oj-checkboxset'];
      var length = componentNames.length;
      var tagName;
      var found = false;
      tagName = targetElement.tagName.toLowerCase();

      for (var i = 0; i < length && !found; i++) {
        componentName = componentNames[i];

        if (tagName.indexOf(componentName) === 0) {
          found = true;
        }
      }

      return found;
    },

    /**
     * Generic function to add a value to the element's attribute. For example, you can
     * add "foo" to the elem's aria-describedby attribute. It will not overwrite
     * any current aria-describedby values already there.
     *
     * @param {Element} elem the HTML element on which to add the attribute
     * @param {string} id the id to add to the attribute
     * @param {string} attr the attribute to add to. e.g., "aria-describedby"
     * @private
     * @memberof oj.ojLabel
     * @instance
     *
     */
    _addElementAttribute: function _addElementAttribute(elem, id, attr) {
      var index;
      var currentAttributeValue = elem.getAttribute(attr);
      var newAttributeValue;
      var tokens;
      tokens = currentAttributeValue ? currentAttributeValue.split(/\s+/) : []; // Get index that id is in the tokens, if at all.

      index = tokens.indexOf(id); // add id if it isn't already there

      if (index === -1) {
        tokens.push(id);
      }

      newAttributeValue = tokens.join(' ').trim();
      elem.setAttribute(attr, newAttributeValue); // @HTMLUpdateOK
    },

    /**
     * Generic function to remove a value to the element's attribute. For example, you can
     * remove "foo" from the elem's aria-describedby attribute. It will not remove
     * any other aria-describedby values already there.
     * @param {Element} elem the HTML element
     * @param {string} id the id to remove from the attr
     * @param {string} attr the attribute to remove from. e.g., "aria-describedby"
     * @private
     * @memberof oj.ojLabel
     * @instance
     */
    _removeElementAttribute: function _removeElementAttribute(elem, id, attr) {
      var currentAttributeValue = elem.getAttribute(attr);
      var newAttributeValue;
      var index;
      var tokens; // get aria-describedby that is on the element
      // split into tokens

      tokens = currentAttributeValue ? currentAttributeValue.split(/\s+/) : []; // Get index that id is in the tokens, if at all.

      index = tokens.indexOf(id); // remove that from the tokens array

      if (index !== -1) {
        tokens.splice(index, 1);
      } // join the tokens back together and trim whitespace


      newAttributeValue = tokens.join(' ').trim();

      if (newAttributeValue) {
        elem.setAttribute(attr, newAttributeValue); // @HTMLUpdateOK
      } else {
        elem.setAttribute(attr, ''); // @HTMLUpdateOK
      }
    },

    /**
     * Create help.
     * @private
     * @memberof oj.ojLabel
     * @instance
     */
    _createHelp: function _createHelp(helpSpan) {
      var helpDef = this.options.help.definition;
      var helpSource = this.options.help.source;

      var helpIconAnchor = this._createHelpIconAnchorDomElement(helpDef, helpSource); // .prepend: Insert content, specified by the parameter, to the beginning of each element


      $(helpSpan).prepend( // @HTMLUpdateOK
      helpIconAnchor);

      this._attachHelpDefToIconAnchor();

      this._focusable({
        element: helpIconAnchor,
        applyHighlight: true
      });
    },

    /**
     * Create required icon span dom and its contents
     * @private
     * @memberof oj.ojLabel
     * @instance
     */
    _createRequiredIconSpanDom: function _createRequiredIconSpanDom() {
      // _createIconSpan creates the span and adds it in the oj-label-group dom
      var requiredSpan = this._createIconSpan(this.requiredSpanId, false);

      requiredSpan.appendChild(this._createRequiredIconDomElement()); // @HTMLUpdateOK
    },

    /**
     * @throws error if showRequired is not a boolean
     * @private
     * @memberof oj.ojLabel
     * @instance
     */
    _checkRequiredOption: function _checkRequiredOption() {
      var showRequired = this.options.showRequired;

      if (typeof showRequired !== 'boolean') {
        throw new Error("Option 'showRequired' has invalid value set: " + showRequired);
      }
    },

    /**
     * Add an id to the label element if there isn't one already there.
     * Called during init and refresh.
     * @private
     * @memberof oj.ojLabel
     * @instance
     */
    _addIdsToDom: function _addIdsToDom() {
      var labelElementId; // Use label-id to set label element's id. If label-id doesn't exist, this uses oj-label's
      // id to generate a sub-id on label.

      if (this._isCustomElement) {
        if (!this.OuterWrapper.id) {
          $(this.OuterWrapper).uniqueId();
        }

        this._refreshLabelId();
      } // if no id on the label element, generate one.
      // this will be used to wrap the helpIcon and the requiredIcon and
      // then for the aria-describedby on the input.


      labelElementId = this.element.attr('id');

      if (labelElementId == null) {
        this.element.uniqueId();
      }
    },

    /**
     * Called if NOT a custom element.
     * move oj-label* classes from label element onto the root dom element
     * @private
     * @memberof oj.ojLabel
     * @instance
     */
    _moveLabelStyleClassesToRootDom: function _moveLabelStyleClassesToRootDom() {
      var arrayOfClasses;
      var classes = this.element.attr('class');
      var className;
      var numClasses;

      if (classes) {
        arrayOfClasses = classes.split(/\s+/);
        numClasses = arrayOfClasses.length;

        for (var i = 0; i < numClasses; i++) {
          className = arrayOfClasses[i]; // if class name has -label- in it, then move it
          // (e.g., oj-label, oj-label-inline, oj-md-label-nowrap,
          // oj-md-labels-inline)

          if (className.indexOf('-label') > 0) {
            this.uiLabel.addClass(className);
            this.element.removeClass(className);
          }
        }
      }
    },

    /**
     * create and return the span with an id that we'll use to put around the help
     * icon or required icon. The order of the dom of oj-label-group's children should always be:
     * <helpIcon span/><requiredIcon span/><label element>
     * @param {string} id the id of the span
     * @param {boolean} isHelp if true, prepend icon span to oj-label-group, else
     * add before the label element.
     * This is needed because we always want the help dom to come before the required dom and
     * we always want the label element to come last.
     * @returns {Element}
     * @private
     * @memberof oj.ojLabel
     * @instance
     */
    _createIconSpan: function _createIconSpan(id, isHelp) {
      var ojLabelGroupDom;
      var span = document.createElement('span');
      span.setAttribute('id', id);

      if (isHelp) {
        ojLabelGroupDom = this.uiLabel.find('.oj-label-group');
        ojLabelGroupDom.prepend(span); // @HTMLUpdateOK
      } else {
        this.element.before(span); // @HTMLUpdateOK
      }

      return span;
    },

    /**
     * For ojLabel component only, not oj-label.
     * return the dom node for the root dom element
     * @private
     * @memberof oj.ojLabel
     * @instance
     */
    _createRootDomElement: function _createRootDomElement() {
      var inputLabelClass;
      var rootAttributes = this.options.rootAttributes;
      var rootDomNode;
      var rootDomNodeClasses = 'oj-label oj-component';

      if (rootAttributes) {
        inputLabelClass = rootAttributes.class;
      }

      if (inputLabelClass) {
        rootDomNodeClasses = rootDomNodeClasses + ' ' + inputLabelClass;
      } // rootDomNode =
      //  $("<div class='oj-label oj-component'><div class='oj-label-group'></div></div>",
      //     this.document[0]);


      rootDomNode = document.createElement('div');
      rootDomNode.className = rootDomNodeClasses;
      rootDomNode.appendChild(this._createOjLabelGroupDom()); // @HTMLUpdateOK

      return rootDomNode;
    },

    /**
     * return the dom node for the oj-label-group node
     * @private
     * @memberof oj.ojLabel
     * @instance
     */
    _createOjLabelGroupDom: function _createOjLabelGroupDom() {
      var labelGroupNode;
      labelGroupNode = document.createElement('div');
      labelGroupNode.className = 'oj-label-group';
      return labelGroupNode;
    },

    /**
     * return the dom node for the span with oj-label-required-icon
     * @private
     * @memberof oj.ojLabel
     * @instance
     */
    _createRequiredIconDomElement: function _createRequiredIconDomElement() {
      var requiredTooltip = this.getTranslatedString(this._BUNDLE_KEY._TOOLTIP_REQUIRED);
      var requiredDom = document.createElement('span');
      requiredDom.className = 'oj-label-required-icon oj-component-icon';
      requiredDom.setAttribute('role', 'img');
      requiredDom.setAttribute('title', requiredTooltip); // title isn't being read by the screen reader. this is only needed for radioset/checkboxset.

      requiredDom.setAttribute('aria-label', requiredTooltip);
      return requiredDom;
    },

    /**
     * return the dom node for the help icon anchor.
     * if (_needsHelpIcon) , show help icon
     * if (helpSource), add href
     * if (helpDef), add 'aria-label'=helpDef on help icon.
     * @private
     * @memberof oj.ojLabel
     * @instance
     */
    _createHelpIconAnchorDomElement: function _createHelpIconAnchorDomElement(helpDef, source) {
      var helpIconAnchor; // construct the help html
      // if source (external url) or helpDef, then render a clickable help icon
      // From our Accessibility expert - You must not put role of img on a link.
      // This will make it so it is not a link any more to AT.
      // It is ok to leave it off the the <a> tag and do the following.
      // helpIconAnchor =
      //  $( "<a tabindex='0' target='_blank' class='oj-label-help-icon-anchor oj-label-help-icon oj-component-icon oj-clickable-icon-nocontext'></a>",
      //  this.document[0] );
      // The above is not reading anything when it has focus if it doesn't have an href. So if
      // it doesn't have an href, it needs some kind of role on it.

      helpIconAnchor = document.createElement('a');
      helpIconAnchor.setAttribute('tabindex', '0');
      helpIconAnchor.setAttribute('target', '_blank');
      helpIconAnchor.className = 'oj-label-help-icon-anchor oj-label-help-icon oj-component-icon oj-clickable-icon-nocontext';

      if (source) {
        try {
          oj.DomUtils.validateURL(source);
          helpIconAnchor.setAttribute('href', source);
        } catch (e) {
          throw new Error(e + '. The source option (' + source + ') is invalid.');
        }
      } else {
        // if there is no href, then we need a role that the screen reader/voiceover will read.
        helpIconAnchor.setAttribute('role', 'img');
      }

      if (helpDef) {
        helpIconAnchor.setAttribute('aria-label', helpDef);
      } else {
        helpIconAnchor.setAttribute('aria-label', this.getTranslatedString(this._BUNDLE_KEY._TOOLTIP_HELP));
      }

      return helpIconAnchor;
    },

    /**
     * To accomodate keyboard and touch users,
     * show a popup on hover, on tabbing in or touch press that shows the
     * help definition text on the help icon.
     *
     * press is recognized when the
     * pointer is down for x ms without any movement. In other words, you press with your finger and
     * don't let up and then after x ms the Help Def window shows up. You can then let go of your finger
     * the help def window stays up.
     * On Android, when you press and hold you see touchstart. When you finally let up, you see touchend
     * On ios, when you press and hold you see touchstart. When you finally let up, sometimes you
     * see touchend only. Other times, you see touchend mousedown mouseup click all
     * consecutively.
     * On ios, a quick tap shows touchstart touchend mousedown mouseup click (I only register those events)
     * all right after another.
     * @private
     * @memberof oj.ojLabel
     */
    _attachHelpDefToIconAnchor: function _attachHelpDefToIconAnchor() {
      var $helpDefPopupDiv;
      var $helpIcon;
      var position;
      var self = this;
      $helpIcon = this.widget().find('.oj-label-help-icon-anchor'); // before we do any of this work, make sure there is a help icon

      if ($helpIcon.length === 0) {
        return;
      } // Create the popup div where we will display the help def text, add a unique id onto it and save
      // that id so we can use it to popup.
      // 1. Build display:none div with help definition text. This will be our popup.
      // 2. Register click/touch event on label which will call a callback to open the popup on
      // PRESS


      if (this._bTouchSupported) {
        // this is code to be extra careful: Check if the _eatClickOnHelpIconListener exists.
        // If it does exist, call 'off'. We don't want this click listener
        // that eats clicks lying around.
        if (this._eatClickOnHelpIconListener) {
          this.widget().off(this._touchEatClickNamespace);
        } // The pressHold gesture also fires a click event on iphone on touchend.  Prevent that here.
        // This event is added to the widget on click in the function _handleOpenPopupForHelpDef


        this._eatClickOnHelpIconListener = function () {
          // changing colors is a good way to debug if the handler is being called. this changes
          // the label color.
          // if (this.style.color === "aqua")
          // this.style.color = "yellow";
          // else
          // this.style.color = "aqua";
          return false;
        };

        $helpIcon.on('contextmenu' + this._touchEatContextMenuNamespace, false);
      } // For touch device, press with finger on helpIcon to show the help def in a popup.
      // If there is no help source, you can also tap with finger on the helpIcon to show the help
      // def in a popup.
      // For keyboard users, tab in to helpIcon to show the help def in a popup.
      // For mouse users, hovering on helpIcon shows the help def in a popup.
      // ------------------------------------------------------------------------------------
      // ENTERING CALLBACK TO OPEN THE POPUP IF NEEDED
      // (focusin from tab, not mouse, OR press from touch)


      this._openPopupForHelpDefCallbackListener = function (event) {
        if ($helpDefPopupDiv == null) {
          // create popup's div
          $helpDefPopupDiv = self._createHelpDefPopupDiv();
          position = {
            my: 'start bottom',
            at: 'end top',
            collision: 'flipcenter',
            of: $helpIcon
          };
          $helpDefPopupDiv.ojPopup({
            position: position,
            modality: 'modeless',
            animation: {
              open: null,
              close: null
            }
          });
        }

        self._handleOpenHelpDefPopup(event, $helpDefPopupDiv, $helpIcon);
      }; // END CALLBACK TO OPEN POPUP
      //
      // CALLBACK TO CLOSE POPUP


      this._closePopupForHelpDefCallbackListener = function () {
        self._handleCloseHelpDefPopup();
      }; // END CALLBACK TO CLOSE POPUP
      // Add event handlers to open the help definition popup


      this._addShowHelpDefinitionEventHandlers($helpIcon);
    },

    /**
     * Create the div that will be used as the popup for the help definition.
     * @private
     * @memberof oj.ojLabel
     */
    _createHelpDefPopupDiv: function _createHelpDefPopupDiv() {
      var contentDiv;
      var $contentDiv;
      var helpDef = this.options.help.definition;
      var helpDefPopupDiv;
      var $helpDefPopupDiv;
      var helpDefText;

      if (helpDef) {
        helpDefText = helpDef;
      } else {
        helpDefText = this.getTranslatedString(this._BUNDLE_KEY._TOOLTIP_HELP);
      }

      if (!this._helpDefPopupDivId) {
        // create a root node to bind to the popup
        helpDefPopupDiv = document.createElement('div');
        helpDefPopupDiv.className = 'oj-label-help-popup';
        helpDefPopupDiv.style.display = 'none';
        $helpDefPopupDiv = $(helpDefPopupDiv);
        $helpDefPopupDiv.uniqueId();
        this._helpDefPopupDivId = $helpDefPopupDiv.prop('id'); // create a content node

        contentDiv = document.createElement('div');
        contentDiv.className = 'oj-label-help-popup-container';
        helpDefPopupDiv.appendChild(contentDiv); // @HTMLUpdateOK created contentDiv ourselves

        $contentDiv = $(contentDiv);
        $contentDiv.text(helpDefText);
        this.uiLabel.append($helpDefPopupDiv); // @HTMLUpdateOK content created by us
      } else {
        // Find the div with the id, and then update the text of it.
        $helpDefPopupDiv = $(document.getElementById(this._helpDefPopupDivId));

        if ($helpDefPopupDiv.length) {
          $contentDiv = $helpDefPopupDiv.find('.oj-label-help-popup-container').first();
          $contentDiv.text(helpDefText);
        }
      }

      return $helpDefPopupDiv;
    },

    /**
     * Add the event listeners to show the helpDefinition text in a popup
     * @param {jQuery} $helpIcon
     * @returns {undefined}
     * @instance
     * @memberof oj.ojLabel
     * @private
     */
    _addShowHelpDefinitionEventHandlers: function _addShowHelpDefinitionEventHandlers($helpIcon) {
      var hammerOptions; // Open the popup on focusin and mousenter.
      // *I have logic in the listener to ignore these when these trigger as a result of
      // the user touching the screen.

      $helpIcon.on('focusin' + this._helpDefPopupNamespace + ' mouseenter' + this._helpDefPopupNamespace, this._openPopupForHelpDefCallbackListener);
      $helpIcon.on('mouseleave' + this._helpDefPopupNamespace, this._closePopupForHelpDefCallbackListener);

      if (this._bTouchSupported) {
        // And if touch is supported, the user can also open the popup on press or,
        //  if no help source, on tap.
        if (this.options.help.source) {
          hammerOptions = {
            recognizers: [[Hammer.Press, {
              time: oj.DomUtils.PRESS_HOLD_THRESHOLD
            }]]
          };
          $helpIcon.ojHammer(hammerOptions); // JET components are encouraged to use JQUI's _on() method, giving all the conveniences
          // of the _on method, like automatic cleanup.

          this._on($helpIcon, {
            press: this._openPopupForHelpDefCallbackListener
          });
        } else {
          hammerOptions = {
            recognizers: [[Hammer.Tap], [Hammer.Press, {
              time: oj.DomUtils.PRESS_HOLD_THRESHOLD
            }]]
          };
          $helpIcon.ojHammer(hammerOptions);

          this._on($helpIcon, {
            press: this._openPopupForHelpDefCallbackListener,
            tap: this._openPopupForHelpDefCallbackListener
          });
        }
      }
    },

    /**
     * Handle open popup for help definition.
     * @instance
     * @memberof oj.ojLabel
     * @private
     */
    _handleOpenHelpDefPopup: function _handleOpenHelpDefPopup(event, helpDefPopupDiv, helpIcon) {
      var isOpen = helpDefPopupDiv.ojPopup('isOpen');

      if (isOpen) {
        return;
      } // touch supported does not mean only touch. It could be a touch-enabled laptop like Windows10


      if (this._bTouchSupported) {
        // For a press, we want to show the popup with the help def,
        // but we do not want to navigate to the source url. So we eat the click.
        if (event.type === 'press') {
          var widget = this.widget();
          widget.on('click' + this._touchEatClickNamespace, this._eatClickOnHelpIconListener);
          var self = this;
          helpDefPopupDiv.on('ojclose', function () {
            widget.off(self._touchEatClickNamespace);
          });
        } else {
          helpDefPopupDiv.off('ojclose');
        } // Open the popup if I get a 'press' event, a 'tap' event, a 'focusin' event if
        // it wasn't a touch, and a 'mouseenter' event if it wasn't a touch.
        // I look for a recent touchstart event and use this to filter out
        // the focusin and mouseevent events. I use touchstart and not touchend because while
        // pressing I get the touchstart, but I don't get the touchend until the finger lets up.


        if (event.type === 'press' || event.type === 'tap' || !oj.DomUtils.recentTouchStart() && (event.type === 'focusin' || event.type === 'mouseenter')) {
          helpDefPopupDiv.ojPopup('open', helpIcon);
        } // end touch code

      } else {
        // non-touch devices. focusin/mouseenter are the only ways to open the popup.
        helpDefPopupDiv.ojPopup('open', helpIcon);
      }
    },

    /**
     * Close helpDef popup. This is called from _NotifyDetached and _NotifyHidden and
     * as a callback for this._closePopupForHelpDefCallbackListener.
     * @private
     * @memberof oj.ojLabel
     */
    _handleCloseHelpDefPopup: function _handleCloseHelpDefPopup() {
      var $helpDefPopupDiv;

      if (this._helpDefPopupDivId != null) {
        $helpDefPopupDiv = $(document.getElementById(this._helpDefPopupDivId));
        $helpDefPopupDiv.ojPopup('close');
      }
    },

    /**
     * Remove the event listeners for opening a popup on the help def icon and for eating
     * the clicks on the 'press' event. Called from destroy and when we remove the help icon.
     * @private
     * @memberof oj.ojLabel
     */
    _removeHelpDefIconEventListeners: function _removeHelpDefIconEventListeners(helpIcon) {
      if (this._bTouchSupported) {
        this.widget().off(this._touchEatClickNamespace);
        helpIcon.off(this._touchEatContextMenuNamespace);
        this._eatClickOnHelpIconListener = null;
        this._eatContextMenuOnHelpIconListener = null; // helpIcon is same element on which we originally called ojHammer()
        // the listeners are automatically removed since we used jqueryui's _on

        helpIcon.ojHammer('destroy');
      }

      helpIcon.off(this._helpDefPopupNamespace);
      this._openPopupForHelpDefCallbackListener = null;
      this._closePopupForHelpDefCallbackListener = null;
    },

    /**
     * removes the help def popup dom and variables
     * @returns {undefined}
     * @private
     * @memberof oj.ojLabel
     */
    _removeHelpDefPopup: function _removeHelpDefPopup() {
      var $helpDefPopupDiv;

      if (this._helpDefPopupDivId != null) {
        $helpDefPopupDiv = $(document.getElementById(this._helpDefPopupDivId));

        if ($helpDefPopupDiv.length > 0) {
          $helpDefPopupDiv.ojPopup('destroy');
          $helpDefPopupDiv.remove();
        }

        this._helpDefPopupDivId = null;
      }
    },

    /**
     * @private
     * @memberof oj.ojLabel
     * @returns {boolean}
     */
    _needsHelpIcon: function _needsHelpIcon() {
      var options = this.options;
      var helpDef;
      var helpSource = options.help.source;
      var needsIcon; // "", or null, or undefined all mean help.source is not specified.

      needsIcon = helpSource !== '' && helpSource != null;

      if (!needsIcon) {
        // Now check helpDef: "", or null, or undefined all mean help.definition is not specified.
        helpDef = options.help.definition;
        needsIcon = helpDef !== '' && helpDef != null;
      }

      return needsIcon;
    },

    /**
     * refresh the help dom --
     * find the help root dom node and remove it if it is there
     * and add back the help html. Helpful if a help option changed.
     * @private
     * @memberof oj.ojLabel
     */
    _refreshHelp: function _refreshHelp() {
      var helpSpanId = this.helpSpanId;
      var helpSpan;
      var $helpIcon;
      var needsHelpIcon;
      var targetElement = this._targetElement; // remove the help info if it is there.

      $helpIcon = this.uiLabel.find('.oj-label-help-icon');

      if ($helpIcon.length === 1) {
        // remove things we added in _attachHelpDefToIconAnchor
        this._removeHelpDefIconEventListeners($helpIcon);

        this._removeHelpDefPopup();

        $helpIcon.remove();
      }

      helpSpan = document.getElementById(helpSpanId);
      needsHelpIcon = this._needsHelpIcon(); // ok, we removed the helpIcon (but not the span) at the start of this method,
      // so we need to add it back if we needHelpIcon

      if (needsHelpIcon) {
        if (helpSpan == null) {
          helpSpan = this._createIconSpan(helpSpanId, true);
        }

        this._createHelp(helpSpan);

        if (this._isCustomElement) {
          this._addHelpSpanIdOnTarget(helpSpanId, targetElement);
        }
      } else if (helpSpan !== null) {
        helpSpan.parentNode.removeChild(helpSpan);

        if (this._isCustomElement) {
          this._removeHelpSpanIdOnTarget(helpSpanId, targetElement);
        }
      }
    },

    /**
     * refresh the required dom --
     * if required is true, then add the required dom if it isn't already there
     * if required is false, remove the required dom if it is there.
     * Helpful if the required option changed.
     * @private
     * @memberof oj.ojLabel
     */
    _refreshRequired: function _refreshRequired() {
      var $requiredDom;
      var requiredSpanId = this.requiredSpanId;
      var requiredSpan;
      var requiredTooltip;
      requiredSpan = document.getElementById(requiredSpanId);

      if (this.options.showRequired) {
        // add required if it wasn't already there
        if (!requiredSpan) {
          this._createRequiredIconSpanDom();

          if (this._isCustomElement) {
            this._addRequiredDescribedByOnCustomFormElement(this._targetElement);
          }
        } else {
          // required is there, so we need to refresh the translated value in case it changed.
          requiredTooltip = this.getTranslatedString(this._BUNDLE_KEY._TOOLTIP_REQUIRED);
          $requiredDom = this.uiLabel.find('.oj-label-required-icon');
          $requiredDom.attr('title', requiredTooltip);
        }
      } else {
        // not required, so remove it
        requiredSpan = document.getElementById(requiredSpanId);

        if (requiredSpan !== null) {
          requiredSpan.parentNode.removeChild(requiredSpan);
        }

        if (this._isCustomElement) {
          this._removeRequiredDescribedByOnCustomFormElement(this._targetElement);
        }
      }
    },

    /**
     * This gets called during component initialization and when the 'for' option changes.
     * And this should find the targetElement, set labelledBy on it and describedBy.
     * @private
     * @memberof oj.ojLabel
     */
    _refreshFor: function _refreshFor(oldValue, newValue) {
      var labelElement = this.element[0];
      var ojLabelId = this.OuterWrapper.id;

      if (oldValue) {
        // If someone removes 'for', the labelled-by is removed and the
        // internal 'for' is removed and data-oj-input-id is removed.
        labelElement.removeAttribute('for');
        this.OuterWrapper.removeAttribute('data-oj-input-id');
        var oldTarget = document.getElementById(oldValue);

        if (oldTarget) {
          var labelledBy = oldTarget.getAttribute(_LABELLED_BY);

          if (labelledBy) {
            if (labelledBy === ojLabelId) {
              oldTarget.removeAttribute(_LABELLED_BY);
            } else {
              // remove the ojLabelId from the labelledBy
              var splitArray = labelledBy.split(/\s+/); // remove ojLabelId from the splitArray and rejoin

              var newArray = splitArray.filter(function (item) {
                return item !== ojLabelId;
              });
              var newLabelledBy = newArray.join(' ');
              oldTarget.setAttribute(_LABELLED_BY, newLabelledBy); // @HTMLUpdateOK
            }
          }
        }
      }

      this._targetElement = document.getElementById(this.options.for);

      if (this._targetElement) {
        var targetElement = this._targetElement;

        if (this._isElementCustomElement(targetElement)) {
          this._addElementAttribute(targetElement, ojLabelId, _LABELLED_BY);

          if (this._needsHelpIcon()) {
            this._addHelpSpanIdOnTarget(this.helpSpanId, targetElement);
          }

          if (this.options.showRequired) {
            this._addRequiredDescribedByOnCustomFormElement(targetElement);
          }
        } else {
          labelElement.setAttribute('for', newValue);
        }
      }
    },

    /**
     * refresh label-id which is only for oj-label custom element.
     * Set the label element's id to label-id. If label-id is not set,
     * then use the <oj-label>'s id attribute to set a sub-id on the label element.
     * @private
     * @memberof oj.ojLabel
     */
    _refreshLabelId: function _refreshLabelId() {
      var labelIdOption;
      var customElementId;
      labelIdOption = this.options.labelId;

      if (labelIdOption) {
        this.element.attr('id', labelIdOption);
      } else {
        // for custom elements, this.uiLabel is <oj-label>.
        customElementId = this.uiLabel.attr('id');

        if (customElementId) {
          // create sub-id on the label element
          this.element.attr('id', customElementId + '|label');
        }
      }
    },

    /**
     * Note that _setOption does not get called during create. it only gets called
     * when the component has already been created.
     * @override
     * @protected
     * @memberof oj.ojLabel
     * @instance
     */
    // eslint-disable-next-line no-unused-vars
    _setOption: function _setOption(key, value) {
      var oldValue = this.options[key];

      this._superApply(arguments);

      switch (key) {
        case 'showRequired':
          this._refreshRequired();

          break;

        case 'help':
          this._refreshHelp();

          break;

        case 'for':
          // todo: what happens if 'for' changes? I can see that being very unlikely.
          // but what it can do is use its id to search for labelledBy target, and
          // remove the labelledBy target, then add 'for' and start again.
          // it can look at this.options.for for 'old value' and value for new value
          if (this._isCustomElement) {
            // refreshes for, which is only for oj-label custom element, not ojLabel.
            // targetElement is the element with id === oj-label's for option
            this._refreshFor(oldValue, value);
          }

          break;

        case 'labelId':
          // refreshes label-id, which is only for oj-label custom element, not ojLabel.
          this._refreshLabelId();

          break;

        default:
          break;
      }
    },
    // @inheritdoc
    getNodeBySubId: function getNodeBySubId(locator) {
      var node;
      var subId;
      node = this._super(locator);

      if (!node) {
        subId = locator.subId;

        if (subId === 'oj-label-help-icon') {
          node = this.widget().find('.oj-label-help-icon')[0];
        }
      } // Non-null locators have to be handled by the component subclasses


      return node || null;
    },
    // @inheritdoc
    getSubIdByNode: function getSubIdByNode(node) {
      var subId = null;

      if (node != null) {
        if (node === this.widget().find('.oj-label-help-icon')[0]) {
          subId = {
            subId: 'oj-label-help-icon'
          };
        }
      }

      return subId || this._superApply(arguments);
    },

    /**
     *
     * @override
     * @protected
     * @memberof oj.ojLabel
     * @instance
     */
    _destroy: function _destroy() {
      // remove things we added in _attachHelpDefToIconAnchor
      var helpIcon = this.uiLabel.find('.oj-label-help-icon');

      this._removeHelpDefIconEventListeners(helpIcon);

      this._removeHelpDefPopup();

      this.helpSpanId = null;
      this.requiredSpanId = null;
      this._isCustomElement = null; // DomUtils.unwrap() will avoid unwrapping if the node is being destroyed by Knockout

      oj.DomUtils.unwrap(this.element, this.uiLabel);
      return this._super();
    }
    /** ** end internal widget functions ****/

    /**
     * Removes the label functionality completely.
     * This will return the element back to its pre-init state.
     *
     * <p>This method does not accept any arguments.
     *
     * @method
     * @name oj.ojLabel#destroy
     * @memberof oj.ojLabel
     * @instance
     * @ignore
     *
     * @example <caption>Invoke the <code class="prettyprint">destroy</code> method:</caption>
     * $( ".selector" ).ojLabel( "destroy" );
     */

    /**
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td rowspan=2>Help Icon</td>
     *       <td><kbd>Tap and Hold</kbd></td>
     *       <td>Show the help definition in a popup</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Tap</kbd></td>
     *       <td>If no help source, show the help definition in a popup.
     *       If help source, navigate to the url.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     *
     * @ojfragment touchDoc - Used in touch gesture section of classdesc, and standalone gesture doc
     * @memberof oj.ojLabel
     * @instance
     */

    /**
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td rowspan=2>Help Icon</td>
     *       <td><kbd>Enter</kbd></td>
     *       <td>If there is an url associated with help icon, navigate to the url.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Tab In</kbd></td>
     *       <td>Show the help definition in a popup.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * @ojfragment keyboardDoc - Used in keyboard section of classdesc, and standalone gesture doc
     * @memberof oj.ojLabel
     * @instance
     */

  }); // ////////////////     SUB-IDS     //////////////////

  /**
   * <p>Sub-ID for the label's help icon.</p>
   *
   * @ojsubid oj-label-help-icon
   * @memberof oj.ojLabel
   *
   * @example <caption>Get the node for the help icon:</caption>
   * var node = myComponent.getNodeBySubId({'subId': 'oj-label-help-icon'});
   */

})();



/* global __oj_label_metadata:false */
(function () {
  __oj_label_metadata.extension._WIDGET_NAME = 'ojLabel';
  __oj_label_metadata.extension._INNER_ELEM = 'label';
  __oj_label_metadata.extension._GLOBAL_TRANSFER_ATTRS = ['accesskey'];
  __oj_label_metadata.extension._WATCHED_ATTRS = ['data-oj-input-id', 'data-oj-set-id'];
  oj.CustomElementBridge.register('oj-label', {
    metadata: __oj_label_metadata
  });
})();

});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojlabelledbyutils',['ojs/ojcore', 'jquery', 'ojs/ojlabel'], 
  /*        
    * @param {Object} oj         
    * @param {jQuery} $        
  */
function(oj, $)
{
  "use strict";


/**
 * @class oj.LabelledByUtils
 * @classdesc JET Labelled Component Utils
 * @export
 * @since 7.1.0
 * @hideconstructor
 * @ignore
 *
 */
var LabelledByUtils = {}; // S T A T I C    V A R S

/**
* String used in the label element's id for custom &lt;oj-label>
* @const
* @ignore
* @type {string}
*/

LabelledByUtils.CUSTOM_LABEL_ELEMENT_ID = '|label';
/**
 * On form component initialization and when form component's 'labelledBy' property changes,
 * call this function to update aria-labelledby on the rootElement of the 'set' component
 * and update aria-describedby on the inputs when labelledBy changes.
 * For custom element only.
 * Only call for the 'set' components, like oj-radioset, oj-color-palette.
 *
 * Background of how oj-label and 'set' components are linked together for accessibility:
 * --------------------------------------------------------------------------------------
 * An application developer links oj-label with a 'set' component like this:
 * <oj-label id='foo'> to <oj-checkboxset labelled-by='foo'>
 *
 * We render the aria and data-oj- attributes on the correct dom like this:
 * <oj-label id='foo' data-oj-set-id='cb'><span id="foo|label_helpIcon"<label id='foo|label'>
 * <oj-checkboxset id='cb' labelled-by='foo' aria-labelledby='foo|label' described-by='foo|label_helpIcon'>
 * <input aria-describedby='foo|label_helpIcon'>
 *
 * In steps:
 * 1. App developer adds labelled-by on its set form component to link them
 * 2. On init, set form component calls _labelledByUpdatedForSet
 * 2a. this writes labelledBy to aria-labelledby on $focusElem,
 * making sure not to override any existing ids
 * 2b. this writes data-oj-set-id onto oj-label
 * 3. oj-label gets notified of data-oj-set-id change and uses it to find the form component
 * using document.getElementById (we want to avoid dom attribute searches for performance reasons)
 * 4. if it has a required/help icon oj-label writes described-by on the set form component,
 * which in turn calls _describedByUpdated.
 * 4a. writes aria-describedby onto its content element to point
 * to the icon text via _describedByUpdated
 * ---------------------------------------------------------------------------------------
 * Note: input form components are linked to the label via for/id. In that case, oj-label
 * finds the form component with document.getElementById(for), writes labelled-by on the form
 * component which in turn writes oj-data-input-id on the label to let the oj-label know what to
 * write for 'for' on its internal label element.
 * this does not happen here. It happens in EditableValueUtils.
 * @param {string} componentId id of the form component.
 * @param {string|null} originalLabelledBy the old value of the labelledBy option
 * @param {string|null} newLabelledBy the new value of the labelledBy option.
 * @param {jQuery} $focusElem jquery Object containing the node(s)
 * to add/remove aria-labelledby to.
 * For 'set' components this is the root element, not the individual inputs.
 * @private
 * @ignore
 */

LabelledByUtils._labelledByUpdatedForSet = function (componentId, originalLabelledBy, newLabelledBy, $focusElem) {
  if (!originalLabelledBy && !newLabelledBy) {
    // nothing to update. return
    return;
  }

  if (!this._IsCustomElement()) {
    return;
  }

  var _updateLabelledBySetAdd = function _updateLabelledBySetAdd($el, labelId, args) {
    var suffix = LabelledByUtils.CUSTOM_LABEL_ELEMENT_ID;

    LabelledByUtils._addAriaLabelledBy($el, labelId + suffix);

    LabelledByUtils._addSetIdOnLabel(labelId, args.componentId);
  };

  var _updateLabelledBySetRemove = function _updateLabelledBySetRemove($el, labelId, args) {
    var suffix = LabelledByUtils.CUSTOM_LABEL_ELEMENT_ID;

    LabelledByUtils._removeAriaLabelledBy($el, labelId + suffix);

    LabelledByUtils._removeSetIdOnLabel(labelId, args.componentId);
  }; // callbacks for what needs to happen when the set form component's labelledBy property changes.


  var callbackObj = {
    callbackAdd: _updateLabelledBySetAdd,
    callbackRemove: _updateLabelledBySetRemove,
    args: {
      componentId: componentId
    }
  };

  LabelledByUtils._byUpdatedTemplate(originalLabelledBy, newLabelledBy, $focusElem, callbackObj);
};
/**
 * On initialization and when form component's 'describedBy' property changes,
 * call this function to update the aria-describedby attribute on the content elements.
 * oj-label writes described-by onto the form component if it has a help icon or required icon
 * for set components.
 * @param {string|null} originalDescribedBy the old value of the 'describedBy' property.
 * This can be a space-delimited list of ids.
 * @param {string|null} newDescribedBy the new value of the 'describedBy' property. This can
 * be a space-delimited list of ids.
 * @param {jQuery} $focusElem jquery Object containing the node(s)
 * to add/remove aria-describedby to. This is the content element usually.
 * @private
 * @ignore
 */


LabelledByUtils._describedByUpdated = function (originalDescribedBy, newDescribedBy) {
  var $focusElem = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._GetContentElement();

  if (!originalDescribedBy && !newDescribedBy) {
    // nothing to update. return
    return;
  }

  var _addAriaDescribedBy = function _addAriaDescribedBy($elems, id) {
    LabelledByUtils._addRemoveAriaBy($elems, 'aria-describedby', id, true);
  };

  var _removeAriaDescribedBy = function _removeAriaDescribedBy($elems, id) {
    LabelledByUtils._addRemoveAriaBy($elems, 'aria-describedby', id, false);
  }; // callbacks for what needs to happen when the form compnent's describedBy property changes.


  var callbackObj = {
    callbackAdd: _addAriaDescribedBy,
    callbackRemove: _removeAriaDescribedBy
  };

  LabelledByUtils._byUpdatedTemplate(originalDescribedBy, newDescribedBy, $focusElem, callbackObj);
}; // Helper functions only called from within this file.

/**
 * Code that gets called when labelledBy or describedBy is updated that does the parsing
 * of the space-delimited attributes and figures out what ids are added and what ids are removed
 * from the originalValue to the newValue. Then it calls the callbackObj's functions to do the
 * particular work.
 * This function's main purpose is to reduce code duplication in this file in _describedByUpdated
 * and _LabelledByUpdated.
 * @param {string|null} originalValue the old value of the labelledBy/describedBy option
 * @param {string|null} newValue the new value of the labelledBy/describedBy option.
 * @param {jQuery} $focusElem jquery Object containing the node(s)
 * to add/remove aria-* to to.
 * @param {Object} callbackObj with parameters 'callbackAdd', 'callbackRemove' and optional 'args'
 * for additional arguments the callback function may need.
 * @private
 * @ignore
 *
 */


LabelledByUtils._byUpdatedTemplate = function (originalValue, newValue, $focusElem, callbackObj) {
  var byId;
  var tokens;
  var originalTokens;
  var i; // The most likely use case if originalLabelledBy is null. Check for that first.

  if (!originalValue && newValue) {
    // newValue can be a space-separated list of ids, so we need to split it and add the suffix
    // to each one and put it back into a space-separated list.
    tokens = newValue.split(/\s+/);

    for (i = 0; i < tokens.length; i++) {
      byId = tokens[i];
      callbackObj.callbackAdd.call(this, $focusElem, byId, callbackObj.args);
    }
  } else if (originalValue && !newValue) {
    // remove all
    tokens = originalValue.split(/\s+/);

    for (i = 0; i < tokens.length; i++) {
      byId = tokens[i];
      callbackObj.callbackRemove.call(this, $focusElem, byId, callbackObj.args);
    }
  } else if (originalValue && newValue) {
    // if both have values, then we should figure out which are the
    // same and ignore them, and remove the ones from originalLabelledBy that are unique and
    // add the ones for newLabelledBy that are unique.
    tokens = newValue.split(/\s+/);
    originalTokens = originalValue.split(/\s+/);

    for (i = 0; i < originalTokens.length; i++) {
      byId = originalTokens[i];

      if (newValue.indexOf(byId) === -1) {
        // not in both, so remove it (add the suffix)
        callbackObj.callbackRemove.call(this, $focusElem, byId, callbackObj.args);
      }
    }

    for (i = 0; i < tokens.length; i++) {
      byId = tokens[i];

      if (originalValue.indexOf(byId) === -1) {
        // not in both, so add it (add the suffix)
        callbackObj.callbackAdd.call(this, $focusElem, byId, callbackObj.args);
      }
    }
  }
};
/**
 * Add the id to the widget's aria-labelledby attribute.
 * @param {jQuery} $elems the jquery element(s) that represents the node on which aria-labelledby is
 * @param {string} id id to add to aria-labelledby
 * @private
 * @ignore
 */


LabelledByUtils._addAriaLabelledBy = function ($elems, id) {
  LabelledByUtils._addRemoveAriaBy($elems, 'aria-labelledby', id, true);
};
/**
 * Remove the id from the widget's aria-labelledby attribute.
 * @param {jQuery} $elems the jquery element(s) that represents the node on which aria-labelledby is
 * @param {string} id id to remove from aria-labelledby
 * @private
 * @ignore
 */


LabelledByUtils._removeAriaLabelledBy = function ($elems, id) {
  LabelledByUtils._addRemoveAriaBy($elems, 'aria-labelledby', id, false);
};
/**
 * Add 'data-oj-set-id' on oj-label, which in turn will
 * set described-by back on the Form component.
 * @param {string} ojLabelId the oj-label element's id.
 * @param {string} formComponentId the id of the form component
 * @private
 * @ignore
 */


LabelledByUtils._addSetIdOnLabel = function (ojLabelId, formComponentId) {
  var ojLabel = document.getElementById(ojLabelId);

  if (ojLabel) {
    if (!ojLabel.getAttribute('data-oj-set-id')) {
      ojLabel.setAttribute('data-oj-set-id', formComponentId);
    }
  }
};
/**
 * Remove 'data-oj-set-id' on oj-label, which in turn will
 * set described-by back on the Form component.
 * @param {string} ojLabelId the oj-label element's id.
 * @param {string} formComponentId the id of the form component
 * @param {boolean} add true if you want to add, false if you want to remove.
 * @private
 * @ignore
 */


LabelledByUtils._removeSetIdOnLabel = function (ojLabelId) {
  var ojLabel = document.getElementById(ojLabelId);

  if (ojLabel) {
    if (ojLabel.getAttribute('data-oj-set-id')) {
      ojLabel.removeAttribute('data-oj-set-id');
    }
  }
};
/**
 * Add or remove the aria- from the element(s).
 * @param {JQuery} $elems jquery Object containing the node(s) to add/remove ariaAttr to.
 * @param {string} ariaAttr aria attribute name 'aria-describedby' or 'aria-labelledby'
 * @param {string} id one id to add or remove to 'aria-describedby' or 'aria-labelledby'
 * @param {boolean} add if true, it will add the id, otherwise it will remove it.
 * @private
 * @ignore
 *
 */


LabelledByUtils._addRemoveAriaBy = function ($elems, ariaAttr, id, add) {
  $elems.each(function () {
    // get ariaAttr that is on the content element(s)
    var ariaAttributeValue = this.getAttribute(ariaAttr); // split into tokens

    var tokens = ariaAttributeValue ? ariaAttributeValue.split(/\s+/) : []; // Get index that id is in the tokens, if at all.

    var index = tokens.indexOf(id); // add id if it isn't already there, remove id if it is there.

    if (add && index === -1) {
      tokens.push(id);
    } else if (!add && index !== -1) {
      // remove that from the tokens array
      tokens.splice(index, 1);
    }

    var newValue = tokens.join(' ').trim();

    if (newValue) {
      this.setAttribute(ariaAttr, newValue); // @HTMLUpdateOK
    } else {
      this.removeAttribute(ariaAttr);
    }
  });
};

  ;return LabelledByUtils;
});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

 
define('ojs/ojeditablevalue',['ojs/ojcore', 'jquery', 'hammerjs', 'ojs/ojtranslation', 'ojs/ojcontext', 'ojs/ojthemeutils', 'ojs/ojcomponentcore', 'ojs/ojanimation', 'ojs/ojmessaging', 'ojs/ojconverterutils', 'ojs/ojvalidator-required',
'ojs/ojlogger', 'ojs/ojlabelledbyutils', 'ojs/ojvalidation-error', 'ojs/ojjquery-hammer', 'ojs/ojpopup', 'ojs/ojlabel'], 
  /*        
    * @param {Object} oj         
    * @param {jQuery} $        
    * @param {Object} Hammer        
  */
function(oj, $, Hammer, Translations, Context, ThemeUtils, Components, AnimationUtils, Message, ConverterUtils, RequiredValidator, Logger, LabelledByUtils)
{
  "use strict";
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }



/* global Promise:false, ConverterUtils:false, Logger:false, Context:false, ThemeUtils:false, */

/**
 * @class oj.EditableValueUtils
 * @classdesc JET Editable Component Utils
 * @export
 * @since 0.6.0
 * @hideconstructor
 * @ignore
 *
 */
oj.EditableValueUtils = {}; // S T A T I C    V A R S

/**
 * The various contexts under which validation can be run by component.
 * @ignore
 */

oj.EditableValueUtils.validationContext = {
  COMPONENT_CREATE: 1,
  CONVERTER_OPTION_CHANGE: 2,
  DISABLED_OPTION_CHANGE: 3,
  READONLY_OPTION_CHANGE: 4,
  REFRESH_METHOD: 5,
  REQUIRED_OPTION_CHANGE: 6,
  RESET_METHOD: 7,
  USER_ACTION: 8,
  VALIDATE_METHOD: 9,
  VALIDATORS_OPTION_CHANGE: 10,
  VALUE_OPTION_CHANGE: 11
};
/**
 * Default validation options used by validate method.
 * @ignore
 */

oj.EditableValueUtils.validateMethodOptions = {
  doValueChangeCheck: false,
  validationContext: oj.EditableValueUtils.validationContext.VALIDATE_METHOD
};
/**
 * Default validation options used when converter option changes
 * @ignore
 */

oj.EditableValueUtils.converterOptionOptions = {
  doValueChangeCheck: false,
  doNotClearMessages: true,
  validationContext: oj.EditableValueUtils.validationContext.CONVERTER_OPTION_CHANGE
};
/**
 * Default validation options used when disabled option changes
 * @ignore
 */

oj.EditableValueUtils.disabledOptionOptions = {
  doValueChangeCheck: false,
  doNotClearMessages: true,
  validationContext: oj.EditableValueUtils.validationContext.DISABLED_OPTION_CHANGE
};
/**
 * Default validation options used when required option changes
 * @ignore
 */

oj.EditableValueUtils.requiredOptionOptions = {
  doValueChangeCheck: false,
  doNotClearMessages: true,
  validationContext: oj.EditableValueUtils.validationContext.REQUIRED_OPTION_CHANGE
};
/**
 * Default validation options used when readOnly option changes
 * @ignore
 */

oj.EditableValueUtils.readOnlyOptionOptions = {
  doValueChangeCheck: false,
  doNotClearMessages: true,
  validationContext: oj.EditableValueUtils.validationContext.READONLY_OPTION_CHANGE
};
/**
 * Default validation options used when refresh method is called.
 * @ignore
 */

oj.EditableValueUtils.refreshMethodOptions = {
  doValueChangeCheck: false,
  doNotClearMessages: true,
  validationContext: oj.EditableValueUtils.validationContext.REFRESH_METHOD
};
/**
 * Default validation options used when validators option changes
 * @ignore
 *  */

oj.EditableValueUtils.validatorsOptionOptions = {
  doValueChangeCheck: false,
  doNotClearMessages: true,
  validationContext: oj.EditableValueUtils.validationContext.VALIDATORS_OPTION_CHANGE
};
/**
* String used in the id on the span that surrounds the help icon.
* @const
* @private
* @ignore
* @type {string}
*/

var _REQUIRED_ICON_ID = '_requiredIcon';
/**
* Enum for validate() return values
* @const
* @ignore
*/

oj.EditableValueUtils.VALIDATE_VALUES = {
  VALID: 'valid',
  INVALID: 'invalid'
};
/**
 * This method is called during _InitOptions() to initialize a component option value from DOM. This
 * uusally is the case when the option value is undefined,
 * i.e., this.options.optionName === undefined.
 * <br/>
 * Returns the attribute value for the given attribute on the element appropriately converted, or
 * the default, if the attribute isn't set on the element.<br/>
 *
 * @param {Object} element the element the component is initialized with.
 * @param {string} attribute the name of the element's attribtue. Example, value, disabled etc.
 *
 * @returns {Object} a JSON object containing the following properties - <br/>
 * <ul>
 * <li><b>fromDom</b> - whether the option value was initialized from DOM. When true the option's
 * value is written back (to observable).</li>
 * <li><b>value</b> - the option value. the attribute value or the default if the attribute isn't
 * set on the element.</li>
 * </ul>
 *
 * @private
 */

oj.EditableValueUtils.getAttributeValue = function (element, attribute) {
  var result;
  var returnVal = {};

  if (element && attribute) {
    var elem = element[0];

    switch (attribute) {
      case 'disabled':
        result = elem.hasAttribute('disabled') ? !!elem.disabled : undefined;
        break;

      case 'pattern':
        result = elem.pattern || undefined;
        break;

      case 'placeholder':
        result = elem.placeholder || undefined;
        break;

      case 'readonly':
        result = elem.hasAttribute('readonly') ? !!elem.readOnly : undefined;
        break;

      case 'required':
        // If attribute is present
        //   - if the required property is undefined then return true since the attribute is set.
        //   - Otherwise set to !!propVal
        if (elem.hasAttribute('required')) {
          var propVal = elem.required;

          if (propVal !== undefined) {
            result = !!propVal;
          } else {
            result = true; // any attribute value indicates true, even required='false'
          }
        } else {
          result = undefined;
        }

        break;

      case 'title':
        result = elem.hasAttribute('title') ? elem.title : undefined;
        break;

      case 'value':
        // element attribute may not be set, in which case default to null
        result = element.val() || undefined;
        break;

      case 'min':
      case 'max':
      default:
        // same logic for min + max as in default
        result = elem.getAttribute(attribute) || undefined;
        break;
    }
  }

  if (result !== undefined) {
    returnVal.fromDom = true;
    returnVal.value = result;
  } else {
    returnVal.fromDom = false; // returnVal.value = defaultValue;
  }

  return returnVal;
};
/**
 * NOTE: This is unnecessary to call for custom elements.
 * Called from component._InitOptions() with an array of options
 * that the component might need to initialize from DOM (e.g.,
 * disabled, required, title, etc). This function loops through each of these and if the
 * constructorOptions[option] is undefined, it tries to get the option from DOM.
 * The constructorOptions hold the options that the page author sets on the component, usually via
 * knockout bindings, and that takes precedence over DOM.
 * e.g., <input id="id" type="text" required data-bind="ojComponent: {component: 'ojInputText',
                                  value: value}"/>
 * value is a constructorOption and required is a DOM option in this example. If you have:
 * e.g., <input id="id" type="text" required data-bind="ojComponent: {component: 'ojInputText',
                                  value: value, required: false}"/>
 * required is both a constructorOption of false and a DOM of true. The constructorOption takes
 * precedence.
 * <p>
 * IMPORTANT: Do not call this method after component has been created, since option values are
 * mutated directly after that point.</p>
 *
 * The 'final' value an option uses/initializes from, can come from these places (in order of least
 * to most likely) - <br/>
 * <ol>
 * <li>component default - this is the widget default </li><br/>
 * <li>app default - this is what a page author defines for the value in the page/app</li> <br/>
 * <li>dom value - if your option also has a dom attribute, this is the value set on element for
 * component. </li> <br/>
 * <li>constructor value - this is the value page author sets on the component binding </li><br/>
 * </ol>
 *
 * At the time _InitOptions is called, (1), (2) and (4) are merged, but this may not be the value a
 * component wants for the option, especially when (4) is undefined. For example, if these values
 * were set for a component - <br/>
 * (1) - 'foo'<br/>
 * (2) - 'bar'<br/>
 * (3) - 'lucy'<br/>
 * (4) - undefined<br/>
 * <p>
 * at the time _InitOptions is called, this.options.option is set to 'bar'. But because DOM value
 * wins over app default or component default, the component needs to check if the constructor value was
 * undefined and if so, set option to the dom value which is 'lucy' in this example. This is what
 * this function does.<br/>
 * This method always defaults the value to be - this.options.option -
 * because we think if neither (3) nor (4) is set, then the value from (2) should win. <br/>
 * </p>
 *
 * @param {Object} props Array holding Object-literal that a component provides
 * with the following properties that helps determine the final value for one or more options.
 *
 * @property {string} props.attribute - name of DOM attribute
 * @property {string|undefined} props.option - name of the option if different from attribute name.
 *
 * @property {Function|boolean|undefined} props.coerceDomValue - if the DOM value is set and
 * coercing the dom value is needed, then either set to boolean true, which uses the default
 * coercion rules for common attributes (a), or provide a custom callback (b). <p>
 * E.g., 'value' option for input number, input date etc. have special rules for coercing the value,
 *  so thse provide a custom callback. For common attributes like required and disabled, set the
 *  value to true so the default oj.EditableValueUtils#coerceDomValueForOption method gets used.
 *
 * @property {boolean|undefined} props.validateOption - if set to true, then it calls
 * oj.EditableValueUtils.validateValueForOption method to validate the option.
 *
 * @param {Object} constructorOptions the options set on the component instance, often using
 * component binding. (this is the value page author sets on the component binding)
 * @param {Object} comp component instance.
 * @param {Function=} postprocessCallback - optional callback that will receive a map of initialized
 * options for post-processing
 * @ignore
 * @public
 */


oj.EditableValueUtils.initializeOptionsFromDom = function (props, constructorOptions, comp, postprocessCallback) {
  var initializedOptions = {}; // Loop through props to initialize option

  for (var i = 0; i < props.length; i++) {
    var finalValue;
    var result;
    var prop = props[i];
    var attribute = prop.attribute;
    var option = prop.option || attribute;
    var coerceDomValue = prop.coerceDomValue;
    var validateOption = prop.validateOption;
    var element = comp.element;
    var previousValue = comp.options[option];
    /* The precedence for the value that an option uses is as follows from lowest to highest -
     *
     * (1) component default - this is the widget default, already merged in to comp.options
     * (2) app default - this is what a page author defines for the value in the page / app,
     * already merged in to comp.options
     * (3) dom value - if your option also has a dom attribute, this is the value set on element.
     * (4) constructor value - this is the value page author sets on the component binding, already
     * merged in to comp.options.
     *
     * When (4) is undefined then attempt to default from (3).
     */
    // Step 1: use DOM value

    if (constructorOptions[option] === undefined) {
      previousValue = comp.options[option];
      result = oj.EditableValueUtils.getAttributeValue(element, attribute); // if we are using domValue then coerce the dom value before writing to options and trigegr
      // option change so the value is written back (to ko)

      if (result.fromDom) {
        finalValue = result.value; // only required needs coercing so not bad

        if (coerceDomValue) {
          if (typeof coerceDomValue === 'boolean') {
            finalValue = oj.EditableValueUtils.coerceDomValueForOption(option, finalValue);
          } else if (typeof coerceDomValue === 'function') {
            finalValue = coerceDomValue.call(comp, finalValue);
          }
        }

        initializedOptions[option] = finalValue;
      }
    }

    var valueToValidate = option in initializedOptions ? initializedOptions[option] : previousValue; // Step 2: validate the option value if needed

    if (validateOption) {
      if (typeof validateOption === 'boolean') {
        oj.EditableValueUtils.validateValueForOption(option, valueToValidate);
      }
    }
  }

  if (postprocessCallback != null) {
    postprocessCallback(initializedOptions);
  }

  comp.option(initializedOptions, {
    _context: {
      writeback: true,
      internalSet: true
    }
  });
};
/**
 * Validates value set for the option and throws error if invalid.
 *
 * @param {string} option name of the option. Validates options common to all edtiableValue
 * holders.
 * @param {string|Object|boolean|number|undefined} value of the option that is validated
 *
 * @throws {Error} if option value is invalid
 * @public
 * @ignore
 */


oj.EditableValueUtils.validateValueForOption = function (option, value) {
  var error = false;

  switch (option) {
    case 'required':
      if (value !== null && typeof value !== 'boolean') {
        error = true;
      }

      break;

    case 'readOnly':
    case 'disabled':
      if (value !== null && typeof value !== 'boolean') {
        error = true;
      }

      break;

    default:
      break;
  }

  if (error) {
    throw new Error("Option '" + option + "' has invalid value set: " + value);
  }
};
/**
 * Coerces the dom value being used for the option, and throws error if invalid.
 *
 * @param {string} option name of the option.
 * @param {string|Object|boolean|number|null} domValue dom value that is being coerced to the
 * option value
 * @throws {Error} if domValue cannot be coerced appropriately
 * @public
 * @ignore
 */


oj.EditableValueUtils.coerceDomValueForOption = function (option, domValue) {
  var coerced = domValue;

  switch (option) {
    case 'required':
      coerced = !!domValue;
      break;

    default:
      break;
  }

  return coerced;
};
/**
 * set pickerAttributes on a popup picker
 *
 * @param {jQuery} picker popup picker
 * @param {Object} pickerAttributes supported attributes are class and style, which are appended to the picker class and style, if any.
 *
 * @ignore
 */


oj.EditableValueUtils.setPickerAttributes = function (picker, pickerAttributes) {
  //  - let the popup picker accept the custom css class name from the component
  if (picker && pickerAttributes) {
    var classValue = pickerAttributes.class;

    if (classValue) {
      var classes = classValue.split(' '); // IE11 doesn't support destructured parameters so we need to iterate across the list
      // of classes

      for (var i = 0, len = classes.length; i < len; ++i) {
        picker[0].classList.add(classes[i]);
      }
    }

    var styleValue = pickerAttributes.style;

    if (styleValue) {
      var pickerElem = picker[0];
      var currStyle = pickerElem.getAttribute('style');

      if (currStyle) {
        pickerElem.setAttribute('style', currStyle + ';' + styleValue); // @HTMLUpdateOK
      } else {
        pickerElem.setAttribute('style', styleValue); // @HTMLUpdateOK
      }
    }
  }
};
/**
 * Helper to see if a special property was set to indicate we definitely have no label.
 * This is a performance enhancement for the corner case where input components are rendered in a
 * ojTable. Input components rendered in an ojTable have no label so we don't need to waste time
 * looking for labels.
 * @param {jQuery} widget The component widget.
 * @return {boolean}
 * @ignore
 * @private
 */


oj.EditableValueUtils.hasNoLabelFlag = function (widget) {
  return widget[0].hasAttribute('data-oj-no-labelledby');
};
/**
 * Given the labelledBy (e.g., this.options.labelledBy), use this to
 * get the oj-label's label element's id when there is a for/id relationship
 * between the oj-label and the form component, but the form component wants to
 * write aria-labelledby on a div instead of using the for/id relationship in dom.
 * Some components need this information to
 * use as their aria-labelledby on their dom element(s) that takes focus. An example
 * is oj-switch and oj-slider which put display:none on its input and uses aria-labelledby
 * on its thumb.
 * This is the preferred way rather than using a 'for' attribute search to find the oj-label.
 * @param labelledBy
 * @param defaultLabelId
 * @return {string|null} return the string to use as the aria-labelledby on the form component's
 * focusable element. If oj-label doesn't exist, this will return null.
 * @ignore
 * @private
 */


oj.EditableValueUtils._getOjLabelAriaLabelledBy = function (labelledBy, defaultLabelId) {
  var ariaLabelledBy;

  var ojlabels = oj.EditableValueUtils._getCustomOjLabelElements(labelledBy);

  if (ojlabels) {
    ariaLabelledBy = '';

    for (var j = 0; j < ojlabels.length; j++) {
      var ojlabel = ojlabels[j];
      var oneLabelElementId = ojlabel.getAttribute('label-id');

      if (!oneLabelElementId) {
        var labelElement = ojlabel.querySelector('label');

        if (labelElement) {
          oneLabelElementId = labelElement.getAttribute('id');
        } else {
          // this is the case where the form component has
          // labelled-by pointing to oj-label that hasn't been
          // upgraded yet and doesn't have label-id on it.
          // this isn't the way the form component and its label
          // should be linked, but it is possible.
          ojlabel.setAttribute('label-id', defaultLabelId);
          oneLabelElementId = defaultLabelId;
        }
      }

      ariaLabelledBy += oneLabelElementId;

      if (j + 1 < ojlabels.length) {
        ariaLabelledBy += ' ';
      }
    }
  }

  return ariaLabelledBy;
};
/**
 * @ignore
 * @private
 */


oj.EditableValueUtils._getCustomOjLabelElements = function (labelledBy) {
  var labelElements = [];

  if (labelledBy) {
    // split into individual ids
    var split = labelledBy.split(/\s+/);

    for (var i = 0; i < split.length; i++) {
      var labelId = split[i];
      var labelElement = document.getElementById(labelId); // don't push any null elements. it's possible labelled-by element can't be found.

      if (labelElement) {
        labelElements.push(labelElement);
      } else {
        Logger.info('Cannot find oj-label with id ' + labelElement);
      }
    }
  }

  return labelElements;
};
/**
 * Called during component initialization for Custom form components so that
 * they will be associated with their oj-label element correctly.
 * It links oj-label and form control for accessibility reasons.
 *
 * Background of how oj-label and 'input' components are linked together for accessibility:
 * --------------------------------------------------------------------------------------
 * An application developer links oj-label with a 'form' component like this:
 * <oj-label id='foo' for='myinput'> to <oj-input-text id='myinput'>
 *
 * We render the aria and data-oj- attributes on the correct dom like this:
 * <oj-label id='foo' for='myinput' data-oj-input-id='myinput|input'>
 * <span id="foo|label_helpIcon"<label id='foo|label' for='myinput|input'>
 * <oj-input-text id='myinput' labelled-by='foo' described-by='foo|label_helpIcon'>
 * <input aria-describedby='foo|label_helpIcon'>
 * ---------------------------------------------------------------------------------------
 * Note: See also _labelledByUpdatedForInputComp. We need both this function
 * and that one because
 * we cannot guarantee the upgrade order of the oj-label and form component.
 * If oj-label is not upgraded at the time the form component is, then it is
 * possible that the labels cannot be found. If that's the case, then the oj-label will
 * write labelledBy on the form component, and the  _labelledByUpdatedForInputComp
 * will get called which calls _setDataOjInputIdAttrOnLabel.
 * @ignore
 * @private
 */


oj.EditableValueUtils._initInputIdLabelForConnection = function (contentElement, componentId, labelledBy) {
  if (componentId) {
    contentElement.setAttribute('id', componentId + '|input');

    if (labelledBy) {
      this._linkLabelForInputComp(labelledBy, contentElement.id);
    }
  }

  if (labelledBy) {
    this._setReadonlyDivLabelledBy(labelledBy);
  }
};
/**
 * This function is called when labelledBy option is changed
 * on the form components with inputs, like
 * oj-input-text. It links oj-label's internal for and input form control's id
 * without relying on property dom searches.
 * Note: See also _initInputIdLabelForConnection. We need both this function
 * and that one because
 * we cannot guarantee the upgrade order of the oj-label and form component.
 * @ignore
 * @private
 */


oj.EditableValueUtils._labelledByUpdatedForInputComp = function (labelledBy, contentElementId) {
  if (labelledBy) {
    if (contentElementId) {
      this._linkLabelForInputComp(labelledBy, contentElementId);
    }

    this._setReadonlyDivLabelledBy(labelledBy);
  } // update the required translation text since it could use label text
  // and if labelledBy changes, label text would have changed.


  if (this._IsRequired() && this.options.translations.required) {
    this._implicitReqValidator = null;

    this._getImplicitRequiredValidator();
  }
};
/**
 * @ignore
 * @private
 */


oj.EditableValueUtils._linkLabelForInputComp = function (labelledBy, contentElementId) {
  var ojlabels = oj.EditableValueUtils._getCustomOjLabelElements(labelledBy);

  if (ojlabels) {
    oj.EditableValueUtils._setDataOjInputIdAttrOnLabel(contentElementId, ojlabels);
  }
};
/**
 * This function is called when labelledBy option is changed
 * on the form components with inputs, like
 * oj-input-text, and during component init, to set aria-labelledby
 * on the readonly div, if the component has a readonly div.
 * @ignore
 * @private
 */


oj.EditableValueUtils._setReadonlyDivLabelledBy = function (labelledBy) {
  // don't call this function if labelledBy doesn't have a value.
  oj.Assert.assert(labelledBy);

  var readonlyElem = this._getReadonlyDiv();

  if (readonlyElem) {
    readonlyElem.setAttribute('aria-labelledby', labelledBy + '|label');
  }
};
/**
 * This function is called when readonly option changes from false to true
 * for readonly input components, or when the component is created.
 * @ignore
 * @private
 */


oj.EditableValueUtils._createOrUpdateReadonlyDiv = function (input) {
  var createConditions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  // create readonly div if it doesn't exist.
  var readonlyElem = this._getReadonlyDiv();

  if (!readonlyElem && createConditions) {
    readonlyElem = this._createReadonlyDiv(input);

    if (this.options.labelledBy) {
      this._setReadonlyDivLabelledBy(this.options.labelledBy);
    }

    this._setAriaLabelFromLabelHint();
  }

  if (readonlyElem) {
    readonlyElem.textContent = this._GetDisplayValue();
  }
};
/**
 * @ignore
 * @private
 */


oj.EditableValueUtils._setDataOjInputIdAttrOnLabel = function (contentElementId, ojlabels) {
  if (ojlabels) {
    for (var i = 0; i < ojlabels.length; i++) {
      var ojlabel = ojlabels[i]; // setting this will cause ojlabel to set its internal label element's for to this id.

      ojlabel.setAttribute('data-oj-input-id', contentElementId);
    }
  }
};
/**
 * Validates the component's display value using the converter and all validators registered on
 * the component and updates the <code class="prettyprint">value</code> option by performing the
 * following steps.
 *
 * <p>
 * <ol>
 * <li>All messages are cleared, including custom messages added by the app. </li>
 * <li>If no converter is present then processing continues to next step. If a converter is
 * present, the UI value is first converted (i.e., parsed). If there is a parse error then
 * messages are shown.</li>
 * <li>If there are no validators setup for the component the <code class="prettyprint">value</code>
 * option is updated using the display value. Otherwise all
 * validators are run in sequence using the parsed value from the previous step. The implicit
 * required validator is run first if the component is marked required. When a validation error is
 * encountered it is remembered and the next validator in the sequence is run. </li>
 * <li>At the end of validation if there are errors, the messages are shown.
 * If there were no errors, then the
 * <code class="prettyprint">value</code> option is updated.</li>
 * </ol>
 *
 * @example <caption>Validate component using its current value.</caption>
 * myComp.validate();
 *
 * @example <caption>Validate component and use the Promise's resolved state.</caption>
 * myComp.validate().then(
 *  function(result) {
 *    if(result === "valid")
 *    {
 *      submitForm();
 *    }
 *  });
 *
 *
 * @return {Promise} Promise resolves to "valid" if there were no converter parse errors and
 * the component passed all validations.
 * The Promise resolves to "invalid" if there were converter parse errors or
 * if there were validation errors.
 *
 * @ignore
 * @private
 */


oj.EditableValueUtils.validate = function () {
  var returnValue; // clear all messages; run full validation on display value
  // _SetValue returns boolean or Promise that resolves to a Boolean.

  returnValue = this._SetValue(this._GetDisplayValue(), null, this._VALIDATE_METHOD_OPTIONS);

  if (this._IsCustomElement()) {
    if (!(returnValue instanceof Promise)) {
      returnValue = Promise.resolve(returnValue ? 'valid' : 'invalid');
    } else {
      // convert true to 'valid' and false to 'invalid'
      return returnValue.then(function (booleanSetValueReturn) {
        return Promise.resolve(booleanSetValueReturn ? 'valid' : 'invalid');
      });
    }
  } else if (returnValue instanceof Promise) {
    return returnValue.then(function (booleanSetValueReturn) {
      return Promise.resolve(booleanSetValueReturn ? 'valid' : 'invalid');
    });
  }

  return returnValue;
};
/**
 * Refresh everything that needs refreshing when the required option is toggled:
 * refreshes theming, aria-required, label.
 *
 * Used by EditableValue components that support the required option.
 * The component links to this function like this:
 *   _refreshRequired : oj.EditableValueUtils._refreshRequired,
 * @param {Object=} value the current value of the required option
 * @private
 * @ignore
 */


oj.EditableValueUtils._refreshRequired = function (value) {
  var id;
  var contentNode;
  var ariaValue;

  var ariaRequiredUnsupported = this._AriaRequiredUnsupported();

  this._refreshTheming('required', value); // refresh aria-required
  // Most inputs/selects need aria-required on the input element (aka 'content')
  // But it is not legal to have aria-required on radio/checkboxes.


  if (!ariaRequiredUnsupported) {
    contentNode = this._GetContentElement();
    ariaValue = value; // (value == "required") ? true : false;

    if (ariaValue && contentNode) {
      contentNode[0].setAttribute('aria-required', ariaValue);
    } else {
      contentNode[0].removeAttribute('aria-required');
    }
  }

  if (!this._IsCustomElement()) {
    if (!this.$label) {
      this._createOjLabel();
    } // need to keep the label's required in sync with the input's required


    if (this.$label) {
      this.$label.ojLabel('option', 'showRequired', value); // in most cases aria-required is supported and that is what we do to get JAWS to say
      // "Required" on focus of the input. But in the case of a 'set' of items where one is required,
      // say radioset/checkboxset, what do we do? aria-required doesn't make sense (nor is it valid
      // as it fails validation in some accessibility validators) on each input, when really it is
      // one in the set that is required, not each one. This is what we are doing from v1 on: we
      // put aria-describedby to point to the required icon text.

      if (ariaRequiredUnsupported) {
        // if aria-labelledby is set,
        // add/remove aria-describedby to the inputs pointing to
        // the label+"_requiredIcon".
        var ariaLabelledByElem = this._getAriaLabelledByElement(this.element);

        if (ariaLabelledByElem !== null && ariaLabelledByElem.length !== 0) {
          id = ariaLabelledByElem[0].getAttribute('id');
        }

        if (id) {
          var ariaId = id + _REQUIRED_ICON_ID;

          if (value) {
            // adds
            this._describedByUpdated(null, ariaId);
          } else {
            // removes
            this._describedByUpdated(ariaId, null);
          }
        }
      }
    }
  }
};
/**
 * Performs post processing after required option is set by taking the following steps.
 *
 * - if component is invalid and has messgesShown -> required: false/true -> clear component errors;
 * run full validation with UI value (we don't know if the UI error is from a required validator
 * or something else);<br/>
 * &nbsp;&nbsp;- if there are validation errors, then value not pushed to model; messagesShown is
 * updated<br/>
 * &nbsp;&nbsp;- if no errors result from the validation, push value to model; author needs to
 * listen to optionChange(value) to clear custom errors.<br/>
 *
 * - if component is invalid and has messagesHidden -> required: false -> clear component
 * errors; no deferred validation is run.<br/>
 * - if component has no error -> required: true -> run deferred validation (we don't want to flag
 * errors unnecessarily)<br/>
 * - messagesCustom is never cleared<br/>
 *
 * @param {string} option
 *
 * @private
 * @ignore
 */
// eslint-disable-next-line no-unused-vars


oj.EditableValueUtils._AfterSetOptionRequired = function (option) {
  // refresh hints, theming and aria to reflect new state
  this._refreshRequired(this._IsRequired());

  this._runMixedValidationAfterSetOption(oj.EditableValueUtils.requiredOptionOptions);
};
/**
 * When validators option changes, take the following steps.
 *
 * - Clear the cached normalized list of all validator instances. push new hints to messaging.<br/>
 * - if component is valid -> validators changes -> no change<br/>
 * - if component is invalid has messagesShown -> validators changes -> clear all component
 * messages and re-run full validation on displayValue. if there are no errors push value to
 * model;<br/>
 * - if component is invalid has messagesHidden -> validators changes -> do nothing; doesn't change
 * the required-ness of component <br/>
 * - messagesCustom is not cleared.<br/>
 *
 * NOTE: The behavior applies to any option that creates implicit validators - min, max, pattern,
 * etc. Components can call this method when these options change.
 *
 * @returns {undefined}
 * @private
 * @ignore
 */


oj.EditableValueUtils._AfterSetOptionValidators = function () {
  var displayValue; // resets all validators and pushes new hints to messaging

  this._ResetAllValidators();

  if (this._hasInvalidMessagesShowing()) {
    this._clearComponentMessages();

    displayValue = this._GetDisplayValue(); // runs full validation on the display value. May be async

    this._SetValue(displayValue, null, oj.EditableValueUtils.validatorsOptionOptions);
  }
};
/**
 * When async-validators property changes, take the following steps.
 *
 * - Clear the cached normalized list of all async and sync validator instances.
 *  push new hints to messaging.<br/>
 * - if component is valid -> validators changes -> no change<br/>
 * - if component is invalid has messagesShown -> validators changes -> clear all component
 * messages and re-run full validation on displayValue. if there are no errors push value to
 * model;<br/>
 * - if component is invalid has messagesHidden -> validators changes -> do nothing; doesn't change
 * the required-ness of component <br/>
 * - messagesCustom is not cleared.<br/>
 *
 *
 * @returns {undefined}
 * @private
 * @ignore
 */


oj.EditableValueUtils._AfterSetOptionAsyncValidators = function () {
  // resets validators and pushes new hints to messaging
  this._AfterSetOptionValidators();
};
/**
 * Performs post processing after converter option changes by taking the following steps.
 *
 * - always push new converter hint to messaging <br/>
 * - if component has no errors -> refresh UI value<br/>
 * - if component is invalid has messagesShown -> clear all component errors and run full
 * validation using display value. <br/>
 * &nbsp;&nbsp;- if there are validation errors, value is not pushed to model; messagesShown is
 * updated.<br/>
 * &nbsp;&nbsp;- if no errors result from the validation, push value to model; author needs to
 * listen to optionChange(value) to clear custom errors.<br/>
 * - if component is invalid has messagesHidden -> refresh UI value. no need to run deferred
 * validations. <br/>
 * - messagesCustom is never cleared<br/>
 *
 * @param {String} option
 *
 * @returns {undefined}
 * @private
 * @ignore
 */
// called when 'converter' option changed, usually from option/setOption calls


oj.EditableValueUtils._AfterSetOptionConverter = function () {
  // clear the cached converter instance and push new hint to messaging
  this._converter = null;
  this._converterChangedCounter += 1;

  var converter = this._GetConverter();

  if (converter instanceof Promise) {
    var self = this;

    this._setBusyStateAsyncConverterLoading();

    var converterCounter = this._converterChangedCounter;

    this._loadingConverter(converter).then(function () {
      if (converterCounter === self._converterChangedCounter) {
        self._ResetConverter();
      }

      self._clearBusyStateAsyncConverterLoading();
    });
  } else {
    this._ResetConverter();
  }
};
/**
 * Performs post processing after we have the loaded converter
 * during component initialization.
 *
 * @returns {undefined}
 * @private
 * @ignore
 */


oj.EditableValueUtils._AfterCreateConverterCached = function () {
  // we do this here for a couple reasons
  // 1. because here we have the final value; an empty placeholder
  // shows up if data changed after first binding. 
  // 2. we do not want the placeholder displayed while the loading
  // indication is showing.
  if (this._HasPlaceholderSet()) {
    // update element placeholder
    this._SetPlaceholder(this.options.placeholder);

    this._customPlaceholderSet = true;
  } // can't show validator hints or converter hints until we have the converter
  // because some validators have the converter as an option.


  this._initComponentMessaging(this._MESSAGING_CONTENT_UPDATE_TYPE.ALL); // need a converter to format the value


  this._Refresh('value', this.options.value, false); // trigger messagesShownChanged for messagesShown if it's non-empty.
  // this.options['messagesShown'] would have been
  // updated in _ComponentCreate if messagesCustom was non-empty. Because we are setting
  // the 'changed' flag to true, the messagesShownChanged event will be fired, and that's what we want.


  if (this.options.messagesShown.length > 0) {
    this._setMessagesOption('messagesShown', this.options.messagesShown, null, true);
  }
};
/**
 * Called when converter option changes and we have the new converter.
 *
 * @private
 * @ignore
 */


oj.EditableValueUtils._ResetConverter = function () {
  var displayValue;

  this._getComponentMessaging().update(this._getMessagingContent(this._MESSAGING_CONTENT_UPDATE_TYPE.CONVERTER_HINT));

  if (this._hasInvalidMessagesShowing()) {
    this._clearComponentMessages();

    displayValue = this._GetDisplayValue(); // runs full validation on the display value. May be async

    this._SetValue(displayValue, null, oj.EditableValueUtils.converterOptionOptions);
  } else {
    // refresh UI display value when there was no need to run full validation
    this._Refresh('converter', this.options.converter, true);
  }
};
/**
 * Returns an array of all validators built by merging the validators option set on the component
 * and the implicit validators setup by the component. <br/>
 * This does not include the implicit required validator. Components can override to add to this
 * array of validators.
 *
 * @return {Array} of validators
 *
 * @private
 * @ignore
 */


oj.EditableValueUtils._GetNormalizedValidatorsFromOption = function () {
  var i;
  var isValidatorInstance = true;
  var normalizedValidators = [];
  var validator;
  var validatorsOption;
  var vOptions;
  var vType;
  var vTypeStr;
  validatorsOption = this.options.validators;

  if (validatorsOption) {
    // Normalize validators
    for (i = 0; i < validatorsOption.length; i++) {
      validator = validatorsOption[i];

      if (_typeof(validator) === 'object') {
        // check if we have an actual validator instance that implements the validate() method
        // oj.Validation.__doImplementsCheck(validator, oj.Validator);
        if (!(validator.validate && typeof validator.validate === 'function')) {
          isValidatorInstance = false;
        }

        if (!isValidatorInstance) {
          // we maybe dealing with an object literal
          // {'type': 'numberRange', 'options': { 'min': 100, 'max': 1000,
          //                                    'hint': {'min': 'some hint about min'}}}
          vTypeStr = validator.type;

          if (vTypeStr && typeof vTypeStr === 'string') {
            if (oj.Validation && oj.Validation.validatorFactory) {
              vType = oj.Validation.validatorFactory(vTypeStr);
            } else {
              Logger.error('oj.Validation.validatorFactory is not available and it is needed to support the deprecated json format for validators property. Please include the backward compatibility "ojvalidation-base" module.');
            }

            if (vType) {
              vOptions = oj.CollectionUtils.copyInto({}, validator.options) || {}; // we push converter into the options if not provided explicitly. This is to allow
              // validators to format values shown in the hint and messages

              vOptions.converter = vOptions.converter || this._GetConverter();
              vOptions.label = vOptions.label || this._getLabelText();
              validator = vType.createValidator(vOptions);
            }
          }
        }

        normalizedValidators.push(validator);
      } else {
        Logger.error('Unable to parse the validator provided:' + validator);
      }
    }
  }

  return normalizedValidators;
};
/**
 * Returns an array of all async validators built by the async-validators attribute
 * set on the component. In this release, Objects that have validate method (
 * and also they could have a hint property) are considered AsyncValidators and
 * AsyncValidator Objects. In future releases we will allow Objects with types, like
 * {'type': 'numberRange',
 * 'options': { 'min': 100, 'max': 1000, 'hint': {'min': 'some hint about min'}}}
 *
 * @return {Array} of async validators
 *
 * @private
 * @ignore
 */


oj.EditableValueUtils._GetNormalizedAsyncValidatorsFromOption = function () {
  var i;
  var normalizedValidators = [];
  var validator;
  var validatorsOption;
  validatorsOption = this.options.asyncValidators; // Normalize validators

  for (i = 0; i < validatorsOption.length; i++) {
    validator = validatorsOption[i];

    if (_typeof(validator) === 'object') {
      // check if we have an actual asyncvalidator object that implements the validate() method
      if (validator.validate && typeof validator.validate === 'function') {
        normalizedValidators.push(validator);
      }
    } else {
      Logger.error('Unable to parse the validator provided:' + validator);
    }
  }

  return normalizedValidators;
};
/**
 * Returns the normalized converter instance.
 * This could return a Promise during component initialization or when changing the
 * component's converter property.
 *
 * @return {Object|null|Promise<Object>|Promise<null>} a converter instance or null
 * or a Promise to a converter instance or null.
 *
 * @private
 * @ignore
 */


oj.EditableValueUtils._GetConverter = function () {
  var converterOption;
  var converterInstanceReturn;
  var self = this;
  var converterPromise; // this._converter holds the instance

  if (!this._converter) {
    converterOption = this.options.converter;

    if (converterOption instanceof Promise) {
      converterPromise = converterOption;
    } else {
      converterInstanceReturn = ConverterUtils.getConverterInstance(converterOption);
    }

    if (converterPromise) {
      return converterPromise.then(function (ci) {
        self._converter = ci;
        return self._converter || null;
      });
    }

    this._converter = converterInstanceReturn;
  }

  return this._converter || null;
};
/**
 * Set busy state for component for async validators for the displayValue.
 * We want to clear busy state for the same displayValue, not for a different displayValue.
 * I suppose if they type in 111, then 222, then 111, we may clear for second 111 before first,
 * but that seems incredibly unlikely.
 * @param {string} displayValue the displayValue busystate we want to set
 *
 * @private
 * @ignore
 */


oj.EditableValueUtils._SetBusyState = function (displayValue) {
  if (this._resolveBusyStateAsyncMap === undefined) {
    // eslint-disable-next-line no-undef
    this._resolveBusyStateAsyncMap = new Map();
  }

  var resolveBusyStateAsync = this._resolveBusyStateAsyncMap.get(displayValue); // Set a page-level busy state if not already set for this displayValue


  if (!resolveBusyStateAsync) {
    var domElem = this.element[0];
    var busyContext = Context.getContext(domElem).getBusyContext();
    var description = 'The page is waiting for async validators for displayValue ' + displayValue;

    if (domElem && domElem.id) {
      description += ' for "' + domElem.id + '" ';
    }

    description += 'to finish.';
    resolveBusyStateAsync = busyContext.addBusyState({
      description: description
    });

    this._resolveBusyStateAsyncMap.set(displayValue, resolveBusyStateAsync);
  }
};
/**
 * Clear busy state for async validators for the displayValue.
 * @param {string} displayValue the displayValue busystate we want to clear
 * @private
 * @ignore
 */


oj.EditableValueUtils._ClearBusyState = function (displayValue) {
  var resolveBusyStateAsync;

  if (this._resolveBusyStateAsyncMap !== undefined) {
    resolveBusyStateAsync = this._resolveBusyStateAsyncMap.get(displayValue);

    if (resolveBusyStateAsync) {
      resolveBusyStateAsync();

      this._resolveBusyStateAsyncMap.delete(displayValue);
    }
  }
};
/**
 * Set busy state for component for async validators hint.
 * We want to clear busy state for the same hint not for a different hint.
 * I use a counter here.
 * @param {number} counter the counter for the busystate we want to set
 *
 * @private
 * @ignore
 */


oj.EditableValueUtils._SetBusyStateAsyncValidatorHint = function (counter) {
  if (this._resolveBusyStateAsyncValidatorHintMap === undefined) {
    // eslint-disable-next-line no-undef
    this._resolveBusyStateAsyncValidatorHintMap = new Map();
  }

  var resolveBusyStateAsyncHint = this._resolveBusyStateAsyncValidatorHintMap.get(counter); // Set a page-level busy state if not already set for this counter


  if (!resolveBusyStateAsyncHint) {
    var domElem = this.element[0];
    var busyContext = Context.getContext(domElem).getBusyContext();
    var description = 'The page is waiting for async validator hint for counter ' + counter;

    if (domElem && domElem.id) {
      description += ' for "' + domElem.id + '" ';
    }

    description += 'to finish.';
    resolveBusyStateAsyncHint = busyContext.addBusyState({
      description: description
    });

    this._resolveBusyStateAsyncValidatorHintMap.set(counter, resolveBusyStateAsyncHint);
  }
};
/**
 * Clear busy state for async validators hint for the counter
 * @param {number} counter the counter for the busystate we want to clear
 * @private
 * @ignore
 */


oj.EditableValueUtils._ClearBusyStateAsyncValidatorHint = function (counter) {
  var resolveBusyStateAsyncHint;

  if (this._resolveBusyStateAsyncValidatorHintMap !== undefined) {
    resolveBusyStateAsyncHint = this._resolveBusyStateAsyncValidatorHintMap.get(counter);

    if (resolveBusyStateAsyncHint) {
      resolveBusyStateAsyncHint();

      this._resolveBusyStateAsyncValidatorHintMap.delete(counter);
    }
  }
};
/**
 * Set busy state for component for async converter loading.
 *
 * @private
 * @ignore
 */


oj.EditableValueUtils._SetBusyStateAsyncConverterLoading = function () {
  // Set a page-level busy state if not already set for async converter loading
  if (!this._resolveBusyStateAsyncConverterLoading) {
    var domElem = this.element[0];
    var busyContext = Context.getContext(domElem).getBusyContext();
    var description = 'The page is waiting for async converter loading ';

    if (domElem && domElem.id) {
      description += 'for "' + domElem.id + '" ';
    }

    description += 'to finish.';
    this._resolveBusyStateAsyncConverterLoading = busyContext.addBusyState({
      description: description
    });
  }
};
/**
 * Clear busy state for async converter loading
 * @private
 * @ignore
 */


oj.EditableValueUtils._ClearBusyStateAsyncConverterLoading = function () {
  if (this._resolveBusyStateAsyncConverterLoading !== undefined) {
    this._resolveBusyStateAsyncConverterLoading();

    delete this._resolveBusyStateAsyncConverterLoading;
  }
};
/**
 * Retrieve the delay before showing status
 * @return {number} the delay in ms
 * @private
 * @ignore
 */


oj.EditableValueUtils._getShowLoadingDelay = function () {
  if (this._defaultOptions == null) {
    this._defaultOptions = ThemeUtils.parseJSONFromFontFamily('oj-form-control-option-defaults');
  }

  var delay = parseInt(this._defaultOptions.showIndicatorDelay, 10);
  return isNaN(delay) ? 0 : delay;
};
/**
 * Set the type of the input element based on virtualKeyboard option.
 *
 * @param {Array.<string>} allowedTypes an array of allowed types
 *
 * @protected
 * @ignore
 */


oj.EditableValueUtils._SetInputType = function (allowedTypes) {
  // Default input type is text
  var inputType = 'text';
  var agentInfo = oj.AgentUtils.getAgentInfo(); // Only change the type on mobile browsers

  if (agentInfo.os === oj.AgentUtils.OS.ANDROID || agentInfo.os === oj.AgentUtils.OS.IOS || agentInfo.os === oj.AgentUtils.OS.WINDOWSPHONE) {
    // Get input type from component's virtualKeyboard option
    if (allowedTypes.indexOf(this.options.virtualKeyboard) >= 0) {
      inputType = this.options.virtualKeyboard;
    } else {
      // Get input type from converter's virtualKeyboardHint option
      var converter = this._GetConverter();

      if (converter && converter.resolvedOptions) {
        var resOptions = converter.resolvedOptions();

        if (allowedTypes.indexOf(resOptions.virtualKeyboardHint) >= 0) {
          inputType = resOptions.virtualKeyboardHint;
        }
      }
    }
  }

  if (inputType == null) {
    this.element[0].removeAttribute('type');
  } else {
    this.element[0].setAttribute('type', inputType);
  }
};
/**
 * Draw a readonly div. When readonly, this div is shown and
 * the input has display:none on it through theming, and vice versa.
 * We set the textContent in _SetDisplayValue() if readonly
 * @param {HTMLElement} pass in this.element[0]
 * @return {HTMLElement|null} the readonlyDivElem or null if we don't want
 * to use a readonly div.
 * @private
 * @ignore
 */


oj.EditableValueUtils._createReadonlyDiv = function (element) {
  if (this._UseReadonlyDiv()) {
    var readonlyElem = document.createElement('div');
    readonlyElem.classList.add('oj-text-field-readonly-div'); // create this inner element that holds the text.  This is needed
    // so that we can put flexbox styles on the oj-text-field-readonly-div
    // to have the text vertically centered in the div.

    var readonlyInnerElem = document.createElement('div');
    readonlyInnerElem.classList.add('oj-text-field-readonly'); // for accessibility you need to be able to tab into a readonly field.

    readonlyInnerElem.setAttribute('tabindex', '0');
    readonlyInnerElem.setAttribute('role', 'textbox');
    readonlyInnerElem.setAttribute('aria-readonly', true);
    readonlyElem.appendChild(readonlyInnerElem);
    element.parentNode.insertBefore(readonlyElem, element); // @HTMLUpdateOK
    // return the element that we need to set textContent, aria-labelledby, etc.

    return readonlyInnerElem;
  }

  return null;
};
/**
 * Returns the inner readonly div HTMLElement that we need to set textContent,
 * aria-labelledby, etc.
 * @private
 * @ignore
 */


oj.EditableValueUtils._getReadonlyDiv = function () {
  return this.widget()[0].querySelector('.oj-text-field-readonly');
};



/* jslint browser: true*/

/**
 * Base class for rendering the 'inside' labels. This is so InsideLabelStrategy
 * and InsideFormControlLabelStrategy can share code.
 * Extends the MessagingStrategy which does more now than messages. It now
 * is also for rendering the form component's label in one of many positions.
 *
 * @extends {oj.MessagingStrategy}
 * @protected
 * @constructor
 * @since 8.0.0
 * @class BaseInsidelLabelStrategy
 * @ignore
 * @ojtsignore
 * @param {Array.<string>} options an array of messaging artifacts that are
 * displayed as an inside label for non-text field form controls.
 * For LabelStrategies this is always only labelEdge.
 */
var BaseInsidelLabelStrategy = function BaseInsidelLabelStrategy(options) {
  this.Init(options);
}; // Subclass from oj.MessagingStrategy


oj.Object.createSubclass(BaseInsidelLabelStrategy, oj.MessagingStrategy, 'BaseInsidelLabelStrategy');
/**
 * Adds a hook for subclass to use its own styleclass on root dom element.
 * @memberof BaseInsidelLabelStrategy
 * @instance
 * @protected
 */

BaseInsidelLabelStrategy.prototype._GetFormControlLabelStyleClass = function () {
  return 'oj-form-control-label-inside';
};
/**
 * Creates the label adding associated event listeners for applying
 * marker selectors to the root and responding to label-hint
 * and other component property changes.
 * @memberof BaseInsidelLabelStrategy
 * @instance
 * @protected
 */


BaseInsidelLabelStrategy.prototype._CreateLabel = function () {
  var component = this.GetComponent();

  var container = this._GetContainer(component); // could be overwritten. InsideLabelStrategy.


  if (!container) return;
  var options = component.options;

  var element = component._getRootElement(); // could be overwritten ,e.g., _getBaseLabelSelector


  var labelStyleClass = this._GetFormControlLabelStyleClass();

  element.classList.add(labelStyleClass);
  this.GenerateIdIfNeeded(element);
  this._showUserAssistanceNotInline = component._showUserAssistanceNotInline();
  var renderRequiredIcon = options.required && this._showUserAssistanceNotInline; // for 'inside labels' we do not show help on the label.

  this._createOjLabelElement(element, component, container, options.labelHint, renderRequiredIcon, options.helpHints, this._showUserAssistanceNotInline);
};
/**
 * @memberof BaseInsidelLabelStrategy
 * @instance
 * @private
 * @param {Element} label oj-label element
 * @param {CustomEvent} event requiredChanged event
 */


BaseInsidelLabelStrategy.prototype._createOjLabelElement = function (element, component, container, labelHint, showRequired, helpHintsAttrValue, showUserAssistanceOnLabel) {
  var ojlabel = document.createElement('oj-label');
  ojlabel.id = BaseInsidelLabelStrategy._getLabelId(element);
  ojlabel.setAttribute('data-oj-binding-provider', 'none');
  ojlabel.setAttribute('data-oj-internal', ''); // associate with form component

  ojlabel.setAttribute('for', element.id);
  var defaultLabelStyleClass = [component._GetDefaultStyleClass(), 'label'].join('-');
  ojlabel.classList.add(defaultLabelStyleClass);

  if (showRequired) {
    ojlabel.setAttribute('show-required', showRequired);
  }

  if (showUserAssistanceOnLabel && helpHintsAttrValue) {
    ojlabel.help = helpHintsAttrValue;
  } // add labelHint


  var span = document.createElement('span');
  span.id = [element.id, '|hint'].join('');
  span.innerText = labelHint; // add to dom and create event handlers

  ojlabel.appendChild(span);

  this._InsertOjLabel(ojlabel, container, component);

  this._CreateEventHandlers(span, element, ojlabel, component);
};
/**
 * Gets the form component's container. Could be overwritten to have more
 * logic to get the container.
 * @memberof BaseInsidelLabelStrategy
 * @instance
 * @protected
 */


BaseInsidelLabelStrategy.prototype._GetContainer = function (component) {
  return component._GetFormControlContainer();
};
/**
 * Creates event handlers
 * Override if there are more event listeners to create
 * Components with label-hint and label-edge of none or inside create
 * their own labels in this strategy, and when they do we listen for
 * attribute changes so we can deal with them and update the label accordingly.
 * If the oj-form-layout creates the label (top/start), then similar event listeners
 * are created there in ojformlayout.
 * @param {Element} span span around the label where we use innerText to set the labelHint
 * @param {Element} element root custom element
 * @param {Element} ojlabel ojlabel custom element
 * @param {Element} component form component
 * @memberof BaseInsidelLabelStrategy
 * @instance
 * @protected
 */


BaseInsidelLabelStrategy.prototype._CreateEventHandlers = function (span, element, ojlabel, component) {
  this._labelHintChangedCallback = BaseInsidelLabelStrategy._labelHintChangedHandler.bind(this, span);
  element.addEventListener('labelHintChanged', this._labelHintChangedCallback);
  this._requiredChangedCallback = BaseInsidelLabelStrategy._requiredChangedHandler.bind(this, ojlabel, component);
  element.addEventListener('requiredChanged', this._requiredChangedCallback);
  this._helpHintsChangedCallback = BaseInsidelLabelStrategy._helpHintsChangedHandler.bind(this, ojlabel, component);
  element.addEventListener('helpHintsChanged', this._helpHintsChangedCallback);
};
/**
 * Removes the fixed label unregistering associated event listeners.
 * @memberof BaseInsidelLabelStrategy
 * @instance
 * @private
 */


BaseInsidelLabelStrategy.prototype._DestroyLabel = function () {
  var component = this.GetComponent();
  var options = component.options;

  var element = component._getRootElement();

  var labelStyleClass = this._GetFormControlLabelStyleClass(); // override


  element.classList.remove(labelStyleClass);

  var labelId = BaseInsidelLabelStrategy._getLabelId(element); // no need to override


  var ojlabel = document.getElementById(labelId);

  if (ojlabel) {
    ojlabel.for = ''; // Triggers code to unlink the oj-label from its form component

    ojlabel.parentElement.removeChild(ojlabel);
  }

  options.labelledBy = undefined;

  this._DeleteEventHandlers(element);
};
/**
 * Removes the event handlers
 * Override if there are more event handlers to delete
 * @param {Element} element root custom element
 * @memberof BaseInsidelLabelStrategy
 * @instance
 * @protected
 */


BaseInsidelLabelStrategy.prototype._DeleteEventHandlers = function (element) {
  element.removeEventListener('labelHintChanged', this._labelHintChangedCallback);
  element.removeEventListener('requiredChanged', this._requiredChangedCallback);
  element.removeEventListener('helpHintsChanged', this._helpHintsChangedCallback);
  delete this._helpHintsChangedCallback;
  delete this._labelHintChangedCallback;
  delete this._requiredChangedCallback;
};
/**
 * @static
 * @private
 * @param {Element} element root custom element
 * @return {string} fixed label id
 */


BaseInsidelLabelStrategy._getLabelId = function (element) {
  return [element.id, '-labelled-by'].join('');
};
/**
 * @static
 * @private
 * @param {Element} span holding label text
 * @param {CustomEvent} event labelChanged event
 */


BaseInsidelLabelStrategy._labelHintChangedHandler = function (span, event) {
  // eslint-disable-next-line no-param-reassign
  span.innerText = event.detail.value;
};
/**
 * @static
 * @private
 * @param {Element} label oj-label element
 * @param {CustomEvent} event requiredChanged event
 */


BaseInsidelLabelStrategy._requiredChangedHandler = function (label, component, event) {
  // we show required on label if compact and not when inline, for example.
  // get it here and cache it if it doesn't exist.
  if (this._showUserAssistanceNotInline == null) {
    this._showUserAssistanceNotInline = component._showUserAssistanceNotInline();
  } // eslint-disable-next-line no-param-reassign


  label.showRequired = event.detail.value && this._showUserAssistanceNotInline;
};
/**
 * helpHints attribute changed on form component, so update help icon on label if it is there.
 * (it could be inline to the component and not on label, if so, see InlineHelpHintsStrategy)
 * @static
 * @private
 * @param {Element} label oj-label element
 * @param {CustomEvent} event helpHintsChanged event
 */


BaseInsidelLabelStrategy._helpHintsChangedHandler = function (label, component, event) {
  this._showUserAssistanceNotInline = component._showUserAssistanceNotInline();

  if (this._showUserAssistanceNotInline) {
    // eslint-disable-next-line no-param-reassign
    label.help = event.detail.value;
  }
};

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }



/* global Promise:false, RequiredValidator:false, Components:false, Message:false, Logger:false, Context:false, Translations:false, ThemeUtils: false, LabelledByUtils:false */

/**
 * The various validation modes
 * @ignore
 */
var _sValidationMode = {
  FULL: 1,
  VALIDATORS_ONLY: 2,
  REQUIRED_VALIDATOR_ONLY: 3
};
/**
* String used in the id on the span that surrounds the help icon.
* @const
* @private
* @type {string}
*/

var _HELP_ICON_ID = '_helpIcon';
/**
* valid state constants
* @const
* @private
* @type {string}
*/

var _VALID = 'valid';
/**
* valid state constants
* @const
* @private
* @type {string}
*/

var _INVALID_HIDDEN = 'invalidHidden';
/**
* valid state constants
* @const
* @private
* @type {string}
*/

var _INVALID_SHOWN = 'invalidShown';
/**
* valid state constants
* @const
* @private
* @type {string}
*/

var _PENDING = 'pending'; // E D I T A B L E V A L U E    A B S T R A C T   W I D G E T

/**
 * @ojcomponent oj.editableValue
 * @augments oj.baseComponent
 * @ojsignature [{
 *                target: "Type",
 *                value: "abstract class editableValue<V, SP extends editableValueSettableProperties<V, SV, RV>, SV= V, RV= V> extends baseComponent<SP>"
 *               },
 *               {
 *                target: "Type",
 *                value: "editableValueSettableProperties<V, SV=V, RV=V> extends baseComponentSettableProperties",
 *                for: "SettableProperties"
 *               }
 *              ]
 * @ojtsimport {module: "ojmessaging", type:"AMD", importName: "Message"}
 * @abstract
 * @since 0.6.0
 * @ojshortdesc Abstract EditableValue element
 * @ojrole input
 * @hideconstructor
 *
 * @classdesc
 * Abstract base class for all editable components that are value holders and that require
 * validation and messaging capabilities. <br/>
 *
 * {@ojinclude "name":"validationAndMessagingDoc"}
 *  * <p>
 * Note: The <code class="prettyprint">required</code>, <code class="prettyprint">validators</code>,
 * <code class="prettyprint">converter</code> properties and the <code class="prettyprint">validate</code>
 * method are not on all EditableValue components so they are not on the EditableValue class.
 * See the EditableValue subclasses for which ones have which of these properties. For example,
 * oj-switch, oj-slider, oj-color-palette, and oj-color-spectrum do not have the
 * <code class="prettyprint">validate</code> method nor do they have the
 * <code class="prettyprint">required</code>, <code class="prettyprint">validators</code>,
 * <code class="prettyprint">converter</code> properties since the components
 * wouldn't do anything with these properties anyway. A user can't type into these components and there
 * is no visual representation for 'nothing is set' on these components. Whereas InputBase, inputNumber,
 * inputSearch and combobox do have these properties since a user can type into the field (so you may
 * need to convert it and validate it) and also blank it out (so you may need to mark it required and
 * run the required validator).
 * </p>

 * <p>
 * <h3 id="declarative-binding-section">
 * Declarative Binding
 * <a class="bookmarkable-link" title="Bookmarkable Link" href="#declarative-binding-section"></a>
 * </h3>
 * When the component's <code class="prettyprint">value</code> property is bound to a Knockout
 * observable and when the value changes, whether the observable is updated or not, and whether a
 * 'writeback' to the observable happens or not, depends on the action that caused the value to
 * change.
 * <ul>
 * <li>when the value changes as a result of user interaction </li>
 * <li>when the value changes because normal validation was run as a result of these properties
 * being changed by the app - <code class="prettyprint">converter</code>, <code class="prettyprint">disabled</code>,
 * <code class="prettyprint">required</code>, <code class="prettyprint">validators</code>, then the
 * value is written to the observable. See the specific property docs for details.</li>
 * <li>when the value changes because normal validation was run as a result of these methods being
 * called by the app -
 * <code class="prettyprint">refresh</code>, <code class="prettyprint">validate</code>,
 * then the value is written to the observable. See the specific method docs for details.</li>
 * <li>when the value changes due to programmatic intervention by app then the value is not written
 * back to observable. This is based on the assumption that the app has mutated the observable
 * already. In this case updating the component's <code class="prettyprint">value</code> property
 * alone will not propagate the change automatically to the observable. Updating the observable is
 * recommended as this will propagate the change automatically to the component.
 * </li>
 * </ul>
 * </p>
 *
 * @example <caption>Initialize component</caption>
 * &lt;oj-input-text id="foo" value="abc"/&gt;
 * @example <caption>Initialize component value using two way data binding</caption>
 * &lt;oj-input-text id="foo" value="{{salary}}"/&gt;
 * &lt;script&gt;
 * &nbsp;&nbsp;var salary = ko.observable('abc');
 * &lt;/script&gt;
 */

oj.__registerWidget('oj.editableValue', $.oj.baseComponent, {
  widgetEventPrefix: 'oj',
  options: {
    /**
     * The oj-label sets the described-by attribute programmatically on the form component.
     * This attribute is not meant to be set by an application developer directly.
     * The described-by is copied to the aria-describedby
     * attribute on the component's inner dom element, and it is needed
     * for accessibility.
     * @example <caption>Initialize component with the <code class="prettyprint">described-by</code> attribute specified:</caption>
     * &lt;oj-some-element described-by="someId">&lt;/oj-some-element>
     *
     * @example <caption>Get or set the <code class="prettyprint">describedBy</code> property after initialization:</caption>
     * // getter
     * var descById = myComp.describedBy;
     *
     * // setter
     * myComp.describedBy = "someId";
     *
     * @ojshortdesc The form component's oj-label automatically sets described-by
     * to make it accessible. It is not meant to be set by application developer.
     * @expose
     * @type {?string}
     * @public
     * @instance
     * @memberof oj.editableValue
     * @since 4.0.0
     */
    describedBy: null,

    /**
     * Whether the component is disabled. The default is false.
     *
     * <p>
     * When the <code class="prettyprint">disabled</code> property changes due to programmatic
     * intervention, the component may clear messages and run validation in some cases. </br>
     * <ul>
     * <li>when a required component is initialized as disabled
     * <code class="prettyprint">value="{{currentValue}}" required disabled</code>,
     * deferred validation is skipped.</li>
     * <li>when a disabled component is enabled,
     *  <ul>
     *  <li>if component is invalid and showing messages then all component messages are cleared,
     *  and full validation run using the display value.
     *   <ul>
     *    <li>if there are validation errors, they are shown.</li>
     *    <li>if no errors result from the validation, the <code class="prettyprint">value</code>
     *    property is updated. Page authors can listen to the <code class="prettyprint">valueChanged</code>
     *    event to clear custom errors.</li>
     *   </ul>
     *  </li>
     *
     *  <li>if component is valid and has no errors then deferred validation is run.
     *    <ul>
     *    <li>if there is a deferred validation error, then the valid property is updated. </li>
     *    </ul>
     *  </li>
     *  <li>if component is invalid and deferred errors then component messages are cleared and
     *  deferred validation re-run.
     *    <ul>
     *    <li>if there is a deferred validation error, then the valid property is updated.</li>
     *    </ul>
     *  </li>
     *  </ul>
     * </li>
     * <li>when enabled component is disabled then no validation is run and the component appears
     * disabled.</li>
     * </ul>
     * </p>
     *
     * @example <caption>Initialize component with <code class="prettyprint">disabled</code> attribute:</caption>
     * &lt;oj-some-element disabled>&lt;/oj-some-element>
     *
     * @example <caption>Get or set the <code class="prettyprint">disabled</code> property after initialization:</caption>
     * // getter
     * var disabled = myComp.disabled;
     *
     * // setter
     * myComp.disabled = false;
     *
     * @ojshortdesc Specifies whether the component is disabled. The default is false.
     * @expose
     * @type {boolean}
     * @default false
     * @public
     * @instance
     * @memberof oj.editableValue
     * @since 0.7.0
     */
    disabled: false,
    displayOptions: {},

    /**
     * Form component help information.
     * @expose
     * @memberof oj.editableValue
     * @instance
     * @public
     * @type {Object}
     * @since 0.7.0
     */
    help: undefined,

    /**
     * <p>help definition text.  See the top-level <code class="prettyprint">help</code> option for details.
     *
     * @expose
     * @alias help.definition
     * @memberof! oj.editableValue
     * @instance
     * @type {?string}
     * @ignore
     * @default null
     *
     * @example <caption>Get or set the <code class="prettyprint">help.definition</code> sub-option, after initialization:</caption>
     * // getter
     * var definitionText = myInputComp.help.definition;
     *
     * // setter:
     * myInputComp.help.definition = "Enter your name";
     */

    /**
     * <p>help source url.  See the top-level <code class="prettyprint">help</code> option for details.
     *
     * @expose
     * @alias help.source
     * @memberof! oj.editableValue
     * @instance
     * @ignore
     * @type {?string}
     * @default null
     *
     * @example <caption>Get or set the <code class="prettyprint">help.source</code> sub-option, after initialization:</caption>
     * // getter
     * var helpSource = myInputComp.help.source;
     *
     * // setter:
     * myInputComp.help.source = "www.abc.com";
     */

    /**
     * <p>
     * The helpHints object contains a definition property and a source property.
     * </p>
     * <ul>
     * <li><code class="prettyprint">definition</code> - hint for help definition text.</li>
     * <li><code class="prettyprint">source</code> - hint for help source URL.</li>
     * </ul>
     *
     * @example <caption>Initialize the component with help hints:</caption>
     * &lt;!-- Using dot notation -->
     * &lt;oj-some-element help-hints.definition='some value' help-hints.source='some-url'>&lt;/oj-some-element>
     *
     * &lt;!-- Using JSON notation -->
     * &lt;oj-some-element help-hints='{"definition":"some value", "source":"some-url"}'>&lt;/oj-some-element>
     *
     * @example <caption>Get or set the <code class="prettyprint">helpHints</code> property after
     * initialization:</caption>
     *
     * // Get one
     * var value = myComponent.helpHints.definition;
     *
     * // Set one, leaving the others intact. Always use the setProperty API for
     * // subproperties rather than setting a subproperty directly.
     * myComponent.setProperty('helpHints.definition', 'some new value');
     *
     * // Get all
     * var values = myComponent.helpHints;
     *
     * // Set all.  Must list every subproperty, as those not listed are lost.
     * myComponent.helpHints = {
     *     definition: 'some new value',
     *     source: 'some-new-url'
     * };
     *
     * @ojshortdesc Represents hints for an oj-form-layout element to render help information on the label of the editable component.
     * @expose
     * @access public
     * @memberof oj.editableValue
     * @ojtranslatable
     * @instance
     * @type {Object}
     * @since 4.1.0
     */
    helpHints: {
      /**
      * A type of user assistance text. User assistance text is used to provide
      * guidance to help the user understand what data to enter or select. help-hints could
      * come from a help system.
      * <p>In the Redwood theme for clarity only one user assistance text shows to the user.
      * The precedence rules are:
      * <ul>
      * <li>help.instruction shows;</li>
      * <li>if no help.instruction, then validator hint shows;</li>
      * <li>if no help.instruction or validator hint, then help-hints.definition shows;</li>
      * <li>if no help.instruction, validator hint, or help-hints.definition, then converter hint shows.</li>
      * <li>help-hints.source always shows along side the above.</li>
      * </ul>
      * </p>
      * <p>
      * In the Redwood theme, by default all user assistance text shows inline.
      * For input components, it shows when the field takes focus. In other components it
      * shows all the time. See the user-assistance-density property for other ways the user
      * assistance text can render.
      * </p>
       * <p>In the Alta theme the help-hint.definition shows up when
       * the user hovers over the help icon on the label,
       * or tabs into the help icon, or press and holds the help icon on a mobile device.
       * </p>
       * <p>No formatted text is available for help definition attribute.</p>
       *
       * <p>See the <a href="#helpHints">help-hints</a> attribute for usage examples.</p>
       *
       * @ojshortdesc Hint for help definition text associated with the label.
       * @expose
       * @alias helpHints.definition
       * @memberof! oj.editableValue
       * @instance
       * @type {string}
       * @ojsignature {target:"Type", value: "?"}
       * @default ""
       * @since 4.1.0
       */
      definition: '',

      /**
       * Help source URL associated with the component.
       * <p>In the Redwood theme, the help-hints.source will show as a link inline to the field.
       * For input components, it shows when the field takes focus. For other components,
       * it shows all the time.
       * </p>
       * <p>In the Alta theme, the help-hints.source will show as a a help icon
       *  next to the label. When clicked the page will navigate to the source url.
       * </p>
       * <p>
       * For security reasons we only support urls with protocol 'http:' or 'https:'.
       * If the url doesn't comply we ignore it and throw an error.
       * Pass in an encoded URL since we do not encode the URL.</p>
       *
       * <p>See the <a href="#helpHints">help-hints</a> attribute for usage examples.</p>
       *
       * @ojshortdesc Help source URL associated with the component.
       * @expose
       * @alias helpHints.source
       * @memberof! oj.editableValue
       * @instance
       * @type {string}
       * @ojsignature {target:"Type", value: "?"}
       * @default ""
       * @since 4.1.0
       */
      source: ''
    },

    /**
     * Represents a hint for rendering a label on the component.
     * <p>This is used in combination with the <a href="#labelEdge">label-edge</a> attribute to control how the label should be rendered.</p>
     *
     * <p>
     * When label-edge is "provided", it gives a hint to oj-form-layout parent element to create an oj-label element for the component.
     * When the <code class="prettyprint">label-hint</code> attribute changes, oj-form-layout element refreshes to
     * display the updated label information.
     * </p>
     * <p>
     * When label-edge is "inside", it gives a hint to the component itself to render a label.
     * </p>
     * <p>
     * When label-edge is "none", and if the component has no labelled-by, aria-label, or aria-labelledby attribute, the label-hint value will be used as the aria-label.
     * </p>
     *
     * @example <caption>Add the component as a direct child of oj-form-layout. Initialize the component with the <code class="prettyprint">label-hint</code> attribute specified.</caption>
     * &lt;oj-form-layout id= 'someId'>
     * &lt;/oj-some-element label-hint='input label'>&lt;/oj-some-element>
     * &lt;/oj-form-layout>
     *
     * @example <caption>Get or set the <code class="prettyprint">labelHint</code> property after
     * initialization:</caption>
     *
     * // getter
     * var value = myComponent.labelHint;
     *
     * // setter
     * myComponent.labelHint = 'some new value'
     *
     * @ojshortdesc Represents a hint for oj-form-layout element to render a label on the editable component.
     * @expose
     * @access public
     * @instance
     * @alias labelHint
     * @ojtranslatable
     * @default ""
     * @memberof oj.editableValue
     * @type {string}
     * @since 4.1.0
     */
    labelHint: '',

    /**
     * Specifies how the label of the component is created when the <code class="prettyprint">label-hint</code> attribute is set on the component.
     * <p>The default value varies by theme, and it works well for the theme in most cases.
     * If the component is in an oj-form-layout, and the label-edge attribute on oj-form-layout is set to an explicit value,
     * the label-edge attribute on all form controls should also be set to an explict value.
     * For example, if the label-edge attribute on oj-form-layout is set to "start" or "top", the label-edge attribute of all form controls should be set to "provided".</p>
     * @ojshortdesc Defines how the label of a component is created. See the Help documentation for more information.
     * @access public
     * @expose
     * @name labelEdge
     * @instance
     * @type {string}
     * @ojsignature {target: "Type", value: "'inside'|'none'|'provided'",  jsdocOverride: true}
     * @memberof! oj.editableValue
     * @ojvalue {string} "inside" The component creates the label using the <code class="prettyprint">label-hint</code> attribute.
     * <p>For text input components (such as oj-input-text), the label floats over the input element but moves up on focus or when the component has a value.</p>
     * <p>For non-text input components (such as oj-checkboxset), the label is created at the top of the component and doesn't move.</p>
     * @ojvalue {string} "none" The component will not have a label, regardless of whether it's in an oj-form-layout or not.
     * <p>If the component has a <code class="prettyprint">label-hint</code> attribute but no labelled-by, aria-label, or aria-labelledby attribute, the label-hint value will be used as the aria-label.</p>
     * <p>Note that if the component already has an external label, "none" should not be specified and "provided" should be used instead.
     * Otherwise it may end up with conflicting label information.</p>
     * @ojvalue {string} "provided" Label is provided by the parent if the parent is an oj-form-layout.
     * <p>oj-form-layout provides the label using the label-hint from the form control and the <a href="oj.ojFormLayout.html#labelEdge">label-edge</a> from oj-form-layout.</p>
     * <p>If there is no oj-form-layout, use an oj-label.</p>
     * @since 8.0.0
     */
    labelEdge: undefined,

    /**
     * List of messages an app would add to the component when it has business/custom validation
     * errors that it wants the component to show. This allows the app to perform further validation
     * before sending data to the server. When this option is set the message shows to the
     * user right away. To clear the custom message, set <code class="prettyprint">messagesCustom</code>
     * back to an empty array.<br/>
     * <p>Each message in the array is an object that duck types oj.Message.
     * See {@link oj.Message} for details.
     * </p>
     * <p>
     * See the <a href="#validation-section">Validation and Messages</a> section
     * for details on when the component clears <code class="prettyprint">messagesCustom</code>;
     * for example, when full validation is run.
     * </p>
     * <p>In the Redwood theme, the Message summary is not displayed to the user, so make sure to have a Message detail
     * set in your Message object.
     * </p>
     *
     *
     * @example <caption>Get or set the <code class="prettyprint">messagesCustom</code> property after initialization:</caption>
     * // getter
     * var customMsgs = myComp.messagesCustom;
     *
     * // setter
     * myComp.messagesCustom = [{summary:"hello", detail:"detail", severity:oj.Message.SEVERITY_LEVEL.INFO}];
     *
     * @example <caption>Set messagesCustom when there are cross-validation errors:</caption>
     * --- HTML ---
     * &lt;oj-some-element messages-custom='{{messagesCustom}}'>&lt;/oj-some-element>
     *
     * --- ViewModel code ---
     * self.messagesCustom = ko.observableArray([]);
     *
     * // the app's function that gets called when the user presses the submit button
     * if (!myValidateCrossValidationFields())
     * {
     *   // the app adds a custom messages to the component and it is displayed right away
     *   var msgs = [];
     *   msgs.push({'summary':'Cross field error', 'detail':'Field 1 needs to be less than Field 2'});
     *   self.messagesCustom(msgs);
     * }
     * else
     * {
     *   // submit data to the server
     * }
     *
     * @ojshortdesc A list of messages added by an application to the component. See the Help documentation for more information.
     * @expose
     * @access public
     * @instance
     * @memberof oj.editableValue
     * @default []
     * @type {Array.<Object>}
     * @ojsignature {target: "Type", value: "Array<oj.Message>"}
     * @since 0.7.0
     * @ojwriteback
     */
    messagesCustom: [],

    /**
     * List of messages currently hidden on component, these are added by component when it runs
     * deferred validation. Each message in the array is an object that duck types oj.Message.
     * See {@link oj.Message} for
     * details. <br/>
     *
     * <p>
     * This is a read-only option so page authors cannot set or change it directly.
     * </p>
     *
     * <p>
     * These messages are not shown to the end-user by default, but page author
     * can show hidden messages using the {@link showMessages} method.
     * </p>
     *
     * @example <caption>Get <code class="prettyprint">messagesShown</code> for the component:</caption>
     * // Foo is InputText, InputNumber, Select, etc.
     * var messages = myInputComp.messagesShown;
     *
     * @expose
     * @access public
     * @instance
     * @memberof oj.editableValue
     * @default []
     * @type {Array.<Object>|undefined}
     * @since 0.7.0
     * @see #showMessages
     * @readonly
     * @ignore
     * @ojwriteback
     */
    messagesHidden: undefined,

    /**
     * List of messages currently shown on component, these include messages generated both by the
     * component and ones provided by app using <code class="prettyprint">messagesCustom</code>.
     * Each message in the array is an object that duck types oj.Message.
     * See {@link oj.Message} for details. <br/>
     *
     * <p>
     * This is a read-only option so page authors cannot set or change it directly.
     * </p>
     *
     * <p>
     * Messages retrieved using the <code class="prettyprint">messagesShown</code> option are by
     * default shown inline, but this can be controlled using the 'messages' property of
     * the <code class="prettyprint">displayOptions</code> option.
     * </p>
     *
     * @example <caption>Get <code class="prettyprint">messagesShown</code> for the component:</caption>
     * // Foo is InputText, InputNumber, Select, etc.
     * var messages = myInputComp.messagesShown;
     *
     * @expose
     * @access public
     * @instance
     * @memberof oj.editableValue
     * @default []
     * @type {Array.<Object>|undefined}
     * @since 0.7.0
     * @readonly
     * @ignore
     * @ojwriteback
     */
    messagesShown: undefined,

    /**
     * A type of user assistance text. User assistance text is used to provide
     * guidance to help the user understand what data to enter or select.
     * <p> In the Redwood theme for clarity only one user assistance text shows to the user.
     *  The precedence rules are:
     * <ul>
     * <li>help.instruction shows;</li>
     * <li>if no help.instruction, then validator hint shows;</li>
     * <li>if no help.instruction or validator hint, then help-hints.definition shows;</li>
     * <li>if no help.instruction, validator hint, or help-hints.definition, then converter hint shows.</li>
     * <li>help-hints.source always shows along side the above.</li>
     * </ul>
     * </p>
     * <p>In the Redwood theme, by default all user assistance text shows inline.
     * For input components, it shows when the field takes focus. In other components
     * it shows all the time. See the user-assistance-density property for other ways
     * the user assistance text can render.
     * <p>
     *  In Alta theme, help.instruction
     * displays in a notewindow when the field takes focus. How is help.instruction better than the html 'title' attribute?
     * The html 'title' attribute only shows up as a tooltip on mouse over, not on keyboard and not in a mobile
     * device. So the html 'title' would only be for text that is not important enough to show all users, or
     * for text that you show the users in another way as well, like in the label.
     * Also you cannot theme the native browser's title window like you can the JET
     * notewindow, so low vision users may have a hard time seeing the 'title' window.
     * For these reasons, the JET EditableValue components do not use the HTML's 'title'
     * attribute and instead use the help.instruction attribute.
     * </p>
     *
     * <p>
     * To include formatted text in the help.instruction, format the string using html tags.
     * For example the
     * help.instruction might look like:
     * <pre class="prettyprint"><code>&lt;oj-some-element help.instruction="&lt;html>Enter &lt;b>at least&lt;/b> 6 characters&lt;/html>">&lt;/oj-some-element></code></pre>
     * If you use formatted text, it should be accessible
     * and make sense to the user if formatting wasn't there.
     *
     * @example <caption>Initialize the component with the <code class="prettyprint">help.instruction</code> sub-attribute:</caption>
     * &lt;oj-some-element help.instruction="some tooltip">&lt;/oj-some-element>
     *
     * @example <caption>Get or set the <code class="prettyprint">help.instruction</code> property after initialization:</caption>
     * // Get one subproperty
     * var instr = myComp.help.instruction;
     *
     * // Set one subproperty, leaving the others intact. Use the setProperty API for
     * // subproperties so that a property change event is fired.
     * myComponent.setProperty('help.instruction', 'some new value');
     *
     * // Get all
     * var values = myComponent.help;
     *
     * // Set all.  Must list every resource key, as those not listed are lost.
     * myComponent.help = {
     *   instruction: 'some new value'
     * };
     *
     * @ojshortdesc Represents advisory information for the component, such as would be appropriate for a tooltip.
     * @expose
     * @access public
     * @instance
     * @alias help.instruction
     * @ojtranslatable
     * @default ""
     * @memberof! oj.editableValue
     * @type {string=}
     * @since 4.0.0
     */
    title: '',

    /**
     * <p>
     * Specifies the density of the form component's user assistance presentation.
     * It can be shown inline with reserved rows to prevent reflow if
     * a user assistance text shows up, inline without reserved rows that would reflow if
     * a user assistance text shows up,
     * or it can be shown compactly in a popup instead.</p>
     * <p>
     * The default value is 'reflow' when the form component is not a descendent of an oj-form-layout
     * component. When the form component is a descendent of an oj-form-layout, the default value comes from the
     * oj-form-layout's <code class="prettyprint">user-assistance-density</code> attribute value.
     * </p>
     * <p>
     * The oj-form-layout component uses the
     * <a href="MetadataTypes.html#PropertyBinding">MetadataTypes.PropertyBinding</a>
     * <code class="prettyprint">provide</code> property to provide its
     * <code class="prettyprint">user-assistance-density</code>
     * attribute value to be consumed by descendent components.
     * The form components are configured to consume the
     * <code class="prettyprint">user-assistance-density</code> property if an
     * ancestor provides it and it is not explicitly set on the form component.
     * Example, oj-form-layout defaults user-assistance-density='efficient', so all its
     * form components descendents will have user-assistance-density='efficient' by default.
     * </p>
     * @ojshortdesc Specifies the density of the form component's user assistance presentation.
     * @access public
     * @expose
     * @name userAssistanceDensity
     * @ojunsupportedthemes ["Alta"]
     * @default "reflow"
     * @instance
     * @type {string}
     * @ojsignature {target: "Type", value: "'reflow'|'efficient'|'compact'",  jsdocOverride: true}
     * @memberof oj.editableValue
     * @ojvalue {string} "reflow" Messages, help, hints, and required are all shown inline under the field with no reserved space.
     * @ojvalue {string} "efficient" Messages, help, hints, and required are all shown inline under the field with reserved space.
     * @ojvalue {string} "compact" Messages, help, hints, and required will not be shown inline; they will show in a mode that keeps the screen more compact, like
     * a popup for the messages, and a required icon to indicate Required.
     * @since 9.0.0
     */
    userAssistanceDensity: 'reflow',

    /**
     * <p>
     * The current valid state of the component. It is evaluated on initial render.
     * It is re-evaluated
     * <ul>
     *   <li>after each validator (validators or async-validators) is run (full or deferred)</li>
     *   <li>when messagesCustom is updated,
     *   since messagesCustom can be added by the app developer any time.</li>
     *   <li>when showMessages() is called. Since showMessages() moves the
     *   hidden messages into messages shown,
     *   if the valid state was "invalidHidden" then it would become "invalidShown".</li>
     *   <li>when the required property has changed. If a component is empty and has required
     *   set, the valid state may be "invalidHidden" (if no invalid messages are being shown as well).
     *   If required property is removed, the valid state would change to "valid".</li>
     * </ul>
     * </p>
     * <p>
     *  Note: New valid states may be added to the list of valid values in future releases.
     *  Any new values will start with "invalid"
     *  if it is an invalid state, "pending" if it is pending state,
     *  and "valid" if it is a valid state.
     * </p>
     * @example <caption>Get <code class="prettyprint">valid</code> attribute, after initialization:</caption>
     * // Getter:
     * var valid = myComp.valid;
     * @example <caption>Set the <code class="prettyprint">on-valid-changed</code>
     *  listener so you can do work in the ViewModel based on the
     *  <code class="prettyprint">valid</code> property:</caption>
     * &lt;oj-some-element id='username' on-valid-changed='[[validChangedListener]]'>
     * &lt;/oj-some-element>
     * &lt;oj-some-element id='password' on-valid-changed='[[validChangedListener]]'>
     * &lt;/oj-some-element>
     * &lt;oj-button disabled='[[componentDisabled]]' on-click='[[submit]]'>Submit&lt;/oj-button>
     * -- ViewModel --
     * self.validChangedListener = function (event) {
     *   var enableButton;
     *   var usernameValidState;
     *   var passwordValidState;
     *
     *   // update the button's disabled state.
     *   usernameValidState = document.getElementById("username").valid;
     *   passwordValidState = document.getElementById("password").valid;
     *
     *   // this updates the Submit button's disabled property's observable based
     *   // on the valid state of two components, username and password.
     *   // It is up to the application how it wants to handle the âpendingï¿½? state
     *   // but we think that in general buttons donât need to be
     *   // enabled / disabled based on the "pending" state.
     *   enableButton =
     *    (usernameValidState !== "invalidShown") &&
     *    (passwordValidState !== "invalidShown");
     *   self.componentDisabled(!enableButton);;
     * };
     *
     * @ojshortdesc The validity state of the component
     * @expose
     * @access public
     * @instance
     * @type {string}
     * @ojvalue {string} "valid" The component is valid
     * @ojvalue {string} "pending" The component is waiting for the validation state to be determined.
     * The "pending" state is set at the start of the convert/validate process.
     * @ojvalue {string} "invalidHidden" The component has invalid messages hidden
     *    and no invalid messages showing. An invalid message is one with severity "error" or higher.
     * @ojvalue {string} "invalidShown" The component has invalid messages showing.
     *  An invalid message is one with severity "error" or higher.
     * @ojwriteback
     * @readonly
     * @memberof oj.editableValue
     * @since 4.2.0
     *
     */
    valid: undefined,

    /**
     * The value of the component.
     *
     * <p>
     * When <code class="prettyprint">value</code> property changes due to programmatic
     * intervention, the component always clears all messages
     * including <code class="prettyprint">messagesCustom</code>, runs deferred validation, and
     * always refreshes UI display value.</br>
     *
     * <h4>Running Validation</h4>
     * <ul>
     * <li>component always runs deferred validation; the
     * <code class="prettyprint">valid</code> property is updated with the result.</li>
     * </ul>
     * </p>
     *
     * @example <caption>Initialize the component with the <code class="prettyprint">value</code> attribute specified:</caption>
     * &lt;oj-some-element value='10'>&lt;/oj-some-element>
     * @example <caption>Get or set <code class="prettyprint">value</code> attribute, after initialization:</caption>
     * // Getter: returns '10'
     * var val = myComp.value;
     * // Setter: sets '20'
     * myComp.value = '20';
     *
     * @ojshortdesc The value of the component.
     * @expose
     * @access public
     * @instance
     * @default null
     * @ojwriteback
     * @ojeventgroup common
     * @memberof oj.editableValue
     * @since 0.6.0
     * @type {any}
     * @ojsignature {
     *                 target: "Accessor",
     *                 value: {
     *                          GetterType: "V|null",
     *                          SetterType: "SV|null"}
     *              }
     */
    value: undefined,
    // Events

    /**
     * Triggered when a default animation is about to start on an element owned by the component.
     *
     * <p>The default animation can be cancelled by calling <code class="prettyprint">event.preventDefault</code>, followed by
     * a call to <code class="prettyprint">event.detail.endCallback</code>.  <code class="prettyprint">event.detail.endCallback</code> should be
     * called immediately after <code class="prettyprint">event.preventDefault</code> if the application merely wants to cancel animation,
     * or it should be called when the custom animation ends if the application is invoking another animation function.  Failure to
     * call <code class="prettyprint">event.detail.endCallback</code> may prevent the component from working properly.</p>
     * <p>For more information on customizing animations, see the documentation of
     * <a href="oj.AnimationUtils.html">oj.AnimationUtils</a>.</p>
     *
     * <caption>The default animations are controlled via the theme (SCSS) :</caption>
     * <pre class="prettyprint"><code>
     * // default animations for "notewindow" display option
     * $popupTailOpenAnimation: (effect: "zoomIn", transformOrigin: "#myPosition") !default;
     * $popupTailCloseAnimation: (effect: "none") !default;
     *
     * // default animations for "inline" display option
     * $messageComponentInlineOpenAnimation: (effect: "expand", startMaxHeight: "#oldHeight") !default;
     * $messageComponentInlineCloseAnimation: (effect: "collapse", endMaxHeight: "#newHeight") !default;
     * </code></pre>
     *
     * @ojshortdesc Triggered when a default animation is about to start, such as when the component is being opened/closed or a child item is being added/removed.
     *
     * @expose
     * @event
     * @memberof oj.editableValue
     * @since 4.0.0
     * @ojbubbles
     * @ojcancelable
     * @instance
     * @property {string} action The action that triggers the animation.</br></br>
     *                           Supported values are:
     *                              <ul>
     *                                <li>"inline-open" - when an inline message container opens or increases in size</li>
     *                                <li>"inline-close" - when an inline message container closes or decreases in size</li>
     *                                <li>"notewindow-open" - when a note window opens</li>
     *                                <li>"notewindow-close" - when a note window closes</li>
     *                              </ul>
     * @property {Element} element The element being animated.
     * @property {function():void} endCallback If the event listener calls event.preventDefault to
     *            cancel the default animation, it must call the endCallback function when it
     *            finishes its own animation handling and any custom animation has ended.
     *
     * @example <caption>Define an event listener for the
     *          <code class="prettyprint">ojAnimateStart</code> event to override the default
     *          "inline-open" animation:</caption>
     * var listener = function( event )
     *   {
     *     // Change the "inline-open" animation for inline message
     *     if (event.detail.action == "inline-open") {
     *       // Cancel default animation
     *       event.preventDefault();
     *       // Invoke new animation and call endCallback when the animation ends
     *       oj.AnimationUtils.fadeIn(event.detail.element).then(event.detail.endCallback);
     *     }
     *   };
     *
     * @example <caption>Define an event listener for the
     *          <code class="prettyprint">ojAnimateStart</code> event to cancel the default
     *          "notewindow-close" animation:</caption>
     * var listener = function( event )
     *   {
     *     // Change the "notewindow-close" animation for note window
     *     if (ui.action == "notewindow-close") {
     *       // Cancel default animation
     *       event.preventDefault();
     *       // Call endCallback immediately to indicate no more animation
     *       event.detail.endCallback();
     *     }
     *   };
     */
    animateStart: null,

    /**
     * Triggered when a default animation has ended.
     *
     * @expose
     * @event
     * @ojbubbles
     * @ojcancelable
     * @memberof oj.editableValue
     * @since 4.0.0
     * @instance
     * @property {string} action The action that triggered the animation.</br></br>
     *                           Supported values are:
     *                              <ul>
     *                                <li>"inline-open" - when an inline message container opens or increases in size</li>
     *                                <li>"inline-close" - when an inline message container closes or decreases in size</li>
     *                                <li>"notewindow-open" - when a note window opens</li>
     *                                <li>"notewindow-close" - when a note window closes</li>
     *                              </ul>
     * @property {Element} element The element being animated.
     * @example <caption>Define an event listener for the
     *          <code class="prettyprint">ojAnimateEnd</code> event to add any processing after the end of
     *          "inline-open" animation:</caption>
     * var listener = function( event )
     * {
     *   // Check if this is the end of "inline-open" animation for inline message
     *   if (event.detail.action == "inline-open") {
     *     // Add any processing here
     *   }
     * };
     */
    animateEnd: null
  },
  // P U B L I C    M E T H O D S
  // @inheritdoc
  getNodeBySubId: function getNodeBySubId(locator) {
    var node;
    var subId;
    node = this._super(locator); // this subId is only for non-custom element components so skip if custom element

    if (!node && !this._IsCustomElement()) {
      subId = locator.subId;

      if (subId === 'oj-label-help-icon') {
        var label = this._GetLabelElement();

        if (label) {
          node = label.parent().find('.oj-label-help-icon');
        }
      }
    } // Non-null locators have to be handled by the component subclasses


    return node || null;
  },
  //* * @inheritdoc */
  getSubIdByNode: function getSubIdByNode(elem) {
    var $node;
    var anchor;
    var div;
    var label;
    var subId = null;

    if (elem != null) {
      $node = $(elem);
      anchor = $node.closest('a.oj-label-help-icon');

      if (anchor != null) {
        // Go up to the top level element of the label
        div = anchor.closest('.oj-label');

        if (div != null) {
          // Now find the actual label
          label = div.find('label')[0];

          if (label) {
            // Make sure the label is the one associated with this component
            if (label === this._GetLabelElement()[0]) {
              subId = {
                subId: 'oj-label-help-icon'
              };
            }
          }
        }
      }
    }

    return subId;
  },

  /**
   * whether the component is currently valid.  It is valid if it doesn't have any errors.
   * This method is final; do not override.
   * Currently this is for the widget components and not custom elements.
   * @example <caption>Check whether the component is valid:</caption>
   * var valid = myInputElement.isValid();
   * @returns {boolean}
   * @access public
   * @instance
   * @expose
   * @memberof oj.editableValue
   * @final
   * @ignore
   */
  isValid: function isValid() {
    if (this._valid === undefined) {
      this._valid = !this._hasInvalidMessages();
    }

    return this._valid;
  },

  /**
   * Called when the DOM underneath the component changes requiring a re-render of the component. An
   * example is when the <code class="prettyprint">id</code> for the input changes. <br/>
   * <p>
   * Another time when refresh might be called is when the locale for the page changes. When it
   * changes, attributes used by its converter and validator that are locale specific, its hints,
   * messages and translations will be updated.
   * </p>
   *
   * <p>
   * When <code class="prettyprint">refresh</code> method is called, the component may take various
   * steps such as clearing messages, running validation etc., based on the state it is in. </br>
   *
   * <h4>Steps Performed Always</h4>
   * <ul>
   * <li>The converter and validators used by the component are reset, and new converter and
   * validator hints is pushed to messaging. E.g., notewindow displays the new hint(s).
   * </li>
   * </ul>
   *
   * <h4>Running Validation</h4>
   * <ul>
   * <li>if component is valid when refresh() is called, the display value is refreshed if component
   * has a converter set.</li>
   * <li>if component is invalid and is showing messages when
   * <code class="prettyprint">refresh()</code> is called, then all component messages are cleared
   * and full validation run using the display value on the component.
   * <ul>
   *   <li>if there are validation errors, then <code class="prettyprint">value</code>
   *   attribute is not updated and the error is shown.
   *   </li>
   *   <li>if no errors result from the validation, the <code class="prettyprint">value</code>
   *   attribute is updated; page author can listen to the <code class="prettyprint">valueChanged</code>
   *   event to clear custom errors.</li>
   * </ul>
   * </li>
   * <li>if component is invalid and has deferred messages when <code class="prettyprint">refresh()</code>
   * is called, then all component messages are cleared and deferred validation is run.</li>
   * </ul>
   * </p>
   *
   * <h4>Clearing Messages</h4>
   * <ul>
   * <li>If clearing messages only those created by the component are cleared.
   * <li><code class="prettyprint">messagesCustom</code> attribute is not cleared.</li>
   * </ul>
   * </p>
   *
   * @example <caption>Redraw the component element.</caption>
   * myComp.refresh();
   *
   * @access public
   * @instance
   * @expose
   * @return {void}
   * @memberof oj.editableValue
   * @ojshortdesc Called when the DOM underneath the component changes, requiring a re-render of the component.
   * @since 0.7.0
   */
  refresh: function refresh() {
    this._super(); // doRefresh refreshes value and disabled


    this._doRefresh();
  },

  /**
   * Resets the component by clearing all messages and messages attributes -
   * <code class="prettyprint">messagesCustom</code> -
   * and updates the component's display value using the attribute value. User entered values will be
   * erased when this method is called.
   *
   * @example <caption>Reset component</caption>
   * myComp.reset(); <br/>
   *
   * @access public
   * @instance
   * @expose
   * @return {void}
   * @memberof oj.editableValue
   * @ojshortdesc Resets the component by clearing all messages and messages attributes, and updates the component's display value using the attribute value.
   * @since 0.7.0
   */
  reset: function reset() {
    this._clearAllMessages(); // since we are pushing component value to UI, only deferred validation need to be run; this is
    // same as setting value option.


    this._runDeferredValidation(this._VALIDATION_CONTEXT.RESET_METHOD);

    this._refreshComponentDisplayValue(this.options.value, true);
  },

  /**
   * Takes all deferred messages and shows them.
   * It then updates the valid property; e.g.,
   * if the valid state was "invalidHidden"
   * before showMessages(), the valid state will become "invalidShown" after showMessages().
   * <p>
   * If there were no deferred messages this method simply returns.
   * </p>
   *
   *
   * @example <caption>Display all messages including deferred ones.</caption>
   * myComp.showMessages();
   * @access public
   * @instance
   * @return {void}
   * @expose
   * @memberof oj.editableValue
   * @ojshortdesc Takes all deferred messages and shows them.
   * @since 0.7.0
   */
  showMessages: function showMessages() {
    var clonedMsgs = [];
    var i;
    var msgHidden;
    var msgsHidden = this.options.messagesHidden;
    var hasMessagesHidden = msgsHidden.length > 0;
    var clonedMsg; // showMessages() copies messagesHidden into clonedMsgs,
    // then clears messagesHidden, and updates messagesShown with the clonedMsgs.
    // It then updates the valid property; e.g.,
    // if the valid state was "invalidHidden"
    // before showMessages(), the valid state will become "invalidShown" after showMessages().

    for (i = 0; i < msgsHidden.length; i++) {
      msgHidden = msgsHidden[i]; // The oj.Message and oj.ComponentMessage distinction is important in a few places in
      // the EV code. For example, when messagesCustom property changes, we keep existing
      // messagesShown only if they are ComponentMessage added by component.
      // if (msg instanceof oj.ComponentMessage && msg._isMessageAddedByComponent())

      if (msgHidden instanceof oj.ComponentMessage) {
        // change oj.ComponentMessage's display state to oj.ComponentMessage.DISPLAY.SHOWN
        msgHidden._forceDisplayToShown(); //
        // .clone() clones the message and the options that were passed in when the message
        // was originally created.


        clonedMsg = msgHidden.clone();
      } else {
        // NOTE: oj.Message is a public class and oj.ComponentMessage is private.
        // oj.Message's .clone is deprecated, so we purposely don't call it here.
        clonedMsg = new Message(msgHidden.summary, msgHidden.detail, msgHidden.severity);
      }

      clonedMsgs.push(clonedMsg);
    }

    if (hasMessagesHidden) {
      this._clearMessages('messagesHidden');

      this._updateMessagesOption('messagesShown', clonedMsgs);

      this._setValidOption(_INVALID_SHOWN, null);
    }
  },
  // P R O T E C T E D    C O N S T A N T S   A N D   M E T H O D S
  // *********** START WIDGET FACTORY METHODS (they retain _camelcase naming convention) **********

  /**
   * Validation mode specifying the kind of validation that gets run.
   * <ul>
   *   <li>FULL - the default and runs both the converter and all validators. </li>
   *   <li>VALIDATORS_ONLY - runs all validators including the required validator is run.</li>
   *   <li>REQUIRED_VALIDATOR_ONLY - runs just the required validator. </li>
   * </ul>
   * @protected
   * @const
   * @type {Object}
   * @memberof oj.editableValue
   */
  _VALIDATION_MODE: _sValidationMode,

  /**
   * The context the component can be in when validation is run.
   * <ul>
   * <li>COMPONENT_CREATE - when component is created and we run validators. usually messages are
   * not displayed right away, i.e, are 'deferred'. </li>
   * <li>VALUE_OPTION_CHANGE - when component's value is updated programmatically. messages are
   * deferred.</li>
   * <li>REQUIRED_OPTION_CHANGE - when component's required option is updated programmatically. messages are
   * deferred.</li>
   * <li>USER_ACTION - when component runs validation as a result of user interating with component.
   * messages are displayed immediately.</li>
   * <li>VALIDATE_METHOD - when component's validate() method is called explicitly. messages are
   * displayed immediately.</li>
   * </ul>
   *
   * @protected
   * @const
   * @type {Object}
   * @memberof oj.editableValue
   *
   */
  _VALIDATION_CONTEXT: oj.EditableValueUtils.validationContext,

  /**
   * Default options used by validate method.
   *
   * @protected
   * @const
   * @type {Object}
   * @memberof oj.editableValue
   * @see #validate
   */
  _VALIDATE_METHOD_OPTIONS: oj.EditableValueUtils.validateMethodOptions,

  /**
   * Called at component create time primarily to initialize options, often using DOM values. This
   * method is called before _ComponentCreate is called, so components that override this method
   * should be aware that the component has not been rendered yet. The element DOM is available and
   * can be relied on to retrieve any default values. <p>
   *
   * This method sets defaults for its options that have a DOM namesake. E.g., value, required,
   * disabled etc. Subclasses can override this method to set their own defaults for these options.
   * Example, the value option is often not set on this.element for components like radioset, which
   * walk the sub-tree to determine the value.
   *
   * @param {!Object} originalDefaults - original default options defined on the widget and its ancestors
   * @param {?Object} constructorOptions - options passed into the wiget constructor
   *
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _InitOptions: function _InitOptions(originalDefaults, constructorOptions) {
    this._super(originalDefaults, constructorOptions);
  },

  /**
   * Initializes options defined by this base class.
   *
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _ComponentCreate: function _ComponentCreate() {
    // remove attributes that trigger html5 validation + inline bubble
    var attrsToRemove = ['required', 'title', 'pattern'];
    var node = this.element;

    var savedAttributes = this._GetSavedAttributes(node);

    this._super();

    this.options.messagesCustom = this.options.messagesCustom || [];
    this.options.messagesHidden = [];
    this.options.messagesShown = this.options.messagesCustom.length > 0 ? this._cloneMessagesBeforeSet(this.options.messagesCustom) : []; // update element DOM for disabled. TODO: say why

    this._SetDisabledDom(node); // remove html5 validation attributes; it's safe to remove these here because components should
    // have already initialized options based on DOM in _InitOptions().
    // Only need to do for <input> elements
    // custom elements create their input/textarea dom, so no need to do that for them.


    if (savedAttributes && !this._IsCustomElement()) {
      var tagName = node[0].tagName.toLowerCase();

      if (tagName === 'input' || tagName === 'textarea') {
        attrsToRemove.forEach(function (value) {
          if (value in savedAttributes) {
            node.removeAttr(value);
          }
        });
      }
    }
  },

  /**
   * The value option alone is initialized here since it requires the component to be fully
   * created. Calling this.options.value before this method does not guarantee the correct
   * value to be returned.
   *
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _AfterCreate: function _AfterCreate() {
    var describedBy;
    var self = this;

    this._super();

    this._refreshTheming('disabled', this.options.disabled);

    this.widget()[0].classList.add('oj-form-control');

    if (this._IsTextFieldComponent()) {
      if (this._IsCustomElement()) {
        this._getRootElement().classList.add('oj-text-field');
      } else {
        this.widget()[0].classList.add('oj-text-field');
      }
    }

    this._toggleOjHasNoValueClass(); // We need to make sure the form component has an id since oj-form-layout
    // creates the label and associates them via for/id. Adding an id from ojformlayout
    // after the component is created does not create the form component's internal id.


    this.widget().uniqueId(); // create an ojLabel only if this isn't a custom element. For example, ojInputText will
    // create an ojLabel, but <oj-input-text> will not. Instead the app dev uses <oj-label>.

    if (!this._IsCustomElement()) {
      this._createOjLabel();
    } else if (this.options.labelledBy) {
      this._labelledByUpdated(this.options.labelledBy);
    } else {
      this._setAriaLabelFromLabelHint();
    } // set describedby on the element as aria-describedby


    describedBy = this.options.describedBy;

    if (describedBy) {
      this._describedByUpdated(null, describedBy);
    } // run deferred validation


    this._runDeferredValidation(this._VALIDATION_CONTEXT.COMPONENT_CREATE); // Validators can have a dependency on the converter, so don't do anything with a validator
    // until the converter is loaded. That includes don't show a validator hint.


    var converter = this._GetConverter();

    this._converterChangedCounter = 0;

    if (converter instanceof Promise) {
      this._setBusyStateAsyncConverterLoading(); // generally, the label edge is derived during the component messaging initialization.
      // but, in this case we are delaying the messaging init.
      // this will be a problem when we deal with deriving the label edge from a form layout.
      // because converter could resolve while the form layout is reparenting the children and
      // look up of parent might not work as expected. So we should just call the label edge
      // derivation logic here. That method internally caches the derived label-edge and we should be
      // fine delaying the label creation until the component is ready.


      this._ResolveLabelEdgeStrategyType();

      this._loadingConverter(converter).then(function () {
        self._AfterCreateConverterCached();

        self._clearBusyStateAsyncConverterLoading();
      });
    } else {
      // this code gets called if you have a synchronous converter
      // or no converter at all.
      this._AfterCreateConverterCached();

      this._setValidOption(this._determineValidFromMessagesOptions(), null);
    }
  },

  /**
   * If we have asynchronous converter loading, the input is readonly and a loading indicator
   * is shown to the user.
   * When the converter is 100% loaded, then the field is set back to how it was.
   * That is when we do the tasks that either need a converter or need the field to be enabled,
   * like showing messagesCustom. Those tasks are done in this method.
   *
   * @memberof oj.editableValue
   * @instance
   * @protected
   */

  /**
   * <p>Saves all the element's attributes. In _destroy all attributes will be restored.
   * </p>
   *
   * @param {Object} element - jQuery selection to save attributes for
   * @protected
   * @memberof oj.editableValue
   * @instance
   * @override
   */
  _SaveAttributes: function _SaveAttributes(element) {
    if (!this._IsCustomElement()) {
      this._SaveAllAttributes(element);
    }
  },

  /**
   * @protected
   * @memberof oj.editableValue
   * @instance
   * @override
   */
  _RestoreAttributes: function _RestoreAttributes(element) {
    if (!this._IsCustomElement()) {
      this._RestoreAllAttributes(element);
    }
  },

  /**
   * Performs post processing after _SetOption() calls _superApply(). Different options, when changed, perform
   * different tasks.
   *
   * @param {string} option
   * @param {Object=} flags
   * @protected
   * @memberof oj.editableValue
   * @instance
   */
  _AfterSetOption: function _AfterSetOption(option, flags) {
    switch (option) {
      case 'disabled':
        this._AfterSetOptionDisabledReadOnly(option, oj.EditableValueUtils.disabledOptionOptions);

        break;

      case 'displayOptions':
        // clear the cached merged options; the getter setup for this.options['displayOptions']
        // will merge the new value with the defaults
        this._initComponentMessaging();

        break;

      case 'labelEdge':
        // if the labelEdge of the component changed, we need to recreate or move the label
        this._initComponentMessaging();

        this._setAriaLabelFromLabelHint();

        break;

      case 'labelHint':
        this._setAriaLabelFromLabelHint();

        break;

      case 'help':
        if (!this._IsCustomElement()) {
          // For non custom element components, help has definition and source, and if those
          // change, the component needs to be refreshed.
          this._Refresh(option, this.options[option]);
        } else {
          // For custom element components, when the help option changes, we have to assume that
          // help.instruction changed. When help.instruction changes push new value to messaging.
          this._getComponentMessaging().update(this._getMessagingContent(this._MESSAGING_CONTENT_UPDATE_TYPE.TITLE));
        }

        break;

      case 'messagesCustom':
        this._messagesCustomOptionChanged(flags);

        this._setValidOption(this._determineValidFromMessagesOptions(), null);

        break;

      case 'placeholder':
        this._SetPlaceholder(this.options.placeholder);

        this._placeholderOptionChanged(flags);

        break;

      case 'title':
        // Ignore title attribute for custom element components.
        if (!this._IsCustomElement()) {
          // no reason to refresh component when title changes just push new value to messaging.
          this._getComponentMessaging().update(this._getMessagingContent(this._MESSAGING_CONTENT_UPDATE_TYPE.TITLE));
        }

        break;

      case 'translations':
        this.refresh();
        break;

      case 'userAssistanceDensity':
        // if the userAssistanceDensity of the component changed,
        // we need to create or remove the user assistance display strategy.
        this._initComponentMessaging();

        break;

      case 'value':
        this._AfterSetOptionValue(option, flags);

        break;

      default:
        break;
    }
  },

  /**
   * Performs post processing after disabled or readOnly option changes by taking the following
   * steps. (Steps are same for readOnly option).
   * <p>
   * if disabled component is enabled then, <br/>
   * - if there are no errors, run deferred validation. component could have been initialized with
   * empty value and disabled.<br/>
   * - if component is invalid and showing messages clear component error, grab UI value and run
   * full validation.<br/>
   * - if component is invalid and has hidden messages; do nothing. <br/>
   * </p>
   * <p>
   * if enabled component is disabled no validation is run.<br/>
   * </p>
   *
   * @param {String} option
   * @param {Object} validationOptions
   *
   * @protected
   * @memberof oj.editableValue
   * @instance
   */
  _AfterSetOptionDisabledReadOnly: function _AfterSetOptionDisabledReadOnly(option, validationOptions) {
    var isEnabled = !(this.options[option] || false); // always refresh

    this._Refresh(option, this.options[option]);

    if (isEnabled) {
      this._runMixedValidationAfterSetOption(validationOptions);
    }
  },

  /**
   * Performs post processing after value option changes by taking the following steps.
   *
   * - triggers a valueChanged event and does writeback if required.<br/>
   * - if setOption was from programmatic intervention, <br/>
   * &nbsp;&nbsp;- clear custom messages and component messages; <br/>
   * &nbsp;&nbsp;- run deferred validation. if there is an error, updates messagesHidden. <br/>
   * - always refreshes UI display by formatting the value option<br/>
   *
   * @param {string} option
   * @param {Object=} flags
   *
   * @protected
   * @memberof oj.editableValue
   * @instance
   *
   */
  _AfterSetOptionValue: function _AfterSetOptionValue(option, flags) {
    var context = flags ? flags._context : null;
    var doNotClearMessages;
    var isUIValueChange = false;

    if (context) {
      isUIValueChange = !!context.originalEvent;
      doNotClearMessages = context.doNotClearMessages || false;
    }

    if (!isUIValueChange) {
      // value option can be updated directly (i.e., programmatically or through user interaction)
      // or updated indirectly as a result of some other option changing - e.g., converter,
      // validators, required etc.
      // When value changes directly due to programatic intervention (usually page author does this)
      // then clear all messages and run deferred validation.
      // If value changes indirectly do not clear custom messages (component messages are already
      // cleared) and run deferred validation.
      if (!doNotClearMessages) {
        this._clearAllMessages(null);
      }

      this._runDeferredValidation(this._VALIDATION_CONTEXT.VALUE_OPTION_CHANGE);
    } // refresh UI display value


    this._Refresh(option, this.options[option], true);
  },

  /**
   * Whether the a value can be set on the component. For example, if the component is
   * disabled then setting value on component is a no-op.
   *
   * @see #_SetValue
   * @return {boolean}
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _CanSetValue: function _CanSetValue() {
    var disabled = this.options.disabled || false;
    return !disabled;
  },

  /**
   * Detaches the widget from the element and restores element exactly like it was before the widget
   * was attached.
   * @protected
   * @expose
   * @memberof oj.editableValue
   * @instance
   *
   */
  _destroy: function _destroy() {
    var labelIndex;
    var labelLength;

    var ret = this._super();

    this._clearAllMessages(null, true);

    this.widget().removeUniqueId();

    if (this._getComponentMessaging()._isActive()) {
      this._getComponentMessaging().deactivate();
    } // make sure the label is still "alive". Otherwise we could get error when we try to
    // destroy it if the dom was removed first and ojLabel was destroyed directly.
    // also make sure to check if there is more than one label and destroy them individually.


    if (this.$label) {
      labelLength = this.$label.length;

      for (labelIndex = 0; labelIndex < labelLength; labelIndex++) {
        if (this.$label[labelIndex] && Components.__GetWidgetConstructor(this.$label[labelIndex]) != null) {
          $(this.$label[labelIndex]).ojLabel('destroy');
        }
      }
    }

    return ret;
  },

  /**
   * @memberof oj.editableValue
   * @instance
   * @override
   * @protected
   * @since 5.0.0
   */
  GetFocusElement: function GetFocusElement() {
    return this._GetContentElement()[0];
  },

  /**
   * Called (by the widget factory) when the option changes, this method responds to the change
   * by refreshing the component if needed. This method is not called for the options passed in
   * during the creation of the widget.
   *
   * @param {string} name of the option
   * @param {Object|string} value
   * @param {Object?} flags - optional flags. The following flags are currently supported:
   * <ul>
   *  <li>changed - true if the caller wants to indicate the value has changed, so no comparison is necessary</li>
   * </ul>
   *
   * @expose
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _setOption: function _setOption(name, value, flags) {
    var retVal;
    var skipSetOption = false;
    var oldValue;
    var newValue;

    switch (name) {
      case 'messagesHidden':
        // this option can never be set programmatically by page author
        skipSetOption = true;
        break;

      case 'messagesShown':
        // this option can never be set programmatically by page author
        skipSetOption = true;
        break;

      case 'rawValue':
        // rawValue is readOnly, so throw an error here.
        skipSetOption = true;
        break;

      case 'describedBy':
        // This sets the aria-describedby on the correct dom node
        oldValue = this.options.describedBy;
        newValue = value;

        this._describedByUpdated(oldValue, newValue);

        break;

      case 'labelledBy':
        if (value) {
          this._labelledByUpdated(value);
        }

        break;

      case 'readOnly':
        this._addRemoveOjReadOnlyClassOnLabel(document.getElementById(this.options.labelledBy), value);

        break;

      default:
        break;
    }

    if (skipSetOption) {
      Logger.error(name + ' option cannot be set');
      return this;
    } // Step 2: Update option value


    retVal = this._superApply(arguments); // Step 3: Do post processing like triggering events, refreshing component DOM etc.

    this._AfterSetOption(name, flags);

    return retVal;
  },
  // *********** END WIDGET FACTORY METHODS **********

  /**
   * Returns a jquery object of the element(s) representing the content node. This could be a jQuery
   * object of the element the widget was invoked on - typically this is an input or select or
   * textarea element for which a value can be set. It could be more than one dom node.
   *
   * @memberof oj.editableValue
   * @instance
   * @protected
   * @return {jQuery} the jquery element that represents the editable content. E.g., an input
   */
  _GetContentElement: function _GetContentElement() {
    return this.element;
  },

  /**
   * Returns a jquery object of the element(s) representing the label node(s) for the input
   * component.
   * First we look for the aria-labelledby attribute on the input.
   * If that's not found, we look for the label with 'for' attribute
   * pointing to input.
   * If that's not found, we walk up the dom looking for aria-labelledby.
   * Note: multiple labels for one input is legal in html-5.
   * This is called for widget components, not custom components.
   * We check as well inside this function and return if a custom component.
   * @memberof oj.editableValue
   * @instance
   * @protected
   * @return {Object} the jquery element that represents the input component's label.
   *  return null if it can't find anything.
   */
  _GetLabelElement: function _GetLabelElement() {
    if (this._IsCustomElement()) {
      return null;
    }

    var ariaElement;
    var labelQuery;

    if (this.$label) {
      return this.$label;
    }

    if (oj.EditableValueUtils.hasNoLabelFlag(this.widget())) {
      return null;
    } // If input has aria-labelledby set, then look for label it is referring to.


    var queryResult = this._getAriaLabelledByElement(this.element);

    if (queryResult !== null && queryResult.length !== 0) {
      return queryResult;
    } // if no aria-labelledby is on the input, then look for a label with 'for'
    // set.


    var id = this.element[0].id;

    if (id !== undefined) {
      labelQuery = "label[for='" + id + "']";
      queryResult = $(labelQuery);

      if (queryResult.length !== 0) {
        return queryResult;
      }
    } // if no aria-labelledby on input and no label with 'for' pointing to input,
    // then as a final step we walk up the dom to see if aria-labelledby is set.
    // If so, then we find the label it is referring to.
    // This would be the case when you have multiple inputs grouped in a div
    // <label id="grouplabel">Address</label>
    // <div aria-labelledby="grouplabel"><input/><input/><input/></div>


    ariaElement = this.element.closest('[aria-labelledby]');

    if (ariaElement.length !== 0) {
      // Element has aria-labelledby set, so look for label it is referring to.
      queryResult = this._getAriaLabelledByElement(ariaElement);

      if (queryResult !== null && queryResult.length !== 0) {
        return queryResult;
      }
    }

    return null;
  },

  /**
   * Returns the element's value. Normally, this is a call to this.element.val(), but for some
   * components, it could be something else. E.g., for ojRadioset the element's value is really the
   * value of the selected radio in the set.
   *
   * @override
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _GetElementValue: function _GetElementValue() {
    return this.element.val();
  },

  /**
   * Returns a jquery object of the element that triggers messaging behavior. The trigger element
   * is usually an input or select or textarea element for which a value can be set/retrieved and
   * validated.
   *
   * @return {jQuery} jquery object
   *
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _GetMessagingLauncherElement: function _GetMessagingLauncherElement() {
    return this._GetContentElement();
  },

  /**
   * Returns the normalized converter instance. Since EditableValue does not have a converter
   * option, this returns null.
   *
   * @return {Object} null
   *
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _GetConverter: function _GetConverter() {
    return null;
  },

  /**
   * Returns an array of implicit validators setup by component. This list contains validators for
   * the internal use of the component and are not a part of this.options.validators. <br/>
   * E.g., if the pattern attribute or option is set, a RegExpValidator instance is automatically
   * created and added to this list. <br/>
   * RequiredValidator is tracked separately from the default validators.
   *
   * @return {Object} a map of string name to the validator instance.
   *
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _GetImplicitValidators: function _GetImplicitValidators() {
    if (!this._implicitSyncValidators) {
      this._implicitSyncValidators = {};
    }

    return this._implicitSyncValidators;
  },

  /**
   * Returns the display value that is ready to be passed to the converter.
   *
   * @param {Object} value the stored value if available that needs to be formatted for display
   * @return {string} usually a string display value
   *
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  // eslint-disable-next-line no-unused-vars
  _GetDisplayValue: function _GetDisplayValue(value) {
    return this._GetContentElement().val();
  },

  /**
   * For components that have the 'validators' option,
   * this returns an array of all validators
   * normalized from the validators option set on the component. <br/>
   * Since EditableValue does not include the 'validators' option, this returns [].
   *
   * @return {Array} of validators.
   * Since EditableValue does not include the 'validators' option, this returns [].
   *
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _GetNormalizedValidatorsFromOption: function _GetNormalizedValidatorsFromOption() {
    return [];
  },

  /**
   * For components that have the 'async-validators' attribute,
   * this returns an array of all validators
   * normalized from the async-validators property set on the component. <br/>
   * Since EditableValue does not include the 'validators' option, this returns [].
   *
   * @return {Array} of validators.
   * Since EditableValue does not include the 'validators' option, this returns [].
   *
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _GetNormalizedAsyncValidatorsFromOption: function _GetNormalizedAsyncValidatorsFromOption() {
    return [];
  },

  /**
   * Returns an array of all validators built by merging the validators
   * option set on the component and the implicit validators
   * setup by the component. As of v8.0, these can be async or sync.<br/>
   * This does not include the implicit required validator.
   * Components can override to add to this
   * array of validators.
   *
   * @return {Array} of validators
   *
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _GetAllValidatorsFromValidatorsOptionAndImplicit: function _GetAllValidatorsFromValidatorsOptionAndImplicit() {
    var allValidators = [];
    var idx;
    var implicitValidatorMap;
    var implicitValidators;
    var normalizedValidators; // this flag helps us only get or create the validators once, not every time
    // we want to get a hint or validate.

    if (!this._allValidators) {
      implicitValidatorMap = this._GetImplicitValidators();
      implicitValidators = []; // combine public and implicit validators to get the combined list

      var keys = Object.keys(implicitValidatorMap);
      var valType;
      var len = keys.length;

      if (len > 0) {
        for (idx = 0; idx < len; idx++) {
          valType = keys[idx];
          implicitValidators.push(implicitValidatorMap[valType]);
        }

        allValidators = allValidators.concat(implicitValidators);
      }

      normalizedValidators = this._GetNormalizedValidatorsFromOption();

      if (normalizedValidators.length > 0) {
        // Add normalize validators
        normalizedValidators.forEach(function (normalizedValidator) {
          allValidators.push(normalizedValidator);
        });
      }

      this._allValidators = allValidators;
    }

    return this._allValidators;
  },

  /**
   * This method also updates the messaging strategies as hints associated with validators could
   * have changed.
   *
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _ResetAllValidators: function _ResetAllValidators() {
    if (this._allValidators) {
      this._allValidators.length = 0;
    }

    this._allValidators = null;

    if (this._IsCustomElement()) {
      // This gets sync and async validator hints.
      // nothing should be waiting on this, so no need to return a Promise.
      this._updateValidatorMessagingHint();
    } else {
      // update messagingstrategy as hints associated with validators could have changed
      this._getComponentMessaging().update(this._getValidatorHintsMC());
    }
  },

  /**
   * Return the element on which aria-label can be found.
   * Usually this is the root element, but some components have aria-label as a transfer attribute,
   * and aria-label set on the root element is transferred to the inner element.
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _GetAriaLabelElement: function _GetAriaLabelElement() {
    return this._getRootElement();
  },

  /**
   * Sets or removes oj-read-only class on element based on readonly value.
   *
   *
   * @param {HTMLElement|undefined} element
   * @param {boolean|undefined} readonly Could be undefined in component does not have readonly
   * option at all.
   *
   * @memberof oj.editableValue
   * @instance
   * @private
   */
  _addRemoveOjReadOnlyClassOnLabel: function _addRemoveOjReadOnlyClassOnLabel(element, readonly) {
    if (element && readonly !== undefined) {
      var readonlystyleclass = 'oj-read-only';

      if (readonly) {
        element.classList.add(readonlystyleclass);
      } else {
        element.classList.remove(readonlystyleclass);
      }
    }
  },

  /**
   * This is used to set the aria label from the label hint, and also
   * updates the readonly div from aria-label if specified.
   * @memberof oj.editableValue
   * @instance
   * @private
   */
  _setAriaLabelFromLabelHint: function _setAriaLabelFromLabelHint() {
    if (this._IsCustomElement()) {
      var ariaLabelElem = this._GetAriaLabelElement();

      var ariaLabel = ariaLabelElem.getAttribute('aria-label');

      var readonlyDiv = this._getReadonlyDiv();

      if (!this.options.labelledBy && this.options.labelHint && this.options.labelEdge === 'none' && (!ariaLabel || ariaLabel === this._ariaLabelFromHint) && !this._getRootElement().getAttribute('aria-labelledby')) {
        // Set aria-label if all of the followings are true:
        // 1. This is a custom element.
        // 2. There is no labelledBy option.
        // 3. There is a labelHint option.
        // 4. labelEdge option is set to 'none' (this will only be set by app)
        // 5. There is no aria-label attribute or the aria-label was set by us.
        // 6. There is no aria-labelledby attribute.
        ariaLabelElem.setAttribute('aria-label', this.options.labelHint); // Set on the readonly div if it exists as well.

        if (readonlyDiv) {
          readonlyDiv.setAttribute('aria-label', this.options.labelHint);
        } // Remember what we set aria-label to


        this._ariaLabelFromHint = this.options.labelHint;
      } else if (this._ariaLabelFromHint && this._ariaLabelFromHint === ariaLabel) {
        // If we have set aria-label previously and no one has changed it, remove it
        // if the current condition no longer need to set aria-label.
        ariaLabelElem.removeAttribute('aria-label'); // remove from the readonly div as well.

        if (readonlyDiv) {
          readonlyDiv.removeAttribute('aria-label');
        }
      } else if (ariaLabel) {
        // The app dev specified 'aria-label' explicitly.
        if (readonlyDiv) {
          readonlyDiv.setAttribute('aria-label', ariaLabel);
        }
      } else if (readonlyDiv) {
        // No ariaLabel, so remove it from the readonly div
        readonlyDiv.removeAttribute('aria-label');
      }
    }
  },

  /**
   * Returns an array of all validators with a hint property. We
   * look on the attributes validators and async-validators as well
   * as in the implicit validators.
   * Having a 'hint' property means they are async validators since
   * the AsyncValidator interface has  an optional 'hint' property
   * whereas the Validator interface has an optional getHint function.
   *
   * @return {Array} of async validators that have hints, [] if none
   *
   * @memberof oj.editableValue
   * @instance
   * @private
   */
  _getAllAsyncValidatorsWithHint: function _getAllAsyncValidatorsWithHint() {
    var allAsyncValidators = this._GetNormalizedAsyncValidatorsFromOption();

    var allAsyncValidatorsWithHints = [];
    var i;
    var validator;

    if (this._IsRequired()) {
      // get the hint for the default required validator and push into array
      validator = this._getImplicitRequiredValidator();

      if ('hint' in validator) {
        allAsyncValidatorsWithHints.push(validator);
      }
    }

    if (allAsyncValidators.length > 0) {
      for (i = 0; i < allAsyncValidators.length; i++) {
        validator = allAsyncValidators[i];

        if ('hint' in validator) {
          allAsyncValidatorsWithHints.push(validator);
        }
      }
    } // gets implicit validators and all validators from the validators option.


    var allValidators = this._GetAllValidatorsFromValidatorsOptionAndImplicit();

    if (allValidators.length > 0) {
      for (i = 0; i < allValidators.length; i++) {
        validator = allValidators[i];

        if ('hint' in validator) {
          allAsyncValidatorsWithHints.push(validator);
        }
      }
    }

    return allAsyncValidatorsWithHints;
  },

  /**
    * Initialize async validator messaging hints, if any.
    * This is called from the ComponentMessaging, not during component
    * initialization.
    *
    * @memberof oj.editableValue
    * @instance
    * @private
    */
  _initAsyncValidatorMessagingHint: function _initAsyncValidatorMessagingHint() {
    var allAsyncValidatorsWithHint = this._getAllAsyncValidatorsWithHint();

    var currentCounter;
    var syncValidatorHintMC;
    var self = this;
    this._asyncValidatorHintCounter = 0;

    if (allAsyncValidatorsWithHint.length > 0) {
      // get the sync validators hints  we are already showing so we can show it with
      // the async validators hints
      syncValidatorHintMC = this._getValidatorHintsMC(); // we use a counter to keep track of the busycontext
      // if we get a more recent update async validators hint requests
      // i.e., asyncValidators property is changed, and we want to ignore any previous
      // hints Promise results. See _updateValidatorMessagingHint.

      currentCounter = this._asyncValidatorHintCounter;

      this._setBusyStateAsyncValidatorHint(currentCounter); // get the async validators hints and show them as well as they resolve


      this._addAsyncValidatorsHintsMessagingContent(allAsyncValidatorsWithHint, syncValidatorHintMC).then(function () {
        self._clearBusyStateAsyncValidatorHint(currentCounter);
      });
    }
  },

  /*
   Called from ComponentMessaging as well.
   * @memberof oj.editableValue
   * @instance
   * @private
   */
  _getValidatorHintsMC: function _getValidatorHintsMC() {
    return this._getMessagingContent(this._MESSAGING_CONTENT_UPDATE_TYPE.VALIDATOR_HINTS);
  },

  /**
   * This gets all asyncValidators that have hints,
   * asynchronously updates the component messaging validator hints with BOTH
   * synchronous and async validators' hints.
   * If there are no asyncValidators with hints, it updates validator hints with sync hints.
   * This is called when asyncValidators property changes or when validators property changes.
   * See #_ResetAllValidators. Not called now from ResetAllValidators.
   *
   * @memberof oj.editableValue
   * @instance
   * @private
   */
  _updateValidatorMessagingHint: function _updateValidatorMessagingHint() {
    var allAsyncValidatorsWithHint = this._getAllAsyncValidatorsWithHint();

    var compMessagings = this._getComponentMessaging();

    var currentCounter;
    var self = this; // this gets all validators with getHint (these are sync validators)

    var syncValidatorHintMC = this._getValidatorHintsMC();

    if (allAsyncValidatorsWithHint.length > 0) {
      // we use a counter to keep track of the busycontext
      // if we get a more recent update async validators hint requests
      // i.e., asyncValidators property is changed.
      this._asyncValidatorHintCounter += 1;
      currentCounter = this._asyncValidatorHintCounter;

      this._setBusyStateAsyncValidatorHint(currentCounter);

      this._addAsyncValidatorsHintsMessagingContent(allAsyncValidatorsWithHint, syncValidatorHintMC).then(function () {
        self._clearBusyStateAsyncValidatorHint(currentCounter);
      });
    } else {
      // if this is [], this causes the notewindow to close if it was open.
      // and we don't want to close/reopen if possible, so don't do this before
      // updating async validator hints. Do it in updating async validator hints.
      compMessagings.update(syncValidatorHintMC);
    }
  },

  /**
   * This is called when we have async validators and we want to add
   * their hints, if any, to the componentMessaging. It also adds
   * the sync validator hints as well.
   * This function will also return a Promise that will resolve when we have updated
   * the componentMessaging with all the hints, async and sync.
   *
   * @param {Array} asyncValidatorsWithHints
   *  Array of asyncValidators that are in the async-validators attribute and have hints
   * @param {string} syncValidatorHintMC
   *  hint messaging content from sync validators.
   * @return {Promise} Promise that when resolves will have the hints
   * @memberof oj.editableValue
   * @instance
   * @private
   */
  _addAsyncValidatorsHintsMessagingContent: function _addAsyncValidatorsHintsMessagingContent(asyncValidatorsWithHint, syncValidatorHintMC) {
    var i; // use counter to ignore if we get a more recent update async validators hint requests
    // i.e., asyncValidators property is changed.

    var asyncValidatorHintCounter = this._asyncValidatorHintCounter;

    var compMessagings = this._getComponentMessaging();

    var hintArray = [];
    var self = this; // We kick off all the async validators.hint simultaneously. When they all resolve/reject,
    // then we can move on.

    var promiseArray = [];

    for (i = 0; i < asyncValidatorsWithHint.length; i++) {
      promiseArray.push(asyncValidatorsWithHint[i].hint);
    }

    function reflect(promise) {
      return promise.then(function (v) {
        var status;
        var validatorHintMessagingContent = {}; // update hint as we get it
        // use counter to ignore if we get a more recent update async validators hint requests
        // i.e., asyncValidators property is changed.

        if (self._asyncValidatorHintCounter === asyncValidatorHintCounter) {
          if (v !== null) {
            hintArray.push(v);
            validatorHintMessagingContent.validatorHint = syncValidatorHintMC.validatorHint.concat(hintArray);
            compMessagings.update(validatorHintMessagingContent);
          }

          status = 'resolved';
        } else {
          status = 'ignore';
        }

        return {
          v: v,
          status: status
        };
      }, function (e) {
        // we don't update the hintArray when the hint Promise rejects.
        // No need to check the counter in this case because there is nothing
        // to 'ignore'.
        return {
          e: e,
          status: 'rejected'
        };
      });
    }

    return new Promise(function (resolve) {
      // Promise.all will end as soon as it gets its first rejection. We don't want that.
      // We want to wait until all promises either resolve or reject. Then we can resolve this
      // outer promise. We do this using the reflect function defined above.
      Promise.all(promiseArray.map(reflect)).then(function () {
        resolve(hintArray);
      });
    });
  },

  /**
   * Whether the component is required. EditableValue doesn't support the required option,
   * so return false.  This allows us to keep some of the required code in EditableValue.
   *
   * @return {boolean} true if required; false
   *
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _IsRequired: function _IsRequired() {
    return false;
  },

  /**
   * Convenience handler for the DOM 'change' event. Subclasses are expected to wire up event
   * handlers for DOM events that they wish to handle.<br/>
   *
   * The implementation retrieves the display value for the component by calling _GetDisplayValue()
   * and calls _SetValue(), with full validation.
   *
   * @param {Event} event DOM event
   *
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _HandleChangeEvent: function _HandleChangeEvent(event) {
    var submittedValue = this._GetDisplayValue(); // run full validation


    this._SetValue(submittedValue, event);
  },

  /**
   * Convenience function to set the rawValue option. Called by subclasses
   *
   * @param {String} val value to set rawValue to
   * @param {Event} event DOM event
   *
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _SetRawValue: function _SetRawValue(val, event) {
    var flags = {};
    flags._context = {
      originalEvent: event,
      writeback: true,
      internalSet: true,
      readOnly: true
    };

    if (!this._CompareOptionValues('rawValue', this.options.rawValue, val)) {
      this.option('rawValue', val, flags);
    }
  },

  /**
  * This method takes a value from a value change listener
  * and determines if it is 'empty'. This is used to toggle a
  * 'oj-has-no-value' style class.
  * This method is generic enough to be used by all EditableValue components,
  * but can be overridden by component if needed.
  *
  * @memberof oj.editableValue
  * @instance
  * @protected
  */
  _IsValueEmpty: function _IsValueEmpty(value) {
    if (value === undefined || value === null) {
      return true;
    } else if (typeof value === 'string') {
      return oj.StringUtils.isEmptyOrUndefined(value);
    } else if (typeof value === 'number') {
      return isNaN(value);
    } else if (Array.isArray(value)) {
      // oj-select-many setting observable(undefined) returns an array with
      // an undefined value versus an undefined value
      return value.length === 0 || value.length === 1 && (value[0] === null || value[0] === undefined);
    }

    return false;
  },

  /**
  * This method toggles a
  * 'oj-has-no-value' style class.
  *
  * @memberof oj.editableValue
  * @instance
  * @private
  */
  _toggleOjHasNoValueClass: function _toggleOjHasNoValueClass(value) {
    var element = this._getRootElement();

    if (this._IsValueEmpty(value)) {
      element.classList.add('oj-has-no-value');
    } else {
      element.classList.remove('oj-has-no-value');
    }
  },

  /**
   * Called in response to a change in the options set for this component, this method refreshes the
   * component display value. Subclasses can override to provide custom refresh behavior.
   *
   * @param {String=} name the name of the option that was changed
   * @param {Object=} value the current value of the option
   * @param {boolean=} forceDisplayValueRefresh
   *
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _Refresh: function _Refresh(name, value, forceDisplayValueRefresh) {
    var helpDef;
    var helpSource;

    switch (name) {
      case 'converter':
        var _value = this.options.value;

        this._refreshComponentDisplayValue(_value, forceDisplayValueRefresh);

        break;

      case 'disabled':
        this._refreshTheming('disabled', this.options.disabled);

        break;

      case 'help':
        if (!this._IsCustomElement()) {
          // refresh the help - need to keep the label in sync with the input.
          if (this.$label) {
            helpDef = this.options.help.definition;
            helpSource = this.options.help.source;
            this.$label.ojLabel('option', 'help', {
              definition: helpDef,
              source: helpSource
            });
            var label = this.$label[0];

            if (label) {
              var labelId = label.id;

              if (labelId) {
                var ariaId = labelId + _HELP_ICON_ID;

                if (helpSource != null || helpDef != null) {
                  this._describedByUpdated(null, ariaId);
                } else {
                  this._describedByUpdated(ariaId, null);
                }
              }
            }
          }
        }

        break;

      case 'value':
        this._refreshComponentDisplayValue(value, forceDisplayValueRefresh);

        break;

      default:
        break;
    }
  },

  /**
   * <p>Notifies the component that its subtree has been made hidden programmatically
   * after the component has been created.
   *
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _NotifyHidden: function _NotifyHidden() {
    this._superApply(arguments);

    this._getComponentMessaging().close();
  },

  /**
   * <p>Notifies the component that its subtree has been removed from the
   * document programmatically after the component has
   * been created.
   *
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _NotifyDetached: function _NotifyDetached() {
    this._superApply(arguments);

    this._getComponentMessaging().close();
  },

  /**
   * Called anytime the label DOM changes requiring a reset of any dependent feature that caches the
   * label, including all validators.
   *
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _ResetComponentState: function _ResetComponentState() {
    // the DOM for the label and its text could have changed.
    if (this.$label) {
      this.$label.ojLabel('refresh');
    } // reset all validators when label changes


    this._implicitReqValidator = null;
    this._converter = null;

    this._ResetAllValidators();
  },

  /**
   * Called when the display value on the element needs to be updated. This method updates the
   * (content) element value. Widgets can override this method to update the element appropriately.
   *
   * @param {String} displayValue of the new string to be displayed
   *
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _SetDisplayValue: function _SetDisplayValue(displayValue) {
    var contentElem = this._GetContentElement();

    if (contentElem.val() !== displayValue) {
      contentElem.val(displayValue);
    }
  },

  /**
   * Sets the disabled option onto the dom.
   * Component subclasses can override this method to not do this in cases where it is invalid,
   * like on a div (e.g., radioset's root dom element is a div).
   * @param {Object} node - dom node
   *
   * @memberof oj.editableValue
   * @instance
   * @protected
   * @since 1.0.0
   */
  _SetDisabledDom: function _SetDisabledDom(node) {
    if (typeof this.options.disabled === 'boolean') {
      node[0].disabled = this.options.disabled; // eslint-disable-line no-param-reassign
    }
  },

  /**
   * Sets the placeholder text on the content element by default. It sets the placeholder attribute
   * on the element. Component subclasses can override this method to control where placeholder text
   * gets set.
   * @param {string} value
   *
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _SetPlaceholder: function _SetPlaceholder(value) {
    var contentElem = this._GetContentElement()[0];

    if (contentElem) {
      if (value == null) {
        contentElem.removeAttribute('placeholder');
      } else {
        contentElem.setAttribute('placeholder', value);
      }
    }
  },

  /**
   * Sets the placeholder option with the value.
   *
   * @param {string} value
   *
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _SetPlaceholderOption: function _SetPlaceholderOption(value) {
    this.options.placeholder = value;
  },

  /**
   * whether the placeholder option is set
   *
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _HasPlaceholderSet: function _HasPlaceholderSet() {
    //  - an empty placeholder shows up if data changed after first binding
    return this.options.placeholder;
  },

  /**
   * Clear the placeholder option
   *
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _ClearPlaceholder: function _ClearPlaceholder() {
    //  - an empty placeholder shows up if data changed after first binding
    this._SetPlaceholderOption('');

    this._SetPlaceholder('');
  },

  /**
   * Runs full validation on the newValue (usually the display value) and sets the parsed value on
   * the component if value passes basic checks and there are no validation errors. <br/>
   * If the newValue is undefined or if it is the same as the last saved displayValue this method
   * skips validation and does not set value (same as ADF). It also updates messages shown
   * if there are errors, and it updates the 'valid' property on the component.<br/>
   * This method returns a Promise if there are async validators
   *  on the component (introduced in v5.2 for custom elements), so if you call this method,
   * and you do work after this method returns that cares about
   * what the value option is, if there are error messages showing, or what the 'valid' state is,
   * then you need to see if the return value is an instanceof Promise,
   * and if so, then you need to wait until it resolves before moving on.
   *
   * @param {string|Object} newValue the ui value that needs to be parsed before it's set.
   * @param {Object=} event an optional event if this was a result of ui interaction. For user
   * initiated actions that trigger a DOM event, passing this event is required. E.g., if user action
   * causes a 'blur' event.
   * @param {Object=} options - an Object literal that callers pass in to determine how validation
   * gets run.
   * @param {boolean=} options.doValueChangeCheck - if set to true compare newValue with last
   * displayValue before running validation; if false, always run validation. E.g., set to false
   * when validate() is called.
   * @param {boolean=} options.doNotClearMessages - if set method will not clear all messages. This
   * is provided for callers that may want to clear only some of the messages. E.g., when required
   * option changes, it clears only component messages, not custom.
   * @param {Array<string>=} options.targetOptions - if specified, only the options specified in
   * this array will be set. If not specified, the "value" option will be set.
   * @param {number=} options.validationMode - accepted values (defined in _VALIDATION_MODE) are:
   * <ul>
   *   <li>FULL - the default and runs both the converter and all validators. </li>
   *   <li>VALIDATORS_ONLY - runs all validators including the required validator is run.</li>
   *   <li>REQUIRED_VALIDATOR_ONLY - runs just the required validator. </li>
   * </ul>
   * @return {Promise|boolean} Promise that resolves to false
   * if value was not set due to validation error,
   * else true, or for widget code or components that do not have async validators or
   * converters, boolean false if value was not set, true otherwise.
   * @example  <caption>Widget subclasses can use this convention to run full validation</caption>
   * this._SetValue(value, event);
   *
   * @memberof oj.editableValue
   * @instance
   * @protected
   *
   */
  _SetValue: function _SetValue(newValue, event, options) {
    var clearBusyStateKey;
    var doValueChangeCheck = options && typeof options.doValueChangeCheck === 'boolean' ? options.doValueChangeCheck : true;
    var self = this;
    var resolvedState = false;
    var validateReturn;
    var fulfilledNewValue; // we want to add/remove the oj-has-no-value styleclass so we can style based on
    // if there is something in the field.
    // this is where we validate what the user has typed in, so it is a good place
    // to check this styleclass.

    this._toggleOjHasNoValueClass(newValue); // disallow setting a value of undefined by widgets


    if (newValue === undefined) {
      Logger.warn('Attempt to set a value of undefined');
      return false;
    }

    if (!doValueChangeCheck || newValue !== self._getLastDisplayValue()) {
      // AsyncValidate returns a promise if the component has async validators
      // that will be resolved to the successfully parsed value
      // if successful or undefined if not successful or was ignored because a newer _AsyncValidate
      // came in.
      // for non-async, it returns the parsed value or undefined if validation failed or
      // was ignored.
      clearBusyStateKey = '' + newValue + '_' + (this._asyncValidatorValidateCounter + 1);
      validateReturn = this._AsyncValidate(newValue, event, options, clearBusyStateKey);

      if (!(validateReturn instanceof Promise)) {
        // Synchronous validation only.
        this._afterAsyncValidateUpdateValue(validateReturn, event, options);

        resolvedState = validateReturn !== undefined;
      } else {
        resolvedState = validateReturn.then(function (fnv) {
          fulfilledNewValue = fnv;
          return self._afterAsyncValidateUpdateValue(fnv, event, options);
        }).then(function () {
          self._clearBusyState(clearBusyStateKey);

          return fulfilledNewValue !== undefined;
        });
      }
    } else if (Logger.level > Logger.LEVEL_WARN) {
      Logger.info('Validation skipped and value option not updated as submitted value "' + newValue.toString ? newValue.toString() : newValue + '" same as previous.');
    }

    return resolvedState;
  },

  /**
   * Parses the value and shows an error, if any.
   * </p>
   *
   * @param {string|Object} newValue the value to parse. Usually this is the string display value
   * @param {Object=} event an optional event if this was a result of ui interaction. For user
   * initiated actions that trigger a DOM event, passing this event is required. E.g., if user action
   * causes a 'blur' event.
   *
   * @return {Object|string|undefined} the parsed value or undefined if parse failed.
   *
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _ParseValueShowErrors: function _ParseValueShowErrors(newValue, event) {
    var newMsgs;
    var parsedValueReturn;
    var self = this;

    this._clearAllMessages(event);

    try {
      // Step1: Parse value using converter.
      parsedValueReturn = this._parseValue(newValue, event); // It's the successfully parsed value from
      // a synchronous converter.

      return parsedValueReturn;
    } catch (ve) {
      // _parseValue failed
      // turn this into Array of oj.ComponentMessage instances.
      // This is what we set on 'messagesShown'
      newMsgs = self._processValidationErrors(ve);

      self._updateMessagesOption('messagesShown', newMsgs, event);

      self._setValidOption(_INVALID_SHOWN, event);
    }

    return undefined;
  },

  /**
   * Runs full validation on the value. If value fails basic checks
   * (see <a href="#_CanSetValue">_CanSetValue</a>, or if value failed validation, this method
   * returns undefined. Otherwise it returns the successfully parsed value. If validation
   * is async, this returns a Promise that resolves to the successfully parsed and
   * validated value, or undefined if unsuccessful or ignored. As soon as we know that something
   * has failed, we set valid to INVALID_SHOWN, when all pass we set valid to VALID.
   * <p>
   * Components should call this method if they know UI value has changed and want to set the
   * new component value.
   * </p>
   * <p>
   * This method works with any combination of synchronous and asynchronous validators.
   * <p>
   *
   * @param {string|Object} newValue the actual value to be set. Usually this is the string display value
   * @param {Object=} event an optional event if this was a result of ui interaction. For user
   * initiated actions that trigger a DOM event, passing this event is required. E.g., if user action
   * causes a 'blur' event.
   * @param {{doNotClearMessages:boolean,validationContext:number,validationMode:number}=} options
   * an Object literal that callers pass in to determine how validation gets run.
   * @param {boolean=} options.doNotClearMessages - if set method will not clear all messages. This
   * is provided for callers that may want to clear only some of the messages. E.g., when required
   * option changes, it clears only component messages, not custom.
   * @param {number=} options.validationContext - the context this method was called. When not set it
   * defaults to _VALIDATION_CONTEXT.USER_ACTION.
   * @param {number=} options.validationMode - accepted values defined in _VALIDATION_MODE
   * @param {string=} busyStateKey key used to set the busy context. The calling function will
   * clear it.
   *
   * @return {Promise.<Object|string|undefined>|Object|string|undefined}
   * A promise if the component has async validators
   * that will be resolved to the successfully parsed value
   * if successful or undefined if not successful or to be ignored due to a newer validation
   * request coming in.
   * the parsed value or undefined if validation failed.
   *
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _AsyncValidate: function _AsyncValidate(newValue, event, options, busyStateKey) {
    var mode = options && options.validationMode ? options.validationMode : this._VALIDATION_MODE.FULL;
    var context = options && options.validationContext ? options.validationContext : this._VALIDATION_CONTEXT.USER_ACTION;
    var doNotClearMessages = options && options.doNotClearMessages || false;
    var newMsgs;
    var successfullyParsedValue;
    var self = this;
    var validateReturn; // disallow setting a value of undefined by widgets

    if (newValue === undefined) {
      Logger.warn('Attempt to set a value of undefined');
      return undefined;
    } else if (this._CanSetValue()) {
      if (!doNotClearMessages) {
        this._clearAllMessages(event);
      } // Stores the newValue we are validating. This is consulted to decide whether or
      // not we skip _SetValue
      // if newValue !== self._getLastDisplayValue()


      try {
        // update the validate counter here, before we call _asyncValidateValue,
        // because we refer to it there to know if we need to ignore a validation result if a new
        // async one came in after.
        this._asyncValidatorValidateCounter += 1; // Step 1: only when "full" validation is requested converters get run

        if (mode === self._VALIDATION_MODE.FULL) {
          this._setLastDisplayValue(newValue); // Step1: Parse value using converter. set valid state to pending in here.


          successfullyParsedValue = this._parseValue(newValue, event, true);
        } else {
          successfullyParsedValue = newValue;
        } // Step 2: Parse didn't throw an error.
        // Run validators and set valid state
        // asyncValidateValue will return a Promise if the component has async validators,
        // otherwise it returns the value if successful or undefined if not.


        validateReturn = self._asyncValidateValue(successfullyParsedValue, event, context);

        if (!(validateReturn instanceof Promise)) {
          return validateReturn;
        } // validateReturn Promise resolves to 'valid' if all validators pass.
        // Resolves to 'invalidShown' if any validator fails.
        // Resolves to 'ignoreValidation' if we are to ignore validation results.


        self._setBusyState(busyStateKey);

        return validateReturn.then(function (valid) {
          if (valid === _VALID) {
            return successfullyParsedValue;
          }

          return undefined;
        });
      } catch (ve) {
        // SYNCHRONOUS _parseValue failed
        // turn this into Array of oj.ComponentMessage instances.
        // This is what we set on 'messagesShown'
        newMsgs = self._processValidationErrors(ve, context);

        self._updateMessagesOption('messagesShown', newMsgs, event);

        self._setValidOption(_INVALID_SHOWN, event);
      }
    } else if (Logger.level > Logger.LEVEL_WARN) {
      Logger.info('Validation skipped and value option not set as component state does not ' + ' allow setting value. For example if the component is readonly or disabled.');
    }

    return validateReturn;
  },

  /**
   * After _AsyncValidate, we normally update the value option and format the value to display
   * it, if no errors are showing.
   * This method does nothing if fulfilledNewValue is undefined. It returns false.
   *
   * @param {string|Object} fulfilledNewValue the parsed value. If undefined, this method returns
   * false.
   * @param {Object=} event an optional event if this was a result of ui interaction. For user
   * initiated actions that trigger a DOM event, passing this event is required. E.g., if user action
   * causes a 'blur' event.
   * @param {Object=} options - an Object literal that callers pass in to determine how validation
   * gets run.
   * @param {boolean=} options.doValueChangeCheck - if set to true compare newValue with last
   * displayValue before running validation; if false, always run validation. E.g., set to false
   * when validate() is called.
   * @param {boolean=} options.doNotClearMessages - if set method will not clear all messages. This
   * is provided for callers that may want to clear only some of the messages. E.g., when required
   * option changes, it clears only component messages, not custom.
   * @param {number=} options.validationMode - accepted values (defined in _VALIDATION_MODE) are:
   * <ul>
   *   <li>FULL - the default and runs both the converter and all validators. </li>
   *   <li>VALIDATORS_ONLY - runs all validators including the required validator is run.</li>
   *   <li>REQUIRED_VALIDATOR_ONLY - runs just the required validator. </li>
   * </ul>
   * @return {boolean} true if value was updated, false otherwise.
   *  This method returns false if fulfilledNewValue is undefined.
   * @example  <caption>Widget subclasses can use this convention to run full validation</caption>
   * this._SetValue(value, event);
   *
   * @memberof oj.editableValue
   * @instance
   * @private
   *
   */
  _afterAsyncValidateUpdateValue: function _afterAsyncValidateUpdateValue(fulfilledNewValue, event, options) {
    var resolvedState = false;
    var updateContext;
    var doUpdateValueOption;

    if (fulfilledNewValue !== undefined) {
      if (options && options.doNotClearMessages === true) {
        doUpdateValueOption = this.isValid() || !this._hasInvalidComponentMessagesShowing();
      } else {
        doUpdateValueOption = this.isValid();
      }

      if (doUpdateValueOption) {
        if (options && options._context) {
          updateContext = options._context;
        } // update value option and then format the value and update display value.


        this._updateValueOption(fulfilledNewValue, event, options && options.validationContext, updateContext, options);

        resolvedState = true;
      }
    }

    return resolvedState;
  },
  //* * @inheritdoc */
  _CompareOptionValues: function _CompareOptionValues(option, value1, value2) {
    if (option === 'value' || option === 'rawValue') {
      return oj.Object.compareValues(value1, value2);
    } else if (option.indexOf('messages') === 0) {
      return this._messagesEquals(value1, value2);
    }

    return this._superApply(arguments);
  },

  /**
   * Returns the default styleclass for the component. All input components must override.
   *
   * @return {string}
   *
   * @memberof oj.editableValue
   * @instance
   * @protected
   * @abstract
   */
  _GetDefaultStyleClass: function _GetDefaultStyleClass() {
    oj.Assert.failedInAbstractFunction();
    return '';
  },
  // I N T E R N A L   P R I V A T E   C O N S T A N T S    A N D   M E T H O D S
  // Subclasses should not override or call these methods

  /**
   * Types of messaging content to update.
   * <ul>
   * <li>'INIT' - builds all messaging content needed for component initialization</li>
   * <li>'VALIDITY_STATE' - updates only validityState every time validation runs and there are
   * new messages or when the messages option changes.</li>
   * <li>'CONVERTER_HINT' - updates only converter hints, this is used when converter option
   * changes</li>
   * <li>'VALIDATOR_HINTS' - updates only validator hints, this is used when validators option
   * changes or when validator hints are first shown the the user.</li>
   * <li>'TITLE' - updates only title, when the title property changes</li>
   * </ul>
   * @private
   * @memberof oj.editableValue
   */
  _MESSAGING_CONTENT_UPDATE_TYPE: {
    INIT: 1,
    VALIDITY_STATE: 2,
    CONVERTER_HINT: 3,
    VALIDATOR_HINTS: 4,
    TITLE: 5
  },

  /**
   * when below listed options are passed to the component, corresponding CSS will be toggled
   * @private
   * @const
   * @type {Object}
   * @memberof oj.editableValue
   */
  _OPTION_TO_CSS_MAPPING: {
    disabled: 'oj-disabled',
    required: 'oj-required'
  },

  /**
   * Clears all messages for this component. Today this only happens when <br/>
   *  - the component's value changes as a result of user interaction, <br/>
   *  - the reset method is called, <br/>
   *  - component is destroyed.<br/>
   *
   * @param {Event=} event the original event (for user initiated actions that trigger a DOM event,
   * like blur) or undefined.
   * @param {boolean=} doNotSetOption default value is false; a true value clears the option
   * directly without using the public option method, causing no events to be fired.
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _clearAllMessages: function _clearAllMessages(event, doNotSetOption) {
    if (!doNotSetOption) {
      this._clearMessages('messagesHidden', event);

      this._clearMessages('messagesShown', event);

      this._clearMessages('messagesCustom', event);
    } else {
      this.options.messagesHidden = [];
      this.options.messagesShown = [];
      this.options.messagesCustom = [];
    }
  },

  /**
   * Clears all messages that were added by component. These includes all messages in messagesHidden
   * option and all messages except custom in messagesShown.
   *
   * Called when these options change - validators, disabled, readonly, required, and methods -
   * refresh are called.
   *
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _clearComponentMessages: function _clearComponentMessages() {
    var beforeLen;
    var msg;
    var shownMsgs = this.options.messagesShown;
    beforeLen = shownMsgs.length;

    this._clearMessages('messagesHidden'); // remove component messages in messagesShown. Custom messges are kept intact.


    for (var i = beforeLen - 1; i >= 0; i--) {
      // NOTE: shownMsgs is this.options['messagesShown']
      // so we are modifying this.options['messagesShown'] here.
      msg = shownMsgs[i];

      if (msg instanceof oj.ComponentMessage) {
        shownMsgs.splice(i, 1);
      }
    }

    if (shownMsgs.length !== beforeLen) {
      // Setting 'changed' flag to true means that although we have already
      // updated this.options['messagesShown'], we still want to fire a messagesShownChanged event.
      this._setMessagesOption('messagesShown', shownMsgs, null, true);
    }
  },

  /**
   * Sets the messages option with the new value.
   * Setting 'changed' flag to true means we want to fire a property changed event
   * without checking that the option value to what you are setting it to. Useful
   * if the option is an array or we have already updated the option directly.
   *
   * This method updates the option directly without invoking setOption() method. This is done by
   * setting the following property in flags parameter of the option() method -
   * <code class="prettyprint">{'_context': {internalSet: true}}</code>
   *
   * @param {string} key
   * @param {Array} value
   * @param {Event=} event the event like the user blurred to trigger a messages option change
   * or undefined.
   * @param {Boolean=} changed when this is true, then we set the 'changed' flag to true, and having
   * the changed flag be true will guarantee that the property changed event is fired even if the
   * the property value is equal to what you are setting it to.
   * @private
   * @memberof oj.editableValue
   */
  _setMessagesOption: function _setMessagesOption(key, value, event, changed) {
    var flags = {}; // Optimize for the common 'clear' operation

    var bothEmpty = value.length === 0 && this.options[key].length === 0;

    if (changed || !bothEmpty) {
      // 'messagesCustom' is not read-only, but 'messagesShown' and 'messagesHidden' are
      flags._context = {
        originalEvent: event,
        writeback: true,
        internalSet: true
      };

      if (key !== 'messagesCustom') {
        flags._context.readOnly = true;
      }

      flags.changed = changed || !bothEmpty;

      this._resetValid();

      this.option(key, value, flags);

      this._updateMessagingContent();
    }
  },

  /**
   * Sets the valid option with the new value.
   *
   * This method updates the option directly without invoking setOption() method. This is done by
   * setting the following property in flags parameter of the option() method -
   * <code class="prettyprint">{'_context': {internalSet: true}}</code>
   *
   * @param {string} newValidState The new valid state to set on the valid option
   *   e.g., "pending", "valid", "invalidShown", "invalidHidden"
   * @param {Event=} event the original event (for user initiated actions that trigger a DOM event,
   * like blur) or undefined. The custom element bridge creates a CustomEvent out of this when
   * it sends the property changed event.
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _setValidOption: function _setValidOption(newValidState, event) {
    var flags = {}; // We do not want to set valid state to PENDING if we are already showing messages, e.g., messages-custom.

    if (!(newValidState === _PENDING && this._determineValidFromMessagesOptions() !== _VALID)) {
      // do not set if it is already set to that
      if (newValidState !== this.options.valid) {
        // 'valid' is read-only
        flags._context = {
          originalEvent: event,
          writeback: true,
          internalSet: true,
          readOnly: true
        };
        this.option('valid', newValidState, flags);
      }
    }
  },

  /**
   * Clears the messages and message options - <code class="prettyprint">messagesHidden</code>,
   * <code class="prettyprint">messagesShown</code>, <code class="prettyprint">messagesCustom</code>.
   *
   * @param {String} option messages option that is being cleared.
   * @param {Event=} event the original event (for user initiated actions that trigger a DOM event,
   * like blur) or undefined.
   *
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _clearMessages: function _clearMessages(option, event) {
    this._setMessagesOption(option, [], event);
  },

  /**
   * Clones messages before it's set. <br/>
   *
   * @param {Array=} value
   * @returns {Array} of cloned messages
   *
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _cloneMessagesBeforeSet: function _cloneMessagesBeforeSet(value) {
    var i;
    var msg;
    var msgsClone = [];
    var val; // we want all messages to be an instance of oj.Message. So clone array

    if (value && value.length > 0) {
      for (i = 0; i < value.length; i++) {
        val = value[i];
        msg = new Message(val.summary, val.detail, val.severity);
        msg = Object.freeze ? Object.freeze(msg) : msg;
        msgsClone.push(msg);
      }
    }

    return msgsClone;
  },

  /**
   * Create the ojLabel component with help (required is done in the components that support
   * required) see oj.EditableValueUtils._refreshRequired.
   * This is not supported for custom elements. For pages with custom elements, the app dev
   * uses the public &lt;oj-label> component.
   * @private
   * @memberof oj.editableValue
   * @instance
   *
   */
  _createOjLabel: function _createOjLabel() {
    var helpDef;
    var helpSource;

    if (this._IsCustomElement()) {
      return;
    }

    this.$label = this._GetLabelElement();

    if (this.$label) {
      helpDef = this.options.help.definition;
      helpSource = this.options.help.source; // create the ojLabel component

      this.$label.ojLabel({
        rootAttributes: {
          class: this._GetDefaultStyleClass() + '-label'
        },
        help: {
          definition: helpDef,
          source: helpSource
        }
      });

      this._createDescribedByForLabel();
    }
  },

  /**
   * Refreshes the aria-describedby for label element's helpIcon
   * @protected
   * @memberof oj.editableValue
   * @instance
   */
  _createDescribedByForLabel: function _createDescribedByForLabel() {
    var helpDef = this.options.help.definition;
    var helpSource = this.options.help.source;
    var labelId;

    if (helpSource != null || helpDef != null) {
      var label = this.$label[0]; // get label's helpIconSpan get the id and add it here.

      if (label) {
        labelId = label.id;
      }

      if (labelId) {
        this._describedByUpdated(null, labelId + _HELP_ICON_ID);
      }
    }
  },

  /**
   * Refreshes the component to respond to DOM changes, in which case fullRefresh=true.
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _doRefresh: function _doRefresh() {
    var runFullValidation = false;
    var displayValue; // reset state and re-initialize component messaging, since refresh() can be called when
    // locale changes, requiring component to show messaging artifactsthis._ for current locale.

    this._ResetComponentState();

    this._initComponentMessaging();

    this._Refresh('disabled', this.options.disabled); // runFullValidation, if needed, does a full validation
    // which in turn updates value option and converted display value


    if (this._hasInvalidMessagesShowing()) {
      runFullValidation = true;
    }

    this._clearComponentMessages();

    if (runFullValidation) {
      // this may return a Promise
      displayValue = this._GetDisplayValue(); // runs full validation on the display value. May be async

      this._SetValue(displayValue, null, oj.EditableValueUtils.refreshMethodOptions);
    } else {
      // run deferred validation if comp is either showing a deferred error or has no errors.
      // But only when required is true.
      if (this._IsRequired()) {
        this._runDeferredValidation(oj.EditableValueUtils.refreshMethodOptions.validationContext);
      } // refresh UI display value when there are no errors or where there are only deferred errors


      this._Refresh('value', this.options.value, true);
    }
  },

  /**
   * Gets the last stored model value
   *
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _getLastModelValue: function _getLastModelValue() {
    return this._oj_lastModelValue;
  },

  /**
   * Gets the last display value
   *
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _getLastDisplayValue: function _getLastDisplayValue() {
    // initially, _oj_lastElementValue is undefined. But the browser returns "" for the
    // displayValue.
    if (this._oj_lastElementValue === undefined) {
      this._oj_lastElementValue = '';
    }

    return this._oj_lastElementValue;
  },

  /**
   * Get the element whose id matches the elem's aria-labelledby value, if any.
   * @param {Object} elem the dom element from which you want to get the
   * aria-labelledby property value
   * @return {jQuery|null} if element does not have aria-labelledby defined, then
   *    returns null. If it  does, then return a new jQuery object with the
   *    label with an id equal to the aria-labelledby value. If no match, then
   *    the jQuery object will be empty.
   *
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _getAriaLabelledByElement: function _getAriaLabelledByElement(elem) {
    // this is the widget way of doing things, so return if custom element.
    if (this._IsCustomElement()) {
      return null;
    } // look for a label with an id equal to the value of aria-labelledby.
    // .prop does not work for aria-labelledby. Need to use .attr to find
    // aria-labelledby.


    var ariaId = elem[0].getAttribute('aria-labelledby');
    var labelQuery;

    if (ariaId !== undefined) {
      labelQuery = "label[id='" + ariaId + "']";
      return $(labelQuery);
    }

    return null;
  },

  /**
   * Returns a concat of messagesShown and messagesHidden.
   *
   * @returns {Array}
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _getMessages: function _getMessages() {
    var messages = []; // messagesShown and messagesHidden could be undefined

    if (this.options.messagesShown) {
      messages = messages.concat(this.options.messagesShown);
    }

    if (this.options.messagesHidden) {
      messages = messages.concat(this.options.messagesHidden);
    }

    return messages; // todo: revisit
  },

  /**
   * Helper method to retrieve the label text. Needed for required translation.
   * Returns the form component's label or oj-label's textContent, if the label was found.
   *
   * @return {string|null}
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _getLabelText: function _getLabelText() {
    if (this.$label) {
      return this.$label[0].textContent;
    }

    var ojlabels = oj.EditableValueUtils._getCustomOjLabelElements(this.options.labelledBy);

    var labelTextContent = null;

    if (ojlabels) {
      for (var i = 0; i < ojlabels.length; i++) {
        if (i > 0) {
          labelTextContent += ' ';
        }

        var ojlabel = ojlabels[i];
        labelTextContent = ojlabel.textContent;
      }
    }

    return labelTextContent;
  },

  /**
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _getValidityState: function _getValidityState() {
    if (this._validityState) {
      return this._validityState;
    }

    this._validityState = new oj.ComponentValidity(this.isValid(), this._getMessages());
    return this._validityState;
  },

  /**
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _hasValidityState: function _hasValidityState() {
    if (this._validityState) {
      return true;
    }

    return false;
  },

  /**
   * Whether component has invalid messages.
   *
   * @return {boolean} true if invalid; false otherwise
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _hasInvalidMessages: function _hasInvalidMessages() {
    return !Message.isValid(this._getMessages());
  },

  /**
   * Whether there are invalid messages, that are currently showing.
   *
   * @return {boolean}
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _hasInvalidMessagesShowing: function _hasInvalidMessagesShowing() {
    return !this.isValid() && this.options.messagesShown.length > 0;
  },

  /**
   * Whether component has invalid messages added by component, that are currently showing.
   *
   * @return {boolean}
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _hasInvalidComponentMessagesShowing: function _hasInvalidComponentMessagesShowing() {
    var compMsgs;
    var msg;
    var shown = this.options.messagesShown;

    for (var i = 0; i < shown.length; i++) {
      msg = shown[i];

      if (msg instanceof oj.ComponentMessage && msg._isMessageAddedByComponent()) {
        compMsgs = compMsgs || [];
        compMsgs.push(msg);
      }
    }

    return compMsgs === undefined ? false : !Message.isValid(compMsgs);
  },

  /**
   * Initializes component messaging both when component is initialized or when displayOptions is
   * set/changed. Call this only when you know the converter has resolved.
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _initComponentMessaging: function _initComponentMessaging() {
    var compMessaging = this._getComponentMessaging();

    var messagingLauncher = this._GetMessagingLauncherElement();

    var compContentElement = this._GetContentElement();

    var messagingContent = this._getMessagingContent(this._MESSAGING_CONTENT_UPDATE_TYPE.INIT); // if default placeholder is currently set then it needs to be cleared here. This is needed for
    // the following reasons
    // i. a component is reinitialized when the locale changed, requiring the converter hint for
    // new locale to be set as placeholder.
    // ii. or a component's placeholder option or displayOptions option, could have changed
    // requiring the placeholder to be reset if it's currently set to the default.


    if (!this._customPlaceholderSet) {
      this._ClearPlaceholder();
    } // this sets all messaging content other than messaging content not needed until the user
    // does something to see them. e.g, validator hints are shown until focus on the field.
    // we do this to help initial render performance.


    compMessaging.activate(messagingLauncher, compContentElement, messagingContent); // Async validators hints are retrieved only when they are needed to be shown to the user.
    // See PopupComponentMessaging.js
    // initialize this counter when we initialize the component.
    // It is used to decide whether or not to ignore async validate resolutions.

    this._asyncValidatorValidateCounter = 0;
  },

  /**
   * Called after messagesCustom option changed. This method pushes custom messages to the
   * messagesShown option.
   *
   * @param {Object} flags
   * @returns {undefined}
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _messagesCustomOptionChanged: function _messagesCustomOptionChanged(flags) {
    var context = flags ? flags._context : null;
    var customMsgs = this.options.messagesCustom;
    var i;
    var msg;
    var previousShown = this.options.messagesShown;
    var shownMsgs = []; // remove old custom messages from messagesShown array

    for (i = 0; i < previousShown.length; i++) {
      msg = previousShown[i];

      if (msg instanceof oj.ComponentMessage && msg._isMessageAddedByComponent()) {
        shownMsgs.push(msg);
      }
    } // add new customMsgs to messagesShown


    for (i = 0; i < customMsgs.length; i++) {
      shownMsgs.push(customMsgs[i]);
    } // set 'messagesShown' option as an internal set


    this._setMessagesOption('messagesShown', shownMsgs, context ? context.originalEvent : null, flags && flags.changed);
  },

  /**
   * This is only needed when we use the
   * deprecated display-options.converter-hint=['placeholder','notewindow'] api that is used
   * in the Alta theme and not the Redwood theme.
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _placeholderOptionChanged: function _placeholderOptionChanged(flags) {
    if (this._getResolvedUserAssistance() !== 'displayOptions') {
      return;
    }

    var context = flags && flags._context || {};
    var refreshMessagingOptions = //  internalMessagingSet indicates whether the current change is from the messaging module.
    // see ComponentMessaging for details
    !context.internalMessagingSet;

    if (refreshMessagingOptions) {
      // if placeholder was set and it's not from messaging code, then the messaging display options
      // may need to re-evaluated. E.g., the default display for
      // converterHint: ['placeholder', 'notewindow'] is 'placeholder', but if user were to set a
      // custom placeholder, this changes the default display for convererHint from 'placeholder'
      // to 'notewindow'.
      this._customPlaceholderSet = true;

      if (this._GetConverter()) {
        this._initComponentMessaging();
      }
    } else {
      this._customPlaceholderSet = false;
    }
  },

  /**
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _setLastModelValue: function _setLastModelValue(value) {
    this._oj_lastModelValue = value;
  },

  /**
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _setLastDisplayValue: function _setLastDisplayValue(value) {
    this._oj_lastElementValue = value;
  },

  /**
   * Adds messages to the option specified - <code class="prettyprint">messagesShown</code> or
   * <code class="prettyprint">messagesHidden</code>.
   *
   * @param {String} option name of the option
   * @param {Object|Array} newMsgs an Array of one or more oj.Message object.
   * @param {Event=} event - the event like the user blurred to trigger a messages option change
   * or undefined.
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _updateMessagesOption: function _updateMessagesOption(option, newMsgs, event) {
    var i;
    var len;
    var msgs;

    if (_typeof(newMsgs) === 'object' && Array.isArray(newMsgs)) {
      // update this.options[option] directly by pushing any new messages into it.
      msgs = this.options[option];
      len = newMsgs.length;

      for (i = 0; i < len; i++) {
        msgs.push(newMsgs[i]);
      }
    } // Setting 'changed' flag to true means that although we have already
    // updated this.options[option], we still want to fire a property changed event.


    this._setMessagesOption(option, msgs, event, true);
  },

  /**
   * Called after the messages* option (messagesShown, etc)
   * has changed to update messaging content
   * display.
   *
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _updateMessagingContent: function _updateMessagingContent() {
    // update component messaging
    this._getComponentMessaging().update(this._getMessagingContent(this._MESSAGING_CONTENT_UPDATE_TYPE.VALIDITY_STATE));
  },

  /**
   * Writes the value into the option by calling the option method.
   *
   * @param {Object|string} newValue the new value to be written to option
   * @param {Object=} event the original event that triggered this
   * @param {number=} validationContext the context in which validation was run that resulted in
   * value being updated.
   * @param {Object=} updateContext the context for updating the value option.
   * @param {Object=} options options for updating the value.
   *
   * @private
   * @memberof oj.editableValue
   * @instance
   * @see #_setOption
   * @see #_AfterSetOptionValue
   */
  _updateValueOption: function _updateValueOption(newValue, event, validationContext, updateContext, options) {
    var context = updateContext || {}; // set dom event

    if (event) {
      context.originalEvent = event;
    } // set writeback flag that determines whether value is written back.


    switch (validationContext) {
      // value is written back outside of normal UI interaction in the following cases.
      case this._VALIDATION_CONTEXT.CONVERTER_OPTION_CHANGE:
      case this._VALIDATION_CONTEXT.DISABLED_OPTION_CHANGE:
      case this._VALIDATION_CONTEXT.READONLY_OPTION_CHANGE:
      case this._VALIDATION_CONTEXT.REFRESH_METHOD:
      case this._VALIDATION_CONTEXT.REQUIRED_OPTION_CHANGE:
      case this._VALIDATION_CONTEXT.VALIDATE_METHOD:
      case this._VALIDATION_CONTEXT.VALIDATORS_OPTION_CHANGE:
        context.writeback = true; // when the above options change or methods are called, and full validation is run the
        // current display value is parsed, and set on the value option if all validations pass.
        // Typically when the value option changes - either programmatically or user changes it, we
        // end up clearing all 3 messages options.
        // But when value changes indirectly as a result of the above cases, then we do not clear
        // custom messages. So a special flag is set so _AfterSetOptionValue can do the right
        // thing. Component messages are already cleared when this method is called.

        context.doNotClearMessages = true;
        break;

      default:
        break;
    }

    context.internalSet = true;
    var valueMap;
    var isValueChanged;

    if (options && options.targetOptions) {
      // If targetOptions is specified, update all options in the array
      valueMap = {};
      isValueChanged = false;

      for (var i = 0; i < options.targetOptions.length; i++) {
        valueMap[options.targetOptions[i]] = newValue;
        isValueChanged = isValueChanged || options.targetOptions[i] === 'value';
      }
    } else {
      // If no targetOptions is specified, just update the "value" option
      valueMap = {
        value: newValue
      };
      isValueChanged = true;
    }

    this.option(valueMap, {
      _context: context
    });

    if (isValueChanged) {
      // When internalSet is true _setOption->_AfterSetOptionValue->_Refresh isn't called.
      // We still need the converter to run and the displayValue to be refreshed, so we
      // call this._AfterSetOptionValue ourselves
      this._AfterSetOptionValue('value', {
        _context: context
      });
    }
  },

  /**
   * Resets the internal property so that the next call to this.isValid() re-evaluates the correct
   * value.
   *
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _resetValid: function _resetValid() {
    this._valid = undefined;
  },

  /**
   * Determines the validity of component based on current value of the messages* options.
   * This is what the 'valid' property should be set to.
   *
   * Now when we start the lifecycle we clearAllMessages, then we continue with validation, etc.
   * But we don't want to update the valid property on clearAllMessages and again when validation
   * has failed. We want to update it only once.
   * @return {string} "valid", "invalidShown", "invalidHidden"
   *
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _determineValidFromMessagesOptions: function _determineValidFromMessagesOptions() {
    var msgsHidden = this.options.messagesHidden;
    var msgsShown = this.options.messagesShown;
    var valid = _VALID; // When new messages are written update the valid property

    if (msgsShown && msgsShown.length !== 0 && !Message.isValid(msgsShown)) {
      valid = _INVALID_SHOWN;
    } else if (msgsHidden && msgsHidden.length !== 0 && !Message.isValid(msgsHidden)) {
      valid = _INVALID_HIDDEN;
    }

    return valid;
  },

  /**
   * Formats the value for display, based on the converter options. If no converter is set then
   * returns the value as is.
   *
   * @param {string} value value to be formatted
   *
   * @return {string} formatted value
   * @throws {Error} when an error occurs during formatting
   * @protected
   * @memberof oj.editableValue
   * @instance
   */
  _formatValue: function _formatValue(value) {
    var formattedValue = value;

    var converter = this._GetConverter(); // don't clear messages here because we clear messages only when direct user interaction with
    // component changes value. All other usecases we expect page authors to clear messages.


    if (converter) {
      // Check if we have a converter instance
      if (_typeof(converter) === 'object') {
        if (converter.format && typeof converter.format === 'function') {
          formattedValue = converter.format(value);
        } else if (Logger.level > Logger.LEVEL_WARN) {
          Logger.info('converter does not support the format method.');
        }
      }
    }

    return formattedValue;
  },

  /**
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _getComponentMessaging: function _getComponentMessaging() {
    if (!this._componentMessaging) {
      this._componentMessaging = new oj.ComponentMessaging(this);
    }

    return this._componentMessaging;
  },

  /**
   * Returns an array of validator hints from any validator with getHint() function.
   * @param {Array} allValidators these are from the validators option
   * and from the GetImplicitValidators function.
   * These can be sync validators only since async validators api does not have getHint(),
   * it has .hint property.
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _getHintsFromAllValidatorsWithGetHintFunction: function _getHintsFromAllValidatorsWithGetHintFunction(allValidators) {
    var i;
    var validator;
    var validatorHints = [];
    var vHint = '';

    if (this._IsRequired()) {
      // get the hint for the default required validator and push into array if it's not already
      // present in the validators array
      validator = this._getImplicitRequiredValidator();

      if (validator.getHint && typeof validator.getHint === 'function') {
        vHint = validator.getHint();

        if (vHint) {
          validatorHints.push(vHint);
        }
      }
    } // loop through all remaining validators to gather hints.
    // this will get sync validators only since sync validators have getHint() api
    // and async validators have .hint property.


    for (i = 0; i < allValidators.length; i++) {
      validator = allValidators[i];
      vHint = '';

      if (_typeof(validator) === 'object') {
        if (validator.getHint && typeof validator.getHint === 'function') {
          vHint = validator.getHint();

          if (vHint) {
            validatorHints.push(vHint);
          }
        }
      }
    }

    return validatorHints;
  },

  /**
   * Returns the required validator instance or creates it if needed and caches it.
   *
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _getImplicitRequiredValidator: function _getImplicitRequiredValidator() {
    var reqTrans = {};
    var reqValOptions;

    if (this._implicitReqValidator == null) {
      // falsey check
      reqTrans = this.options.translations ? this.options.translations.required || {} : {}; // TODO: cache required validator; purged when its options change, i.e., translations or label
      // DOM changes

      reqValOptions = {
        hint: reqTrans.hint || null,
        label: this._getLabelText(),
        messageSummary: reqTrans.messageSummary || null,
        messageDetail: reqTrans.messageDetail || null
      };
      this._implicitReqValidator = new RequiredValidator(reqValOptions);
    }

    return this._implicitReqValidator;
  },

  /**
    * In the Alta theme, we want to continue to use the display-options properties to decide
    * where to render help-instruction, messages, validation-hint, etc. For example, if
    * display-options.messages = 'notewindow' then the messages will show up in a popup on focus.
    *
    * In the Redwood theme, we instead use the user-assistance attribute set on the component
    * to decide whether to show the user assistance (this includes Required)
    * inline or in compact mode which is where the user assistance is shown via a popup,
    * like in the ? icon on the label or a (x) icon in the field.
    * We need a way to say 'use' the user-assistance-density attribute or 'ignore'
    * the user-assistance-density attribute and instead use the 'old' way
    * of doing things based on the theme.
    * And if you are 'using' the user-assistance-density attribute what is it,
    * reflow or efficient or compact?
    * @return {'reflow'|'efficient'|'compact'|'displayOptions'} If 'displayOptions' it uses
    * the 'old' way of doing things which is to look at all the displayOptions for where to display
    * things. If 'efficient' or 'reflow' it renders all the user assistance inline,
    * and if compact it renders everything in the 'compact' ux design which is in notewindows.
    * @private
    * @memberof oj.editableValue
    * @instance
    */
  _getResolvedUserAssistance: function _getResolvedUserAssistance() {
    // ThemeUtils caches the result so no need to do it here.
    var defaultOptions = ThemeUtils.parseJSONFromFontFamily('oj-form-control-option-defaults'); // this will return 'use' or 'ignore'. This tells us whether we should use the
    // user-assistance-density attribute or ignore it. If we ignore it, we will
    // use the displayOptions attribute.

    if (defaultOptions) {
      var useUserAssistanceOption = defaultOptions.useUserAssistanceOptionDefault;
      return useUserAssistanceOption === 'use' ? this.options.userAssistanceDensity : 'displayOptions';
    } // if no theme return displayOptions for bw compatibility.


    return 'displayOptions';
  },

  /**
    * In the Alta theme, we show required on the label with an * icon,
    * and help on label with a ? icon.
    * In the Redwood theme, we show 'Required'/help as text inline if
    * user-assistance-density attribute is not 'compact',
    * else we show it as an * on the icon.
    * @private
    * @memberof oj.editableValue
    * @instance
    */
  _showUserAssistanceNotInline: function _showUserAssistanceNotInline() {
    var resolvedUserAssistance = this._getResolvedUserAssistance();

    return resolvedUserAssistance === 'compact' || resolvedUserAssistance === 'displayOptions';
  },

  /**
   * Returns content that will be used by messaging strategies.
   *
   * @param {number} updateType of messaging content to update. Accepted values are defined by
   * this._MESSAGING_CONTENT_UPDATE_TYPE.
   *
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _getMessagingContent: function _getMessagingContent(updateType) {
    var messagingContent = {};
    var allValidators;
    var converter;
    var converterHint = ''; // eslint-disable-next-line no-param-reassign

    updateType = updateType || this._MESSAGING_CONTENT_UPDATE_TYPE.VALIDITY_STATE; // Add validityState which includes messages, valid and severity.
    // These are shown to the user right away on initialization if they are there.

    if (updateType === this._MESSAGING_CONTENT_UPDATE_TYPE.INIT || updateType === this._MESSAGING_CONTENT_UPDATE_TYPE.VALIDITY_STATE) {
      // get messages from messagesShown and messagesHidden
      messagingContent.validityState = this._getMessagingContentValidityState();
    }

    if (updateType === this._MESSAGING_CONTENT_UPDATE_TYPE.INIT || updateType === this._MESSAGING_CONTENT_UPDATE_TYPE.CONVERTER_HINT) {
      converter = this._GetConverter();

      if (converter) {
        if (_typeof(converter) === 'object') {
          if (converter.getHint && typeof converter.getHint === 'function') {
            converterHint = converter.getHint() || '';
          }
        }
      }

      messagingContent.converterHint = converterHint;
    } // Do not get validator hints on component initialization. Instead we get them
    // when the user first needs them, like when they focus in the input.
    // We do this to help initial render performance.


    if (updateType === this._MESSAGING_CONTENT_UPDATE_TYPE.VALIDATOR_HINTS) {
      // gets implicit validators and all validators from the validators option.
      allValidators = this._GetAllValidatorsFromValidatorsOptionAndImplicit(); // sync validators have getHint() function.
      // async validators do not; they have hint property.
      // so this will get sync validators' hints

      var syncValidatorHints = this._getHintsFromAllValidatorsWithGetHintFunction(allValidators) || [];
      messagingContent.validatorHint = syncValidatorHints;
    }

    if (updateType === this._MESSAGING_CONTENT_UPDATE_TYPE.INIT || updateType === this._MESSAGING_CONTENT_UPDATE_TYPE.TITLE) {
      // For custom element components, we use help.instruction option value for the
      // messageContent title, otherwise, use the title option value.  help.instruction
      // is used by custom element components, and title is used by non-custom element components.
      var title;

      if (this._IsCustomElement()) {
        var help = this.options.help;

        if (help != null) {
          title = help.instruction;
        }
      } else {
        title = this.options.title;
      }

      messagingContent.title = title || '';
    }

    return messagingContent;
  },

  /**
   *
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _getMessagingContentValidityState: function _getMessagingContentValidityState() {
    var validityState;

    if (!this._hasValidityState()) {
      // this will create the validity state.
      validityState = this._getValidityState();
    } else {
      // update validityState before packaging it
      validityState = this._getValidityState();
      validityState.update(this.isValid(), this._getMessages());
    }

    return validityState;
  },

  /**
   * Compares the messages arrays for equality.
   *
   * @param {Array} pm previous messages
   * @param {Array} m new messages
   * @returns {boolean} true if equal false otherwise
   * @private
   * @memberof oj.editableValue
   * @instance
   *
   */
  _messagesEquals: function _messagesEquals(pm, m) {
    var match = -1;
    var pmo;
    var passed = true; // $.extend merges the contents of two or more objects together into the first object

    var previousMsgs = $.extend([], pm);
    var msgs = $.extend([], m);

    if (previousMsgs.length !== msgs.length) {
      return false;
    } // one way it gets here is if there is one messages-custom message on initialization and
    // after the busyContext is complete meaning the page is rendered, we set a different
    // messages-custom message.


    previousMsgs.forEach(function (pMsg) {
      if (!(pMsg instanceof Message)) {
        // freeze message instance once its created
        pmo = new Message(pMsg.summary, pMsg.detail, pMsg.severity);
        pmo = Object.freeze ? Object.freeze(pmo) : pmo;
      } else {
        pmo = pMsg;
      }

      match = -1;
      msgs.forEach(function (msg, j) {
        if (Message.getSeverityLevel(pmo.severity) === Message.getSeverityLevel(msg.severity) && pmo.summary === msg.summary && pmo.detail === msg.detail) {
          match = j; // found a match, so break out of loop
        }
      }); // remove entry at 'match' index from msgs

      if (match > -1) {
        msgs.splice(match, 1);
      } else {
        // we found no match so no need to loop
        passed = false;
      }
    });
    return passed;
  },

  /**
   * Parses the value using the converter set and returns the parsed value. If parsing fails the
   * error is written into the element. This function sets the valid state to PENDING before it tries
   * to parse.
   *
   * @param {string=} submittedValue to parse
   * @param {Object=} event an optional event if this was a result of ui interaction. For user
   * initiated actions that trigger a DOM event, passing this event is required. E.g., if user action
   * causes a 'blur' event.
   * @param {boolean?} setValid true if you want to set the valid state to pending->invalid
   * @return {Object} parsed value
   * @throws {Error} an Object with message
   * @protected
   * @memberof oj.editableValue
   * @instance
   */
  _parseValue: function _parseValue(submittedValue, event, setValid) {
    var converter = this._GetConverter();

    var parsedValue = submittedValue;

    if (converter) {
      if (_typeof(converter) === 'object') {
        if (converter.parse && typeof converter.parse === 'function') {
          try {
            // we are dealing with a converter instance
            if (setValid) {
              this._setValidOption(_PENDING, event);
            }

            parsedValue = converter.parse(submittedValue); // caller will set valid option, since usually we go on to call validators after
            // converters and don't want to set pending->valid->pending again.
          } catch (error) {
            throw error;
          }
        } else if (Logger.level > Logger.LEVEL_WARN) {
          Logger.info('converter does not support the parse method.');
        }
      }
    }

    return parsedValue;
  },

  /**
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _addValidationError: function _addValidationError(e, msgs) {
    var detail;
    var severity;
    var ojmessage;
    var summary;

    if (e instanceof oj.ConverterError || e instanceof oj.ValidatorError) {
      ojmessage = e.getMessage();
      severity = ojmessage.severity || Message.SEVERITY_LEVEL.ERROR;
      summary = ojmessage.summary || Translations.getTranslatedString('oj-message.error');
      detail = ojmessage.detail || Translations.getTranslatedString('oj-converter.detail');
    } else if (e.summary || e.detail) {
      severity = Message.SEVERITY_LEVEL.ERROR;
      summary = e.summary || Translations.getTranslatedString('oj-message.error');
      detail = e.detail || Translations.getTranslatedString('oj-converter.detail');
    } else {
      // TODO: is this error message generic enough to use for both converter and validator errors?
      severity = Message.SEVERITY_LEVEL.ERROR;
      summary = Translations.getTranslatedString('oj-message.error');
      detail = e.message || Translations.getTranslatedString('oj-converter.detail');
    }

    msgs.push({
      summary: summary,
      detail: detail,
      severity: severity
    });
  },

  /**
   * Processes the error information for one or more errors and returns an Array of
   * oj.ComponentMessage instances.
   *
   * @param {Error} e instance of Error
   * @param {number=} context the context in which the validation error was thrown
   * @param {String=} display whether message is shown or hidden
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _processValidationErrors: function _processValidationErrors(e, context, display) {
    var componentMsgs = [];
    var msg;
    var msgs = e._messages || [];
    var options = {};
    options.context = context || 0;
    options.display = display || oj.ComponentMessage.DISPLAY.SHOWN;

    if (msgs.length === 0) {
      this._addValidationError(e, msgs);
    }

    for (var i = 0; i < msgs.length; i++) {
      msg = msgs[i];
      componentMsgs.push(this._createComponentMessage(msg.summary, msg.detail, msg.severity, options));
    }

    return componentMsgs || null;
  },

  /**
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _createComponentMessage: function _createComponentMessage(summary, detail, severity, options) {
    var cMsg; // new properties can't be added but existing properties can be changed

    cMsg = new oj.ComponentMessage(summary, detail, severity, options);
    cMsg = Object.seal ? Object.seal(cMsg) : cMsg;
    return cMsg;
  },

  /**
   * Formats and refreshes the component display value,
   * only when the current value is different from the last
   * saved value, unless asked to always refresh the display value.
   *
   * @param {Object|undefined} value the changed value that needs to be updated on UI
   * @param {boolean=} fullRefresh false is the default; true means always refresh component
   * display value using the current option value. This overwrites any UI value, the user may have
   * entered.
   *
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _refreshComponentDisplayValue: function _refreshComponentDisplayValue(value, fullRefresh) {
    var displayValueReturn; // when we change the display value via value change we want to
    // update the 'oj-has-no-value' class.

    this._toggleOjHasNoValueClass(value); // We set the last model value after the format, so this is saying,
    // has the value about to be formatted different than the one we last formatted?


    if (fullRefresh || value !== this._getLastModelValue()) {
      // this formats the value and displays it.
      displayValueReturn = this._UpdateElementDisplayValue(value);
    }

    return displayValueReturn;
  },

  /**
   * Toggles css selector on the widget. E.g., when required option changes, the oj-required
   * selector needs to be toggled.
   * @param {string} option
   * @param {Object|string} value
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _refreshTheming: function _refreshTheming(option, value) {
    if (Object.keys(this._OPTION_TO_CSS_MAPPING).indexOf(option) !== -1) {
      if (value) {
        this.widget()[0].classList.add(this._OPTION_TO_CSS_MAPPING[option]);
      } else {
        this.widget()[0].classList.remove(this._OPTION_TO_CSS_MAPPING[option]);
      }
    }
  },

  /**
   * Runs validators in deferred mode using the option value. Any validation error thrown is
   * deferred, or hidden by component, until explicitly asked to show them (see showMessages()).
   * Deferred error is pushed to <code class="prettyprint">messagesHidden</code> option.
   *
   * @param {number} context in which validation was run.
   * @see #showMessages
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _runDeferredValidation: function _runDeferredValidation(context) {
    var self = this;

    if (this._CanSetValue()) {
      if (!this._resolveBusyStateDeferredValidation) {
        var domElem = this.element[0];
        var busyContext = Context.getContext(domElem).getBusyContext();
        var description = 'The page is waiting for async deferred validation ';

        if (domElem && domElem.id) {
          description += 'for "' + domElem.id + '" ';
        }

        description += 'to finish.';
        this._resolveBusyStateDeferredValidation = busyContext.addBusyState({
          description: description
        });
      }

      var resultPromise = this._validateValueForRequiredOnly(this.options.value, context);

      if (resultPromise instanceof Promise) {
        resultPromise.then(function () {
          if (self._resolveBusyStateDeferredValidation) {
            self._resolveBusyStateDeferredValidation();

            delete self._resolveBusyStateDeferredValidation;
          }

          self._setValidOption(self._determineValidFromMessagesOptions(), null);
        });
      } else {
        this._setValidOption(this._determineValidFromMessagesOptions(), null);

        if (this._resolveBusyStateDeferredValidation) {
          this._resolveBusyStateDeferredValidation();

          delete this._resolveBusyStateDeferredValidation;
        }

        return;
      }
    } else if (Logger.level > Logger.LEVEL_WARN) {
      Logger.info('Deferred validation skipped as component is readonly or disabled.');
    }

    this._setValidOption(this._determineValidFromMessagesOptions(), null);
  },

  /**
   * Runs either deferred or normal validation based on the state component is in. This method is
   * called when certain options change - required, disabled etc.
   *
   * <p>
   * - if component is invalid and has messgesShown -> required: false/true -> clear component errors;
   * run full validation with UI value (we don't know if the UI error is from a required validator
   * or something else);<br/>
   * &nbsp;&nbsp;- if there are validation errors, then value not pushed to model; messagesShown is
   * updated<br/>
   * &nbsp;&nbsp;- if no errors result from the validation, push value to model; author needs to
   * listen to valueChanged to clear custom errors.<br/>
   *
   * - if component is invalid and has messagesHidden -> required: false -> clear component
   * errors; no deferred validation is run.<br/>
   * - if component has no error -> required: true -> run deferred validation (we don't want to flag
   * errors unnecessarily)<br/>
   * - messagesCustom is never cleared<br/>
   * </p>
   *
   * @param {Object} validationOptions
   *
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _runMixedValidationAfterSetOption: function _runMixedValidationAfterSetOption(validationOptions) {
    var runFullValidation = false;
    var displayValue; // runFullValidation, if needed, does a full validation
    // which in turn updates value option and converted display value

    if (this._hasInvalidMessagesShowing()) {
      runFullValidation = true;
    }

    this._clearComponentMessages();

    if (runFullValidation) {
      // this may return a Promise
      displayValue = this._GetDisplayValue(); // runs full validation on the display value. May be async

      this._SetValue(displayValue, null, validationOptions);
    }

    if (!runFullValidation && this._IsRequired()) {
      // run deferred validation if we didn't run full validation
      // (e.g., comp is either showing a deferred error or has no errors.)
      // But only when required is true do
      // we update the valid option within _runDeferredValidation
      this._runDeferredValidation(validationOptions.validationContext);
    } else {
      this._setValidOption(this._determineValidFromMessagesOptions(), null);
    }
  },

  /**
   * Formats the modelValue and updates the display value.
   * @param modelValue
   * @param ignoreAfterError boolean defaults to false.
   * If true, do not do anything after format error, like
   * do not show messages, do not change valid state.
   * @return {undefined|string} if formatting threw an error, return undefined.
   * if formatting was successful and no other errors occur, return formatted
   * value.
   * @throw {Error} converter.format error if the converter is synchronous.
   * @protected
   * @memberof oj.editableValue
   * @instance
   */
  _UpdateElementDisplayValue: function _UpdateElementDisplayValue(modelValue, ignoreAfterError) {
    var displayValue;
    var parsedReturnValue;
    displayValue = modelValue;

    try {
      // returns the converter formatted value, and if there is no converter, it returns
      // the value as is.
      displayValue = this._formatValue(modelValue); // synchronous converter's format succeeded or no converter

      try {
        this._setLastModelValue(modelValue);

        this._afterConverterFormat(displayValue);
      } catch (e) {
        // rethrow error in case _SetDisplayValue() threw an error. See ojcheckboxset,
        // it throws error if it isn't an array or if it is null.
        throw e;
      }

      parsedReturnValue = displayValue;
    } catch (e) {
      if (!ignoreAfterError) {
        this._afterConverterFormatFailure(e);
      }

      this._setLastModelValue(modelValue); // displayValue is modelValue if we get here.


      this._afterConverterFormat(displayValue);

      parsedReturnValue = undefined;
    }

    return parsedReturnValue;
  },

  /**
   * This gets called while the converter module is loading asynchronously
   * @protected
   * @memberof oj.editableValue
   * @instance
   */
  _SetLoading: function _SetLoading() {
    var widgetElem = this.widget()[0];
    var focusElem = this.GetFocusElement();
    widgetElem.classList.add('oj-loading');
    this._saveAriaLabel = focusElem.getAttribute('aria-label');
    var loadingText = Translations.getTranslatedString('oj-ojEditableValue.loading');
    focusElem.setAttribute('aria-label', loadingText);
  },

  /**
   * This gets called when the converter was loading asynchronously
   * and now it is loaded.
   * @protected
   * @memberof oj.editableValue
   * @instance
   */
  _ClearLoading: function _ClearLoading() {
    var widgetElem = this.widget()[0];
    var focusElem = this.GetFocusElement();
    widgetElem.classList.remove('oj-loading');

    if (this._saveAriaLabel) {
      focusElem.setAttribute('aria-label', this._saveAriaLabel);
    } else {
      focusElem.removeAttribute('aria-label');
    }
  },

  /**
   * @ignore
   * @protected
   * @memberof oj.editableValue
   * @return {boolean}
   */
  _UseReadonlyDiv: function _UseReadonlyDiv() {
    // ThemeUtils caches the result so no need to do it here.
    var defaultOptions = ThemeUtils.parseJSONFromFontFamily('oj-form-control-option-defaults');
    return defaultOptions.readonlyElem === 'div';
  },

  /**
   * This is called from InlineHelpHintsStrategy to determine if the
   * component should show help hints on focus or always. Set
   * components show it always.
   * @ignore
   * @protected
   * @memberof oj.editableValue
   * @return {'focus'|'always'}
   */
  _ShowHelpHints: function _ShowHelpHints() {
    return this._IsTextFieldComponent() ? 'focus' : 'always';
  },

  /**
     * This is called from InlineHelpHintsStrategy to determine
     * the location of the inline help hints, above the component
     * or below inline.
   * @ignore
   * @protected
   * @memberof oj.editableValue
   * @return {'above'|'inline'}
   */
  _ShowHelpHintsLocation: function _ShowHelpHintsLocation() {
    return 'inline';
  },

  /**
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _afterConverterFormat: function _afterConverterFormat(displayValue) {
    var actualDisplayValue;

    this._SetDisplayValue(displayValue); // getting the display value right after we set it is probably not necessary,  but just in
    // case a subclass did something to it, we do.


    actualDisplayValue = this._GetDisplayValue();

    this._setLastDisplayValue(actualDisplayValue); // update rawValue option to keep it in sync with the display value


    this._SetRawValue(actualDisplayValue, null);
  },

  /**
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _afterConverterFormatFailure: function _afterConverterFormatFailure(e) {
    var newMsgs; // Turn this into Array of oj.ComponentMessage instances.
    // This is what we set on 'messagesShown'

    newMsgs = this._processValidationErrors(e);

    this._updateMessagesOption('messagesShown', newMsgs); // update valid option to INVALID_SHOWN


    this._setValidOption(_INVALID_SHOWN, null);
  },

  /**
   * When we are asynchronously loading a converter we show a loading indication
   * and make the input (not the component) readonly.
   * @param converterPromise {Promise<Converter>}
   * @return {Promise<Object|null>} a Promise to a converter instance or null
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _loadingConverter: function _loadingConverter(converterPromise) {
    var self = this;

    var showLoadingIndicatorDelay = oj.EditableValueUtils._getShowLoadingDelay();

    var converterCounter = this._converterChangedCounter;
    var loadingTimeout = setTimeout(function () {
      // _converterChangedCounter is incremented if we get a change of converter option.
      if (converterCounter === self._converterChangedCounter) {
        self._SetLoading();
      }
    }, showLoadingIndicatorDelay);
    return converterPromise.then(function (ci) {
      self._ClearLoading();

      clearTimeout(loadingTimeout);
      return ci;
    });
  },

  /**
       * @param {Object|undefined} value
       * @param {number} context in which validation was run.
       * @return {Promise<null> | null} a Promise to indicate validation has finished or null if sync
       * @private
       * @memberof oj.editableValue
       * @instance
       */
  _validateValueForRequiredOnly: function _validateValueForRequiredOnly(value, context) {
    var newMsgs;
    var validator;
    var self = this; // run required validation if component is required
    // SYNCHRONOUS OR ASYNCHRONOUS

    if (this._IsRequired()) {
      validator = this._getImplicitRequiredValidator();

      try {
        // check if trimmed value is empty. See AdfUIEditableValue.prototype.ValidateValue
        this._setValidOption(_PENDING, null);

        var validateReturned = validator.validate(oj.StringUtils.trim(value));

        if (validateReturned instanceof Promise) {
          return validateReturned.then(function () {}, function (e) {
            newMsgs = self._processValidationErrors(e, context, oj.ComponentMessage.DISPLAY.HIDDEN);

            if (newMsgs) {
              self._updateMessagesOption('messagesHidden', newMsgs);
            }
          });
        }
      } catch (e) {
        // this is a messagesHidden message
        // turn this into Array of oj.ComponentMessage instances. This is what we set on 'messagesHidden'
        newMsgs = this._processValidationErrors(e, context, oj.ComponentMessage.DISPLAY.HIDDEN);

        if (newMsgs) {
          this._updateMessagesOption('messagesHidden', newMsgs);
        }
      }
    }

    return null;
  },

  /**
   * This is called from both _SetValue and when we need to re-validate due to
   * property changes, like converters, required, etc.
   * This validates the value by running through the list of all registered validators and
   * async-validators. The algorithm is as follows -
   * 1. if isRequired, run required validator.
   * 2. get all the rest of the validators and validate in sequence.
   * 3. get async-validators and kick them all off simultaneously, and show errors as we get them.
   * 4. update valid state immediately if it turns for the worse.
   * 5. will ignore validation results if we get a new call to this method with a different value
   *  before we get back the async validate results from a previous value.
   * results.
   *
   * Callers can rely on the 'valid' options property to determine the validity state of the
   * component after calling this method
   *
   * @param {Object|string} value to be validated
   * @param {Event?} event the original event (for user initiated actions that trigger a DOM event,
   * like blur) or undefined. The custom element bridge creates a CustomEvent out of this when
   * it sends the property changed event.
   * @param {number=} context determines when validation is being run. Used when creating Messages
   * @return {Promise|Object|string|undefined}
   * Promise resolves to 'valid' if all validators pass. Resolves to 'invalidShown'
   * if any validator fails. Resolves to 'ignoreValidation' if we are to ignore validation results.
   * If no async validators are on the component, it returns the value we validated if
   * validation passed or undefined if validation failed.
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _asyncValidateValue: function _asyncValidateValue(value, event, context) {
    // we get validators from async-validators option. This is not cached, but
    // it is fast to get. TODO cache.
    var normalizedAsyncValidators = this._GetNormalizedAsyncValidatorsFromOption(); // gets implicit validators and validators from validators option.
    // these can be sync or async validators. This is cached.


    var normalizedValidators = this._GetAllValidatorsFromValidatorsOptionAndImplicit();

    var i;
    var isInvalidShownSet = false;
    var finalValidState;
    var newMsgs;
    var self = this;
    var implicitRequiredValidator;
    var valMsgs = []; // this to be used to decide whether or not to ignore async validate resolutions.
    // if we use the value to decide whether or not to ignore async validate resolutions, it
    // would not work if the user types in an invalid value, then another value, then the
    // invalid value again. He would see two identical error messages if the async validators
    // are slow. We talked about using a queue, and decided a counter would work just as well.

    var asyncValidatorValidateCounter = this._asyncValidatorValidateCounter;
    var promiseArray = []; // run required validator first, push to promiseArray if it is a Promise

    var isRequired = this._IsRequired();

    if (isRequired) {
      implicitRequiredValidator = this._getImplicitRequiredValidator();
    }

    if (isRequired || normalizedAsyncValidators.length > 0 || normalizedValidators.length > 0) {
      this._setValidOption(_PENDING, event);
    }

    if (implicitRequiredValidator) {
      try {
        var requiredValidatorPromise = implicitRequiredValidator.validate(oj.StringUtils.trim(value));

        if (requiredValidatorPromise) {
          promiseArray.push(requiredValidatorPromise);
        }
      } catch (e) {
        // save all validation errors
        this._addValidationError(e, valMsgs);

        this._setValidOption(_INVALID_SHOWN, event);

        isInvalidShownSet = true;
      }
    }

    var result;

    for (i = 0; i < normalizedAsyncValidators.length; i++) {
      try {
        result = normalizedAsyncValidators[i].validate(value);
      } catch (e) {
        // async validators should not throw errors, they should just reject
        // so we should treat this as a reject
        result = Promise.reject(e);
      }

      if (!(result instanceof Promise)) {
        result = Promise.resolve(result);
      }

      promiseArray.push(result);
    } // run through all validators on the validators option + implicit ones.
    // could be sync or async


    for (i = 0; i < normalizedValidators.length; i++) {
      try {
        result = normalizedValidators[i].validate(value);

        if (result instanceof Promise) {
          promiseArray.push(result);
        }
      } catch (e) {
        // save all validation errors
        this._addValidationError(e, valMsgs);

        this._setValidOption(_INVALID_SHOWN, event);

        isInvalidShownSet = true;
      }
    } // show sync validator messages, if any


    if (valMsgs.length > 0) {
      var ve = new Error();
      ve._messages = valMsgs;
      newMsgs = this._processValidationErrors(ve, context); // turn this into Array of oj.ComponentMessage instances.
      // This is what we set on 'messagesShown'

      this._updateMessagesOption('messagesShown', newMsgs, event);
    } // when a promise resolves or errors out, we return an Object with the value or error state,
    // and the status.
    // We want to show error messages right away, as we get them.
    // We also want to ignore any error messages or valid state changes if we get
    // a new value to validate while the current async validate methods haven't returned yet.
    // This could happen if we kick off a slow validator and the user types into the field
    // and blurs to cause a new _SetValue->validation before this one returns.


    function reflect(promise) {
      return promise.then(function (v) {
        var status; // Ignore validate Promise results if it is for a value that isn't the most current value
        // we are validating. The only con is if they are in the process of typing in the field,
        // errors might show up for value when they last pressed Enter|Blur.
        // We decided this is fine, and we will show the value in the error message in our demos
        // so the user won't get confused, and we'll doc that this is what the app dev should do.

        if (self._asyncValidatorValidateCounter === asyncValidatorValidateCounter) {
          status = 'resolved';
        } else {
          if (Logger.level > Logger.LEVEL_WARN) {
            Logger.info('Validate ignored because new value came in before async validator finished for ' + value);
          }

          status = 'ignore';
        }

        return {
          v: v,
          status: status
        };
      }, function (e) {
        var status;

        if (self._asyncValidatorValidateCounter === asyncValidatorValidateCounter) {
          // turn this into Array of oj.ComponentMessage instances.
          // This is what we set on 'messagesShown'
          newMsgs = self._processValidationErrors(e, context);

          self._updateMessagesOption('messagesShown', newMsgs, event);

          if (!isInvalidShownSet) {
            self._setValidOption(_INVALID_SHOWN, event);

            isInvalidShownSet = true;
          }

          status = 'rejected';
        } else {
          if (Logger.level > Logger.LEVEL_WARN) {
            Logger.info('Validate ignored because new value came in before async validator finished for ' + value);
          }

          status = 'ignore';
        }

        return {
          e: e,
          status: status
        };
      });
    }

    if (promiseArray.length > 0) {
      return new Promise(function (resolve) {
        // Promise.all will end as soon as it gets its first rejection. We don't want that.
        // We want to wait until all promises either resolve or reject. Then we can resolve this
        // outer promise. We do this using the reflect function defined above.
        Promise.all(promiseArray.map(reflect)).then(function (results) {
          var ignoreList = results.filter(function (x) {
            return x.status === 'ignore';
          });

          if (ignoreList.length > 0) {
            finalValidState = 'ignoreValidation';
          } else {
            finalValidState = !isInvalidShownSet ? _VALID : _INVALID_SHOWN; // we could be showing messages, like 'messagesCustom'. If so, valid is invalidShown,
            // even if all validators passed.

            self._setValidOption(self._determineValidFromMessagesOptions(), event);
          }

          resolve(finalValidState);
        });
      });
    } // only sync validators were found


    if (valMsgs.length === 0) {
      // we could be showing messages, like 'messagesCustom'. If so, valid is invalidShown,
      // even if all validators passed.
      this._setValidOption(self._determineValidFromMessagesOptions(), event);
    } // if no error messages returned from validating the value, return newValue


    return valMsgs.length === 0 ? value : undefined;
  },

  /**
   * This is called when we have a labelledBy attribute during component initialization
   * or the attribute updates.
   *
   * @param {string} labelledBy The labelledBy attribute value. Can be a space delimited value.
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _labelledByUpdated: function _labelledByUpdated(labelledBy) {
    var ojlabels = oj.EditableValueUtils._getCustomOjLabelElements(labelledBy);

    if (ojlabels) {
      for (var i = 0; i < ojlabels.length; i++) {
        var ojlabel = ojlabels[i];
        ojlabel.classList.add(this._GetDefaultStyleClass() + '-label');

        if (this.widget().attr('data-oj-internal') === undefined && this.options.readOnly !== undefined) {
          this._addRemoveOjReadOnlyClassOnLabel(ojlabel, this.options.readOnly);
        }
      }
    }
  },

  /**
   * propogate described-by to aria-describedby
   *
   * @memberof oj.editableValue
   * @instance
   * @private
   */
  _describedByUpdated: LabelledByUtils._describedByUpdated,

  /**
   * Set busy state for async validators
   *
   * @memberof oj.editableValue
   * @instance
   * @private
   */
  _setBusyState: oj.EditableValueUtils._SetBusyState,

  /**
   * Clear  busy state for async validators
   *
   * @memberof oj.editableValue
   * @instance
   * @private
   */
  _clearBusyState: oj.EditableValueUtils._ClearBusyState,

  /**
   * Set busy state for async validators hint
   *
   * @memberof oj.editableValue
   * @instance
   * @private
   */
  _setBusyStateAsyncValidatorHint: oj.EditableValueUtils._SetBusyStateAsyncValidatorHint,

  /**
   * Clear  busy state for async validators hint
   *
   * @memberof oj.editableValue
   * @instance
   * @private
   */
  _clearBusyStateAsyncValidatorHint: oj.EditableValueUtils._ClearBusyStateAsyncValidatorHint,

  /**
   * Set busy state for async converter loading
   *
   * @memberof oj.editableValue
   * @instance
   * @private
   */
  _setBusyStateAsyncConverterLoading: oj.EditableValueUtils._SetBusyStateAsyncConverterLoading,

  /**
   * Clear  busy state for async converter loading
   *
   * @memberof oj.editableValue
   * @instance
   * @private
   */
  _clearBusyStateAsyncConverterLoading: oj.EditableValueUtils._ClearBusyStateAsyncConverterLoading,

  /**
   * If we have asynchronous converter loading, the input is readonly and a loading indicator
   * is shown to the user.
   * When the converter is 100% loaded, then the field is set back to how it was.
   * That is when we do the tasks that either need a converter or need the field to be enabled,
   * like showing messagesCustom. Those tasks are done in this method.
   *
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _AfterCreateConverterCached: oj.EditableValueUtils._AfterCreateConverterCached,

  /**
   * Returns the readonly div HTMLElement.
   * @memberof oj.editableValue
   * @instance
   * @private
   */
  _getReadonlyDiv: oj.EditableValueUtils._getReadonlyDiv,

  /**
   * Creates or updates the readonly div. This is called when the
   * component is initially enabled and becomes readonly.
   * @memberof oj.editableValue
   * @instance
   * @private
   */
  _createOrUpdateReadonlyDiv: oj.EditableValueUtils._createOrUpdateReadonlyDiv,

  /**
  * Creates the readonly div. This is called when the
  * component is initially enabled and becomes readonly.
  * @memberof oj.editableValue
  * @instance
  * @private
  */
  _createReadonlyDiv: oj.EditableValueUtils._createReadonlyDiv,

  /**
   * @memberof oj.editableValue
   * @instance
   * @private
   */
  _setReadonlyDivLabelledBy: oj.EditableValueUtils._setReadonlyDivLabelledBy,

  /**
   * Returns the associated input container needed for component managed labels.  Subclasses can
   * override if the container is not marked with the '.oj-text-field-container' or
   * '.oj-form-control-container' selector. The
   * input elements are children of the container and a sibling to the inline messages container.
   * @memberof oj.editableValue
   * @instance
   * @protected
   * @return {Element|undefined}
   */
  _GetFormControlContainer: function _GetFormControlContainer() {
    if (this._IsCustomElement()) {
      var selector = '.' + [this._GetComponentManagedBaseLabelStyleClass(), 'container'].join('-');
      return this._getRootElement().querySelector(selector);
    }

    return undefined;
  },

  /**
   * Returns if the element is a text field element or not.
   * @memberof oj.editableValue
   * @instance
   * @protected
   * @return {string}
   */
  _IsTextFieldComponent: function _IsTextFieldComponent() {
    return false;
  },

  /**
   * Returns the base selector name used to define the input container.
   * @memberof oj.editableValue
   * @instance
   * @protected
   * @return {string}
   */
  _GetComponentManagedBaseLabelStyleClass: function _GetComponentManagedBaseLabelStyleClass() {
    if (this._IsTextFieldComponent()) {
      return 'oj-text-field';
    }

    return 'oj-form-control';
  },

  /**
   * For components like input number/ input date etc, where we have some icon or button beside the input text:
   * Previously, we set flex =1 on the input and the input's width will autogrow based on buttons width.
   * But in case of an inside label, the label also should grow and shrink exactly as the input
   * We can make this to work only by wrapping the input (and label in case of inside) in to a div and
   * set the flex for the div to 1.
   * Now the button or icon becomes a sibling of this div and not the input.
   *
   * @protected
   * @instance
   * @ignore
   * @return {Element}
   */
  _CreateMiddleWrapper: function _CreateMiddleWrapper() {
    // For the inside label to be assigned with the same width as input,
    // We need to put the label and the input together in a div and set flex=1 for the div.
    // This way, they both will occupy the same space as avialble after the buttons.
    var innerDivElem = document.createElement('div');
    innerDivElem.className = 'oj-text-field-middle';
    return innerDivElem;
  },

  /**
   * Resolves the labelEdge strategy type from the labelEdge property.
   * Called from the ComponentMessaging
   * class which picks which label strategy to use. For example,
   * oj-radioset with label-edge='inside' uses the InsideFormControlLabelStrategy
   * which has type 'insideformcontrol'.
   * whereas the oj-input-text with label-edige='inside' uses the InsideLabelStrategy
   * which has type 'inside'.
   * @memberof oj.editableValue
   * @instance
   * @protected
   * @return {string}
   */
  _ResolveLabelEdgeStrategyType: function _ResolveLabelEdgeStrategyType() {
    var labelEdge = this.options.labelEdge;

    if (this._IsCustomElement()) {
      if (labelEdge === 'inside') {
        // Resolve the 'inside' labelEdge to 'insideformcontrol' for
        // non-text fields.
        // An 'insideformcontrol' label renders on top of the component with
        // the smaller font that matches a text-field's 'inside' label.
        if (!this._IsTextFieldComponent()) {
          labelEdge = oj.ComponentMessaging._STRATEGY_TYPE.LABEL_EDGE_INSIDE_FORM_CNTRL;
        }
      }
    }

    return labelEdge;
  }
}, true);

Components.setDefaultOptions({
  editableValue: // properties for all editableValue components
  {
    displayOptions: Components.createDynamicPropertyGetter(function (context) {
      var displayOptions = {
        messages: context.containers.indexOf('ojDataGrid') >= 0 || context.containers.indexOf('ojTable') >= 0 ? ['notewindow'] : ['inline'],
        converterHint: ['placeholder', 'notewindow'],
        validatorHint: ['notewindow']
      };
      displayOptions[context.isCustomElement ? 'helpInstruction' : 'title'] = ['notewindow'];
      return displayOptions;
    }),
    help: Components.createDynamicPropertyGetter(function (context) {
      // Conditionally set the defaults for custom element vs widget syntax since we expose different APIs
      if (context.isCustomElement) {
        return {
          instruction: ''
        };
      }

      return {
        definition: null,
        source: null
      };
    }),
    labelEdge: Components.createDynamicPropertyGetter(function (context) {
      // update the labelEdge value to theme based.
      if (context.isCustomElement) {
        return (ThemeUtils.parseJSONFromFontFamily('oj-form-control-option-defaults') || {}).labelEdge;
      }

      return undefined;
    }),
    userAssistanceDensity: Components.createDynamicPropertyGetter(function (context) {
      var userAssistanceDensityVar = context.containers.indexOf('ojDataGrid') >= 0 || context.containers.indexOf('ojTable') >= 0 ? 'compact' : 'reflow';
      return userAssistanceDensityVar;
    })
  }
}); // ////////////////     SUB-IDS     //////////////////

/**
 * <p>Sub-ID for the help icon element used by EditableValue components.</p>
 *
 * @ojsubid oj-label-help-icon
 * @memberof oj.editableValue
 * @ignore
 *
 * @example <caption>Get the help icon element associated with an editable value component:</caption>
 * var node = myComp.getNodeBySubId("oj-label-help-icon");
 */
// ////////////// fragments /////////////////

/**
 * <p>
 * <h3 id="validation-section">
 * Validation and Messaging
 * <a class="bookmarkable-link" title="Bookmarkable Link" href="#validation-section"></a>
 * </h3>
 * An editable component runs validation (normal or deferred) based on the action performed on it
 * (either by end-user or page author), and the state it was in when the action occurred. Examples
 * of actions are - creating a component, user changing the value of the component by interacting
 * with it, the app setting a value programmatically, the app calling the validate() method etc. At
 * the time the action occurs, the component could already be showing errors, or can have a deferred
 * error or have no errors.
 * <p>
 * These factors also determine whether validation errors/messages get shown to the user immediately
 * or get deferred. The following sections highlight the kinds of validation that are run and how
 * messages get handled.
 * </p>
 * <h4 id="normal-validation-section">Normal Validation
 * <a class="bookmarkable-link" title="Bookmarkable Link" href="#normal-validation-section"></a></h4>
 * Normal validation is run in the following cases on the display value, using the converter and
 * validators (this includes async-validators) set on the component,
 * and validation errors are reported to user immediately.
 * <ul>
 * <li>When value changes as a result of user interaction all messages are cleared, including custom
 * messages added by the app, and full validation is run on the UI value. The steps performed are
 * outlined below.
 * <ol>
 * <li>All messages are cleared and <code class="prettyprint">messagesCustom</code> property is cleared</li>
 * <li>If no converter is present then processing continues to next step. If a converter is
 * present, the UI value is first converted (i.e., parsed). If there is a parse error then
 * the messages are shown and processing returns.</li>
 * <li>If there are no validators setup for the component then the value is set on the component.
 * Otherwise all validators are run in sequence using the parsed value from the previous step. The
 * implicit required is run first if the component is marked required. When a validation error is
 * encountered it is remembered and the next validator in the sequence is run.
 * <ul><li>NOTE: The value is trimmed before required validation is run</li></ul>
 * </li>
 * <li>At the end of the validation run if there are errors, the messages are shown
 * and processing returns. If there are async-validators, those errors are shown as soon as they
 * come in, and not until all validators, sync and async validators, are complete, does processing
 * return, that is, value and valid are updated. If there are no errors, then the
 * <code class="prettyprint">value</code> property is updated and the formatted value displayed on the
 * UI.</li>
 * </ol>
 * </li>
 * <li>When the <code class="prettyprint">validate</code> method is called by app, all messages are
 * cleared and full validation run using the display value. See <code class="prettyprint">validate</code>
 * method on the sub-classes for details. Note: JET validation is designed to catch user input errors, and not invalid
 * data passed from the server; this should be caught on the server.</li>
 * <li>When certain properties change through programmatic intervention by app, the component
 * determines whether it needs to run normal validation based on the state the component is in.
 * Refer to the <a href="#mixed-validation-section">Mixed Validation</a> section below for details. </li>
 * </ul>
 *
 * <h4 id="deferred-validation-section">Deferred Validation
 * <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-validation-section"></a>
 * </h4>
 * Deferred validation is run in the following cases on the component value using the implicit
 * required validator if required is true, and validation errors are deferred, i.e., not shown to user immediately.
 * Refer to the <a href="#deferred-messages-section">Showing Deferred Messages</a> section to
 * understand how deferred messages can be shown.
 * <ul>
 *  <li>When a component is created and it is required deferred validation is run and no messages are cleared
 *  prior to running validation.
 *  Refer to the <a href="#deferred-validators-section">Validators
 *  Participating in Deferred Validation</a> section for details.</li>
 *  <li>When the <code class="prettyprint">value</code> property changes due to programmatic
 *  intervention deferred validation is run, after all messages and messagesCustom property are cleared.</li>
 *  <li>When the <code class="prettyprint">reset</code> method is called, deferred validation is run
 *   after all messages and messagesCustom property are cleared.</li>
 *  <li>When certain properties change through programmatic intervention by app, the component
 *  determines whether it needs to run deferred validation based on the state the component is in.
 *  Refer to the <a href="#mixed-validation-section">Mixed Validation</a> section below for details.</li>
 * </ul>
 *
 * <h4 id="mixed-validation-section">Mixed Validation
 * <a class="bookmarkable-link" title="Bookmarkable Link" href="#mixed-validation-section"></a>
 * </h4>
 * Either deferred or normal validation is run in the following cases based on the state the
 * component is in and any validation errors encountered are either hidden or shown to user.
 * <ul>
 *  <li>when disabled property changes. See <a href="#disabled">disabled</a> property for details.</li>
 *  <li>when refresh method is called. See <a href="#refresh">refresh</a> method for details.</li>
 *  <li>when converter property changes. Not all EditableValue components have the converter property. See
 *  the sub-classes that have the converter property for details, e.g., {@link oj.inputBase#converter}.</li>
 *  <li>when required property changes. Not all EditableValue components have the required property. See
 *  the sub-classes that have the required property for details, e.g., {@link oj.inputBase#required}.</li>
 *  <li>when validators property changes. Not all EditableValue components have the validators property. See
 *  the sub-classes that have the validators property for details, e.g., {@link oj.inputBase#validators}.</li>
 *  <li>when asyncValidators property changes. Not all EditableValue components have the asyncValidators property. See
 *  the sub-classes that have the asyncValidators property for details, e.g., {@link oj.inputBase#async-validators}.</li>
 *
 * </ul>
 * </p>
 *
 * <p>
 * <h3 id="deferred-messages-section">
 * Showing Deferred Messages
 * <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-messages-section"></a>
 * </h3>
 * Deferred validation messages are displayed only when page author requests for it explicitly in
 * one of the following ways:
 * <ul>
 * <li>calls the <a href="#showMessages"><code class="prettyprint">showMessages</code></a> method on the component</li>
 * </ul>
 * </p>
 *
 * <p>
 * <h3 id="deferred-validators-section">
 * Validators Participating in Deferred Validation
 * <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-validators-section"></a>
 * </h3>
 * The required validator is the only validator type that participates in deferred validation.
 * The required property needs to be set to true for the required validator to run.
 * </p>
 * <p>
 * <h3 id="user-assistance-text-section">
 * User Assistance Text
 * <a class="bookmarkable-link" title="Bookmarkable Link" href="#user-assistance-text-section"></a>
 * </h3>
 * <p>
 * User assistive text provides guidance to help the user understand what data to enter or select.
 * </p>
 * <p>In the Redwood theme, by default all user assistance text shows inline.
 * For input components, it shows when the field takes focus. In other components
 * it shows all the time. See the user-assistance-density property for other ways
 * the user assistance text can render, like in 'compact' mode, it will render as an icon on the label
 * which when clicked will show the user assistance text in a notewindow.
 * <p>
 * <p>The JET form component properties that are used for user assistance text are help.instruction,
 * validator and converter hints, and help-hints.
 * In the Redwood theme for clarity only one user assistance text shows to the user.
 * The precedence rules are:
 * <ul>
 * <li>help.instruction shows;</li>
 * <li>if no help.instruction, then validator hint shows;</li>
 * <li>if no help.instruction or validator hint, then help-hints.definition shows;</li>
 * <li>if no help.instruction, validator hint, or help-hints.definition, then converter hint shows.</li>
 * <li>help-hints.source always shows along side the above.</li>
 * </ul>
 * </p>
 * <p>In the Alta theme all the user assistance text are displayed to the user. By default
 * help.instruction and the validator/converter hints show in a notewindow that is displayed
 * when the field takes focus. The help-hints render as a help icon on the label and when clicked
 * show in a notewindow. Note: If there is no label, help-hints help icon will not show.
 * </p>
 * <p>Sometimes a validator or converter hints shows that you do not want. To not show it,
 *  set the display-options.validator-hint and/or display-options.converter-hint property to 'none'.
 * </p>
 * <p>required and placeholder properties also can be used to guide the user.
 * In Redwood, a required field shows the word Required under the field
 * when the field is empty and does not have focus.
 * Placeholder is shown when the field is empty and has focus.
 * </p>
 * @ojfragment validationAndMessagingDoc - Used in the general section of classdesc
 * @memberof oj.editableValue
 */

/**
 * <p>Disabled content: JET supports an accessible luminosity contrast ratio,
 * as specified in <a href="http://www.w3.org/TR/WCAG20/#visual-audio-contrast-contrast">WCAG 2.0 - Section 1.4.3 "Contrast"</a>,
 * in the themes that are accessible.  (See the "Theming" chapter of the JET Developer Guide for more information on which
 * themes are accessible.)  Note that Section 1.4.3 says that text or images of text that are part of an inactive user
 * interface component have no contrast requirement.  Because disabled content may not meet the minimum contrast ratio
 * required of enabled content, it cannot be used to convey meaningful information.<p>
 *
 * @ojfragment accessibilityDisabledEditableValue
 * @memberof oj.editableValue
 * @instance
 */

/**
 * <p>The placeholder text is not read reliably by the screen reader. For accessibility reasons, you need to associate the text to its
 * JET form component using aria-describedby.
 * <p>
 *
 * @ojfragment accessibilityPlaceholderEditableValue
 * @memberof oj.editableValue
 * @instance
 */



/* jslint browser: true*/

/**
 * Adapter for handling inline Help and Hints text.
 * Extends the MessagingStrategy which does more now than messages.
 *
 * @extends {oj.MessagingStrategy}
 * @protected
 * @constructor
 * @since 9.0.0
 * @class InlineHelpHintsStrategy
 * @ignore
 * @ojtsignore
 * @param {Array.<string>} displayOptions an array of messaging artifacts that are
 * displayed as an inside label for text fields.
 * For LabelStrategies this is always only labelEdge.
 */
var InlineHelpHintsStrategy = function InlineHelpHintsStrategy(displayOptions, parentElement) {
  this.Init(displayOptions);
  this._userAssistanceDivElement = parentElement;
};
/**
 * Registers the InlineHelpHintsStrategy constructor function with oj.ComponentMessaging.
 * No need to register since we are not creating this strategy on from ComponentMessaging.
 * InlineUserAssistanceStrategy creates it.
 * @private
 */
// oj.ComponentMessaging
//    .registerMessagingStrategy('inlinehelphints',
//     InlineHelpHintsStrategy);
// Subclass from oj.MessagingStrategy


oj.Object.createSubclass(InlineHelpHintsStrategy, oj.MessagingStrategy, 'InlineHelpHintsStrategy');
/**
 * @param {Object} cm a reference to an instance of oj.ComponentMessaging that provides access to
 * the latest messaging content.
 * @public
 * @memberof InlineHelpHintsStrategy
 * @instance
 * @override
 */

InlineHelpHintsStrategy.prototype.activate = function (cm) {
  InlineHelpHintsStrategy.superclass.activate.call(this, cm);

  if (this.containerRoot == null) {
    this._createInlineHelpHints();
  }
};
/**
 * @param {Array.<string>} newOptions
 * @public
 * @memberof InlineHelpHintsStrategy
 * @instance
 * @override
 */


InlineHelpHintsStrategy.prototype.reactivate = function (newOptions, parentElement) {
  InlineHelpHintsStrategy.superclass.reactivate.call(this, newOptions);
  this._userAssistanceDivElement = parentElement;

  var containerRootExists = this._isContainerRootDomInDocument();

  if (!containerRootExists) {
    this._createInlineHelpHints();
  }
};
/**
 * @param {Object=} content the messaging content object. If it contains validityState, then
 * this means the component has messaging content.
 * @return {boolean}
 * @memberof InlineHelpHintsStrategy
 * @instance
 * @oublic
 * @override
 */
// eslint-disable-next-line no-unused-vars


InlineHelpHintsStrategy.prototype.shouldUpdate = function (content) {
  // TODO: Add other help/validation as well. If any of those change
  // we should update.
  var updateTitle = !!(content && content.title !== undefined);
  var updateValidatorHint = !!(content && content.validatorHint !== undefined);
  return updateTitle || updateValidatorHint;
};
/**
 * Updates component with instance using the content provided.
 * @memberof InlineHelpHintsStrategy
 * @instance
 * @public
 * @override
 */


InlineHelpHintsStrategy.prototype.update = function () {
  InlineHelpHintsStrategy.superclass.update.call(this);

  this._updateInlineHelpHints();
};
/**
 * Cleans up dom on the component and removes any event listeners it created.
 * @memberof InlineHelpHintsStrategy
 * @instance
 * @public
 * @override
 */


InlineHelpHintsStrategy.prototype.deactivate = function () {
  var component = this.GetComponent();

  var element = component._getRootElement();

  var container = this._getHelpHintsInlineContainer(element);

  if (container) {
    this.RemoveAriaDescribedByForInlineMessaging(container);
    container.parentElement.removeChild(container);
  } // if we created a event handler then we know we have to delete them here.


  if (this._focusinCallback) {
    this._deleteFocusEventHandlers(element);
  }

  InlineHelpHintsStrategy.superclass.deactivate.call(this);
};
/**
 * Creates the dom adding associated event listeners for applying
 * marker selectors to the root and responding to focus event listeners.
 * @memberof InlineHelpHintsStrategy
 * @instance
 * @private
 */


InlineHelpHintsStrategy.prototype._createInlineHelpHints = function () {
  var component = this.GetComponent();

  var showHelpHints = component._ShowHelpHints();

  if (showHelpHints === 'always') {
    // if showHelpHints is 'focus', then we create the content on the first focusin so that
    // we can delay getting validation hints.
    // otherwise add content now.
    this._addHelpHintsContent(component);
  }

  if (showHelpHints === 'focus') {
    this._createFocusEventHandlers(component);
  }

  this._createHelpHintsAttributeEventHandlers(component);
};
/**
 * Creates the focusevent handlers.
 * @memberof InlineHelpHintsStrategy
 * @instance
 * @private
 */


InlineHelpHintsStrategy.prototype._createFocusEventHandlers = function (component) {
  var element = component._getRootElement();

  this._focusinCallback = InlineHelpHintsStrategy._focusinHandler.bind(this, component);
  element.addEventListener('focusin', this._focusinCallback);
  this._focusoutCallback = InlineHelpHintsStrategy._focusoutHandler.bind(this, component);
  element.addEventListener('focusout', this._focusoutCallback);
};

InlineHelpHintsStrategy.prototype._deleteFocusEventHandlers = function (element) {
  element.removeEventListener('focusin', this._focusinCallback);
  delete this._focusinCallback;
  element.removeEventListener('focusout', this._focusoutCallback);
  delete this._focusoutCallback;
};
/**
 * Creates the help/helpHints handlers.
 * @memberof InlineHelpHintsStrategy
 * @instance
 * @private
 */


InlineHelpHintsStrategy.prototype._createHelpHintsAttributeEventHandlers = function (component) {
  var element = component._getRootElement();

  this._helpHintsChangedCallback = InlineHelpHintsStrategy._helpHintsChangedHandler.bind(this, component);
  element.addEventListener('helpHintsChanged', this._helpHintsChangedCallback);
};

InlineHelpHintsStrategy.prototype._deleteHelpHintsAttributeEventHandlers = function (element) {
  element.removeEventListener('helpHintsChanged', this._helpHintsChangedCallback);
  delete this._helpHintsChangedCallback;
};
/**
 * @return {Element} help hints inline container dom element, if it exists,
 * null otherwise. It is the oj-helphints-inline-container dom element.
 * This may be a child of the user assistance dom element or not because
 * radioset/checkboxset it is not since it is under the label, so start
 * with root
 * @memberof InlineHelpHintsStrategy
 * @instance
 * @private
 */


InlineHelpHintsStrategy.prototype._getHelpHintsInlineContainer = function (rootElem) {
  return rootElem.querySelector('.oj-helphints-inline-container');
};
/**
 * Returns true if the div exists. This is needed
 * because it is possible that components delete their dom, including
 * the inline dom, which means the this.containerRoot is not
 * null.
 * @return {boolean} true if this.containerRoot exists in the dom
 * @private
 * @memberof InlineHelpHintsStrategy
 * @instance
 */


InlineHelpHintsStrategy.prototype._isContainerRootDomInDocument = function () {
  var containerRootExistsInDocument = false;

  if (this.containerRoot) {
    var id = this.containerRoot.id;
    containerRootExistsInDocument = document.getElementById(id);
  }

  return containerRootExistsInDocument !== null;
};
/**
 * Show the message on focus. We will use theming to hide the message on blur.
 * This way it will already be there the next time we focus.
 * We show helpInstruction and if that's not there validaton hint and
 * if that is not there help definition. And on whichever of these, we show
 * More Info... for help.source if that is there.
 * @static
 * @private
 * @param {Object} component form component root element
 * @param {CustomEvent} event focus event
 */
// eslint-disable-next-line no-unused-vars


InlineHelpHintsStrategy._focusinHandler = function (component, event) {
  // add focusin on parent
  this._userAssistanceDivElement.classList.add('oj-focus');

  if (this._contentAddedOnFocus) {
    return;
  }

  this._contentAddedOnFocus = this._addHelpHintsContent(component);
};
/**
 * @static
 * @private
 * @param {Object} component form component root element
 * @param {CustomEvent} event helpChanged event
 */
// eslint-disable-next-line no-unused-vars


InlineHelpHintsStrategy._helpHintsChangedHandler = function (component, event) {
  this._addHelpHintsContent(component);
};
/**
 * Creates the content.
 * @param {Object} component the form component
 * @return {boolean} Returns true if content was added
 * @memberof InlineHelpHintsStrategy
 * @instance
 * @private
 */


InlineHelpHintsStrategy.prototype._addHelpHintsContent = function (component) {
  // let helpSource = component.options.helpHints.source;
  var hintsHtml;
  var helpOptions = component.options.help;
  var helpInstruction = helpOptions ? helpOptions.instruction : null;

  if (helpInstruction) {
    var helpInstructionDom = oj.PopupMessagingStrategyUtils.GetTextDom(document, helpInstruction, true); // turn it into a string

    var helpInstructionDomString = helpInstructionDom ? helpInstructionDom.outerHTML : ''; // @HTMLUpdateOK

    hintsHtml = helpInstructionDomString;
  }

  if (!hintsHtml && this.ShowValidatorHint()) {
    // helpInstruction takes priority. If it is not set, check validator hints.
    // This involves loading the validators if they are not set.
    // ShowValidatorHint may be null if the display-options.validatorHint = 'none',
    // otherwise we show the validator hint.
    // no helpInstruction, so try to get validation hint
    // we do the same thing that we do in PopupComponentMessages
    var hints = this.GetValidatorHints();

    if (hints.length > 0) {
      hintsHtml = hints.join('<br/>');
    }
  }

  if (!hintsHtml) {
    // try to get help definition
    // We get notified of changes to help-hints in
    // InlineHelpHintsStrategy.prototype._createHelpHintsAttributeEventHandlers
    var helpHints = component.options.helpHints;
    var definition = helpHints ? helpHints.definition : null;

    if (definition) {
      hintsHtml = definition;
    }
  } // try to get the converterHint


  if (!hintsHtml && this.ShowConverterHint()) {
    var _hints = this.GetConverterHint();

    if (_hints.length > 0) {
      hintsHtml = _hints.join('<br/>');
    }
  }

  if (hintsHtml && !this.containerRoot) {
    this.containerRoot = document.createElement('div');
    this.containerRoot.classList.add('oj-helphints-inline-container');
    $(this.containerRoot).uniqueId();
    this.AddAriaDescribedByForInlineMessaging(this.containerRoot);

    var showHelpHintsLocation = component._ShowHelpHintsLocation();

    if (showHelpHintsLocation === 'inline') {
      this._userAssistanceDivElement.appendChild(this.containerRoot);
    } else {
      var formControlContainerDom = component._GetFormControlContainer();

      formControlContainerDom.parentElement.insertBefore(this.containerRoot, formControlContainerDom);
    }
  } // Now we have created the container root, we can add the hintsHtml
  // This function is also called when updateHelpHintsContent, so it is possible
  // that there is no more help and hintsHtml is '',
  // in which case we want to clear out textContent.


  if (this.containerRoot) {
    this.containerRoot.innerHTML = hintsHtml || ''; // @HTMLUpdateOK
  }

  if (this._userAssistanceDivElement) {
    // add this selector the first time we have hints. then use
    // theming to hide/show it based on focus and whether or not
    // we have messages, which trumps hints.
    if (hintsHtml) {
      this._userAssistanceDivElement.classList.add('oj-has-helphints');
    } else {
      this._userAssistanceDivElement.classList.remove('oj-has-helphints');
    }
  }

  return hintsHtml;
};
/**
 * If the inline message is already open its contents need to updated when update() or
 * reactivate() is called.
 *
 * @private
 * @memberof InlineHelpHintsStrategy
 * @instance
 */


InlineHelpHintsStrategy.prototype._updateInlineHelpHints = function () {
  var component = this.GetComponent();

  this._addHelpHintsContent(component);
};
/**
 * @static
 * @private
 * @param {Object} component the form component
 * @param {CustomEvent} event focus event
 */
// eslint-disable-next-line no-unused-vars


InlineHelpHintsStrategy._focusoutHandler = function (component, event) {
  // make this focusout since focusout bubbles and blur does not.
  this._userAssistanceDivElement.classList.remove('oj-focus');
};



/* global ThemeUtils:false, Context:false */

/* jslint browser: true*/

/**
 * A messaging strategy that places the messaging content inline (underneath) the editableValue
 * component.
 *
 * @param {Array.<string>} displayOptions an array of messaging artifacts displayed inline. e.g,
 * 'messages' (for now only 'messages' are supported inline, not converterHints, and others)
 * @constructor
 * @extends {oj.MessagingStrategy}
 * @private
 */
oj.InlineMessagingStrategy = function (displayOptions, parentElement) {
  this.Init(displayOptions);
  this._parentElement = parentElement;
};
/**
 * Registers the InlineMessagingStrategy constructor function with oj.ComponentMessaging.
 *
 * @private
 */


oj.ComponentMessaging.registerMessagingStrategy(oj.ComponentMessaging._STRATEGY_TYPE.INLINE, oj.InlineMessagingStrategy); // Subclass from oj.MessagingStrategy

oj.Object.createSubclass(oj.InlineMessagingStrategy, oj.MessagingStrategy, 'oj.InlineMessagingStrategy');
/**
 * Does nothing; We do not create the inline messaging dom until we get messages to show.
 *
 * @param {Object} cm a reference to an instance of oj.ComponentMessaging that provides access to
 * the latest messaging content. * @private
 * @memberof oj.InlineMessagingStrategy
 * @instance
 * @override
 *
 */

oj.InlineMessagingStrategy.prototype.activate = function (cm) {
  oj.InlineMessagingStrategy.superclass.activate.call(this, cm); // We do not create the inline messaging dom until we get messages to show.
};
/**
 * Reinitializes with the new display options and updates component messaging using the new content.
 *
 * @param {Array.<string>} newDisplayOptions
 * @private
 * @memberof oj.InlineMessagingStrategy
 * @instance
 * @override
 *
 */


oj.InlineMessagingStrategy.prototype.reactivate = function (newDisplayOptions, parentElement) {
  oj.InlineMessagingStrategy.superclass.reactivate.call(this, newDisplayOptions);
  this._parentElement = parentElement;

  this._updateInlineMessage();
};
/**
 * Returns true if the messaging content should update. This method is an
 * optimization because the update() method is called too often and any time any content changes.
 * The only time InlineMessagingStrategy#update needs to execute is when the oj.ComponentValidity
 * object is in the content because we don't add this unless there are messages.
 *
 * @param {Object=} content the messaging content object. If it contains validityState, then
 * this means the component has messaging content.
 * @return {boolean}
 * @memberof oj.InlineMessagingStrategy
 * @instance
 * @private
 * @override
 */


oj.InlineMessagingStrategy.prototype.shouldUpdate = function (content) {
  // content is messaging content, and in EditableValue we add a validityState for
  // messages, valid, and severity, so if validityState is there, we know messages are there.
  return !!(content && content.validityState !== undefined);
};
/**
 * Updates component with instance using the content provided.
 * @memberof oj.InlineMessagingStrategy
 * @instance
 * @private
 * @override
 */


oj.InlineMessagingStrategy.prototype.update = function () {
  oj.InlineMessagingStrategy.superclass.update.call(this);

  this._updateInlineMessage();
};
/**
 * Cleans up messages on the component and destroys any widgets it created.
 *
 * @memberof oj.InlineMessagingStrategy
 * @instance
 * @private
 * @override
 */


oj.InlineMessagingStrategy.prototype.deactivate = function () {
  this._removeMessagingContentRootDom();

  oj.InlineMessagingStrategy.superclass.deactivate.call(this);
};
/**
 * Get the default animation.
 *
 * @private
 * @memberof oj.InlineMessagingStrategy
 * @instance
 */


oj.InlineMessagingStrategy.prototype._getDefaultAnimation = function () {
  // Load the default animation once per page scope
  if (!oj.InlineMessagingStrategy._defaultAnimation) {
    var animation = (ThemeUtils.parseJSONFromFontFamily('oj-messaging-inline-option-defaults') || {}).animation;
    animation = animation || {};
    oj.InlineMessagingStrategy._defaultAnimation = animation;
  }

  return oj.InlineMessagingStrategy._defaultAnimation;
};
/**
 * Replace animation options with runtime values, such as oldHeight and
 * newHeight, which are specified as placeholders in the default animations
 * but their values are not known until runtime.
 *
 * @param {string|Object|Array} effects - The animation options.
 * @param {Object} map - An object containing the runtime property key-value map.
 * @return {string|Object|Array} The resolved animation effects
 * @private
 * @memberof oj.InlineMessagingStrategy
 * @instance
 */


oj.InlineMessagingStrategy.prototype._replaceAnimationOptions = function (effects, map) {
  var effectsAsString;
  var isEffectsTypeofString;

  if (!oj.StringUtils.isString(effects)) {
    isEffectsTypeofString = false;
    effectsAsString = JSON.stringify(effects);
  } else {
    isEffectsTypeofString = true;
    effectsAsString = effects + ''; // append "" to get around a closure compiler warning
  }

  var keys = Object.keys(map);

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    effectsAsString = effectsAsString.replace(new RegExp(key, 'g'), map[key]);
  }

  var _effects = isEffectsTypeofString ? effectsAsString :
  /** @type {Object} */
  JSON.parse(effectsAsString);

  return _effects;
};
/**
 * Determine the animation for displaying new messaging content.
 * returns 'open' if the inline message is getting bigger with the new content
 * returns 'close' if the inline message is getting smaller with the new content
 * else returns 'noanimation' if the inline message size is the same
 *
 * @param {jQuery} rootElem - The root element for inline message.
 * @param {string} newContent - The new content to display.
 * @private
 * @memberof oj.InlineMessagingStrategy
 * @instance
 */


oj.InlineMessagingStrategy.prototype._determineAnimation = function (rootElem, newContent) {
  var action;
  var effect;
  var parsedEffect;

  var defaults = this._getDefaultAnimation();

  if (defaults) {
    var el = rootElem[0];
    var oldContent = el.innerHTML; // @HTMLUpdateOK

    var oldHeight = el.offsetHeight;
    var newHeight;
    el.innerHTML = newContent; // @HTMLUpdateOK

    newHeight = el.offsetHeight;
    el.innerHTML = oldContent; // @HTMLUpdateOK

    if (newHeight > oldHeight) {
      action = 'open';
    } else if (newHeight < oldHeight) {
      action = 'close';
    } else {
      action = 'noanimation';
    }

    if (action !== 'noanimation') {
      effect = defaults[action];

      if (effect) {
        parsedEffect = this._replaceAnimationOptions(effect, {
          '#oldHeight': oldHeight + 'px',
          '#newHeight': newHeight + 'px'
        });
      }
    }
  }

  return {
    action: action,
    effect: parsedEffect
  };
};
/**
 * Set busy state before opening or closing inline message.
 *
 * @private
 * @memberof oj.InlineMessagingStrategy
 * @instance
 */


oj.InlineMessagingStrategy.prototype._setBusyState = function () {
  // Set a page-level busy state if not already set
  if (!this._resolveBusyState) {
    var component = this.GetComponent();
    var jElem = component ? component.element : null;
    var domElem = jElem ? jElem[0] : null;
    var busyContext = Context.getContext(domElem).getBusyContext();
    var description = 'The page is waiting for inline message ';

    if (domElem && domElem.id) {
      description += 'for "' + domElem.id + '" ';
    }

    description += 'to open/close';
    this._resolveBusyState = busyContext.addBusyState({
      description: description
    });
  }
};
/**
 * Clear busy state after opening or closing inline message.
 *
 * @private
 * @memberof oj.InlineMessagingStrategy
 * @instance
 */


oj.InlineMessagingStrategy.prototype._clearBusyState = function () {
  if (this._resolveBusyState) {
    this._resolveBusyState();

    this._resolveBusyState = null;
  }
};
/**
 * Queue up inline messaging open/close actions so that it only animate once
 * for multiple updates within the same tick.
 *
 * @param {string} contentToShow - The messaging content to show.
 * @private
 * @memberof oj.InlineMessagingStrategy
 * @instance
 */


oj.InlineMessagingStrategy.prototype._queueAction = function (contentToShow) {
  var self = this;
  var rootElem = this.$messagingContentRoot; // Return if we are animating. This flag is set right before we
  // start animating. When animation is done, it will call _queueAction
  // again with this._currentContentToShow. That way we only show the latest content.
  // Otherwise we may start a new animation or we may swap content
  //  while we are still animating a previous contentToShow.

  if (self._inInlineMessagingAnimation) {
    this._currentContentToShow = contentToShow;
    return;
  }

  this._currentContentToShow = null;

  this._setBusyState(); // If there is a pending timeout, clear it and set a new one so that only the
  // last animation queued within the same tick will be run.  Otherwise we will
  // end up with too many animation since the messaging framework keeps clearing
  // and updating the message display during validation, etc.


  if (this._timeoutId) {
    clearTimeout(this._timeoutId);
  }

  this._timeoutId = setTimeout(function () {
    self._timeoutId = null; // Make sure $messagingContentRoot is still there.  It could have been
    // removed by the time the timeout function is run.

    if (rootElem && rootElem[0]) {
      // Parse and substitute runtime values in animation options
      var actionEffect = self._determineAnimation(rootElem, contentToShow); // action 'close' means the message container is getting smaller
      // (may be a new, smaller message), if it is 'open' it is
      // getting larger. If it is 'noanimation' the size hasn't changed and
      // we don't animate in this case.


      var action = actionEffect.action;
      var effect = actionEffect.effect;

      if (action === 'noanimation') {
        rootElem[0].innerHTML = contentToShow; // @HTMLUpdateOK

        self._clearBusyState();
      } else {
        // aria-live polite is needed so a screen reader will read the inline message without the
        // user needing to set focus to the input field. aria-live: 'off' is needed before
        // content animates otherwise JAWS will re-read the message.
        // We think JAWS re-reads when the dom changes, even if that is with css.
        // This still doesn't work in Chrome because Chrome or JAWS on Chrome
        // seem to buffer the aria-live: polite and not read the aria-live: off.
        // The accessibility team agrees that because it works in
        // Firefox this is either a JAWS or Chrome bug, not a JET bug.
        if (action === 'close') {
          rootElem[0].setAttribute('aria-live', 'off');
        } else {
          rootElem[0].setAttribute('aria-live', 'polite');
        } // Set the new content first if we're opening. We don't animate in if 'open'.


        if (action === 'open') {
          rootElem[0].innerHTML = contentToShow; // @HTMLUpdateOK
        } // Invoke animation


        self._inInlineMessagingAnimation = true; // eslint-disable-next-line no-undef

        AnimationUtils.startAnimation(rootElem[0], 'inline-' + action, effect, self.GetComponent()).then(function () {
          var afterAnimateContentToShow;
          self._inInlineMessagingAnimation = false; // Set the new content last if we're closing; in other words,
          // if we are closing we are animating
          // the old content before we switch in the new content, and to prevent a JAWS re-read,
          // we set aria-live to 'off' above. Now that we are done animating set it to
          // polite so JAWS will read the new message.

          if (action === 'close') {
            rootElem[0].setAttribute('aria-live', 'polite');
            rootElem[0].innerHTML = contentToShow; // @HTMLUpdateOK
          } // Clear busy state when animation ends. If _queueAction was called
          // while we were animating the previous _queueAction request,
          // we saved the _currentContentToShow and returned. Now go
          // ahead a call _queueAction with that new content now that the
          // animation from the previous contentToShow has ended.


          if (self._currentContentToShow !== null) {
            afterAnimateContentToShow = self._currentContentToShow;
            self._currentContentToShow = null;

            self._queueAction(afterAnimateContentToShow);
          } else {
            self._clearBusyState();
          }
        });
      }
    } else {
      // Just clear the busy state if $messagingContentRoot no longer exists
      self._clearBusyState();
    }
  }, 0);
};
/**
 * If the inline message is already open its contents need to updated when update() or
 * reactivate() is called.
 *
 * @private
 * @memberof oj.InlineMessagingStrategy
 * @instance
 */


oj.InlineMessagingStrategy.prototype._updateInlineMessage = function () {
  var contentToShow;
  var domNode; // contentToShow will be "" (a falsey) if there are no messages to show.

  contentToShow = this._buildInlineHtml(); // add/remove oj-has-messages on this._parentElement if it exists;

  if (this._parentElement) {
    if (contentToShow) {
      this._parentElement.classList.add('oj-has-messages');
    } else {
      this._parentElement.classList.remove('oj-has-messages');
    }
  } // create the inline messaging dom if there is content to show and the dom hasn't been created.
  // We do not create the inline messaging dom until the first content is shown.


  var messagingRootExists = this._isMessagingContentRootDomInDocument();

  if (contentToShow && !messagingRootExists) {
    this._createInlineMessage();
  }

  if (this.$messagingContentRoot && this.$messagingContentRoot[0]) {
    // Only enable default animation for custom elements so that automated tests
    // for legacy components are not affected
    if (this.GetComponent()._IsCustomElement()) {
      // This may be called multiple times within the same event cycle because the
      // old message is cleared before validation and the message is
      // reconstructed.  Since we now have animation for inline message, we don't
      // want to update the DOM every single time.  Instead we queue up the
      // updates and will only show the last one within the same event cyle.
      this._queueAction(contentToShow);
    } else {
      // Legacy components don't have animation so just update the DOM
      // push new content into inline message dom
      domNode = this.$messagingContentRoot[0]; // contentToShow includes content that may come from app. It is scrubbed for illegal tags
      // before setting to innerHTML

      domNode.innerHTML = contentToShow; // @HTMLUpdateOK
    }
  }
};

oj.InlineMessagingStrategy.prototype._createInlineMessage = function () {
  var widget;
  this.$messagingContentRoot = $(this._getInlineContentHtml());
  this.AddAriaDescribedByForInlineMessaging(this.$messagingContentRoot[0]);

  this._addAriaLive(this.$messagingContentRoot); // append content that goes in inline messaging div


  if (this._parentElement) {
    this._parentElement.appendChild(this.$messagingContentRoot[0]); // @HTMLUpdateOK

  } else {
    // make it the very LAST child of the widget.
    widget = this.GetComponent().widget();
    widget[0].appendChild(this.$messagingContentRoot[0]); // @HTMLUpdateOK
  }
};
/**
 * Returns the dom for the messaging-inline-container.
 *
 * @return {string}
 * @private
 * @memberof oj.InlineMessagingStrategy
 * @instance
 */


oj.InlineMessagingStrategy.prototype._getInlineContentHtml = function () {
  return "<div class='oj-messaging-inline-container'></div>";
};
/**
 * Removes the messaging content root dom and anything else that was adding during the
 * creation of the messaging content root dom.
 *
 * @private
 * @memberof oj.InlineMessagingStrategy
 * @instance
 */


oj.InlineMessagingStrategy.prototype._removeMessagingContentRootDom = function () {
  var messagingRootExists = this._isMessagingContentRootDomInDocument();

  if (messagingRootExists) {
    this.RemoveAriaDescribedByForInlineMessaging(this.$messagingContentRoot[0]);
    var parentNode = this.$messagingContentRoot[0].parentNode;

    if (parentNode) {
      parentNode.removeChild(this.$messagingContentRoot[0]);
    }
  }

  this.$messagingContentRoot = null;
};
/**
 * aria-live: polite
 * This is needed so a screen reader will read the inline message without the user needing to
 * set focus to the input field.
 * @param {jQuery} messagingRoot
 * @memberof oj.InlineMessagingStrategy
 * @instance
 * @private
 */


oj.InlineMessagingStrategy.prototype._addAriaLive = function (messagingRoot) {
  oj.Assert.assertPrototype(messagingRoot, $);
  messagingRoot[0].setAttribute('aria-live', 'polite');
};
/**
 * Returns the content to show inside the inline message html.
 * @return {string} content to show, else "". "" is a falsey.
 * @private
 * @memberof oj.InlineMessagingStrategy
 * @instance
 */


oj.InlineMessagingStrategy.prototype._buildInlineHtml = function () {
  var document; // For now anyway, ShowMessages is always true since the inlineMessaging case is for messaging.

  if (this.ShowMessages()) {
    document = this.GetComponent().document[0]; // returns messages or "" if there are none

    return this._buildMessagesHtml(document);
  }

  return '';
};
/**
 * Returns the content to show inside messages (not hints)
 * @param {Document} document
 * @return {string} content if there are messages, else "". "" is a falsey.
 * @private
 * @memberof oj.InlineMessagingStrategy
 * @instance
 */


oj.InlineMessagingStrategy.prototype._buildMessagesHtml = function (document) {
  var content = '';
  var maxSeverity;
  var messages;
  var renderSeveritySelectors = true;

  if (this.HasMessages()) {
    messages = this.GetMessages();
    maxSeverity = this.GetMaxSeverity();
    content = oj.PopupMessagingStrategyUtils.buildMessagesHtml(document, messages, maxSeverity, renderSeveritySelectors);
  }

  return content;
};
/**
 * Returns true if the inline messaging div exists. This is needed
 * because it is possible that components delete their dom, including
 * the inline message dom, which means the this.$messagingContentRoot is not
 * null.
 * @return {boolean} true if this.$messagingContentRoot exists in the dom
 * @private
 * @memberof oj.InlineMessagingStrategy
 * @instance
 */


oj.InlineMessagingStrategy.prototype._isMessagingContentRootDomInDocument = function () {
  var messagingRootExistsInDocument = false;

  if (this.$messagingContentRoot) {
    var id = this.$messagingContentRoot[0].id;
    messagingRootExistsInDocument = document.getElementById(id);
  } else {
    return false;
  }

  return messagingRootExistsInDocument !== null;
};



/* global Translations:false */

/* jslint browser: true*/

/**
 * Adapter for handling inline Required text.
 * Extends the MessagingStrategy which does more now than messages.
 *
 * @extends {oj.MessagingStrategy}
 * @protected
 * @constructor
 * @since 9.0.0
 * @class InlineRequiredStrategy
 * @ignore
 * @ojtsignore
 * @param {Array.<string>} displayOptions an array of messaging artifacts that are
 * displayed as an inside label for text fields.
 * For LabelStrategies this is always only labelEdge.
 */
var InlineRequiredStrategy = function InlineRequiredStrategy(displayOptions, parentElement) {
  this.Init(displayOptions);
  this._parentElement = parentElement;
};
/**
 * Registers the InlineRequiredStrategy constructor function with oj.ComponentMessaging.
 * No need to register since we are not creating this strategy on from ComponentMessaging.
 * InlineUserAssistanceStrategy creates it.
 * @private
 */
// oj.ComponentMessaging
//    .registerMessagingStrategy('required',
//     InlineRequiredStrategy);
// Subclass from oj.MessagingStrategy


oj.Object.createSubclass(InlineRequiredStrategy, oj.MessagingStrategy, 'InlineRequiredStrategy');
/**
 * @param {Object} cm a reference to an instance of oj.ComponentMessaging that provides access to
 * the latest messaging content.
 * @public
 * @memberof InlineRequiredStrategy
 * @instance
 * @override
 */

InlineRequiredStrategy.prototype.activate = function (cm) {
  InlineRequiredStrategy.superclass.activate.call(this, cm);

  if (this.containerRoot == null) {
    this._createInlineRequired();
  }
};
/**
 * @param {Array.<string>} newOptions
 * @public
 * @memberof InlineRequiredStrategy
 * @instance
 * @override
 */


InlineRequiredStrategy.prototype.reactivate = function (newOptions, parentElement) {
  InlineRequiredStrategy.superclass.reactivate.call(this, newOptions);
  this._parentElement = parentElement; // select/combobox on refresh destroys all its contents, including
  // the inline messaging container, and then reactivate is called.

  var containerRootExists = this._isContainerRootDomInDocument();

  if (!containerRootExists) {
    this._createInlineRequired();
  }
};
/**
 * @param {Object=} content the messaging content object. If it contains validityState, then
 * this means the component has messaging content.
 * @return {boolean}
 * @memberof InlineRequiredStrategy
 * @instance
 * @oublic
 * @override
 */
// eslint-disable-next-line no-unused-vars


InlineRequiredStrategy.prototype.shouldUpdate = function (content) {
  // We are registering a requiredChanged listener that
  // will update when it should.
  return false;
};
/**
 * Updates component with instance using the content provided.
 * @memberof InlineRequiredStrategy
 * @instance
 * @public
 * @override
 */


InlineRequiredStrategy.prototype.update = function () {
  InlineRequiredStrategy.superclass.update.call(this);
};
/**
 * Cleans up dom on the component and removes any event listeners it created.
 * @memberof InlineRequiredStrategy
 * @instance
 * @public
 * @override
 */


InlineRequiredStrategy.prototype.deactivate = function () {
  var container = this._getRequiredInlineContainer();

  if (container) {
    this._parentElement.removeChild(container);
  }

  var component = this.GetComponent();

  var element = component._getRootElement();

  element.removeEventListener('requiredChanged', this._requiredChangedCallback);
  delete this._requiredChangedCallback;
  this._parentElement = null;
  this.containerRoot = null;
  InlineRequiredStrategy.superclass.deactivate.call(this);
};
/**
 * Creates the Required dom adding associated event listeners for applying
 * marker selectors to the root and responding to required property changes.
 * @memberof InlineRequiredStrategy
 * @instance
 * @private
 */


InlineRequiredStrategy.prototype._createInlineRequired = function () {
  var component = this.GetComponent();
  var options = component.options;

  var element = component._getRootElement(); // we render the required dom if the component is required. We use theming to toggle
  // the visibility of the Required text to follow the Redwood UX design, which is to
  // show the Required text when required and empty and no other user assistance text is showing,
  // else do not show Required.


  if (options.required) {
    this.containerRoot = document.createElement('div');
    this.containerRoot.classList.add('oj-required-inline-container');
    var requiredText = Translations.getTranslatedString('oj-ojEditableValue.requiredText');
    this.containerRoot.textContent = requiredText;
    $(this.containerRoot).uniqueId();

    this._parentElement.appendChild(this.containerRoot);

    if (component._AriaRequiredUnsupported()) {
      this.AddDescribedByToElement(element, this.containerRoot.id);
    }
  }

  if (!this._requiredChangedCallback) {
    // whether or not we create the required dom we need to add an event listener so if required attribute
    // changes on the component, we create the required dom.
    // if required changed, we will remove or add the required dom
    this._requiredChangedCallback = this._requiredChangedHandler.bind(this, component);
    element.addEventListener('requiredChanged', this._requiredChangedCallback);
  }
};
/**
 * @memberof InlineRequiredStrategy
 * @instance
 * @private
 */


InlineRequiredStrategy.prototype._getRequiredInlineContainer = function () {
  return this._parentElement.querySelector('.oj-required-inline-container');
};
/**
 * @memberof InlineRequiredStrategy
 * @instance
 * @private
 * @param {Component} the component
 * @param {CustomEvent} event requiredChanged event
 */


InlineRequiredStrategy.prototype._requiredChangedHandler = function (component, event) {
  var requiredOptionValue = event.detail.value;

  var container = this._getRequiredInlineContainer();

  if (requiredOptionValue && container === null) {
    this._createInlineRequired();
  } else if (!requiredOptionValue && container !== null) {
    // not required
    // remove the dom if it is there
    if (container) {
      this._parentElement.removeChild(container);
    }
  }
};
/**
 * Returns true if the div exists. This is needed
 * because it is possible that components delete their dom, including
 * the inline dom, which means the this.containerRoot is not
 * null.
 * @return {boolean} true if this.containerRoot exists in the dom
 * @private
 * @memberof InlineRequiredStrategy
 * @instance
 */


InlineRequiredStrategy.prototype._isContainerRootDomInDocument = function () {
  var containerRootExistsInDocument = false;

  if (this.containerRoot) {
    var id = this.containerRoot.id;
    containerRootExistsInDocument = document.getElementById(id);
  }

  return containerRootExistsInDocument !== null;
};



/* global InlineRequiredStrategy: false, InlineHelpHintsStrategy: false */

/* jslint browser: true*/

/**
 * A user assistance strategy that places the user assistance content inline (underneath) the editableValue
 * component. This does not look at displayOptions, but passes it on to its contained strategies.
 * For example if display-options.validatorHint='none', we do not want to show it.
 * TODO: This is confusing because displayOptions is what is displayed in each strategy.
 * But for Redwood we want displayOptions to be ['messages', 'validationHint', 'required', 'title']
 * @since 9.0.0
 * @constructor
 * @extends {oj.MessagingStrategy}
 * @private
 */
var InlineUserAssistanceStrategy = function InlineUserAssistanceStrategy(displayOptions) {
  // Redwood wants messages to always show up inline, nowhere else.
  // TODO: Does this need to be able to be set to 'none' for CCAs?
  // is there a displayOptions.messages = 'none'?
  this.Init(displayOptions);
  this._displayOptions = displayOptions;
};
/**
 * Registers the InlineUserAssistanceStrategy constructor function with oj.ComponentMessaging.
 *
 * @private
 */


oj.ComponentMessaging.registerMessagingStrategy(oj.ComponentMessaging._STRATEGY_TYPE.USER_ASSISTANCE_INLINE, InlineUserAssistanceStrategy); // Subclass from oj.MessagingStrategy

oj.Object.createSubclass(InlineUserAssistanceStrategy, oj.MessagingStrategy, 'InlineUserAssistanceStrategy');
/**
 * Activate by writing an empty div and by activating the sub-strategies
 *
 * @param {Object} cm a reference to an instance of oj.ComponentMessaging that provides access to
 * the latest messaging content.
 * @private
 * @memberof InlineUserAssistanceStrategy
 * @instance
 * @override
 *
 */

InlineUserAssistanceStrategy.prototype.activate = function (cm) {
  InlineUserAssistanceStrategy.superclass.activate.call(this, cm);
  this._componentMessaging = cm;
  var component = this.GetComponent();
  var options = component.options;

  var element = component._getRootElement(); // set readonly and disabled event listeners


  this._readonlyChangedCallback = this._readonlyChangedHandler.bind(this, component);
  element.addEventListener('readonlyChanged', this._readonlyChangedCallback);
  this._disabledChangedCallback = this._disabledChangedHandler.bind(this, component);
  element.addEventListener('disabledChanged', this._disabledChangedCallback); // set userAssistanceDensity event listener to change styleclass

  this._userAssistanceDensityChangedCallback = this._userAssistanceDensityChangedHandler.bind(this, component);
  element.addEventListener('userAssistanceDensityChanged', this._userAssistanceDensityChangedCallback); // create the user assistance dom. It is needed in readonly, disabled and enabled modes
  // so that in form layout mixed mode the fields all have this dom with a min-height
  // to keep the fields lined up.

  if (this.containerRoot == null) {
    this._createInlineContainer();
  } // Do not create any dom for sub-dom if readonly or disabled is true
  // since we do not want to show Required, Inline messages, nor help hints in
  // readonly or disabled modes.


  if (this._isDisabledOrReadonly()) {
    return;
  }

  this._activateContainerStrategies(cm, options);
};
/**
 * Reinitializes with the new display options and updates component messaging using the new content.
 * newDisplayOptions are the strategies for InlineUserAssistanceStrategy.
 * During Init we save the original displayOptions.
 *
 * @param {Array.<string>} newDisplayOptions
 * @private
 * @memberof InlineUserAssistanceStrategy
 * @instance
 * @override
 *
 */


InlineUserAssistanceStrategy.prototype.reactivate = function (newDisplayOptions) {
  InlineUserAssistanceStrategy.superclass.reactivate.call(this, newDisplayOptions);
  var options = this.GetComponent().options;

  if (this._isDisabledOrReadonly(options)) {
    return;
  } // select/combobox on refresh destroys all its contents, including
  // the inline containers, and then reactivate is called.


  var containerRootExists = this._isContainerRootDomInDocument();

  if (!containerRootExists) {
    this._createInlineContainer();
  } // if we have already activated our sub-strategies,
  // this._inlineMessagingStrategy will not be undefined


  if (this._inlineMessagingStrategy) {
    // delegate to contained strategies.
    this._inlineMessagingStrategy.reactivate(newDisplayOptions, this.containerRoot);

    if (this._inlineRequiredStrategy) {
      this._inlineRequiredStrategy.reactivate(newDisplayOptions, this.containerRoot);
    }

    if (this._inlineHelpHintsStrategy) {
      this._inlineHelpHintsStrategy.reactivate(newDisplayOptions, this.containerRoot);
    }
  } else {
    // we haven't activated the sub-strategies yet, so do it now.
    this._activateContainerStrategies(this._componentMessaging, options);
  }
};
/**
 * Returns true if the messaging content should update. This method is an
 * optimization because the update() method is called too often and any time any content changes.
 * The only time InlineUserAssistanceStrategy#update needs to execute is when the oj.ComponentValidity
 * object is in the content because we don't add this unless there are messages.
 *
 * @param {Object=} content the messaging content object. If it contains validityState, then
 * this means the component has messaging content.
 * @return {boolean}
 * @memberof InlineUserAssistanceStrategy
 * @instance
 * @private
 * @override
 */


InlineUserAssistanceStrategy.prototype.shouldUpdate = function (content) {
  if (this._isDisabledOrReadonly()) {
    return false;
  } // return true and check in update per strategy we are delegating to.


  this._shouldUpdateContent = content;
  return true;
};
/**
 * Updates component with instance using the content provided.
 * @memberof InlineUserAssistanceStrategy
 * @instance
 * @private
 * @override
 */


InlineUserAssistanceStrategy.prototype.update = function () {
  InlineUserAssistanceStrategy.superclass.update.call(this);

  if (!this._inlineMessagingStrategy) {
    // if we haven't created the sub-strategies yet, return.
    return;
  } // if readonly or disabled, return


  if (this._isDisabledOrReadonly()) {
    return;
  }

  if (this._inlineMessagingStrategy.shouldUpdate(this._shouldUpdateContent)) {
    this._inlineMessagingStrategy.update();
  }

  if (this._inlineRequiredStrategy && this._inlineRequiredStrategy.shouldUpdate(this._shouldUpdateContent)) {
    this._inlineRequiredStrategy.update();
  }

  if (this._inlineHelpHintsStrategy && this._inlineHelpHintsStrategy.shouldUpdate(this._shouldUpdateContent)) {
    this._inlineHelpHintsStrategy.update();
  }
};
/**
 * Cleans up messages on the component and destroys any widgets it created.
 *
 * @memberof InlineUserAssistanceStrategy
 * @instance
 * @private
 * @override
 */


InlineUserAssistanceStrategy.prototype.deactivate = function () {
  this._inlineMessagingStrategy.deactivate();

  if (this._inlineRequiredStrategy) {
    this._inlineRequiredStrategy.deactivate();
  }

  if (this._inlineHelpHintsStrategy) {
    this._inlineHelpHintsStrategy.deactivate();
  }

  this._removeContainerRootDom();

  delete this._inlineMessagingStrategy;
  delete this._inlineRequiredStrategy;
  delete this._inlineHelpHintsStrategy; // Remove event handlers

  var component = this.GetComponent();

  var element = component._getRootElement();

  element.removeEventListener('readonlyChanged', this._readonlyChangedCallback);
  delete this._readonlyChangedCallback;
  element.removeEventListener('disabledChanged', this._disabledChangedCallback);
  delete this._disabledChangedCallback;
  element.removeEventListener('userAssistanceDensityChanged', this._userAssistanceDensityChangedCallback);
  delete this._userAssistanceDensityChangedCallback;
  InlineUserAssistanceStrategy.superclass.deactivate.call(this);
};

InlineUserAssistanceStrategy.prototype._createInlineContainer = function () {
  this.containerRoot = document.createElement('div');
  this.containerRoot.classList.add('oj-user-assistance-inline-container'); // this will be oj-efficient or oj-reflow and will be used in theming to
  // either reserve space with min-height or not reserve space.

  var component = this.GetComponent();
  var userAssistanceOptionValue = component.options.userAssistanceDensity;

  if (userAssistanceOptionValue === 'efficient') {
    this.containerRoot.classList.add('oj-efficient');
  } else if (userAssistanceOptionValue === 'reflow') {
    this.containerRoot.classList.add('oj-reflow');
  }

  $(this.containerRoot).uniqueId(); // append content that goes in inline user assistance div
  // make it the very LAST child of the widget.

  component.widget()[0].appendChild(this.containerRoot); // @HTMLUpdateOK
};
/**
 * Removes the messaging content root dom and anything else that was adding during the
 * creation of the messaging content root dom.
 *
 * @private
 * @memberof InlineUserAssistanceStrategy
 * @instance
 */


InlineUserAssistanceStrategy.prototype._removeContainerRootDom = function () {
  if (this._isContainerRootDomInDocument()) {
    var parentNode = this.containerRoot.parentNode;

    if (parentNode) {
      parentNode.removeChild(this.containerRoot);
    }
  }

  this.containerRoot = null;
};
/**
 * Returns true if the inline div exists. This is needed
 * because it is possible that components delete their dom, including
 * the inline dom, which means the this.containerRoot is not
 * null.
 * @return {boolean} true if this.containerRoot exists in the dom
 * @private
 * @memberof InlineUserAssistanceStrategy
 * @instance
 */


InlineUserAssistanceStrategy.prototype._isContainerRootDomInDocument = function () {
  var containerRootExistsInDocument = false;

  if (this.containerRoot) {
    var id = this.containerRoot.id;
    containerRootExistsInDocument = document.getElementById(id);
  }

  return containerRootExistsInDocument !== null;
};
/**
 * activate the Container Strategies
 * @private
 * @memberof InlineUserAssistanceStrategy
 * @instance
 */


InlineUserAssistanceStrategy.prototype._activateContainerStrategies = function (cm, options) {
  // instantiate and activate the strategy objects this strategy delegates to
  // we wait until this function to instantiate because we want to have the containerRoot
  // created, and we wait until activate to do that in our strategies.
  var Callback = oj.InlineMessagingStrategy;
  this._inlineMessagingStrategy = new Callback(this._displayOptions, this.containerRoot);

  this._inlineMessagingStrategy.activate(cm); // Set up the strategy if the component has a required attribute. It doesn't have to be
  // set to required, but it needs to have a required attribute in its api.


  if (options.required !== undefined) {
    Callback = InlineRequiredStrategy;
    this._inlineRequiredStrategy = new Callback(this._displayOptions, this.containerRoot);

    this._inlineRequiredStrategy.activate(cm);
  } // setup InlineHelpHintsStrategy


  Callback = InlineHelpHintsStrategy;
  this._inlineHelpHintsStrategy = new Callback(this._displayOptions, this.containerRoot);

  this._inlineHelpHintsStrategy.activate(cm);
};
/**
 * If user-assistance-density property is changed
 * @memberof InlineUserAssistanceStrategy
 * @instance
 * @private
 * @param {Component} the component
 * @param {CustomEvent} event readonlyChanged event
 */


InlineUserAssistanceStrategy.prototype._userAssistanceDensityChangedHandler = function (component, event) {
  var userAssistanceOptionValue = event.detail.value;
  var _OJ_REFLOW = 'oj-reflow';
  var _OJ_EFFICIENT = 'oj-efficient';

  if (userAssistanceOptionValue === 'efficient') {
    this.containerRoot.classList.add(_OJ_EFFICIENT);
    this.containerRoot.classList.remove(_OJ_REFLOW);
  } else if (userAssistanceOptionValue === 'reflow') {
    this.containerRoot.classList.add(_OJ_REFLOW);
    this.containerRoot.classList.remove(_OJ_EFFICIENT);
  } else {
    this.containerRoot.classList.remove(_OJ_EFFICIENT);
    this.containerRoot.classList.remove(_OJ_REFLOW);
  }
};
/**
 * If readonly is true, then delete the user-assistance-display dom
 * and deactivate all the sub-strategies, otherwise activate them.
 * @memberof InlineUserAssistanceStrategy
 * @instance
 * @private
 * @param {Component} the component
 * @param {CustomEvent} event readonlyChanged event
 */


InlineUserAssistanceStrategy.prototype._readonlyChangedHandler = function (component, event) {
  var readonlyOptionValue = event.detail.value;

  if (readonlyOptionValue) {
    this._deactivateContainerStrategies();
  } else {
    var options = component.options;

    this._activateContainerStrategies(this._componentMessaging, options);
  }
};
/**
 * If disabled is true, then delete the user-assistance-display dom
 * and deactivate all the sub-strategies, otherwise activate them.
 * @memberof InlineUserAssistanceStrategy
 * @instance
 * @private
 * @param {Component} the component
 * @param {CustomEvent} event disabledChanged event
 */


InlineUserAssistanceStrategy.prototype._disabledChangedHandler = function (component, event) {
  var disabledOptionValue = event.detail.value;

  if (disabledOptionValue) {
    this._deactivateContainerStrategies();
  } else {
    var options = component.options;

    this._activateContainerStrategies(this._componentMessaging, options);
  }
};
/**
 * Deactivate all the sub-strategies.
 * @memberof InlineUserAssistanceStrategy
 * @instance
 * @private
 */


InlineUserAssistanceStrategy.prototype._deactivateContainerStrategies = function () {
  if (this._inlineMessagingStrategy) {
    this._inlineMessagingStrategy.deactivate();
  }

  if (this._inlineRequiredStrategy) {
    this._inlineRequiredStrategy.deactivate();
  }

  if (this._inlineHelpHintsStrategy) {
    this._inlineHelpHintsStrategy.deactivate();
  }

  delete this._inlineMessagingStrategy;
  delete this._inlineRequiredStrategy;
  delete this._inlineHelpHintsStrategy;
};
/**
 * If component readOnly or disabled.
 * @return {boolean}
 * @private
 * @memberof InlineUserAssistanceStrategy
 * @instance
 */


InlineUserAssistanceStrategy.prototype._isDisabledOrReadonly = function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.GetComponent().options;
  var isDisabled = options.disabled || false;
  var isReadOnly = options.readOnly || false;
  return isDisabled || isReadOnly;
};



/* global BaseInsidelLabelStrategy: false */

/* jslint browser: true*/

/**
 * Adapter for rendering fixed labels within the form component's root dom node as the first
 * child of the root dom element,
 * and smaller to match a text field's 'inside' label.
 * This is used for non-text-field components like
 * radioset/checkboxset/slider/switch/datepicker/colorpicker, etc.
 *
 * @extends BaseInsidelLabelStrategy
 * @protected
 * @constructor
 * @since 8.0.0
 * @class InsideFormControlLabelStrategy
 * @ignore
 * @ojtsignore
 * @param {Array.<string>} options an array of messaging artifacts that are
 * displayed as an inside label for non-text field form controls.
 * For LabelStrategies this is always only labelEdge.
 */
var InsideFormControlLabelStrategy = function InsideFormControlLabelStrategy(options) {
  this.Init(options);
};
/**
 * Registers the LabelStrategy constructor function with oj.ComponentMessaging.
 *
 * @private
 */


oj.ComponentMessaging.registerMessagingStrategy(oj.ComponentMessaging._STRATEGY_TYPE.LABEL_EDGE_INSIDE_FORM_CNTRL, InsideFormControlLabelStrategy); // Subclass from BaseInsidelLabelStrategy

oj.Object.createSubclass(InsideFormControlLabelStrategy, BaseInsidelLabelStrategy, 'InsideFormControlLabelStrategy');
/**
 * @param {Object} cm a reference to an instance of oj.ComponentMessaging that provides access to
 * the latest messaging content.
 * @public
 * @memberof InsideFormControlLabelStrategy
 * @instance
 * @override
 */

InsideFormControlLabelStrategy.prototype.activate = function (cm) {
  InsideFormControlLabelStrategy.superclass.activate.call(this, cm);

  this._CreateLabel();
};
/**
 * @param {Array.<string>} newOptions
 * @public
 * @memberof InsideFormControlLabelStrategy
 * @instance
 * @override
 */


InsideFormControlLabelStrategy.prototype.reactivate = function (newOptions) {
  InsideFormControlLabelStrategy.superclass.reactivate.call(this, newOptions);

  this._DestroyLabel();

  this._CreateLabel();
};
/**
 * @param {Object=} content the messaging content object. If it contains validityState, then
 * this means the component has messaging content.
 * @return {boolean}
 * @memberof InsideFormControlLabelStrategy
 * @instance
 * @oublic
 * @override
 */


InsideFormControlLabelStrategy.prototype.shouldUpdate = function () {
  return false;
};
/**
 * Updates component with instance using the content provided.
 * @memberof InsideFormControlLabelStrategy
 * @instance
 * @public
 * @override
 */


InsideFormControlLabelStrategy.prototype.update = function () {
  InsideFormControlLabelStrategy.superclass.update.call(this);
};
/**
 * Cleans up messages on the component and destroys any widgets it created.
 * @memberof InsideFormControlLabelStrategy
 * @instance
 * @public
 * @override
 */


InsideFormControlLabelStrategy.prototype.deactivate = function () {
  this._DestroyLabel();

  InsideFormControlLabelStrategy.superclass.deactivate.call(this);
};
/**
 * Adds a hook for subclass to use its own styleclass on root dom element.
 * @memberof InsideFormControlLabelStrategy
 * @instance
 * @protected
 */


InsideFormControlLabelStrategy.prototype._GetFormControlLabelStyleClass = function () {
  return 'oj-form-control-label-inside';
};
/**
 * Insert the ojLabel
 * @memberof InsideFormControlLabelStrategy
 * @protected
 * @override
 * @param {Element} ojlabel
 * @param {Element} container
 * @param {Object} component
 * @return {string}
 */


InsideFormControlLabelStrategy.prototype._InsertOjLabel = function (ojlabel, _container, component) {
  // node.insertBefore(newnode, existingnode);
  // insert the new ojlabel element as first child of the root
  var root = component._getRootElement();

  root.insertBefore(ojlabel, root.firstElementChild);
};
/**
 * Creates event handlers
 * Override to add helpHints.
 * @param {Element} span span around the label where we use innerText to set the labelHint
 * @param {Element} element root custom element
 * @param {Element} ojlabel ojlabel custom element
 * @param {Element} component form component
 * @memberof InsideFormControlLabelStrategy
 * @instance
 * @protected
 * @override
 */


InsideFormControlLabelStrategy.prototype._CreateEventHandlers = function (span, element, ojlabel, component) {
  InsideFormControlLabelStrategy.superclass._CreateEventHandlers.call(this, span, element, ojlabel, component);
};
/**
 * @static
 * @private
 * @param {Element} span holding label text
 * @param {CustomEvent} event labelChanged event
 */


InsideFormControlLabelStrategy._labelHintChangedHandler = function (span, event) {
  // eslint-disable-next-line no-param-reassign
  span.innerText = event.detail.value;
};



/* global Promise:false, Context:false */

/* jslint browser: true*/

/**
 * Adapter for handling dynamically setting the inputs placeholder attribute
 *
 * @extends {oj.MessagingStrategy}
 * @protected
 * @constructor
 * @since 8.0.0
 * @class oj.InsideLabelPlaceholderStrategy
 * @ignore
 * @ojtsignore
 * @param {Array.<string>} options an array of messaging artifacts displayed inline. e.g,
 */
oj.InsideLabelPlaceholderStrategy = function (options) {
  this.Init(options);
}; // Subclass from oj.MessagingStrategy


oj.Object.createSubclass(oj.InsideLabelPlaceholderStrategy, oj.MessagingStrategy, 'oj.InsideLabelPlaceholderStrategy');
/**
 * Sets up a placeholder for the component instance using the converter hint.
 *
 * @param {Object} cm a reference to an instance of oj.ComponentMessaging that provides access to
 * the latest messaging content.
 * @public
 * @memberof oj.InsideLabelPlaceholderStrategy
 * @instance
 * @override
 */

oj.InsideLabelPlaceholderStrategy.prototype.activate = function (cm) {
  oj.InsideLabelPlaceholderStrategy.superclass.activate.call(this, cm);

  this._createPlaceholderToggle();
};
/**
 * @param {Array.<string>} newOptions
 * @public
 * @memberof oj.InsideLabelPlaceholderStrategy
 * @instance
 * @override
 */


oj.InsideLabelPlaceholderStrategy.prototype.reactivate = function (newOptions) {
  oj.InsideLabelPlaceholderStrategy.superclass.reactivate.call(this, newOptions);

  this._destroyPlaceholderToggle();

  this._createPlaceholderToggle();
};
/**
 * @public
 * @memberof oj.InsideLabelPlaceholderStrategy
 * @instance
 * @override
 */


oj.InsideLabelPlaceholderStrategy.prototype.deactivate = function () {
  this._destroyPlaceholderToggle();

  oj.InsideLabelPlaceholderStrategy.superclass.deactivate.call(this);
};
/**
 *
 * @param {Object=} content the messaging content that is being updated
 * @return {boolean}
 * @public
 * @memberof oj.InsideLabelPlaceholderStrategy
 * @instance
 * @override
 */


oj.InsideLabelPlaceholderStrategy.prototype.shouldUpdate = function (content) {
  return content && content.converterHint !== undefined || this.GetComponent().options.placeholder;
};
/**
 * @public
 * @memberof oj.InsideLabelPlaceholderStrategy
 * @instance
 * @override
 */


oj.InsideLabelPlaceholderStrategy.prototype.update = function () {
  oj.InsideLabelPlaceholderStrategy.superclass.update.call(this);

  this._placeholderChanged();
};
/**
 * @private
 * @memberof oj.InsideLabelPlaceholderStrategy
 * @instance
 */


oj.InsideLabelPlaceholderStrategy.prototype._destroyPlaceholderToggle = function () {
  var component = this.GetComponent();

  var element = component._GetContentElement()[0];

  var rootElement = component._getRootElement();

  this._blurCallback();

  element.removeEventListener('focusout', this._blurCallback, false);
  delete this._blurCallback;
  element.removeEventListener('focusin', this._focusCallback, false);
  delete this._focusCallback;
  rootElement.removeEventListener('placeholderChanged', this._placeholderChangedCallback, false);
  delete this._placeholderChangedCallback;

  if (component._HasPlaceholderSet()) {
    component._SetPlaceholder(component.options.placeholder);

    component._customPlaceholderSet = true;
  }
};
/**
 * @private
 * @memberof oj.InsideLabelPlaceholderStrategy
 * @instance
 */


oj.InsideLabelPlaceholderStrategy.prototype._createPlaceholderToggle = function () {
  var component = this.GetComponent();

  var element = component._GetContentElement()[0];

  var rootElement = component._getRootElement();

  component._customPlaceholderSet = true;
  this._blurCallback = oj.InsideLabelPlaceholderStrategy._blurHandler.bind(this, element);
  element.addEventListener('focusout', this._blurCallback, false);
  this._focusCallback = oj.InsideLabelPlaceholderStrategy._focusHandler.bind(this);
  element.addEventListener('focusin', this._focusCallback, false);
  this._placeholderChangedCallback = this._placeholderChanged.bind(this);
  rootElement.addEventListener('placeholderChanged', this._placeholderChangedCallback, false);

  this._placeholderChanged();
};
/**
 * @private
 * @memberof oj.InsideLabelPlaceholderStrategy
 * @instance
 */


oj.InsideLabelPlaceholderStrategy.prototype._placeholderChanged = function () {
  var component = this.GetComponent();

  var element = component._GetContentElement()[0];

  var callback;

  if (oj.FocusUtils.containsFocus(element)) {
    callback = this._focusCallback;
  } else {
    callback = this._blurCallback;
  } // Allow the component to complete default processing. setPlaceholder will
  // following after the value changed from _AfterSetOption - invoke micro next-tick.


  Promise.resolve(true).then(function () {
    callback();
  });
};
/**
 * Returns true if the converter hint should be shown in the placeholder area.
 * If displayOptions are to be ignored, like in Redwood theme, then this returns false.
 * If displayOptions.converter-hint is 'none', then this returns false;
 * @public
 * @memberof oj.InsideLabelPlaceholderStrategy
 * @param {Object} component
 * @return {boolean}
 * @static
 */


oj.InsideLabelPlaceholderStrategy.ShowConverterHintAsPlaceholder = function (component) {
  var displayOptions = component.options.displayOptions;

  if (!displayOptions || component._getResolvedUserAssistance() !== 'displayOptions') {
    return false;
  }

  var converterHint = displayOptions.converterHint;

  if (converterHint instanceof Array) {
    return converterHint[0] === 'placeholder';
  }

  return converterHint === 'placeholder';
};
/**
 * @private
 * @memberof oj.InsideLabelPlaceholderStrategy
 * @static
 */


oj.InsideLabelPlaceholderStrategy._focusHandler = function () {
  var component = this.GetComponent();
  var placeholder;

  if (oj.InsideLabelPlaceholderStrategy.ShowConverterHintAsPlaceholder(component)) {
    var hints = this.GetConverterHint();
    placeholder = hints.length > 0 ? hints[0] : null;
  }

  if (!placeholder) {
    placeholder = component.options.placeholder;
  }

  component._SetPlaceholder(placeholder);
};
/**
 * @private
 * @memberof oj.InsideLabelPlaceholderStrategy
 * @static
 */


oj.InsideLabelPlaceholderStrategy._blurHandler = function (element) {
  if (element.hasAttribute('aria-haspopup')) {
    // ignore blur handling if the component has a popup and the popup has focus
    var popupId = element.getAttribute('aria-owns');
    var popupDom = document.getElementById(popupId);

    if (oj.FocusUtils.containsFocus(popupDom)) {
      return;
    }
  }

  var placeholder;
  var component = this.GetComponent();

  if (oj.InsideLabelPlaceholderStrategy.ShowConverterHintAsPlaceholder(component)) {
    var hints = this.GetConverterHint();
    placeholder = hints.length > 0 ? hints[0] : null;
  }

  if (!placeholder) {
    placeholder = component.options.placeholder;
  } // if the component legally has a placeholder we cant set it to null.
  // if we do that, select components will choke. Because they rely on placeholder
  // to decide if it should render a empty option etc.
  // So if there is a legal placeholder, we will just set its value to empty on blur.


  if (placeholder === null || placeholder === undefined) {
    component._SetPlaceholder(null);
  } else {
    component._SetPlaceholder('');
  }
};



/* global ThemeUtils:false, Context:false, BaseInsidelLabelStrategy: false */

/* jslint browser: true*/

/**
 * Adapter for handling aspects of floating labels.
 * Extends the MessagingStrategy which does more now than messages. It now
 * is also for rendering the form component's label in one of many positions.
 *
 * @extends BaseInsidelLabelStrategy
 * @protected
 * @constructor
 * @since 7.0.0
 * @class oj.InsideLabelStrategy
 * @ignore
 * @ojtsignore
 * @param {Array.<string>} displayOptions an array of messaging artifacts that are
 * displayed as an inside label for text fields.
 * For LabelStrategies this is always only labelEdge.
 */
oj.InsideLabelStrategy = function (displayOptions) {
  this.Init(displayOptions);
  this._displayOptions = displayOptions;
};
/**
 * Registers the LabelStrategy constructor function with oj.ComponentMessaging.
 *
 * @private
 */


oj.ComponentMessaging.registerMessagingStrategy(oj.ComponentMessaging._STRATEGY_TYPE.LABEL_EDGE_INSIDE, oj.InsideLabelStrategy); // Subclass from BaseInsidelLabelStrategy

oj.Object.createSubclass(oj.InsideLabelStrategy, BaseInsidelLabelStrategy, 'oj.InsideLabelStrategy');
/**
 * @param {Object} cm a reference to an instance of oj.ComponentMessaging that provides access to
 * the latest messaging content.
 * @public
 * @memberof oj.InsideLabelStrategy
 * @instance
 * @override
 */

oj.InsideLabelStrategy.prototype.activate = function (cm) {
  oj.InsideLabelStrategy.superclass.activate.call(this, cm);
  this._componentMessaging = cm;
  var component = this.GetComponent();

  var element = component._getRootElement();

  this._placeholderChangedCallback = this._placeholderChangedHandler.bind(this);
  element.addEventListener('placeholderChanged', this._placeholderChangedCallback);

  this._activatePlaceholderStrategyIfNeeded(cm);

  this._CreateLabel();
};
/**
 * @param {Array.<string>} newOptions
 * @public
 * @memberof oj.InsideLabelStrategy
 * @instance
 * @override
 */


oj.InsideLabelStrategy.prototype.reactivate = function (newDisplayOptions) {
  oj.InsideLabelStrategy.superclass.reactivate.call(this, newDisplayOptions);

  this._DestroyLabel();

  this._CreateLabel();

  if (this._placeholderStrategy) {
    this._placeholderStrategy.reactivate(newDisplayOptions);
  } else {
    // we haven't activated the placeholder yet, so do it now.
    this._activatePlaceholderStrategyIfNeeded(this._componentMessaging);
  }
};
/**
 * @param {Object=} content the messaging content object. If it contains validityState, then
 * this means the component has messaging content.
 * @return {boolean}
 * @memberof oj.InsideLabelStrategy
 * @instance
 * @oublic
 * @override
 */


oj.InsideLabelStrategy.prototype.shouldUpdate = function (content) {
  if (this._placeholderStrategy) {
    return this._placeholderStrategy.shouldUpdate(content);
  }

  return false;
};
/**
 * Updates component with instance using the content provided.
 * @memberof oj.InsideLabelStrategy
 * @instance
 * @public
 * @override
 */


oj.InsideLabelStrategy.prototype.update = function () {
  if (this._placeholderStrategy) {
    this._placeholderStrategy.update();
  }
};
/**
 * Cleans up messages on the component and destroys any widgets it created.
 * @memberof oj.InsideLabelStrategy
 * @instance
 * @public
 * @override
 */


oj.InsideLabelStrategy.prototype.deactivate = function () {
  if (this._placeholderStrategy) {
    this._placeholderStrategy.deactivate();

    delete this._placeholderStrategy;
  } // Remove event handlers


  var component = this.GetComponent();

  var element = component._getRootElement();

  element.removeEventListener('placeholderChanged', this._placeholderChangedCallback);
  delete this._placeholderChangedCallback;

  this._DestroyLabel();

  oj.InsideLabelStrategy.superclass.deactivate.call(this);
};
/**
 * activate the PlaceholderStrategy if they have not already been activated.
 *
 * @private
 * @memberof oj.InsideLabelStrategy
 * @instance
 */


oj.InsideLabelStrategy.prototype._activatePlaceholderStrategyIfNeeded = function (cm) {
  var _this = this;

  if (this._placeholderStrategy === undefined) {
    var createInsideLabelPlaceholderStrategy = function createInsideLabelPlaceholderStrategy() {
      var Callback = oj.InsideLabelPlaceholderStrategy;
      _this._placeholderStrategy = new Callback(_this._displayOptions);

      _this._placeholderStrategy.activate(cm);
    };

    var component = this.GetComponent();
    var compOptions = component.options; // If the component has a placeholder or if it uses displayOptions+
    // has it set so that converter is shown as a placeholder.
    // Note: the Redwood theme does not use displayOptions.

    var needsInsidePlaceholder = compOptions.placeholder || component._getResolvedUserAssistance() === 'displayOptions' && oj.InsideLabelPlaceholderStrategy.ShowConverterHintAsPlaceholder(component);

    if (needsInsidePlaceholder) {
      createInsideLabelPlaceholderStrategy();
    }
  }
};
/**
 * If placeholder has a value, then activate the sub-strategy if it isn't
 * yet activated.
 * @memberof oj.InsideLabelStrategy
 * @instance
 * @private
 */


oj.InsideLabelStrategy.prototype._placeholderChangedHandler = function () {
  this._activatePlaceholderStrategyIfNeeded(this._componentMessaging);
};
/**
 * Gets the form component's container.
 * @memberof oj.InsideLabelStrategy
 * @instance
 * @protected
 * @override
 */


oj.InsideLabelStrategy.prototype._GetContainer = function (component) {
  var container = component._GetFormControlContainer();

  if (!container) {
    return null;
  } // look for a component container override


  var fname = '_GetContentWrapper';

  if (component[fname]) {
    container = component[fname]();
  }

  return container;
};
/**
 * @memberof oj.InsideLabelStrategy
 * @protected
 * @override
 * @param {string} labelEdgeValue
 * @return {string}
 */


oj.InsideLabelStrategy.prototype._GetFormControlLabelStyleClass = function () {
  var labelEdgeValue = 'inside';
  return [oj.InsideLabelStrategy._BASE_STYLE_CLASS, 'label', labelEdgeValue.toLowerCase()].join('-');
};
/**
 * @memberof oj.InsideLabelStrategy
 * @protected
 * @override
 * @param {Element} ojlabel
 * @param {Element} container
 * @param {Object} component
 * @return {string}
 */
// eslint-disable-next-line no-unused-vars


oj.InsideLabelStrategy.prototype._InsertOjLabel = function (ojlabel, container) {
  // node.insertBefore(newnode, existingnode);
  // insert the new ojlabel element before the existing firstChildElement.
  container.insertBefore(ojlabel, container.firstElementChild);
};
/**
 * Base selector (prefix) for styling floating labels
 * @const
 * @private
 * @type {string}
 */


oj.InsideLabelStrategy._BASE_STYLE_CLASS = 'oj-text-field';



/* jslint browser: true*/

/* global Promise:false, Hammer:false, Components:false, Message:false, Context:false, ThemeUtils:false, Translations:false */

/**
 * A messaging strategy that uses an instance of ojPopup component to show and hide messaging content.
 *
 * @param {Array.<string>} displayOptions an array of messaging artifacts displayed in the popup. e.g,
 * 'messages', 'converterHints', 'validationHints', 'title'.
 * @constructor
 * @extends {oj.MessagingStrategy}
 * @private
 */
oj.PopupMessagingStrategy = function (displayOptions) {
  this.Init(displayOptions);
};
/**
 * Registers the PopupMessagingStrategy constructor function with oj.ComponentMessaging.
 *
 * @private
 */


oj.ComponentMessaging.registerMessagingStrategy(oj.ComponentMessaging._STRATEGY_TYPE.NOTEWINDOW, oj.PopupMessagingStrategy); // Subclass from oj.MessagingStrategy

oj.Object.createSubclass(oj.PopupMessagingStrategy, oj.MessagingStrategy, 'oj.PopupMessagingStrategy');
/**
 * Messaging popup defaults for components, by component type. A special 'default' type defines the
 * defaults for most editableValue components.
 * The following properties are available -
 * 'events' - these specify the on handlers for events that are setup to open and close popups
 * 'position' - specifies the type of element the popup is positioned against.
 * @private
 */

oj.PopupMessagingStrategy._DEFAULTS_BY_COMPONENT = {
  // mouseenter and mouseleave is what you want instead of mouseover/mouseout when the launcher
  // isn't a simple input. In the case of radioset and checkboxset, the launcher is the widget
  // which is the div that contains all the rows, inputs and labels. If we use mouseover/mouseout
  // in this case we are constantly opening and closing the popup (not really visible to the user,
  // but still not good for performance I'm sure) if the user moves the mouse around the different
  // dom elements within the widget.
  //
  // on touch devices: the "press" event name maps to Hammer's press event, so a touch and hold
  // will open the popup.
  ojRadioset: {
    position: 'launcher',
    // when press opens popup, the user taps elsewhere to dismiss popup
    events: {
      open: 'focusin mouseenter press',
      close: 'mouseleave'
    }
  },
  ojCheckboxset: {
    position: 'launcher',
    // when press opens popup, the user taps elsewhere to dismiss popup
    events: {
      open: 'focusin mouseenter press',
      close: 'mouseleave'
    }
  },
  // Since we now add extra dom on the input components for inline messages, we don't want to
  // position on the tip of the component root. Instead we want to position on the main part of the
  // component, which is in a lot of cases the launcher. In the case of inputDate/Time/Number,
  // it's the launcher's parent (inputDate/Time/Number wrap input and buttons with a parent).
  ojInputText: {
    position: 'launcher',
    events: {
      open: 'focusin'
    }
  },
  ojTextArea: {
    position: 'launcher',
    events: {
      open: 'focusin'
    }
  },
  ojInputPassword: {
    position: 'launcher',
    events: {
      open: 'focusin'
    }
  },
  ojSwitch: {
    position: 'launcher',
    events: {
      open: 'focusin mouseenter',
      close: 'mouseleave'
    }
  },
  ojSlider: {
    position: 'launcher',
    events: {
      open: 'focusin mouseenter',
      close: 'mouseleave'
    }
  },
  ojColorSpectrum: {
    position: 'launcher',
    events: {
      open: 'focusin mouseenter',
      close: 'mouseleave'
    }
  },
  ojColorPalette: {
    position: 'launcher',
    events: {
      open: 'focusin mouseenter',
      close: 'mouseleave'
    }
  },
  default: {
    position: 'launcher-wrapper',
    events: {
      open: 'focusin'
    }
  }
};
/**
 * @private
 * @const
 * @type {string}
 */

oj.PopupMessagingStrategy._SELECTOR_FORMCONTROL_HINT = 'oj-form-control-hint';
/**
 * @private
 * @const
 * @type {string}
 */

oj.PopupMessagingStrategy._SELECTOR_FORMCONTROL_HINT_CONVERTER = 'oj-form-control-hint-converter';
/**
 * @private
 * @const
 * @type {string}
 */

oj.PopupMessagingStrategy._SELECTOR_FORMCONTROL_HINT_VALIDATOR = 'oj-form-control-hint-validator';
/**
 * @private
 * @const
 * @type {string}
 */

oj.PopupMessagingStrategy._SELECTOR_FORMCONTROL_HINT_TITLE = 'oj-form-control-hint-title';
/**
 * @private
 * @const
 * @type {string}
 */

oj.PopupMessagingStrategy._OPEN_NAMESPACE = '.ojPopupMessagingOpen';
/**
 * @private
 * @const
 * @type {string}
 */

oj.PopupMessagingStrategy._CLOSE_NAMESPACE = '.ojPopupMessagingClose';
/**
 * Sets up a tooltip for the component instance using the messaging content provided.
 *
 * @param {Object} cm a reference to an instance of oj.ComponentMessaging that provides access to
 * the latest messaging content.
 * @private
 * @memberof oj.PopupMessagingStrategy
 * @override
 * @instance
 */

oj.PopupMessagingStrategy.prototype.activate = function (cm) {
  oj.PopupMessagingStrategy.superclass.activate.call(this, cm);

  this._initMessagingPopup();
};
/**
 * Reinitializes with the new display options and updates component messaging using the new content.
 *
 * @param {Array.<string>} newDisplayOptions
 * @private
 * @memberof oj.PopupMessagingStrategy
 * @instance
 * @override
 */


oj.PopupMessagingStrategy.prototype.reactivate = function (newDisplayOptions) {
  oj.PopupMessagingStrategy.superclass.reactivate.call(this, newDisplayOptions);

  this._updatePopupIfOpenOrComponentHasFocus();
};

oj.PopupMessagingStrategy.prototype.update = function () {
  oj.PopupMessagingStrategy.superclass.update.call(this);

  this._updatePopupIfOpenOrComponentHasFocus();
};
/**
 * Cleans up messages on the component and destroys any widgets it created.
 *
 * @private
 * @memberof oj.PopupMessagingStrategy
 * @instance
 * @override
 */


oj.PopupMessagingStrategy.prototype.deactivate = function () {
  this._unregisterLauncherEvents();

  this._destroyTooltip();

  oj.PopupMessagingStrategy.superclass.deactivate.call(this);
};
/**
 * Close the popup if it is open. EditableValue calls this from _NotifyHidden and _NotifyDetached
 * so that we don't have an open popup if the app dev hides a subtree the component is within.
 * @private
 * @memberof oj.PopupMessagingStrategy
 * @instance
 */


oj.PopupMessagingStrategy.prototype.close = function () {
  this._closePopup();
};
/**
 * Closes the associated notewindow popup
 * @private
 * @memberof oj.PopupMessagingStrategy
 * @instance
 */


oj.PopupMessagingStrategy.prototype._closePopup = function () {
  function doClose(resolve) {
    if (this._isPopupInitialized()) {
      if (resolve) {
        // Add an event listener to resolve the promise
        this._setActionResolver(this.$messagingContentRoot, 'close', resolve);
      }

      this.$messagingContentRoot.ojPopup('close'); // Just return if we call ojPopup close.  The promise will be resolved
      // by the ojclose event listener.

      return;
    }

    if (resolve) {
      // Resolve the promise immediately if we didn't call ojPopup close
      resolve(true);
    }
  }

  this._queueAction(doClose.bind(this));
};
/**
 * @private
 * @memberof oj.PopupMessagingStrategy
 * @instance
 */


oj.PopupMessagingStrategy.prototype._initMessagingPopup = function () {
  if (!this._openPopupCallback) {
    this._registerLauncherEvents();
  }
};
/**
 * Add listeners for animation events.
 * We use this to delegate animation events to the editableValue component since
 * the original events are triggered on the popup, which is created internally
 * and the application cannot bind listeners to it.  By delegating the events,
 * application can bind the listeners to the component.
 *
 * @param {jQuery} messagingContentRoot - The jQuery object for the messaging root node
 * @private
 * @memberof oj.PopupMessagingStrategy
 * @instance
 */


oj.PopupMessagingStrategy.prototype._addAnimateEventListeners = function (messagingContentRoot) {
  var delegateEvent = function delegateEvent(newEventType, event, ui) {
    var component = this.GetComponent();

    if (component && component._trigger) {
      // always stop propagation if we have a component to delegate to
      event.stopPropagation(); // prevent default only if the component handler says so, as indicated by
      // a return value of false.

      if (!component._trigger(newEventType, null, ui)) {
        event.preventDefault();
      }
    }
  }; // Add animation event listeners to delegate the events to the component


  messagingContentRoot.on('ojanimatestart.notewindow', delegateEvent.bind(this, 'animateStart'));
  messagingContentRoot.on('ojanimateend.notewindow', delegateEvent.bind(this, 'animateEnd'));
};
/**
 * Remove listeners for animation events.
 *
 * @private
 * @memberof oj.PopupMessagingStrategy
 * @instance
 */


oj.PopupMessagingStrategy.prototype._removeAnimateEventListeners = function (messagingContentRoot) {
  messagingContentRoot.off('ojanimatestart.notewindow');
  messagingContentRoot.off('ojanimateend.notewindow');
};
/**
 * Set busy state on the component that invokes the notewindow.
 *
 * @private
 * @memberof oj.PopupMessagingStrategy
 * @instance
 */


oj.PopupMessagingStrategy.prototype._setBusyState = function (eventType) {
  var component = this.GetComponent();
  var jElem = component ? component.element : null;
  var domElem = jElem ? jElem[0] : null;
  var busyContext = Context.getContext(domElem).getBusyContext();
  var description = 'The page is waiting for note window ';

  if (domElem && domElem.id) {
    description += 'for "' + domElem.id + '" ';
  }

  description += 'to ' + eventType;
  return busyContext.addBusyState({
    description: description
  });
};
/**
 * Set an event listener to resolve promise when popup open/close action ends.
 *
 * @private
 * @memberof oj.PopupMessagingStrategy
 * @instance
 */


oj.PopupMessagingStrategy.prototype._setActionResolver = function (messagingContentRoot, eventType, resolvePromise) {
  var animationOption; // Disable animation if there are other queued actions.  Otherwise we will end
  // up with too many animation since the messaging framework keeps clearing and
  // updating the message display during validation, etc.

  if (this._actionCount > 1) {
    // Remember the original animation so that we can restore it later
    animationOption = messagingContentRoot.ojPopup('option', 'animation');
    messagingContentRoot.ojPopup('option', 'animation', null);
  } // Add a busy state for the component.  Even though ojpopup add busy state,
  // it is in the scope of the popup element.


  var resolveBusyState = this._setBusyState(eventType); // Add an one-time listener to resolve the promise


  messagingContentRoot.one('oj' + eventType, function () {
    // Restore any saved animation option
    if (animationOption) {
      messagingContentRoot.ojPopup('option', 'animation', animationOption);
    }

    resolveBusyState();
    resolvePromise(true);
  });
};
/**
 * Queue up popup open and close actions so that they are executed in the
 * correct order.
 *
 * @private
 * @memberof oj.PopupMessagingStrategy
 * @instance
 */


oj.PopupMessagingStrategy.prototype._queueAction = function (task) {
  if (this.GetComponent()._IsCustomElement()) {
    // Queue up the action for custom elements to avoid animation overlapping each other
    var self = this;

    var createActionPromise = function createActionPromise(_task) {
      var promise = new Promise(_task);
      promise.then(function () {
        self._actionCount -= 1;
      });
      return promise;
    };

    if (!this._actionCount) {
      // If there is no action in progress, create a new promise directly instead
      // of chaining to any resolved promise to avoid an extra wait state.
      this._actionCount = 1;
      this._actionPromise = createActionPromise(task);
    } else {
      this._actionCount += 1;
      this._actionPromise = this._actionPromise.then(function () {
        return createActionPromise(task);
      });
    }
  } else {
    // Invoke the action immediately for legacy components since there is no animation
    task(null);
  }
};
/**
 * Opens a popup. This handler is called in the context of the launcher usually the this.element or
 * some relevant node the messaging popup is associated to.
 *
 * @private
 * @memberof oj.PopupMessagingStrategy
 * @instance
 */


oj.PopupMessagingStrategy.prototype._openPopup = function (event) {
  function doOpen(resolve) {
    var domNode;
    var latestContent;
    var $launcher;

    if (this._canOpenPopup()) {
      latestContent = this._buildPopupHtml();

      if (!oj.StringUtils.isEmptyOrUndefined(latestContent)) {
        var messagingContentRoot = this._getPopupElement();

        var isPopupOpen = messagingContentRoot.ojPopup('isOpen'); // replace popup messaging content with new content

        domNode = oj.PopupMessagingStrategyPoolUtils.getPopupContentNode(messagingContentRoot); // latestContent is includes content that may come from app. It is scrubbed for illegal tags
        // before setting to innerHTML

        domNode.innerHTML = ''; // @HTMLUpdateOK

        domNode.innerHTML = latestContent; // @HTMLUpdateOK

        if (!isPopupOpen) {
          $launcher = this.GetLauncher();

          if (event && event.type === 'press') {
            this._openPopupOnPressEvent($launcher);
          }

          if (resolve) {
            // Add an event listener to resolve the promise
            this._setActionResolver(messagingContentRoot, 'open', resolve);
          }

          messagingContentRoot.ojPopup('open', $launcher); // Just return if we call ojPopup open.  The promise will be resolved
          // by the ojopen event listener.

          return;
        } else if (isPopupOpen) {
          messagingContentRoot.ojPopup('refresh');
        }
      }
    }

    if (resolve) {
      // Resolve the promise immediately if we didn't call ojPopup open
      resolve(true);
    }
  }

  this._queueAction(doOpen.bind(this));
};
/**
 * This is called to open the popup on the 'press' event. E.g., ojCheckboxset and ojRadioset
 * use press to open the popup.
 * @param {Object|null} jqLauncher
 */


oj.PopupMessagingStrategy.prototype._openPopupOnPressEvent = function (jqLauncher) {
  this._inPressEvent = true; // We add these event listeners when we open the popup as a result of the 'press' event
  // and we are going to remove them when we close the popup, as well as when we unregister
  // launcher events to make doubly sure they aren't lying around.
  // / Use capture phase to make sure we cancel it before any regular bubble listeners hear it.

  jqLauncher[0].addEventListener('click', this._eatChangeAndClickOnPress, true); // need to eat 'change' as well. Otherwise the dialog will close on press up, and the input
  // stays unchecked.
  // This is because when the input  gets the 'change' event, it calls validate,
  // which then updates messages, and if there is no message,
  // then calls _updatePopupIfOpen, contentToShow = "", then it closes the popup.

  jqLauncher[0].addEventListener('change', this._eatChangeAndClickOnPress, true); // touchend/mousedown/change/click happen in fast succession on tap or press.
  // Android never fires a click event on press up, so after 50ms we clear the inPressEvent flag
  // since the _eatChangeAndClickOnPress callback never gets called for Android.

  jqLauncher.one('touchend', function () {
    // 50ms.  Make as small as possible to prevent unwanted side effects.
    setTimeout(function () {
      this._inPressEvent = false;
    }, 50);
  });
};
/**
 * The pressHold gesture fires a click and change event on ios after touchend.  Prevent that here.
 * @private
 */


oj.PopupMessagingStrategy.prototype._eatChangeAndClickOnPress = function (event) {
  // on ios:
  // if I tap quickly on an input, I get on div: touchstart/touchend/mousedown/change/click
  // if I tap and hold on an input, I get: touchstart
  // when I let up, I get: touchend/mousedown/change/click
  // on android:
  // if I tap quickly on an input, I get touchstart touchend mousedown click change
  // if I tap and hold on an input, I get touchstart/mousedown
  // when I let up, I get touchend. (no change or click like I do for ios)
  // After 'press' release of a radio or checkbox if we do not eat the the click and change events,
  // the dialog closes.
  if (this._inPressEvent) {
    // For Mobile Safari capture phase at least,
    // returning false doesn't work; must use pD() and sP() explicitly.
    event.preventDefault();
    event.stopPropagation(); // the event order is first change, then click.
    // so when we get the click, clear the inPressEvent flag.

    if (event.type === 'click') {
      this._inPressEvent = false;
    }
  }
};
/**
 * Determines whether the messaging popup can be opened.
 * @return {boolean}
 * @private
 * @memberof oj.PopupMessagingStrategy
 * @instance
 */


oj.PopupMessagingStrategy.prototype._canOpenPopup = function () {
  var options = this.GetComponent().options;
  var isDisabled = options.disabled || false;
  var isReadOnly = options.readOnly || false;
  return !(isDisabled || isReadOnly);
};
/**
 * If the popup is already open or if component has focus,
 * its contents need to updated when update() or reactivate() is called.
 * @private
 * @memberof oj.PopupMessagingStrategy
 * @instance
 */


oj.PopupMessagingStrategy.prototype._updatePopupIfOpenOrComponentHasFocus = function () {
  var contentToShow;
  var domNode;
  var isLauncherActiveElement;
  var isPopupOpen = false;
  var launcher;
  var messagingContentRoot;
  launcher = this.GetLauncher();

  if (launcher == null) {
    return;
  } // See if launcher contains activeElement


  isLauncherActiveElement = this.GetLauncher()[0].contains(document.activeElement);

  if (this._isPopupInitialized()) {
    messagingContentRoot = this._getPopupElement();
    isPopupOpen = messagingContentRoot.ojPopup('isOpen');

    if (isPopupOpen) {
      contentToShow = this._buildPopupHtml();

      if (contentToShow) {
        // push new content into popup
        domNode = oj.PopupMessagingStrategyPoolUtils.getPopupContentNode(messagingContentRoot); // contentToShow is includes content that may come from app. It is scrubbed for illegal tags
        // before setting to innerHTML

        domNode.innerHTML = ''; // @HTMLUpdateOK

        domNode.innerHTML = contentToShow; // @HTMLUpdateOK

        messagingContentRoot.ojPopup('refresh');
      } else {
        // if there is no content to show and popup is currently open, close it.
        messagingContentRoot.ojPopup('close');
      }
    }
  } else if (isLauncherActiveElement) {
    contentToShow = this._buildPopupHtml();

    if (contentToShow) {
      // if popup is closed but focus is on activeElement re-open it
      this._openPopup(undefined);
    }
  }
};
/**
 * @private
 * @memberof oj.PopupMessagingStrategy
 * @instance
 */


oj.PopupMessagingStrategy.prototype._unregisterLauncherEvents = function () {
  var jqLauncher = this.GetLauncher(); // Remove event handlers setup on launcher

  jqLauncher.off(oj.PopupMessagingStrategy._OPEN_NAMESPACE);
  jqLauncher.off(oj.PopupMessagingStrategy._CLOSE_NAMESPACE);
  jqLauncher[0].removeEventListener('click', this._eatChangeAndClickOnPress, true);
  jqLauncher[0].removeEventListener('change', this._eatChangeAndClickOnPress, true);

  if (oj.DomUtils.isTouchSupported()) {
    jqLauncher.ojHammer().off('press');
    jqLauncher.ojHammer('destroy');
    jqLauncher.off('contextmenu', this._eatContextMenuOnOpenPopupListener);
    this._eatContextMenuOnOpenPopupListener = null;
    this._inPressEvent = null;
  }

  this._openPopupCallback = null;
  this._closePopupCallback = null;
};
/**
 * @private
 * @memberof oj.PopupMessagingStrategy
 * @instance
 */


oj.PopupMessagingStrategy.prototype._registerLauncherEvents = function () {
  var closeEvents;
  var closePopupCallback;
  var compDefaults;
  var events;
  var hammerOptions;
  var jqLauncher = this.GetLauncher();
  var nonPressOpenEvents;
  var openPopupCallback;
  var pressEventIndex;
  compDefaults = oj.PopupMessagingStrategy._DEFAULTS_BY_COMPONENT[this.GetComponent().widgetName];
  events = compDefaults ? compDefaults.events : oj.PopupMessagingStrategy._DEFAULTS_BY_COMPONENT.default.events; // 1. associate the ojPopup component to wrapper <div> for popup content
  // 2. wire up on() event handlers for registered events that open and close popup. E.g., focusin.
  // 3. autoDismissal happens automatically when focus leaves component. For other events like
  // mouseover it's required to call off()

  if (events.open) {
    openPopupCallback = this._openPopupCallback;

    if (!openPopupCallback) {
      openPopupCallback = this._openPopup.bind(this);
      this._openPopupCallback = openPopupCallback;
    } // separate out press event, namespace the events string, and attach event handler


    pressEventIndex = events.open.indexOf('press');
    nonPressOpenEvents = this._getNamespacedEvents(events.open.replace('press', ''), oj.PopupMessagingStrategy._OPEN_NAMESPACE);
    jqLauncher.on(nonPressOpenEvents, openPopupCallback); // The pressHold gesture also fires a contextmenu event on Windows 10 touch.
    // Prevent that here for components that use 'press' for popup messaging as
    // the context menu causes the popup message window to close. Note that this
    // means the context menu will be disabled for these components.

    if (oj.DomUtils.isTouchSupported() && pressEventIndex !== -1) {
      this._eatContextMenuOnOpenPopupListener = function () {
        return false;
      };

      jqLauncher.on('contextmenu', this._eatContextMenuOnOpenPopupListener); // for radios and checkboxes, on ios, press hold brings up popup, but release closes it
      // and checks it, so in this case we have to eat the click/change events. this happens
      // in the openPopupCallback

      hammerOptions = {
        recognizers: [[Hammer.Press, {
          time: 750
        }]]
      };
      jqLauncher.ojHammer(hammerOptions).on('press', openPopupCallback);
    }
  }

  if (events.close) {
    closePopupCallback = this._closePopupCallback;

    if (!closePopupCallback) {
      closePopupCallback = this._closePopup.bind(this);
      this._closePopupCallback = closePopupCallback;
    }

    closeEvents = this._getNamespacedEvents(events.close, oj.PopupMessagingStrategy._CLOSE_NAMESPACE);
    jqLauncher.on(closeEvents, closePopupCallback);
  }
};
/**
 * Turn the events string into an array, add namespace, and turn it back into a string.
 * @param {string} events e.g., "focusin mousedown"
 * @param {string} namespace the namespace that starts with a dot
 * @return {string|null} the events string that is namespaced.
 * e.g., "focusin.ojPopupMessagingOpen mousedown.ojPopupMessagingOpen"
 * @private
 */


oj.PopupMessagingStrategy.prototype._getNamespacedEvents = function (events, namespace) {
  var eventsArray;
  var namespacedEventsArray;
  var length;

  if (events === '' || namespace === '') {
    return events;
  }

  eventsArray = events.split(' ');
  length = eventsArray.length;
  namespacedEventsArray = [];

  for (var i = 0; i < length; i++) {
    // ignore ""
    if (eventsArray[i]) {
      namespacedEventsArray.push(eventsArray[i] + namespace);
    }
  }

  return namespacedEventsArray.join(' ');
};
/**
 * Returns the popup position options.
 * Components like radio and checkboxset use the launcher, which is the inputs.
 * Since we now add extra dom for inline messages, we don't want to position
 * on the tip of the component root. Instead we want to position on the main part of the component,
 * which is in a lot of cases the launcher. In the case of inputDate/Time/Number, it's the launcher's
 * parent.
 * @private
 * @memberof oj.PopupMessagingStrategy
 * @instance
 */


oj.PopupMessagingStrategy.prototype._getPopupPosition = function () {
  var compDefaultPosition;
  var compDefaults;
  var launcher;
  var popupPositionOptions;
  compDefaults = oj.PopupMessagingStrategy._DEFAULTS_BY_COMPONENT[this.GetComponent().widgetName];
  compDefaultPosition = compDefaults ? compDefaults.position : oj.PopupMessagingStrategy._DEFAULTS_BY_COMPONENT.default.position;

  if (compDefaultPosition) {
    if (compDefaultPosition === 'launcher') {
      launcher = this.GetLauncher();
    } else if (compDefaultPosition === 'launcher-wrapper') {
      launcher = this.GetLauncher().parent();
    }
  } // should never get here since the _DEFAULTS_BY_COMPONENTS["default"] should cover it.


  if (!launcher) {
    launcher = this.GetComponent().widget();
  }

  popupPositionOptions = {
    my: 'start bottom',
    at: 'end top',
    collision: 'flipcenter',
    of: launcher
  };
  return popupPositionOptions;
};
/**
 * Returns a jquery element that a messaging popup is bound to.
 *
 * @return {jQuery!} messaging popup pool container
 * @private
 * @memberof oj.PopupMessagingStrategy
 * @instance
 */


oj.PopupMessagingStrategy.prototype._getPopupElement = function () {
  var popup;
  var position;

  if (this.$messagingContentRoot) {
    return this.$messagingContentRoot;
  }

  popup = oj.PopupMessagingStrategyPoolUtils.getNextFreePopup();
  position = this._getPopupPosition();
  popup.ojPopup('option', 'position', position);
  popup.ojPopup('option', 'beforeClose', this._popupBeforeCloseCallback.bind(this));
  popup.ojPopup('option', 'close', this._popupCloseCallback.bind(this));
  popup.ojPopup('option', 'open', this._popupOpenCallback.bind(this)); // Use default animation only for custom elements

  if (this.GetComponent()._IsCustomElement()) {
    // Get the default animation
    var defaultAnimations = (ThemeUtils.parseJSONFromFontFamily('oj-messaging-popup-option-defaults') || {}).animation;
    defaultAnimations.actionPrefix = 'notewindow';
    popup.ojPopup('option', 'animation', defaultAnimations);

    this._addAnimateEventListeners(popup);
  } else {
    popup.ojPopup('option', 'animation', null);
  }

  this.$messagingContentRoot = popup;
  return this.$messagingContentRoot;
};
/**
 * Popup open event listener that changes the popups autoDismiss to focusLoss
 * in a timeout of 10ms.  This timeout period gives the browser time to fire
 * events that might follow a click such as a focus event.  This is to allow
 * validation by a button versus a component instance.
 *
 * @param {jQuery.event=} event
 * @memberof! oj.PopupMessagingStrategy
 * @private
 */


oj.PopupMessagingStrategy.prototype._popupOpenCallback = function (event) {
  var target = $(event.target);
  var self = this;
  window.setTimeout(function () {
    if (Components.isComponentInitialized(target, 'ojPopup')) {
      target.ojPopup('option', 'autoDismiss', 'focusLoss');
    } else {
      delete self.$messagingContentRoot;
    }
  }, 10);
};
/**
 * Popup beforeClose event listener that will add busy state to the component
 * @param {jQuery.event=} event
 * @memberof! oj.PopupMessagingStrategy
 * @private
 */


oj.PopupMessagingStrategy.prototype._popupBeforeCloseCallback = function () {
  this._resolveBusyState = this._setBusyState('close');
};
/**
 * Popup closed event listener that will reset the popups state and free it into the
 * pool of available messaging popups.
 * @param {jQuery.event=} event
 * @memberof! oj.PopupMessagingStrategy
 * @private
 */


oj.PopupMessagingStrategy.prototype._popupCloseCallback = function (event) {
  var jqLauncher = this.GetLauncher();
  var target = $(event.target);

  this._removeAnimateEventListeners(target);

  if (Components.isComponentInitialized(target, 'ojPopup')) {
    target.ojPopup('option', 'autoDismiss', 'none');
    target.ojPopup('option', 'open', null);
    target.ojPopup('option', 'close', null);
    target.ojPopup('option', 'beforeClose', null);
  } // Check that the launcher is still there when removing listeners


  if (jqLauncher && jqLauncher[0]) {
    jqLauncher[0].removeEventListener('click', this._eatChangeAndClickOnPress, true);
    jqLauncher[0].removeEventListener('change', this._eatChangeAndClickOnPress, true);
  }

  this.$messagingContentRoot = null;
  this._inPressEvent = null;
  var popupContent = oj.PopupMessagingStrategyPoolUtils.getPopupContentNode(target);
  popupContent.innerHTML = ''; // @HTMLUpdateOK

  if (this._resolveBusyState) {
    this._resolveBusyState();

    this._resolveBusyState = null;
  }
};
/**
 * @memberof! oj.PopupMessagingStrategy
 * @private
 * @instance
 */


oj.PopupMessagingStrategy.prototype._destroyTooltip = function () {
  this._closePopup();

  oj.PopupMessagingStrategyPoolUtils.destroyFreePopup();
};
/**
 * Returns the content to show inside popup.
 * @private
 * @return {String|string} content
 * @memberof oj.PopupMessagingStrategy
 * @instance
 */


oj.PopupMessagingStrategy.prototype._buildPopupHtml = function () {
  var addSeparator = false;
  var document = this.GetComponent().document[0];
  var nwContent = [];
  var nwHtml = '';

  if (this.ShowMessages()) {
    nwContent.push(this._buildMessagesHtml(document));
  }

  if (this.ShowConverterHint() || this.ShowValidatorHint() || this.ShowTitle()) {
    nwContent.push(this._buildHintsHtml(document));
  }

  nwContent.forEach(function (content) {
    if (content) {
      if (addSeparator) {
        nwHtml = nwHtml.concat(oj.PopupMessagingStrategyUtils.getSeparatorHtml(document));
      } else {
        addSeparator = true;
      }

      nwHtml = nwHtml.concat(content);
    }
  });
  return nwHtml;
};
/**
 * Returns the messages html (e.g., error messages, confirmation messages), not hints
 * @param {Document} document
 * @return {string} content
 * @private
 * @memberof oj.PopupMessagingStrategy
 * @instance
 */


oj.PopupMessagingStrategy.prototype._buildMessagesHtml = function (document) {
  var content = '';
  var maxSeverity = this.GetMaxSeverity();
  var messages;
  var renderSeveritySelectors = false;

  if (this.HasMessages()) {
    messages = this.GetMessages();
    content = oj.PopupMessagingStrategyUtils.buildMessagesHtml(document, messages, maxSeverity, renderSeveritySelectors);
  }

  return content;
};
/**
 * All hints including title
 * @param {Document} document
 * @return {string} html content for all hints.
 * @private
 * @memberof oj.PopupMessagingStrategy
 * @instance
 */


oj.PopupMessagingStrategy.prototype._buildHintsHtml = function (document) {
  var hint;
  var hints = [];
  var hintsHtml = '';
  var i;

  if (this.ShowConverterHint()) {
    hints = this.GetConverterHint();
    hint = hints.length ? hints[0] : '';
    hintsHtml += oj.PopupMessagingStrategyUtils.buildHintHtml(document, oj.PopupMessagingStrategy._SELECTOR_FORMCONTROL_HINT_CONVERTER, hint, false, oj.PopupMessagingStrategy._SELECTOR_FORMCONTROL_HINT);
  }

  if (this.ShowValidatorHint()) {
    hints = this.GetValidatorHints();

    for (i = 0; i < hints.length; i++) {
      hintsHtml += oj.PopupMessagingStrategyUtils.buildHintHtml(document, oj.PopupMessagingStrategy._SELECTOR_FORMCONTROL_HINT_VALIDATOR, hints[i], false, oj.PopupMessagingStrategy._SELECTOR_FORMCONTROL_HINT);
    }
  }

  if (this.ShowTitle()) {
    hintsHtml += oj.PopupMessagingStrategyUtils.buildHintHtml(document, oj.PopupMessagingStrategy._SELECTOR_FORMCONTROL_HINT_TITLE, this.GetTitle(), true, oj.PopupMessagingStrategy._SELECTOR_FORMCONTROL_HINT);
  }

  return hintsHtml ? "<div class='oj-form-control-hints'>" + hintsHtml + '</div>' : '';
};
/**
 * Determines if there is a message popup currently associated with the component
 * strategy.
 * @return {boolean}
 * @private
 * @memberof oj.PopupMessagingStrategy
 * @instance
 */


oj.PopupMessagingStrategy.prototype._isPopupInitialized = function () {
  // is(":oj-popup") finds the popup component if it exists
  return this.$messagingContentRoot ? Components.isComponentInitialized(this.$messagingContentRoot, 'ojPopup') : false;
};
/**
 * @ignore
 */


oj.PopupMessagingStrategyUtils = {};
/**
 * Renders the html content for a single hint.
 * @param {Document} document
 * @param {string} selector
 * @param {string} hintText
 * @param {boolean} htmlAllowed
 * @param {string} formControlSelectors
 *
 * @return {string} html content for a single hint.
 * @public
 */

oj.PopupMessagingStrategyUtils.buildHintHtml = function (document, selector, hintText, htmlAllowed, formControlSelectors) {
  var titleDom;

  if (hintText) {
    titleDom = document.createElement('div');
    var selectors = formControlSelectors.split(' ');

    for (var i = 0, len = selectors.length; i < len; ++i) {
      titleDom.classList.add(selectors[i]);
    }

    titleDom.classList.add(selector);

    oj.PopupMessagingStrategyUtils._appendTextDom(titleDom, oj.PopupMessagingStrategyUtils.GetTextDom(document, hintText, htmlAllowed));
  }

  return titleDom ? titleDom.outerHTML : ''; // @HTMLUpdateOK
};
/**
 * @param {number} severity
 * @returns (string} translated string for the severity
 * @public
 */


oj.PopupMessagingStrategyUtils.getSeverityTranslatedString = function (severity) {
  var sevTypeStr; // get the translated string for the severity

  switch (severity) {
    case Message.SEVERITY_LEVEL.FATAL:
      sevTypeStr = Translations.getTranslatedString('oj-message.fatal');
      break;

    case Message.SEVERITY_LEVEL.ERROR:
      sevTypeStr = Translations.getTranslatedString('oj-message.error');
      break;

    case Message.SEVERITY_LEVEL.WARNING:
      sevTypeStr = Translations.getTranslatedString('oj-message.warning');
      break;

    case Message.SEVERITY_LEVEL.INFO:
      sevTypeStr = Translations.getTranslatedString('oj-message.info');
      break;

    case Message.SEVERITY_LEVEL.CONFIRMATION:
      sevTypeStr = Translations.getTranslatedString('oj-message.confirmation');
      break;

    default:
      break;
  }

  return sevTypeStr;
};
/**
 * @param {Document} document
 * @returns {string}
 * @public
 */


oj.PopupMessagingStrategyUtils.getSeparatorHtml = function (document) {
  var jSeparatorDom;
  jSeparatorDom = $(document.createElement('hr'));
  return jSeparatorDom ? jSeparatorDom.get(0).outerHTML : ''; // @HTMLUpdateOK
};
/**
 * Returns the messages html (e.g., error messages, confirmation messages), not hints
 * @param {Document} document
 * @param {Array} messages
 * @param {number} maxSeverity
 * @param {boolean} renderSeveritySelectors
 * @return {string} content
 * @private
 * @memberof oj.PopupMessagingStrategyUtils
 * @instance
 */


oj.PopupMessagingStrategyUtils.buildMessagesHtml = function (document, messages, maxSeverity, renderSeveritySelectors) {
  var content = '';
  var detail;
  var i;
  var j;
  var message;
  var messagesByType = [];
  var messagesByTypes = {};
  var messageObj;
  var severityLevel;
  var severityStr;
  var summary; // Step1: build an indexed array of messages by severity level.

  for (i = 0; i < messages.length; i++) {
    message = messages[i];

    if (!(message instanceof Message)) {
      messageObj = new Message(message.summary, message.detail, message.severity);
    } else {
      messageObj = message;
    }

    severityLevel = Message.getSeverityLevel(messageObj.severity);

    if (!messagesByTypes[severityLevel]) {
      messagesByTypes[severityLevel] = [];
    }

    messagesByTypes[severityLevel].push(messageObj);
  } // Step 2: starting with maxSeverity level build messages with decreasing severity


  for (i = maxSeverity; i >= Message.SEVERITY_LEVEL.CONFIRMATION; i--) {
    messagesByType = messagesByTypes[i] || [];

    for (j = 0; j < messagesByType.length; j++) {
      message = messagesByType[j];
      severityLevel = Message.getSeverityLevel(message.severity);
      severityStr = oj.PopupMessagingStrategyUtils.getSeverityTranslatedString(severityLevel);
      summary = message.summary || severityStr; // if detail is empty we don't care to duplicate summary. also detail if present can be
      // formatted html content (ADF feature)

      detail = message.detail || '';
      content = content.concat(oj.PopupMessagingStrategyUtils.buildMessageHtml(document, summary, detail, severityLevel, renderSeveritySelectors));
    }
  }

  return content;
};
/**
 * Builds the HTML content for a single message
 * @param {Document} document
 * @param {string} summary
 * @param {string} detail
 * @param {number} severityLevel
 * @returns {string}
 * @public
 */


oj.PopupMessagingStrategyUtils.buildMessageHtml = function (document, summary, detail, severityLevel, addSeverityClass) {
  var msgContent;
  var msgDetail;
  var msgDom;
  var msgIcon;
  var msgSummary;
  var severityStr = oj.PopupMessagingStrategyUtils.getSeverityTranslatedString(severityLevel); // build message
  // (x) <Summary Text>
  // <Detail Text>

  msgDom = document.createElement('div');
  msgDom.classList.add(oj.PopupMessagingStrategyUtils._SELECTOR_MESSAGE);

  if (addSeverityClass) {
    var severityClasses = oj.PopupMessagingStrategyUtils._getSeveritySelector(severityLevel).split(' ');

    for (var i = 0, slen = severityClasses.length; i < slen; ++i) {
      msgDom.classList.add(severityClasses[i]);
    }
  } // build msg icon


  msgIcon = document.createElement('span');

  var severityIconClasses = oj.PopupMessagingStrategyUtils._getSeverityIconSelector(severityLevel).split(' ');

  for (var j = 0, silen = severityIconClasses.length; j < silen; ++j) {
    msgIcon.classList.add(severityIconClasses[j]);
  }

  if (severityStr == null) {
    msgIcon.removeAttribute('title');
  } else {
    msgIcon.setAttribute('title', severityStr);
  }

  msgIcon.setAttribute('role', 'img');
  msgDom.appendChild(msgIcon); // @HTMLUpdateOK
  // build msg content which includes summary and detail

  msgContent = document.createElement('span');
  msgContent.classList.add(oj.PopupMessagingStrategyUtils._SELECTOR_MESSAGE_CONTENT);

  if ((ThemeUtils.parseJSONFromFontFamily('oj-messaging-popup-option-defaults') || {}).messageSummaryOptionDefault === 'header') {
    msgSummary = document.createElement('div');
    msgSummary.classList.add(oj.PopupMessagingStrategyUtils._SELECTOR_MESSAGE_SUMMARY);
    msgSummary.textContent = summary;
    msgContent.appendChild(msgSummary); // @HTMLUpdateOK
  }

  if (detail) {
    // detail text allows html content. So scrub it before setting it.
    var detailDom = oj.PopupMessagingStrategyUtils.GetTextDom(document, detail, true);
    msgDetail = document.createElement('div');
    msgDetail.classList.add(oj.PopupMessagingStrategyUtils._SELECTOR_MESSAGE_DETAIL);

    oj.PopupMessagingStrategyUtils._appendTextDom(msgDetail, detailDom);

    msgContent.appendChild(msgDetail); // @HTMLUpdateOK
  }

  msgDom.appendChild(msgContent); // @HTMLUpdateOK

  return msgDom.outerHTML; // @HTMLUpdateOK
};
/**
 * @param {number} severity
 * @return {string} the icon selector for the severity
 * @private
 */


oj.PopupMessagingStrategyUtils._getSeverityIconSelector = function (severity) {
  var sevIconStr; // get the icon selector for the severity

  switch (severity) {
    case Message.SEVERITY_LEVEL.FATAL:
      sevIconStr = oj.PopupMessagingStrategyUtils._SELECTOR_MESSAGE_ERROR_ICON;
      break;

    case Message.SEVERITY_LEVEL.ERROR:
      sevIconStr = oj.PopupMessagingStrategyUtils._SELECTOR_MESSAGE_ERROR_ICON;
      break;

    case Message.SEVERITY_LEVEL.WARNING:
      sevIconStr = oj.PopupMessagingStrategyUtils._SELECTOR_MESSAGE_WARNING_ICON;
      break;

    case Message.SEVERITY_LEVEL.INFO:
      sevIconStr = oj.PopupMessagingStrategyUtils._SELECTOR_MESSAGE_INFO_ICON;
      break;

    case Message.SEVERITY_LEVEL.CONFIRMATION:
      sevIconStr = oj.PopupMessagingStrategyUtils._SELECTOR_MESSAGE_CONFIRMATION_ICON;
      break;

    default:
      break;
  }

  return oj.PopupMessagingStrategyUtils._DEFAULT_STATUS_ICON_SELECTORS + sevIconStr;
};
/**
 * @param {number} severity
 * @return {string} the style selector for the severity
 * @private
 */


oj.PopupMessagingStrategyUtils._getSeveritySelector = function (severity) {
  var sevSelectorStr; // get the icon selector for the severity

  switch (severity) {
    case Message.SEVERITY_LEVEL.FATAL:
      sevSelectorStr = oj.PopupMessagingStrategyUtils._SELECTOR_MESSAGE_ERROR;
      break;

    case Message.SEVERITY_LEVEL.ERROR:
      sevSelectorStr = oj.PopupMessagingStrategyUtils._SELECTOR_MESSAGE_ERROR;
      break;

    case Message.SEVERITY_LEVEL.WARNING:
      sevSelectorStr = oj.PopupMessagingStrategyUtils._SELECTOR_MESSAGE_WARNING;
      break;

    case Message.SEVERITY_LEVEL.INFO:
      sevSelectorStr = oj.PopupMessagingStrategyUtils._SELECTOR_MESSAGE_INFO;
      break;

    case Message.SEVERITY_LEVEL.CONFIRMATION:
    default:
      sevSelectorStr = oj.PopupMessagingStrategyUtils._SELECTOR_MESSAGE_CONFIRMATION;
      break;
  }

  return sevSelectorStr;
};
/**
 *  if content is html clean html by allowing only legal tags before returning, to safeguard from
 *  script injection errors.
 *
 * @param {Document} document
 * @param {string} value
 * @param {boolean=} htmlAllowed if value can have html content
 *
 * @return {Element} dom node containing the scrubbed hint
 * @public
 */


oj.PopupMessagingStrategyUtils.GetTextDom = function (document, value, htmlAllowed) {
  var textDom = null;

  if (oj.StringUtils.isString(value)) {
    if (htmlAllowed && oj.DomUtils.isHTMLContent(value)) {
      // strip out html start/end tags
      textDom = oj.DomUtils.cleanHtml(value.substring(6, value.length - 7));
    } else {
      textDom = document.createElement('span');
      textDom.textContent = value;
    }
  }

  return textDom;
};
/**
 * This function can append dom elements or HTML text, similar to how jquery append() works.  It assumes that the html
 * has already been cleaned.
 * @param {Element} parentElement The parent dom element that the dom element or html text is appended to.
 * @param {String|Element} textDom The dom element or HTML text to append
 * @private
 */


oj.PopupMessagingStrategyUtils._appendTextDom = function (parentElement, textDom) {
  if (oj.StringUtils.isString(textDom)) {
    // eslint-disable-next-line no-param-reassign
    parentElement.innerHTML = textDom; // @HTMLUpdateOK
  } else {
    parentElement.appendChild(textDom);
  }
};
/**
 * @private
 * @const
 * @type {string}
 */


oj.PopupMessagingStrategyUtils._DEFAULT_STATUS_ICON_SELECTORS = 'oj-component-icon oj-message-status-icon ';
/**
 * @private
 * @const
 * @type {string}
 */

oj.PopupMessagingStrategyUtils._SELECTOR_MESSAGE = 'oj-message';
/**
 * @private
 * @const
 * @type {string}
 */

oj.PopupMessagingStrategyUtils._SELECTOR_MESSAGE_SUMMARY = 'oj-message-summary';
/**
 * @private
 * @const
 * @type {string}
 */

oj.PopupMessagingStrategyUtils._SELECTOR_MESSAGE_DETAIL = 'oj-message-detail';
/**
 * @private
 * @const
 * @type {string}
 */

oj.PopupMessagingStrategyUtils._SELECTOR_MESSAGE_CONTENT = 'oj-message-content';
/**
 * @private
 * @const
 * @type {string}
 */

oj.PopupMessagingStrategyUtils._SELECTOR_MESSAGE_ERROR_ICON = 'oj-message-error-icon';
/**
 * @private
 * @const
 * @type {string}
 */

oj.PopupMessagingStrategyUtils._SELECTOR_MESSAGE_WARNING_ICON = 'oj-message-warning-icon';
/**
 * @private
 * @const
 * @type {string}
 */

oj.PopupMessagingStrategyUtils._SELECTOR_MESSAGE_INFO_ICON = 'oj-message-info-icon';
/**
 * @private
 * @const
 * @type {string}
 */

oj.PopupMessagingStrategyUtils._SELECTOR_MESSAGE_CONFIRMATION_ICON = 'oj-message-confirmation-icon'; // new theming keys so that we can style the different types of messages differently. Like,
// the background-color can be light red for error. This style will go on the same dom node
// as the oj-message selector.

/**
 * @private
 * @const
 * @type {string}
 */

oj.PopupMessagingStrategyUtils._SELECTOR_MESSAGE_ERROR = 'oj-message-error';
/**
 * @private
 * @const
 * @type {string}
 */

oj.PopupMessagingStrategyUtils._SELECTOR_MESSAGE_WARNING = 'oj-message-warning';
/**
 * @private
 * @const
 * @type {string}
 */

oj.PopupMessagingStrategyUtils._SELECTOR_MESSAGE_INFO = 'oj-message-info';
/**
 * @private
 * @const
 * @type {string}
 */

oj.PopupMessagingStrategyUtils._SELECTOR_MESSAGE_CONFIRMATION = 'oj-message-confirmation';
/**
 * @ignore
 */

oj.PopupMessagingStrategyPoolUtils = {};
/**
 * @public
 * @returns {jQuery} popup taken or created from the free pool
 */

oj.PopupMessagingStrategyPoolUtils.getNextFreePopup = function () {
  var pool = oj.PopupMessagingStrategyPoolUtils._getPool();

  var popups = pool.find('.' + oj.PopupMessagingStrategyPoolUtils._SELECTOR_MESSAGING);
  var popup;

  if (popups.length === 0) {
    popup = $(oj.PopupMessagingStrategyPoolUtils._getPopupContentHtml());
    popup[0].style.display = 'none'; // popup is an empty div

    popup.appendTo(pool); // @HTMLUpdateOK

    var popupOptions = {
      initialFocus: 'none',
      tail: 'simple',
      autoDismiss: 'none',
      modality: 'modeless',
      animation: {
        open: null,
        close: null
      }
    };
    popup.ojPopup(popupOptions);
  } else {
    popup = $(popups[0]);
  }

  return popup;
};
/**
 * Passed in the root dom element of the message popup and returns the content element.
 *
 * @param {jQuery} popup root element
 * @returns {Element} content element of message popup
 */


oj.PopupMessagingStrategyPoolUtils.getPopupContentNode = function (popup) {
  return popup.find('.' + oj.PopupMessagingStrategyPoolUtils._SELECTOR_MESSAGING_CONTAINER)[0];
};
/**
 * @public
 */


oj.PopupMessagingStrategyPoolUtils.destroyFreePopup = function () {
  var popup;

  if (oj.PopupMessagingStrategyPoolUtils._getFreePoolCount() > 0) {
    // if the message popup is open, remove it.
    // if there is at least one popup in the pool, remove it.
    popup = oj.PopupMessagingStrategyPoolUtils.getNextFreePopup();
    var el = popup[0];
    popup.ojPopup('destroy');
    el.parentNode.removeChild(el);
  }
};
/**
 * Returns a div appended to the body that is a common pool of notewindow popups
 * used internally by editable value holders.
 *
 * @return {jQuery!} messaging popup pool container
 * @private
 */


oj.PopupMessagingStrategyPoolUtils._getPool = function () {
  /** @type {jQuery!} */
  var pool = $('#' + oj.PopupMessagingStrategyPoolUtils._MESSAGING_POPUP_POOL_ID);

  if (pool.length > 0) {
    return pool;
  }

  pool = $('<div>');
  var poolElem = pool[0];
  poolElem.setAttribute('id', oj.PopupMessagingStrategyPoolUtils._MESSAGING_POPUP_POOL_ID);
  poolElem.setAttribute('role', 'presentation');
  document.body.appendChild(poolElem); // @HTMLUpdateOK

  return pool;
};
/**
 * @return {number} number of unused popup in the pool
 * @private
 */


oj.PopupMessagingStrategyPoolUtils._getFreePoolCount = function () {
  var pool = oj.PopupMessagingStrategyPoolUtils._getPool();

  var popups = pool.find('.' + oj.PopupMessagingStrategyPoolUtils._SELECTOR_MESSAGING);
  return popups.length;
};
/**
 * @return {string} messaging popup html
 * @private
 */


oj.PopupMessagingStrategyPoolUtils._getPopupContentHtml = function () {
  return '<div class="' + oj.PopupMessagingStrategyPoolUtils._SELECTOR_MESSAGING + '">' + '<div class="' + oj.PopupMessagingStrategyPoolUtils._SELECTOR_MESSAGING_CONTAINER + '"></div>' + '</div>';
};
/**
 * @const
 * @private
 * @type {string}
 */


oj.PopupMessagingStrategyPoolUtils._SELECTOR_MESSAGING_CONTAINER = 'oj-messaging-popup-container';
/**
 * @const
 * @private
 * @type {string}
 */

oj.PopupMessagingStrategyPoolUtils._SELECTOR_MESSAGING = 'oj-messaging-popup';
/**
 * @const
 * @private
 * @type {string}
 */

oj.PopupMessagingStrategyPoolUtils._MESSAGING_POPUP_POOL_ID = '__oj_messaging_popup_pool';

});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojoption',['ojs/ojcore', 'jquery', 'ojs/ojcomponentcore'], 
function(oj, $)
{

//%COMPONENT_METADATA%
var __oj_option_metadata = 
{
  "properties": {
    "disabled": {
      "type": "boolean",
      "value": false
    },
    "value": {
      "type": "any"
    }
  },
  "methods": {
    "setProperty": {},
    "getProperty": {},
    "refresh": {},
    "setProperties": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "extension": {}
};


/**
 * @constructor
 * @private
 */
// eslint-disable-next-line no-unused-vars
function ojOption(context) {
  /**
   * Append each node to the element.
   * @private
   */
  function _appendNodes(elem, nodes) {
    $.each(nodes, function (i, node) {
      elem.appendChild(node);
    });
  }
  /**
   * Remove node from the element.
   * @private
   */


  function _removeNodes(elem, nodes) {
    $.each(nodes, function (i, node) {
      elem.removeChild(node);
    });
  }
  /**
   * Rearrange slots in the right order and remove unwanted slots.
   * @private
   */


  function _arrangeSlots(elem) {
    // get the slotMap
    var slots = oj.BaseCustomElementBridge.getSlotMap(elem);
    var supportedSlots = ['startIcon', '', 'endIcon']; // remove unwanted slots

    $.each(slots, function (slotName, nodes) {
      if (supportedSlots.indexOf(slotName) === -1) {
        _removeNodes(elem, nodes);
      }
    }); // rearrange slots

    $.each(supportedSlots, function (i, slotName) {
      if (slots[slotName]) {
        _appendNodes(elem, slots[slotName]);
      }
    });
  }

  this.updateDOM = function () {
    var customRenderer = context.element.customOptionRenderer; // reorder the slots and remove unwanted slots

    _arrangeSlots(context.element);

    if (customRenderer && typeof customRenderer === 'function') {
      customRenderer(context.element);
    }
  };
}



/**
 * @ojcomponent oj.ojOption
 * @since 4.0.0
 * @ojshortdesc An option represents a value for JET elements that display a list of values.
 * @ojrole option
 *
 * @ojsignature class ojOption extends JetElement<ojOptionSettableProperties>
 *
 * @ojpropertylayout {propertyGroup: "common", items: ["value", "disabled"]}
 *
 * @classdesc
 * <h3 id="optionOverview-section">
 *   JET Option
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#optionOverview-section"></a>
 * </h3>
 * <p>The oj-option element is used to declare values for JET elements that display list of values.
 * It's supported by the following elements:
 * <ul>
 * <li>oj-buttonset-one</li>
 * <li>oj-buttonset-many</li>
 * <li>oj-checkboxset</li>
 * <li>oj-combobox-one</li>
 * <li>oj-combobox-many</li>
 * <li>oj-menu</li>
 * <li>oj-radioset</li>
 * <li>oj-select-one</li>
 * <li>oj-select-many</li>
 * <li>oj-menu-select-many</li>
 * <li>oj-swipe-actions</li>
 * </ul>
 * </p>
 * <p>For example:
 * <pre class="prettyprint">
 * <code>
 * &lt;oj-select-one>
 *   &lt;oj-option value="option 1">option 1&lt;/oj-option>
 *   &lt;oj-option value="option 2">option 2&lt;/oj-option>
 *   &lt;oj-option value="option 3">option 3&lt;/oj-option>
 *   &lt;oj-option value="option 4">option 4&lt;/oj-option>
 * &lt;/oj-select-one>
 * </code></pre>
 */

/**
 * <p>Disables the oj-option if set to <code class="prettyprint">true</code>.
 *
 * @name disabled
 * @ojshortdesc Disables the option if set to true.
 * @expose
 * @memberof oj.ojOption
 * @instance
 * @type {boolean}
 * @default false
 *
 * @example <caption>Initialize the oj-option with the <code class="prettyprint">disabled</code> attribute specified:</caption>
 * &lt;oj-option disabled="[[isDisabled]]" value="option1">Option1&lt;/oj-option>
 *
 * @example <caption>Get or set the <code class="prettyprint">disabled</code> property after initialization:</caption>
 * // getter
 * var disabledValue = myOption.disabled;
 *
 * // setter
 * myOption.disabled = true;
 */

/**
 * <p>Specifies the oj-option's value. The value is associated with the oj-option element whose display value may be different.
 *
 * @name value
 * @ojshortdesc The value of the option.
 * @expose
 * @memberof oj.ojOption
 * @instance
 * @type {any}
 *
 * @example <caption>Initialize the oj-option with the <code class="prettyprint">value</code> attribute specified:</caption>
 * &lt;oj-option value="option1">Option1&lt;/oj-option>
 *
 * @example <caption>Get or set the <code class="prettyprint">value</code> property after initialization:</caption>
 * // getter
 * var optionValue = myOption.value;
 *
 * // setter
 * myOption.value = 'option1';
 */

/**
 * <p>Child content for oj-option. This is normally the text node that displays for oj-option.</p>
 *
 * @ojchild Default
 * @ojshortdesc The default slot for the option's content.
 * @memberof oj.ojOption
 *
 * @example <caption>Initialize the oj-option with child content specified:</caption>
 * &lt;oj-option>
 *   Option label
 * &lt;/oj-option>
 */

/**
 * <p>Named slot for the oj-option's start icon.</p>
 *
 * @ojslot startIcon
 * @ojshortdesc The slot for the option's start icon.
 * @memberof oj.ojOption
 *
 * @example <caption>Initialize the oj-option with the <code class="prettyprint">startIcon</code> slot specified:</caption>
 * &lt;oj-option>
 *   &lt;span slot='startIcon'>&lt;img src='start.png' alt='Start'>&lt;/span>
 * &lt;/oj-option>
 */

/**
 * <p>Named slot for the oj-option's end icon.</p>
 *
 * @ojslot endIcon
 * @ojshortdesc The slot for the option's end icon.
 * @memberof oj.ojOption
 *
 * @example <caption>Initialize the oj-option with the <code class="prettyprint">endIcon</code> slot specified:</caption>
 * &lt;oj-option>
 *   &lt;span slot='endIcon'>&lt;img src='end.png' alt='End'>&lt;/span>
 * &lt;/oj-option>
 */

/**
 * Sets a property or a single subproperty for complex properties and notifies the component
 * of the change, triggering a [property]Changed event.
 *
 * @function setProperty
 * @ojshortdesc Sets a property or a single subproperty for complex properties and notifies the component of the change, triggering a corresponding event.
 * @param {string} property - The property name to set. Supports dot notation for subproperty access.
 * @param {any} value - The new value to set the property to.
 * @return {void}
 *
 * @expose
 * @memberof oj.ojOption
 * @instance
 *
 * @example <caption>Set a single subproperty of a complex property:</caption>
 * myComponent.setProperty('complexProperty.subProperty1.subProperty2', "someValue");
 */

/**
 * Retrieves a value for a property or a single subproperty for complex properties.
 * @function getProperty
 * @param {string} property - The property name to get. Supports dot notation for subproperty access.
 * @return {any}
 *
 * @expose
 * @memberof oj.ojOption
 * @instance
 *
 * @example <caption>Get a single subproperty of a complex property:</caption>
 * var subpropValue = myComponent.getProperty('complexProperty.subProperty1.subProperty2');
 */

/**
 * Refreshes the visual state of the component.
 *
 * @function refresh
 * @return {void}
 * @expose
 * @memberof oj.ojOption
 * @instance
 */

/**
 * Performs a batch set of properties.
 * @function setProperties
 * @param {Object} properties - An object containing the property and value pairs to set.
 * @return {void}
 *
 * @expose
 * @memberof oj.ojOption
 * @instance
 *
 * @example <caption>Set a batch of properties:</caption>
 * myComponent.setProperties({"prop1": "value1", "prop2.subprop": "value2", "prop3": "value3"});
 */



/* global __oj_option_metadata */

/* global ojOption:false */

/**
 * @protected
 * @ignore
 */
(function () {
  // not documented
  __oj_option_metadata.properties.customOptionRenderer = {};
  __oj_option_metadata.extension._CONSTRUCTOR = ojOption;
  oj.CustomElementBridge.register('oj-option', {
    metadata: __oj_option_metadata
  });
})();

});
(function() {function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

define('ojs/ojhighlighttext',['exports', 'ojs/ojvcomponent'], function (exports, ojvcomponent) {
  'use strict';
  /**
   * @license
   * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
   * The Universal Permissive License (UPL), Version 1.0
   * as shown at https://oss.oracle.com/licenses/upl/
   * @ignore
   */

  /**
   * @ojcomponent oj.ojHighlightText
   * @ojtsvcomponent
   * @augments oj.baseComponent
   * @since 9.1.0
   * @ojdisplayname Highlight Text
   * @ojshortdesc A Highlight Text renders text with highlighting applied.
   * @ojsignature [{
   *                target: "Type",
   *                value: "class ojHighlightText extends baseComponent<ojHighlightTextSettableProperties>"
   *               },
   *               {
   *                target: "Type",
   *                value: "ojHighlightTextSettableProperties extends baseComponentSettableProperties",
   *                for: "SettableProperties"
   *               }
   *              ]
   *
   * @ojpropertylayout {propertyGroup: "common", items: ["text", "matchText"]}
   * @ojvbdefaultcolumns 6
   * @ojvbmincolumns 2
   *
   * @classdesc
   * <h3 id="highlightTextOverview-section">
   *   JET Highlight Text
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#highlightTextOverview-section"></a>
   * </h3>
   * <p>Description: JET Highlight Text renders text with highlighting applied.</p>
   *
   * <p>JET Highlight Text renders a text string with highlighting applied to the given text to match.</p>
   *
   * A Highlight Text can be created with the following markup.</p>
   *
   * <pre class="prettyprint"><code>
   * &lt;oj-highlight-text
   *   text='My text to apply highlighting to.'
   *   match-text='igh'>
   * &lt;/oj-highlight-text>
   * </code></pre>
   */

  /**
   * The text string to apply highlighting to.
   *
   * @example <caption>Initialize the Highlight Text with the <code class="prettyprint">text</code> attribute specified:</caption>
   * &lt;oj-highlight-text text="My text to apply highlighting to.">&lt;/oj-highlight-text>
   *
   * @example <caption>Get or set the <code class="prettyprint">text</code> property after initialization:</caption>
   * // getter
   * var textValue = myHighlightText.text;
   *
   * // setter
   * myHighlightText.text = "My text to apply highlighting to.";
   *
   * @expose
   * @member
   * @name text
   * @ojshortdesc The text string to apply highlighting to.
   * @ojtranslatable
   * @access public
   * @instance
   * @memberof oj.ojHighlightText
   * @type {string}
   * @default ''
   */

  /**
   * The text string to match.
   *
   * @example <caption>Initialize the Highlight Text with the <code class="prettyprint">match-text</code> attribute specified:</caption>
   * &lt;oj-highlight-text match-text="igh">&lt;/oj-highlight-text>
   *
   * @example <caption>Get or set the <code class="prettyprint">matchText</code> property after initialization:</caption>
   * // getter
   * var matchTextValue = myHighlightText.matchText;
   *
   * // setter
   * myHighlightText.matchText = "igh";
   *
   * @expose
   * @member
   * @name matchText
   * @ojshortdesc The text string to match.
   * @ojtranslatable
   * @access public
   * @instance
   * @memberof oj.ojHighlightText
   * @type {string}
   * @default ''
   */
  // Superclass Doc Overrides

  /**
   * @ojslot contextMenu
   * @memberof oj.ojHighlightText
   * @ignore
   */

  /**
   * @name refresh
   * @memberof oj.ojHighlightText
   * @instance
   * @ignore
   */

  /**
   * @name translations
   * @memberof oj.ojHighlightText
   * @instance
   * @ignore
   */

  var __decorate = null && null.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
      if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    }
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };

  var Props = function Props() {
    _classCallCheck(this, Props);

    this.text = '';
    this.matchText = '';
  };

  exports.HighlightText = /*#__PURE__*/function (_ojvcomponent$VCompon) {
    _inherits(HighlightText, _ojvcomponent$VCompon);

    var _super = _createSuper(HighlightText);

    function HighlightText(props) {
      var _this;

      _classCallCheck(this, HighlightText);

      _this = _super.call(this, props);
      _this._HIGHLIGHT_TOKEN = '__@@__';
      return _this;
    }

    _createClass(HighlightText, [{
      key: "render",
      value: function render() {
        var props = this.props;

        var content = this._highlighter(props.text, props.matchText);

        return ojvcomponent.h("oj-highlight-text", {
          class: 'oj-highlighttext'
        }, content);
      }
    }, {
      key: "_highlighter",
      value: function _highlighter(unhighlightedText, matchText) {
        if (matchText) {
          var escapedMatchText = this._escapeRegExp(matchText);

          var highlightedText = unhighlightedText.replace(new RegExp(escapedMatchText, 'gi'), this._HIGHLIGHT_TOKEN + '$&' + this._HIGHLIGHT_TOKEN);
          var tokens = highlightedText.split(this._HIGHLIGHT_TOKEN);
          var nodes = tokens.map(function (current, index) {
            return index % 2 == 0 ? current : ojvcomponent.h("span", {
              class: 'oj-highlighttext-highlighter'
            }, current);
          });
          return ojvcomponent.h("span", null, nodes);
        }

        return ojvcomponent.h("span", null, unhighlightedText);
      }
    }, {
      key: "_escapeRegExp",
      value: function _escapeRegExp(str) {
        return str.replace(/[.*+\-?^${}()|[\]\\]/g, '\\$&');
      }
    }]);

    return HighlightText;
  }(ojvcomponent.VComponent);

  exports.HighlightText.metadata = {
    "extension": {
      "_DEFAULTS": Props
    },
    "properties": {
      "text": {
        "type": "string",
        "value": ""
      },
      "matchText": {
        "type": "string",
        "value": ""
      }
    }
  };
  exports.HighlightText = __decorate([ojvcomponent.customElement('oj-highlight-text')], exports.HighlightText);
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
});
}());
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojselectcombobox',['ojs/ojcore', 'jquery', 'ojs/ojcontext', 'ojs/ojlistdataproviderview', 'ojs/ojtreedataproviderview', 'ojs/ojthemeutils', 'ojs/ojtimerutils', 'ojs/ojcomponentcore', 'ojs/ojlogger', 'ojs/ojeditablevalue', 'ojs/ojoptgroup', 'ojs/ojoption', 'ojs/ojhighlighttext'], 
function(oj, $, Context, ListDataProviderView, TreeDataProviderView, ThemeUtils, TimerUtils, Components, Logger)
{
  "use strict";
var __oj_combobox_many_metadata = 
{
  "properties": {
    "asyncValidators": {
      "type": "Array<Object>",
      "value": []
    },
    "converter": {
      "type": "object"
    },
    "describedBy": {
      "type": "string"
    },
    "disabled": {
      "type": "boolean",
      "value": false
    },
    "displayOptions": {
      "type": "object",
      "properties": {
        "converterHint": {
          "type": "Array<string>|string",
          "value": [
            "placeholder",
            "notewindow"
          ]
        },
        "helpInstruction": {
          "type": "Array<string>|string",
          "value": [
            "notewindow"
          ]
        },
        "messages": {
          "type": "Array<string>|string",
          "value": [
            "inline"
          ]
        },
        "validatorHint": {
          "type": "Array<string>|string",
          "value": [
            "notewindow"
          ]
        }
      }
    },
    "help": {
      "type": "object",
      "properties": {
        "instruction": {
          "type": "string",
          "value": ""
        }
      }
    },
    "helpHints": {
      "type": "object",
      "properties": {
        "definition": {
          "type": "string",
          "value": ""
        },
        "source": {
          "type": "string",
          "value": ""
        }
      }
    },
    "labelEdge": {
      "type": "string",
      "enumValues": [
        "inside",
        "none",
        "provided"
      ]
    },
    "labelHint": {
      "type": "string",
      "value": ""
    },
    "labelledBy": {
      "type": "string"
    },
    "maximumResultCount": {
      "type": "number",
      "value": 15
    },
    "messagesCustom": {
      "type": "Array<Object>",
      "writeback": true,
      "value": []
    },
    "minLength": {
      "type": "number",
      "value": 0
    },
    "optionRenderer": {
      "type": "function"
    },
    "options": {
      "type": "Array<Object>|object"
    },
    "optionsKeys": {
      "type": "object",
      "properties": {
        "childKeys": {
          "type": "object",
          "properties": {
            "label": {
              "type": "string"
            },
            "value": {
              "type": "string"
            },
            "children": {
              "type": "string"
            },
            "childKeys": {
              "type": "object",
              "properties": {
                "label": {
                  "type": "string"
                },
                "value": {
                  "type": "string"
                },
                "children": {
                  "type": "string"
                },
                "childKeys": {
                  "type": "object"
                }
              }
            }
          }
        },
        "children": {
          "type": "string"
        },
        "label": {
          "type": "string"
        },
        "value": {
          "type": "string"
        }
      }
    },
    "pickerAttributes": {
      "type": "object",
      "properties": {
        "style": {
          "type": "string"
        },
        "class": {
          "type": "string"
        }
      }
    },
    "placeholder": {
      "type": "string"
    },
    "rawValue": {
      "type": "Array<string>",
      "writeback": true,
      "readOnly": true
    },
    "readonly": {
      "type": "boolean",
      "value": false
    },
    "required": {
      "type": "boolean",
      "value": false
    },
    "translations": {
      "type": "object",
      "value": {},
      "properties": {
        "filterFurther": {
          "type": "string"
        },
        "moreMatchesFound": {
          "type": "string"
        },
        "noMatchesFound": {
          "type": "string"
        },
        "oneMatchesFound": {
          "type": "string"
        },
        "required": {
          "type": "object",
          "properties": {
            "hint": {
              "type": "string"
            },
            "messageDetail": {
              "type": "string"
            },
            "messageSummary": {
              "type": "string"
            }
          }
        }
      }
    },
    "userAssistanceDensity": {
      "type": "string",
      "enumValues": [
        "compact",
        "efficient",
        "reflow"
      ],
      "value": "reflow"
    },
    "valid": {
      "type": "string",
      "writeback": true,
      "enumValues": [
        "invalidHidden",
        "invalidShown",
        "pending",
        "valid"
      ],
      "readOnly": true
    },
    "validators": {
      "type": "Array",
      "value": []
    },
    "value": {
      "type": "Array<any>",
      "writeback": true
    },
    "valueOptions": {
      "type": "Array<Object>",
      "writeback": true
    }
  },
  "methods": {
    "refresh": {},
    "validate": {},
    "reset": {},
    "showMessages": {},
    "setProperty": {},
    "getProperty": {},
    "setProperties": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "events": {
    "ojAnimateStart": {},
    "ojAnimateEnd": {}
  },
  "extension": {}
};
var __oj_combobox_one_metadata = 
{
  "properties": {
    "asyncValidators": {
      "type": "Array<Object>",
      "value": []
    },
    "converter": {
      "type": "object"
    },
    "describedBy": {
      "type": "string"
    },
    "disabled": {
      "type": "boolean",
      "value": false
    },
    "displayOptions": {
      "type": "object",
      "properties": {
        "converterHint": {
          "type": "Array<string>|string",
          "value": [
            "placeholder",
            "notewindow"
          ]
        },
        "helpInstruction": {
          "type": "Array<string>|string",
          "value": [
            "notewindow"
          ]
        },
        "messages": {
          "type": "Array<string>|string",
          "value": [
            "inline"
          ]
        },
        "validatorHint": {
          "type": "Array<string>|string",
          "value": [
            "notewindow"
          ]
        }
      }
    },
    "filterOnOpen": {
      "type": "string",
      "enumValues": [
        "none",
        "rawValue"
      ],
      "value": "none"
    },
    "help": {
      "type": "object",
      "properties": {
        "instruction": {
          "type": "string",
          "value": ""
        }
      }
    },
    "helpHints": {
      "type": "object",
      "properties": {
        "definition": {
          "type": "string",
          "value": ""
        },
        "source": {
          "type": "string",
          "value": ""
        }
      }
    },
    "labelEdge": {
      "type": "string",
      "enumValues": [
        "inside",
        "none",
        "provided"
      ]
    },
    "labelHint": {
      "type": "string",
      "value": ""
    },
    "labelledBy": {
      "type": "string"
    },
    "maximumResultCount": {
      "type": "number",
      "value": 15
    },
    "messagesCustom": {
      "type": "Array<Object>",
      "writeback": true,
      "value": []
    },
    "minLength": {
      "type": "number",
      "value": 0
    },
    "optionRenderer": {
      "type": "function"
    },
    "options": {
      "type": "Array<Object>|object"
    },
    "optionsKeys": {
      "type": "object",
      "properties": {
        "childKeys": {
          "type": "object",
          "properties": {
            "label": {
              "type": "string"
            },
            "value": {
              "type": "string"
            },
            "children": {
              "type": "string"
            },
            "childKeys": {
              "type": "object",
              "properties": {
                "label": {
                  "type": "string"
                },
                "value": {
                  "type": "string"
                },
                "children": {
                  "type": "string"
                },
                "childKeys": {
                  "type": "object"
                }
              }
            }
          }
        },
        "children": {
          "type": "string"
        },
        "label": {
          "type": "string"
        },
        "value": {
          "type": "string"
        }
      }
    },
    "pickerAttributes": {
      "type": "object",
      "properties": {
        "style": {
          "type": "string"
        },
        "class": {
          "type": "string"
        }
      }
    },
    "placeholder": {
      "type": "string"
    },
    "rawValue": {
      "type": "string",
      "writeback": true,
      "readOnly": true
    },
    "readonly": {
      "type": "boolean",
      "value": false
    },
    "required": {
      "type": "boolean",
      "value": false
    },
    "translations": {
      "type": "object",
      "value": {},
      "properties": {
        "filterFurther": {
          "type": "string"
        },
        "moreMatchesFound": {
          "type": "string"
        },
        "noMatchesFound": {
          "type": "string"
        },
        "oneMatchesFound": {
          "type": "string"
        },
        "required": {
          "type": "object",
          "properties": {
            "hint": {
              "type": "string"
            },
            "messageDetail": {
              "type": "string"
            },
            "messageSummary": {
              "type": "string"
            }
          }
        }
      }
    },
    "userAssistanceDensity": {
      "type": "string",
      "enumValues": [
        "compact",
        "efficient",
        "reflow"
      ],
      "value": "reflow"
    },
    "valid": {
      "type": "string",
      "writeback": true,
      "enumValues": [
        "invalidHidden",
        "invalidShown",
        "pending",
        "valid"
      ],
      "readOnly": true
    },
    "validators": {
      "type": "Array",
      "value": []
    },
    "value": {
      "type": "any",
      "writeback": true
    },
    "valueOption": {
      "type": "object",
      "writeback": true,
      "properties": {
        "value": {
          "type": "any"
        },
        "label": {
          "type": "string"
        }
      }
    }
  },
  "methods": {
    "refresh": {},
    "validate": {},
    "reset": {},
    "showMessages": {},
    "setProperty": {},
    "getProperty": {},
    "setProperties": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "events": {
    "ojValueUpdated": {},
    "ojAnimateStart": {},
    "ojAnimateEnd": {}
  },
  "extension": {}
};
var __oj_select_many_metadata = 
{
  "properties": {
    "describedBy": {
      "type": "string"
    },
    "disabled": {
      "type": "boolean",
      "value": false
    },
    "displayOptions": {
      "type": "object",
      "properties": {
        "converterHint": {
          "type": "Array<string>|string",
          "value": [
            "placeholder",
            "notewindow"
          ]
        },
        "helpInstruction": {
          "type": "Array<string>|string",
          "value": [
            "notewindow"
          ]
        },
        "messages": {
          "type": "Array<string>|string",
          "value": [
            "inline"
          ]
        },
        "validatorHint": {
          "type": "Array<string>|string",
          "value": [
            "notewindow"
          ]
        }
      }
    },
    "help": {
      "type": "object",
      "properties": {
        "instruction": {
          "type": "string",
          "value": ""
        }
      }
    },
    "helpHints": {
      "type": "object",
      "properties": {
        "definition": {
          "type": "string",
          "value": ""
        },
        "source": {
          "type": "string",
          "value": ""
        }
      }
    },
    "labelEdge": {
      "type": "string",
      "enumValues": [
        "inside",
        "none",
        "provided"
      ]
    },
    "labelHint": {
      "type": "string",
      "value": ""
    },
    "labelledBy": {
      "type": "string"
    },
    "maximumResultCount": {
      "type": "number",
      "value": 15
    },
    "messagesCustom": {
      "type": "Array<Object>",
      "writeback": true,
      "value": []
    },
    "minimumResultsForSearch": {
      "type": "number",
      "value": 15
    },
    "optionRenderer": {
      "type": "function"
    },
    "options": {
      "type": "Array<Object>|object"
    },
    "optionsKeys": {
      "type": "object",
      "properties": {
        "childKeys": {
          "type": "object",
          "properties": {
            "label": {
              "type": "string"
            },
            "value": {
              "type": "string"
            },
            "children": {
              "type": "string"
            },
            "childKeys": {
              "type": "object"
            }
          }
        },
        "children": {
          "type": "string"
        },
        "label": {
          "type": "string"
        },
        "value": {
          "type": "string"
        }
      }
    },
    "pickerAttributes": {
      "type": "object",
      "properties": {
        "style": {
          "type": "string"
        },
        "class": {
          "type": "string"
        }
      }
    },
    "placeholder": {
      "type": "string"
    },
    "readonly": {
      "type": "boolean",
      "value": false
    },
    "renderMode": {
      "type": "string",
      "enumValues": [
        "jet",
        "native"
      ]
    },
    "required": {
      "type": "boolean",
      "value": false
    },
    "translations": {
      "type": "object",
      "value": {},
      "properties": {
        "filterFurther": {
          "type": "string"
        },
        "moreMatchesFound": {
          "type": "string"
        },
        "noMatchesFound": {
          "type": "string"
        },
        "oneMatchesFound": {
          "type": "string"
        },
        "required": {
          "type": "object",
          "properties": {
            "hint": {
              "type": "string"
            },
            "messageDetail": {
              "type": "string"
            },
            "messageSummary": {
              "type": "string"
            }
          }
        },
        "searchField": {
          "type": "string"
        }
      }
    },
    "userAssistanceDensity": {
      "type": "string",
      "enumValues": [
        "compact",
        "efficient",
        "reflow"
      ],
      "value": "reflow"
    },
    "valid": {
      "type": "string",
      "writeback": true,
      "enumValues": [
        "invalidHidden",
        "invalidShown",
        "pending",
        "valid"
      ],
      "readOnly": true
    },
    "value": {
      "type": "Array<any>",
      "writeback": true
    },
    "valueOptions": {
      "type": "Array<Object>",
      "writeback": true
    }
  },
  "methods": {
    "refresh": {},
    "validate": {},
    "reset": {},
    "showMessages": {},
    "setProperty": {},
    "getProperty": {},
    "setProperties": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "events": {
    "ojAnimateStart": {},
    "ojAnimateEnd": {}
  },
  "extension": {}
};
var __oj_select_one_metadata = 
{
  "properties": {
    "describedBy": {
      "type": "string"
    },
    "disabled": {
      "type": "boolean",
      "value": false
    },
    "displayOptions": {
      "type": "object",
      "properties": {
        "converterHint": {
          "type": "Array<string>|string",
          "value": [
            "placeholder",
            "notewindow"
          ]
        },
        "helpInstruction": {
          "type": "Array<string>|string",
          "value": [
            "notewindow"
          ]
        },
        "messages": {
          "type": "Array<string>|string",
          "value": [
            "inline"
          ]
        },
        "validatorHint": {
          "type": "Array<string>|string",
          "value": [
            "notewindow"
          ]
        }
      }
    },
    "help": {
      "type": "object",
      "properties": {
        "instruction": {
          "type": "string",
          "value": ""
        }
      }
    },
    "helpHints": {
      "type": "object",
      "properties": {
        "definition": {
          "type": "string",
          "value": ""
        },
        "source": {
          "type": "string",
          "value": ""
        }
      }
    },
    "labelEdge": {
      "type": "string",
      "enumValues": [
        "inside",
        "none",
        "provided"
      ]
    },
    "labelHint": {
      "type": "string",
      "value": ""
    },
    "labelledBy": {
      "type": "string"
    },
    "maximumResultCount": {
      "type": "number",
      "value": 15
    },
    "messagesCustom": {
      "type": "Array<Object>",
      "writeback": true,
      "value": []
    },
    "minimumResultsForSearch": {
      "type": "number",
      "value": 15
    },
    "optionRenderer": {
      "type": "function"
    },
    "options": {
      "type": "Array<Object>|object"
    },
    "optionsKeys": {
      "type": "object",
      "properties": {
        "childKeys": {
          "type": "object",
          "properties": {
            "label": {
              "type": "string"
            },
            "value": {
              "type": "string"
            },
            "children": {
              "type": "string"
            },
            "childKeys": {
              "type": "object"
            }
          }
        },
        "children": {
          "type": "string"
        },
        "label": {
          "type": "string"
        },
        "value": {
          "type": "string"
        }
      }
    },
    "pickerAttributes": {
      "type": "object",
      "properties": {
        "style": {
          "type": "string"
        },
        "class": {
          "type": "string"
        }
      }
    },
    "placeholder": {
      "type": "string"
    },
    "readonly": {
      "type": "boolean",
      "value": false
    },
    "renderMode": {
      "type": "string",
      "enumValues": [
        "jet",
        "native"
      ]
    },
    "required": {
      "type": "boolean",
      "value": false
    },
    "translations": {
      "type": "object",
      "value": {},
      "properties": {
        "filterFurther": {
          "type": "string"
        },
        "moreMatchesFound": {
          "type": "string"
        },
        "noMatchesFound": {
          "type": "string"
        },
        "oneMatchesFound": {
          "type": "string"
        },
        "required": {
          "type": "object",
          "properties": {
            "hint": {
              "type": "string"
            },
            "messageDetail": {
              "type": "string"
            },
            "messageSummary": {
              "type": "string"
            }
          }
        },
        "searchField": {
          "type": "string"
        }
      }
    },
    "userAssistanceDensity": {
      "type": "string",
      "enumValues": [
        "compact",
        "efficient",
        "reflow"
      ],
      "value": "reflow"
    },
    "valid": {
      "type": "string",
      "writeback": true,
      "enumValues": [
        "invalidHidden",
        "invalidShown",
        "pending",
        "valid"
      ],
      "readOnly": true
    },
    "value": {
      "type": "any",
      "writeback": true
    },
    "valueOption": {
      "type": "object",
      "writeback": true,
      "properties": {
        "value": {
          "type": "any"
        },
        "label": {
          "type": "string"
        }
      }
    }
  },
  "methods": {
    "refresh": {},
    "validate": {},
    "reset": {},
    "showMessages": {},
    "setProperty": {},
    "getProperty": {},
    "setProperties": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "events": {
    "ojAnimateStart": {},
    "ojAnimateEnd": {}
  },
  "extension": {}
};


/**
 * @preserve Copyright 2012 Igor Vaynberg
 *
 * This software is licensed under the Apache License, Version 2.0 (the "Apache License") or the GNU
 * General Public License version 2 (the "GPL License"). You may choose either license to govern your
 * use of this software only upon the condition that you accept all of the terms of either the Apache
 * License or the GPL License.
 *
 * You may obtain a copy of the Apache License and the GPL License at:
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 * http://www.gnu.org/licenses/gpl-2.0.html
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * Apache License or the GPL Licesnse is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the Apache License and the GPL License for
 * the specific language governing permissions and limitations under the Apache License and the GPL License.
 */

/* global Promise:false, Symbol:false, TimerUtils:false, Context:false, ListDataProviderView:false, TreeDataProviderView:false */

/**
 * @private
 */
var _ComboUtils = {
  // native renderMode: marker class for generated options list
  GENERATED_OPTIONS_SELECTOR: 'oj-select-options-generated',
  KEY: {
    TAB: 9,
    ENTER: 13,
    ESC: 27,
    SPACE: 32,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    SHIFT: 16,
    CTRL: 17,
    ALT: 18,
    PAGE_UP: 33,
    PAGE_DOWN: 34,
    HOME: 36,
    END: 35,
    BACKSPACE: 8,
    DELETE: 46,
    isControl: function isControl(e) {
      var k = e.which;

      switch (k) {
        case _ComboUtils.KEY.SHIFT:
        case _ComboUtils.KEY.CTRL:
        case _ComboUtils.KEY.ALT:
          return true;

        default:
          if (e.metaKey) {
            return true;
          }

          return false;
      }
    },
    isFunctionKey: function isFunctionKey(k) {
      var key = k.which ? k.which : k;
      return key >= 112 && key <= 123;
    }
  },

  /*
     * The default fetch size from the data provider
     */
  DEFAULT_FETCH_SIZE: 15,

  /*
     * The default fetch size to fetch all the data from the data provider
     */
  DEFAULT_FETCH_ALL_SIZE: -1,

  /*
     * The fetch size from the data provider for local filtering
     */
  FILTERING_FETCH_SIZE_MIN: 100,
  FILTERING_FETCH_SIZE_MAX: 500,

  /*
     * The fetch size factor based on maximumResultCount for local filtering
     */
  FILTERING_FETCH_SIZE_MRC_TIMES: 7,

  /*
     * The default delay in milliseconds between when a keystroke occurs
     * and when a search is performed to get the filtered options.
     */
  DEFAULT_QUERY_DELAY: 70,
  ValueChangeTriggerTypes: {
    ENTER_PRESSED: 'enter_pressed',
    OPTION_SELECTED: 'option_selected',
    BLUR: 'blur',
    SEARCH_ICON_CLICKED: 'search_icon_clicked'
  },
  lastMousePosition: {
    x: 0,
    y: 0
  },
  nextUid: function () {
    var counter = 1;
    return function () {
      var ret = counter;
      counter += 1;
      return ret;
    };
  }(),
  // TODO:
  scrollBarDimensions: null,
  // _ComboUtils

  /*
     * 4-10 times faster .each replacement
     * it overrides jQuery context of element on each iteration
     */
  each2: function each2(list, c) {
    var j = $.isFunction(list[0]) ? $(list[0]()) : $(list[0]);
    var i = -1;
    var l = list.length;

    while ( // eslint-disable-line
    ++i < l // eslint-disable-line
    && (j.context = j[0] = $.isFunction(list[0]) ? list[i]() : list[i]) // eslint-disable-line
    && c.call(j[0], i, j) !== false // i=index, j=jQuery object
    ) {} // eslint-disable-line


    return list;
  },
  // _ComboUtils
  measureScrollbar: function measureScrollbar() {
    var $template = $("<div class='oj-listbox-measure-scrollbar'></div>");
    $template.appendTo('body'); // @HTMLUpdateOK

    var dim = {
      width: $template.width() - $template[0].clientWidth,
      height: $template.height() - $template[0].clientHeight
    };
    $template.remove();
    return dim;
  },
  // _ComboUtils

  /*
     * Splits the string into an array of values, trimming each value.
     * An empty array is returned for nulls or empty
     */
  splitVal: function splitVal(string, separator) {
    var val;
    var i;
    var l;

    if (string === null || string.length < 1) {
      return [];
    }

    val = string.split(separator);

    for (i = 0, l = val.length; i < l; i++) {
      val[i] = $.trim(val[i]);
    }

    return val;
  },
  // _ComboUtils
  getSideBorderPadding: function getSideBorderPadding(element) {
    return element.outerWidth(false) - element.width();
  },
  // _ComboUtils
  installKeyUpChangeEvent: function installKeyUpChangeEvent(element) {
    var key = 'keyup-change-value';
    element.on('keydown', function () {
      if ($.data(element, key) === undefined) {
        $.data(element, key, element.val());
      }
    });
    element.on('keyup', function (e) {
      if (e.which === _ComboUtils.KEY.ENTER) {
        //  - select and combobox stop keyboard event propegation
        e.preventDefault();
        return;
      }

      var val = $.data(element, key);

      if (val !== undefined && element.val() !== val) {
        $.removeData(element, key);
        element.trigger('keyup-change');
      }
    });
  },
  // _ComboUtils
  getSearchText: function getSearchText(event) {
    var searchText; //  - start typing 1 letter on select box, but 2 letters displayed on searchbox
    // In case of chrome/IE, typed key is added on search element as we move focus from select element to search
    // But this is not happening on firefox and hence we need to set it as part of select element's event
    // and kill the event to avoid duplicate charecters on search field later in IE/chrome.
    // Dropdown popup will be opened on up/down/left/right arrows so excluding those as search text.

    var keycode = event.which || event.keyCode;

    if (event && event.type === 'keydown' && (keycode === 32 || // spacebar
    keycode > 47 && keycode < 58 || // number keys
    keycode > 64 && keycode < 91 || // letter keys
    keycode > 95 && keycode < 112 || // numpad keys
    keycode > 185 && keycode < 193 || // ;=,-./` (in order)
    keycode > 218 && keycode < 223)) {
      // [\]' (in order)
      // JET-30104 - typing ">" in oj-select-one filter, causes a different character to appear
      // KeyboardEvent.keyCode is deprecated in favor of KeyboardEvent.key & KeyboardEvent.code
      // For our use case, KeyboardEvent.key property returns the value of the key pressed by the user,
      // taking into consideration the state of modifier keys such as Shift as well as the keyboard locale and layout
      // Even though it has cross-browser compatibility, it is better to have a fallback mechanism.
      if (event.key != null) {
        searchText = event.key;
      } else {
        // fallback to using keyCode
        // Numpad keys return different keyCodes for the numbers
        // String.fromCharCode would return 'a' for '1' and so forth
        // Need to convert those keyCodes to regular number keyCodes
        if (keycode >= 96 && keycode <= 105) {
          keycode -= 48;
        }

        searchText = String.fromCharCode(keycode); // keydown event always return uppercase letter

        if (!event.shiftKey) {
          searchText = searchText.toLowerCase();
        }
      } //  - select and combobox stop keyboard event propegation


      event.preventDefault();
    }

    return searchText;
  },

  /**
   * Escapes the special characters from the expression
   *
   * @param {string} exp
   * @return {string} The escaped and valid regexp string literal
   *
   * @memberof! _ComboUtils
   * @static
   * @ignore
   */
  escapeRegExp: function escapeRegExp(exp) {
    return exp.replace(/[.*+\-?^${}()|[\]\\]/g, '\\$&');
  },
  // _ComboUtils

  /*
     * filters mouse events so an event is fired only if the mouse moved.
     *
     * filters out mouse events that occur when mouse is stationary but
     * the elements under the pointer are scrolled.
     */
  installFilteredMouseMove: function installFilteredMouseMove(element) {
    element.on('mousemove', function (e) {
      var lastpos = _ComboUtils.lastMousePosition;

      if (lastpos === undefined || lastpos.x !== e.pageX || lastpos.y !== e.pageY) {
        $(e.target).trigger('mousemove-filtered', e);
        _ComboUtils.lastMousePosition.x = e.pageX;
        _ComboUtils.lastMousePosition.y = e.pageY;
      }
    });
  },
  // _ComboUtils
  thunk: function thunk(formula) {
    var evaluated = false;
    var value;
    return function () {
      if (evaluated === false) {
        value = formula();
        evaluated = true;
      }

      return value;
    };
  },
  // _ComboUtils
  _focus: function _focus(widget, $el) {
    if ($el[0] === document.activeElement) {
      return;
    } // add busy state


    var resolveBusyState = _ComboUtils._addBusyState(widget.container, 'setting focus');
    /* set the focus in a timeout - that way the focus is set after the processing
         of the current event has finished - which seems like the only reliable way
         to set focus */


    var timer = TimerUtils.getTimer(40);
    timer.getPromise().then(function () {
      var el = $el[0];
      var pos = $el.val().length;
      var range;
      $el.focus();
      /* make sure el received focus so we do not error out when trying to manipulate the caret.
             sometimes modals or others listeners may steal it after its set */

      if ($el.is(':visible') && el === document.activeElement) {
        /* after the focus is set move the caret to the end, necessary when we val()
               just before setting focus */
        if (el.setSelectionRange) {
          el.setSelectionRange(pos, pos);
        } else if (el.createTextRange) {
          range = el.createTextRange();
          range.collapse(false);
          range.select();
        }
      }

      resolveBusyState(); // Set a 40 timeout. In voiceover mode, previous partial value was read. See 
      // This happens on ios Safari only, not Chrome. Setting a 40 timeout fixes the issue
      // on Safari in voiceover.
    });
  },
  // _ComboUtils
  getCursorInfo: function getCursorInfo(_el) {
    var el = $(_el)[0];
    var offset = 0;
    var length = 0;

    if ('selectionStart' in el) {
      offset = el.selectionStart;
      length = el.selectionEnd - offset;
    } else if ('selection' in document) {
      el.focus(); // Fixed???

      var sel = document.selection.createRange();
      length = document.selection.createRange().text.length;
      sel.moveStart('character', -el.value.length);
      offset = sel.text.length - length;
    }

    return {
      offset: offset,
      length: length
    };
  },
  // _ComboUtils
  killEvent: function killEvent(event) {
    event.preventDefault();
  },
  // _ComboUtils

  /*
     * Produces a query function that works with a local array
     */
  local: function local(options, optKeys) {
    var data = options; // data elements

    var dataText;
    var tmp; // function used to retrieve the text portion of a data item that is matched against the search

    var text = function text(item) {
      return '' + item.label;
    };

    if ($.isArray(data)) {
      tmp = data;
      data = {
        results: tmp
      };
    }

    if ($.isFunction(data) === false) {
      tmp = data;

      data = function data() {
        return tmp;
      };
    }

    var dataItem = data(); // select with no options

    if (dataItem && dataItem.text) {
      text = dataItem.text; // if text is not a function we assume it to be a key name

      if (!$.isFunction(text)) {
        // we need to store this in a separate variable because in the next step data gets reset
        // and data.text is no longer available
        dataText = dataItem.text;

        text = function text(item) {
          return item[dataText];
        };
      }
    }

    return function (query) {
      var t = query.term;
      var filtered = {
        results: []
      }; // if optionsKeys is set, we need to do the key mapping, don't return

      if (t === '' && !optKeys) {
        query.callback(data());
        return;
      }

      if (data()) {
        _ComboUtils.each2($(data().results), function (i, datum) {
          _ComboUtils._processData(query, datum, filtered.results, optKeys, true, text);
        });
      }

      query.callback(filtered);
    };
  },
  // native renderMode
  createOptionTag: function createOptionTag(depth, value, label, formatFunc) {
    var node = $('<option>');
    node.addClass('oj-listbox-result oj-listbox-result-selectable oj-listbox-results-depth-' + depth); // option label

    node.attr('role', 'option');
    node.attr('id', 'oj-listbox-result-label-' + _ComboUtils.nextUid());
    node.text(formatFunc(label));
    node.attr('value', value);
    return node;
  },
  // native renderMode
  createOptgroupTag: function createOptgroupTag(container, label, formatFunc) {
    var node = $('<optgroup>');
    node.addClass('oj-listbox-results-sub');
    node.attr('label', formatFunc(label));
    container.addClass('oj-listbox-result-with-children');
    return node;
  },
  // native renderMode
  // This method turns a list of <ul>s and <li>s into <optgroup>s and <option>s
  listPopulateResults: function listPopulateResults(_container, _list, formatFunc) {
    var populate = function populate(container, list, depth) {
      var node;
      var li;
      var label;
      var ul;
      list.each(function () {
        li = $(this);

        if (li.is('li')) {
          // process <li> with children
          if (li.children('ul').length > 0) {
            // get the <li> text only dont include its descendants
            label = li.contents().filter(function () {
              return this.nodeType !== 1 || this.tagName.toLowerCase() !== 'ul';
            }).text();
            node = _ComboUtils.createOptgroupTag(container, label, formatFunc);
            ul = li.children('ul');
            populate(node, ul.children(), depth + 1);
          } else {
            // process <li> without children
            node = _ComboUtils.createOptionTag(depth, li.attr('oj-data-value'), li.text(), formatFunc);
          }

          node.appendTo(container); // @HTMLUpdateOK
        }
      });
    };

    populate(_container, _list, 0);
  },
  // native renderMode
  // This method turns <oj-optgroup>s and <oj-option>s into <optgroup>s and <option>s
  ojOptionPopulateResults: function ojOptionPopulateResults(_container, _ojOptions, formatFunc) {
    var populate = function populate(container, ojOptions, depth) {
      var node;
      var ojOption;
      var label;
      ojOptions.each(function () {
        ojOption = $(this);

        if (ojOption.is('oj-option')) {
          label = ojOption.text() || ojOption.attr('label');
          node = _ComboUtils.createOptionTag(depth, ojOption.prop('value'), label, formatFunc);
        } else if (ojOption.is('oj-optgroup')) {
          label = ojOption.text() || ojOption.attr('label');
          node = _ComboUtils.createOptgroupTag(container, label, formatFunc);
          populate(node, ojOption.children(), depth + 1);
        } else if (ojOption.is('option')) {
          // the option element created for the placeholder in native mode
          node = ojOption;
        }

        node.appendTo(container); // @HTMLUpdateOK
      });
    };

    populate(_container, _ojOptions, 0);
  },
  // native renderMode
  lookupOptionKeys: function lookupOptionKeys(result, optionsKeys, _key) {
    var key = optionsKeys[_key] || _key;
    return result[key];
  },
  // native renderMode
  // This method turns a JSON object into <optgroup>s and <option>s
  arrayPopulateResults: function arrayPopulateResults(_container, _arrlist, formatFunc, _optionsKeys) {
    var populate = function populate(container, arrlist, depth, optionsKeys) {
      var item;
      var node;
      var children;
      var label;
      var value;

      for (var i = 0, l = arrlist.length; i < l; i++) {
        item = arrlist[i]; // process children

        children = _ComboUtils.lookupOptionKeys(item, optionsKeys, 'children');
        label = _ComboUtils.lookupOptionKeys(item, optionsKeys, 'label');

        if (children && children.length > 0) {
          node = _ComboUtils.createOptgroupTag(container, label, formatFunc);
          populate(node, children, depth + 1, optionsKeys.childKeys || {});
        } else {
          // without children
          value = _ComboUtils.lookupOptionKeys(item, optionsKeys, 'value');
          node = _ComboUtils.createOptionTag(depth, value, label, formatFunc);
        }

        node.appendTo(container); // @HTMLUpdateOK
      }
    };

    populate(_container, _arrlist, 0, _optionsKeys || {});
  },
  // native renderMode
  cleanupResults: function cleanupResults(container) {
    container.children().not('oj-option, oj-optgroup').remove();
    container.removeClass('oj-listbox-result-with-children');
  },
  // _ComboUtils
  _addBusyState: function _addBusyState(element, description) {
    var desc = "The component identified by '" + element.attr('id') + "' " + description;
    var busyStateOptions = {
      description: desc
    };
    var busyContext = Context.getContext(element[0]).getBusyContext();
    return busyContext.addBusyState(busyStateOptions);
  },
  _clearBusyState: function _clearBusyState(resolveFunc) {
    if (resolveFunc) {
      resolveFunc();
    }
  },
  isDataProvider: function isDataProvider(data) {
    return data && oj.DataProviderFeatureChecker ? oj.DataProviderFeatureChecker.isDataProvider(data) : false;
  },
  isTreeDataProvider: function isTreeDataProvider(data) {
    return data && oj.DataProviderFeatureChecker ? oj.DataProviderFeatureChecker.isTreeDataProvider(data) : false;
  },
  getDataProvider: function getDataProvider(options) {
    if (options) {
      var dataProvider = options._dataProvider || options.options;

      if (_ComboUtils.isDataProvider(dataProvider)) {
        return dataProvider;
      }
    }

    return null;
  },
  clearDataProviderWrapper: function clearDataProviderWrapper(widget) {
    // eslint-disable-next-line no-param-reassign
    widget.options._dataProvider = null;
  },
  //  - need to be able to specify the initial value of select components bound to dprv
  // traversal using depth first search
  // return an oj.Option object if found otherwise return null
  _findOption: function _findOption(ojOption, value) {
    if (oj.Object.compareValues(value, ojOption.value)) {
      return ojOption;
    } else if (ojOption.children) {
      var children = ojOption.children;
      var result;

      for (var i = 0; i < children.length; i++) {
        result = _ComboUtils._findOption(children[i], value);

        if (result) {
          return result;
        }
      }
    } // not found


    return null;
  },
  findOption: function findOption(arOpts, value) {
    //  - create selectone with a valueoption and a value of object datatype doesn't work
    // need to check if arOpts is an array
    if (Array.isArray(arOpts)) {
      for (var i = 0, len = arOpts.length; i < len; i++) {
        var result = _ComboUtils._findOption(arOpts[i], value);

        if (result) {
          return result;
        }
      } // not found


      return null;
    }

    return _ComboUtils._findOption(arOpts, value);
  },
  findOptions: function findOptions(ojOptgroup, values) {
    var ojOptionArr = [];

    for (var i = 0; i < values.length; i++) {
      var option = _ComboUtils.findOption(ojOptgroup, values[i]);

      if (option) {
        ojOptionArr.push(option);
      }
    }

    return ojOptionArr;
  },
  //  - oj.tests.input.combobox.testcombobox display value mismatch automation failure
  findOptionFromResult: function findOptionFromResult(context, val, data) {
    var queryResult = _ComboUtils.getLastQueryResult(context);

    var match;

    if (queryResult) {
      match = _ComboUtils.findOption(queryResult, val);
    } // for multiChoice look for data from selected options when no match is found


    if (context.ojContext.multiple && !match) {
      match = _ComboUtils.getSelectedOptionData(context, val);
    }

    if (match) {
      var optionData = {
        value: val,
        label: match.label
      };

      if (match.data && match.metadata) {
        optionData.data = match.data;
        optionData.metadata = match.metadata;
      }

      return optionData;
    }

    return data;
  },
  // merge value and valueOption, value wins if both are specified
  // return true if the value is specified and it's not contained in valueOptions
  mergeValueAndValueOptions: function mergeValueAndValueOptions(ojContext) {
    var value = ojContext.options.value;
    var resolveLater = false; // multiple

    if (ojContext.multiple) {
      var valueOptions = ojContext.options.valueOptions; // value specified

      if (value && value.length > 0) {
        // both value and valueOptions specified, find the option for the value
        var ojoptionArr;

        if (valueOptions && valueOptions.length) {
          ojoptionArr = _ComboUtils.findOptions(valueOptions, value);
        } // update valueOptions if more than one


        if (!ojoptionArr || ojoptionArr.length !== valueOptions.length) {
          // need to find out the label and setValueOptions later
          resolveLater = true;
        }
      } else if (valueOptions) {
        // value not specified
        _ComboUtils.syncValueWithValueOptions(ojContext, valueOptions, value, null);
      }
    } else {
      // single
      var valueOption = ojContext.options.valueOption; // value specified

      if (value !== null && value !== undefined) {
        // both value and valueOption specified, find the option for the value
        var ojoption;

        if (valueOption) {
          ojoption = _ComboUtils.findOption(valueOption, value);
        } // update valueOption


        if (!ojoption) {
          // need to find out the label and setValueOption later
          resolveLater = true;
        }
      } else if (valueOption) {
        // value not specified
        _ComboUtils.syncValueWithValueOption(ojContext, valueOption, value, null);
      }
    }

    return resolveLater;
  },
  // single selection: keep value in sync with valueOption
  // param nativeRender can be either null or boolean
  // null: don't update display label
  // true: update display label in native mode
  // false: update display label in jet mode
  syncValueWithValueOption: function syncValueWithValueOption(ojContext, valueOption, value, nativeRender) {
    var newVal;
    var updateLabel = true; //  - resetting value when value-option and placeholder are set throws exception

    if (_ComboUtils.isValueOptionsForPlaceholder(false, valueOption)) {
      if (_ComboUtils.isValueForPlaceholder(false, value)) {
        newVal = value;
        updateLabel = false;
      } else {
        newVal = null;
      }
    } else {
      newVal = valueOption ? valueOption.value : null;
    }

    if (oj.Object.compareValues(newVal, value)) {
      //  - lov does not show the value-option label when it's updated later
      // if the value is the same, we still need to update display label
      if (nativeRender === true) {
        var selElem = ojContext.element[0];
        $(selElem.options[selElem.selectedIndex]).text(_ComboUtils.getLabel(valueOption));
      } else if (nativeRender === false) {
        var context = ojContext.select || ojContext.combobox;

        if (context && updateLabel) {
          context._updateSelection(valueOption);
        }
      }
    } else {
      _ComboUtils._forceSetValue(ojContext, newVal);
    }
  },
  // multiple selection: keep value in sync with valueOptions
  // param nativeRender can be either null or boolean
  // null: don't update display label
  // true: update display label in native mode
  // false: update display label in jet mode
  syncValueWithValueOptions: function syncValueWithValueOptions(ojContext, valueOptions, value, nativeRender) {
    var newVal;
    var updateLabel = true;

    if (_ComboUtils.isValueOptionsForPlaceholder(true, valueOptions)) {
      if (_ComboUtils.isValueForPlaceholder(true, value)) {
        newVal = value;
        updateLabel = false;
      } else {
        newVal = _ComboUtils.getValueForPlaceholder(true);
      }

      if (!oj.Object.compareValues(newVal, value)) {
        _ComboUtils._forceSetValue(ojContext, newVal);
      }
    } else if (valueOptions) {
      newVal = [];

      for (var i = 0; i < valueOptions.length; i++) {
        newVal.push(valueOptions[i].value);
      }

      if (oj.Object.compareValues(newVal, value)) {
        //  - lov does not show the value-option label when it's updated later
        // if the value is the same, we still need to update display label
        if (nativeRender === true) {
          var s = 0;
          ojContext.element.find('option').each(function () {
            if (this.selected) {
              var label = _ComboUtils.getLabel(valueOptions[s]); // eslint-disable-next-line eqeqeq


              if (this.text != label) {
                $(this).text(label);
              }

              s += 1;
            }
          });
        } else if (nativeRender === false) {
          var context = ojContext.select || ojContext.combobox;

          if (context && updateLabel) {
            context._updateSelection(valueOptions);
          }
        }
      } else {
        _ComboUtils._forceSetValue(ojContext, newVal);
      }
    }
  },
  // _ComboUtils
  // Internally set the value option, skipping validation and the check for different value
  _forceSetValue: function _forceSetValue(_ojContext, newVal) {
    var ojContext = _ojContext;
    var flags = {
      doValueChangeCheck: false,
      _context: {
        internalSet: true,
        writeback: true
      }
    }; // FIX  - VALUE UNCHANGED IN DISABLED SELECT WHEN CHANGING BOUND VALUEOPTION
    // _SetValue always performs validation, which calls _CanSetValue, which returns false if
    // the component is disabled, thereby disallowing the set.  We override _CanSetValue on the
    // component in order to force it to return true in this case.

    ojContext.forceCanSetValue = true;

    try {
      ojContext._SetValue(newVal, null, flags);
    } finally {
      delete ojContext.forceCanSetValue;
    }
  },
  // whether placeholder is specified
  isPlaceholderSpecified: function isPlaceholderSpecified(options) {
    return typeof options.placeholder === 'string';
  },
  //  - resetting value when value-option and placeholder are set throws exception
  getFixupValueOptionsForPlaceholder: function getFixupValueOptionsForPlaceholder(multiple) {
    return multiple ? [] : {
      value: null,
      label: null
    };
  },
  // if placeholder is specified, in addition to the normalized valueOptions format
  // (multiple: [], single: {value: null, label: null}, the valueOption(s) recognized in
  // this method also can be used in init or set
  // multiple: null, undefiend and []
  // single: null, undefined, {}, {value:null} and {value: null, label: null}
  isValueOptionsForPlaceholder: function isValueOptionsForPlaceholder(multiple, valOpts) {
    return valOpts == null || !multiple && valOpts.value == null || oj.Object.compareValues(valOpts, _ComboUtils.getFixupValueOptionsForPlaceholder(multiple));
  },
  // return normalized valueOption(s) if placeholder is selected
  // otherwise return @parm valOpts
  getValueOptionsForPlaceholder: function getValueOptionsForPlaceholder(ojContext, valOpts) {
    var multiple = ojContext.multiple;

    if (ojContext._IsCustomElement() && _ComboUtils.isPlaceholderSpecified(ojContext.options) && _ComboUtils.isValueOptionsForPlaceholder(multiple, valOpts)) {
      // eslint-disable-next-line no-param-reassign
      valOpts = _ComboUtils.getFixupValueOptionsForPlaceholder(multiple);
    }

    return valOpts;
  },
  getValueForPlaceholder: function getValueForPlaceholder(multiple) {
    return multiple ? [] : '';
  },
  isValueForPlaceholder: function isValueForPlaceholder(multiple, value) {
    return value == null || oj.Object.compareValues(value, _ComboUtils.getValueForPlaceholder(multiple));
  },
  //  - need to be able to specify the initial value of select components bound to dprv
  setValueOptions: function setValueOptions(ojContext, valueOptions) {
    var context = {
      internalSet: true,
      changed: true,
      writeback: true
    };

    var opts = _ComboUtils.getOpts(ojContext);

    var isDataProvider = opts ? _ComboUtils.isDataProvider(opts.options) : false;
    var newValueOptions;

    if (ojContext.multiple) {
      var valueOptionsData = [];
      var valueOptionsMetadata = [];

      if (valueOptions && valueOptions.length) {
        newValueOptions = [];

        for (var i = 0; i < valueOptions.length; i++) {
          newValueOptions.push({
            value: valueOptions[i].value,
            label: valueOptions[i].label
          });

          if (isDataProvider) {
            valueOptionsData.push(valueOptions[i].data);
            valueOptionsMetadata.push(valueOptions[i].metadata);
          }
        }
      } else {
        newValueOptions = valueOptions;
      } // set the 'valueOptions' data and metadata in the context


      context = _ComboUtils.getContextWithExtraData(context, opts, valueOptionsData, valueOptionsMetadata);
      ojContext.option('valueOptions', newValueOptions, {
        _context: context
      }); //  - placeholder is not displayed after removing selections from select many
      // update internal valueOptions

      if (opts) {
        opts.valueOptions = newValueOptions;
      }
    } else {
      var valopt = valueOptions;

      if (Array.isArray(valueOptions)) {
        valopt = valueOptions[0];
      } // set the 'valueOption' data and metadata in the context


      if (valopt) {
        context = _ComboUtils.getContextWithExtraData(context, opts, valopt.data, valopt.metadata);
      } //  - resetting value when value-option and placeholder are set throws exception


      if (valopt && !_ComboUtils.isValueOptionsForPlaceholder(ojContext.multiple, valopt)) {
        newValueOptions = {
          value: valopt.value,
          label: valopt.label
        };
        ojContext.option('valueOption', {
          value: valopt.value,
          label: valopt.label
        }, {
          _context: context
        });
      } else {
        newValueOptions = valopt;
      }

      ojContext.option('valueOption', newValueOptions, {
        _context: context
      }); //  - placeholder is not displayed after removing selections from select many
      // update internal valueOption

      if (opts) {
        opts.valueOption = newValueOptions;
      }
    }
  },
  // update display label(s) and valueOption(s) after value was set
  updateValueOptions: function updateValueOptions(context) {
    //  - qunit: failure across browsers in select tests
    if (!context) {
      return;
    }

    var element = context.datalist ? context.datalist : context.opts.element;
    context.opts.initSelection.call(null, element, function (_selected) {
      var multiple = context.ojContext.multiple;
      var selected = _selected; // in combobox, values may be new entries

      if (selected == null && context._classNm === 'oj-combobox') {
        var value = context.ojContext.options.value;

        if (multiple) {
          selected = [];

          for (var i = 0; i < value.length; i++) {
            selected.push(context.opts.manageNewEntry(value[i]));
          }
        } else {
          selected = context.opts.manageNewEntry(value);
        }
      }

      if (selected) {
        context.setValOpts(selected);

        if (multiple) {
          context._updateSelection(selected);
        } else {
          context._updateSelectedOption(selected);
        }
      }
    });
  },

  /*  - need to be able to specify the initial value of select components bound to dprv
     * If both dataProvider and valueOption[s] are specified, use valueOption[s[ for display values.
     * If valueOption[s] is not specified or a selected value is missing then we will fetch the real data
     * from the dataProvider like before.
     * return true if valueOption[s] is applied, false otherwise
     */
  applyValueOptions: function applyValueOptions(context, options) {
    if (context && !context.ojContext._resolveValueOptionsLater && (context._classNm === 'oj-combobox' || context._classNm === 'oj-select')) {
      var isMultiple = context.ojContext.multiple;
      var valueOptions = isMultiple ? options.valueOptions : options.valueOption; //  - resetting value when value-option and placeholder are set throws exception
      //  - placeholder is not displayed after removing selections from select many

      if (_ComboUtils.isValueOptionsForPlaceholder(isMultiple, valueOptions)) {
        return false;
      }

      if (valueOptions) {
        context._updateSelection(valueOptions);

        return true;
      }
    }

    return false;
  },
  isValueChanged: function isValueChanged(widget) {
    return widget._valueHasChanged;
  },
  setValueChanged: function setValueChanged(widget, val) {
    // eslint-disable-next-line no-param-reassign
    widget._valueHasChanged = val;
  },
  // check if the component is in invalid state due to component error messages
  // and not due to custom error messages defined via messagesCustom attribute.
  hasInvalidComponentMessages: function hasInvalidComponentMessages(context) {
    return !context.isValid() && context._hasInvalidComponentMessagesShowing();
  },

  /*
     * If dataProvider is used,
     * wrap a ListViewDataProviderView or TreeViewDataProviderView around it
     * and save the wrapper
     */
  wrapDataProviderIfNeeded: function wrapDataProviderIfNeeded(widget, opts) {
    var wOptions = widget.options;
    var dataProvider = wOptions.options;

    if (_ComboUtils.isDataProvider(dataProvider)) {
      var wrapper;
      var optionsKeys = wOptions.optionsKeys || {};

      var isTree = _ComboUtils.isTreeDataProvider(dataProvider); // Wrap the data provider in a TreeDataProviderView or ListDataProviderView


      if (isTree && !(dataProvider instanceof oj.TreeDataProviderView) || !isTree && !(dataProvider instanceof oj.ListDataProviderView)) {
        var mapFields = function mapFields(item) {
          var data = item.data;
          var mappedItem = {};
          mappedItem.data = {}; // copy all the fields

          var keys = Object.keys(data);

          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var value = data[key];
            mappedItem.data[key] = value;
          } // map label field
          //  COMBO-BOX TRIGGERS VALUE CHANGE WITH LABEL IF OPTIONS-KEYS.LABEL POINTS AT NUMBER FIELD
          // Enforce label to be always strings


          if (optionsKeys.label != null) {
            mappedItem.data.label = String(data[optionsKeys.label]);
          } else if (data.label != null) {
            mappedItem.data.label = String(data.label);
          } // map value field


          if (optionsKeys.value != null) {
            mappedItem.data.value = data[optionsKeys.value];
          }

          mappedItem.metadata = {
            key: data[optionsKeys.value || 'value']
          };
          return mappedItem;
        }; // create ListDataProviderView or TreeDataProviderView with dataMapping


        wrapper = isTree ? new TreeDataProviderView(dataProvider, {
          dataMapping: {
            mapFields: mapFields
          }
        }) : new ListDataProviderView(dataProvider, {
          dataMapping: {
            mapFields: mapFields
          }
        });
      } // save the data provider or wrapper


      if (wrapper) {
        wOptions._dataProvider = wrapper; // update internal wrapper

        if (opts) {
          // eslint-disable-next-line no-param-reassign
          opts._dataProvider = wrapper;
        }
      }
    }
  },

  /**
     * get display label. If label is missing, String(value) will be returned
     * @private
     */
  getLabel: function getLabel(item) {
    //  - number converter with comboboxes fails on zero value entry
    // if label is null or undefined use value
    return item.label != null ? item.label : String(item.value);
  },

  /**
     * data provider event handler
     * @private
     */
  _handleDataProviderEvents: function _handleDataProviderEvents(widget, event) {
    if (event.type === 'mutate') {
      if (event.detail.remove != null) {
        var data = event.detail.remove.data;
        var changed = false;
        var newVal = [].concat(widget.options.value);

        for (var i = 0; i < data.length; i++) {
          var index = newVal.indexOf(data[i].value);

          if (index >= 0) {
            newVal.splice(index, 1);
            changed = true;
          }
        }

        if (changed) {
          widget._setOption('value', newVal);
        }
      }
    }

    widget._setOption('options', widget.options.options);
  },

  /*
     * Add data provider event listeners
     */
  addDataProviderEventListeners: function addDataProviderEventListeners(widget) {
    var dataProvider = _ComboUtils.getDataProvider(widget.options);

    if (dataProvider) {
      _ComboUtils.removeDataProviderEventListeners(widget);

      var dataProviderEventHandler = _ComboUtils._handleDataProviderEvents.bind(null, widget); // eslint-disable-next-line no-param-reassign


      widget._saveDataProviderEH = dataProviderEventHandler;
      dataProvider.addEventListener('mutate', dataProviderEventHandler);
      dataProvider.addEventListener('refresh', dataProviderEventHandler);
    }
  },

  /*
     * Remove data provider event listeners
     */
  removeDataProviderEventListeners: function removeDataProviderEventListeners(widget) {
    var dataProvider = _ComboUtils.getDataProvider(widget.options);

    var dataProviderEventHandler = widget._saveDataProviderEH;

    if (dataProvider != null && dataProviderEventHandler) {
      dataProvider.removeEventListener('mutate', dataProviderEventHandler);
      dataProvider.removeEventListener('refresh', dataProviderEventHandler); // eslint-disable-next-line no-param-reassign

      widget._saveDataProviderEH = undefined;
    }
  },
  // _ComboUtils
  // Add a loading indicator to the select box
  addLoadingIndicator: function addLoadingIndicator(_container) {
    var container = _container; //  - display loading indicator when fetching label for initial value is slow

    if (container._loadingIndicatorCount === undefined) {
      container._loadingIndicatorCount = 1;
    } else {
      container._loadingIndicatorCount += 1;
    } // check if it's already added


    if (container._saveLoadingIndicator != null) {
      return;
    } // TODO: center icon


    var item = $(document.createElement('div'));
    item.uniqueId().attr('role', 'presentation').addClass('oj-listbox-loading-icon-container');
    var icon = $(document.createElement('div'));
    icon.addClass('oj-icon oj-listbox-loading-icon');
    item.append(icon); // @HTMLUpdateOK

    container.prepend(item); // @HTMLUpdateOK

    container._saveLoadingIndicator = item;
  },
  // _ComboUtils
  // Remove the loading indicator
  removeLoadingIndicator: function removeLoadingIndicator(_container) {
    var container = _container; //  - display loading indicator when fetching label for initial value is slow

    if (container._loadingIndicatorCount !== undefined) {
      // remove the loading indicator when reference count down to 0
      if (container._loadingIndicatorCount === 1) {
        container._loadingIndicatorCount = undefined;

        if (container._saveLoadingIndicator != null) {
          container._saveLoadingIndicator.remove();

          container._saveLoadingIndicator = undefined;
        }
      } else {
        container._loadingIndicatorCount -= 1;
      }
    }
  },
  // _ComboUtils
  // Add dropdown message such as filter further or no matches found
  addDropdownMessage: function addDropdownMessage(container, context, messageText) {
    // check if it's already added
    if (container._saveDropdownMessage) {
      return;
    }

    var msgParent = $(document.createElement('div'));
    msgParent.addClass('oj-listbox-filter-message-box');
    var message = $(document.createElement('div'));
    message.addClass('oj-listbox-filter-message-text oj-listbox-liveregion');
    message.attr({
      role: 'region',
      'aria-live': 'polite'
    });
    var separator = $(document.createElement('div'));
    separator.addClass('oj-listbox-filter-message-separator');
    msgParent.append(message); // @HTMLUpdateOK

    msgParent.append(separator); // @HTMLUpdateOK

    container.prepend(msgParent); // @HTMLUpdateOK

    message.text(messageText); // eslint-disable-next-line no-param-reassign

    container._saveDropdownMessage = msgParent;
  },
  // _ComboUtils
  // Remove dropdown message
  removeDropdownMessage: function removeDropdownMessage(container) {
    if (container._saveDropdownMessage) {
      container._saveDropdownMessage.remove(); // eslint-disable-next-line no-param-reassign


      container._saveDropdownMessage = undefined;
    }
  },
  // _ComboUtils
  createItemResult: function createItemResult(itemData, itemMetadata) {
    return {
      label: itemData.label,
      value: itemData.value,
      disabled: itemData.disabled,
      children: itemData.children,
      data: itemData,
      metadata: itemMetadata
    };
  },
  fetchFlatData: function fetchFlatData(context, dataProvider, fetchListParms, query, dropdown, maxItems) {
    var results = [];
    var asyncIterator = dataProvider.fetchFirst(fetchListParms)[Symbol.asyncIterator](); // maxItems > 0 indicates a max limit on the results

    var hasMaxLimit = maxItems > 0;

    function filterData(fetchResults) {
      if (fetchResults) {
        var data = fetchResults.value.data;
        var metadata = fetchResults.value.metadata;

        if (data) {
          var itemData;
          var itemMetadata;

          for (var i = 0; i < data.length && (!hasMaxLimit || results.length < maxItems); i++) {
            itemData = data[i];
            itemMetadata = metadata[i]; // skip filter locally if it is already done thru data provider

            if (fetchListParms.filterCriterion || !query || !query.matcher || query.matcher(query.term, _ComboUtils.getLabel(itemData), itemData)) {
              results.push(_ComboUtils.createItemResult(itemData, itemMetadata));
            }
          }
        } // clear message


        if (dropdown) {
          _ComboUtils.removeDropdownMessage(dropdown);
        } // not all results are fetched, display mesage for filtering further


        if (dropdown && !fetchResults.done && hasMaxLimit && results.length >= maxItems) {
          _ComboUtils.addDropdownMessage(dropdown, context, context.getTranslatedString('filterFurther')); // eslint-disable-next-line no-param-reassign


          context._hasMore = true;
        } else {
          // fetch more
          if (!fetchResults.done && (!hasMaxLimit || results.length < maxItems)) {
            return asyncIterator.next().then(filterData);
          } // eslint-disable-next-line no-param-reassign


          context._hasMore = false;
        }
      }

      return Promise.resolve(results);
    }

    return asyncIterator.next().then(filterData);
  },
  fetchTreeData: function fetchTreeData(context, rootDataProvider, fetchListParms, query, dropdown, maxItems) {
    // maxItems > 0 indicates a max limit on the results
    var hasMaxLimit = maxItems > 0;
    var remaining = fetchListParms.size; // eslint-disable-next-line no-param-reassign

    context._hasMore = false;

    if (dropdown) {
      _ComboUtils.removeDropdownMessage(dropdown);
    }

    function fetchLayer(dataProvider) {
      // eslint-disable-next-line no-param-reassign
      fetchListParms.size = remaining;
      var results = [];
      var iterator = dataProvider.fetchFirst(fetchListParms)[Symbol.asyncIterator]();
      return iterator.next().then(processChunk);

      function processChunk(fetchResult) {
        var data = fetchResult.value.data;
        var metadata = fetchResult.value.metadata;
        var childrenPromise = fetchChildren(0);
        return childrenPromise.then(function () {
          if (!hasMaxLimit) {
            if (fetchResult.done) {
              return Promise.resolve(results);
            }
          } else if (fetchResult.done || remaining <= 0) {
            if (!fetchResult.done) {
              // eslint-disable-next-line no-param-reassign
              context._hasMore = true;
            }

            return Promise.resolve(results);
          }

          return iterator.next().then(processChunk);
        });

        function processItem(itemData, itemMetadata, children) {
          var match = !query || !query.matcher || fetchListParms.filterCriterion || query.matcher(query.term, _ComboUtils.getLabel(itemData), itemData);
          var selectable = dataProvider.getChildDataProvider(itemData.value) == null;

          if (!selectable) {
            match = false;
          } // don't decrement the remaining counter if there is no max limit


          if (match && children.length === 0 && hasMaxLimit) {
            remaining -= 1;
          }

          if (match || children.length > 0) {
            // keep a reference to the original row data in "data"
            var result = _ComboUtils.createItemResult(itemData, itemMetadata);

            if (itemData.disabled) {
              result.disabled = true;
            }

            if (!selectable || result.disabled) {
              result._jetUnSelectable = true;
            }

            if (children.length > 0) {
              result.children = children;
            }

            results.push(result);
          }
        }

        function fetchChildren(i) {
          if (i < data.length) {
            if (remaining > 0 || !hasMaxLimit) {
              var itemData = data[i];
              var itemMetadata = metadata[i];
              var childDataProvider = dataProvider.getChildDataProvider(itemData.value);

              if (childDataProvider) {
                return fetchLayer(childDataProvider).then(function (childResults) {
                  processItem(itemData, itemMetadata, childResults);
                  return fetchChildren(i + 1);
                });
              }

              processItem(itemData, itemMetadata, []);
              return fetchChildren(i + 1);
            } // eslint-disable-next-line no-param-reassign


            context._hasMore = true;
          }

          return Promise.resolve(results);
        }
      }
    }

    return fetchLayer(rootDataProvider).then(function (results) {
      if (context._hasMore && dropdown) {
        _ComboUtils.addDropdownMessage(dropdown, context, context.getTranslatedString('filterFurther'));
      }

      return results;
    });
  },
  // _ComboUtils
  // Fetch from the data provider and filter the data locally until
  // the end of data or fetch size has reached
  fetchFilteredData: function fetchFilteredData(context, fetchSize, maxItems, query, dropdown) {
    var dataProvider = _ComboUtils.getDataProvider(context.options);

    var fetchListParms = {
      size: fetchSize
    }; // check if data provider support filtering?

    var filterCapability = dataProvider.getCapability('filter');
    var $co = oj.AttributeFilterOperator.AttributeOperator.$co;
    var $regex = oj.AttributeFilterOperator.AttributeOperator.$regex;
    var filterThruDataProvider = false;
    var filterSupportsRegex = false; // only filter thru data provider if it supports contains($co or $regex) operator

    if (filterCapability) {
      var filters = filterCapability.operators;

      if (filters && filters.length > 0) {
        if (filters.indexOf($co) >= 0 || filters.indexOf($regex) >= 0) {
          filterThruDataProvider = true;

          if (filters.indexOf($regex) >= 0) {
            filterSupportsRegex = true;
          }
        }
      }
    }

    var isTree = _ComboUtils.isTreeDataProvider(dataProvider); // have to filter


    if (query && query.term) {
      // use dataprovider filtering if supported
      if (filterThruDataProvider) {
        // TODO test in the data mapping case to see if "label" works
        // Note: revisit when tree dataProvider is supported
        // for now if optionsKey is used, 'label' must specify in optionsKeys
        var optKeys = context.options.optionsKeys;
        var attrName;

        if (optKeys && optKeys.label) {
          attrName = optKeys.label;
        } else {
          attrName = 'label';
        } // case insensitive query should use $regex


        if (filterSupportsRegex) {
          var escapedTerm = _ComboUtils.escapeRegExp(query.term);

          fetchListParms.filterCriterion = {
            op: $regex,
            attribute: attrName,
            value: new RegExp(escapedTerm, 'i')
          };
        } else {
          // if no regex support just fallback to $co
          fetchListParms.filterCriterion = {
            op: $co,
            attribute: attrName,
            value: query.term
          };
        }
      } else if (!isTree) {
        if (maxItems > 0) {
          // for local filtering increase the fetch size
          var fs = maxItems * _ComboUtils.FILTERING_FETCH_SIZE_MRC_TIMES; // fetch size should be between minimum and maximum fetch size for local filtering

          if (fs > _ComboUtils.FILTERING_FETCH_SIZE_MAX) {
            fs = _ComboUtils.FILTERING_FETCH_SIZE_MAX;
          } else if (fs < _ComboUtils.FILTERING_FETCH_SIZE_MIN) {
            fs = _ComboUtils.FILTERING_FETCH_SIZE_MAX;
          }

          fetchListParms.size = fs;
        } else {
          fetchListParms.size = maxItems;
        }
      }
    }

    return isTree ? _ComboUtils.fetchTreeData(context, dataProvider, fetchListParms, query, dropdown, maxItems) : _ComboUtils.fetchFlatData(context, dataProvider, fetchListParms, query, dropdown, maxItems);
  },
  // used as rejected error in the fetchFromDataProvider method
  rejectedError: {},
  // _ComboUtils
  // add busy state
  // display an animated gif if it is fetch initially
  // fetch from the data provider
  // display message for furthur filtering if not all results are fetched
  // if multiple queries are in progress, discard all but the last query
  fetchFromDataProvider: function fetchFromDataProvider(widget, options, query, fetchSize) {
    var context = widget.ojContext; // add busy context

    if (!context._fetchResolveFunc) {
      context._fetchResolveFunc = _ComboUtils._addBusyState(widget.container, 'fetching data');
    } // reject the previous promise to avoid out of order request


    if (context._saveRejectFunc) {
      context._saveRejectFunc(_ComboUtils.rejectedError);
    } // save the current reject function


    var remotePromise = new Promise(function (resolve, reject) {
      context._saveRejectFunc = reject;
    }); // display spinning icon only for the initial fetch

    if (widget.selection && options.fetchType === 'init' && !context._spinnerContainer) {
      context._spinnerContainer = widget.selection;

      _ComboUtils.addLoadingIndicator(context._spinnerContainer); // eslint-disable-next-line no-param-reassign


      options.fetchType = null;
    }

    var maxItems = _ComboUtils._getMaxItems(options); // fetch data from dataProvider


    var fs = fetchSize || options.fetchSize || maxItems;

    var fetchPromise = _ComboUtils.fetchFilteredData(context, fs, maxItems, query, widget.dropdown).then(function (fetchResults) {
      //  - search not shown before typing a character
      context._resultCount = fetchResults ? fetchResults.length : 0;
      return fetchResults;
    }); // if multiple queries are in progress, discard all but the last query


    Promise.race([remotePromise, fetchPromise]).then(function (fetchResults) {
      // clear the reject function
      context._saveRejectFunc = null;

      if (context._spinnerContainer) {
        _ComboUtils.removeLoadingIndicator(context._spinnerContainer);

        context._spinnerContainer = undefined;
      } //  - search not shown before typing a character


      if (context._resolveSearchBoxLater) {
        widget._showSearchBox('');
      }

      query.callback({
        results: fetchResults
      });

      if (context._fetchResolveFunc) {
        // clear busy context
        context._fetchResolveFunc();

        context._fetchResolveFunc = null;
      }
    }, function (error) {
      // don't remove busy state if the reject coming from Promise.race
      if (error !== _ComboUtils.rejectedError && context._fetchResolveFunc) {
        query.callback();

        context._fetchResolveFunc();

        context._fetchResolveFunc = null;
      }
    });
  },
  // _ComboUtils
  // fetch first block of data from the data provider
  fetchFirstBlockFromDataProvider: function fetchFirstBlockFromDataProvider(container, options, fetchSize) {
    var dataProvider = _ComboUtils.getDataProvider(options); // add busy context


    var fetchResolveFunc = _ComboUtils._addBusyState(container, 'fetching selected data');

    var maxItems = _ComboUtils._getMaxItems(options);

    var fetchListParms = {
      size: fetchSize || maxItems
    };

    if (_ComboUtils.isTreeDataProvider(dataProvider)) {
      return _ComboUtils.fetchTreeData({}, dataProvider, fetchListParms, null, null, maxItems).then(function (fetchResults) {
        // return the leaf node data
        if (fetchSize === 1 && fetchResults && fetchResults.length > 0) {
          var selval = fetchResults[0];

          for (; selval.children;) {
            selval = selval.children[0];
          } // eslint-disable-next-line no-param-reassign


          fetchResults = [selval];
        }

        _ComboUtils._clearBusyState(fetchResolveFunc);

        return fetchResults;
      }, function () {
        _ComboUtils._clearBusyState(fetchResolveFunc);

        return null;
      });
    }

    var asyncIterator = dataProvider.fetchFirst(fetchListParms)[Symbol.asyncIterator]();
    return asyncIterator.next().then(function (fetchResults) {
      _ComboUtils._clearBusyState(fetchResolveFunc);

      return fetchResults.value.data;
    }, function () {
      _ComboUtils._clearBusyState(fetchResolveFunc);

      return null;
    });
  },
  duringFetchByKey: function duringFetchByKey(container) {
    return container._fetchByKeys;
  },
  // _ComboUtils
  // fetch the data row by its key("value")
  fetchByKeyFromDataProvider: function fetchByKeyFromDataProvider(widget, options, query) {
    var dataProvider = _ComboUtils.getDataProvider(options); // add busy context


    var container = widget && widget.selection ? widget.container : widget;

    var fetchResolveFunc = _ComboUtils._addBusyState(container, 'fetching selected data'); //  - display loading indicator when fetching label for initial value is slow


    if (widget && widget.selection) {
      if (widget.opts.fetchType === 'init' && !container._spinnerContainer) {
        container._spinnerContainer = widget.selection;

        _ComboUtils.addLoadingIndicator(container._spinnerContainer);
      }
    } //  - sdp.fetchbykeys method is being called twice for a single value
    // Stored the selected value in container._fetchByKeys, it will be cleared when the promise
    // is resolved or rejected. When this method is called again with the same selected value,
    // don't make another call to dataProvider.fetchByKeys because the previous one is in flight.


    var fetchPromise;

    if (container._fetchByKeys && container._fetchByKeys.promise && oj.Object.compareValues(query.value, container._fetchByKeys.key)) {
      fetchPromise = container._fetchByKeys.promise;
    } else {
      fetchPromise = dataProvider.fetchByKeys({
        keys: query.value
      }); // save key and promise
      // eslint-disable-next-line no-param-reassign

      container._fetchByKeys = {
        key: query.value,
        promise: fetchPromise
      };
    } // fetch the data row by its key("value")


    fetchPromise.then(function (fetchResults) {
      //  - sdp.fetchbykeys method is being called twice for a single value
      // eslint-disable-next-line no-param-reassign
      container._fetchByKeys = undefined;

      if (container._spinnerContainer) {
        _ComboUtils.removeLoadingIndicator(container._spinnerContainer);

        container._spinnerContainer = undefined;
      }

      var values = [];
      fetchResults.results.forEach(function (val) {
        values.push(_ComboUtils.createItemResult(val.data, val.metadata));
      });
      query.callback({
        results: values
      });

      _ComboUtils._clearBusyState(fetchResolveFunc);
    }, function () {
      //  - sdp.fetchbykeys method is being called twice for a single value
      // eslint-disable-next-line no-param-reassign
      container._fetchByKeys = undefined;
      query.callback();

      _ComboUtils._clearBusyState(fetchResolveFunc);
    });
  },
  // _ComboUtils
  // check if the specified value is in the dataProvider
  // return a promise with the following results
  // 1) null: value is invalid or reject by fetchByKeyFromDataProvider
  // 2) array of valid values
  validateFromDataProvider: function validateFromDataProvider(container, options, value) {
    // eslint-disable-next-line no-unused-vars
    return new Promise(function (resolve, reject) {
      _ComboUtils.fetchByKeyFromDataProvider(container, options, {
        value: Array.isArray(value) ? value : [value],
        callback: function callback(data) {
          var results = null; //  - need to be able to specify the initial value of select components bound to dprv

          if (data && data.results.length) {
            results = {};
            results.value = [];
            results.valueOptions = [];

            for (var i = 0; i < data.results.length; i++) {
              results.valueOptions.push(data.results[i]);
              results.value.push(data.results[i].value);
            }
          }

          resolve(results);
        }
      });
    });
  },
  // _ComboUtils
  // Readonly support for the custom element only
  isReadonly: function isReadonly(widget) {
    return widget._IsCustomElement() && (widget.options.readOnly || widget.options.loading === 'loading');
  },
  // _ComboUtils
  // Get maximum items to display in the dropdown
  _getMaxItems: function _getMaxItems(options) {
    var maxItems;

    if (options.maximumResultCount !== undefined && options.maximumResultCount !== null) {
      maxItems = options.maximumResultCount; // max items less than 1 indicates no max limit

      if (maxItems < 1) {
        maxItems = _ComboUtils.DEFAULT_FETCH_ALL_SIZE;
      }
    } else {
      maxItems = _ComboUtils.DEFAULT_FETCH_SIZE;
    }

    return maxItems;
  },

  /*
     * Produces a query function that works with a remote data
     */
  remote: function remote(options, optKeys) {
    return function (query) {
      var context = {
        component: this.ojContext
      };

      if (query.value) {
        context.value = query.value;
      } else {
        context.term = query.term || '';
      }

      options(context).then(function (data) {
        var filtered = {
          results: []
        };

        if (data) {
          _ComboUtils.each2($(data), function (i, datum) {
            _ComboUtils._processData(query, datum, filtered.results, optKeys, false);
          });
        }

        query.callback(filtered);
      });
    };
  },
  // _ComboUtils

  /*
     * Maps the optionsKeys and options array and creates the array of
     * Label-Value objects. If options array is local data then
     * it filters the result array based on the term entered in the search field.
     */
  _processData: function _processData(query, data, collection, keys, isLocal, text) {
    var group;
    var datum = data[0]; // key mappings

    if (!datum.label && keys && keys.label) {
      datum.label = datum[keys.label];
    }

    if (!datum.value && keys && keys.value) {
      datum.value = datum[keys.value];
    }

    if (!datum.children && keys && keys.children) {
      datum.children = datum[keys.children];
      delete datum[keys.children];
    }

    if (datum.children) {
      group = {};
      var attrs = Object.keys(datum);

      for (var k = 0; k < attrs.length; k++) {
        var attr = attrs[k];
        group[attr] = datum[attr];
      }

      group.children = [];

      _ComboUtils.each2($(datum.children), function (i, childDatum) {
        _ComboUtils._processData(query, childDatum, group.children, keys && keys.childKeys ? keys.childKeys : null, isLocal, text);
      }); //  - group labels participate in the filtering
      // Reverted. In the nested data case, group may be selectable. Without putting the
      // group data in the collection, we will find no match and new entry may be created for combobox.
      // For group that has matching children, we need to call the matcher on the group label
      // to update the matches array. This needs to be done before checking the group.children.length.


      if (!isLocal || query.matcher(query.term, text(group), datum) || group.children.length) {
        collection.push(group);
      }
    } else if (!isLocal || query.matcher(query.term, text(datum), datum)) {
      collection.push(datum);
    }
  },
  // _ComboUtils
  checkFormatter: function checkFormatter(ojContext, formatter, formatterName) {
    if ($.isFunction(formatter)) {
      return true;
    }

    if (!formatter) {
      return false;
    }

    throw new Error(formatterName + ' must be a function or a false value');
  },
  // _ComboUtils

  /*
     * Creates a new class
     */
  clazz: function clazz(SuperClass, methods) {
    var constructor = function constructor() {};

    oj.Object.createSubclass(constructor, SuperClass, '');
    constructor.prototype = $.extend(constructor.prototype, methods);
    return constructor;
  },
  // _ComboUtils
  LAST_QUERY_RESULT: 'last-query-result',
  getLastQueryResult: function getLastQueryResult(context) {
    var queryResult = $.data(context.container, context._classNm + '-' + _ComboUtils.LAST_QUERY_RESULT);
    return queryResult;
  },
  saveLastQueryResult: function saveLastQueryResult(context, queryResult) {
    $.data(context.container, context._classNm + '-' + _ComboUtils.LAST_QUERY_RESULT, queryResult);
  },
  // _ComboUtils

  /* ER 29805293 - lov: when bound to dp impl selecting an item from dropdown must provide data
     * when the multichoice component is initialized or when an item is selected, options data is saved in item pills
     * get the data saved in item pills for the passed val
     */
  getSelectedOptionData: function getSelectedOptionData(context, val) {
    if (context.ojContext.multiple && context.selection) {
      var item;
      var itemData;
      var selections = context.selection.find('.' + context._classNm + '-selected-choice');

      for (var i = 0; i < selections.length; i++) {
        item = selections.get(i);
        itemData = $(item).data(context._elemNm);

        if (oj.Object.compareValues(val, itemData.value)) {
          return itemData;
        }
      }
    }

    return undefined;
  },
  // _ComboUtils
  getContextWithExtraData: function getContextWithExtraData(context, opts, data, metadata) {
    // set extradata in context only for dataprovider
    var isDataProvider = opts ? _ComboUtils.isDataProvider(opts.options) : false; // do not extend context if the data is empty

    if (!isDataProvider || data == null || Array.isArray(data) && data.length === 0) {
      return context;
    }

    return $.extend(context || {}, {
      extraData: {
        data: data,
        metadata: metadata
      }
    });
  },
  // _ComboUtils
  getOpts: function getOpts(ojContext) {
    var opts;

    if (ojContext) {
      if (ojContext.combobox && ojContext.combobox.opts) {
        opts = ojContext.combobox.opts;
      } else if (ojContext.select && ojContext.select.opts) {
        opts = ojContext.select.opts;
      }
    }

    return opts;
  }
};
var _ojChoiceDefaults = {
  closeOnSelect: true,
  openOnEnter: true,
  formatNoMatches: function formatNoMatches(ojContext) {
    return ojContext.getTranslatedString('noMatchesFound');
  },
  formatMoreMatches: function formatMoreMatches(ojContext, num) {
    if (num === 1) {
      return ojContext.getTranslatedString('oneMatchesFound');
    }

    return ojContext.getTranslatedString('moreMatchesFound', {
      num: '' + num
    });
  },
  id: function id(e) {
    return e.id;
  },
  matcher: function matcher(term, text) {
    return ('' + text).toUpperCase().indexOf(('' + term).toUpperCase()) >= 0;
  },
  separator: ','
}; // eslint-disable-next-line no-unused-vars

var _AbstractOjChoice = _ComboUtils.clazz(Object, {
  // _AbstractOjChoice
  _bind: function _bind(func) {
    var self = this;
    return function () {
      return func.apply(self, arguments);
    };
  },
  // _AbstractOjChoice
  _customOptionRenderer: function _customOptionRenderer(elems) {
    var elem;
    var self = this;
    elems.each(function () {
      elem = $(this);

      if (elem.is('oj-option')) {
        elem.wrap('<li></li>'); // @HTMLUpdateOK
      } else if (elem.is('oj-optgroup')) {
        elem.wrap('<li></li>'); // @HTMLUpdateOK

        self._customOptionRenderer(elem.children());

        elem.children().wrapAll("<ul class='oj-listbox-result-sub' role='group'></ul>"); // @HTMLUpdateOK
      }
    });
  },
  // _AbstractOjChoice
  _init: function _init(_opts) {
    var results;
    var search;
    var className = this._classNm;
    var elemName = this._elemNm;
    var resultsSelector = '.oj-listbox-results';
    this.ojContext = _opts.ojContext;

    var opts = this._prepareOpts(_opts);

    this.opts = opts;
    this.id = opts.id;
    this.headerInitialized = false;
    this.isOjOption = this.ojContext._IsCustomElement() && !opts.options && opts.element.find('oj-option').length > 0; // 'opts.element' is initialized in _setup() method in component files
    // ojcombobox.js, ojselect.js and ojInputSearch.js.
    // destroy if called on an existing component

    if (opts.element.data(elemName) !== undefined && opts.element.data(elemName) !== null) {
      opts.element.data(elemName)._destroy();
    }

    this._prepareContainer(); // This prepares the container and sets this.container and this.containerSelector
    // cache the body so future lookups are cheap


    this.body = _ComboUtils.thunk(function () {
      return opts.element.closest('body');
    });
    this.dropdown = this.container.find('.oj-listbox-drop');
    this.dropdown.data('ojlistbox', this); //  - let the ojselect popup accept the custom css class name from the component

    this._setPickerAttributes(opts.pickerAttributes); // link the shared dropdown dom to the target component instance


    var containerId = this.containerId;
    this.dropdown.attr('data-oj-containerid', containerId);
    results = this.container.find(resultsSelector);
    this.results = results;
    this.results.on('click', _ComboUtils.killEvent); //  - oghag missing label for ojselect and ojcombobox

    var alabel = this._getTransferredAttribute('aria-label');

    if (alabel != null) {
      this.results.attr('aria-label', alabel);
    } // if html ul element is provided, use it instead


    if (opts.list && $('#' + opts.list).is('ul')) {
      var dropdownList = $('#' + opts.list);
      this.dropdownListParent = dropdownList.parent();
      dropdownList.addClass('oj-listbox-results').attr('role', 'listbox');
      this.results.replaceWith(dropdownList); // @HTMLUpdateOK

      results = this.container.find(resultsSelector);
      this.results = results;
      this.results.css('display', '');
    } // custom element syntax with oj-option elements


    if (this.isOjOption) {
      var elems = opts.element.children();

      this._customOptionRenderer(elems);

      this.results.append(opts.element.children()); // @HTMLUpdateOK

      this.datalist = this.results;
    }

    if (className === 'oj-select') {
      search = this.container.find('input.oj-listbox-input');
    } else {
      search = this.container.find('input.' + className + '-input');
    }

    this.search = search;
    this.queryCount = 0;
    this.resultsPage = 0;
    this.context = null;
    this._ariaDescribedByAdded = []; // used to store aria-describedby ids for multi choice
    // initialize the container

    this._initContainer();

    this.container.on('click', _ComboUtils.killEvent);

    _ComboUtils.installFilteredMouseMove(this.results); //  - CUSTOM TABINDEX DOES NOT WORK
    // Transfer the tabindex in the created input element or the selection element


    if (this.elementTabIndex) {
      if (className === 'oj-select') {
        // this.selection is available only after the _initContainer call
        this.selection.attr('tabindex', this.elementTabIndex);
      } else {
        this.search.attr('tabindex', this.elementTabIndex);
      }
    }

    this._boundHighlightUnderEvent = this._bind(this._highlightUnderEvent);

    if (this.ojContext._IsCustomElement()) {
      this._delegatedDropdownTouchStartListener = function (event) {
        var container = event.currentTarget;
        var targetElement = event.target.closest(resultsSelector);

        if (targetElement && container.contains(targetElement)) {
          this._boundHighlightUnderEvent($.Event(event, {
            currentTarget: targetElement
          }));
        }
      }.bind(this);

      this.dropdown.on('mousemove-filtered touchmove touchend', resultsSelector, this._boundHighlightUnderEvent);
      this.dropdown[0].addEventListener('touchstart', this._delegatedDropdownTouchStartListener, {
        passive: true
      });
    } else {
      this.dropdown.on('mousemove-filtered touchstart touchmove touchend', resultsSelector, this._boundHighlightUnderEvent);
    } // do not propagate change event from the search field out of the component


    $(this.container).on('change', '.' + className + '-input', function (e) {
      e.stopPropagation();
    });
    $(this.dropdown).on('change', '.' + className + '-input', function (e) {
      e.stopPropagation();
    });
    var self = this;

    _ComboUtils.installKeyUpChangeEvent(search);

    search.on('keyup-change input paste', this._bind(this._updateResults));
    search.on('focus', function () {
      search.addClass(className + '-focused');

      if (className !== 'oj-select') {
        self.container.addClass('oj-focus');
      }

      self.isSearchFocused = true;
    });
    search.on('blur', function () {
      search.removeClass(className + '-focused');

      if (className !== 'oj-select') {
        self.container.removeClass('oj-focus');
      }

      self.isSearchFocused = false;
    });
    this.dropdown.on('mouseup', resultsSelector, this._bind(function (e) {
      if ($(e.target).closest('.oj-listbox-result-selectable').length > 0) {
        this._highlightUnderEvent(e);

        this._selectHighlighted(null, e);
      }
    })); // trap all mouse events from leaving the dropdown. sometimes there may be a modal that is listening
    // for mouse events outside of itself so it can close itself. since the dropdown is now outside the combobox's
    // dom it will trigger the popup close, which is not what we want

    this.dropdown.on('click mouseup mousedown', function (e) {
      e.stopPropagation();
    });

    if ($.isFunction(this.opts.initSelection)) {
      // /support ko options-binding
      // init dataProvider fetchType
      this.opts.fetchType = 'init';
      var valOpts = this.getValOpts();

      if (this.ojContext.multiple && (!valOpts || valOpts.length === 0) || !this.ojContext.multiple && !valOpts) {
        valOpts = null;
      }

      this._initSelection(valOpts);
    }

    var readonly = opts.element.prop('readonly');

    if (readonly === undefined) {
      readonly = false;
    }

    this._readonly(readonly);

    var disabled = opts.element.prop('disabled');

    if (disabled === undefined) {
      disabled = false;
    }

    this._enable(!disabled); // create the readonlyDiv


    if (readonly) {
      var input = this.container.find('.oj-combobox-input');

      this.ojContext._createOrUpdateReadonlyDiv(input[0]);
    } // Calculate size of scrollbar


    _ComboUtils.scrollBarDimensions = _ComboUtils.scrollBarDimensions || _ComboUtils.measureScrollbar();
    this.autofocus = opts.element.prop('autofocus');
    opts.element.prop('autofocus', false);

    if (this.autofocus) {
      this._focus();
    }

    _ComboUtils.addDataProviderEventListeners(opts.ojContext); // Readonly support


    this.applyReadonlyState();
  },

  /**
     * Creates content elements and this method should be overridden by all the children
     * and they should return their own collection of HTML elements that represents their
     * own content
     *
     * @return {jQuery} The collection of HTML elements that represent the content
     *
     * @memberof! _AbstractOjChoice
     * @instance
     * @protected
     */
  _CreateContentElements: function _CreateContentElements() {
    return null;
  },

  /**
     * Configure slots for custom elements.
     * This is noop by default and children that support slots should
     * override this method.
     * Children that implements this method should also implement
     * _RestoreSlots method to ensure that slot elements are returned to
     * their original place when calling destroy method.
     *
     * @memberof! _AbstractOjChoice
     * @instance
     * @protected
     */
  _ConfigureSlots: function _ConfigureSlots() {},

  /**
     * Restores slots for custom elements.
     * This is noop by default and children that support slots should
     * override this method.
     * Children that implements _ConfigureSlots method should also implement
     * this method to ensure that slot elements are returned to
     * their original place when calling destroy method.
     *
     * @memberof! _AbstractOjChoice
     * @instance
     * @protected
     */
  _RestoreSlots: function _RestoreSlots() {},

  /**
     * Creates container for widgets
     *
     * @return {jQuery} The created container
     *
     * @memberof! _AbstractOjChoice
     * @instance
     * @private
     */
  _createContainerForWidget: function _createContainerForWidget() {
    var container = $(document.createElement('div'));

    var content = this._CreateContentElements(); // method defined by child classes


    container.attr('class', this._COMPONENT_CLASSLIST); // member initialized by child classes

    container.append(content); // @HTMLUpdateOK

    return container;
  },

  /**
     * Prepares the container and initializes member variable related to the
     * container.
     *
     * @memberof! _AbstractOjChoice
     * @instance
     * @private
     */
  _prepareContainer: function _prepareContainer() {
    var container;
    var containerId;
    var containerSelector;
    var elementName;
    var elementTabIndex;

    if (this.ojContext._IsCustomElement()) {
      container = this._prepareContainerForCustomElement();
    } else {
      container = this._prepareContainerForWidget();
    } // now the container is the outer most element of the component
    // For custom elements, it will be oj custom element where as for widgets it will be the
    // container created by this._createContainerForWidget which is appended to the parent of the inner element.


    container.find('.oj-listbox-drop').css('display', 'none');
    containerId = this._getOrCreateContainerId(container); // eslint-disable-next-line no-useless-escape

    containerSelector = '#' + containerId.replace(/([;&,\.\+\*\~':"\!\^#$%@\[\]\(\)=>\|])/g, '\\$1');
    elementTabIndex = this.opts.element.attr('tabindex');
    elementName = this._elemNm;
    this.opts.element.data(elementName, this).attr('tabindex', '-1'); // @HTMLUpdateOK

    container.data(elementName, this); // initialize instance members

    this.container = container;
    this.containerId = containerId;
    this.containerSelector = containerSelector;
    this.elementTabIndex = elementTabIndex; // Configure slots only after the instance memeber container is initialized

    this._ConfigureSlots();
  },

  /**
     * Appends the created container for custom element
     *
     * @return {jQuery} The reference to the container with the appended content
     *
     * @memberof! _AbstractOjChoice
     * @instance
     * @private
     */
  _prepareContainerForCustomElement: function _prepareContainerForCustomElement() {
    var _outerWrapper = this.ojContext.OuterWrapper;

    var _content = this._CreateContentElements(); // method defined by child classes


    var _containerClass = this._COMPONENT_CLASSLIST; // member initialized by child classes

    var _container; // For custom element, the outer wrapper will be the container


    _container = $(_outerWrapper); // Apply the class from the container param

    _container.addClass(_containerClass);

    _container.prepend(_content); // @HTMLUpdateOK


    return _container;
  },

  /**
     * Appends the created container for widget
     *
     * @return {jQuery} The reference to the container with the appended content
     *
     * @memberof! _AbstractOjChoice
     * @instance
     * @private
     */
  _prepareContainerForWidget: function _prepareContainerForWidget() {
    var _element = this.opts.element;

    var _container = this._createContainerForWidget();

    var style; // For widgets, the container is swapped with the element

    _element.before(_container); // @HTMLUpdateOK


    _container.append(_element); // @HTMLUpdateOK
    // Weâre copying the style attribute over from the outer element to
    // the container. Normally setting the style attribute would
    // trigger a CSP inline style violation. However, we wonât hit this
    // because when CSP is enabled, the outer element wonât have a style
    // attribute and thus attr(âstyleâ) wonât be called.


    style = this._getAttribute('style');

    if (style) {
      _container.attr('style', style); // @HTMLUpdateOK

    }

    return _container;
  },

  /**
     * Retrieves ID of the container and if one is not available, an ID will be created
     *
     * @param {jQuery} container The container element
     * @return {string} The container ID that was retrieved or created
     *
     * @memberof! _AbstractOjChoice
     * @instance
     * @private
     */
  _getOrCreateContainerId: function _getOrCreateContainerId(container) {
    var containerId;

    if (this.ojContext._IsCustomElement()) {
      containerId = this._getAttribute('id');

      if (!containerId) {
        containerId = this._classNm + '-' + _ComboUtils.nextUid();
        container.attr('id', containerId);
      }
    } else {
      //  - ojselect - rootAttributes are not propagated to generated jet component
      var rootAttributes = this.opts.rootAttributes;
      containerId = rootAttributes && rootAttributes.id ? rootAttributes.id : 'ojChoiceId_' + (this._getAttribute('id') || this._classNm + _ComboUtils.nextUid());
      container.attr('id', containerId);
    }

    return containerId;
  },
  // _AbstractOjChoice
  // Readonly support
  applyReadonlyState: function applyReadonlyState() {
    var $content = this.ojContext._GetContentElement();

    if (_ComboUtils.isReadonly(this.ojContext)) {
      this.container.addClass('oj-read-only');

      if (this._classNm === 'oj-combobox') {
        if (this.ojContext.multiple) {
          // the following code is for oj-combobox-many
          $content = null;
          this.search.removeAttr('tabindex');
          this.selection.attr('tabindex', this.elementTabIndex || '0');

          if (this.ojContext.options.labelledBy) {
            // for oj-combobox-many in readonly mode, when you click on the field it is the
            // wrapper that gets focus, not the input, so you need aria-labelledby to point
            // to label element's id.
            var defaultLabelId = this.uuid + '_Label';

            var ariaLabelledBy = oj.EditableValueUtils._getOjLabelAriaLabelledBy(this.ojContext.options.labelledBy, defaultLabelId);

            if (ariaLabelledBy) {
              this.selection.attr('aria-labelledby', ariaLabelledBy);
            }
          }
        } else {
          $content.attr('readonly', true); // create readonly div if it doesn't exist.

          this.ojContext._createOrUpdateReadonlyDiv($content[0]);
        }
      } else if (this._classNm === 'oj-select') {
        $content.attr('aria-readonly', 'true');
      }

      if ($content) {
        $content.removeAttr('role');
        $content.removeAttr('aria-expanded');
      }
    } else {
      this.container.removeClass('oj-read-only');

      if (this._classNm === 'oj-combobox') {
        if (this.ojContext.multiple) {
          $content = null;

          if (this.elementTabIndex != null) {
            this.search.attr('tabindex', this.elementTabIndex);
          }

          this.selection.removeAttr('tabindex');
          this.selection.removeAttr('aria-labelledby');
        } else {
          $content.removeAttr('readonly', true);
        }
      } else if (this._classNm === 'oj-select') {
        $content.removeAttr('aria-readonly');
      }

      if ($content) {
        $content.attr('role', 'combobox');
        $content.attr('aria-expanded', 'false');
      }
    }

    this._enableInterface();
  },

  /**
   * Syncs the aria-label of the content elemnt with the dropdown
   *
   * @memberof! _AbstractOjChoice
   * @instance
   * @public
   * @ignore
   */
  updateAriaLabelIfNeeded: function updateAriaLabelIfNeeded() {
    // labelEdge and labelHint are only for custom element
    if (!this.ojContext._IsCustomElement()) {
      return;
    } // aria-label will be set on the content element
    // sync it with the dropdown


    var alabel = this._contentElement.attr('aria-label');

    if (alabel) {
      // Update dropdown
      this.results.attr('aria-label', alabel);
    } else {
      // Update dropdown
      this.results.removeAttr('aria-label');
    }
  },
  // _AbstractOjChoice
  _clickAwayHandler: function _clickAwayHandler(event) {
    var dropdown = this.dropdown;
    var self; //  - period character in element id prevents options box open/close
    // escapeSelector handles special characters

    if ($(event.target).closest(dropdown).length || $(event.target).closest('#' + $.escapeSelector(dropdown.attr('data-oj-containerid'))).length) {
      return;
    }

    if (dropdown.length > 0) {
      self = dropdown.data('ojlistbox');
      self.close(event);
    }
  },
  // _AbstractOjChoice
  _surrogateRemoveHandler: function _surrogateRemoveHandler() {
    if (this.dropdown) {
      this.dropdown.remove();
    }
  },
  // _AbstractOjChoice
  _destroy: function _destroy() {
    var closeDelayTimer = this._closeDelayTimer;

    if (!isNaN(closeDelayTimer)) {
      delete this._closeDelayTimer;
      window.clearTimeout(closeDelayTimer);
    }

    var element = this.opts.element;
    var ojcomp = element.data(this._elemNm);
    this.close();

    if (this.propertyObserver) {
      delete this.propertyObserver;
      this.propertyObserver = null;
    } // 'results' is initialized in _init() method and it can not be changed by an external developer.
    // clean up the ul list


    if (this.opts.list && this.results) {
      this._cleanupList(this.results); // Move to original parent


      if (this.dropdownListParent) {
        this.dropdownListParent.append(this.results); // @HTMLUpdateOK
      }
    } else if (this.isOjOption && this.results) {
      this._unwrapOjOptions(this.results);

      this.opts.element.append(this.results.children()); // @HTMLUpdateOK
    }

    if (ojcomp !== undefined) {
      if (this.ojContext._IsCustomElement()) {
        this._cleanUpContainerForCustomElement();
      } else {
        this._cleanUpContainerForWidget();
      }

      element.removeAttr('aria-hidden').removeData(this._elemNm).off('.' + this._classNm).prop('autofocus', this.autofocus || false);

      if (this.elementTabIndex) {
        element.attr({
          tabindex: this.elementTabIndex
        });
      } else {
        element.removeAttr('tabindex');
      }

      element.show();
    }
  },

  /**
     * Cleans up the container for widget
     *
     * @memberof! _AbstractOjChoice
     * @instance
     * @private
     */
  _cleanUpContainerForWidget: function _cleanUpContainerForWidget() {
    var element = this.opts.element;
    var ojcomp = element.data(this._elemNm); // Move the element outside the container to its original place

    ojcomp.container.after(element); // @HTMLUpdateOK

    ojcomp.container.remove();
    ojcomp.dropdown.remove();
  },

  /**
     * Cleans up the container for custom element
     *
     * @memberof! _AbstractOjChoice
     * @instance
     * @private
     */
  _cleanUpContainerForCustomElement: function _cleanUpContainerForCustomElement() {
    var element = this.opts.element;
    var ojcomp = element.data(this._elemNm); // remove touchstart listener from dropdown

    ojcomp.dropdown[0].removeEventListener('touchstart', this._delegatedDropdownTouchStartListener, {
      passive: true
    });
    delete this._delegatedDropdownTouchStartListener;
    ojcomp.container.empty();
    ojcomp.container.off('click');
    ojcomp.container.append(element); // @HTMLUpdateOK
    // : COMBOBOX CUSTOM END SLOT DISAPPEARED ON REFRESH AND DEFAULT END SLOT IS SHOWN
    // If end slot was provided, move it back to its original place

    this._RestoreSlots();
  },
  // _AbstractOjChoice

  /*
     * unwrap oj-option and oj-optgroup
     */
  _unwrapOjOptions: function _unwrapOjOptions(list) {
    var children = list.children();
    var elem;
    var self = this;
    children.each(function () {
      elem = $(this);

      if (elem.is('li')) {
        // oj-optgroup
        if (elem.hasClass('oj-listbox-result-with-children') || elem.children('oj-optgroup').length > 0) {
          // if the oj-optgroup went through the populateResults call
          if (elem.hasClass('oj-listbox-result-with-children')) {
            elem.children('.oj-listbox-result-label').remove();
          } // unwrap children


          self._unwrapOjOptions(elem.find('oj-optgroup').children()); // unwrap the <ul>


          elem.find('oj-optgroup').children().children().unwrap(); // unwrap the <li>

          elem.find('oj-optgroup').unwrap();
        } else if (elem.hasClass('oj-listbox-result')) {
          // unwrap the <li>
          // if the oj-option went through the populateResults call
          elem.find('oj-option').unwrap().unwrap();
        } else {
          elem.find('oj-option').unwrap();
        }
      }
    });
  },
  // _AbstractOjChoice

  /*
     * Clean up the html list provided by app
     */
  _cleanupList: function _cleanupList(list) {
    if (list && list.is('ul')) {
      list.removeClass('oj-listbox-results oj-listbox-result-sub');
      list.removeAttr('role');

      for (var i = list.children().length - 1; i >= 0; i--) {
        this._cleanupList($(list.children()[i]));
      }
    } else if (list.is('li')) {
      if (list.hasClass('oj-listbox-placeholder') || list.hasClass('oj-listbox-no-results')) {
        list.remove();
      } // remove added li classes starts with oj-listbox-


      if (list.attr('class')) {
        list.attr('class', list.attr('class').replace(/oj-listbox-\S+/g, ''));
      } // remove wrapping div


      var wrappingDiv = list.children('.oj-listbox-result-label');

      if (wrappingDiv) {
        wrappingDiv.contents().unwrap();
      }

      if (list.css('display') === 'none') {
        list.css('display', '');
      }

      this._cleanupList(list.children('ul'));
    }
  },
  // _AbstractOjChoice

  /*
     * Processes option/optgroup/li element and return data object
     */
  _optionToData: function _optionToData(element) {
    if (element.is('option') || element.is('oj-option')) {
      return {
        value: element.prop('value') || element.attr('value'),
        label: element.text().trim() || element.attr('label'),
        element: element.get(),
        css: element.attr('class'),
        disabled: element.prop('disabled'),
        locked: element.attr('locked') === 'locked' || element.data('locked') === true
      };
    } else if (element.is('optgroup') || element.is('oj-optgroup')) {
      return {
        label: element.prop('label') || element.attr('label'),
        disabled: element.prop('disabled'),
        children: [],
        element: element.get(),
        css: element.attr('class')
      };
    } else if (element.is('li')) {
      var itemLabel;
      var itemValue;
      var disabled;
      var groupData = null;
      var elemChildren = element.children();

      if (elemChildren && elemChildren.length > 0 && elemChildren.is('ul')) {
        itemLabel = element.attr('oj-data-label') ? element.attr('oj-data-label') : element.clone().children().remove().end().text().trim();
        itemValue = element.attr('oj-data-value');
        groupData = [];
      } else if (elemChildren && elemChildren.length > 0 && elemChildren.is('oj-optgroup')) {
        itemLabel = elemChildren.prop('label');
        disabled = elemChildren.prop('disabled');
        groupData = [];
      } else {
        var ojOptionItem = element.find('oj-option');
        itemLabel = element.attr('oj-data-label') ? element.attr('oj-data-label') : element.text().trim();
        itemValue = ojOptionItem.length > 0 ? ojOptionItem.prop('value') : element.attr('oj-data-value');
        disabled = ojOptionItem.length > 0 ? ojOptionItem.prop('disabled') : undefined;
      }

      return {
        value: itemValue,
        label: itemLabel,
        disabled: disabled,
        element: element.get(),
        css: element.attr('class'),
        children: groupData
      };
    }

    return undefined;
  },
  // _AbstractOjChoice

  /*
     * Prepares the option items to display in the drop down
     */
  _prepareOpts: function _prepareOpts(_opts) {
    var opts = _opts;
    var element;
    var datalist;
    var self = this; // clone the options array if optionsKeys is specified

    if (opts.options && Array.isArray(opts.options) && opts.optionsKeys) {
      opts.options = $.extend(true, [], opts.options);
    }

    element = opts.element;
    var tagName = element.get(0).tagName.toLowerCase();

    if (opts.ojContext._IsCustomElement()) {
      if (!opts.options && opts.element.children().length > 0) {
        datalist = $(element);
        this.datalist = datalist;
      }
    } else if (tagName === 'input' && element.attr('list')) {
      datalist = $('#' + element.attr('list'));
      this.datalist = datalist;
    } else if (tagName === 'select' && element.children().length > 0) {
      // /ojselect
      datalist = element;
      this.datalist = datalist;
    } else if (opts.list) {
      // if html ul list is provided
      datalist = $('#' + opts.list);
      this.datalist = datalist;
    }

    opts = $.extend({}, {
      populateResults: function populateResults(_container, _results, query, _showPlaceholder) {
        var _populate;

        var id = this.opts.id;

        var isTreeDataProvider = _ComboUtils.isTreeDataProvider(_ComboUtils.getDataProvider(this.opts));

        var optionRenderer = this.opts.optionRenderer;

        if (typeof optionRenderer !== 'function') {
          // cannot be non-function
          optionRenderer = null;
        }

        if (this.opts.ojContext._IsCustomElement() && optionRenderer) {
          // update renderer for custom element format
          var origRenderer = optionRenderer;

          optionRenderer = function optionRenderer(context) {
            var obj = origRenderer(context); // New interface is for the renderer to return oj-option or oj-optgroup element

            if (obj && (obj.tagName === 'OJ-OPTION' || obj.tagName === 'OJ-OPTGROUP')) {
              // Add the data-oj-binding-provider attribute if it doesn't have one so that it will be upgraded
              if (!obj.hasAttribute('data-oj-binding-provider')) {
                obj.setAttribute('data-oj-binding-provider', 'none');
              }

              return obj;
            } // Maintain backward compatibility with old interface


            return obj && obj.insert ? obj.insert : null;
          };
        }

        _populate = function populate(resultsParent, results, container, depth, showPlaceholder) {
          var i;
          var l;
          var result;
          var selectable;
          var disabled;
          var node;
          var label;
          var formatted;

          var processChildren = function processChildren(_node, _result) {
            if (_result.children && _result.children.length > 0) {
              var nestedList = _result.element && $(_result.element[0]).is('li') && $(_result.element[0]).children('ul');
              var innerContainer = nestedList ? $(_result.element[0]).children('ul') : $('<ul></ul>');

              if (!innerContainer.hasClass('oj-listbox-result-sub')) {
                innerContainer.addClass('oj-listbox-result-sub');
              } // set role


              innerContainer.attr('role', 'group');

              _populate(_result, _result.children, innerContainer, depth + 1, false);

              if (!nestedList) {
                _node.append(innerContainer); // @HTMLUpdateOK

              }
            }
          };

          var termHighlight = function termHighlight(highlighterSection, pattern) {
            function innerHighlight(_node, pat) {
              var isHighlighterNode = $(_node).is('OJ-HIGHLIGHT-TEXT');
              var isTextNode = _node.nodeType === 3;

              if (isHighlighterNode) {
                _node.setAttribute('match-text', pat);
              } else if (isTextNode) {
                var text = _node.data; // replace it with oj-highlight-text only if the text node has
                // non-empty data

                if (text.trim() !== '') {
                  var _ojHighlightTextElem = document.createElement('oj-highlight-text');

                  _ojHighlightTextElem.setAttribute('text', text);

                  _ojHighlightTextElem.setAttribute('match-text', pat);

                  _ojHighlightTextElem.setAttribute('data-oj-internal', '');

                  _ojHighlightTextElem.setAttribute('data-oj-binding-provider', 'none'); // replace the text node with the newly created oj-highlight-text element


                  _node.parentNode.replaceChild(_ojHighlightTextElem, _node);
                }
              } else if (_node.nodeType === 1 && _node.childNodes && !/(script|style)/i.test(_node.tagName)) {
                // This function is to highlight the text appeared in the passed-in node.
                // So recursively it checks for child nodes also.
                // But need not to highlight the text appeared in <script> and <style> tags, so skipping them.
                for (var h = 0; h < _node.childNodes.length; h++) {
                  innerHighlight(_node.childNodes[h], pat);
                }
              }
            }

            if (highlighterSection.length && pattern && pattern.length) {
              highlighterSection.each(function () {
                innerHighlight(this, pattern.toUpperCase());
              });
            }
          };

          var highlightLabelNode = function highlightLabelNode(labelNode) {
            if (opts.highlightTermInOptions(query)) {
              var highlighterSection = labelNode.find('.oj-listbox-highlighter-section');

              if (!highlighterSection.length) {
                highlighterSection = labelNode;
              }

              termHighlight(highlighterSection, query.term);
            }
          };

          var createLabelContent = function createLabelContent(labelNode, _result) {
            var contentNode;

            if (optionRenderer) {
              // For data provider, we store the whole original data item on the result wrapper
              // object instead of copying all the fields, now we need to pass the stored original
              // data to an option-renderer
              var contextData = _ComboUtils.isDataProvider(opts.options) ? _result.data : _result;
              var context = {
                index: i,
                depth: depth,
                leaf: !_result.children,
                parent: resultsParent,
                data: contextData,
                component: opts.ojContext,
                parentElement: labelNode.get(0)
              };

              if (opts.ojContext._FixRendererContext) {
                context = opts.ojContext._FixRendererContext(context);
              } // if an element is returned from the renderer and
              // the parent of that element is null, we will append
              // the returned element to the parentElement.
              // If non-null, we won't do anything, assuming that the
              // rendered content has already added into the DOM somewhere.


              var content = optionRenderer.call(opts.ojContext, context);

              if (content !== null) {
                // allow return of document fragment from jquery create or
                // js document.createDocumentFragment
                if (content.parentNode === null || content.parentNode instanceof DocumentFragment) {
                  labelNode.get(0).appendChild(content); // @HTMLUpdateOK

                  contentNode = content;
                }
              }
            } else {
              formatted = opts.formatResult(_result);

              if (formatted !== undefined) {
                labelNode.text(formatted);
                labelNode.attr('aria-label', formatted);
              }
            }

            highlightLabelNode(labelNode);
            return contentNode;
          }; //  - ojselect does not show placeholder text when data option is specified
          //  - placeholder text is a selectable item that results in an error for ojcomponent
          // /ojselect only add placeholder to dropdown if there is no search filter
          // /and not required


          var placeholder = self._getPlaceholder();

          if (showPlaceholder && placeholder !== null && !query.term && container.find('.oj-listbox-placeholder').length <= 0 && (tagName !== 'select' || !self.ojContext._IsRequired())) {
            // create placeholder item
            result = {
              value: '',
              label: placeholder
            };
            node = $('<li></li>');
            node.addClass('oj-listbox-placeholder oj-listbox-results-depth-0 oj-listbox-result oj-listbox-result-selectable');
            node.attr('role', 'presentation');
            label = $(document.createElement('div'));
            label.addClass('oj-listbox-result-label');
            label.attr('id', 'oj-listbox-result-label-' + _ComboUtils.nextUid());
            label.attr('role', 'option');
            formatted = opts.formatResult(result);

            if (formatted !== undefined) {
              label.text(formatted);
            }

            label.attr('aria-label', formatted);
            node.append(label); // @HTMLUpdateOK

            node.data(self._elemNm, result);
            container.prepend(node); // @HTMLUpdateOK
          }

          for (i = 0, l = results.length; i < l; i++) {
            result = results[i];
            disabled = result.disabled === true; // Bug JET-31662 - ISSUE WITH AUTOMATIC SCROLLING IN A JET SELECT LIST WITH A LARGE CUSTOMER-SUPPLIED DATA SET
            // A node will be selectable only if it is a leaf node. For a node to be a leaf node, when using a
            // tree data provider, it should have not have the flag _jetUnSelectable set. When using an
            // observable array, it should not be disabled, should have a non-null value and should not have
            // any children. If result.children is not null, we consider the node be a parent node. This means
            // even if it is an empty array, we still treat it as a parent node with no children.

            selectable = isTreeDataProvider ? !result._jetUnSelectable : !disabled && id(result) != null && result.children == null;
            var isList = result.element && $(result.element[0]).is('li');
            node = isList ? $(result.element[0]) : $('<li></li>');

            if (node.hasClass('oj-listbox-result')) {
              if (result.children && result.children.length > 0) {
                processChildren(node, result);
              }

              highlightLabelNode($(result.element[0]).children('div'));
              $(result.element[0]).css('display', '');
            } else {
              node.addClass('oj-listbox-results-depth-' + depth);
              node.addClass('oj-listbox-result');
              node.addClass(selectable ? 'oj-listbox-result-selectable' : 'oj-listbox-result-unselectable');

              if (disabled) {
                node.addClass('oj-disabled');
              }

              if (result.children) {
                node.addClass('oj-listbox-result-with-children');
              }

              node.attr('role', 'presentation');

              var labelId = 'oj-listbox-result-label-' + _ComboUtils.nextUid();

              label = $(document.createElement('div'));
              label.addClass('oj-listbox-result-label');
              label.attr('id', labelId);
              label.attr('role', 'option');

              if (disabled) {
                label.attr('aria-disabled', 'true');
              } //  - grouping header accessibility issue for jaws
              // build the full path of aria-label ids, which will be referred by the leaf nodes
              // 'ariaLabelledById' property is later used by _processAriaLabelForHierarchy
              // to set 'aria-labelledby' attribute in leaf nodes


              if (resultsParent && resultsParent.ariaLabelledById) {
                result.ariaLabelledById = resultsParent.ariaLabelledById + ' ' + labelId;
              } else {
                result.ariaLabelledById = labelId;
              } // append label to node


              if (!isList) {
                var content = createLabelContent(label, result);
                node.append(label); // @HTMLUpdateOK

                if (content && (content.tagName === 'OJ-OPTION' || content.tagName === 'OJ-OPTGROUP')) {
                  // Update the disabled state on ancestors
                  if (content.getAttribute('disabled')) {
                    node.removeClass('oj-listbox-result-selectable');
                    node.addClass('oj-listbox-result-unselectable oj-disabled');
                    label.attr('aria-disabled', 'true');
                  } // Create text for oj-optgroup


                  if (content.tagName === 'OJ-OPTGROUP' && content.hasAttribute('label')) {
                    // Insert a text node for the label attribute
                    var labelText = content.getAttribute('label');
                    var textNode = document.createTextNode(labelText);
                    content.insertBefore(textNode, content.firstChild); // @HTMLUpdateOK
                  }
                }
              } // process children


              if (result.children && result.children.length > 0) {
                processChildren(node, result);
              }

              node.data(self._elemNm, result);

              if (!isList) {
                container.append(node); // @HTMLUpdateOK
              } else {
                var elem = $(result.element[0]); // oj-optgroup

                if (elem.children('oj-optgroup').length > 0) {
                  var groupLabel = elem.children('oj-optgroup').prop('label') + '';
                  elem.prepend(label.text(groupLabel)); // @HTMLUpdateOK
                } else if (elem.children('oj-option').length > 0) {
                  elem.contents().wrapAll(label); // @HTMLUpdateOK
                } else {
                  // wrap the li contents except the nested ul with wrapping div
                  elem.contents().filter(function () {
                    return this.tagName !== 'UL';
                  }).wrapAll(label); // @HTMLUpdateOK
                }

                highlightLabelNode(elem.children('div'));
                elem.css('display', '');
              }
            }
          }
        }; // /ojselect placehholder


        _populate(null, _results, _container, 0, _showPlaceholder);
      },
      highlightTermInOptions: function highlightTermInOptions(query) {
        return !(query.initial === true);
      }
    }, _ojChoiceDefaults, opts);

    opts.id = function (e) {
      return e.value;
    };

    opts.formatResult = function (result) {
      var label = _ComboUtils.getLabel(result);

      return !isNaN(label) ? this.ojContext._formatValue(label) : label;
    };

    opts.formatSelection = function (data) {
      var label = _ComboUtils.getLabel(data);

      if (data != null && label != null) {
        if (isNaN(label)) {
          return label;
        }

        return this.ojContext._formatValue(label);
      }

      return undefined;
    };

    if (tagName !== 'select' && opts.manageNewEntry !== null) {
      opts.manageNewEntry = function (term) {
        var entry = {};
        entry.label = $.trim(term);
        entry.value = entry.label;
        return entry;
      };
    }

    if (this.datalist) {
      opts.query = this._bind(function (query) {
        var data = {
          results: [],
          more: false
        };
        var term = query.term;
        var children;

        var _process;

        _process = function process(elm, collection) {
          var group;
          var elems;
          var nestedLi = elm.children() && elm.children().length > 0 && (elm.children().is('ul') || elm.children().is('oj-optgroup'));

          if (elm.is('option') || elm.is('oj-option') || elm.is('li') && !nestedLi) {
            if (query.matcher(term, elm.text() || elm.attr('label'), elm)) {
              collection.push(self._optionToData(elm));
            }
          } else if (elm.is('optgroup') || elm.is('oj-optgroup') || elm.is('li') && nestedLi) {
            group = self._optionToData(elm);

            if (elm.is('optgroup') || elm.is('oj-optgroup')) {
              elems = elm.children();
            } else if (elm.children('oj-optgroup')) {
              elems = elm.children().children('ul').children();
            } else {
              elm.children('ul').children();
            }

            _ComboUtils.each2(elems, function (i, el) {
              _process(el, group.children);
            });

            if (group.children.length > 0) {
              collection.push(group);
            }
          }
        };

        children = this.datalist.children(); // /ojselect remove existing placeholder item

        if (this._getPlaceholder() !== undefined && children.length > 0 && children.first().attr('value') === '') {
          children = children.slice(1);
        }

        _ComboUtils.each2(children, function (i, elm) {
          _process(elm, data.results);
        });

        query.callback(data);
      });
    } else if ('options' in opts) {
      var dataOptions = opts.options;

      if (_ComboUtils.getDataProvider(opts)) {
        opts.query = function (query) {
          if (query.value) {
            _ComboUtils.fetchByKeyFromDataProvider(self, opts, query);
          } else {
            _ComboUtils.fetchFromDataProvider(self, opts, query);
          }
        };
      } else if ($.isFunction(dataOptions)) {
        opts.query = _ComboUtils.remote(dataOptions, opts.optionsKeys ? opts.optionsKeys : null);
      } else {
        opts.query = _ComboUtils.local(dataOptions, opts.optionsKeys ? opts.optionsKeys : null);
      }
    }

    return opts;
  },
  // _AbstractOjChoice
  _createHeader: function _createHeader() {
    var headerElem = this.opts.element.find('.oj-listbox-header');

    if (headerElem.length) {
      this.header = $('<li>', {
        class: 'oj-listbox-result-header oj-listbox-result-unselectable',
        role: 'presentation'
      });
      this.header.append(headerElem.children()); // @HTMLUpdateOK

      this._initializeHeaderItems();

      var resultsNHeaderContainer = $('<ul>', {
        class: 'oj-listbox-results-with-header',
        role: 'listbox'
      });
      resultsNHeaderContainer.append(this.header); // @HTMLUpdateOK

      resultsNHeaderContainer.appendTo(this.results.parent()); // @HTMLUpdateOK

      var resultsWrapper = $('<li>', {
        role: 'presentation'
      });
      resultsNHeaderContainer.append(resultsWrapper); // @HTMLUpdateOK

      this.results.attr('role', 'presentation');
      this.results.appendTo(resultsWrapper); // @HTMLUpdateOK
    }

    this.headerInitialized = true;
  },
  _initializeHeaderItems: function _initializeHeaderItems() {
    this.headerItems = this.header.find("li[role='option'], li:not([role])");
    this.headerItems.uniqueId();
    this.header.find('ul').attr('role', 'presentation');
    this.header.find('li:not([role])').attr('role', 'option');
    var selector = 'a, input, select, textarea, button, object, .oj-component-initnode';
    this.header.find(selector).each(function () {
      $(this).attr('tabIndex', -1);
    });
  },
  _isHeaderItem: function _isHeaderItem(item) {
    var isHeaderItem = false;
    this.headerItems.each(function () {
      if ($(this).attr('id') === item) {
        isHeaderItem = true;
        return false;
      }

      return true;
    });
    return isHeaderItem;
  },
  _getNextHeaderItem: function _getNextHeaderItem(currentItem) {
    if (!this.headerItems) {
      return null;
    }

    if (!currentItem) {
      return this.headerItems.first();
    }

    var foundCurrentItem = false;
    var nextItem = null;
    this.headerItems.each(function () {
      if (foundCurrentItem) {
        nextItem = $(this);
        return false;
      }

      foundCurrentItem = $(this).attr('id') === currentItem;
      return true;
    });
    return nextItem;
  },
  _getPreviousHeaderItem: function _getPreviousHeaderItem(currentItem) {
    if (!this.headerItems) {
      return null;
    }

    var previousItem = null;
    this.headerItems.each(function () {
      if ($(this).attr('id') === currentItem) {
        return false;
      }

      previousItem = $(this);
      return true;
    });
    return previousItem;
  },
  _setFocusOnHeaderItem: function _setFocusOnHeaderItem(item) {
    var focusable = item.find('.oj-component .oj-enabled').first();

    if (focusable.length === 0) {
      var selector = 'a, input, select, textarea, button, object, .oj-component-initnode';
      focusable = item.find(selector).first();

      if (focusable.length === 0) {
        focusable = item.children().first();
      }
    }

    if (focusable) {
      focusable.addClass('oj-focus oj-focus-highlight oj-focus-only');
    }
  },
  _removeHighlightFromHeaderItems: function _removeHighlightFromHeaderItems() {
    if (this.headerItems) {
      this.headerItems.find('.oj-focus').removeClass('oj-focus oj-focus-highlight oj-focus-only');
    }
  },
  // _AbstractOjChoice
  _triggerSelect: function _triggerSelect(data) {
    var evt = $.Event(this._elemNm + '-selecting', {
      val: this.id(data),
      object: data
    });
    this.opts.element.trigger(evt);
    return !evt.isDefaultPrevented();
  },
  // _AbstractOjChoice
  _isInterfaceEnabled: function _isInterfaceEnabled() {
    return this.enabledInterface === true;
  },
  // _AbstractOjChoice
  _enableInterface: function _enableInterface() {
    // Readonly support
    var enabled = this._enabled && !(_ComboUtils.isReadonly(this.ojContext) || this._readonly);

    if (enabled === this.enabledInterface) {
      return false;
    } // Readonly support


    if (!_ComboUtils.isReadonly(this.ojContext)) {
      this.container.toggleClass('oj-disabled', !enabled);
    }

    this.close();
    this.enabledInterface = enabled;
    return true;
  },
  // _AbstractOjChoice
  _enable: function _enable(_enabled) {
    var enabled = _enabled;

    if (enabled === undefined) {
      enabled = true;
    }

    if (this._enabled === enabled) {
      return;
    }

    this._enabled = enabled;
    this.opts.element.prop('disabled', !(enabled || _ComboUtils.isReadonly(this.ojContext)));
    this.container.toggleClass('oj-enabled', enabled);

    this._enableInterface();
  },
  // _AbstractOjChoice
  _disable: function _disable() {
    this._enable(false);
  },
  // _AbstractOjChoice
  _readonly: function _readonly(_enabled) {
    var enabled = _enabled;

    if (enabled === undefined) {
      enabled = false;
    }

    if (this._readonly === enabled) {
      return false;
    }

    this._readonly = enabled;
    this.opts.element.prop('readonly', enabled);

    this._enableInterface();

    return true;
  },
  // _AbstractOjChoice
  _opened: function _opened() {
    return this.container.hasClass('oj-listbox-dropdown-open');
  },
  // _AbstractOjChoice
  _getDropdownPositionElement: function _getDropdownPositionElement() {
    return this.container[0].querySelector('.oj-text-field-container');
  },
  // _AbstractOjChoice
  _usingHandler: function _usingHandler(pos, props) {
    // if the input part of the component is clipped in overflow, implicitly close the dropdown popup.
    if (oj.PositionUtils.isAligningPositionClipped(props)) {
      // add busy state
      var resolveBusyState = _ComboUtils._addBusyState(this.container, 'closing popup');

      this._closeDelayTimer = window.setTimeout(function () {
        $.proxy(this.close, this);
        resolveBusyState();
      }, 1);
      return;
    }

    var container = this.container;
    var dropdown = props.element.element;
    dropdown.css(pos);

    if (props.vertical === 'bottom') {
      container.addClass('oj-listbox-drop-above');
      dropdown.addClass('oj-listbox-drop-above');
    } else {
      container.removeClass('oj-listbox-drop-above');
      dropdown.removeClass('oj-listbox-drop-above');
    }
  },
  // _AbstractOjChoice
  _getDropdownPosition: function _getDropdownPosition() {
    var position = {
      my: 'start top',
      at: 'start bottom',
      of: this._getDropdownPositionElement(),
      collision: 'flip',
      using: $.proxy(this._usingHandler, this)
    };
    var isRtl = oj.DomUtils.getReadingDirection() === 'rtl';
    return oj.PositionUtils.normalizeHorizontalAlignment(position, isRtl);
  },
  // _AbstractOjChoice
  _positionDropdown: function _positionDropdown() {
    var dropdown = this.dropdown;

    var position = this._getDropdownPosition();

    var container = this.container;
    dropdown.css('width', container.outerWidth());
    dropdown.position(position);
  },
  // _AbstractOjChoice
  // beforeExpand
  _shouldOpen: function _shouldOpen(e) {
    if (this._opened()) {
      return false;
    } // Readonly support


    if (this._enabled === false || _ComboUtils.isReadonly(this.ojContext) || this._readonly === true) {
      return false;
    }

    var eventData = {
      component: this.opts.element
    };
    return this.ojContext._trigger('beforeExpand', e, eventData);
  },
  // _AbstractOjChoice
  _clearDropdownAlignmentPreference: function _clearDropdownAlignmentPreference() {
    // clear the classes used to figure out the preference of where the dropdown should be opened
    this.container.removeClass('oj-listbox-drop-above');
    this.dropdown.removeClass('oj-listbox-drop-above');
  },
  // _AbstractOjChoice

  /**
     * Opens the dropdown
     *
     * @return {boolean} whether or not dropdown was opened. This method will return false if, for example,
     * the dropdown is already open, or if the 'open' event listener on the element called preventDefault().
     * @ignore
     */
  open: function open(e, dontUpdateResults) {
    if (!this._shouldOpen(e)) {
      return false;
    }

    this._opening(e, dontUpdateResults);

    return true;
  },
  // _AbstractOjChoice
  _opening: function _opening() {
    if (!this.headerInitialized) {
      this._createHeader();
    } // this._clearPlaceholder();


    this.container.addClass('oj-listbox-dropdown-open');
  },
  // _AbstractOjChoice
  _showDropDown: function _showDropDown() {
    if (!this._opened()) {
      // Just to make sure that _opening() method is called before calling
      // the _showDropDown().
      return;
    }

    var alreadyExpanded = this._getActiveContainer().attr('aria-expanded');

    if (alreadyExpanded === 'true') {
      return;
    }

    this._clearDropdownAlignmentPreference(); //  - picking ojselect value using filter and keyboard may cause dropdown close error
    // For signle select only -
    // if popup exists, refresh its content, otherwise create a popup


    var popupRoot = this.dropdown.parent();

    if (this._classNm === 'oj-select' && this.opts.multiple !== true && popupRoot && popupRoot.hasClass('oj-listbox-drop-layer')) {
      oj.PopupService.getInstance().triggerOnDescendents(popupRoot, oj.PopupService.EVENT.POPUP_REFRESH);
    } else {
      if (this.dropdown[0] !== this.body().children().last()[0]) {
        this.dropdown.detach().appendTo(this.body()); // @HTMLUpdateOK
      }

      this.dropdown.appendTo(this.body()); // @HTMLUpdateOK

      if (this.header) {
        this.dropdown.find('.oj-listbox-results-with-header').prepend(this.header); // @HTMLUpdateOK

        this.header.show();
      }

      var psEvents = {};
      psEvents[oj.PopupService.EVENT.POPUP_CLOSE] = $.proxy(this.close, this);
      psEvents[oj.PopupService.EVENT.POPUP_REMOVE] = $.proxy(this._surrogateRemoveHandler, this);
      psEvents[oj.PopupService.EVENT.POPUP_AUTODISMISS] = $.proxy(this._clickAwayHandler, this);
      psEvents[oj.PopupService.EVENT.POPUP_REFRESH] = $.proxy(this._positionDropdown, this);
      /** @type {!Object.<oj.PopupService.OPTION, ?>} */

      var psOptions = {};
      psOptions[oj.PopupService.OPTION.POPUP] = this.dropdown;
      psOptions[oj.PopupService.OPTION.LAUNCHER] = this.opts.element;
      psOptions[oj.PopupService.OPTION.EVENTS] = psEvents;
      psOptions[oj.PopupService.OPTION.POSITION] = this._getDropdownPosition();
      psOptions[oj.PopupService.OPTION.LAYER_SELECTORS] = 'oj-listbox-drop-layer';
      psOptions[oj.PopupService.OPTION.CUSTOM_ELEMENT] = this.ojContext._IsCustomElement();
      oj.PopupService.getInstance().open(psOptions); // move the global id to the correct dropdown

      $('#oj-listbox-drop').removeAttr('id');
      this.dropdown.attr('id', 'oj-listbox-drop');
      var containerId = this.containerId;
      this.dropdown.attr('data-oj-containerid', containerId);
    } // show the elements


    this._positionDropdown(); // /select: accessibility


    this._getActiveContainer().attr('aria-expanded', true);
  },
  // _AbstractOjChoice
  // eslint-disable-next-line no-unused-vars
  close: function close(event, shouldReopenOnNewData) {
    // This is used by the combobox to determine whether the dropdown
    // should be reopened when new data comes
    this.shouldReopenOnNewData = shouldReopenOnNewData === true;

    if (!this._opened()) {
      return;
    }

    this.container.removeClass('oj-listbox-dropdown-open');

    var dropDownVisible = this._getActiveContainer().attr('aria-expanded');

    delete this.ojContext._resolveSearchBoxLater;

    if (!dropDownVisible || dropDownVisible === 'false') {
      return;
    }

    var cid = this.containerId;
    var scroll = 'scroll.' + cid;
    var resize = 'resize.' + cid;
    var orient = 'orientationchange.' + cid; // unbind event listeners

    this.container.parents().add(window).each(function () {
      $(this).off(scroll).off(resize).off(orient);
    });

    this._clearDropdownAlignmentPreference();
    /** @type {!Object.<oj.PopupService.OPTION, ?>} */


    var psOptions = {};
    psOptions[oj.PopupService.OPTION.POPUP] = this.dropdown;
    oj.PopupService.getInstance().close(psOptions);

    if (this.header) {
      // When popup opened header will be shown in the popup.
      // But once it is closed contents of the popup will be removed,
      // but the header should not be detached from the DOM,
      // because knockout binding will be lost. That is why header will be
      // moved under the component container. And when again popup opened
      // it will be added back to the popup.
      this.header.hide();
      this.header.appendTo(this.container); // @HTMLUpdateOK
    }

    this.dropdown.removeAttr('data-oj-containerid');
    this.dropdown.removeAttr('id');

    if (this.opts.list || this.isOjOption) {
      this._removeHighlight();
    } else {
      this.dropdown.detach();
      this.results.empty();
    }

    this.dropdown.appendTo(this.container); // @HTMLUpdateOK
    // /select: accessibility

    this._getActiveContainer().attr('aria-expanded', false);

    if (this._elemNm === 'ojcombobox') {
      this._getActiveContainer().removeAttr('aria-activedescendant');
    } //  - press escape after search in select causes select to become unresponsive


    $.removeData(this.container, this._classNm + '-last-term');
  },
  // _AbstractOjChoice
  _setPickerAttributes: function _setPickerAttributes(pickerAttributes) {
    oj.EditableValueUtils.setPickerAttributes(this.dropdown, pickerAttributes);
  },
  // _AbstractOjChoice
  _clearSearch: function _clearSearch() {},
  // _AbstractOjChoice
  _ensureHighlightVisible: function _ensureHighlightVisible() {
    var results = this.results;
    var children;
    var child;
    var hb;
    var rb;
    var y;
    var more;

    var index = this._highlight();

    if (index < 0) {
      return;
    }

    children = this._findHighlightableChoices();
    child = $(children[index]);
    hb = child.offset().top + child.outerHeight(true); // if this is the last child lets also make sure oj-combobox-more-results is visible

    if (index === children.length - 1) {
      more = results.find('li.oj-listbox-more-results');

      if (more.length > 0) {
        hb = more.offset().top + more.outerHeight(true);
      }
    }

    rb = results.offset().top + results.outerHeight(true);

    if (hb > rb) {
      results.scrollTop(results.scrollTop() + (hb - rb));
    }

    y = child.offset().top - results.offset().top; // make sure the top of the element is visible

    if (y < 0 && child.css('display') !== 'none') {
      results.scrollTop(results.scrollTop() + y); // y is negative
    }
  },
  // _AbstractOjChoice
  _findHighlightableChoices: function _findHighlightableChoices() {
    return this.results.find('.oj-listbox-result-selectable:not(.oj-disabled, .oj-selected)').filter(function () {
      return $(this).css('display') !== 'none';
    });
  },
  // _AbstractOjChoice
  _moveHighlight: function _moveHighlight(delta) {
    var choices = this._findHighlightableChoices();

    var index = this._highlight();

    if (this.header && (index <= 0 || index === choices.length - 1)) {
      var activeDescendant = this._getActiveContainer().attr('aria-activedescendant');

      var isHeaderItem = this._isHeaderItem(activeDescendant);

      if (!isHeaderItem) {
        activeDescendant = null;
      }

      var headerItem = null;

      if (delta > 0 && (index < 0 || index === choices.length - 1)) {
        headerItem = this._getNextHeaderItem(activeDescendant);
      } else if (delta < 0 && (isHeaderItem && index < 0 || index === 0)) {
        headerItem = this._getPreviousHeaderItem(activeDescendant);
      }

      if (headerItem) {
        this._removeHighlight();

        this._setFocusOnHeaderItem(headerItem);

        this._getActiveContainer().attr('aria-activedescendant', headerItem.attr('id'));

        return;
      } else if (isHeaderItem && delta < 0) {
        index = 0;
      }
    }

    while (index >= -1 && index < choices.length) {
      index += delta; // support cycling through the first/last item

      if (index === choices.length) {
        index = 0;
      } else if (index === -1) {
        index = choices.length - 1;
      }

      var choice = $(choices[index]);

      if (choice.hasClass('oj-listbox-result-selectable') && !choice.hasClass('oj-disabled') && !choice.hasClass('oj-selected')) {
        this._highlight(index);

        break;
      }
    }
  },
  // _AbstractOjChoice
  _highlight: function _highlight(_index) {
    var index = _index;

    var choices = this._findHighlightableChoices();

    var choice;

    if (arguments.length === 0) {
      // If no argumnets passed then currently highlighted
      // option will be returned.
      var curSelected = choices.filter('.oj-hover');

      if (!curSelected.length) {
        curSelected = choices.children('.oj-hover').closest('.oj-listbox-result');
      } //  - acc: screenreader not reading ojselect items


      this._updateMatchesCount(curSelected.text());

      return choices.get().indexOf(curSelected[0]);
    }

    if (index >= choices.length) {
      index = choices.length - 1;
    }

    if (index < 0) {
      index = 0;
    }

    this._removeHighlight();

    choice = $(choices[index]);

    if (choice.hasClass('oj-listbox-result-with-children')) {
      var sels = choice.children('.oj-listbox-result-label');
      sels.addClass('oj-hover'); //  - acc: screenreader not reading ojselect items

      this._updateMatchesCount(sels.text());
    } else {
      choice.addClass('oj-hover'); //  - acc: screenreader not reading ojselect items

      this._updateMatchesCount(choice.text());
    } // ensure assistive technology can determine the active choice
    // /select: accessibility


    this._getActiveContainer().attr('aria-activedescendant', choice.find('.oj-listbox-result-label').attr('id'));

    this._ensureHighlightVisible();

    return 0;
  },
  // _AbstractOjChoice
  _removeHighlight: function _removeHighlight() {
    this.results.find('.oj-hover').removeClass('oj-hover');

    this._removeHighlightFromHeaderItems();

    if (this._elemNm === 'ojcombobox') {
      this._getActiveContainer().removeAttr('aria-activedescendant');
    }
  },
  // _AbstractOjChoice
  _highlightUnderEvent: function _highlightUnderEvent(event) {
    var el = $(event.target).closest('.oj-listbox-result-selectable');

    if (el.length > 0 && !el.is('.oj-hover')) {
      var choices = this._findHighlightableChoices();

      this._highlight(choices.index(el));
    } else if (el.length === 0) {
      // if we are over an unselectable item remove all highlights
      this._removeHighlight();
    }
  },
  // _AbstractOjChoice
  _updateMatchesCount: function _updateMatchesCount(translatedString) {
    // write to this liveRegion only when the dropdown message box doesn't exist
    if (!this.dropdown.find('.oj-listbox-filter-message-text').length) {
      var liveRegion = this.container.find('.oj-listbox-liveregion');

      if (liveRegion.length) {
        liveRegion.text(translatedString);
      }
    }
  },
  // _AbstractOjChoice
  _updateResults: function _updateResults(initial, force) {
    var search = this.search;
    var self = this;
    var term = search.val();
    var lastTerm = $.data(this.container, this._classNm + '-last-term'); // prevent duplicate queries against the same term
    // not applying to multi select since user can search the same term after making selection
    // it's ok for single select since the last term will be updated after selection

    if (initial !== true && lastTerm && term === lastTerm && this.opts.multiple !== true && !force) {
      return;
    } // In IE even for chnage of placeholder fires 'input' event,
    // so in such cases we don't need to query for results.


    if (!lastTerm && !term && initial && initial.type === 'input') {
      return;
    }

    $.data(this.container, this._classNm + '-last-term', term);
    var minLength = this.opts.minLength || 0;

    if (term.length >= minLength) {
      if (this._queryTimer) {
        this._queryTimer.clear();
      }

      if (!initial || initial === true) {
        this._queryResults(initial);
      } else {
        this._queryResolveBusyState = _ComboUtils._addBusyState(this.container, 'query results');
        this._queryTimer = TimerUtils.getTimer(_ComboUtils.DEFAULT_QUERY_DELAY);

        this._queryTimer.getPromise().then(function (completed) {
          if (completed) {
            self._queryResults(initial);
          }
        }).then(this._queryResolveBusyState);
      }
    } else {
      this.close();
    }
  },
  // _AbstractOjChoice
  _queryResults: function _queryResults(initial) {
    var search = this.search;
    var results = this.results;
    var opts = this.opts;
    var self = this;
    var input;
    var term = search.val(); // sequence number used to drop out-of-order responses

    var queryNumber = 0;
    var minLength = opts.minLength || 0;

    if (minLength > term.length) {
      this.close();
      return;
    }

    this.open(null, true);

    function postRender() {
      self._positionDropdown();

      if (self.header && self.headerItems.length) {
        var highlightableChoices = self._findHighlightableChoices();

        var totalOptions = self.headerItems.length + highlightableChoices.length;
        self.headerItems.attr('aria-setsize', totalOptions);

        if (highlightableChoices.length) {
          var highlightableOptions = highlightableChoices.children("[role='option']");
          highlightableOptions.attr('aria-setsize', totalOptions);
          highlightableOptions.first().attr('aria-posinset', self.headerItems.length + 1);
        }
      }
    }

    this.queryCount += 1;
    queryNumber = this.queryCount;

    this._removeHighlight();

    input = this.search.val();

    if (input !== undefined && input !== null && (initial !== true || opts.inputSearch || opts.filterOnOpen === 'rawValue' || opts.minLength > 0)) {
      term = input;
    } else {
      term = '';
    }

    this.resultsPage = 1;
    opts.query({
      element: opts.element,
      term: term,
      page: this.resultsPage,
      context: null,
      matcher: opts.matcher,
      callback: this._bind(function (data) {
        // ignore old responses
        if (queryNumber !== this.queryCount) {
          return;
        } // ignore a response if the oj-combobox has been closed before it was received


        if (!this._opened()) {
          return;
        } // clear dropdown message if any


        if (!opts.ojContext._hasMore) {
          _ComboUtils.removeDropdownMessage(self.dropdown);
        } // save context, if any


        this.context = !data || data.context === undefined ? null : data.context; // create a default choice and prepend it to the list

        if ((!data || data.results && data.results.length === 0 || this._isDataSelected(data) && this.ojContext.isValid()) && _ComboUtils.checkFormatter(self.ojContext, opts.formatNoMatches, 'formatNoMatches')) {
          var transtr = opts.formatNoMatches(self.ojContext, search.val());

          if (this._classNm === 'oj-select' || this.header) {
            this._showDropDown();

            this._preprocessResults(results);

            postRender();

            _ComboUtils.addDropdownMessage(self.dropdown, self.ojContext, transtr); // if no search box, don't need a separator


            if (!this._hasSearchBox()) {
              var separator = self.dropdown.find('.oj-listbox-filter-message-separator');

              if (separator.length) {
                separator.css('display', 'none');
              }
            }
          } else {
            this.close(null, true);
          }

          this._updateMatchesCount(transtr);

          return;
        }

        _ComboUtils.saveLastQueryResult(this, data.results);

        this._showDropDown();

        this._preprocessResults(results);

        self.opts.populateResults.call(this, results, data.results, {
          term: search.val(),
          page: this.resultsPage,
          context: null,
          initial: initial
        }, this._showPlaceholder());

        this._postprocessResults(data, initial);

        postRender();

        this._updateMatchesCount(opts.formatMoreMatches(self.ojContext, this._findHighlightableChoices().length));
      })
    });
  },
  // _AbstractOjChoice
  _preprocessResults: function _preprocessResults(results) {
    if (this.opts.list || this.isOjOption) {
      var resultList = results.children(); // hide the list items

      this._hideResultList(resultList);
    } else {
      results.empty();
    }
  },
  // _AbstractOjChoice
  _processAriaLabelForHierarchy: function _processAriaLabelForHierarchy() {
    //  - grouping header accessibility issue for jaws
    // For Hierarchical data, screen reader should read:
    // 1. the label full-path for the first and last node at the leaf level
    // 2. the label for the nodes between first and last node at the leaf level
    var compound = this.results.find('.oj-listbox-result-with-children');

    if (compound.length === 0) {
      return;
    }

    var self = this;

    var setAriaLabelledBy = function setAriaLabelledBy(node) {
      var nodeLabel = node.find('.oj-listbox-result-label');
      var ariaLabelledById = node.data(self._elemNm).ariaLabelledById;

      if (ariaLabelledById && nodeLabel) {
        nodeLabel.attr('aria-labelledby', ariaLabelledById);
      }
    };

    _ComboUtils.each2(compound, function (i, choice) {
      // process aria-labelledby attribute for the selectable and visible leaf nodes
      var leafNodes = choice.find('.oj-listbox-result-selectable:visible'); // first and last node at the leaf level should have the
      // aria-labelledby pointing to the full-path of labelIds

      if (leafNodes && leafNodes.length > 0) {
        // first leaf node
        setAriaLabelledBy($(leafNodes[0])); // last leaf node

        if (leafNodes.length > 1) {
          setAriaLabelledBy($(leafNodes[leafNodes.length - 1]));
        }
      }
    });
  },
  // _AbstractOjChoice
  _normalizeHighlighterLabel: function _normalizeHighlighterLabel(item) {
    var highlighterSection;

    if (item.children('div').children('oj-option').length > 0) {
      // The text may be wrapped inside another span with foreach data-bind
      highlighterSection = item.children('div').children('oj-option').find('oj-highlight-text');
    } else {
      highlighterSection = item.children('div').children('oj-highlight-text');
    }

    if (highlighterSection.length > 0) {
      for (var i = 0; i < highlighterSection.length; i++) {
        var ojHighlightTextElem = highlighterSection[i];
        var text = ojHighlightTextElem.getAttribute('text') || '';
        var textNode = document.createTextNode(text); // replace the oj-highlight-text with the old text node

        ojHighlightTextElem.parentElement.replaceChild(textNode, ojHighlightTextElem);
      }
    }
  },
  // _AbstractOjChoice
  _hideResultList: function _hideResultList(resultList) {
    for (var i = 0; i < resultList.length; i++) {
      var item = $(resultList[i]);

      if (item.is('LI')) {
        if (item.hasClass('oj-listbox-no-results') || item.hasClass('oj-listbox-placeholder')) {
          item.remove();
        }

        item.css('display', 'none');

        if (item.hasClass('oj-selected')) {
          item.removeClass('oj-selected');
        } // remove highlighter section and merge back text nodes


        this._normalizeHighlighterLabel(item);
      }

      var nested;

      if (item.children('oj-optgroup')) {
        nested = item.children('oj-optgroup').children('ul');
      } else {
        nested = item.children('ul');
      }

      if (nested && nested.children()) {
        this._hideResultList(nested.children());
      }
    }
  },
  // _AbstractOjChoice
  _cancel: function _cancel(event) {
    this.close(event);
  },
  // _AbstractOjChoice
  _focusSearch: function _focusSearch() {
    _ComboUtils._focus(this, this.search);
  },
  // _AbstractOjChoice
  _selectHighlighted: function _selectHighlighted(_options, event) {
    var options = _options;

    if (this.header) {
      var activeDescendant = this._getActiveContainer().attr('aria-activedescendant');

      if (this._isHeaderItem(activeDescendant)) {
        // There can be clickable elements in the custom header and
        // which can also be selected through UP/DOWN arrow keys.
        // When such header elements selected through keyboard
        // they should work as if they have clicked.
        // That is why simulating the click on header options.
        var activeItem = $('#' + activeDescendant);
        var selector = 'a, input, select, textarea, button, object';
        var clickable = activeItem.find(selector).first();

        if (clickable.length === 0) {
          clickable = activeItem.children();
        }

        if (clickable.length) {
          clickable[0].click();
        }

        this.close(event);
        return;
      }
    }

    var index = this._highlight();

    var highlighted = this.results.find('.oj-hover');
    var data = highlighted.closest('.oj-listbox-result').data(this._elemNm);

    if (data) {
      this._highlight(index);

      var previousValue = this.getVal();
      options = options || {};
      options.trigger = _ComboUtils.ValueChangeTriggerTypes.OPTION_SELECTED;

      var onSelectReturn = this._onSelect(data, options, event);

      if (onSelectReturn instanceof Promise) {
        onSelectReturn.then(this._bind(function (result) {
          if (result) {
            // trigger events only if the value is set
            this._triggerUpdateEvent(data, options, event);

            this._triggerValueUpdatedEvent(data, previousValue);
          }
        }));
      } else if (onSelectReturn !== false) {
        // Need to trigger the events even when onSelectReturn is null
        // as the events should be triggered even when setting the same value again
        this._triggerUpdateEvent(data, options, event);

        this._triggerValueUpdatedEvent(data, previousValue);
      } // no need to wait for _onSelect to be resolved for as the
      // setting the flag is response to the event and not setting the value.


      if (event && event.type === 'keydown') {
        // This flag will be used in "keyup" event handler to avoid
        // the re-process of the event.
        this.enterKeyEventHandled = true;
      }
    }
  },
  // _AbstractOjChoice
  _getPlaceholder: function _getPlaceholder() {
    return this.opts.element.attr('placeholder') || this.opts.element.attr('data-placeholder') || // jquery 1.4 compat
    this.opts.element.data('placeholder') || this.opts.placeholder;
  },
  // _AbstractOjChoice
  _setPlaceholder: function _setPlaceholder() {
    var placeholder = this._getPlaceholder(); // placeholder text of selectMany is in the <li> of this.selection


    if (this.ojContext.multiple && this._classNm === 'oj-select') {
      var defLi = this.selection.find('.oj-select-default');

      if (defLi.length > 0) {
        defLi.text(placeholder);
      } else {
        this._clearSearch();
      }
    } else if (!placeholder) {
      this.search.removeAttr('placeholder');
    } else {
      this.search.attr('placeholder', placeholder);
    }
  },
  // _AbstractOjChoice
  _initContainerWidth: function _initContainerWidth() {
    function resolveContainerWidth() {
      var style;
      var attrs;
      var matches;
      var i;
      var l;
      var attr; // check if there is inline style on the element that contains width

      style = this._getAttribute('style');

      if (style !== undefined && style !== null) {
        attrs = style.split(';');

        for (i = 0, l = attrs.length; i < l; i++) {
          attr = attrs[i].replace(/\s/g, '');
          matches = attr.match(/^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i);

          if (matches !== null && matches.length >= 1) {
            return matches[1];
          }
        }
      }

      return null;
    }

    var width = resolveContainerWidth.call(this);

    if (width !== null) {
      this.container.css('width', width);
    }
  },
  //  - selected value got replaced once the label for initial value is available
  valHasChanged: function valHasChanged() {
    var container = this.container;

    if (_ComboUtils.duringFetchByKey(container)) {
      _ComboUtils.setValueChanged(this.ojContext, true); // remove loading indicator


      var spinnerContainer = this.selection;

      if (spinnerContainer._saveLoadingIndicator && !this.ojContext.multiple) {
        _ComboUtils.removeLoadingIndicator(spinnerContainer);
      }
    }
  },
  // _AbstractOjChoice
  getVal: function getVal() {
    return this.ojContext.option('value');
  },
  // _AbstractOjChoice
  getRawValue: function getRawValue() {
    return this.ojContext.option('rawValue');
  },
  // _AbstractOjChoice
  // /pass original event

  /**
     * Sets the value
     * @instance
     * @ignore
     * @param {any} val The value to be set
     * @param {jQuery.Event=} event The event at which the method is invoked
     * @param {object} context Context
     * @return {Promise|boolean|null} Result of setting the value
     *                                * Promise when using async validators
     *                                * boolean when using sync validators / when setting the value without validators
     *                                * null when setValue is not invoked since there was no change in the value
     */
  setVal: function setVal(val, event, context) {
    //  - selected value got replaced once the label for initial value is available
    this.valHasChanged();
    var options = {
      doValueChangeCheck: false
    };

    if (context) {
      options._context = context;
    } //  - need to be able to specify the initial value of select components bound to dprv


    var multiple = this.ojContext.multiple;

    if (!this._skipSetValueOptions) {
      //  - resetting value when value-option and placeholder are set throws exception
      if (_ComboUtils.isValueForPlaceholder(multiple, val) && this._getPlaceholder() !== null) {
        this.setValOpts(_ComboUtils.getFixupValueOptionsForPlaceholder(multiple));
      } else {
        var queryResult = _ComboUtils.getLastQueryResult(this);

        var match;

        if (queryResult) {
          if (multiple) {
            match = _ComboUtils.findOptions(queryResult, val);
          } else {
            match = _ComboUtils.findOption(queryResult, val);
          }
        } // set valueOption


        if (match) {
          // clone valueOption otherwise it will not trigger change event
          this.setValOpts(match);
        } else if (this._classNm === 'oj-combobox') {
          // new entry?
          this.ojContext._resolveValueOptionsLater = _ComboUtils.findOption(this.getValOpts(), val) != null;
        } else {
          this.ojContext._resolveValueOptionsLater = true;
        }
      }
    } // Fix  - CUSTOM MESSAGES ARE BEING CLEARED WHEN THE VALUE DOESN'T CHANGE
    // If the value has not changed, bypass the call to _SetValue method in EditableValue.
    // Because we don't have to set the value again in EditableValue.
    // Note:
    // 1. If there are component validation errors the value may not reflect the display value,
    // hence set value if the component has invalid messages even if the value has not changed.
    // 2. If there are custom error messages set via 'messagesCustom' attribute, the value will reflect
    // the display value and so no need to set value if the value has not changed.
    // 3. If the user is search filtering and re-selecting the same value in ojSingleCombobox (),
    // value won't be changed.  However the display value could be modified due to search operation.
    // So update the display value for ojSingleCombobox if the value has not changed.


    var previousVal = this.getVal();
    var setValueResult = null;

    if (!Array.isArray(val) && !this.ojContext._IsCustomElement()) {
      //  - select needs implementation fixes...
      // 1. _SetValue() compares the value passed in to the last saved display value. This is
      // from ADF and is useful for comparing display values for inputs but since combo sets an
      // array, this check is not needed.
      // 2. To bypass the check call this method when the value has changed and with the
      // additional parameter.
      if (!oj.Object.compareValues(previousVal, [val]) || _ComboUtils.hasInvalidComponentMessages(this.ojContext)) {
        setValueResult = this.ojContext._SetValue([val], event, options);
      } else if (this._classNm === 'oj-combobox' && !multiple) {
        this.ojContext._SetDisplayValue([val]);
      }
    } else {
      // eslint-disable-next-line no-lonely-if
      if (!oj.Object.compareValues(previousVal, val) || _ComboUtils.hasInvalidComponentMessages(this.ojContext)) {
        //  - select needs implementation fixes...
        setValueResult = this.ojContext._SetValue(val, event, options);
      } else if (this._classNm === 'oj-combobox' && !multiple) {
        this.ojContext._SetDisplayValue(val);
      }
    }

    return setValueResult;
  },
  getValOpts: function getValOpts() {
    var ojContext = this.ojContext;
    return ojContext.multiple ? ojContext.option('valueOptions') : ojContext.option('valueOption');
  },
  setValOpts: function setValOpts(valOpts) {
    var ojContext = this.ojContext;
    var multiple = ojContext.multiple;

    var fixupValOpts = _ComboUtils.getFixupValueOptionsForPlaceholder(multiple);

    var oldValOpts = multiple ? ojContext.options.valueOptions : ojContext.options.valueOption; // dont fire option change event if the valueOption(s) already represents a placeholder

    if (_ComboUtils.isValueOptionsForPlaceholder(multiple, valOpts) && _ComboUtils.isValueOptionsForPlaceholder(multiple, oldValOpts) && _ComboUtils.isPlaceholderSpecified(ojContext.options)) {
      if (multiple) {
        ojContext.options.valueOptions = fixupValOpts;
      } else {
        ojContext.options.valueOption = fixupValOpts;
      }
    } else if (!oj.Object.compareValues(valOpts, this.getValOpts())) {
      _ComboUtils.setValueOptions(ojContext, valOpts);
    }

    if (multiple) {
      this.opts.valueOptions = valOpts;
    } else {
      this.opts.valueOption = valOpts;
    }
  },
  // _AbstractOjChoice
  // eslint-disable-next-line no-unused-vars
  _triggerUpdateEvent: function _triggerUpdateEvent(val, context, event) {// This method is overridden in OjInputSeachContainer to fire the
    // "update" event. As this event is relevant for only ojInputSearch,
    // there is no default implementation.
  },
  // _AbstractOjChoice
  // eslint-disable-next-line no-unused-vars
  _triggerValueUpdatedEvent: function _triggerValueUpdatedEvent(data, previousValue) {// This method is overridden in OjSingleCombobox to fire the
    // "ojValueUpdated" custom event. As this event is relevant for only oj-combobox-one,
    // there is no default implementation.
  },
  // _AbstractOjChoice
  // /ojselect placeholder
  _showPlaceholder: function _showPlaceholder() {
    return false;
  },
  // _AbstractOjChoice
  // select: accessibility
  _getActiveContainer: function _getActiveContainer() {
    return this.search;
  },
  // _AbstractOjChoice
  _getAttribute: function _getAttribute(id) {
    return this.opts.ojContext._IsCustomElement() ? this.opts.ojContext.OuterWrapper.getAttribute(id) : this.opts.element.attr(id);
  },

  /**
   * Retrieves the value of the attributed transferred by the framework.
   *
   * @param {string} id The attribute whose value has to be retrieved
   * @return {string?} The value of the attribute if specified
   *
   * @memberof! _AbstractOjChoice
   * @instance
   * @private
   */
  _getTransferredAttribute: function _getTransferredAttribute(id) {
    return this.opts.element.attr(id);
  },
  // _AbstractOjChoice
  _showSearchBox: function _showSearchBox(searchText) {
    var focusOnSearchBox = false;
    var searchBox = this.dropdown.find('.oj-listbox-search');

    if (searchBox) {
      // hide and show the search box
      if (this._hasSearchBox()) {
        this.dropdown.find('.oj-listbox-search-wrapper').removeClass('oj-helper-hidden-accessible');
        $(searchBox).removeAttr('aria-hidden');
        this.search.val(searchText);
        focusOnSearchBox = true;
      } else {
        this.dropdown.find('.oj-listbox-search-wrapper').addClass('oj-helper-hidden-accessible');
        $(searchBox).attr('aria-hidden', 'true');
      }
    } // if search box is being displayed, focus on the search box otherwise focus on the select box


    _ComboUtils._focus(this, focusOnSearchBox ? this.search : this.selection); // /disable "click" on spyglass


    if (focusOnSearchBox) {
      var self = this;
      searchBox.find('.oj-listbox-spyglass-box').on('mouseup click', function (e) {
        self.search.focus(); //  - select and combobox stop keyboard event propegation

        e.preventDefault();
      });
    }
  },
  // _AbstractOjChoice
  _hasSearchBox: function _hasSearchBox() {
    if (this._userTyping) {
      return true;
    }

    var threshold = this.opts.minimumResultsForSearch;
    var len;

    if (this.opts.list) {
      len = $('#' + this.opts.list).find('li').length;
    } else if (_ComboUtils.isDataProvider(this.opts.options)) {
      //  - search not shown before typing a character
      // in case of dataProvider and if data is not available,
      // return true temporary, but resolve later when data is ready
      if (this.ojContext._resultCount === undefined) {
        len = threshold + 1;
        this.ojContext._resolveSearchBoxLater = true;
      } else {
        len = this.ojContext._resultCount;
        delete this.ojContext._resolveSearchBoxLater;
      }
    } else if (this.datalist) {
      if (this.ojContext._IsCustomElement()) {
        // get the count of oj-options
        len = this.datalist.children().find('oj-option').length;
      } else {
        // get the length from the select options
        len = this.datalist[0].length;
      }
    } else if (this.opts.options) {
      len = this.opts.options.length;
    }

    return len > threshold;
  },
  // eslint-disable-next-line no-unused-vars
  _isDataSelected: function _isDataSelected(data) {
    return false;
  },
  _findItem: function _findItem(list, value) {
    for (var i = 0; i < list.length; i++) {
      if ($(list[i]).data(this._elemNm).value === value) {
        return list[i];
      }
    }

    return null;
  }
});



/**
 * @preserve Copyright 2012 Igor Vaynberg
 *
 * This software is licensed under the Apache License, Version 2.0 (the "Apache License") or the GNU
 * General Public License version 2 (the "GPL License"). You may choose either license to govern your
 * use of this software only upon the condition that you accept all of the terms of either the Apache
 * License or the GPL License.
 *
 * You may obtain a copy of the Apache License and the GPL License at:
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 * http://www.gnu.org/licenses/gpl-2.0.html
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * Apache License or the GPL Licesnse is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the Apache License and the GPL License for
 * the specific language governing permissions and limitations under the Apache License and the GPL License.
 */

/* global _ComboUtils:false, _AbstractOjChoice:false, Logger:false, Promise:false */

/**
 * @private
 */
var _AbstractSingleChoice = _ComboUtils.clazz(_AbstractOjChoice, {
  // _AbstractSingleChoice
  _enableInterface: function _enableInterface() {
    if (_AbstractSingleChoice.superclass._enableInterface.apply(this, arguments)) {
      this.search.prop('disabled', !(this._isInterfaceEnabled() || _ComboUtils.isReadonly(this.ojContext)));
    }
  },
  // _AbstractSingleChoice
  _focus: function _focus() {
    this.close();
  },
  // _AbstractSingleChoice
  _destroy: function _destroy() {
    $("label[for='" + this.search.attr('id') + "']").attr('for', this.opts.element.attr('id'));

    _AbstractSingleChoice.superclass._destroy.apply(this, arguments);
  },
  // _AbstractSingleChoice
  _clear: function _clear(event) {
    var data = this.selection.data(this._elemNm);

    if (data) {
      // guard against queued quick consecutive clicks
      // This method will be invoked with or without event but 'data' will be null when it is invoked without event.
      // This logic is intended to clear the existing value when user manualy removes text in placeholder input box(which only happens for Combobox).
      // Ideally we should pass event, when we invoke _SetValue() if it is invoked on a UI action. So adding a warning message if event is null.
      if (!event) {
        Logger.warn('Event should not be null when user modified the value in UI');
      } //  - error 'value is required' is shown even though it has a value
      // only clear value when it's not "select" and "required"


      var emptyVal = this.ojContext._IsCustomElement() ? '' : [];

      if (this._classNm !== 'oj-select' || !this.ojContext._IsRequired()) {
        this.setVal(emptyVal, event);
      }

      this.search.val('');
      this.selection.removeData(this._elemNm);
    }

    this._setPlaceholder();
  },
  // _AbstractSingleChoice
  _initSelection: function _initSelection() {
    //  - need to be able to specify the initial value of select components bound to dprv
    if (!_ComboUtils.applyValueOptions(this, this.opts)) {
      var element = this.datalist ? this.datalist : this.opts.element;
      this.opts.initSelection.call(null, element, this._bind(this._updateSelectedOption));
    }
  },
  // _AbstractSingleChoice
  _containerKeydownHandler: function _containerKeydownHandler(e) {
    if (!this._isInterfaceEnabled()) {
      return;
    }

    if (e.which === _ComboUtils.KEY.PAGE_UP || e.which === _ComboUtils.KEY.PAGE_DOWN) {
      // prevent the page from scrolling
      e.preventDefault();
      return;
    }

    switch (e.which) {
      case _ComboUtils.KEY.UP:
      case _ComboUtils.KEY.DOWN:
        if (this._opened()) {
          this._moveHighlight(e.which === _ComboUtils.KEY.UP ? -1 : 1);
        } else {
          this.open(e);
        } //  - select and combobox stop keyboard event propegation


        e.preventDefault();
        return;

      case _ComboUtils.KEY.ENTER:
        // Fix :  PRESSING 'ENTER' WITHIN DROPDOWN SHOULD NOT PROPAGATE
        if (this._opened()) {
          e.stopPropagation();
        }

        this._selectHighlighted(null, e); //  - select and combobox stop keyboard event propegation


        e.preventDefault();

        if (!this._opened()) {
          this._userTyping = false;
        }

        return;

      case _ComboUtils.KEY.TAB:
        this.close(e);
        this._userTyping = false;
        return;

      case _ComboUtils.KEY.ESC:
        if (this._opened()) {
          // prevent the page from scrolling
          e.preventDefault();
        }

        this._cancel(e);

        this._userTyping = false;
        return;

      default:
        break;
    } // /ojselect: used by select


    this._userTyping = true;
  },
  // _AbstractSingleChoice
  _containerKeyupHandler: function _containerKeyupHandler(e) {
    if (this._isInterfaceEnabled()) {
      if (!this._opened()) {
        this.open(e);
      }
    }
  },
  // _AbstractSingleChoice
  _initContainer: function _initContainer() {
    var container = this.container; //  - ojselect id attribute on oj-select-choice div is not meaningful

    var rootAttr = this.opts.rootAttributes;
    var idSuffix = rootAttr && rootAttr.id ? rootAttr.id : this._getAttribute('id') || _ComboUtils.nextUid();

    var ariaLabel = this._getTransferredAttribute('aria-label');

    var ariaControls = this._getTransferredAttribute('aria-controls');

    var selection = container.find('.' + this._classNm + '-choice');
    this.selection = selection;
    this._contentElement = this._elemNm === 'ojcombobox' ? this.search : this.selection; //  - ojselect missing id attribute on oj-select-choice div

    selection.attr('id', this._classNm + '-choice-' + idSuffix); // add aria associations

    selection.find('.' + this._classNm + '-input').attr('id', this._classNm + '-input-' + idSuffix);

    if (!this.results.attr('id')) {
      this.results.attr('id', 'oj-listbox-results-' + idSuffix);
    }

    var liveRegion = container.find('.oj-listbox-liveregion');

    if (liveRegion.length) {
      liveRegion.attr('id', 'oj-listbox-live-' + idSuffix);
    } //  - Accessibility : JAWS does not read aria-controls attribute set on ojselect


    if (this._classNm !== 'oj-select') {
      this.search.attr('aria-owns', this.results.attr('id'));
    }

    if (!this.ojContext._IsCustomElement()) {
      var elementLabel = $("label[for='" + this._getAttribute('id') + "']");

      if (!elementLabel.attr('id')) {
        elementLabel.attr('id', this._classNm + '-label-' + idSuffix);
      }

      this.search.attr('aria-labelledby', elementLabel.attr('id'));
      this.opts.element.attr('aria-labelledby', elementLabel.attr('id'));

      if (this.search.attr('id')) {
        elementLabel.attr('for', this.search.attr('id'));
      }
    }

    if (ariaLabel) {
      this.search.attr('aria-label', ariaLabel);
    }

    if (ariaControls) {
      this.search.attr('aria-controls', ariaControls);
    }

    selection.on('keydown', this._bind(this._containerKeydownHandler)); // selection.on("keyup-change input", this._bind(this._containerKeyupHandler));

    selection.on('mousedown', this._bind(function (e) {
      // if the mousedown target is the end slot or if the interface is not enabled, do nothing
      if (e.target.getAttribute('slot') === 'end' || $(this._endSlot).find(e.target).length > 0 || !this._isInterfaceEnabled()) {
        return;
      } // /prevent user from focusing on disabled select


      if (this.opts.element.prop('disabled')) {
        _ComboUtils.killEvent(e);
      } // if select box gets focus ring via keyboard event previously, clear it now


      selection.removeClass('oj-focus-highlight');

      if (this._opened()) {
        this.close(e);
      } else if (this._isInterfaceEnabled()) {
        this.open(e);
      } //  - keyboard flashes briefly on ios.


      var hidden = this.search.parent().attr('aria-hidden');

      if (hidden && hidden === 'true') {
        this.selection.focus();
      } else {
        this.search.focus();
      } // prevent focus move back


      if ($(e.target).hasClass('oj-combobox-open-icon')) {
        _ComboUtils.killEvent(e);
      }

      this.container.addClass('oj-active');
    }));
    selection.on('mouseup', this._bind(function () {
      this.container.removeClass('oj-active');
    }));
    selection.on('focus', this._bind(function (e) {
      _ComboUtils.killEvent(e);
    }));
    this.search.on('compositionstart', this._bind(function () {
      // See _isComposing in InputBase for comments on what this does
      this.ojContext._isComposing = true;
    }));
    this.search.on('compositionend', this._bind(function (e) {
      this.ojContext._isComposing = false;

      this._onSearchInputHandler(e);
    }));
    this.search.on('input', this._bind(function (e) {
      if (!this.ojContext._isComposing) {
        this._onSearchInputHandler(e);
      }
    }));
    this.search.on('focus', this._bind(function () {
      this._previousDisplayValue = this.search.val();
    }));
    this.search.on('blur keyup', this._bind(function (e) {
      if (e.type === 'keyup' && e.keyCode !== 10 && e.keyCode !== 13) {
        return;
      }

      if (this.search.val() !== undefined && this.results.find('.oj-hover').length <= 0 && (e.type !== 'keyup' || !this.enterKeyEventHandled)) {
        // Call _onSelect if no previous data and there is typed in text
        // or the previous data is different from typed in text
        if (this.opts.manageNewEntry) {
          var value = this.search.val();
          var valopt = this.opts.manageNewEntry(value);
          var trigger = e.type === 'blur' ? _ComboUtils.ValueChangeTriggerTypes.BLUR : _ComboUtils.ValueChangeTriggerTypes.ENTER_PRESSED;
          var options = {
            trigger: trigger
          };
          var selectionData = this.selection.data(this._elemNm);
          var previousValue = this.getVal();

          if (!selectionData && value !== '' || selectionData && selectionData.label !== value || !this.ojContext.isValid() && value !== this._previousDisplayValue) {
            var onSelectReturn = this._onSelect(valopt, options, e);

            if (e.type !== 'blur') {
              if (onSelectReturn instanceof Promise) {
                onSelectReturn.then(this._bind(function (result) {
                  if (result) {
                    // trigger events only if the value is set
                    this._triggerUpdateEvent(valopt, options, e);

                    this._triggerValueUpdatedEvent(valopt, previousValue);
                  }
                }));
              } else if (onSelectReturn !== false) {
                // Need to trigger the events even when onSelectReturn is null
                // as the events should be triggered even when setting the same value again
                this._triggerUpdateEvent(valopt, options, e);

                this._triggerValueUpdatedEvent(valopt, previousValue);
              }
            }
          } else if (e.type === 'keyup') {
            // if the value stays the same, we still want to fire valueUpdated event to support search use cases
            if (selectionData && selectionData.label === value) {
              valopt = selectionData;
            } // Close the dropdown


            this.close(e);

            this._triggerUpdateEvent(valopt, options, e);

            this._triggerValueUpdatedEvent(valopt, previousValue);
          }
        } else if (this.opts.manageNewEntry == null) {
          var data = this.selection.data(this._elemNm);

          if (this.search.val() === '') {
            if (this._classNm !== 'oj-select') {
              this._clear(e);
            }
          } else if (!data && this.search.val() !== '') {
            this._clearSearch();
          } else if (this._classNm !== 'oj-select') {
            //  - typing in search text & pressing enter, changes user entered search text
            var formatted = this.opts.formatSelection(data);

            if (formatted !== undefined) {
              this.search.val(formatted);
            }
          }
        }
      } // Clear up the focus classes on blur event


      if (e.type === 'blur') {
        this.search.removeClass(this._classNm + '-focused');
        this.container.removeClass('oj-focus');
      } // Clearing the flag which is set while processing the keydown event
      // in _selectHighlighted() method.


      this.enterKeyEventHandled = false;
    }));

    this._initContainerWidth();

    this.opts.element.hide().attr('aria-hidden', true);

    this._setPlaceholder();
  },

  /**
   * Handles input event and compositionend event for the search field
   * @param {jQuery.Event} event input/compositionend event triggered on the search field
   * @private
   */
  _onSearchInputHandler: function _onSearchInputHandler(event) {
    if (this._classNm === 'oj-combobox') {
      // When user types in something into the combobox, mark it dirty
      // and this will be used when deciding what should be used
      // for validation
      this.hasUncommittedValue = true;
    }

    this.ojContext._SetRawValue(this.search.val(), event);
  },
  // _AbstractSingleChoice
  _prepareOpts: function _prepareOpts() {
    var opts = _AbstractSingleChoice.superclass._prepareOpts.apply(this, arguments);

    var self = this; // /ojselect set initial selected value

    var tagName = opts.element.get(0).tagName.toLowerCase();

    if (tagName === 'input' && opts.element.attr('list') || tagName === 'select' && opts.element.children().length > 0 || opts.ojContext._IsCustomElement() && !opts.options || opts.list) {
      var eleName = opts.list ? 'li' : 'option';

      if (opts.ojContext._IsCustomElement()) {
        eleName = 'oj-option';
      } // install the selection initializer


      opts.initSelection = function (element, callback) {
        var selected;
        var value = self.getVal();

        if (Array.isArray(value) && !opts.ojContext._IsCustomElement()) {
          value = value[0];
        }

        if (value !== undefined && value !== null) {
          selected = self._optionToData(element.find(eleName).filter(function () {
            var elemValue;

            if (eleName === 'li') {
              elemValue = this.getAttribute('oj-data-value');
            } else if (eleName === 'option' || eleName === 'oj-option') {
              elemValue = this.value;
            }

            return oj.Object.compareValues(elemValue, value);
          })); //  - select list behaves differently when using options attribute vs options tag

          if (tagName === 'select' && selected === undefined) {
            value = null;
          }
        }

        if (value === undefined || value === null) {
          selected = self._optionToData(element.find(eleName).filter(function () {
            if (eleName === 'li') {
              return this.getAttribute('oj-data-selected') === true;
            } else if (eleName === 'option') {
              return this.selected;
            }

            return false;
          })); // set first oj-option for oj-select

          if (self._classNm === 'oj-select' && selected === undefined && opts.ojContext._IsCustomElement()) {
            selected = self._optionToData($(element.find(eleName)[0]));
            oj.Logger.info('Select identified by ' + self.container.attr('id') + ' defaults to first option because the value is not set.');
          }
        }

        callback(selected);
      }; //  - ojselect should ignore the invalid value set programmatically


      opts.validate = function (element, value) {
        var selected;

        if (value !== undefined && value !== null) {
          selected = self._optionToData(element.find(eleName).filter(function () {
            var elemValue;

            if (eleName === 'li') {
              elemValue = this.getAttribute('oj-data-value');
            } else if (eleName === 'option' || eleName === 'oj-option') {
              elemValue = this.value;
            }

            return oj.Object.compareValues(elemValue, value);
          }));
        }

        return !!selected;
      };
    } else if ('options' in opts || this.getVal() && this.getVal().length > 0) {
      if (_ComboUtils.isDataProvider(opts.options) || $.isFunction(opts.options)) {
        // install default initSelection when applied to hidden input
        // and getting data from remote
        opts.initSelection = function (element, callback) {
          var findOption = function findOption(results, optionValue) {
            for (var i = 0, l = results.length; i < l; i++) {
              var result = results[i];

              if (oj.Object.compareValues(optionValue, opts.id(result))) {
                return result;
              }

              if (result.children) {
                var found = findOption(result.children, optionValue);

                if (found) {
                  return found;
                }
              }
            }

            return null;
          };

          var id = self._getValueItem();

          var match = null;

          if (id == null) {
            var optionsKeys = self.ojContext.options.optionsKeys;

            if (tagName === 'select' && !self.ojContext._HasPlaceholderSet() && (!optionsKeys || !optionsKeys.value && !optionsKeys.label)) {
              _ComboUtils.fetchFirstBlockFromDataProvider(self.container, opts, 1).then(function (data) {
                if (data && data.length > 0) {
                  callback(data[0]);
                  oj.Logger.info('Select identified by ' + self.container.attr('id') + ' defaults to first option because the value is not set.');
                }
              });
            } else {
              callback(match);
            }

            return;
          } // This data will be saved after querying the options.


          var queryResult = _ComboUtils.getLastQueryResult(self);

          if (queryResult) {
            match = findOption(queryResult, id);
          }

          if (!match) {
            // currentItem will hold the selected object with value and label.
            // Which updated everytime value is changed.
            var currentItem = self.currentItem;

            if (currentItem && currentItem.length && oj.Object.compareValues(id, opts.id(currentItem[0]))) {
              match = currentItem[0];
              oj.Logger.info('Select identified by ' + self.container.attr('id') + ' defaults to first option due to invalid value.');
            }
          } // valueChangeTrigger will have one of the values from
          // _ComboUtils._ValueChangeTriggerTypes, which represents the
          // what triggered the value change. But if value is programmatically
          // updated this will be null. So if valueChangeTrigger is null
          // querying for the options again as component will not have list
          // of options in case value is updated programmatically.


          if (!match && !self.valueChangeTrigger) {
            opts.query({
              value: [id],
              callback: !$.isFunction(callback) ? $.noop : function (qryResult) {
                //  - While fetching the label for the initial value,
                // user can still interact the component and pick a new value.
                if (!_ComboUtils.isDataProvider(opts.options) || oj.Object.compareValues(id, self.getVal()) && !_ComboUtils.isValueChanged(self.ojContext)) {
                  if (qryResult && qryResult.results) {
                    match = findOption(qryResult.results, id);
                  }

                  callback(match);

                  _ComboUtils.setValueChanged(self.ojContext, undefined);
                }
              }
            });
          } else {
            callback(match);
          }
        };
      } else {
        // install default initSelection when applied to hidden input and data is local
        //  - ojselect does not display selected value
        opts.initSelection = function (element, callback) {
          var id = self._getValueItem(); // search in data by id, storing the actual matching item
          // var first = null;
          //  - ojselect - validator error message is not shown
          // initialize first = placeholder if we have a placeholder and select value is not required


          var usePlaceholder = tagName === 'select' && self.ojContext._HasPlaceholderSet() && !self.ojContext._IsRequired();
          var first = usePlaceholder ? self._getPlaceholder() : null;
          var match = null;
          opts.query({
            matcher: function matcher(term, text, el) {
              var isMatch = oj.Object.compareValues(id, opts.id(el));

              if (isMatch) {
                match = el;
              } // /ojselect save the 1st option


              if (first == null) {
                first = el;
              }

              return isMatch;
            },
            callback: !$.isFunction(callback) ? $.noop : function () {
              // ojselect if no match, pick the 1st option
              // If the option data is pending, don't send the placeholder to the callback
              // so the value won't be nulled out
              if (!match && tagName === 'select' && !self.ojContext._isOptionDataPending()) {
                match = first;
                oj.Logger.info('Select identified by ' + self.container.attr('id') + ' defaults to ' + (usePlaceholder ? 'placeholder' : 'first option') + ' due to invalid value.');
              }

              callback(match);
            }
          });
        }; //  - ojselect should ignore the invalid value set programmatically


        opts.validate = function (element, value) {
          var id = value; // search in data by id, storing the actual matching item

          var match = null;
          opts.query({
            matcher: function matcher(term, text, el) {
              var isMatch = oj.Object.compareValues(id, opts.id(el));

              if (isMatch) {
                match = el;
              }

              return isMatch;
            },
            callback: $.noop
          });
          return !!match;
        };
      }
    }

    return opts;
  },
  // _AbstractSingleChoice
  _postprocessResults: function _postprocessResults(data, initial, noHighlightUpdate) {
    var selected = -1;
    var self = this;
    var highlightableChoices;
    highlightableChoices = this._findHighlightableChoices();

    _ComboUtils.each2(highlightableChoices, function (i, elm) {
      var valueItem = self._getValueItem();

      if (valueItem != null && oj.Object.compareValues(valueItem, self.id(elm.data(self._elemNm)))) {
        selected = i;
        return false;
      }

      return true;
    }); // and highlight it


    if (noHighlightUpdate !== false) {
      if (initial === true && selected >= 0) {
        this._highlight(selected);
      }
    } //  - grouping header accessibility issue for jaws


    this._processAriaLabelForHierarchy();
  },
  // _AbstractSingleChoice

  /**
   * Handles when a selection is made by the user
   *
   * @param {object} data A valueOption object for the currect selection
   * @param {object} options Options for _onSelect method on how to handle the event
   * @param {jQuery.Event=} event The event at which the method is invoked
   * @return {Promise|boolean|null} Result of setting the value
   *                                * Promise when using async validators
   *                                * boolean when using sync validators / when setting the value without validators
   *                                * null when setValue is not invoked since there was no change in the value
   *
   * @memberof! _AbstractSingleChoice
   * @instance
   * @private
   */
  _onSelect: function _onSelect(data, options, event) {
    if (!this._triggerSelect(data)) {
      return false;
    }

    var context;

    var opts = _ComboUtils.getOpts(this.ojContext);

    if (options && options.trigger) {
      context = {
        optionMetadata: {
          trigger: options.trigger
        }
      };
    } // set the data and metadata in the context


    context = _ComboUtils.getContextWithExtraData(context, opts, data.data, data.metadata); // var old = this.getVal()? this.getVal()[0] : null;
    // selection will be updated after _SetValue is called
    // this._updateSelection(data);

    this.close(event); // When there is validation error, the value option may retain the previous value
    // although the display value is different. In that case, user should be able to still
    // select the previous valid value to get rid off the invalid style and message.

    /* if (!(old === this.id(data)))*/

    var val;
    var valopt = data;
    var previousHasUncommittedValue = this.hasUncommittedValue;
    var setValueReturn = null;
    var returnValue = null;

    if (this.id(data).length === 0) {
      val = this.ojContext._IsCustomElement() ? _ComboUtils.getValueForPlaceholder(false) : [];
      valopt = _ComboUtils.getFixupValueOptionsForPlaceholder(false);
    } else {
      val = this.id(data);
    } // setValueOptions before setVal so that new entry already in valueOption.
    // this is to avoid looking for new entry on the dataProvider


    if (this._classNm === 'oj-combobox' || this._classNm === 'oj-select') {
      this._skipSetValueOptions = true; //  - oj.tests.input.combobox.testcombobox display value mismatch automation failure

      this.setValOpts(_ComboUtils.findOptionFromResult(this, val, valopt));
    } // Fix , 
    // For combobox, we are using the flag hasUncommittedValue to decide on whether
    // the label or the value would take part in validation.
    // So, when a selection is made, this flag has to be cleared before setting the value.


    this.hasUncommittedValue = false; // setVal method returns a promise that resolves to true|false or a boolean

    setValueReturn = this.setVal(val, event, context);

    if (setValueReturn instanceof Promise) {
      returnValue = setValueReturn.then(this._bind(function (result) {
        this._onSelectAfterSetVal(result, previousHasUncommittedValue); // return the result of the validation, which can use by methods
        // that rely on the result of _onSelect call.


        return result;
      }));
    } else {
      // Sanitize the setValueReturn to be boolean.
      // we can treat null as a passed case, since it represents that
      // the value is already the selected values and a valid one.
      var result = setValueReturn !== false;

      this._onSelectAfterSetVal(result, previousHasUncommittedValue);

      returnValue = setValueReturn;
    } // need not to wait for the validation to complete as the following
    // operations are a response to the event and not for setting the value.


    if (event.type !== 'blur') {
      this._focusSearch();
    }

    return returnValue;
  },

  /**
   * Performs operations that has to be done after the setVal call in _onSelect
   *
   * @param {boolean} result The result of the setVal call
   * @param {boolean} previousHasUncommittedValue The initial hasCommittedValue flag value
   *
   * @memberof! _AbstractSingleChoice
   * @instance
   * @private
   */
  _onSelectAfterSetVal: function _onSelectAfterSetVal(result, previousHasUncommittedValue) {
    // If the validation fails, set the hasUncommittedValue flag so as to revert it back to its
    // original state
    if (result === false) {
      // The validation failed, so reset the flag
      this.hasUncommittedValue = previousHasUncommittedValue;
    }

    this._skipSetValueOptions = false;
  },
  // _AbstractSingleChoice
  _clearSearch: function _clearSearch() {
    this.search.val('');
  },
  // _AbstractSingleChoice
  _getValueItem: function _getValueItem() {
    var valueItem = null;
    var val = this.getVal(); // value supports any type including boolean, so a simple if (val) check will not work

    if (val !== null && val !== undefined) {
      if (!this.ojContext._IsCustomElement() && val.length) {
        valueItem = val[0];
      } else {
        valueItem = val;
      }
    }

    return valueItem;
  },

  /**
   * Returns the selection data
   * @instance
   * @private
   * @ignore
   * @return {Object}
   */
  _getSelectionData: function _getSelectionData() {
    return this.selection.data(this._elemNm);
  },

  /**
   * Returns the components wrapper under which label needs to be inserted in the inside strategy
   * @instance
   * @protected
   * @ignore
   * @return {Element|undefined}
   */
  _GetContentWrapper: function _GetContentWrapper() {
    return this.container[0].querySelector('.oj-text-field-middle');
  }
});



/**
 * @preserve Copyright 2012 Igor Vaynberg
 *
 * This software is licensed under the Apache License, Version 2.0 (the "Apache License") or the GNU
 * General Public License version 2 (the "GPL License"). You may choose either license to govern your
 * use of this software only upon the condition that you accept all of the terms of either the Apache
 * License or the GPL License.
 *
 * You may obtain a copy of the Apache License and the GPL License at:
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 * http://www.gnu.org/licenses/gpl-2.0.html
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * Apache License or the GPL Licesnse is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the Apache License and the GPL License for
 * the specific language governing permissions and limitations under the Apache License and the GPL License.
 */

/* global _ComboUtils:false, _AbstractSingleChoice:false */

/**
 * @private
 */
var _OjSingleCombobox = _ComboUtils.clazz(_AbstractSingleChoice, {
  _elemNm: 'ojcombobox',
  _classNm: 'oj-combobox',
  _COMPONENT_CLASSLIST: 'oj-combobox oj-component',

  /**
   * Creates children elements for oj-combobox-one
   *
   * @return {jQuery} The collection of HTML elements that represent the content
   *
   * @memberof! _OjSingleCombobox
   * @instance
   * @protected
   * @override
   */
  _CreateContentElements: function _CreateContentElements() {
    var contentStructure = ["<div class='oj-text-field-container' role='presentation'>", "  <div class='oj-combobox-choice' tabindex='-1' role='presentation'>", "   <div class='oj-text-field-middle'>", "     <input type='text' autocomplete='off' autocorrect='off' autocapitalize='off'", "       spellcheck='false' class='oj-combobox-input' role='combobox' aria-expanded='false' aria-autocomplete='list' />", '   </div>', "   <abbr class='oj-combobox-clear-entry' role='presentation'></abbr>", "   <span class='oj-combobox-divider' role='presentation'></span>", "   <a class='oj-combobox-arrow oj-combobox-icon oj-component-icon oj-clickable-icon-nocontext oj-combobox-open-icon'", "       role='button' aria-label='expand'></a>", '  </div>', '</div>', "<div class='oj-listbox-drop' role='presentation'>", "   <ul class='oj-listbox-results' role='listbox'>", '   </ul>', '</div>', "<div class='oj-helper-hidden-accessible oj-listbox-liveregion' aria-live='polite'></div>"];
    var container = $(contentStructure.join(''));
    return container;
  },

  /**
   * Configures slots for oj-combobox-one
   *
   * @memberof! _OjSingleCombobox
   * @instance
   * @protected
   * @override
   */
  _ConfigureSlots: function _ConfigureSlots() {
    // The container should be initialized before calling this method
    if (this.container == null || !this.ojContext._IsCustomElement()) {
      return;
    }

    var container = this.container; // container is always a jQuery object of custom-element

    var slotMap = oj.BaseCustomElementBridge.getSlotMap(container[0]);
    var endSlot = slotMap.end;

    if (endSlot) {
      // remove the divider
      container.find('.oj-combobox-divider').remove(); // remove the default arrow anchor

      container.find('.oj-combobox-arrow').remove(); // append the slot at the end

      container.find('.oj-combobox-choice').append(endSlot); // @HTMLUpdateOK

      this._endSlot = endSlot;
    }
  },

  /**
   * Restores slots for oj-combobox-one
   *
   * @memberof! _OjSingleCombobox
   * @instance
   * @protected
   * @override
   */
  _RestoreSlots: function _RestoreSlots() {
    var _endSlot = this._endSlot;

    if (_endSlot != null && this.container != null && this.ojContext._IsCustomElement()) {
      this.container.append(_endSlot); // @HTMLUpdateOK
    } // Clear the reference to the dom element


    this._endSlot = null;
  },
  _triggerValueUpdatedEvent: function _triggerValueUpdatedEvent(data, previousValue) {
    if (!this.ojContext._IsCustomElement()) {
      return;
    }

    var value = this.id(data);

    if (value === undefined || value === null) {
      // If the value is entered by user (not by selecting an option) then
      // only 'label' will be present in the data object.
      value = data.label ? data.label : '';
    }

    if (!this.ojContext.isValid()) {
      return;
    }

    var detail = {};
    var element = this.ojContext.OuterWrapper;
    detail.value = value;
    detail.previousValue = previousValue;
    var eventName = 'ojValueUpdated';
    var valueUpdatedEvent = new CustomEvent(eventName, {
      detail: detail
    });
    element.dispatchEvent(valueUpdatedEvent);
  },
  // eslint-disable-next-line no-unused-vars
  _enable: function _enable(enabled) {
    _OjSingleCombobox.superclass._enable.apply(this, arguments);

    if (this._enabled) {
      this.container.find('.oj-combobox-arrow').removeClass('oj-disabled');
    } else {
      this.container.find('.oj-combobox-arrow').addClass('oj-disabled');
    }
  },
  _opening: function _opening(event, dontUpdateResults) {
    // if beforeExpand is not cancelled
    _OjSingleCombobox.superclass._opening.apply(this, arguments);

    this._focusSearch();

    if (!dontUpdateResults) {
      this._updateResults(true);
    }
  },
  _containerKeydownHandler: function _containerKeydownHandler(e) {
    // If oj-button is used in the end slot, let the button handle the key down event
    if (e.target.getAttribute('slot') === 'end' || $(this._endSlot).find(e.target).length > 0) {
      return;
    } // /ignore control key and function key


    if (_ComboUtils.KEY.isControl(e) || _ComboUtils.KEY.isFunctionKey(e)) {
      return;
    }

    _OjSingleCombobox.superclass._containerKeydownHandler.apply(this, arguments);
  },
  _updateSelection: function _updateSelection(data) {
    var formatted;
    var item = [];
    var text;
    this.selection.data(this._elemNm, data);

    if (data !== null && data.length !== 0) {
      formatted = this.opts.formatSelection(data);

      if (formatted !== undefined && this.search.val() !== formatted) {
        this.search.val(formatted);
      }

      this.search.removeClass(this._classNm + '-default');
      item.push(data);
      text = formatted;
    } else {
      // data will be null only when user set it programmatically.
      this.search.val('');

      this._setPlaceholder();

      text = '';
    } // keep readonly div's content in sync


    if (this.ojContext.options.readOnly) {
      var readonlyElem = this.ojContext._getReadonlyDiv();

      if (readonlyElem) {
        readonlyElem.textContent = text;
      }
    } // Storing this data so that it will be used when setting the display value.


    this.currentItem = item;
  },
  _updateSelectedOption: function _updateSelectedOption(selected) {
    if (selected !== undefined && selected !== null) {
      this._updateSelection(selected); //  - need to be able to specify the initial value of select components bound to dprv


      this.setValOpts(selected);
    } else {
      // if we found no match, update the selection with the value
      var value = this.getVal();
      var data;

      if (value === undefined || value === null) {
        data = null;
      } else if (!Array.isArray(value)) {
        data = {
          label: value
        };
      } else if (value.length) {
        data = {
          label: value[0]
        };
      } else {
        data = null;
      }

      this._updateSelection(data); // if value is a new entry


      if (!selected && value) {
        this.setValOpts({
          value: value,
          label: _ComboUtils.getLabel({
            value: value
          })
        });
      } else {
        this.setValOpts(selected);
      }
    }
  }
});



/**
 * @preserve Copyright 2012 Igor Vaynberg
 *
 * This software is licensed under the Apache License, Version 2.0 (the "Apache License") or the GNU
 * General Public License version 2 (the "GPL License"). You may choose either license to govern your
 * use of this software only upon the condition that you accept all of the terms of either the Apache
 * License or the GPL License.
 *
 * You may obtain a copy of the Apache License and the GPL License at:
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 * http://www.gnu.org/licenses/gpl-2.0.html
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * Apache License or the GPL Licesnse is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the Apache License and the GPL License for
 * the specific language governing permissions and limitations under the Apache License and the GPL License.
 */

/* global _ComboUtils:false, _AbstractSingleChoice:false, Promise:false */

/**
 * @private
 */
var _OjSingleSelect = _ComboUtils.clazz(_AbstractSingleChoice, {
  _elemNm: 'ojselect',
  _classNm: 'oj-select',
  _userTyping: false,
  _COMPONENT_CLASSLIST: 'oj-select oj-component',

  /**
   * Creates children elements for oj-select-one
   *
   * @return {jQuery} The collection of HTML elements that represent the content
   *
   * @memberof! _OjSingleSelect
   * @instance
   * @protected
   * @override
   */
  _CreateContentElements: function _CreateContentElements() {
    var contentStructure = ["<div class='oj-text-field-container' role='presentation'>", "  <div class='oj-select-choice' tabindex='0' role='combobox' ", "     aria-autocomplete='none' aria-expanded='false'>", "   <div class='oj-text-field-middle'>", "      <span class='oj-select-chosen'></span>", '   </div>', "    <abbr class='oj-select-search-choice-close' role='presentation'></abbr>", "    <a class='oj-select-arrow oj-component-icon oj-clickable-icon-nocontext oj-select-open-icon' role='presentation'>", '    </a>', '  </div>', '</div>', "<div class='oj-listbox-drop' role='dialog'>", "  <div class='oj-listbox-search-wrapper'>", "  <div class='oj-listbox-search'>", "    <input type='text' autocomplete='off' autocorrect='off' autocapitalize='off'", "           spellcheck='false' class='oj-listbox-input' title='Search field' ", "           role='combobox' aria-expanded='false' aria-autocomplete='list' />", "    <span class='oj-listbox-spyglass-box'>", "      <span class='oj-component-icon oj-listbox-search-icon' role='presentation'>", "       <b role='presentation'></b></span>", '    </span>', '  </div>', '  </div>', "   <ul class='oj-listbox-results' role='listbox'>", '   </ul>', '</div>', "<div class='oj-helper-hidden-accessible oj-listbox-liveregion' aria-live='polite'></div>"];
    return $(contentStructure.join(''));
  },
  // _OjSingleSelect
  // eslint-disable-next-line no-unused-vars
  _enable: function _enable(enabled) {
    _OjSingleSelect.superclass._enable.apply(this, arguments); //  - dropdown icon is in disabled state after enabling ojselect


    if (this._enabled) {
      var elementTabIndex = this.elementTabIndex ? this.elementTabIndex : '0';
      this.selection.attr('tabindex', elementTabIndex);
      this.container.find('.oj-select-arrow').removeClass('oj-disabled');
    } else {
      // Don't allow focus on a disabled "select"
      this.selection.attr('tabindex', '-1'); //  - disabled select icon hover still shows changes

      this.container.find('.oj-select-arrow').addClass('oj-disabled');
    }
  },
  // _OjSingleSelect
  close: function close(event) {
    if (!this._opened()) {
      return;
    } //  - ojselect input field grabs focus on paste
    // don't set focus on the select box if event target is not select element
    // Bug JET-34119 - focus is not returned to oj-select-one after selecting an option from the dropdown
    // return the focus to the select if the event.target is in the dropdown.
    // We need to determine whether the focus has to be returned to the select or not
    // If the event is of type MouseEvent or FocusEvent, it has be checked if the
    // event target is a part of the select or its dropdown and only if it is
    // the focus should be retained.
    // Note: In Firefox, Safari and Edge clicking on an input element triggers a
    // FocusEvent while in Chrome and IE11, MouseEvent will be triggered. So both
    // has to be considered here.


    var originalEvent = event ? event.originalEvent : null;
    var isMouseOrFocusEvent = originalEvent instanceof MouseEvent || originalEvent instanceof FocusEvent;
    var shouldReturnFocus = event && (!isMouseOrFocusEvent || event.target === this.selection || event.target === this.search || this.dropdown.has(event.target).length > 0);

    _OjSingleSelect.superclass.close.apply(this, arguments);

    this.selection.attr('aria-expanded', false).removeAttr('aria-haspopup').removeAttr('aria-owns');
    this.search.attr('aria-expanded', false).removeAttr('aria-controls'); //  - required validation err is not displayed when user tabs out
    // always clear search text when dropdown close

    if (!this._testClear(event)) {
      this._clearSearch();
    } // When the dropdown is open and if the close method is invoked
    // by clicking directly on an input element, different browsers
    // behave differently.
    // Some, triggers mousedown event before a focus event on the target element
    // which results in this method being called before this.ojContext._handleAfterFocusToggle
    // which thus results in the expected behavior. But in other browsers it is the
    // opposite, which results in the _handleAfterFocusToggle method to be called
    // with focusOut event before closing the dropdown. This incorrectly results in
    // oj-focus class being added to the root element. In this case, we would have
    // to remove the class. As the select is currently not focused and also does not
    // have the dropdown open, it should not have oj-focus class.


    if (this.ojContext.hasAfterToggleHandlerAddedFocusClass && !shouldReturnFocus) {
      this.ojContext._getRootElement().classList.remove('oj-focus');

      this.ojContext.hasAfterToggleHandlerAddedFocusClass = false;
    }

    if (shouldReturnFocus) {
      _ComboUtils._focus(this, this.selection);
    } // /remove "mouse click" listeners on spyglass


    this.container.find('.oj-listbox-spyglass-box').off('mouseup click');
  },
  // _OjSingleSelect
  _opening: function _opening(event, dontUpdateResults) {
    _OjSingleSelect.superclass._opening.apply(this, arguments); //  - select input gets stuck with sdp fetchchain delay
    // show drop down in order to show the searchBox


    this._showDropDown();

    var searchText = _ComboUtils.getSearchText(event); // select: focus still stay on the selectBox if open dropdown by mouse click


    this._showSearchBox(searchText);

    if (!dontUpdateResults) {
      if (searchText) {
        this._updateResults();
      } else {
        this._updateResults(true);
      }
    }
  },
  // _OjSingleSelect
  _showDropDown: function _showDropDown() {
    if (!this._opened()) {
      // Just to make sure that _opening() method is called before calling
      // the _showDropDown().
      return;
    }

    var expanding = this.selection.attr('aria-expanded') !== 'true';

    _OjSingleSelect.superclass._showDropDown.apply(this, arguments);

    if (expanding) {
      this.selection.attr('aria-expanded', true).attr('aria-haspopup', 'dialog').attr('aria-owns', this.results.attr('id'));
      this.search.attr('aria-expanded', true).attr('aria-controls', this.results.attr('id') + ' ' + this.container.find('.oj-listbox-liveregion').attr('id'));
    } //  - search moves cursor to end, difficult to edit search

  },
  // _OjSingleSelect
  _initContainer: function _initContainer() {
    // /ojselect placeholder
    var selectedId = this.containerId + '_selected';
    this.text = this.container.find('.oj-select-chosen').attr('id', selectedId);

    _OjSingleSelect.superclass._initContainer.apply(this, arguments); // /select: accessibility


    this.selection.attr({
      'aria-labelledby': this.search.attr('aria-labelledby'),
      'aria-describedby': selectedId
    }); //  - missing select label

    var label = this._getTransferredAttribute('aria-label');

    if (label) {
      this.selection.attr('aria-label', label);
    }

    this.search.on('keydown', this._bind(this._containerKeydownHandler));
    this.search.on('keyup-change input', this._bind(this._containerKeyupHandler)); //  - nls: hardcoded string 'search field' in select component

    this.search.attr('title', this.ojContext.getTranslatedString('searchField')); //  - required validation err is not displayed when user tabs out

    var self = this;
    this.selection.on('blur', function (e) {
      self._testClear(e);
    });
  },
  // _OjSingleSelect
  _initSelection: function _initSelection() {
    if (this._isPlaceholderOptionSelected()) {
      this._updateSelection(null);

      this.close();

      this._setPlaceholder();
    } else {
      _OjSingleSelect.superclass._initSelection.apply(this, arguments);
    }
  },
  // _OjSingleSelect
  _updateSelectedOption: function _updateSelectedOption(selected) {
    if (selected !== undefined && selected !== null) {
      // ojSelect by default use first option if user set a value which is not listed in original option items.
      // So need to update options to reflect the correct value in component state.
      var selectedVal;
      var value = this.getVal();

      if (Array.isArray(value) && !this.ojContext._IsCustomElement()) {
        value = value[0];
      }

      selectedVal = this.opts.id(selected); // editableValue doesn't accept undefined value

      if (selectedVal === undefined) {
        selectedVal = null;
      } //  - the selected option of the ojselect not reflected in the value variable


      if (!oj.Object.compareValues(value, selectedVal)) {
        this.ojContext._setInitialSelectedValue(selectedVal);
      }

      this.setValOpts(selected);

      this._updateSelection(selected);

      this.close();
    } else {
      this.setValOpts(null);
    }
  },
  // _OjSingleSelect
  _updateSelection: function _updateSelection(data) {
    this.selection.data(this._elemNm, data); //  - ojet select displaying values incorrectly

    if (data !== null) {
      this.text.text(typeof data === 'string' ? data : _ComboUtils.getLabel(data));
    } // make sure placeholder text has "oj-select-default" class


    if (data && data.id !== '') {
      this.text.removeClass(this._classNm + '-default');
    }
  },
  // _OjSingleSelect
  _getActiveContainer: function _getActiveContainer() {
    var expanded = this.search.attr('aria-expanded');
    return expanded && this._hasSearchBox() ? this.search : this.selection;
  },
  // _OjSingleSelect
  _isPlaceholderOptionSelected: function _isPlaceholderOptionSelected() {
    // /ojselect allow placeholder to be an empty string
    if (this._getPlaceholder() === null) {
      return false; // no placeholder specified so no option should be considered
    }

    var cval = this.getVal();
    cval = Array.isArray(cval) ? cval[0] : cval; // This method is used to check whether placeholder text need to be displayed in ui or not and hence checking current value should be fine.

    return _ComboUtils.isValueForPlaceholder(false, cval);
  },
  // _OjSingleSelect
  // /ojselect placeholder this method should be in AbstractOjChoice
  _getPlaceholder: function _getPlaceholder() {
    return this.opts.placeholder;
  },
  // _OjSingleSelect
  _showPlaceholder: function _showPlaceholder() {
    // make sure the aggregate component options are current
    this.opts.placeholder = this.ojContext.options.placeholder;
    return true;
  },
  // _OjSingleSelect
  _setPlaceholder: function _setPlaceholder() {
    var placeholder = this._getPlaceholder();

    if (this._isPlaceholderOptionSelected() && placeholder !== undefined) {
      this.text.text(placeholder).addClass(this._classNm + '-default');
    }
  },
  // _OjSingleSelect

  /**
   * Sets the value
   * @instance
   * @override
   * @ignore
   * @param {any} val The value to be set
   * @param {jQuery.Event=} event The event at which the method is invoked
   * @param {object} context Context
   * @return {Promise} Result of setting the value
   */
  setVal: function setVal(val, event, context) {
    // /pass original event
    var setValueReturn = _OjSingleSelect.superclass.setVal.call(this, val, event, context);

    if (setValueReturn instanceof Promise) {
      return setValueReturn.then(this._bind(function (result) {
        if (result !== false) {
          this.selection.data('selectVal', val);
        }
      }));
    }

    if (setValueReturn !== false) {
      this.selection.data('selectVal', val);
    }

    return setValueReturn;
  },
  // _OjSingleSelect
  _containerKeydownHandler: function _containerKeydownHandler(e) {
    //  - strange text show up after type in "<" in the select component
    //  - keyboard handling issues
    if (_ComboUtils.KEY.isControl(e) && e.which !== _ComboUtils.KEY.SHIFT || e.which === _ComboUtils.KEY.SHIFT || _ComboUtils.KEY.isFunctionKey(e)) {
      return;
    }

    switch (e.which) {
      case _ComboUtils.KEY.TAB:
        this.close(e); // James: tab out of an expanded poplist, focus is going all the way to the top of the page.

        this.selection.focus(); //  - required validation err is not displayed when user tabs out

        this._testClear(e);

        return;
      // open dropdown on Enter

      case _ComboUtils.KEY.ENTER:
        if (e.target === this.selection[0] && !this._opened()) {
          this.open(e); //  - select and combobox stop keyboard event propegation

          e.preventDefault();
          return;
        }

        break;

      default:
        break;
    }

    _OjSingleSelect.superclass._containerKeydownHandler.apply(this, arguments);

    if (this._userTyping) {
      //  - select input gets stuck with sdp fetchchain delay
      // force opening the dropdown to show seach text in the searchbox
      this.open(e); //  - ojselect search box does not appear when i start typing

      if (this._opened()) {
        var searchBox = this.dropdown.find('.oj-listbox-search');

        if ($(searchBox).attr('aria-hidden') === 'true') {
          var searchText = _ComboUtils.getSearchText(e);

          if (searchText) {
            this._showSearchBox(searchText);

            this._updateResults();
          }
        }
      }
    }
  },
  // _OjSingleSelect
  //  - required validation err is not displayed when user tabs out
  _testClear: function _testClear(event) {
    if (this.text.text() === '') {
      // In the case when the selected option or oj-option has empty text for label
      // but has valid value, we don't want to clear the value out -- see 
      //  - lov does not show the value-option label when it's updated later
      if (this.datalist && this.selection.data(this._elemNm) && this.selection.data(this._elemNm).value || !_ComboUtils.isValueForPlaceholder(false, this.ojContext.options.value)) {
        return false;
      }

      this._clear(event);

      return true;
    }

    return false;
  }
});



/**
 * @preserve Copyright 2012 Igor Vaynberg
 *
 * This software is licensed under the Apache License, Version 2.0 (the "Apache License") or the GNU
 * General Public License version 2 (the "GPL License"). You may choose either license to govern your
 * use of this software only upon the condition that you accept all of the terms of either the Apache
 * License or the GPL License.
 *
 * You may obtain a copy of the Apache License and the GPL License at:
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 * http://www.gnu.org/licenses/gpl-2.0.html
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * Apache License or the GPL Licesnse is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the Apache License and the GPL License for
 * the specific language governing permissions and limitations under the Apache License and the GPL License.
 */

/* global _ComboUtils:false, _AbstractOjChoice:false, Promise:false */

/**
 * @private
 */
var _AbstractMultiChoice = _ComboUtils.clazz(_AbstractOjChoice, {
  _prepareOpts: function _prepareOpts() {
    var opts = _AbstractMultiChoice.superclass._prepareOpts.apply(this, arguments);

    var self = this;
    var tagName = opts.element.get(0).tagName.toLowerCase();

    if (tagName === 'input' && opts.element.attr('list') || tagName === 'select' && opts.element.children().length > 0 || opts.ojContext._IsCustomElement() && !opts.options || opts.list) {
      var eleName = opts.list ? 'li' : 'option';

      if (opts.ojContext._IsCustomElement()) {
        eleName = 'oj-option';
      } // install the selection initializer


      opts.initSelection = function (element, callback) {
        var selected;
        var data = [];

        if (self.getVal()) {
          var ids = self.getVal();

          for (var i = 0; i < ids.length; i++) {
            var id = ids[i]; // eslint-disable-next-line no-loop-func

            selected = element.find(eleName).filter(function () {
              var elemValue;

              if (eleName === 'li') {
                elemValue = this.getAttribute('oj-data-value');
              } else if (eleName === 'option' || eleName === 'oj-option') {
                elemValue = this.value;
              }

              return oj.Object.compareValues(elemValue, id);
            });

            if (selected && selected.length) {
              data.push(self._optionToData(selected));
            } else if (self._elemNm === 'ojcombobox') {
              // If user entered value which is not listed in predefiend options
              data.push({
                value: id,
                label: id
              });
            }
          }
        } else if (tagName !== 'select') {
          // don't do this for select since it returns the first option as selected by default
          selected = element.find(eleName).filter(function () {
            if (eleName === 'option') {
              return this.selected;
            } else if (eleName === 'li') {
              return this.getAttribute('oj-data-selected') === true;
            } else if (eleName === 'oj-option') {
              return this.getAttribute('selected') === true;
            }

            return false;
          });

          _ComboUtils.each2(selected, function (index, elm) {
            data.push(self._optionToData(elm));
          });
        }

        callback(data);
      };
    } else if ('options' in opts) {
      if (_ComboUtils.isDataProvider(opts.options) || $.isFunction(opts.options)) {
        // install default initSelection when applied to hidden input and data is remote
        opts.initSelection = function (element, callback) {
          var findOptions = function findOptions(results, optionValues) {
            var foundOptions = [];

            for (var i = 0, l = results.length; i < l; i++) {
              var result = results[i];
              var idx = optionValues.indexOf(opts.id(result));

              if (idx >= 0) {
                foundOptions.push(result);
              }

              if (result.children) {
                var childOptions = findOptions(result.children, optionValues);

                if (childOptions && childOptions.length) {
                  $.merge(foundOptions, childOptions);
                }
              }
            }

            return foundOptions;
          };

          var ids = self.getVal(); // search in data by array of ids, storing matching items in a list

          var matches = []; // This data will be saved after querying the options.

          var queryResult = _ComboUtils.getLastQueryResult(self);

          if (queryResult) {
            matches = findOptions(queryResult, ids);
          }

          var reorderOptions = function reorderOptions() {
            // Reorder matches based on the order they appear in the ids array because right now
            // they are in the order in which they appear in data array.
            // If not found in the current result, then will check in the saved current item.
            var ordered = [];

            for (var i = 0; i < ids.length; i++) {
              var id = ids[i];
              var found = false;

              for (var j = 0; j < matches.length; j++) {
                var match = matches[j];

                if (oj.Object.compareValues(id, opts.id(match))) {
                  ordered.push(match);
                  matches.splice(j, 1);
                  found = true;
                  break;
                }
              }

              if (!found) {
                // currentItem will hold the selected object with value and label.
                // Which updated everytime value is changed.
                var currentItem = self.currentItem;

                if (currentItem && currentItem.length) {
                  for (var k = 0; k < currentItem.length; k++) {
                    if (oj.Object.compareValues(id, opts.id(currentItem[k]))) {
                      ordered.push(currentItem[k]);
                      found = true;
                      break;
                    }
                  }
                }

                if (!found && self._elemNm === 'ojcombobox') {
                  // If user entered value which is not listed in predefiend options
                  ordered.push({
                    value: id,
                    label: id
                  });
                }
              }
            }

            callback(ordered);
          }; // valueChangeTrigger will have one of the values from
          // _ComboUtils._ValueChangeTriggerTypes, which represents the
          // what triggered the value change. But if value is programmatically
          // updated this will be null. So if valueChangeTrigger is null
          // querying for the options again as component will not have list
          // of options in case value is updated programmatically.


          if (!self.valueChangeTrigger) {
            opts.query({
              value: ids,
              callback: function callback(qryResult) {
                if (qryResult && qryResult.results) {
                  var results = findOptions(qryResult.results, ids);

                  if (results && results.length) {
                    var concat = results;

                    if (_ComboUtils.isDataProvider(opts.options)) {
                      //  - While fetching the label for the initial value,
                      // user can still interact the component and pick a new value.
                      concat = [];
                      var vals = self.getVal();

                      if (oj.Object.compareValues(ids, vals) && !_ComboUtils.isValueChanged(self.ojContext)) {
                        concat = results;
                      } else {
                        var v;
                        var found;
                        var valOpts = self.getValOpts(); // value has changed, concatenate results and value options

                        vals.forEach(function (val) {
                          found = false;

                          for (v = 0; v < valOpts.length; v++) {
                            if (oj.Object.compareValues(valOpts[v].value, val)) {
                              found = true;
                              concat.push(valOpts[v]);
                              break;
                            }
                          }

                          if (!found) {
                            for (v = 0; v < results.length; v++) {
                              if (oj.Object.compareValues(results[v].value, val)) {
                                concat.push({
                                  value: results[v].value,
                                  label: results[v].label
                                });
                                break;
                              }
                            }
                          }
                        }); // update ids and valueOptions

                        ids = vals;

                        _ComboUtils.setValueOptions(self.ojContext, concat);
                      }
                    }

                    $.merge(matches, concat);
                  }
                }

                _ComboUtils.setValueChanged(self.ojContext, undefined);

                reorderOptions();
              }
            });
          } else {
            reorderOptions();
          }
        };
      } else {
        // install default initSelection when applied to hidden input and data is local
        opts.initSelection = function (element, callback) {
          var ids = self.getVal();

          if (!ids || ids.length === 0) {
            return;
          } // search in data by array of ids, storing matching items in a list


          var matches = [];
          opts.query({
            matcher: function matcher(term, text, el) {
              var isMatch = $.grep(ids, function (id) {
                return oj.Object.compareValues(id, opts.id(el));
              }).length;

              if (isMatch) {
                matches.push(el);
              }

              return isMatch;
            },
            callback: !$.isFunction(callback) ? $.noop : function () {
              // reorder matches based on the order they appear in the ids array because right now
              // they are in the order in which they appear in data array
              var ordered = [];

              for (var i = 0; i < ids.length; i++) {
                var id = ids[i];
                var found = false;

                for (var j = 0; j < matches.length; j++) {
                  var match = matches[j];

                  if (oj.Object.compareValues(id, opts.id(match))) {
                    ordered.push(match);
                    matches.splice(j, 1);
                    found = true;
                    break;
                  }
                }

                if (!found && self._elemNm === 'ojcombobox') {
                  // If user entered value which is not listed in predefiend options
                  ordered.push({
                    value: id,
                    label: id
                  });
                }
              }

              callback(ordered);
            }
          });
        };
      }
    }

    return opts;
  },
  _selectChoice: function _selectChoice(choice) {
    var selected = this.container.find('.' + this._classNm + '-selected-choice.oj-focus');
    var hasSelected = selected && selected.length > 0;
    var hasChoice = choice && choice.length > 0; // Condition 1: Nothing is selected and we need select an item (selected == null && choice == item1)
    // Condition 2: An item is selected and we need to unselect that item (selected == item1 && choice == null)
    // Condition 3: An item is selected and we need to select another item (selected == item1 && choice == item2)
    // Condition 4: An item is selected and we need to select same item (selected == item1 && choice == item1)
    // Make sure Condition 4 is no-op and we don't trigger choice-selected / choice-deselected event

    if (!hasSelected && hasChoice || hasSelected && !hasChoice || hasSelected && hasChoice && choice[0] !== selected[0]) {
      if (hasSelected) {
        this.opts.element.trigger('choice-deselected', selected);
        selected.removeClass('oj-focus');
      }

      if (hasChoice) {
        this.close();
        choice.addClass('oj-focus');
        this.container.find('.' + this._classNm + '-description').text(choice.attr('valueText') + '. Press back space to delete.').attr('aria-live', 'assertive');
        this.opts.element.trigger('choice-selected', choice);
      }
    }
  },
  _destroy: function _destroy() {
    $("label[for='" + this.search.attr('id') + "']").attr('for', this.opts.element.attr('id'));

    if (this.ojContext._IsCustomElement()) {
      // remove touchstart listener from container
      this.container[0].removeEventListener('touchstart', this._delegatedContainerTouchStartListener, {
        passive: false
      });
      delete this._delegatedContainerTouchStartListener;
      this.container.off('click touchstart');
    }

    _AbstractMultiChoice.superclass._destroy.apply(this, arguments);
  },
  _initContainer: function _initContainer() {
    var selector = '.' + this._classNm + '-choices';

    var idSuffix = _ComboUtils.nextUid();

    var elementLabel;

    var ariaLabel = this._getTransferredAttribute('aria-label');

    var ariaControls = this._getTransferredAttribute('aria-controls');

    this.searchContainer = this.container.find('.' + this._classNm + '-search-field');
    var selection = this.container.find(selector);
    this.selection = selection;
    var self = this;
    this.selection.on('click', '.' + this._classNm + '-selected-choice:not(.' + this._classNm + '-locked)', function () {
      if (self._elemNm === 'ojcombobox') {
        self.search[0].focus();
      } // Fixed??


      self._selectChoice($(this));
    }); // only ojSelectMany triggers the selection blur event.

    if (this._elemNm === 'ojselect') {
      this.selection.on('blur', function () {
        self._selectChoice(null);
      });
    }

    this._contentElement = this._elemNm === 'ojcombobox' ? this.search : this.selection; // add aria associations

    selection.find('.' + this._classNm + '-input').attr('id', this._classNm + '-input-' + idSuffix);

    if (!this.results.attr('id')) {
      this.results.attr('id', 'oj-listbox-results-' + idSuffix);
    }

    this._contentElement.attr('aria-owns', this.results.attr('id'));

    if (!this.ojContext._IsCustomElement()) {
      elementLabel = $("label[for='" + this._getAttribute('id') + "']");

      if (!elementLabel.attr('id')) {
        elementLabel.attr('id', this._classNm + '-label-' + idSuffix);
      }

      this._contentElement.attr('aria-labelledby', elementLabel.attr('id'));

      this.opts.element.attr('aria-labelledby', elementLabel.attr('id'));

      if (this.search.attr('id')) {
        elementLabel.attr('for', this.search.attr('id'));
      }
    }

    if (ariaLabel) {
      this._contentElement.attr('aria-label', ariaLabel);
    }

    if (ariaControls) {
      this._contentElement.attr('aria-controls', ariaControls);
    }

    if (this.elementTabIndex) {
      this._contentElement.attr('tabindex', this.elementTabIndex);
    }

    this.keydowns = 0; // Add keydown keyup handler on the select box for ojselect

    if (this._elemNm === 'ojselect') {
      this.selection.on('keydown', this._bind(this._containerKeydownHandler));
      this.selection.on('keyup', this._bind(function () {
        this.keydowns = 0;
      }));
    }

    this.search.on('keydown', this._bind(this._containerKeydownHandler));
    this.search.on('keyup', this._bind(function () {
      this.keydowns = 0;
    }));
    this.search.on('compositionstart', this._bind(function () {
      // See _isComposing in InputBase for comments on what this does
      this.ojContext._isComposing = true;
    }));
    this.search.on('compositionend', this._bind(function (e) {
      this.ojContext._isComposing = false;

      this._onSearchInputHandler(e);
    }));
    this.search.on('input', this._bind(function (e) {
      if (!this.ojContext._isComposing) {
        this._onSearchInputHandler(e);
      }
    }));
    this.search.on('blur keyup', this._bind(function (e) {
      if (e.type === 'keyup' && e.keyCode !== 10 && e.keyCode !== 13) {
        return;
      }

      if (this.opts.manageNewEntry && this.search.val() && this.results.find('.oj-hover').length <= 0) {
        var data = this.opts.manageNewEntry(this.search.val());
        var trigger = e.type === 'blur' ? _ComboUtils.ValueChangeTriggerTypes.BLUR : _ComboUtils.ValueChangeTriggerTypes.ENTER_PRESSED;
        var options = {
          trigger: trigger
        };

        var onSelectReturn = this._onSelect(data, options, e); // BUG JET-37212 - oj-combobox-many: input text is not cleared on blur
        // The clearing part was removed while fixing the bug JET-28569. But this part is
        // needed to clear the search box under certain cases like typing in a value that is already
        // present and then blurring out.


        if (onSelectReturn instanceof Promise) {
          // The issue JET-28569 which removed this part so as to not clear the text when using async-validator
          // so in that case, wait for the promise to resolve and then clear the text if needed.
          onSelectReturn.then(this._bind(this._clearSearchOnBlur));
        } else {
          this._clearSearchOnBlur();
        }
      }

      this._selectChoice(null);

      if (e.type === 'blur') {
        // JET-35372 8.2.0: oj-combobox-many steals input focus when value/options are updated
        // reset the isSearchFocused flag on blur event
        this.isSearchFocused = false; // Clear up the focus classes on blur event

        this.search.removeClass(this._classNm + '-focused');
        this.container.removeClass('oj-focus');
      }

      e.stopImmediatePropagation();
    }));
    this._containerClickAndTouchStartListener = this._bind(function (e) {
      if (!this._isInterfaceEnabled()) {
        return;
      }

      if ($(e.target).closest('.' + this._classNm + '-selected-choice').length > 0) {
        // clicked inside a selected choice, do not open
        return;
      }

      this._selectChoice(null);

      if (this._opened()) {
        this.close(e);
      } else {
        this.open(e);

        if (this._elemNm === 'ojcombobox' || this._hasSearchBox()) {
          this._focusSearch();
        }
      }

      e.preventDefault();
    });

    if (this.ojContext._IsCustomElement()) {
      this._delegatedContainerTouchStartListener = function (event) {
        var container = event.currentTarget;
        var targetElement = event.target.closest(selector);

        if (targetElement && container.contains(targetElement)) {
          this._containerClickAndTouchStartListener($.Event(event, {
            currentTarget: targetElement
          }));
        }
      }.bind(this);

      this.container.on('click', selector, this._containerClickAndTouchStartListener);
      this.container[0].addEventListener('touchstart', this._delegatedContainerTouchStartListener, {
        passive: false
      });
    } else {
      this.container.on('click touchstart', selector, this._containerClickAndTouchStartListener);
    }

    this._initContainerWidth();

    this.opts.element.hide().attr('aria-hidden', true); // set the placeholder if necessary

    this._clearSearch();
  },

  /**
   * Handles input event and compositionend event for the search field
   * @param {jQuery.Event} e Input event triggered on the search field
   * @private
   */
  _onSearchInputHandler: function _onSearchInputHandler(e) {
    var valueOpts = (this.getValOpts() || []).slice(0);
    var searchText = this.search.val();
    var rawValue = valueOpts.map(function (vo) {
      return vo.label;
    });

    if (searchText !== '') {
      rawValue.push(searchText);
    }

    if (this._classNm === 'oj-combobox') {
      // When user types in something into the combobox, mark it dirty
      // and this will be used when deciding what should be used
      // for validation
      this.hasUncommittedValue = true;
    }

    this.ojContext._SetRawValue(rawValue, e);
  },
  _containerKeydownHandler: function _containerKeydownHandler(e) {
    if (!this._isInterfaceEnabled()) {
      return;
    }

    this.keydowns += 1;
    var selected = this.selection.find('.' + this._classNm + '-selected-choice.oj-focus');
    var prev = selected.prev('.' + this._classNm + '-selected-choice:not(.' + this._classNm + '-locked)');
    var next = selected.next('.' + this._classNm + '-selected-choice:not(.' + this._classNm + '-locked)');
    var pos = this._elemNm === 'ojselect' && !this._userTyping ? _ComboUtils.getCursorInfo(this.selection) : _ComboUtils.getCursorInfo(this.search);

    if (selected.length && (e.which === _ComboUtils.KEY.LEFT || e.which === _ComboUtils.KEY.RIGHT || e.which === _ComboUtils.KEY.BACKSPACE || e.which === _ComboUtils.KEY.DELETE || e.which === _ComboUtils.KEY.ENTER)) {
      var selectedChoice = selected;

      if (e.which === _ComboUtils.KEY.LEFT && prev.length) {
        selectedChoice = prev;
      } else if (e.which === _ComboUtils.KEY.RIGHT) {
        selectedChoice = next.length ? next : null;
      } else if (e.which === _ComboUtils.KEY.BACKSPACE) {
        this._unselect(selected.first(), e);

        this._resetSearchWidth();

        selectedChoice = prev.length ? prev : next;
      } else if (e.which === _ComboUtils.KEY.DELETE) {
        this._unselect(selected.first(), e);

        this._resetSearchWidth();

        selectedChoice = next.length ? next : null;
      } else if (e.which === _ComboUtils.KEY.ENTER) {
        selectedChoice = null;
      }

      this._selectChoice(selectedChoice);

      e.preventDefault();

      if (!selectedChoice || !selectedChoice.length) {
        this.open(e);
      }

      return;
    } else if (this._isBackNavAllowed() && pos.offset === 0 && !pos.length && (e.which === _ComboUtils.KEY.BACKSPACE && this.keydowns === 1 || e.which === _ComboUtils.KEY.LEFT)) {
      this._selectChoice(this.selection.find('.' + this._classNm + '-selected-choice:not(.' + this._classNm + '-locked)').last());

      e.preventDefault();
      return;
    }

    this._selectChoice(null);

    if (_ComboUtils.KEY.isControl(e) || _ComboUtils.KEY.isFunctionKey(e)) {
      return;
    }

    switch (e.which) {
      case _ComboUtils.KEY.UP:
      case _ComboUtils.KEY.DOWN:
        if (this._opened()) {
          this._moveHighlight(e.which === _ComboUtils.KEY.UP ? -1 : 1);
        } else {
          this.open(e);
        }

        e.preventDefault();
        return;

      case _ComboUtils.KEY.PAGE_UP:
      case _ComboUtils.KEY.PAGE_DOWN:
        // prevent the page from scrolling
        e.preventDefault();
        return;

      case _ComboUtils.KEY.ENTER:
        if (this._opened()) {
          this._selectHighlighted(null, e); // Fix :  PRESSING 'ENTER' WITHIN DROPDOWN SHOULD NOT PROPAGATE


          e.stopPropagation();
        } // prevent form from being submitted


        e.preventDefault();
        return;

      case _ComboUtils.KEY.TAB:
        this.close(e);
        return;

      case _ComboUtils.KEY.ESC:
        this._cancel(e);

        e.preventDefault();
        return;

      default:
        break;
    }

    if (this._opened() && this._userTyping === false) {
      // bring up the search box if user started typing after the drop down is already opened
      this._userTyping = true;
      this.close();
    } // ojselect: used by select


    this._userTyping = true;
  },
  _isBackNavAllowed: function _isBackNavAllowed() {
    // For ojSelectMany: Backspace / Left navigation is not allowed if the search is focused
    if (this._elemNm === 'ojselect') {
      return document.activeElement !== this.search[0];
    }

    return true;
  },
  _enableInterface: function _enableInterface() {
    if (_AbstractMultiChoice.superclass._enableInterface.apply(this, arguments)) {
      this.search.prop('disabled', !(this._isInterfaceEnabled() || _ComboUtils.isReadonly(this.ojContext)));
    }
  },
  _initSelection: function _initSelection(valueOptions) {
    var vv = this.getVal();

    if ((vv === null || vv.length === 0) && (this._classNm === 'oj-select' || this.opts.element.text().trim() === '')) {
      this._updateSelection(valueOptions || []);

      this.close(); // set the placeholder if necessary

      this._clearSearch();
    }

    if (this.datalist || this.getVal() !== null && this.getVal().length) {
      var self = this;
      var element;

      if (this.datalist) {
        element = this.datalist;
      } else {
        element = this.opts.element;
      } //  - need to be able to specify the initial value of select components bound to dprv


      if (!_ComboUtils.applyValueOptions(this, this.opts)) {
        this.opts.initSelection.call(null, element, function (data) {
          if (data !== undefined && data !== null && data.length !== 0) {
            self._updateSelection(data);

            self.close(); // set the placeholder if necessary

            self._clearSearch();
          }
        });
      }
    }
  },
  _focus: function _focus() {
    this.close();
    this.search.focus();
  },
  _updateSelection: function _updateSelection(data) {
    var ids = [];
    var filtered = [];
    var self = this; // filter out duplicates

    $(data).each(function () {
      if (ids.indexOf(self.id(this)) < 0) {
        ids.push(self.id(this));
        filtered.push(this);
      }
    });

    if (filtered && filtered.length > 0 && (this._classNm === 'oj-combobox' || this._classNm === 'oj-select')) {
      // JET-35213 - reset issue in required oj-select-many
      // When calling reset method, the valueOptions might not have been set (like when click on an option,
      // where valueOptions will be set before updating selection). In such scenarios, where the valueOptions
      // are not updated the filtered data from the data provider should be set as valueOptions instead of populating
      // from the current valueOptions even if it is not an initial fetch
      if (this.opts.fetchType === 'init' || !this._skipSetValueOptions) {
        // for initial fetch, the filtered data will include data/metadata information when bound to a data provider
        this.setValOpts(filtered);
      } else if (_ComboUtils.isDataProvider(this.opts.options)) {
        // for non-initial fetch from data provider, populate data/metadata from valueOptions for the selected ids
        filtered = _ComboUtils.findOptions(this.opts.valueOptions, ids);
      }
    }

    this.selection.find('.' + this._classNm + '-selected-choice').remove();
    this.selection.find('.oj-select-default').remove();

    this._updateAriaDescribedBy(null, true);

    $(filtered).each(function () {
      self._addSelectedChoice(this);
    }); // Storing this data so that it will be used when setting the display value.

    this.currentItem = filtered;
    this.currentValue = ids;

    self._postprocessResults();
  },

  /**
   * Updates the aria-describedby attribute on the content element
   * @param {string=} idToAdd The id of the DOM element that has to be added here
   * @param {boolean=} shouldRemoveExisting a flag to indicate if existsing ids should be removed
   *
   * @memberof! _AbstractMultiChoice
   * @instance
   * @private
   */
  _updateAriaDescribedBy: function _updateAriaDescribedBy(idToAdd, shouldRemoveExisting) {
    var $contentElement = this._contentElement;
    var $selectionElement = this.selection;
    var currentAriaDescribedbyIds = $contentElement.attr('aria-describedby') || '';
    var shouldUpdateAttribute = false;
    var updatedAriaDescribedbyIds = currentAriaDescribedbyIds; // Remove first and then add

    if (shouldRemoveExisting) {
      // remove only the ids that are added by selectcombobox
      this._ariaDescribedByAdded.forEach(function (id) {
        updatedAriaDescribedbyIds = updatedAriaDescribedbyIds.replace(id, '');
        shouldUpdateAttribute = true;
      }); // trim the ids to remove leading and trailing space and remove any extra spaces


      updatedAriaDescribedbyIds = updatedAriaDescribedbyIds.trim().replace(/\s\s+/g, ' ');
      this._ariaDescribedByAdded = [];
    } // Add ids after removing


    if (idToAdd) {
      updatedAriaDescribedbyIds = (updatedAriaDescribedbyIds + ' ' + idToAdd).trim();

      this._ariaDescribedByAdded.push(idToAdd);

      shouldUpdateAttribute = true;
    } // Only update the attribute on the DOM if it is modified


    if (shouldUpdateAttribute) {
      $contentElement.attr('aria-describedby', updatedAriaDescribedbyIds); // for combobox we need to update it on the ul as well as input element

      if (this._classNm === 'oj-combobox') {
        $selectionElement.attr('aria-describedby', updatedAriaDescribedbyIds);
      }
    }
  },
  // AbstractMultiChoice

  /**
   * Handles when a selection is made by the user
   *
   * @param {object} data A valueOption object for the currect selection
   * @param {object} options Options for _onSelect method on how to handle the event
   * @param {jQuery.Event=} event The event at which the method is invoked
   * @return {Promise|boolean|null} Result of setting the value
   *                                * Promise when using async validators
   *                                * boolean when using sync validators / when setting the value without validators
   *                                * null when setValue is not invoked since there was no change in the value
   *
   * @memberof! _AbstractMultiChoice
   * @instance
   * @private
   */
  _onSelect: function _onSelect(data, options, event) {
    if (!this._triggerSelect(data)) {
      return false;
    }

    var context;

    if (options && options.trigger) {
      context = {
        optionMetadata: {
          trigger: options.trigger
        }
      };
    } // selection will be added when _SetValue is called
    // this._addSelectedChoice(data);
    // Clone the value before invoking setVal(), otherwise it will not trigger change event.


    var val = this.getVal() ? this.getVal().slice(0) : []; // Initial Value options

    var valOptsInit = this.getValOpts() ? this.getValOpts().slice(0) : [];
    var valOpts = valOptsInit.slice(0);
    var isSelectCombobox = this._classNm === 'oj-combobox' || this._classNm === 'oj-select'; // If the component is invalid, we will not get all the values matching the displayed value

    if (!this.ojContext.isValid()) {
      val = this.currentValue.slice(0);
      valOpts = this.currentItem.slice(0);
    }

    var self = this;
    var id;
    var valOpt;
    var valueOptionsData = [];
    var valueOptionsMetadata = [];

    var opts = _ComboUtils.getOpts(this.ojContext);

    var isDataProvider = opts ? _ComboUtils.isDataProvider(opts.options) : false;
    var setValueReturn = null;
    var returnValue = null;
    var previousHasUncommittedValue = this.hasUncommittedValue;

    if (isDataProvider) {
      // populate data/metadata for existing selections
      for (var i = 0; i < valOpts.length; i++) {
        valOpt = valOpts[i];
        id = this.id(valOpt);
        valOpts[i] = _ComboUtils.findOptionFromResult(self, id, valOpt);
        valueOptionsData.push(valOpts[i].data);
        valueOptionsMetadata.push(valOpts[i].metadata);
      }
    }

    id = this.id(data);
    $(data).each(function (index) {
      if (val.indexOf(id) < 0 && id !== '') {
        val.push(id);

        if (isSelectCombobox) {
          //  - oj.tests.input.combobox.testcombobox display value mismatch automation failure
          if (Array.isArray(data)) {
            valOpt = _ComboUtils.findOptionFromResult(self, id, data[index]);
          } else {
            valOpt = _ComboUtils.findOptionFromResult(self, id, data);
          }

          valOpts.push(valOpt);

          if (isDataProvider) {
            // populate data/metadata for new selections
            valueOptionsData.push(valOpt.data);
            valueOptionsMetadata.push(valOpt.metadata);
          }
        }
      }
    }); // setValueOptions before setVal so that new entry already in valueOptions
    // this is to avoid looking for new entry on the dataProvider

    if (isSelectCombobox) {
      this._skipSetValueOptions = true;
      this.setValOpts(valOpts);
    } // set the valueOptions data and metadata in the context


    context = _ComboUtils.getContextWithExtraData(context, opts, valueOptionsData, valueOptionsMetadata); // Fix , 
    // For combobox, we are using the flag hasUncommittedValue to decide on whether
    // the label or the value would take part in validation.
    // So, when a selection is made, this flag has to be cleared before setting the value.

    this.hasUncommittedValue = false; // setVal method returns a promise that resolves to true|false or a boolean

    setValueReturn = this.setVal(val, event, context);

    if (setValueReturn instanceof Promise) {
      returnValue = setValueReturn.then(this._bind(function (result) {
        this._afterOnSelectSetVal(result, data, valOptsInit, previousHasUncommittedValue); // return the result of the validation, which can use by methods
        // that rely on the result of _onSelect call.


        return result;
      }));
    } else {
      // Sanitize the setValueReturn to be boolean.
      // we can treat null as a passed case, since it represents that
      // the value is already one of the selected values and a valid one.
      var result = setValueReturn !== false;

      this._afterOnSelectSetVal(result, data, valOptsInit, previousHasUncommittedValue);

      returnValue = setValueReturn;
    } // need not to wait for the validation to complete as the following
    // operations are a response to the event and not for setting the value.


    if (this.opts.closeOnSelect) {
      this.close(event);
    } // When clicking outside the combobox (including clicking on other components) triggers a blur event
    // Should not focus the search when the trigger is a blur event.


    if ((!options || options.trigger !== _ComboUtils.ValueChangeTriggerTypes.BLUR) && this._elemNm === 'ojcombobox') {
      this._focusSearch();
    }

    return returnValue;
  },

  /**
   * Performs operations that has to be done after the setVal call in _onSelect
   *
   * @param {boolean} result The result of the setVal call
   * @param {object} data A valueOption object for the currect selection
   * @param {object} valOptsInit The initial valueOptions
   * @param {boolean} previousHasUncommittedValue The initial hasCommittedValue flag value
   *
   * @memberof! _AbstractMultiChoice
   * @instance
   * @private
   */
  _afterOnSelectSetVal: function _afterOnSelectSetVal(result, data, valOptsInit, previousHasUncommittedValue) {
    var isSelectCombobox = this._classNm === 'oj-combobox' || this._classNm === 'oj-select'; // If the validation fails, set the hasUncommittedValue flag so as to revert it back to its
    // original state

    if (result === false) {
      // The validation failed, so reset the flag
      this.hasUncommittedValue = previousHasUncommittedValue; // : component oj-combobox-many displays the list of the values - does not exclude the invalid values
      // If the input text is invalid, restore to initial value options

      if (isSelectCombobox && !this.ojContext.isValid()) {
        this.setValOpts(valOptsInit);
      }
    }

    this._skipSetValueOptions = false;

    if (this.select || !this.opts.closeOnSelect) {
      this._postprocessResults(data, false, this.opts.closeOnSelect === true);
    }

    if (this.opts.closeOnSelect) {
      // do not reset search width if the input text is invalid
      // this will allow users to correct any invalid input text
      if (this.ojContext.isValid()) {
        this._resetSearchWidth();
      }
    }
  },
  _cancel: function _cancel(event) {
    this.close(event);

    if (this._elemNm === 'ojcombobox') {
      this._focusSearch();
    }
  },
  _addSelectedChoice: function _addSelectedChoice(data) {
    var enableChoice = !data.locked;
    var enabledItem = $("<li class='" + this._classNm + "-selected-choice'>" + '    <div></div>' + "    <a href='#' onclick='return false;' role='button' aria-label='remove' class='" + this._classNm + '-clear-entry ' + '      oj-component-icon oj-clickable-icon-nocontext ' + this._classNm + "-clear-entry-icon' tabindex='-1'>" + '    </a>' + '</li>');
    var disabledItem = $( // "<li class='oj-combobox-selected-choice oj-combobox-locked'>" +
    "<li class='" + this._classNm + '-selected-choice ' + this._classNm + "-locked'>" + '<div></div>' + '</li>');
    var choice = enableChoice ? enabledItem : disabledItem;
    var formatted;
    formatted = this.opts.formatSelection(data);

    if (formatted !== undefined) {
      // set the text and id for the label
      var selectedLabelId = this._classNm + '-selected-choice-label-' + _ComboUtils.nextUid();

      choice.find('div').addClass(this._classNm + '-selected-choice-label').text(formatted).attr('id', selectedLabelId);
      choice.find('.' + this._classNm + '-clear-entry').attr('aria-label', formatted + ' remove');
      choice.attr('valueText', formatted);

      this._updateAriaDescribedBy(selectedLabelId, false);
    }

    if (enableChoice) {
      choice.find('.' + this._classNm + '-clear-entry').on('mousedown', _ComboUtils.killEvent).on('click dblclick', this._bind(function (e) {
        if (!this._isInterfaceEnabled()) {
          return;
        }

        $(e.target).closest('.' + this._classNm + '-selected-choice').fadeOut('fast', this._bind(function () {
          this._unselect($(e.target), e);

          this.selection.find('.' + this._classNm + '-selected-choice.oj-focus').removeClass('oj-focus');
          this.close(e);

          if (this._elemNm === 'ojcombobox') {
            this._focusSearch();
          }
        })).dequeue();

        _ComboUtils.killEvent(e); // stop the propagation, so focus effect is not added to the choice


        e.stopPropagation();
      }));
    }

    choice.data(this._elemNm, data); // searchContainer is initialized in _initContainer() method.
    // And this can not be changed by an external developer. It is constructed by component only.

    if (this._elemNm === 'ojcombobox') {
      choice.insertBefore(this.searchContainer); // @HTMLUpdateOK
    } else {
      this.selection.append(choice); // @HTMLUpdateOK
    }
  },
  // keep valueOptions in sync with value
  _syncValueOptions: function _syncValueOptions(ojContext, value, valueOptions) {
    var newValOpts = [];
    var valueOptionsData = [];
    var valueOptionsMetadata = [];

    var opts = _ComboUtils.getOpts(this.ojContext);

    var isDataProvider = opts ? _ComboUtils.isDataProvider(opts.options) : false;
    var id;

    if (value && valueOptions) {
      for (var i = 0; i < value.length; i++) {
        for (var j = 0; j < valueOptions.length; j++) {
          var newOpt = valueOptions[j];

          if (oj.Object.compareValues(newOpt.value, value[i])) {
            if (isDataProvider) {
              id = this.id(newOpt);
              newOpt = _ComboUtils.findOptionFromResult(this, id, newOpt); // populate data/metadata for the current selections

              valueOptionsData.push(newOpt.data);
              valueOptionsMetadata.push(newOpt.metadata);
            }

            newValOpts.push(newOpt);
          }
        }
      }

      _ComboUtils.setValueOptions(ojContext, newValOpts); // set the new valueOptions in the current item


      this.currentItem = newValOpts;
    } // get the context with data/metadata info for data provider


    return _ComboUtils.getContextWithExtraData(null, opts, valueOptionsData, valueOptionsMetadata);
  },
  _unselect: function _unselect(oselected, event) {
    var val = this.getVal() ? this.getVal().slice(0) : [];
    var selected = oselected.closest('.' + this._classNm + '-selected-choice');

    if (selected.length === 0) {
      // TODO: translation string
      throw new Error('Invalid argument: ' + selected + '. Must be .' + this._classNm + '-selected-choice');
    }

    var data = selected.data(this._elemNm);

    if (!data) {
      // prevent a race condition when the 'x' is clicked really fast repeatedly the event can be queued
      // and invoked on an element already removed
      return;
    }

    var valOpts; // If the component is invalid, we will not get all the values matching the displayed value

    if (!this.ojContext.isValid()) {
      val = this.currentValue.slice(0);
      valOpts = this.currentItem.slice(0);
    } else {
      valOpts = (this.getValOpts() || []).slice(0);
    }

    var context;
    var setValueReturn;
    var index = val.indexOf(this.id(data));

    if (index !== -1) {
      val.splice(index, 1);
      context = this._syncValueOptions(this.ojContext, val, valOpts);
      this._skipSetValueOptions = true;
      setValueReturn = this.setVal(val, event, context);

      if (setValueReturn instanceof Promise) {
        setValueReturn.then(this._bind(function (result) {
          this._afterUnselectSetValue(result, selected);
        }));
      } else {
        this._afterUnselectSetValue(setValueReturn, selected);
      }
    }
  },

  /**
   * Performs operations that has to be done after setting the value in _unselect method
   *
   * @param {boolean} result The result of setVal call
   * @param {HTMLElement} selected The current selected element that has to be removed
   *
   * @memberof! _AbstractMultiChoice
   * @instance
   * @private
   */
  _afterUnselectSetValue: function _afterUnselectSetValue(result, selected) {
    this._skipSetValueOptions = false;

    if (result !== false && this.select) {
      this._postprocessResults();
    } // The selected option should be removed irrespective of the setVal result


    selected.remove();
  },
  // eslint-disable-next-line no-unused-vars
  _postprocessResults: function _postprocessResults(data, initial, noHighlightUpdate) {
    // display all available options in the drop down if the component is in invaid state
    if (!this.ojContext.isValid()) {
      return;
    }

    var val = this.getVal();
    var choices = this.results.find('.oj-listbox-result');
    var compound = this.results.find('.oj-listbox-result-with-children');
    var self = this;

    _ComboUtils.each2(choices, function (i, choice) {
      var id = self.id(choice.data(self._elemNm));

      if (val && val.indexOf(id) >= 0) {
        choice.addClass('oj-selected'); // mark all children of the selected parent as selected

        choice.find('.oj-listbox-result-selectable').addClass('oj-selected');
      }
    });

    _ComboUtils.each2(compound, function (i, choice) {
      // hide an optgroup if it doesnt have any selectable children
      if (!choice.is('.oj-listbox-result-selectable') && choice.find('.oj-listbox-result-selectable:not(.oj-selected)').length === 0) {
        choice.addClass('oj-selected');
      }
    }); //  - grouping header accessibility issue for jaws


    this._processAriaLabelForHierarchy();

    if (!choices.filter('.oj-listbox-result:not(.oj-selected)').length > 0 && this._classNm !== 'oj-select') {
      this.close(null, true);
    }
  },
  _isDataSelected: function _isDataSelected(data) {
    var val = this.getVal();

    if (!val || val.length === 0) {
      return false;
    }

    var results = data.results;

    for (var i = 0; i < results.length; i++) {
      if (val.indexOf(this.id(results[i])) === -1) {
        return false;
      }
    }

    return true;
  },
  _resetSearchWidth: function _resetSearchWidth() {// do nothing. subclass override
  },

  /**
   * Sets the value
   *
   * @param {Array<any>} val The value to be set
   * @param {jQuery.Event=} event The event at which the method is invoked
   * @param {object} context Context
   * @return {Promise|boolean|null} Result of setting the value
   *                                * Promise when using async validators
   *                                * boolean when using sync validators / when setting the value without validators
   *                                * null when setValue is not invoked since there was no change in the value
   *
   * @memberof! _AbstractMultiChoice
   * @instance
   * @override
   * @ignore
   */
  setVal: function setVal(val, event, context) {
    var unique = [];
    var vals = val; //  - selected value got replaced once the label for initial value is available

    this.valHasChanged();

    if (typeof val === 'string') {
      vals = _ComboUtils.splitVal(val, this.opts.separator);
    } // filter out duplicates


    for (var i = 0; i < vals.length; i++) {
      if (unique.indexOf(vals[i]) < 0) {
        unique.push(vals[i]);
      }
    }

    var options = {
      doValueChangeCheck: false
    };

    if (context) {
      options._context = context;
    } //  - need to be able to specify the initial value of select components bound to dprv
    // set valueOption


    if (!this._skipSetValueOptions) {
      var queryResult = _ComboUtils.getLastQueryResult(this);

      var match;

      if (queryResult) {
        match = _ComboUtils.findOptions(queryResult, vals);
      }

      if (match && match.length) {
        _ComboUtils.setValueOptions(this.ojContext, match);
      }
    } // Fix  - CUSTOM MESSAGES ARE BEING CLEARED WHEN THE VALUE DOESN'T CHANGE
    // If the value has not changed, bypass the call to _SetValue method in EditableValue.
    // Because we don't have to set the same value again in EditableValue.
    // Note: If there are component validation errors the value may not reflect the display value,
    // hence set value if the component has invalid messages even if the value has not changed.
    // If there are custom error messages set via 'messagesCustom' attribute, the value will reflect
    // the display value and so no need to set value if the value has not changed.


    var previousVal = this.getVal();
    var setValueResult = null;

    if (!oj.Object.compareValues(previousVal, unique) || _ComboUtils.hasInvalidComponentMessages(this.ojContext)) {
      setValueResult = this.ojContext._SetValue(unique, event, options);
    }

    if (setValueResult instanceof Promise) {
      // eslint-disable-next-line no-unused-vars
      return setValueResult.then(this._bind(function (result) {
        this._afterSetValue(unique);
      }));
    } // Call afterSetValue unconditionally if setValue is executed synchronously
    // as this method has parts of code that needs to be executed for both when
    // validation passes or when it fails. The checks are done in the method
    // so it is okay to call this function unconditionally here.


    this._afterSetValue(unique);

    return setValueResult;
  },

  /**
   * Executes the operations that has to be done after the _SetValue call
   *
   * @param {Array} unique The array of unique set of values that was set in the _SetValue call
   *
   * @memberof! _AbstractMultiChoice
   * @instance
   * @private
   */
  _afterSetValue: function _afterSetValue(unique) {
    if (this.ojContext.isValid() || unique.length === 0) {
      this.currentValue = unique;
    }

    this.search.attr('aria-activedescendant', this.opts.element.attr('id'));
  },

  /**
   * Returns the selection data
   * @instance
   * @private
   * @ignore
   * @return {Array|null}
   */
  _getSelectionData: function _getSelectionData() {
    var dataArr = null;
    var self = this;
    var data = null;
    var choices = this.container.find('.' + this._classNm + '-selected-choice');

    if (choices) {
      dataArr = [];
      choices.each(function () {
        data = $(this).data(self._elemNm);

        if (data != null) {
          dataArr.push(data);
        }
      });
    }

    return dataArr;
  },

  /**
   * Handles clearing the search when the user blurs out from the search
   * @instance
   * @private
   * @ignore
   */
  _clearSearchOnBlur: function _clearSearchOnBlur() {
    // : component oj-combobox-many displays validation error message even when no value is entered in the component
    // do not clear search if the input text is invalid
    // this will allow users to correct any invalid input text
    if (!this._opened() && this._classNm !== 'oj-select' && this.ojContext.isValid()) {
      this._clearSearch();
    }
  },

  /**
   * Returns the components wrapper under which label needs to be inserted in the inside strategy
   * @instance
   * @protected
   * @ignore
   * @return {Element|undefined}
   */
  _GetContentWrapper: function _GetContentWrapper() {
    return this.container[0].querySelector('.oj-text-field-container');
  }
});



/**
 * @preserve Copyright 2012 Igor Vaynberg
 *
 * This software is licensed under the Apache License, Version 2.0 (the "Apache License") or the GNU
 * General Public License version 2 (the "GPL License"). You may choose either license to govern your
 * use of this software only upon the condition that you accept all of the terms of either the Apache
 * License or the GPL License.
 *
 * You may obtain a copy of the Apache License and the GPL License at:
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 * http://www.gnu.org/licenses/gpl-2.0.html
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * Apache License or the GPL Licesnse is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the Apache License and the GPL License for
 * the specific language governing permissions and limitations under the Apache License and the GPL License.
 */

/* global _ComboUtils:false, _AbstractMultiChoice:false */

/**
 * @private
 */
var _OjMultiCombobox = _ComboUtils.clazz(_AbstractMultiChoice, {
  _elemNm: 'ojcombobox',
  _classNm: 'oj-combobox',
  _COMPONENT_CLASSLIST: 'oj-combobox oj-combobox-multi oj-component',

  /**
   * Creates children elements for oj-combobox-many
   *
   * @return {jQuery} The collection of HTML elements that represent the content
   *
   * @memberof! _OjMultiCombobox
   * @instance
   * @protected
   * @override
   */
  _CreateContentElements: function _CreateContentElements() {
    var contentStructure = ["<div class='oj-text-field-container' role='presentation'> ", "<ul class='oj-combobox-choices'>", "  <li class='oj-combobox-search-field'><span class='oj-helper-hidden'>&nbsp;</span>", "    <input type='text' role='combobox' aria-expanded='false' aria-autocomplete='list' autocomplete='off' autocorrect='off' autocapitalize='off' spellcheck='false' class='oj-combobox-input'>", '  </li>', '</ul>', '</div>', "<div class='oj-combobox-description oj-helper-hidden-accessible'></div>", "<div class='oj-listbox-drop oj-listbox-drop-multi'>", "   <ul class='oj-listbox-results' role='listbox'>", '   </ul>', '</div>', "<div class='oj-helper-hidden-accessible oj-listbox-liveregion' aria-live='polite'></div>"];
    return $(contentStructure.join(''));
  },
  _opening: function _opening(event, dontUpdateResults) {
    // if beforeExpand is not cancelled
    // beforeExpand event will be triggered in base class _shouldOpen method
    this._resizeSearch();

    _OjMultiCombobox.superclass._opening.apply(this, arguments);

    this._focusSearch();

    if (!dontUpdateResults) {
      this._updateResults(true);
    }

    this.search.focus();
  },
  _clearSearch: function _clearSearch() {
    var placeholder = this._getPlaceholder();

    var maxWidth = this._getMaxSearchWidth(); //  - need to be able to specify the initial value of select components bound to dprv


    if (placeholder != null && _ComboUtils.isValueForPlaceholder(true, this.getVal()) && _ComboUtils.isValueOptionsForPlaceholder(true, this.getValOpts())) {
      this.search.attr('placeholder', placeholder); // stretch the search box to full width of the container so as much of the placeholder is visible as possible
      // we could call this._resizeSearch(), but we do not because that requires a sizer and we do not want to create one so early because of a firefox bug, see #944

      this.search.val('').width(maxWidth > 0 ? maxWidth : this.container.css('width')); //  when the component is pre-created, the input box would get the default size

      this.searchContainer.width('100%');
    } else {
      this.search.attr('placeholder', '');
      this.search.val('').width(10); // reset the search container, so the input doesn't go to the next line if there is still room

      this.searchContainer.width('auto');
    }
  },
  _resetSearchWidth: function _resetSearchWidth() {
    this.search.width(10);
  },
  _getMaxSearchWidth: function _getMaxSearchWidth() {
    return this.selection.width() - _ComboUtils.getSideBorderPadding(this.search);
  },
  _textWidth: function _textWidth(text) {
    var textSpan = document.createElement('span');
    var textNode = document.createTextNode(text);
    textSpan.style.display = 'none';
    textSpan.appendChild(textNode); // @HTMLUpdateOK

    $('body').append(textSpan); // @HTMLUpdateOK

    var width = $('body').find('span:last').width();
    $('body').find('span:last').remove();
    return width;
  },
  _resizeSearch: function _resizeSearch() {
    var minimumWidth;
    var left;
    var maxWidth;
    var containerLeft;
    var searchWidth;

    var sideBorderPadding = _ComboUtils.getSideBorderPadding(this.search);

    minimumWidth = this._textWidth(this.search.val()) + 10;
    left = this.search.offset().left;
    maxWidth = this.selection.width();
    containerLeft = this.selection.offset().left;
    searchWidth = maxWidth - (left - containerLeft) - sideBorderPadding;

    if (searchWidth < minimumWidth) {
      searchWidth = maxWidth - sideBorderPadding;
    }

    if (searchWidth < 40) {
      searchWidth = maxWidth - sideBorderPadding;
    }

    if (searchWidth <= 0) {
      searchWidth = minimumWidth;
    }

    this.search.width(Math.floor(searchWidth));
  }
});



/**
 * @preserve Copyright 2012 Igor Vaynberg
 *
 * This software is licensed under the Apache License, Version 2.0 (the "Apache License") or the GNU
 * General Public License version 2 (the "GPL License"). You may choose either license to govern your
 * use of this software only upon the condition that you accept all of the terms of either the Apache
 * License or the GPL License.
 *
 * You may obtain a copy of the Apache License and the GPL License at:
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 * http://www.gnu.org/licenses/gpl-2.0.html
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * Apache License or the GPL Licesnse is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the Apache License and the GPL License for
 * the specific language governing permissions and limitations under the Apache License and the GPL License.
 */

/* global _ComboUtils:false, _AbstractMultiChoice:false */

/**
 * @private
 */
var _OjMultiSelect = _ComboUtils.clazz(_AbstractMultiChoice, {
  _elemNm: 'ojselect',
  _classNm: 'oj-select',
  _userTyping: false,
  _COMPONENT_CLASSLIST: 'oj-select oj-select-multi oj-component',

  /**
   * Creates children elements for oj-select-many
   *
   * @return {jQuery} The collection of HTML elements that represent the content
   *
   * @memberof! _OjMultiSelect
   * @instance
   * @protected
   * @override
   */
  _CreateContentElements: function _CreateContentElements() {
    var contentStructure = ["<div class='oj-text-field-container' role='presentation'>", "<ul class='oj-select-choices' tabindex='0' role='combobox' ", "  aria-autocomplete='none' aria-expanded='false'>", '</ul>', '</div>', "<div class='oj-select-description oj-helper-hidden-accessible'></div>", "<div class='oj-listbox-drop' role='dialog'>", "  <div class='oj-listbox-search-wrapper'>", "  <div class='oj-listbox-search'>", "    <input type='text' autocomplete='off' autocorrect='off' autocapitalize='off'", "           spellcheck='false' class='oj-listbox-input' title='Search field' ", "           role='combobox' aria-expanded='false' aria-autocomplete='list' />", "    <span class='oj-listbox-spyglass-box'>", "      <span class='oj-component-icon oj-listbox-search-icon' role='presentation'>", "       <b role='presentation'></b></span>", '    </span>', '  </div>', '  </div>', "   <ul class='oj-listbox-results' role='listbox'>", '   </ul>', '</div>', "<div class='oj-helper-hidden-accessible oj-listbox-liveregion' aria-live='polite'></div>"];
    return $(contentStructure.join(''));
  },
  // _OjMultiSelect
  // eslint-disable-next-line no-unused-vars
  _enable: function _enable(enabled) {
    _OjMultiSelect.superclass._enable.apply(this, arguments);

    if (this._enabled) {
      var elementTabIndex = this.elementTabIndex ? this.elementTabIndex : '0';
      this.selection.attr('tabindex', elementTabIndex);
    } else {
      // Don't allow focus on a disabled "select"
      this.selection.attr('tabindex', '-1');
    }
  },
  _containerKeydownHandler: function _containerKeydownHandler(e) {
    _OjMultiSelect.superclass._containerKeydownHandler.apply(this, arguments);

    if (this._userTyping && !this._opened()) {
      this.open(e);
    }
  },
  _opening: function _opening(event, dontUpdateResults) {
    // if beforeExpand is not cancelled
    // beforeExpand event will be triggered in base class _shouldOpen method
    _OjMultiSelect.superclass._opening.apply(this, arguments); //  - select input gets stuck with sdp fetchchain delay
    // show drop down in order to show the searchBox


    this._showDropDown();

    var searchText = _ComboUtils.getSearchText(event); // select: focus still stay on the selectBox if open dropdown by mouse click


    this._showSearchBox(searchText);

    if (!dontUpdateResults) {
      if (searchText) {
        this._updateResults();
      } else {
        this._updateResults(true);
      }
    }
  },
  close: function close(event) {
    // reset _userTyping after drop down is closed
    if (this._userTyping === true) {
      this._userTyping = false;
    } // Bug JET-34119 - focus is not returned to oj-select-one after selecting an option from the dropdown
    // return the focus to the select if the event.target is in the dropdown.
    // We need to determine whether the focus has to be returned to the select or not
    // If the event is of type MouseEvent or FocusEvent, it has be checked if the
    // event target is a part of the select or its dropdown and only if it is
    // the focus should be retained.
    // Note: In Firefox, Safari and Edge clicking on an input element triggers a
    // FocusEvent while in Chrome and IE11, MouseEvent will be triggered. So both
    // has to be considered here.


    var originalEvent = event ? event.originalEvent : null;
    var isMouseOrFocusEvent = originalEvent instanceof MouseEvent || originalEvent instanceof FocusEvent;
    var shouldReturnFocus = event && (!isMouseOrFocusEvent || event.target === this.selection || event.target === this.search || this.dropdown.has(event.target).length > 0);

    _OjMultiSelect.superclass.close.apply(this, arguments); // When the dropdown is open and if the close method is invoked
    // by clicking directly on an input element, different browsers
    // behave differently.
    // Some, triggers mousedown event before a focus event on the target element
    // which results in this method being called before this.ojContext._handleAfterFocusToggle
    // which thus results in the expected behavior. But in other browsers it is the
    // opposite, which results in the _handleAfterFocusToggle method to be called
    // with focusOut event before closing the dropdown. This incorrectly results in
    // oj-focus class being added to the root element. In this case, we would have
    // to remove the class. As the select is currently not focused and also does not
    // have the dropdown open, it should not have oj-focus class.


    if (this.ojContext.hasAfterToggleHandlerAddedFocusClass && !shouldReturnFocus) {
      this.ojContext._getRootElement().classList.remove('oj-focus');

      this.ojContext.hasAfterToggleHandlerAddedFocusClass = false;
    }

    if (shouldReturnFocus) {
      _ComboUtils._focus(this, this.selection);
    }
  },
  _clearSearch: function _clearSearch() {
    var placeholder = this._getPlaceholder();

    if (placeholder != null && _ComboUtils.isValueForPlaceholder(true, this.getVal()) && _ComboUtils.isValueOptionsForPlaceholder(true, this.getValOpts())) {
      var node = $('<li></li>');
      node.addClass('oj-select-default');
      node.text(placeholder);
      this.selection.append(node); // @HTMLUpdateOK
    }
  }
});



/* global _ComboUtils:false, _OjSingleCombobox:false */

/**
 * @private
 */
var _OjInputSeachContainer = _ComboUtils.clazz(_OjSingleCombobox, {
  _elemNm: 'ojinputsearch',
  _classNm: 'oj-inputsearch',
  _COMPONENT_CLASSLIST: 'oj-inputsearch oj-component',
  // return the element one which we want to position the listbox-dropdown. We don't
  // want it to be the container because we add the inline messages to the container
  // and if we line up to the container when it has inline messages, the dropdown
  // appears after the inline messages. We want it to always appear next to the input,
  // which is the first child of the container.
  _getDropdownPositionElement: function _getDropdownPositionElement() {
    return this.container.children().first();
  },

  /**
   * Creates children elements for ojInputSearch
   *
   * @return {jQuery} The collection of HTML elements that represent the content
   *
   * @memberof! _OjInputSeachContainer
   * @instance
   * @protected
   * @override
   */
  _CreateContentElements: function _CreateContentElements() {
    var contentStructure = ["<div class='oj-inputsearch-choice' tabindex='-1' role='presentation'>", "   <input type='text' autocomplete='off' autocorrect='off' autocapitalize='off'", "       spellcheck='false' class='oj-inputsearch-input' role='combobox' aria-expanded='false' aria-autocomplete='list' />", "   <a class='oj-inputsearch-search-button oj-inputsearch-search-icon oj-component-icon oj-clickable-icon-nocontext'", "       role='button' aria-label='search'></a>", '</div>', "<div class='oj-listbox-drop' role='presentation'>", "   <ul class='oj-listbox-results' role='listbox'>", '   </ul>', '</div>', "<div role='region' class='oj-helper-hidden-accessible oj-listbox-liveregion' aria-live='polite'></div>"];
    var container = $(contentStructure.join(''));
    var trigger = container.find('.oj-inputsearch-search-button');

    this._attachSearchIconClickHandler(trigger);

    return container;
  },
  _attachSearchIconClickHandler: function _attachSearchIconClickHandler(trigger) {
    var self = this;
    trigger.on('click', function (event) {
      if (!self._isInterfaceEnabled()) {
        return undefined;
      }

      if (self.opts.manageNewEntry) {
        var value = self.search.val();
        var data = self.opts.manageNewEntry(value);
        var options = {
          trigger: _ComboUtils.ValueChangeTriggerTypes.SEARCH_ICON_CLICKED
        };
        var selectionData = self.selection.data(self._elemNm);

        if (!selectionData && value !== '' || selectionData && selectionData.label !== value || !self.ojContext.isValid() && value !== self._previousDisplayValue) {
          self._onSelect(data, options, event);

          self._triggerUpdateEvent(data, options, event);
        } else {
          if (selectionData && selectionData.label === value) {
            data = selectionData;
          }

          self._triggerUpdateEvent(data, options, event);
        }
      }

      return false;
    }).on('mousedown', function (event) {
      event.stopPropagation();
      return false;
    });
  },
  // _OjInputSeachContainer
  // eslint-disable-next-line no-unused-vars
  _enable: function _enable(enabled) {
    _OjInputSeachContainer.superclass._enable.apply(this, arguments);

    if (this._enabled) {
      this.container.find('.oj-inputsearch-search-button').removeClass('oj-disabled');
    } else {
      this.container.find('.oj-inputsearch-search-button').addClass('oj-disabled');
    }
  },
  // _OjInputSeachContainer
  // Overriding this method to fire the "update" event which is relevant to
  // only InputSearch
  _triggerUpdateEvent: function _triggerUpdateEvent(data, context, event) {
    var trigger;

    if (context) {
      trigger = context.trigger;
    }

    var options = {
      _context: {
        optionMetadata: {
          trigger: trigger
        }
      }
    };
    var value = this.id(data);

    if (!value || value.length === 0) {
      // If the value is entered by user (not by selecting an option) then
      // only 'label' will be present in the data object.
      value = data.label ? data.label : [];
    } // inputSearch is a widget component, and only has synchronous validation


    var parsed = this.ojContext._AsyncValidate(value, event, options);

    if (parsed === undefined || !this.ojContext.isValid()) {
      return;
    }

    if (typeof value === 'string') {
      value = [value];
    }

    var eventData = {
      value: value,
      optionMetadata: {
        trigger: trigger
      }
    };

    this.ojContext._trigger('update', event, eventData);
  },
  // _OjInputSeachContainer
  // eslint-disable-next-line no-unused-vars
  _prepareOpts: function _prepareOpts(_opts) {
    var opts = _OjInputSeachContainer.superclass._prepareOpts.apply(this, arguments);

    opts.highlightTermInOptions = function () {
      return true;
    };

    return opts;
  }
});



/* jslint browser: true,devel:true*/

/**
 * The oj.Optgroup interface defines API for a group option of the JET Select and Combobox.
 * Use <code class="prettyprint">oj.Option</code> for a leaf option and <code class="prettyprint">oj.Optgroup</code> for a group option.
 * <ul>
 * <li><code class="prettyprint">children</code> is a required attribute to group the Option children.</li>
 * <li><code class="prettyprint">label</code> is a required attribute</li>
 * </ul>
 * <p>See <a href="oj.Option.html">oj.Option</a> for a leaf option</p>
 * <p>See {@link oj.ojComboboxOne#options}</p>
 * <p>See {@link oj.ojComboboxMany#options}</p>
 * <p>See {@link oj.ojSelectOne#options}</p>
 * <p>See {@link oj.ojSelectMany#options}</p>
 * @since 4.1.0
 * @export
 * @interface oj.Optgroup
 */

/**
 * Label is a required attribute. It is used to display the group label.
 *
 * @export
 * @expose
 * @memberof oj.Optgroup
 * @instance
 * @name label
 * @type {string}
 */

/**
 * disabled is an optional attribute. When specified, all options in the group is not selectable.
 *
 * @export
 * @expose
 * @memberof oj.Optgroup
 * @instance
 * @name disabled
 * @type {boolean}
 * @ojsignature { target: "Type",
 *                value: "?"}
 */

/**
 * Children is a required attribute. It is used to group its Option or Optgroup children.
 *
 * @export
 * @expose
 * @memberof oj.Optgroup
 * @instance
 * @name children
 * @type {Array.<oj.Option|oj.Optgroup>}
 */

/**
 * End of jsdoc
 */



/* jslint browser: true,devel:true*/

/**
 * The oj.Option interface defines API for a leaf option of the JET select and combobox.
 * Use <code class="prettyprint">oj.Option</code> for a leaf option and <code class="prettyprint">oj.Optgroup</code> for a group option.
 * <ul>
 * <li><code class="prettyprint">value</code> is a required attribute. It must be a row key in the data provider.</li>
 * <li><code class="prettyprint">label</code> is an optional attribute. If missing, String(value) is used.</li>
 * </ul>
 * <p>See <a href="oj.Optgroup.html">oj.Optgroup</a> for group option</p>
 * <p>See {@link oj.ojComboboxOne#options}</p>
 * <p>See {@link oj.ojComboboxMany#options}</p>
 * <p>See {@link oj.ojSelectOne#options}</p>
 * <p>See {@link oj.ojSelectMany#options}</p>
 * <p>See {@link oj.ojMenuSelectMany#options}</p>
 * @since 4.1.0
 * @export
 * @interface oj.Option
 */

/**
 * value is required attribute. It must be the row key in the data provider because JET Select and Combobox use "value" to fetch the displayed "label".
 *
 * @export
 * @expose
 * @memberof oj.Option
 * @instance
 * @name value
 * @type {Object}
 */

/**
 * label is an optional attribute. It is the display label for the option item. If it's missing, String(value) will be used.
 *
 * @export
 * @expose
 * @memberof oj.Option
 * @instance
 * @name label
 * @type {string}
 * @ojsignature { target: "Type",
 *                value: "?"}
 */

/**
 * disabled is an optional attribute. When disabled is true, the option item is not selectable.
 *
 * @export
 * @expose
 * @memberof oj.Option
 * @instance
 * @name disabled
 * @type {boolean}
 * @ojsignature { target: "Type",
 *                value: "?"}
 */

/**
 * End of jsdoc
 */



/* global _ComboUtils:false, _OjMultiCombobox:false, _OjSingleCombobox:false, Promise:false */

/**
   * @ojcomponent oj.ojComboboxOne
   * @augments oj.ojCombobox
   * @since 0.6.0
   * @ojdisplayname Combobox (One)
   * @ojshortdesc A combobox one is a dropdown list that supports single selection, text input, and search filtering.
   * @ojrole combobox
   * @ojsignature [{
   *                target: "Type",
   *                value: "class ojComboboxOne<K, D, V= any> extends ojCombobox<V, ojComboboxOneSettableProperties<K, D, V>, V, string>",
   *                genericParameters: [{"name": "K", "description": "Type of key of the dataprovider"}, {"name": "D", "description": "Type of data from the dataprovider"}
   *                , {"name": "V", "description": "Type of value of the component"}]
   *               },
   *               {
   *                target: "Type",
   *                value: "ojComboboxOneSettableProperties<K, D, V=any> extends ojComboboxSettableProperties<V>",
   *                for: "SettableProperties"
   *               }
   *              ]
   * @ojtsimport {module: "ojconverter-number", type: "AMD", imported: ["IntlNumberConverter", "NumberConverter"]}
   * @ojtsimport {module: "ojconverter-datetime", type: "AMD",  imported: ["IntlDateTimeConverter", "DateTimeConverter"]}
   * @ojtsimport {module: "ojvalidator", type: "AMD", importName: "Validator"}
   * @ojtsimport {module: "ojvalidator-async", type: "AMD", importName: "AsyncValidator"}
   * @ojtsimport {module: "ojconverter-datetime", type: "AMD",  imported: ["IntlDateTimeConverter", "DateTimeConverter"]}
   * @ojtsimport {module: "ojvalidator-daterestriction", type: "AMD", importName: "DateRestrictionValidator"}
   * @ojtsimport {module: "ojvalidator-datetimerange", type: "AMD", importName: "DateTimeRangeValidator"}
   * @ojtsimport {module: "ojvalidator-length", type: "AMD", importName: "LengthValidator"}
   * @ojtsimport {module: "ojvalidator-numberrange", type: "AMD", importName: "NumberRangeValidator"}
   * @ojtsimport {module: "ojvalidator-regexp", type: "AMD", importName: "RegExpValidator"}
   * @ojtsimport {module: "ojvalidator-required", type: "AMD", importName: "RequiredValidator"}
   *
   * @ojpropertylayout {propertyGroup: "common", items: ["labelHint", "placeholder", "required", "disabled"]}
   * @ojpropertylayout {propertyGroup: "data", items: ["value", "options"]}
   * @ojvbdefaultcolumns 6
   * @ojvbmincolumns 2
   *
   * @classdesc
   * <h3 id="comboboxOneOverview-section">
   *   JET Combobox One
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#comboboxOneOverview-section"></a>
   * </h3>
   * <p>Description: JET Combobox One provides support for single-select, text input, and search filtering.</p>
   *
   * <p>A JET Combobox One can be created with the following markup.</p>
   *
   * <pre class="prettyprint">
   * <code>
   * &lt;oj-combobox-one>
   *   &lt;oj-option value="option 1">option 1&lt;/oj-option>
   *   &lt;oj-option value="option 2">option 2&lt;/oj-option>
   *   &lt;oj-option value="option 3">option 3&lt;/oj-option>
   *   &lt;oj-option value="option 4">option 4&lt;/oj-option>
   * &lt;/oj-combobox-one>
   * </code></pre>
   *
   * {@ojinclude "name":"validationAndMessagingDoc"}
   *
   * <h3 id="touch-section">
   *   Touch End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"touchDocOne"}
   *
   * <h3 id="keyboard-section">
   *   Keyboard End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"keyboardDocOne"}
   *
   * <h3 id="perf-section">
   *   Performance
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#perf-section"></a>
   * </h3>
   *
   * <h4>Page Load</h4>
   * <p>If the <a href="#options">options</a> attribute is a data provider, and if there is an initially selected value, setting the <a href="#valueOption">valueOption</a> attribute initially can improve page load performance because the element will not have to fetch the selected label from the data provider.</p>
   * <p>When using a data provider, the dropdown data isn't fetched until the user opens the dropdown.</p>
   *
   *
   * {@ojinclude "name":"comboboxCommon"}
   */
// --------------------------------------------------- oj.ojCombobox-One Styling Start ------------------------------------------------------------

/**
   * @classdesc The following CSS classes can be applied by the page author as needed.<br/>
   * The form control style classes can be applied to the component, or an ancestor element. <br/>
   * When applied to an ancestor element, all form components that support the style classes will be affected.
   */
// ---------------- oj-form-control-full-width --------------

/**
  * Changes the max-width to 100% so that form components will occupy all the available horizontal space.
  * @ojstyleclass oj-form-control-full-width
  * @ojdisplayname Full Width
  * @memberof oj.ojComboboxOne
  * @ojtsexample
  * &lt;oj-combobox-one class="oj-form-control-full-width">
  *   &lt;oj-option value="option 1">option 1&lt;/oj-option>
  *   &lt;oj-option value="option 2">option 2&lt;/oj-option>
  *   &lt;oj-option value="option 3">option 3&lt;/oj-option>
  *   &lt;oj-option value="option 4">option 4&lt;/oj-option>
  * &lt;/oj-combobox-one>
  */
// ---------------- oj-form-control max-width --------------

/**
* In the Redwood theme the default max width of a text field is 100%.
* These max width convenience classes are available to create a medium or small field.<br>
* The class is applied to the root element.
* @ojstyleset form-control-max-width
* @ojdisplayname Max Width
* @ojstylesetitems ["form-control-max-width.oj-form-control-max-width-sm", "form-control-max-width.oj-form-control-max-width-md"]
* @ojstylerelation exclusive
* @memberof oj.ojComboboxOne
* @ojtsexample
* &lt;oj-combobox-one class="oj-form-control-max-width-md">
*   &lt;oj-option value="option 1">option 1&lt;/oj-option>
*   &lt;oj-option value="option 2">option 2&lt;/oj-option>
*   &lt;oj-option value="option 3">option 3&lt;/oj-option>
* &lt;/oj-combobox-one>
*/

/**
* @ojstyleclass form-control-max-width.oj-form-control-max-width-sm
* @ojshortdesc Sets the max width for a small field
* @ojdisplayname Small
* @memberof! oj.ojComboboxOne
 */

/**
* @ojstyleclass form-control-max-width.oj-form-control-max-width-md
* @ojshortdesc Sets the max width for a medium field
* @ojdisplayname Medium
* @memberof! oj.ojComboboxOne
 */
// ---------------- oj-form-control width --------------

/**
* In the Redwood theme the default width of a text field is 100%.
* These width convenience classes are available to create a medium or small field.<br>
* The class is applied to the root element.
* @ojstyleset form-control-width
* @ojdisplayname Width
* @ojstylesetitems ["form-control-width.oj-form-control-width-sm", "form-control-width.oj-form-control-width-md"]
* @ojstylerelation exclusive
* @memberof oj.ojComboboxOne
* @ojtsexample
* &lt;oj-combobox-one class="oj-form-control-width-md">
*   &lt;oj-option value="option 1">option 1&lt;/oj-option>
*   &lt;oj-option value="option 2">option 2&lt;/oj-option>
*   &lt;oj-option value="option 3">option 3&lt;/oj-option>
* &lt;/oj-combobox-one>
*/

/**
* @ojstyleclass form-control-width.oj-form-control-width-sm
* @ojshortdesc Sets the width for a small field
* @ojdisplayname Small
* @memberof! oj.ojComboboxOne
 */

/**
* @ojstyleclass form-control-width.oj-form-control-width-md
* @ojshortdesc Sets the width for a medium field
* @ojdisplayname Medium
* @memberof! oj.ojComboboxOne
 */
// ---------------- oj-form-control-text-align- --------------

/**
 * Classes that help align text of the element.
 * @ojstyleset text-align
 * @ojdisplayname Text Alignment
 * @ojstylesetitems ["text-align.oj-form-control-text-align-right", "text-align.oj-form-control-text-align-start", "text-align.oj-form-control-text-align-end"]
 * @ojstylerelation exclusive
 * @memberof oj.ojComboboxOne
 * @ojtsexample
 * &lt;oj-combobox-one class="oj-form-control-text-align-right">
 *   &lt;oj-option value="option 1">option 1&lt;/oj-option>
 *   &lt;oj-option value="option 2">option 2&lt;/oj-option>
 *   &lt;oj-option value="option 3">option 3&lt;/oj-option>
 *   &lt;oj-option value="option 4">option 4&lt;/oj-option>
 * &lt;/oj-combobox-one>
 */

/**
 * @ojstyleclass text-align.oj-form-control-text-align-right
 * @ojshortdesc Aligns the text to the right regardless of the reading direction. This is normally used for right aligning numbers.
 * @ojdisplayname Align-Right
 * @memberof! oj.ojComboboxOne
 */

/**
 * @ojstyleclass text-align.oj-form-control-text-align-start
 * @ojshortdesc Aligns the text to the left in LTR and to the right in RTL.
 * @ojdisplayname Align-Start
 * @memberof! oj.ojComboboxOne
 */

/**
 * @ojstyleclass text-align.oj-form-control-text-align-end
 * @ojshortdesc Aligns the text to the right in LTR and to the left in RTL.
 * @ojdisplayname Align-End
 * @memberof! oj.ojComboboxOne
 */
// --------------------------------------------------- oj.ojCombobox -One Styling end ------------------------------------------------------------

/**
   * @ojcomponent oj.ojComboboxMany
   * @augments oj.ojCombobox
   * @since 0.6.0
   * @ojdisplayname Combobox (Many)
   * @ojshortdesc A combobox many is a dropdown list that supports multiple selections, text input, and search filtering.
   * @ojrole combobox
   * @ojsignature [{
   *                target: "Type",
   *                value: "class ojComboboxMany<K, D, V= any> extends ojCombobox<Array<V>, ojComboboxManySettableProperties<K, D, V>, Array<V>, Array<string>>",
   *                genericParameters: [{"name": "K", "description": "Type of key of the dataprovider"}, {"name": "D", "description": "Type of data from the dataprovider"}
   *                ,{"name": "V", "description": "Type of each item in the value of the component"}]
   *               },
   *               {
   *                target: "Type",
   *                value: "ojComboboxManySettableProperties<K, D, V= any> extends ojComboboxSettableProperties<Array<V>>",
   *                for: "SettableProperties"
   *               }
   *              ]
   *
   *
   * @ojpropertylayout {propertyGroup: "common", items: ["labelHint", "placeholder", "required", "disabled"]}
   * @ojpropertylayout {propertyGroup: "data", items: ["value", "options"]}
   * @ojvbdefaultcolumns 6
   * @ojvbmincolumns 2
   *
   * @classdesc
   * <h3 id="comboboxManyOverview-section">
   *   JET Combobox Many
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#comboboxManyOverview-section"></a>
   * </h3>
   * <p>Description: JET Combobox Many provides support for multi-select, text input, and search filtering.</p>
   *
   * <p>A JET Combobox Many can be created with the following markup.</p>
   *
   * <pre class="prettyprint">
   * <code>
   * &lt;oj-combobox-many>
   *   &lt;oj-option value="option 1">option 1&lt;/oj-option>
   *   &lt;oj-option value="option 2">option 2&lt;/oj-option>
   *   &lt;oj-option value="option 3">option 3&lt;/oj-option>
   *   &lt;oj-option value="option 4">option 4&lt;/oj-option>
   * &lt;/oj-combobox-many>
   * </code></pre>
   *
   * {@ojinclude "name":"validationAndMessagingDoc"}
   *
   * <h3 id="touch-section">
   *   Touch End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"touchDocMany"}
   *
   * <h3 id="keyboard-section">
   *   Keyboard End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"keyboardDocMany"}
   *
   * <h3 id="perf-section">
   *   Performance
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#perf-section"></a>
   * </h3>
   *
   * <h4>Page Load</h4>
   * <p>If the <a href="#options">options</a> attribute is a data provider, and if there are initially selected values, setting the <a href="#valueOptions">valueOptions</a> attribute initially can improve page load performance because the element will not have to fetch the selected labels from the data provider.</p>
   * <p>When using a data provider, the dropdown data isn't fetched until the user opens the dropdown.</p>
   *
   *
   * {@ojinclude "name":"comboboxCommon"}
   */
// --------------------------------------------------- oj.ojCombobox-many Styling Start ------------------------------------------------------------

/**
   * @classdesc The following CSS classes can be applied by the page author as needed.<br/>
   * The form control style classes can be applied to the component, or an ancestor element. <br/>
   * When applied to an ancestor element, all form components that support the style classes will be affected.
   */
// ---------------- oj-form-control-full-width --------------

/**
  * Changes the max-width to 100% so that form components will occupy all the available horizontal space.
  * @ojstyleclass oj-form-control-full-width
  * @ojdisplayname Full Width
  * @memberof oj.ojComboboxMany
  * @ojtsexample
  * &lt;oj-combobox-many class="oj-form-control-full-width">
  *   &lt;oj-option value="option 1">option 1&lt;/oj-option>
  *   &lt;oj-option value="option 2">option 2&lt;/oj-option>
  *   &lt;oj-option value="option 3">option 3&lt;/oj-option>
  *   &lt;oj-option value="option 4">option 4&lt;/oj-option>
  * &lt;/oj-combobox-many>
  */
// ---------------- oj-form-control max-width --------------

/**
* In the Redwood theme the default max width of a text field is 100%.
* These max width convenience classes are available to create a medium or small field.<br>
* The class is applied to the root element.
* @ojstyleset form-control-max-width
* @ojdisplayname Max Width
* @ojstylesetitems ["form-control-max-width.oj-form-control-max-width-sm", "form-control-max-width.oj-form-control-max-width-md"]
* @ojstylerelation exclusive
* @memberof oj.ojComboboxMany
* @ojtsexample
* &lt;oj-combobox-many class="oj-form-control-max-width-md">
*   &lt;oj-option value="option 1">option 1&lt;/oj-option>
*   &lt;oj-option value="option 2">option 2&lt;/oj-option>
*   &lt;oj-option value="option 3">option 3&lt;/oj-option>
* &lt;/oj-combobox-many>
*/

/**
* @ojstyleclass form-control-max-width.oj-form-control-max-width-sm
* @ojshortdesc Sets the max width for a small field
* @ojdisplayname Small
* @memberof! oj.ojComboboxMany
 */

/**
* @ojstyleclass form-control-max-width.oj-form-control-max-width-md
* @ojshortdesc Sets the max width for a medium field
* @ojdisplayname Medium
* @memberof! oj.ojComboboxMany
 */
// ---------------- oj-form-control width --------------

/**
* In the Redwood theme the default width of a text field is 100%.
* These width convenience classes are available to create a medium or small field.<br>
* The class is applied to the root element.
* @ojstyleset form-control-width
* @ojdisplayname Width
* @ojstylesetitems ["form-control-width.oj-form-control-width-sm", "form-control-width.oj-form-control-width-md"]
* @ojstylerelation exclusive
* @memberof oj.ojComboboxMany
* @ojtsexample
* &lt;oj-combobox-many class="oj-form-control-width-md">
*   &lt;oj-option value="option 1">option 1&lt;/oj-option>
*   &lt;oj-option value="option 2">option 2&lt;/oj-option>
*   &lt;oj-option value="option 3">option 3&lt;/oj-option>
* &lt;/oj-combobox-many>
*/

/**
* @ojstyleclass form-control-width.oj-form-control-width-sm
* @ojshortdesc Sets the width for a small field
* @ojdisplayname Small
* @memberof! oj.ojComboboxMany
 */

/**
* @ojstyleclass form-control-width.oj-form-control-width-md
* @ojshortdesc Sets the width for a medium field
* @ojdisplayname Medium
* @memberof! oj.ojComboboxMany
 */
// ---------------- oj-form-control-text-align- --------------

/**
 * Classes that help align text of the element.
 * @ojstyleset text-align
 * @ojdisplayname Text Alignment
 * @ojstylesetitems ["text-align.oj-form-control-text-align-right", "text-align.oj-form-control-text-align-start", "text-align.oj-form-control-text-align-end"]
 * @ojstylerelation exclusive
 * @memberof oj.ojComboboxMany
 * @ojtsexample
 * &lt;oj-combobox-many class="oj-form-control-text-align-right">
 *   &lt;oj-option value="option 1">option 1&lt;/oj-option>
 *   &lt;oj-option value="option 2">option 2&lt;/oj-option>
 *   &lt;oj-option value="option 3">option 3&lt;/oj-option>
 *   &lt;oj-option value="option 4">option 4&lt;/oj-option>
 * &lt;/oj-combobox-many>
 */

/**
 * @ojstyleclass text-align.oj-form-control-text-align-right
 * @ojshortdesc Aligns the text to the right regardless of the reading direction. This is normally used for right aligning numbers.
 * @ojdisplayname Align-Right
 * @memberof! oj.ojComboboxMany
 */

/**
 * @ojstyleclass text-align.oj-form-control-text-align-start
 * @ojshortdesc Aligns the text to the left in LTR and to the right in RTL.
 * @ojdisplayname Align-Start
 * @memberof! oj.ojComboboxMany
 */

/**
 * @ojstyleclass text-align.oj-form-control-text-align-end
 * @ojshortdesc Aligns the text to the right in LTR and to the left in RTL.
 * @ojdisplayname text-Align-End
 * @memberof! oj.ojComboboxMany
 */
// --------------------------------------------------- oj.ojCombobox-many Styling end ------------------------------------------------------------

/**
   * @ojcomponent oj.ojCombobox
   * @augments oj.editableValue
   * @ojimportmembers oj.ojDisplayOptions
   * @since 0.6.0
   * @abstract
   * @ojsignature [{
   *                target: "Type",
   *                value: "abstract class ojCombobox<V, SP extends ojComboboxSettableProperties<V, SV, RV>, SV=V, RV=V> extends editableValue<V, SP, SV, RV>"
   *               },
   *               {
   *                target: "Type",
   *                value: "ojComboboxSettableProperties<V, SV= V, RV= V> extends editableValueSettableProperties<V, SV, RV>",
   *                for: "SettableProperties"
   *               }
   *              ]
   *
   * @hideconstructor
   * @classdesc
   */

/**
   *
   * <h3 id="rtl-section">
   *   Reading direction
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
   * </h3>
   *
   * <p>As with any JET element, in the unusual case that the directionality (LTR or RTL) changes post-init, the Combobox must be <code class="prettyprint">refresh()</code>ed.</p>
   *
   *
   * <h3 id="a11y-section">
   *   Accessibility
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
   * </h3>
   * <p>
   * It is up to the application developer to associate an oj-label to the combobox element.
   * You should put an <code>id</code> on the combobox element, and then set
   * the <code>for</code> attribute on the oj-label to be the combobox element's id.
   * </p>
   * <p>
   * The element will decorate its associated label with required and help
   * information, if the <code>required</code> and <code>help</code> attributes are set.
   * </p>
   *
   * @ojfragment comboboxCommon
   * @memberof oj.ojCombobox
   */
oj.__registerWidget('oj.ojCombobox', $.oj.editableValue, {
  defaultElement: '<input>',
  widgetEventPrefix: 'oj',
  options: {
    /**
     * {@ojinclude "name":"comboboxCommonAsyncValidators"}
     *
     * @example <caption>Create an Object that duck-types the oj.AsyncValidator interface.
     * Bind the Object to the JET form component's async-validators attribute. The
     * validator's 'validate' method will be called when the user changes the input.</caption>
     *  self.asyncValidator1 = {
     *    // required validate method
     *    'validate': function(value) {
     *      return new Promise(function(resolve, reject) {
     *        var successful = someBackendMethod();
     *        if (successful) {
     *          resolve(true);
     *        } else {
     *          reject(new Error('The options are incorrect.'));
     *        }
     *      });
     *    },
     *    // optional hint attribute. hint shows up when user sets focus to input.
     *    'hint': new Promise(function (resolve, reject) {
     *      var backendHint = getSomeBackendHint();
     *      resolve(backendHint);
     *    });
     *  };
     *  -- HTML --
     *  &lt;oj-combobox-one async-validators="[[[asyncValidator1]]]">&lt;/oj-combobox-one>
     * @example <caption>Initialize the component with multiple AsyncValidator
     * duck-typed instances:</caption>
     * -- HTML --
     * &lt;oj-combobox-one
                async-validators="[[[asyncValidator1, asyncValidator2]]]">&lt;/oj-combobox-one>
     *
     * @example <caption>Get or set the <code class="prettyprint">asyncValidators</code>
     * property after initialization:</caption>
     * // getter
     * var validators = myComp.asyncValidators;
     *
     * // setter
     * var myValidators = [{
     * 'validate' : function(value) {
     *   return new Promise(function(resolve, reject) {
     *   // mock server-side delay
     *   setTimeout(function () {
     *     if (valuePassesValidation) {
     *       resolve(true);
     *     } else {
     *       reject(new Error('the options are incorrect'));
     *     }
     *   },10);
     *   });
     * }
     * }];
     * myComp.asyncValidators = myValidators;
     * @ojdeprecated {since: '8.0.0', description: 'Use the validators property instead for either regular Validators or AsyncValidators.'}
     * @name asyncValidators
     * @ojshortdesc Specifies a list of asynchronous validators used by the component when performing validation. Use async-validators when you need to perform some validation work on the server. See the Help documentation for more information.
     * @expose
     * @access public
     * @instance
     * @memberof oj.ojComboboxOne
     * @default []
     * @ojsignature  { target: "Type",
     *       value: "Array<oj.AsyncValidator<V>>",
     *       jsdocOverride: true}
     * @type {Array.<Object>}
     */

    /**
    * {@ojinclude "name":"comboboxCommonAsyncValidators"}
    *
    * @example <caption>Create an Object that duck-types the oj.AsyncValidator interface.
    * Bind the Object to the JET form component's async-validators attribute. The
    * validator's 'validate' method will be called when the user changes the input.</caption>
    *  self.asyncValidator1 = {
    *    // required validate method
    *    'validate': function(value) {
    *      return new Promise(function(resolve, reject) {
    *        var successful = someBackendMethod();
    *        if (successful) {
    *          resolve(true);
    *        } else {
    *          reject(new Error('The amount of purchase is too high. It is ' + value));
    *        }
    *      });
    *    },
    *    // optional hint attribute. hint shows up when user sets focus to input.
    *    'hint': new Promise(function (resolve, reject) {
    *      var formattedMaxPurchase = getSomeBackendFormattedMaxPurchase();
    *      resolve(maxPurchase + " is the maximum.");
    *    });
    *  };
    *  -- HTML --
    *  &lt;oj-combobox-many async-validators="[[[asyncValidator1]]]">&lt;/oj-combobox-many>
    * @example <caption>Initialize the component with multiple AsyncValidator
    * duck-typed instances:</caption>
    * -- HTML --
    * &lt;oj-combobox-many
              async-validators="[[[asyncValidator1, asyncValidator2]]]">&lt;/oj-combobox-many>
    *
    * @example <caption>Get or set the <code class="prettyprint">asyncValidators</code>
    * property after initialization:</caption>
    * // getter
    * var validators = myComp.asyncValidators;
    *
    * // setter
    * var myValidators = [{
    * 'validate' : function(value) {
    *   return new Promise(function(resolve, reject) {
    *   // mock server-side delay
    *   setTimeout(function () {
    *     if (value === "pass" || value === "another pass") {
    *       resolve(true);
    *     } else {
    *       reject(new Error("value isn't 'pass' or 'another pass'. It is " + value.));
    *     }
    *   },10);
    *   });
    * }
    * }];
    * myComp.asyncValidators = myValidators;
    * @ojdeprecated {since: '8.0.0', description: 'Use the validators property instead for either regular Validators or AsyncValidators.'}
    * @name asyncValidators
    * @ojshortdesc Specifies a list of asynchronous validators used by the component when performing validation. Use async-validators when you need to perform some validation work on the server. See the Help documentation for more information.
    * @expose
    * @access public
    * @instance
    * @memberof oj.ojComboboxMany
    * @default []
    * @ojsignature  { target: "Type",
    *       value: "Array<oj.AsyncValidator<Array<V>>>",
    *       jsdocOverride: true}
    * @type {Array.<Object>}
    */

    /**
    * List of asynchronous validators used by the component when performing validation.
    * Use <code class="prettyprint">async-validators</code> when you need to
    * perform some validation work on the server. Otherwise, use
    * <code class="prettyprint">validators</code>, which are synchronous.
    * <p>
    * Each item in the Array is an instance that duck types {@link oj.AsyncValidator}.
    * Implicit validators created by a component when certain attributes
    * are present (e.g. <code class="prettyprint">required</code> attribute) are separate from
    * validators specified through the <code class="prettyprint">async-validators</code>
    * attribute and the <code class="prettyprint">validators</code> attribute.
    * At runtime when the component runs validation, it
    * combines the implicit validators with the list specified through the
    * <code class="prettyprint">validators</code>
    * attribute and also the list specified through the
    * <code class="prettyprint">async-validators</code> attribute.
    * Error messages are shown as soon as each async validator returns;
    * we do not wait until all the async validators finish to show errors.
    * If the component's valid state changes for the worse, it is also updated
    * as each validator returns so valid will be invalidShown
    * as soon as the first validator has an Error.
    * </p>
    * <p> It is recommended that you show the
    * value you are validating in the error message because if the async operation takes a while,
    * the user could be typing in a new value when the error message comes back
    * and might be confused what value the error is for. However, if the user enters a new value
    * (like presses Enter or Tab), a new validation lifecycle will start
    * and validation errors for the previous value will not be shown to the user.
    * If you need to format the value for the error message,
    * you can use e.g. for number
    * <code class="prettyprint">new NumberConverter.IntlNumberConverter(converterOption)</code>
    * to get the converter instance,
    * then call <code class="prettyprint">converter.format(value)</code>.
    * </p>
    * <p>
    * Hints exposed by async-validators and validators are shown in the notewindow by default,
    * or as determined by the 'validatorHint' property set on the
    * <code class="prettyprint">display-options</code> attribute.
    * </p>
    * <p>Since async validators are run asynchronously, you should wait on the BusyContext before
    * you check valid property or the value property. Alternatively you can add a callback to
    * the validChanged or valueChanged events.
    * </p>
    * <p>
    * The steps performed always, running validation and clearing messages is the same as
    * for the <code class="prettyprint">validators</code> attribute.
    * </p>
    * <br/>
    * @expose
    * @access public
    * @instance
    * @memberof oj.ojCombobox
    * @default []
    * @ojfragment comboboxCommonAsyncValidators
    */
    asyncValidators: [],

    /**
    * {@ojinclude "name":"comboboxCommonConverter"}
    *
    * @example <caption>Initialize the Combobox with a number converter instance:</caption>
    * &lt;oj-combobox-one converter="[[salaryConverter]]">&lt;/oj-combobox-one><br/>
    * // Initialize converter instance using currency options
    * var options = {style: 'currency', 'currency': 'USD', maximumFractionDigits: 0};
    * var salaryConverter = new NumberConverter(options);
    * @example <caption>Initialize the Combobox with converter object literal:</caption>
    * &lt;oj-combobox-one converter='{"type": "number", "options": {"style": "decimal"}}'>&lt;/oj-combobox-one>
    * @example <caption>Get or set the <code class="prettyprint">converter</code>
    *  property after initialization:</caption>
    * // getter
    * var converter = myComp.converter;
    *
    * // setter
    * myComp.converter = myConverter;
    *
    * @name converter
    * @ojshortdesc An object that converts the value. See the Help documentation for more information.
    * @expose
    * @access public
    * @instance
    * @memberof oj.ojComboboxOne
    * @ojsignature [{
    *    target: "Type",
    *    value: "Promise<oj.Converter<V>>|oj.Converter<V>|
    *            null",
    *    jsdocOverride: true},
    * {
    *    target: "Type",
    *    value: "Promise<oj.Converter<V>>|oj.Converter<V>|
    *            oj.Validation.RegisteredConverter|
    *            null",
    *    consumedBy: 'tsdep'}]
    * @ojdeprecated {since: '8.0.0', target: 'memberType', value: ['oj.Validation.RegisteredConverter'],
    *                description:'Defining a converter with an object literal with converter type and its options
    *                  (aka JSON format) has been deprecated and does nothing. If needed, you can make the JSON format
    *                  work again by importing the deprecated module you need, like ojvalidation-base.'}
    * @type {Object|null}
    * @default null
    */

    /**
    * {@ojinclude "name":"comboboxCommonConverter"}
    *
    * @example <caption>Initialize the Combobox with a number converter instance:</caption>
    * &lt;oj-combobox-many converter="[[salaryConverter]]">&lt;/oj-combobox-many><br/>
    * // Initialize converter instance using currency options
    * var options = {style: 'currency', 'currency': 'USD', maximumFractionDigits: 0};
    * var salaryConverter = new NumberConverter(options);
    *
    * @example <caption>Initialize the Combobox with converter object literal:</caption>
    * &lt;oj-combobox-many converter='{"type": "number", "options": {"style": "decimal"}}'>&lt;/oj-combobox-many>
    * @example <caption>Get or set the <code class="prettyprint">converter</code>
    *  property after initialization:</caption>
    * // getter
    * var converter = myComp.converter;
    *
    * // setter
    * myComp.converter = myConverter;
    *
    * @name converter
    * @ojshortdesc An object that converts the value. See the Help documentation for more information.
    * @expose
    * @access public
    * @instance
    * @memberof oj.ojComboboxMany
    * @ojsignature [{
    *    target: "Type",
    *    value: "Promise<oj.Converter<V>>|oj.Converter<V>|
    *            null",
    *    jsdocOverride: true},
    * {
    *    target: "Type",
    *    value: "Promise<oj.Converter<V>>|oj.Converter<V>|
    *            oj.Validation.RegisteredConverter|
    *            null",
    *    consumedBy: 'tsdep'}]
    * @ojdeprecated {since: '8.0.0', target: 'memberType', value: ['oj.Validation.RegisteredConverter'],
    *                description:'Defining a converter with an object literal with converter type and its options
    *                  (aka JSON format) has been deprecated and does nothing. If needed, you can make the JSON format
    *                  work again by importing the deprecated module you need, like ojvalidation-base.'}
    * @type {Object|null}
    * @default null
    */

    /**
    * A converter instance or Promise to a converter instance
    * or one that duck types {@link oj.Converter}.
    * When <code class="prettyprint">converter</code> property changes due to programmatic
    * intervention, the element performs various tasks based on the current state it is in. </br>
    * <p>
    * The hint exposed by the converter is shown inline by default in the Redwood theme when
    * the field has focus.
    * In the Alta theme, converter hints are shown in a notewindow on focus,
    * or as determined by the
    * 'converterHint' property set on the <code class="prettyprint">display-options</code>
    * attribute.
    * In either theme, you can turn off showing converter hints by using the
    * 'converterHint' property set to 'none' on the <code class="prettyprint">display-options</code>
    * attribute.
    * </p>
    * <p>
    * In the Redwood theme, only one hint shows at a time, so the precedence rules are:
    * help.instruction shows; if no help.instruction then validator hints show;
    * if none, then help-hints.definition shows; if none, then converter hint shows.
    * help-hints.source always shows along with the other help or hint.
    * </p>
    * <h4>Steps Performed Always</h4>
    * <ul>
    * <li>Any cached converter instance is cleared and new converter created. The converter hint is
    * pushed to messaging. E.g., notewindow displays the new hint(s).
    * </li>
    * </ul>
    *
    * <h4>Running Validation</h4>
    * <ul>
    * <li>if element is valid when <code class="prettyprint">converter</code> property changes, the
    * display value is refreshed.</li>
    * <li>if element is invalid and is showing messages when
    * <code class="prettyprint">converter</code> property changes, then all messages generated by the
    * element are cleared and full validation run using its current display value.
    * <ul>
    *   <li>if there are validation errors, then <code class="prettyprint">value</code>
    *   property is not updated, and the errors are shown. The display value is not refreshed in this case. </li>
    *   <li>if no errors result from the validation, <code class="prettyprint">value</code>
    *   property is updated; page author can listen to the <code class="prettyprint">valueChanged</code>
    *   event on the <code class="prettyprint">value</code> property to clear custom errors. The
    *   display value is refreshed with the formatted value provided by converter.</li>
    * </ul>
    * </li>
    * <li>if element is invalid and has deferred messages when
    * <code class="prettyprint">converter</code> property changes, then the display value is
    * refreshed with the formatted value provided by converter.</li>
    * </ul>
    * </p>
    *
    * <h4>Clearing Messages</h4>
    * <ul>
    * <li>When element messages are cleared in the cases described above, messages created by
    * the element are cleared.</li>
    * <li><code class="prettyprint">messages-custom</code> property is not cleared. Page authors can
    * choose to clear it explicitly when setting the converter property.</li>
    * </ul>
    * </p>
    *
    * @ojshortdesc An object that converts the value. See the Help documentation for more information.
    * @expose
    * @access public
    * @instance
    * @memberof oj.ojCombobox
    * @ojfragment comboboxCommonConverter
    */
    converter: null,

    /**
    * Whether to filter the list with the current display value on opening the drop down. This can be used to support search use cases.
    * This only applies to the initial opening of the drop down. When the user starts typing, the dropdown filters as usual.
    *
    * @example <caption>Initialize the combobox with the <code class="prettyprint">filter-on-open</code> attribute specified:</caption>
    * &lt;oj-combobox-one filter-on-open="rawValue">&lt;/oj-combobox-one>
    *
    * @example <caption>Get or set the <code class="prettyprint">filter-on-open</code> property after initialization:</caption>
    * // getter
    * var filterOnOpenValue = myCombobox.filterOnOpen;
    *
    * // setter
    * myCombobox.filterOnOpen = "rawValue";
    *
    * @ojshortdesc Whether to filter the drop down list on open.
    * @expose
    * @instance
    * @memberof oj.ojComboboxOne
    * @type {string}
    * @since 4.2.0
    *
    * @ojvalue {string} "none"  Show all available options without filtering on open.
    * @ojvalue {string} "rawValue" Filter the drop down list on open with the rawValue (current display value).
    * @default "none"
    */
    filterOnOpen: 'none',

    /**
    * {@ojinclude "name":"comboboxCommonLabelledBy"}
    * @name labelledBy
    * @expose
    * @ojshortdesc The oj-label sets the labelledBy property
    * programmatically on the form component.
    * @type {string|null}
    * @default null
    * @since 7.0.0
    * @access public
    * @instance
    * @memberof oj.ojComboboxMany
    */

    /**
    * {@ojinclude "name":"comboboxCommonLabelledBy"}
    * @name labelledBy
    * @expose
    * @ojshortdesc The oj-label sets the labelledBy property
    * programmatically on the form component.
    * @type {string|null}
    * @default null
    * @since 7.0.0
    * @access public
    * @instance
    * @memberof oj.ojComboboxOne
    */

    /**
    * <p>
    * The oj-label sets the labelledBy property programmatically on the form component
    * to make it easy for the form component to find its oj-label component (a
    * document.getElementById call.)
    * </p>
    * <p>
    * The application developer should use the 'for'/'id api
    * to link the oj-label with the form component;
    * the 'for' on the oj-label to point to the 'id' on the input form component.
    * This is the most performant way for the oj-label to find its form component.
    * </p>
    *
    * // setter
    * myComp.labelledBy = "labelId";
    *
    * @expose
    * @ojshortdesc The oj-label sets the labelledBy property
    * programmatically on the form component.
    * @type {string|null}
    * @default null
    * @since 7.0.0
    * @access public
    * @instance
    * @memberof oj.ojCombobox
    * @ojfragment comboboxCommonLabelledBy
    */
    labelledBy: null,

    /**
    * The placeholder text to set on the element. The placeholder specifies a short hint that can be displayed before user
    * selects or enters a value.
    *
    * @example <caption>Initialize the combobox with the <code class="prettyprint">placeholder</code> attribute specified:</caption>
    * &lt;oj-combobox-one placeholder="Please select ...">&lt;/oj-combobox-one>
    *
    * @example <caption>Get or set the <code class="prettyprint">placeholder</code> property after initialization:</caption>
    * // getter
    * var placeholderValue = myCombobox.placeholder;
    *
    * // setter
    * myCombobox.placeholder = "Select a value";
    *
    * @name placeholder
    * @ojshortdesc A short hint that can be displayed before user selects or enters a value.
    * @expose
    * @access public
    * @instance
    * @memberof oj.ojComboboxOne
    * @type {string|null}
    * @default null
    * @ojtranslatable
    */

    /**
    * The placeholder text to set on the element. The placeholder specifies a short hint that can be displayed before user
    * selects or enters a value.
    *
    * @example <caption>Initialize the combobox with the <code class="prettyprint">placeholder</code> attribute specified:</caption>
    * &lt;oj-combobox-many placeholder="Please select ...">&lt;/oj-combobox-many>
    *
    * @example <caption>Get or set the <code class="prettyprint">placeholder</code> property after initialization:</caption>
    * // getter
    * var placeholderValue = myCombobox.placeholder;
    *
    * // setter
    * myCombobox.placeholder = "Select values";
    *
    * @name placeholder
    * @ojshortdesc A short hint that can be displayed before user selects or enters a value.
    * @expose
    * @access public
    * @instance
    * @memberof oj.ojComboboxMany
    * @type {string|null}
    * @default null
    * @ojtranslatable
    */
    placeholder: null,

    /**
    * @typedef {Object} oj.ojCombobox.Option
    * @property {boolean=} disabled Option item is disabled.
    * @property {string=} label The display label for the option item. If it's missing, string(value) will be used.
    * @property {any} value The value of the option item.
    */

    /**
    * @typedef {Object} oj.ojCombobox.Optgroup
    * @property {boolean=} disabled Option group is disabled.
    * @property {string} label The display label for the option group.
    * @property {Array.<Object>} children The Option or Optgroup children.
    * @ojsignature { target: "Type", value: "Array.<oj.ojCombobox.Option|oj.ojCombobox.Optgroup>", for: "children", jsdocOverride: true}
    */

    /**
    * {@ojinclude "name":"comboboxCommonOptions"}
    * @name options
    * @ojshortdesc The option items for the Combobox.
    * @expose
    * @access public
    * @instance
    * @type {Array.<Object>|Object|null}
    * @ojsignature { target: "Type",
    *                value: "Array<oj.ojCombobox.Option|oj.ojCombobox.Optgroup>|oj.DataProvider<K, D>|null",
    *                jsdocOverride: true}
    * @default null
    * @memberof oj.ojComboboxOne
    *
    * @example <caption>Initialize the Combobox with the <code class="prettyprint">options</code> specified:</caption>
    * &lt;oj-combobox-one options="[[dataArray]]">&lt;/oj-combobox-one>
    *
    * @example <caption>The options array should contain objects with value and label properties:</caption>
    * var dataArray = [{value: 'option1', label: 'Option 1'},
    *                  {value: 'option2', label: 'Option 2', disabled: true},
    *                  {value: 'option3', label: 'Option 3'}];
    *
    * @example <caption>Initialize the Combobox with a data provider and data mapping:</caption>
    * &lt;oj-combobox-one options="[[dataProvider]]">&lt;/oj-combobox-one>
    *
    * @example <caption>Data mapping can be used if data doesn't have value and label properties.</caption>
    * // actual field names are "id" and "name"
    * var dataArray = [
    *            {id: 'Id 1', name: 'Name 1'},
    *            {id: 'Id 2', name: 'Name 2'},
    *            {id: 'Id 3', name: 'Name 3'}];
    *
    * // In mapfields, map "name" to "label" and "id" to "value"
    * var mapFields = function(item) {
    *   var data = item['data'];
    *   var mappedItem = {};
    *   mappedItem['data'] = {};
    *   mappedItem['data']['label'] = data['name'];
    *   mappedItem['data']['value'] = data['id'];
    *   mappedItem['metadata'] = {'key': data['id']};
    *   return mappedItem;
    * };
    * var dataMapping = {'mapFields': mapFields};
    *
    * var arrayDataProvider = new oj.ArrayDataProvider(dataArray, {keyAttributes: 'id'});
    * var dataProvider = new oj.ListDataProviderView(arrayDataProvider, {'dataMapping': dataMapping});
    */

    /**
    * {@ojinclude "name":"comboboxCommonOptions"}
    * @name options
    * @ojshortdesc The option items for the Combobox.
    * @expose
    * @access public
    * @instance
    * @type {Array.<Object>|Object|null}
    *
    * @ojsignature { target: "Type",
    *                value: "Array<oj.ojCombobox.Option|oj.ojCombobox.Optgroup>|oj.DataProvider<K, D>|null",
    *                jsdocOverride: true}
    * @default null
    * @memberof oj.ojComboboxMany
    *
    * @example <caption>Initialize the Combobox with the <code class="prettyprint">options</code> specified:</caption>
    * &lt;oj-combobox-many options="[[dataArray]]">&lt;/oj-combobox-many>
    *
    * @example <caption>The options array should contain objects with value and label properties:</caption>
    * var dataArray = [{value: 'option1', label: 'Option 1'},
    *                  {value: 'option2', label: 'Option 2', disabled: true},
    *                  {value: 'option3', label: 'Option 3'}];
    *
    * @example <caption>Initialize the Combobox with a data provider and data mapping:</caption>
    * &lt;oj-combobox-many options="[[dataProvider]]">&lt;/oj-combobox-many>
    *
    * @example <caption>Data mapping can be used if data doesn't have value and label properties.</caption>
    * // actual field names are "id" and "name"
    * var dataArray = [
    *            {id: 'Id 1', name: 'Name 1'},
    *            {id: 'Id 2', name: 'Name 2'},
    *            {id: 'Id 3', name: 'Name 3'}];
    *
    * // In mapfields, map "name" to "label" and "id" to "value"
    * var mapFields = function(item) {
    *   var data = item['data'];
    *   var mappedItem = {};
    *   mappedItem['data'] = {};
    *   mappedItem['data']['label'] = data['name'];
    *   mappedItem['data']['value'] = data['id'];
    *   mappedItem['metadata'] = {'key': data['id']};
    *   return mappedItem;
    * };
    * var dataMapping = {'mapFields': mapFields};
    *
    * var arrayDataProvider = new oj.ArrayDataProvider(dataArray, {keyAttributes: 'id'});
    * var dataProvider = new oj.ListDataProviderView(arrayDataProvider, {'dataMapping': dataMapping});
    */

    /**
    * The option items for the Combobox. This attribute can be used instead of providing a list of <code class="prettyprint">oj-option</code> or <code class="prettyprint">oj-optgroup</code> child elements of the Combobox element.
    * This attribute accepts:
    * <ol>
    * <li>an array of <code class="prettyprint">oj.ojCombobox.Option</code> and/or <code class="prettyprint">oj.ojCombobox.Optgroup</code>.
    *   <ul>
    *   <li>Use <code class="prettyprint">oj.ojCombobox.Option</code> for a leaf option.</li>
    *   <li>Use <code class="prettyprint">oj.ojCombobox.Optgroup</code> for a group option.</li>
    *   </ul>
    * </li>
    * <li>a data provider. This data provider must implement <a href="oj.DataProvider.html">oj.DataProvider</a>.
    *   <ul>
    *   <li><code class="prettyprint">value</code> in <code class="prettyprint">oj.ojCombobox.Option</code> must be the row key in the data provider.</li>
    *   <li>A maximum of 15 rows will be displayed in the dropdown. If more than 15 results are available then users need to filter further.</li>
    *   <li>If the data provider supports the filter criteria capability including the contains (<code class="prettyprint">$co or $regex</code>) operator, JET Combobox will request the data provider to do filtering. Otherwise it will filter internally.</li>
    *   <li>See also <a href="#perf-section">Improve page load performance</a></li>
    *   </ul>
    * </li>
    * </ol>
    *
    * @expose
    * @memberof oj.ojCombobox
    * @instance
    * @ojfragment comboboxCommonOptions
    */
    options: null,

    /**
    * @typedef {Object} oj.ojCombobox.OptionsKeys
    * @property {?string=} label The key name for the label.
    * @property {?string=} value The key name for the value.
    * @property {?string=} children The key name for the children.
    * @property {?Object=} childKeys The object for the child keys.
    * @ojsignature {target:"Type", for:"childKeys", value:"oj.ojCombobox.OptionsKeys", jsdocOverride:true}
    */

    /**
    * {@ojinclude "name":"comboboxCommonOptionsKeys"}
    *
    * @example <caption>Initialize the Combobox with <code class="prettyprint">options-keys</code> specified. This allows the key names to be redefined in the options array.</caption>
    * &lt;oj-combobox-one options-keys="[[optionsKeys]]">&lt;/oj-combobox-one>
    * @example var optionsKeys = {value : "state_abbr", label : "state_name"};
    * @example <caption>Redefine keys for data with subgroups.</caption>
    * var optionsKeys = {label : "regions", children : "states",
    *                    childKeys : {value : "state_abbr", label : "state_name"}};
    * @name optionsKeys
    * @ojshortdesc Specify the key names to use in the options array.  Depending on options-keys means that the signature of the data does not match what is supported by the options attribute.
    * @expose
    * @access public
    * @instance
    * @type {?Object}
    * @default null
    * @memberof oj.ojComboboxOne
    * @ojsignature {target:"Type", value:"oj.ojCombobox.OptionsKeys|null", jsdocOverride:true}
    */

    /**
    * {@ojinclude "name":"comboboxCommonOptionsKeys"}
    *
    * @example <caption>Initialize the Combobox with <code class="prettyprint">options-keys</code> specified. This allows the key names to be redefined in the options array.</caption>
    * &lt;oj-combobox-many options-keys="[[optionsKeys]]">&lt;/oj-combobox-many>
    * @example var optionsKeys = {value : "state_abbr", label : "state_name"};
    * @example <caption>Redefine keys for data with subgroups.</caption>
    * var optionsKeys = {label : "regions", children : "states",
    *                    childKeys : {value : "state_abbr", label : "state_name"}};
    * @name optionsKeys
    * @ojshortdesc Specify the key names to use in the options array.  Depending on options-keys means that the signature of the data does not match what is supported by the options attribute.
    * @expose
    * @access public
    * @instance
    * @type {?Object}
    * @default null
    * @memberof oj.ojComboboxMany
    * @ojsignature {target:"Type", value:"oj.ojCombobox.OptionsKeys|null", jsdocOverride:true}
    */

    /**
    * Specify the key names to use in the options array.
    * <p>Depending on options-keys means that the signature of the data does not match what is supported by the options attribute. When using Typescript, this would result in a compilation error.</p>
    * <p>Best practice is to use a <a href="oj.ListDataProviderView.html">oj.ListDataProviderView</a> with data mapping as a replacement.</p>
    * <p>However, for the app that must fetch data from a REST endpoint where the data fields do not match those that are supported by the options attribute, you may use the options-keys with any dataProvider that implements <a href="oj.DataProvider.html">oj.DataProvider</a> interface.</p>
    * <p>Note: <code class="prettyprint">child-keys</code> and <code class="prettyprint">children</code> properties in <code class="prettyprint">options-keys</code> are ignored when using a <a href="oj.TreeDataProvider.html">oj.TreeDataProvider</a>.</p>
    *
    * @expose
    * @access public
    * @instance
    * @memberof oj.ojCombobox
    * @ojfragment comboboxCommonOptionsKeys
    */
    optionsKeys: {
      /**
       * The key name for the label.
       *
       * @name optionsKeys.label
       * @expose
       * @public
       * @instance
       * @memberof! oj.ojComboboxOne
       * @type {?string}
       * @ojsignature { target: "Type",
       *                value: "?"}
       * @default null
       */

      /**
      * The key name for the label.
      *
      * @name optionsKeys.label
      * @expose
      * @public
      * @instance
      * @memberof! oj.ojComboboxMany
      * @type {?string}
      * @ojsignature { target: "Type",
      *                value: "?"}
      * @default null
      */

      /**
      * The key name for the value.
      *
      * @name optionsKeys.value
      * @expose
      * @public
      * @instance
      * @memberof! oj.ojComboboxOne
      * @type {?string}
      * @ojsignature { target: "Type",
      *                value: "?"}
      * @default null
      */

      /**
      * The key name for the value.
      *
      * @name optionsKeys.value
      * @expose
      * @public
      * @instance
      * @memberof! oj.ojComboboxMany
      * @type {?string}
      * @ojsignature { target: "Type",
      *                value: "?"}
      * @default null
      */

      /**
      * The key name for the children. It is ignored when using a <a href="oj.TreeDataProvider.html">oj.TreeDataProvider</a>.
      *
      * @name optionsKeys.children
      * @ojshortdesc The key name for the children. It is ignored when using a TreeDataProvider.
      * @expose
      * @public
      * @instance
      * @memberof! oj.ojComboboxOne
      * @type {?string}
      * @ojsignature { target: "Type",
      *                value: "?"}
      * @default null
      */

      /**
      * The key name for the children. It is ignored when using a <a href="oj.TreeDataProvider.html">oj.TreeDataProvider</a>.
      *
      * @name optionsKeys.children
      * @ojshortdesc The key name for the children. It is ignored when using a TreeDataProvider.
      * @expose
      * @public
      * @instance
      * @memberof! oj.ojComboboxMany
      * @type {?string}
      * @ojsignature { target: "Type",
      *                value: "?"}
      * @default null
      */

      /**
      * The object for the child keys. It is ignored when using a <a href="oj.TreeDataProvider.html">oj.TreeDataProvider</a>.
      *
      * @name optionsKeys.childKeys
      * @ojshortdesc The object for the child keys. It is ignored when using a TreeDataProvider.
      * @expose
      * @public
      * @instance
      * @memberof! oj.ojComboboxOne
      * @type {?Object}
      * @ojsignature {target:"Type", value:"oj.ojCombobox.OptionsKeys", jsdocOverride:true}
      * @default null
      * @property {?string=} label The key name for the label.
      * @property {?string=} value The key name for the value.
      * @property {?string=} children The key name for the children.
      * @property {?Object=} childKeys The object for the child keys.
      * @ojsignature {target:"Type", for:"childKeys", value:"oj.ojCombobox.OptionsKeys|null", jsdocOverride:true}
      */

      /**
       * The object for the child keys. It is ignored when using a <a href="oj.TreeDataProvider.html">oj.TreeDataProvider</a>.
       *
       * @name optionsKeys.childKeys
       * @ojshortdesc The object for the child keys. It is ignored when using a TreeDataProvider.
       * @expose
       * @public
       * @instance
       * @memberof! oj.ojComboboxMany
       * @type {?Object}
       * @ojsignature {target:"Type", value:"oj.ojCombobox.OptionsKeys", jsdocOverride:true}
       * @default null
       * @property {?string=} label The key name for the label.
       * @property {?string=} value The key name for the value.
       * @property {?string=} children The key name for the children.
       * @property {?Object=} childKeys The object for the child keys.
       * @ojsignature {target:"Type", for:"childKeys", value:"oj.ojCombobox.OptionsKeys|null", jsdocOverride:true}
       */
    },

    /**
    * <p>Attributes specified here will be set on the picker DOM element when it's launched.
    * <p>The supported attribute is <code class="prettyprint">class</code>, which is appended to the picker's class, if any.
    * Note: 1) picker-attributes is not applied in the native theme.
    * 2) setting this attribute after element creation has no effect.
    *
    * @property {string=} style The css style to append to the picker.
    * @property {string=} class The css class to append to the picker.
    *
    * @example <caption>Initialize the combobox specifying the class attribute to be set on the picker DOM element:</caption>
    * &lt;oj-combobox-one picker-attributes="[[pickerAttributes]]">&lt;/oj-combobox-one>
    * @example var pickerAttributes = {
    *   "style": "color:blue;",
    *   "class": "my-class"
    * };
    *
    * @name pickerAttributes
    * @ojshortdesc The style attributes for the drop down.
    * @expose
    * @memberof oj.ojComboboxOne
    * @ojdeprecated {target: "property", for: "style", since: "7.0.0", description: "Style property of pickerAttribute is deprecated as it violates the recommended <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy'>Content Security Policy</a> for JET which disallows <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/style-src'>inline styles</a>. Use class property instead."}
    * @instance
    * @type {?Object}
    * @default null
    */

    /**
    * <p>Attributes specified here will be set on the picker DOM element when it's launched.
    * <p>The supported attribute is <code class="prettyprint">class</code>, which is appended to the picker's class, if any.
    * Note: 1) picker-attributes is not applied in the native theme.
    * 2) setting this attribute after element creation has no effect.
    *
    * @property {string=} style The css style to append to the picker.
    * @property {string=} class The css class to append to the picker.
    *
    * @example <caption>Initialize the combobox specifying the class attribute to be set on the picker DOM element:</caption>
    * &lt;oj-combobox-many picker-attributes="[[pickerAttributes]]">&lt;/oj-combobox-many>
    * @example var pickerAttributes = {
    *   "class": "my-class"
    * };
    *
    * @name pickerAttributes
    * @ojshortdesc The style attributes for the drop down.
    * @expose
    * @memberof oj.ojComboboxMany
    * @ojdeprecated {target: "property", for: "style", since: "7.0.0", description: "Style property of pickerAttribute is deprecated as it violates the recommended <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy'>Content Security Policy</a> for JET which disallows <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/style-src'>inline styles</a>. Use class property instead."}
    * @instance
    * @type {?Object}
    * @default null
    */
    pickerAttributes: null,

    /**
    * @typedef {Object} oj.ojCombobox.OptionContext
    * @property {Element} componentElement A reference to the combobox element.
    * @property {?Element} parent The parent of the data item. The parent is null for root node.
    * @property {number} index The index of the option, where 0 is the index of the first option. In the hierarchical case the index is relative to its parent.
    * @property {number } depth The depth of the option. The depth of the first level children under the invisible root is 0.
    * @property {boolean} leaf Whether the option is a leaf or a group.
    * @property {Object} data The data object for the option.
    * @property {Element} parentElement The option label element. The renderer can use this to directly append content.
    */

    /**
    * {@ojinclude "name":"comboboxCommonOptionRenderer"}
    * @name optionRenderer
    * @ojshortdesc The renderer function that renders the content of each option.
    * @expose
    * @memberof oj.ojComboboxOne
    * @instance
    * @type {null|function(Object):Object}
    * @ojsignature { target: "Type",
    *                value: "?((param0: oj.ojCombobox.OptionContext) => Element)|null",
    *                jsdocOverride: true}
    * @default null
    * @example <caption>Initialize the Combobox with a renderer:</caption>
    * &lt;oj-combobox-one option-renderer="[[optionRenderer]]">&lt;/oj-combobox-one>
    * @example var optionRenderer = function(context) {
    *            var ojOption = document.createElement('oj-option');
    *            // Set the textContent or append other child nodes
    *            ojOption.textContent = context.data['FIRST_NAME'] + ' ' + context.data['LAST_NAME'];
    *            return ojOption;
    *          };
    */

    /**
    * {@ojinclude "name":"comboboxCommonOptionRenderer"}
    * @name optionRenderer
    * @ojshortdesc The renderer function that renders the content of each option.
    * @expose
    * @memberof oj.ojComboboxMany
    * @instance
    * @type {null|function(Object):Object}
    * @ojsignature { target: "Type",
    *                value: "?((param0: oj.ojCombobox.OptionContext) => Element)|null",
    *                jsdocOverride: true}
    * @default null
    * @example <caption>Initialize the Combobox with a renderer:</caption>
    * &lt;oj-combobox-many option-renderer="[[optionRenderer]]">&lt;/oj-combobox-many>
    * @example var optionRenderer = function(context) {
    *            var ojOption = document.createElement('oj-option');
    *            // Set the textContent or append other child nodes
    *            ojOption.textContent = context.data['FIRST_NAME'] + ' ' + context.data['LAST_NAME'];
    *            return ojOption;
    *          };
    */

    /**
    * The renderer function that renders the content of each option.
    * The function should return an oj-option element (for leaf option) or an oj-optgroup element (for group option).
    * <p>It is not necessary to set the "value" attribute on the oj-option as it is available from the options data.</p>
    * <p><b>
    * Note: Prior to version 6.1.0, the function could also return one of the following:
    * <ul>
    *   <li>An Object with the following property:
    *     <ul><li>insert: HTMLElement - A DOM element representing the content of the option.</li></ul>
    *   </li>
    *   <li>undefined: If the developer chooses to manipulate the option content directly, the function should return undefined.</li>
    * </ul>
    * This is deprecated and support may be removed in the future.
    * </b></p>
    *
    * <p>The <code class="prettyprint">option-renderer</code> decides only
    * how the options' content has to be rendered in the drop down.
    * Once an option is selected from the drop down,
    * what value has to be displayed in the in input field is decided by the
    * label field in the data object. See <a href="#options">options</a>
    * and <a href="#optionsKeys">options-keys</a> for configuring option label and value.
    * </p>
    *
    * <p>The context parameter passed to the renderer contains the following keys:</p>
    * <table class="keyboard-table">
    *   <thead>
    *     <tr>
    *       <th>Key</th>
    *       <th>Description</th>
    *     </tr>
    *   </thead>
    *   <tbody>
    *     <tr>
    *       <td><kbd>componentElement</kbd></td>
    *       <td>A reference to the Combobox element.</td>
    *     </tr>
    *     <tr>
    *       <td><kbd>parent</kbd></td>
    *       <td>The parent of the data item. The parent is null for root node.</td>
    *     </tr>
    *     <tr>
    *       <td><kbd>index</kbd></td>
    *       <td>The index of the option, where 0 is the index of the first option. In the hierarchical case the index is relative to its parent.</td>
    *     </tr>
    *     <tr>
    *       <td><kbd>depth</kbd></td>
    *       <td>The depth of the option. The depth of the first level children under the invisible root is 0.</td>
    *     </tr>
    *     <tr>
    *       <td><kbd>leaf</kbd></td>
    *       <td>Whether the option is a leaf or a group.</td>
    *     </tr>
    *     <tr>
    *       <td><kbd>data</kbd></td>
    *       <td>The data object for the option.</td>
    *     </tr>
    *     <tr>
    *       <td><kbd>parentElement</kbd></td>
    *       <td>The option label element.  The renderer can use this to directly append content.</td>
    *     </tr>
    *   </tbody>
    * </table>
    *
    * @expose
    * @memberof oj.ojCombobox
    * @instance
    * @ojfragment comboboxCommonOptionRenderer
    */
    optionRenderer: null,

    /**
    * The minimum number of characters a user must type before a options
    * filtering is performed. Zero is useful for local data with just a few items,
    * but a higher value should be used when a single character search could match a few thousand items.
    *
    * @expose
    * @memberof oj.ojComboboxOne
    * @name minLength
    * @ojshortdesc The minimum number of characters a user must type before search filtering is performed.
    * @instance
    * @type {number}
    * @default 0
    * @ojmin 0
    *
    * @example <caption>Initialize the Combobox with the <code class="prettyprint">min-length</code> attribute specified:</caption>
    * &lt;oj-combobox-one min-length="2">&lt;/oj-combobox-one>
    *
    * @example <caption>Get or set the <code class="prettyprint">minLength</code> property after initialization:</caption>
    * // getter
    * var minLengthValue = myCombobox.minLength;
    *
    * // setter
    * myCombobox.minLength = 3;
    *
    */

    /**
    * The minimum number of characters a user must type before a options
    * filtering is performed. Zero is useful for local data with just a few items,
    * but a higher value should be used when a single character search could match a few thousand items.
    *
    * @expose
    * @memberof oj.ojComboboxMany
    * @name minLength
    * @ojshortdesc The minimum number of characters a user must type before search filtering is performed.
    * @instance
    * @type {number}
    * @default 0
    * @ojmin 0
    *
    * @example <caption>Initialize the Combobox with the <code class="prettyprint">min-length</code> attribute specified:</caption>
    * &lt;oj-combobox-many min-length="2">&lt;/oj-combobox-many>
    *
    * @example <caption>Get or set the <code class="prettyprint">minLength</code> property after initialization:</caption>
    * // getter
    * var minLengthValue = myCombobox.minLength;
    *
    * // setter
    * myCombobox.minLength = 3;
    *
    */
    minLength: 0,

    /**
    * {@ojinclude "name":"comboboxCommonMaximumResultCount"}
    *
    * @example <caption>Initialize the combobox with the <code class="prettyprint">maximum-result-count</code> attribute specified:</caption>
    * &lt;oj-combobox-one maximum-result-count="25">&lt;/oj-combobox-one>
    *
    * @example <caption>Get or set the <code class="prettyprint">maximumResultCount</code> property after initialization:</caption>
    * // getter
    * var maximumResultCount = myCombobox.maximumResultCount;
    *
    * // setter
    * myCombobox.maximumResultCount = 25;
    *
    * @name maximumResultCount
    * @ojshortdesc The maximum number of results displayed in the dropdown.
    * @expose
    * @memberof oj.ojComboboxOne
    * @since 8.0.0
    * @instance
    * @type {number}
    * @default 15
    */

    /**
    * {@ojinclude "name":"comboboxCommonMaximumResultCount"}
    *
    * @example <caption>Initialize the combobox with the <code class="prettyprint">maximum-result-count</code> attribute specified:</caption>
    * &lt;oj-combobox-many maximum-result-count="25">&lt;/oj-combobox-many>
    *
    * @example <caption>Get or set the <code class="prettyprint">maximumResultCount</code> property after initialization:</caption>
    * // getter
    * var maximumResultCount = myCombobox.maximumResultCount;
    *
    * // setter
    * myCombobox.maximumResultCount = 25;
    *
    * @name maximumResultCount
    * @ojshortdesc The maximum number of results displayed in the dropdown.
    * @expose
    * @memberof oj.ojComboboxMany
    * @since 8.0.0
    * @instance
    * @type {number}
    * @default 15
    */

    /**
    * <p>The maximum number of results that will be displayed in the dropdown when the options attribute is bound to a data provider.</p>
    *
    * <p>If more than the maximum number of results are available from data provider then user needs to filter further.
    * A value less than 1 indicates there is no maximum limit and all the results will be fetched and displayed in the dropdown.</p>
    *
    * <p>When the options attribute is bound to a hierarchical data source like a <a href="oj.TreeDataProvider.html">oj.TreeDataProvider</a>,
    * this attribute represents the maximum number of leaf results that will be displayed in the dropdown.</p>
    *
    * <p>Note: This attribute has no effect when the options attribute is bound to an array/observable array or
    * when the component renders an oj-option element or an oj-optgroup element as children.</p>
    *
    * @expose
    * @memberof oj.ojCombobox
    * @instance
    * @ojfragment comboboxCommonMaximumResultCount
    */
    maximumResultCount: 15,

    /**
    * {@ojinclude "name":"comboboxCommonRawValue"}
    *
    * <p>
    * The <code class="prettyprint">rawValue</code> updates on the 'input' javascript event,
    * so the <code class="prettyprint">rawValue</code> changes as the value of the input is changed.
    * Consider the above example of combobox. Now, if the user types in 'Edge' into the field,
    * the <code class="prettyprint">rawValue</code> will be 'E', then 'Ed', then 'Edg', and finally 'Edge'.
    * Then when the user blurs or presses Enter the <code class="prettyprint">value</code> property gets
    * converted and validated (if there is a converter or validators) and then gets updated if valid.
    * In this case, without any converter the <code class="prettyprint">value</code> will be updated to 'Edge'.
    * </p>
    * <p>
    * If the user types in 'CH' instead, the <code class="prettyprint">rawValue</code> will be 'C' and then 'CH'.
    * Now, when the user blurs or presses Enter and since the <code class="prettyprint">rawValue</code> now matches
    * one of the keys(values) of the current set of options the <code class="prettyprint">value</code> will be
    * updated to 'CH', while the <code class="prettyprint">rawValue</code> gets updated to 'Chrome' and the user now sees 'Chrome'
    * in the text field.
    * </p>
    * <p>
    * Note that a <code class="prettyprint">rawValueChanged</code> event will be triggered when setting
    * the <code class="prettyprint">value</code> to 'CH' and the event payload will contain the current
    * <code class="prettyprint">rawValue</code> as 'Chrome' and previous <code class="prettyprint">rawValue</code> as 'CH'.
    * </p>
    *
    * @name rawValue
    * @ojshortdesc The currently displayed text retrieved from the input field.
    * @expose
    * @access public
    * @instance
    * @memberof oj.ojComboboxOne
    * @type {?string}
    * @default null
    * @since 1.2.1
    * @readonly
    * @ojwriteback
    */

    /**
    * {@ojinclude "name":"comboboxCommonRawValue"}
    *
    * <p>
    * The <code class="prettyprint">rawValue</code> updates on the 'input' javascript event,
    * so the <code class="prettyprint">rawValue</code> changes as the value of the input is changed. The
    * <code class="prettyprint">rawValue</code> is always an array when exists and the last element of the
    * array represent the current text typed in the input text field.
    * Consider the above example combobox. Now, if the user types in 'Edge' into the field,
    * the <code class="prettyprint">rawValue</code> will be ['E'], then ['Ed'], then ['Edg'], and finally ['Edge'].
    * Then when the user blurs or presses Enter the <code class="prettyprint">value</code> property gets
    * converted and validated (if there is a converter or validators) and then gets updated if valid.
    * In this case, without any converter the <code class="prettyprint">value</code> will be updated to ['Edge'].
    * </p>
    * <p>
    * Then if the user continues to type in 'CH', the <code class="prettyprint">rawValue</code> will be ['Edge', 'C']
    * and then ['Edge', 'CH']. The rawValue will contains the labels of all the selected values along with the text
    * currently being typed in the text field. Now, when the user blurs or presses Enter and since the
    * text now matches one of the keys(values) of the current set of options the <code class="prettyprint">value</code> will be
    * updated to ['Edge', 'CH'], while the <code class="prettyprint">rawValue</code> gets updated to ['Edge', 'Chrome']
    * and the user now sees two pills 'Edge' and 'Chrome'.
    * </p>
    * <p>
    * Note that a <code class="prettyprint">rawValueChanged</code> event will be triggered when setting
    * the <code class="prettyprint">value</code> and the event payload will contain the current
    * <code class="prettyprint">rawValue</code> as ['Edge', 'Chrome'] and previous
    * <code class="prettyprint">rawValue</code> as ['Edge', 'CH'].
    * </p>
    *
    * @name rawValue
    * @ojshortdesc The currently displayed text retrieved from the input field.
    * @expose
    * @access public
    * @instance
    * @memberof oj.ojComboboxMany
    * @type {?Array<string>}
    * @default null
    * @since 1.2.1
    * @readonly
    * @ojwriteback
    */

    /**
    * <p>The  <code class="prettyprint">rawValue</code> is the read-only property for retrieving
    * the current value from the input field in string form. The main consumer of
    * <code class="prettyprint">rawValue</code> is a converter.</p>
    * <p>This is a read-only attribute so page authors cannot set or change it directly.</p>
    * <p>
    * Consider a combobox with the following options:
    * <pre>
    * <code>
    *   &lt;oj-option value="CH">Chrome&lt;/oj-option>
    *   &lt;oj-option value="FF">Firefox&lt;/oj-option>
    *   &lt;oj-option value="SA">Safari&lt;/oj-option>
    *   &lt;oj-option value="OP">Opera&lt;/oj-option>
    * </code>
    * </pre>
    * </p>
    *
    * @example <caption>Get the <code class="prettyprint">rawValue</code> property after initialization:</caption>
    * // getter
    * var rawValue = myCombobox.rawValue;
    *
    * @ojshortdesc The currently displayed text retrieved from the input field.
    * @expose
    * @access public
    * @instance
    * @memberof oj.ojCombobox
    * @ojfragment comboboxCommonRawValue
    */
    rawValue: null,

    /**
    * {@ojinclude "name":"comboboxCommonRequired"}
    *
    * @example <caption>Initialize the Combobox with the <code class="prettyprint">required</code> attribute:</caption>
    * &lt;oj-combobox-one required="[[isRequired]]">&lt;/oj-combobox-one>
    *
    * @example <caption>Get or set the <code class="prettyprint">required</code> property after initialization:</caption>
    * // getter
    * var requiredValue = myCombobox.required;
    *
    * // setter
    * myCombobox.required = true;
    *
    * @name required
    * @ojshortdesc Specifies whether a value is required.
    * @expose
    * @access public
    * @instance
    * @memberof oj.ojComboboxOne
    * @type {boolean}
    * @default false
    * @since 0.7.0
    * @see #translations
    */

    /**
    * {@ojinclude "name":"comboboxCommonRequired"}
    *
    * @example <caption>Initialize the Combobox with the <code class="prettyprint">required</code> attribute:</caption>
    * &lt;oj-combobox-many required="[[isRequired]]">&lt;/oj-combobox-many>
    *
    * @example <caption>Get or set the <code class="prettyprint">required</code> property after initialization:</caption>
    * // getter
    * var requiredValue = myCombobox.required;
    *
    * // setter
    * myCombobox.required = true;
    *
    * @name required
    * @ojshortdesc Specifies whether a value is required.
    * @expose
    * @access public
    * @instance
    * @memberof oj.ojComboboxMany
    * @type {boolean}
    * @default false
    * @since 0.7.0
    * @see #translations
    */

    /**
    * Whether the Combobox is required or optional. When required is set to true, an implicit
    * required validator is created using the RequiredValidator -
    * <code class="prettyprint">RequiredValidator()</code>.
    *
    * Translations specified using the <code class="prettyprint">translations.required</code> attribute
    * and the label associated with the Combobox, are passed through to the options parameter of the
    * createValidator method.
    *
    * <p>
    * When <code class="prettyprint">required</code> property changes due to programmatic intervention,
    * the Combobox may clear messages and run validation, based on the current state it's in. </br>
    *
    * <h4>Running Validation</h4>
    * <ul>
    * <li>if element is valid when required is set to true, then it runs deferred validation on
    * the value. This is to ensure errors are not flagged unnecessarily.
    * </li>
    * <li>if element is invalid and has deferred messages when required is set to false, then
    * element messages are cleared but no deferred validation is run.
    * </li>
    * <li>if element is invalid and currently showing invalid messages when required is set, then
    * element messages are cleared and normal validation is run using the current display value.
    * <ul>
    *   <li>if there are validation errors, then <code class="prettyprint">value</code>
    *   property is not updated and the error is shown.
    *   </li>
    *   <li>if no errors result from the validation, the <code class="prettyprint">value</code>
    *   property is updated; page author can listen to the <code class="prettyprint">valueChanged</code>
    *   event on the <code class="prettyprint">value</code> property to clear custom errors.</li>
    * </ul>
    * </li>
    * </ul>
    *
    * <h4>Clearing Messages</h4>
    * <ul>
    * <li>Only messages created by the element are cleared.</li>
    * <li><code class="prettyprint">messages-custom</code> attribute is not cleared.</li>
    * </ul>
    *
    * </p>
    * <p>
    * This property set to <code class="prettyprint">false</code> implies that a value is not required to be provided by the user.
    * This is the default.
    * This property set to <code class="prettyprint">true</code> implies that a value is required to be provided by the user.
    * </p>
    * <p>
    * Additionally a required validator -
    * {@link oj.RequiredValidator} - is implicitly used if no explicit required validator is set.
    * An explicit required validator can be set by page authors using the validators attribute.
    * </p>
    * <p>
    * In the Alta theme the input's label will render a required icon. In the Redwood theme, by default,
    * a Required text is rendered inline when the field is empty.  If user-assistance-density is 'compact', it will show on the label as an icon.
    * </p>
    *
    * @expose
    * @access public
    * @instance
    * @memberof oj.ojCombobox
    * @since 0.7.0
    * @see #translations
    * @ojfragment comboboxCommonRequired
    */
    required: false,

    /**
    * Dictates element's readonly state.
    * <p>
    * The default value for readonly is false. However, if the form component is a descendent of
    * <code class="prettyprint">oj-form-layout</code>, the default value for readonly could come from the
    * <code class="prettyprint">oj-form-layout</code> component's readonly attribute.
    * The <code class="prettyprint">oj-form-layout</code> uses the
    * <a href="MetadataTypes.html#PropertyBinding">MetadataTypes.PropertyBinding</a>
    * <code class="prettyprint">provide</code> property to provide its
    * <code class="prettyprint">readonly</code>
    * attribute value to be consumed by descendent components.
    * The form components are configured to consume the readonly property if an ancestor provides it and
    * it is not explicitly set.
    * For example, if the oj-form-layout's readonly attribute is set to true, and a descendent form component does
    * not have its readonly attribute set, the form component's readonly will be true.
    * </p>
    *
    * @example <caption>Initialize the combobox with the <code class="prettyprint">readonly</code> attribute:</caption>
    * &lt;oj-some-element readonly>&lt;/oj-some-element>
    *
    * @example <caption>Get or set the <code class="prettyprint">readonly</code> property after initialization:</caption>
    * // getter
    * var ro = myComp.readonly;
    *
    * // setter
    * myComp.readonly = false;
    *
    * @name readOnly
    * @alias readonly
    * @expose
    * @ojshortdesc Specifies whether the component is read-only. A read-only element cannot be modified, but user interaction is allowed. See the Help documentation for more information.
    * @access public
    * @instance
    * @memberof oj.ojComboboxOne
    * @type {boolean}
    * @default false
    */

    /**
    * Dictates element's readonly state.
    * <p>
    * The default value for readonly is false. However, if the form component is a descendent of
    * <code class="prettyprint">oj-form-layout</code>, the default value for readonly could come from the
    * <code class="prettyprint">oj-form-layout</code> component's readonly attribute.
    * The <code class="prettyprint">oj-form-layout</code> uses the
    * <a href="MetadataTypes.html#PropertyBinding">MetadataTypes.PropertyBinding</a>
    * <code class="prettyprint">provide</code> property to provide its
    * <code class="prettyprint">readonly</code>
    * attribute value to be consumed by descendent components.
    * The form components are configured to consume the readonly property if an ancestor provides it and
    * it is not explicitly set.
    * For example, if the oj-form-layout's readonly attribute is set to true, and a descendent form component does
    * not have its readonly attribute set, the form component's readonly will be true.
    * </p>
    * @example <caption>Initialize the combobox with the <code class="prettyprint">readonly</code> attribute:</caption>
    * &lt;oj-some-element readonly>&lt;/oj-some-element>
    *
    * @example <caption>Get or set the <code class="prettyprint">readonly</code> property after initialization:</caption>
    * // getter
    * var ro = myComp.readonly;
    *
    * // setter
    * myComp.readonly = false;
    *
    * @name readOnly
    * @alias readonly
    * @expose
    * @ojshortdesc Specifies whether the component is read-only. A read-only element cannot be modified, but user interaction is allowed. See the Help documentation for more information.
    * @access public
    * @instance
    * @memberof oj.ojComboboxMany
    * @type {boolean}
    * @default false
    */
    readOnly: false,

    /**
    * {@ojinclude "name":"comboboxCommonValidators"}
    *
    *
    * @example <caption>Initialize the Combobox with validator instance:</caption>
    * &lt;oj-combobox-one validators="[[validators]]">&lt;/oj-combobox-one>
    * @example var validators = [new RegExpValidator({
    *       pattern: '[a-zA-Z0-9]{3,}'
    *     })];
    *
    *
    * @example <caption>Initialize the Combobox with multiple validator instances:</caption>
    * var validator1 = new MyCustomValidator({'foo': 'A'});
    * var validator2 = new MyCustomValidator({'foo': 'B'});
    * var validators = [validator1, validator2];
    * &lt;oj-combobox-one validators="[[validators]]">&lt;/oj-combobox-one>
    *
    * @example <caption>Get or set the <code class="prettyprint">validators</code> property after initialization:</caption>
    * // get one
    * var validator = myCombobox.validators[0];
    *
    * // get all
    * var validators = myCombobox.validators;
    *
    * // set all
    * myCombobox.validators = myValidators;
    *
    * @name validators
    * @ojshortdesc Specifies a list of synchronous validators for performing validation by the element. See the Help documentation for more information.
    * @expose
    * @access public
    * @instance
    * @memberof oj.ojComboboxOne
    * @type {Array}
    * @default []
    * @ojsignature  [{ target: "Type",
    *   value: "Array<oj.Validator<V>|oj.AsyncValidator<V>>|null",
    *   jsdocOverride: true},
    * { target: "Type",
    *   value: "Array<oj.Validator<V>|oj.AsyncValidator<V>|
    *       oj.Validation.RegisteredValidator>|null",
    *   consumedBy: 'tsdep'}]
    * @ojdeprecated {since: '8.0.0', target: 'memberType', value: ['oj.Validation.RegisteredValidator'],
    *                description: 'Defining a validator with an object literal with validator type and
    *                  its options (aka JSON format) has been deprecated and does nothing. If needed, you can
    *                  make the JSON format work again by importing the deprecated ojvalidation module you need,
    *                  like ojvalidation-base.'}
    */

    /**
    * {@ojinclude "name":"comboboxCommonValidators"}
    *
    * @example <caption>Initialize the Combobox with validator instance:</caption>
    * &lt;oj-combobox-many validators="[[validators]]">&lt;/oj-combobox-many>
    * @example var validators = [new RegExpValidator({
    *       pattern: '[a-zA-Z0-9]{3,}'
    *     })];
    *
    *
    * @example <caption>Initialize the Combobox with multiple validator instances:</caption>
    * var validator1 = new MyCustomValidator({'foo': 'A'});
    * var validator2 = new MyCustomValidator({'foo': 'B'});
    * var validators = [validator1, validator2];
    * &lt;oj-combobox-many validators="[[validators]]">&lt;/oj-combobox-many>
    *
    * @example <caption>Get or set the <code class="prettyprint">validators</code> property after initialization:</caption>
    * // get one
    * var validator = myCombobox.validators[0];
    *
    * // get all
    * var validators = myCombobox.validators;
    *
    * // set all
    * myCombobox.validators = myValidators;
    *
    * @name validators
    * @ojshortdesc Specifies a list of synchronous validators for performing validation by the element. See the Help documentation for more information.
    * @expose
    * @access public
    * @instance
    * @memberof oj.ojComboboxMany
    * @type {Array}
    * @default []
    * @ojsignature  [{ target: "Type",
    *   value: "Array<oj.Validator<V>|oj.AsyncValidator<V>>|null",
    *   jsdocOverride: true},
    * { target: "Type",
    *   value: "Array<oj.Validator<V>|oj.AsyncValidator<V>|
    *       oj.Validation.RegisteredValidator>|null",
    *   consumedBy: 'tsdep'}]
    * @ojdeprecated {since: '8.0.0', target: 'memberType', value: ['oj.Validation.RegisteredValidator'],
    *                description: 'Defining a validator with an object literal with validator type and
    *                  its options (aka JSON format) has been deprecated and does nothing. If needed, you can
    *                  make the JSON format work again by importing the deprecated ojvalidation module you need,
    *                  like ojvalidation-base.'}
    */

    /**
    * List of validators, synchronous or asynchronous,
    * used by component along with asynchronous validators from the deprecated async-validators option
    * and the implicit component validators when performing validation. Each item is either an
    * instance that duck types {@link oj.Validator} or {@link oj.AsyncValidator}.
    * As of v8.0.0, defining a validator with an object literal
    * with validator type and its options
    * (aka json format) has been deprecated and does nothing.
    * If needed, you can make the json format work
    * again by importing the deprecated module you need, e.g., ojvalidation-base module.
    * <p>
    * Implicit validators are created by the element when certain attributes are present.
    * For example, if the <code class="prettyprint">required</code>
    * attribute is set, an implicit {@link oj.RequiredValidator} is created.
    * At runtime when the component runs validation, it
    * combines all the implicit validators with all the validators
    * specified through this <code class="prettyprint">validators</code> attribute
    * and the <code class="prettyprint">async-validators</code> attribute, and
    * runs all of them.
    * </p>
    * <p>
    * Hints exposed by validators are shown inline by default in the Redwood theme when the field
    * has focus.
    * In the Alta theme, validator hints are shown in a notewindow on focus,
    * or as determined by the
    * 'validatorHint' property set on the <code class="prettyprint">display-options</code>
    * attribute.
    * </p>
    * <p>
    * In the Redwood theme, only one hint shows at a time, so the precedence rules are:
    * help.instruction shows; if no help.instruction then validator hints show;
    * if none, then help-hints.definition shows; if none, then converter hint shows.
    * help-hints.source always shows along with the other help or hint.
    * </p>
    *
    * <p>
    * When <code class="prettyprint">validators</code> property changes due to programmatic
    * intervention, the element may decide to clear messages and run validation, based on the
    * current state it is in. </br>
    *
    * <h4>Steps Performed Always</h4>
    * <ul>
    * <li>The cached list of validator instances are cleared and new validator hints is pushed to
    * messaging. E.g., notewindow displays the new hint(s).
    * </li>
    * </ul>
    *
    * <h4>Running Validation</h4>
    * <ul>
    * <li>if element is valid when validators changes, element does nothing other than the
    * steps it always performs.</li>
    * <li>if element is invalid and is showing messages -
    * <code class="prettyprint">messages-shown</code> property is non-empty, when
    * <code class="prettyprint">validators</code> or
    * <code class="prettyprint">async-validators</code changes then all element messages
    * are cleared and full validation run using the display value on the element.
    * <ul>
    *   <li>if there are validation errors, then <code class="prettyprint">value</code>
    *   property is not updated and the error is shown.
    *   </li>
    *   <li>if no errors result from the validation, the <code class="prettyprint">value</code>
    *   property is updated; page author can listen to the <code class="prettyprint">valueChanged</code>
    *   event on the <code class="prettyprint">value</code> property to clear custom errors.</li>
    * </ul>
    * </li>
    * <li>if element is invalid and has deferred messages when validators changes, it does
    * nothing other than the steps it performs always.</li>
    * </ul>
    * </p>
    *
    * <h4>Clearing Messages</h4>
    * <ul>
    * <li>Only messages created by the element are cleared.</li>
    * <li><code class="prettyprint">messages-custom</code> property is not cleared.</li>
    * </ul>
    * </p>
    *
    * @expose
    * @access public
    * @instance
    * @memberof oj.ojCombobox
    * @ojfragment comboboxCommonValidators
    */
    validators: [],

    /**
    * The <code class="prettyprint">valueOption</code> is similar to the <code class="prettyprint">value</code>, but is an
    * Object which contains both a value and display label.
    * The <code class="prettyprint">value</code> and <code class="prettyprint">valueOption</code> are kept in sync.
    * If initially both are set, the selected value in the <code class="prettyprint">value</code> attribute has precedence.
    * <p>Note: When the <code class="prettyprint">options</code> attribute is bound to a data provider, the <code class="prettyprint">valueOptionChanged</code> event will include data and metadata information if it is available from data provider.</p>
    * <p>Setting the <code class="prettyprint">valueOption</code> attribute initially can improve page load performance if there are initially selected values.  But, the initial <code class="prettyprint">valueOptionChanged</code> event will not include data and metadata information, because the element doesn't have to fetch the selected label from the data provider.</p>
    * <p>If <code class="prettyprint">valueOption</code> is not specified or the selected value is missing, then the label will be fetched from the data provider.</p>
    *
    * @name valueOption
    * @ojshortdesc The current value of the element and its associated display label.
    * @expose
    * @instance
    * @type {null | Object}
    * @default null
    * @ojwriteback
    *
    * @property {any} value current value of multiple selected JET Combobox values
    * @property {string} [label] display label of value above. If missing, String(value) is used.
    * @memberof oj.ojComboboxOne
    * @ojsignature { target: "Type",
    *                value: "V|null", for: "value"}
    *
    * @example <caption>Initialize the Combobox with the <code class="prettyprint">value-option</code> attribute specified:</caption>
    * &lt;oj-combobox-one value-option="[[valueOption]]">&lt;/oj-combobox-one>
    *
    * @example <caption>Object with value and label properties:</caption>
    * var valueOption = {'value': 'val1', 'label': 'Label 1'};
    *
    * @example <caption>Get or set the <code class="prettyprint">valueOption</code> property after initialization:</caption>
    * // getter
    * var valueOption = myCombobox.valueOption;
    *
    * // setter
    * myCombobox.valueOption = valueOption;
    */
    valueOption: null,

    /**
    * The <code class="prettyprint">valueOptions</code> is similar to the <code class="prettyprint">value</code>, but is an array
    * of Objects and each Object contains both a value and display label.
    * The <code class="prettyprint">value</code> and <code class="prettyprint">valueOptions</code> are kept in sync.
    * If initially both are set, the selected values in the <code class="prettyprint">value</code> attribute has precedence.
    * <p>Note: When the <code class="prettyprint">options</code> attribute is bound to a data provider, the <code class="prettyprint">valueOptionsChanged</code> event will include data and metadata information if it is available from data provider.</p>
    * <p>Setting the <code class="prettyprint">valueOptions</code> attribute initially can improve page load performance if there are initially selected values.  But, the initial <code class="prettyprint">valueOptionsChanged</code> event will not include data and metadata information, because the element doesn't have to fetch the selected label from the data provider.</p>
    * <p>If <code class="prettyprint">valueOptions</code> is not specified or one of the selected values is missing, then the labels will be fetched from the data provider.</p>
    *
    * @name valueOptions
    * @ojshortdesc The current values of the element and their associated display labels.
    * @expose
    * @instance
    * @type {null | Array.<Object>}
    * @default null
    * @ojwriteback
    *
    * @property {any} value the current value of JET Combobox
    * @property {string} [label] display label of value above. If missing, String(value) is used.
    * @ojsignature { target: "Type",
    *                value: "Array<{value: V, label?: string}> | null",
    *                jsdocOverride: true}
    *
    * @memberof oj.ojComboboxMany
    *
    * @example <caption>Initialize the Combobox with the <code class="prettyprint">value-options</code> attribute specified:</caption>
    * &lt;oj-combobox-many value-options="[[optionsArray]]">&lt;/oj-combobox-many>
    *
    * @example <caption>Array of Objects with value and label properties:</caption>
    * var optionsArray = [{'value': 'val1', 'label': 'Label 1'},
    *                     {'value': 'val2', 'label': 'Label 2'}];
    *
    * @example <caption>Get or set the <code class="prettyprint">valueOptions</code> property after initialization:</caption>
    * // getter
    * var valueOptions = myCombobox.valueOptions;
    *
    * // setter
    * myCombobox.valueOptions = optionsArray;
    */
    valueOptions: null,

    /**
    * The value of the element. It supports any type.
    * <p>Note: When the <code class="prettyprint">options</code> attribute is bound to a data provider, the <code class="prettyprint">valueChanged</code> event will include data and metadata information if it is available from data provider.</p>
    *
    * @example <caption>Initialize the combobox with the <code class="prettyprint">value</code> attribute specified:</caption>
    * &lt;oj-combobox-one value="option1">&lt;/oj-combobox-one>
    *
    * @example <caption>Get or set the <code class="prettyprint">value</code> property after initialization:</caption>
    * // getter
    * var value = myCombobox.value;
    *
    * // setter
    * myCombobox.value = "option1";
    *
    * @member
    * @name value
    * @ojshortdesc The value of the element.
    * @access public
    * @instance
    * @ojeventgroup common
    * @memberof oj.ojComboboxOne
    * @type {any}
    * @ojsignature { target: "Type",
    *                value: "V|null"}
    * @default null
    * @ojwriteback
    */

    /**
    * The value of the element. The value is an array with any type of items.
    * <p>Note: When the <code class="prettyprint">options</code> attribute is bound to a data provider, the <code class="prettyprint">valueChanged</code> event will include data and metadata information if it is available from data provider.</p>
    *
    * @example <caption>Initialize the combobox with the <code class="prettyprint">value</code> attribute specified:</caption>
    * &lt;oj-combobox-many value="{{val}}">&lt;/oj-combobox-many>
    * @example var val = ['option1', 'option2'];
    *
    * @example <caption>Get or set the <code class="prettyprint">value</code> property after initialization:</caption>
    * // getter
    * var value = myCombobox.value;
    *
    * // setter
    * myCombobox.value = ["option1", "option2"];
    *
    * @member
    * @name value
    * @ojshortdesc The value of the element.
    * @access public
    * @instance
    * @ojeventgroup common
    * @memberof oj.ojComboboxMany
    * @type {Array.<any>|null}
    * @ojsignature { target: "Type",
    *                value: "Array<V>|null"}
    * @default null
    * @ojwriteback
    */

    /**
    * Triggered when the value is submitted by the user through pressing the enter key or selecting from the drop down list.
    * This is to support search use cases.
    * The event will be fired even if the value is the same. This will help the application to re-submit the search query for the same value.
    * The event is not triggered if the submitted value fails validation. The event is not triggered on blur or tab out.
    *
    * @example <caption>Define an event listener.</caption>
    * var listener = function( event )
    * {
    *   // Get the search term
    *   var term = event['detail']['value'];
    *
    *   // search with the term
    * };
    * @ojshortdesc Event handler for when the value is submitted by the user.
    * @expose
    * @event
    * @memberof oj.ojComboboxOne
    * @since 4.2.0
    *
    * @instance
    * @property {any} value the current value
    * @property {any} previousValue the previous value
    */
    valueUpdated: null
  },

  /**
     * Returns a jQuery object containing the element visually representing the combobox.
     *
     * <p>This method does not accept any arguments.
     *
     * @memberof! oj.ojCombobox
     * @instance
     * @public
     * @ignore
     * @return {jQuery} the combobox
     */
  widget: function widget() {
    return this.combobox.container;
  },

  /**
     * @memberof! oj.ojCombobox
     * @instance
     * @protected
     * @override
     */
  _ComponentCreate: function _ComponentCreate() {
    this._super();

    _ComboUtils.wrapDataProviderIfNeeded(this, null);

    this._setup();
  },

  /**
     * @memberof! oj.ojCombobox
     * @instance
     * @protected
     * @override
     */
  _AfterCreate: function _AfterCreate() {
    this._super();

    if (this._IsCustomElement()) {
      this._initInputIdLabelForConnection(this._GetContentElement()[0], this.OuterWrapper.id, this.options.labelledBy); // need to apply the oj-focus marker selector for control of the floating label.


      var rootElement = this._getRootElement();

      this._focusable({
        element: rootElement,
        applyHighlight: false,
        afterToggle: this._handleAfterFocusToggle.bind(this, rootElement)
      }); // If labelEdge is set to none, aria-label would have been set to the innerElem
      // so, we need to update the aria-label elsewhere


      if (this.combobox && this.options.labelEdge === 'none') {
        this.combobox.updateAriaLabelIfNeeded();
      }
    }
  },

  /**
    * If the dropdown is open and the afterToggle handler is called with focusout,
    * turn on the 'oj-focus' selector. This is needed for floating labels.  If focus
    * moves to the droplist, the label should be in the up position versus floating
    * down over the input on selection of a dropdown item.
    * @private
    * @instance
    * @memberof! oj.ojCombobox
    */
  _handleAfterFocusToggle: function _handleAfterFocusToggle(element, eventType) {
    if (eventType === 'focusout') {
      var dropdown = this._getDropdown();

      if (dropdown) {
        element.classList.add('oj-focus');
      }
    }
  },

  /**
     * @memberof! oj.ojCombobox
     * @instance
     * @protected
     * @override
     */
  _InitOptions: function _InitOptions(originalDefaults, constructorOptions) {
    var props = [{
      attribute: 'disabled',
      validateOption: true
    }, {
      attribute: 'placeholder'
    }, {
      attribute: 'required',
      coerceDomValue: true,
      validateOption: true
    }, {
      attribute: 'title'
    } // {attribute: "value"}
    ];

    this._super(originalDefaults, constructorOptions);

    oj.EditableValueUtils.initializeOptionsFromDom(props, constructorOptions, this);
    this.multiple = !this._IsCustomElement() ? this.options.multiple : this.OuterWrapper.nodeName === 'OJ-COMBOBOX-MANY';

    if (this.options.value === undefined) {
      if (!this._IsCustomElement()) {
        this.options.value = this.element.attr('value') !== undefined ? _ComboUtils.splitVal(this.element.val(), ',') : null;
      }
    } else {
      // clone the value, otherwise _setDisplayValue will not be invoked on binding value to ko observableArray.
      // TODO: Need to revisit this once 18724975 is fixed.
      var value = this.options.value;

      if (Array.isArray(value)) {
        if (!this._IsCustomElement()) {
          value = value.slice(0);
        }
      } else if (typeof value === 'string') {
        if (this.multiple === true) {
          value = _ComboUtils.splitVal(value, ',');
        } else if (!this._IsCustomElement()) {
          value = [value];
        }
      }

      this.options.value = value;
    }
  },

  /**
  * Whether the component is required.
  *
  * @return {boolean} true if required; false
  *
  * @memberof! oj.ojCombobox
  * @instance
  * @protected
  * @override
  */
  _IsRequired: function _IsRequired() {
    return this.options.required;
  },

  /**
   * This method handles the labelled-by attribute change
   *
   * @param {string} labelledBy The id of the label element
   * @param {string} contentElementId The id of the conetent element
   *
   * @memberof! oj.ojCombobox
   * @instance
   * @private
   */
  // eslint-disable-next-line no-unused-vars
  _labelledByUpdatedForInputComp: function _labelledByUpdatedForInputComp(labelledBy, contentElementId) {
    oj.EditableValueUtils._labelledByUpdatedForInputComp.apply(this, arguments);

    if (this.combobox.results == null) {
      return;
    } // Update the aria-labelledby attribute of the results container
    // Fix  - Acc error in the OATB tool


    var defaultLabelId = this.uuid + '_Label';

    var ariaLabelledBy = oj.EditableValueUtils._getOjLabelAriaLabelledBy(labelledBy, defaultLabelId);

    this.combobox.results.attr('aria-labelledby', ariaLabelledBy);
  },

  /**
   * @memberof! oj.ojCombobox
   * @instance
   * @private
   */
  _initInputIdLabelForConnection: oj.EditableValueUtils._initInputIdLabelForConnection,

  /**
   * @memberof! oj.ojCombobox
   * @instance
   * @private
   */
  _linkLabelForInputComp: oj.EditableValueUtils._linkLabelForInputComp,

  /**
   * Draw a readonly div. When readonly, this div is shown and
   * the input has display:none on it through theming, and vice versa.
   * We set the textContent in _SetDisplayValue() if readonly
   * @param {HTMLElement} pass in this.element[0]
   * @memberof! oj.ojCombobox
   * @instance
   * @private
   */
  _createOrUpdateReadonlyDiv: oj.EditableValueUtils._createOrUpdateReadonlyDiv,

  /**
   * Performs post processing after required option is set by taking the following steps.
   *
   * - if component is invalid and has messgesShown -> required: false/true -> clear component errors;
   * run full validation with UI value (we don't know if the UI error is from a required validator
   * or something else);<br/>
   * &nbsp;&nbsp;- if there are validation errors, then value not pushed to model; messagesShown is
   * updated<br/>
   * &nbsp;&nbsp;- if no errors result from the validation, push value to model; author needs to
   * listen to optionChange(value) to clear custom errors.<br/>
   *
   * - if component is invalid and has messagesHidden -> required: false -> clear component
   * errors; no deferred validation is run.<br/>
   * - if component has no error -> required: true -> run deferred validation (we don't want to flag
   * errors unnecessarily)<br/>
   * - messagesCustom is never cleared<br/>
   *
   * @param {string} option
   *
   * @memberof! oj.ojCombobox
   * @instance
   * @protected
   */
  _AfterSetOptionRequired: oj.EditableValueUtils._AfterSetOptionRequired,

  /**
   * When validators option changes, take the following steps.
   *
   * - Clear the cached normalized list of all validator instances. push new hints to messaging.<br/>
   * - if component is valid -> validators changes -> no change<br/>
   * - if component is invalid has messagesShown -> validators changes -> clear all component
   * messages and re-run full validation on displayValue. if there are no errors push value to
   * model;<br/>
   * - if component is invalid has messagesHidden -> validators changes -> do nothing; doesn't change
   * the required-ness of component <br/>
   * - messagesCustom is not cleared.<br/>
   *
   * NOTE: The behavior applies to any option that creates implicit validators - min, max, pattern,
   * etc. Components can call this method when these options change.
   *
   * @memberof! oj.ojCombobox
   * @instance
   * @protected
   */
  _AfterSetOptionValidators: oj.EditableValueUtils._AfterSetOptionValidators,

  /**
      * When async-validators attribute changes, take the following steps.
      *
      * - Clear the cached normalized list of all validator instances. push new hints to messaging.<br/>
      * - if component is valid -> validators changes -> no change<br/>
      * - if component is invalid has messagesShown -> validators changes -> clear all component
      * messages and re-run full validation on displayValue. if there are no errors push value to
      * model;<br/>
      * - if component is invalid has messagesHidden -> validators changes -> do nothing; doesn't change
      * the required-ness of component <br/>
      * - messagesCustom is not cleared.<br/>
      * @memberof! oj.ojCombobox
      * @instance
      * @protected
      */
  _AfterSetOptionAsyncValidators: oj.EditableValueUtils._AfterSetOptionAsyncValidators,

  /**
   * Performs post processing after converter option changes by taking the following steps.
   *
   * - always push new converter hint to messaging <br/>
   * - if component has no errors -> refresh UI value<br/>
   * - if component is invalid has messagesShown -> clear all component errors and run full
   * validation using display value. <br/>
   * &nbsp;&nbsp;- if there are validation errors, value is not pushed to model; messagesShown is
   * updated.<br/>
   * &nbsp;&nbsp;- if no errors result from the validation, push value to model; author needs to
   * listen to optionChange(value) to clear custom errors.<br/>
   * - if component is invalid has messagesHidden -> refresh UI value. no need to run deferred
   * validations. <br/>
   * - messagesCustom is never cleared<br/>
   *
   * @memberof! oj.ojCombobox
   * @instance
   * @protected
   */
  _AfterSetOptionConverter: oj.EditableValueUtils._AfterSetOptionConverter,

  /**
   * Called when converter option changes and we have gotten the new converter
   * @memberof! oj.ojCombobox
   * @instance
   * @protected
   */
  _ResetConverter: oj.EditableValueUtils._ResetConverter,

  /**
   * Returns the normalized converter instance.
   *
   * @return {Object} a converter instance or null
   * @memberof! oj.ojCombobox
   * @instance
   * @protected
   */
  _GetConverter: oj.EditableValueUtils._GetConverter,

  /**
   * This returns an array of all validators
   * normalized from the validators option set on the component. <br/>
   * @return {Array} of validators.
   * @memberof! oj.ojCombobox
   * @instance
   * @protected
   */
  _GetNormalizedValidatorsFromOption: oj.EditableValueUtils._GetNormalizedValidatorsFromOption,

  /**
  * This returns an array of all async validators
  * normalized from the async-validators attribute set on the component. <br/>
  * @return {Array} of validators.
  * @memberof! oj.ojCombobox
  * @instance
  * @protected
  */
  _GetNormalizedAsyncValidatorsFromOption: oj.EditableValueUtils._GetNormalizedAsyncValidatorsFromOption,
  _setup: function _setup() {
    var opts = {};
    var multi = this.multiple;
    opts.element = this.element;
    opts.ojContext = this; // fixup valueOption(s) if placeholder is selected

    if (_ComboUtils.isValueForPlaceholder(multi, this.options.value)) {
      if (multi) {
        this.options.valueOptions = _ComboUtils.getValueOptionsForPlaceholder(this, this.options.valueOptions);
      } else {
        this.options.valueOption = _ComboUtils.getValueOptionsForPlaceholder(this, this.options.valueOption);
      }
    }

    opts = $.extend(this.options, opts);
    this.combobox = multi ? new _OjMultiCombobox() : new _OjSingleCombobox();

    this.combobox._init(opts);

    this._refreshRequired(this.options.required); //  - need to be able to specify the initial value of select components bound to dprv


    this._resolveValueOptionsLater = _ComboUtils.mergeValueAndValueOptions(this);
  },

  /**
   * @memberof! oj.ojCombobox
   * @instance
   * @private
   */
  _refreshRequired: oj.EditableValueUtils._refreshRequired,

  /**
   * Called to find out if aria-required is unsupported.
   * @memberof! oj.ojCombobox
   * @instance
   * @protected
   */
  _AriaRequiredUnsupported: function _AriaRequiredUnsupported() {
    return false;
  },

  /**
   * @memberof! oj.ojCombobox
   * @instance
   * @protected
   * @override
   */
  _destroy: function _destroy() {
    this.combobox._destroy();

    this._super();
  },

  /**
   * Returns if the element is a text field element or not.
   * @memberof oj.ojCombobox
   * @instance
   * @protected
   * @return {boolean}
   */
  _IsTextFieldComponent: function _IsTextFieldComponent() {
    return true;
  },

  /**
   * Returns the components wrapper under which label needs to be inserted in the inside strategy
   * @instance
   * @protected
   * @ignore
   * @return {Element|undefined}
   */
  _GetContentWrapper: function _GetContentWrapper() {
    if (this._IsCustomElement()) {
      return this.combobox._GetContentWrapper();
    }

    return undefined;
  },

  /**
   * Refreshes the combobox.
   *
   * <p>This method does not accept any arguments.
   *
   * @expose
   * @memberof oj.ojCombobox
   * @instance
   * @return {void}
   * @ojshortdesc Refreshes the combobox.
   * @public
   */
  refresh: function refresh() {
    this._super();

    this.combobox._destroy();

    this._setup();

    this._SetRootAttributes();

    this._initComponentMessaging();
  },

  /**
     * Handles options specific to combobox.
     * @override
     * @protected
     * @memberof! oj.ojCombobox
     */
  _setOption: function _setOption(key, _value, flags) {
    var value = _value;
    var multi = this.multiple;

    if (key === 'value') {
      if (Array.isArray(value)) {
        if (!this._IsCustomElement()) {
          value = value.slice(0);
        }
      } else if (typeof value === 'string') {
        if (multi === true) {
          value = _ComboUtils.splitVal(value, ',');
        } else if (!this._IsCustomElement()) {
          value = [value];
        }
      } // valueChangeTrigger will be used while setting the display value.


      if (flags && flags._context && flags._context.optionMetadata) {
        this.combobox.valueChangeTrigger = flags._context.optionMetadata.trigger;
      } else {
        this.combobox.valueChangeTrigger = null;
      } //  - placeholder is not displayed after removing selections from select many
      //  - resetting value when value-option and placeholder are set throws exception


      if (typeof this.options.placeholder === 'string' && (value == null || value && value.length === 0 || this._IsCustomElement() && _ComboUtils.isValueForPlaceholder(multi, value))) {
        _ComboUtils.setValueOptions(this, _ComboUtils.getFixupValueOptionsForPlaceholder(multi));

        this._super(key, value, flags);

        return;
      }
    } // if we have a new data provider, remove the old dataProvider event listeners


    if (key === 'options') {
      _ComboUtils.removeDataProviderEventListeners(this);

      _ComboUtils.clearDataProviderWrapper(this);
    } else if (key === 'optionsKeys') {
      _ComboUtils.clearDataProviderWrapper(this);
    } else if (key === 'valueOption' && multi !== true) {
      // fixup valueOption
      value = _ComboUtils.getValueOptionsForPlaceholder(this, value); //  - unable to clear values on lov value-option, to get the placeholder to show

      this.combobox.opts.valueOption = value;
    } else if (key === 'valueOptions' && multi === true) {
      // fixup valueOptions
      value = _ComboUtils.getValueOptionsForPlaceholder(this, value); //  - unable to clear values on lov value-option, to get the placeholder to show

      this.combobox.opts.valueOptions = value;
    }

    this._super(key, value, flags); //  - need to be able to specify the initial value of select components bound to dprv


    if (key === 'valueOption' && multi !== true) {
      _ComboUtils.syncValueWithValueOption(this, value, this.options.value, false);
    } else if (key === 'valueOptions' && multi === true) {
      _ComboUtils.syncValueWithValueOptions(this, value, this.options.value, false);
    } else if (key === 'value') {
      // update valueOptions
      _ComboUtils.updateValueOptions(this.combobox);
    } else if (key === 'options') {
      // only add data provider event listeners to new data provider
      if (_ComboUtils.isDataProvider(value)) {
        _ComboUtils.wrapDataProviderIfNeeded(this, this.combobox ? this.combobox.opts : null);

        _ComboUtils.addDataProviderEventListeners(this);
      }

      this.combobox.opts.options = value;
      this.combobox.opts = this.combobox._prepareOpts(this.combobox.opts); // : INCONSISTENT AUTOSUGGEST VALUES DISPLAYED IN OJCOMBOBOX COMPONENT
      // Open the dropdown when the user is still typing and the options are updated.

      if (this.combobox.isSearchFocused && this.combobox.shouldReopenOnNewData || this.combobox._opened()) {
        // This is to be treated as non-initial update as the term highlight should be done if there
        // are matches.
        this.combobox._updateResults(false, true);
      }
    } else if (key === 'optionsKeys') {
      _ComboUtils.wrapDataProviderIfNeeded(this, this.combobox ? this.combobox.opts : null);
    } else if (key === 'disabled') {
      if (value) {
        this.combobox._disable();
      } else {
        this.combobox._enable();
      } // Readonly support

    } else if (key === 'readOnly') {
      this.combobox.applyReadonlyState();
    } else if (key === 'labelledBy') {
      if (this.options.labelledBy) {
        var id = this._GetContentElement()[0].id;

        this._labelledByUpdatedForInputComp(this.options.labelledBy, id);
      }
    } else if (key === 'maximumResultCount') {
      this.combobox.opts.maximumResultCount = value;
    }
  },

  /**
     * Performs post processing after _SetOption() is called. Different options when changed perform
     * different tasks. See _AfterSetOption[OptionName] method for details.
     *
     * @param {string} option
     * @param {Object|string=} previous
     * @param {Object=} flags
     * @protected
     * @memberof! oj.ojCombobox
     * @instance
     * @override
     */
  // eslint-disable-next-line no-unused-vars
  _AfterSetOption: function _AfterSetOption(option, previous, flags) {
    this._superApply(arguments);

    switch (option) {
      case 'required':
        this._AfterSetOptionRequired(option);

        break;

      case 'validators':
        this._AfterSetOptionValidators(option);

        break;

      case 'converter':
        this._AfterSetOptionConverter(option);

        break;

      case 'asyncValidators':
        this._AfterSetOptionAsyncValidators(option);

        break;

      case 'labelHint':
      case 'labelEdge':
        // Changing labelHint and labelEdge might have updated
        // aria-label on the root element. Check if it is needed to
        // update the aria-label on inner elements.
        if (this.combobox) {
          this.combobox.updateAriaLabelIfNeeded();
        }

        break;

      default:
        break;
    }
  },
  // 19670748, dropdown popup should be closed on subtreeDetached notification.
  _NotifyDetached: function _NotifyDetached() {
    this._superApply(arguments);

    this.combobox.close();
  },
  // 19670748, dropdown popup should be closed on subtreeHidden notification.
  _NotifyHidden: function _NotifyHidden() {
    this._superApply(arguments);

    this.combobox.close();
  },

  /**
     * Override to do the delay connect/disconnect
     * @memberof oj.ojCombobox
     * @override
     * @protected
     */
  _VerifyConnectedForSetup: function _VerifyConnectedForSetup() {
    //  - temp moving oj-select from one elem to another should not cause fetch
    return true;
  },

  /**
     * Updates display value of combobox.
     * @override
     * @protected
     * @memberof! oj.ojCombobox
     */
  // eslint-disable-next-line no-unused-vars
  _SetDisplayValue: function _SetDisplayValue(displayValue) {
    //  - need to be able to specify the initial value of select components bound to dprv
    if (_ComboUtils.applyValueOptions(this.combobox, this.options)) {
      if (this.multiple) {
        this.combobox._clearSearch();
      }
    } else {
      this.combobox._initSelection();
    }

    this._resolveValueOptionsLater = false;
  },

  /**
     * Returns the display value.
     * @override
     * @protected
     * @memberof! oj.ojCombobox
     * @return {Array|Object|null} display value of the component
     */
  _GetDisplayValue: function _GetDisplayValue() {
    var displayValue = null;

    var opts = _ComboUtils.getOpts(this);

    var data = this.combobox._getSelectionData();

    if (data != null) {
      if (this.multiple) {
        displayValue = [];

        if (Array.isArray(data)) {
          for (var i = 0; i < data.length; i++) {
            displayValue.push(opts.formatSelection(data[i]));
          }
        } else {
          displayValue.push(opts.formatSelection(data));
        }
      } else {
        // eslint-disable-next-line no-lonely-if
        if (Array.isArray(data) && data.length > 0) {
          displayValue = opts.formatSelection(data[0]);
        } else {
          displayValue = opts.formatSelection(data);
        }
      }
    } else {
      // get the display value from editable value if the selection data is unavailable
      displayValue = this._super();
    }

    return displayValue;
  },

  /**
     * Set the placeholder.
     * @override
     * @protected
     * @memberof! oj.ojCombobox
     */
  _SetPlaceholder: function _SetPlaceholder(value) {
    if (this.combobox) {
      this.combobox.opts.placeholder = value; // TODO: pavitra - noticed that some combobox tests fail because the _setPlaceholder is
      // undefined, when this method is called from _AfterCreate().

      if (this.combobox._setPlaceholder) {
        this.combobox._setPlaceholder();
      }
    }
  },

  /**
     * Parses the value using the converter set and returns the parsed value. If parsing fails the
     * error is written into the element
     *
     * @override
     * @protected
     * @memberof! oj.ojCombobox
     * @instance
     */
  _parseValue: function _parseValue(_submittedValue) {
    var parsedVal;
    var submittedValue = _submittedValue;

    if (typeof submittedValue === 'string') {
      if (this.multiple === true) {
        submittedValue = _ComboUtils.splitVal(submittedValue, ',');
      } else if (!this._IsCustomElement()) {
        submittedValue = [submittedValue];
      }
    }

    if (Array.isArray(submittedValue)) {
      parsedVal = [];

      for (var i = 0; i < submittedValue.length; i++) {
        var parsed = this._super(submittedValue[i]);

        parsedVal.push(parsed);
      }
    } else {
      parsedVal = this._super(submittedValue);
    }

    return parsedVal;
  },

  /**
   * Returns the messaging launcher element  i.e., where user sets focus that triggers the popup.
   * Usually this is the element input or select that will receive focus and on which the popup
   * for messaging is initialized.
   *
   * @override
   * @protected
   * @memberof! oj.ojCombobox
   * @return {Object} jquery element which represents the messaging launcher component
   */
  _GetMessagingLauncherElement: function _GetMessagingLauncherElement() {
    return this.combobox.search;
  },

  /**
   * @override
   * @protected
   * @memberof! oj.ojCombobox
   *
   * @param {!Object} menu The JET Menu to open as a context menu.  Always non-<code class="prettyprint">null</code>.
   * @param {!Event} event What triggered the menu launch.  Always non-<code class="prettyprint">null</code>.
   * @param {string} eventType "mouse", "touch", or "keyboard".  Never <code class="prettyprint">null</code>.
   */
  _NotifyContextMenuGesture: function _NotifyContextMenuGesture(menu, event, eventType) {
    // The default baseComponent behavior in _OpenContextMenu assumes this.element for the
    // launcher. In this case, the original element the component is bound to is
    // hidden (display: none). Pass in an openOption override.
    var launcher = this._GetMessagingLauncherElement();

    this._OpenContextMenu(event, eventType, {
      launcher: launcher
    });
  },

  /**
   * Returns the jquery element that represents the content part of the component.
   * This is usually the component that user sets focus on (tabindex is set 0) and
   * where aria attributes like aria-required, aria-labeledby etc. are set. This is
   * also the element where the new value is updated. Usually this is the same as
   * the _GetMessagingLauncherElement.
   *
   * @override
   * @protected
   * @memberof! oj.ojCombobox
   * @return {jQuery} jquery element which represents the content.
   */
  _GetContentElement: function _GetContentElement() {
    return this.combobox.search;
  },

  /**
   * Returns the element on which aria-label can be found.
   * For combobox components, it is the content element where the aria-label will be set.
   *
   * @override
   * @protected
   * @memberof! oj.ojCombobox
   * @return {HTMLElement} The element in which we set the aria-label attribute
   */
  _GetAriaLabelElement: function _GetAriaLabelElement() {
    return this._GetContentElement()[0];
  },

  /**
   * Returns the default styleclass for the component.
   *
   * @return {string}
   * @expose
   * @memberof! oj.ojCombobox
   * @override
   * @protected
   */
  _GetDefaultStyleClass: function _GetDefaultStyleClass() {
    return 'oj-combobox';
  },

  /**
   *
   * @protected
   * @override
   * @instance
   * @memberof! oj.ojCombobox
   */
  _SetLoading: function _SetLoading() {
    this._super();

    this.combobox.applyReadonlyState();
  },

  /**
   *
   * @protected
   * @override
   * @instance
   * @memberof! oj.ojCombobox
   */
  _ClearLoading: function _ClearLoading() {
    this._super();

    this.combobox.applyReadonlyState();
  },

  /**
   * <ol>
   * <li>All messages are cleared, including custom messages added by the app. </li>
   * <li>If no converter is present then processing continues to next step. If a converter is
   * present, the UI value is first converted (i.e., parsed). If there is a parse error then
   * the messages are shown.</li>
   * <li>If there are no validators setup for the component the <code class="prettyprint">value</code>
   * option is updated using the display value. Otherwise all
   * validators are run in sequence using the parsed value from the previous step. The implicit
   * required validator is run first if the component is marked required. When a validation error is
   * encountered it is remembered and the next validator in the sequence is run. </li>
   * <li>At the end of validation if there are errors, the messages are shown.
   * If there were no errors, then the
   * <code class="prettyprint">value</code> option is updated.</li>
   * </ol>
   *
   * @example <caption>Validate component using its current value.</caption>
   * myComp.validate();
   *
   * @example <caption>Validate component and use the Promise's resolved state.</caption>
   * myComp.validate().then(
   *  function(result) {
   *    if(result === "valid")
   *    {
   *      submitForm();
   *    }
   *  });
   * @return {Promise} Promise resolves to "valid" if there were no converter parse errors and
   * the component passed all validations.
   * The Promise resolves to "invalid" if there were converter parse errors or
   * if there were validation errors.
   * @ojshortdesc Validates the component's display value using all converters and validators registered on the component. If there are no validation errors, then the value is updated. See the Help documentation for more information.
   * @method
   * @access public
   * @expose
   * @instance
   * @memberof oj.ojCombobox
   *
   */
  validate: function validate() {
    var displayValueForSetValue = this._getDisplayValueForSetValue();

    var combobox = this.combobox;
    var valueCandidate = displayValueForSetValue;
    var valOptToResetOnFailure;
    var returnValue;

    if (combobox.hasUncommittedValue) {
      // we need to update the valueOptions before setting the value
      var newValOpts = null;
      var multiple = this.multiple;

      if (multiple) {
        var lastRawValue = displayValueForSetValue[displayValueForSetValue.length - 1];
        var val = (combobox.getVal() || []).slice(0);

        var data = this._getValueOptionCandidateFromRawValue(lastRawValue);

        var id = combobox.id(data);
        var initialValOpts = (combobox.getValOpts() || []).slice(0);
        newValOpts = initialValOpts.slice(0);

        if (val.indexOf(id) === -1) {
          newValOpts.push(data);
          val.push(id); // : component oj-combobox-many displays the list of the values - does not exclude the invalid values
          // ValueOption has been modified, so it should be resetted
          // if validation fails

          valOptToResetOnFailure = initialValOpts;
        }

        valueCandidate = val;
      } else {
        newValOpts = this._getValueOptionCandidateFromRawValue(displayValueForSetValue);
        valueCandidate = combobox.id(newValOpts);
      }

      combobox._skipSetValueOptions = true;
      combobox.setValOpts(newValOpts); // Since the valOpts are set, reset the hasUncommittedValue flag
      // The newValOpts will be available in the component's valueOption

      combobox.hasUncommittedValue = false;
    } // returns Promise that resolves to true|false or boolean


    returnValue = this._SetValue(valueCandidate, null, this._VALIDATE_METHOD_OPTIONS);

    if (this._IsCustomElement()) {
      if (!(returnValue instanceof Promise)) {
        combobox._skipSetValueOptions = false;

        if (!returnValue && valOptToResetOnFailure) {
          combobox.setValOpts(valOptToResetOnFailure);
          combobox.hasUncommittedValue = true;
        }

        returnValue = Promise.resolve(returnValue ? 'valid' : 'invalid');
      } else {
        returnValue = returnValue.then(function (booleanSetValueReturn) {
          combobox._skipSetValueOptions = false;

          if (!booleanSetValueReturn && valOptToResetOnFailure) {
            combobox.setValOpts(valOptToResetOnFailure);
            combobox.hasUncommittedValue = true;
          }

          return Promise.resolve(booleanSetValueReturn ? 'valid' : 'invalid');
        });
      }
    }

    return returnValue;
  },

  /**
     * Runs full validation on the newValue and sets the newValue on the component.
     *
     * @return {Promise|boolean}
     * @memberof oj.ojCombobox
     * @override
     * @instance
     * @protected
     */
  _SetValue: function _SetValue(newValue, event, options) {
    // if the _SetValue has failed due to validation errors in combobox, update the display value
    // if there are no validation errors, display value will be updated by editableValue
    var resolved = this._super(newValue, event, options); // update display value only if there are validation errors
    // don't wait for the promise to resolve to update the display value


    if (!resolved || resolved instanceof Promise) {
      var isPlaceholderVal;

      if (this._IsCustomElement()) {
        isPlaceholderVal = _ComboUtils.isValueForPlaceholder(this.multiple, newValue);
      } else {
        isPlaceholderVal = newValue == null || newValue === '' || oj.Object.compareValues(newValue, []);
      } // do not update display value for the call from validate method
      // do not update display value if the newValue is a placeholder value
      // note: placeholder value indicates user is clearing selection(s) and
      // we don't need to update display value in that scenario.


      if (!isPlaceholderVal && options !== this._VALIDATE_METHOD_OPTIONS) {
        this._SetDisplayValue(newValue);
      }
    }

    return resolved;
  },

  /**
     * Whether a value can be set on the component. For example, if the component is
     * disabled or readOnly then setting value on component is a no-op.
     *
     * @see #_SetValue
     * @return {boolean}
     * @memberof oj.ojCombobox
     * @override
     * @instance
     * @protected
     */
  _CanSetValue: function _CanSetValue() {
    // FIX  - VALUE UNCHANGED IN DISABLED SELECT WHEN CHANGING BOUND VALUEOPTION
    // _SetValue always performs validation, which calls _CanSetValue, which returns false if
    // the component is disabled, thereby disallowing the set.  Override _CanSetValue here
    // so that we can force it to return true when syncing the value with the valueOption[s]
    // from _ComboUtils.syncValueWithValueOption[s].
    if (this.forceCanSetValue) {
      return true;
    }

    return this._super();
  },

  /**
     * Finds the valueOption candidate for the rawValue provided.
     * The value candidate is the value/label pair that will be set if the validation passes.
     * There can be two cases:
     *  1. The rawValue matches a key in the current dataprovider, then the valueOption from the
     *     dataprovider will be the value candidate
     *  2. Otherwise, a new valueOption will be created with value and label matching the rawValue
     *     which will be the value candidate
     *
     * @param {string} rawValue The rawValue for which the value candidate has to be obtained
     * @return {object} The valueOption candidate
     * @memberof oj.ojCombobox
     * @instance
     * @private
     */
  _getValueOptionCandidateFromRawValue: function _getValueOptionCandidateFromRawValue(rawValue) {
    var defaultValueOption = this.combobox.opts.manageNewEntry(rawValue);
    return _ComboUtils.findOptionFromResult(this.combobox, rawValue, defaultValueOption);
  },
  _getDisplayValueForSetValue: function _getDisplayValueForSetValue() {
    var displayValue = null;
    var newValue = null;
    var hasUncommittedValue = this.combobox.hasUncommittedValue;

    if (this.multiple !== true) {
      // Fix , 
      // Based on the state of the combobox, the return value is decided
      // If the combobox has uncommitted value in it (i.e. rawValue does not represent the value)
      // then the rawValue should be sent for validation, otherwise the value should be sent.
      // This is because the value represents the key while the rawValue represent the label.
      // So, when the combobox has uncommitted changes, then the rawValue will be the candidate for the
      // new label. When the combobox does not have uncommitted changes, the value is already set so it has
      // to be used for all validation purposes.
      if (hasUncommittedValue) {
        displayValue = this.combobox.getRawValue();
      } else {
        displayValue = this.combobox.getValOpts() ? this.combobox.getValOpts().value : null;
      }

      if (!this._IsCustomElement()) {
        if (displayValue === undefined || displayValue === null || displayValue === '') {
          newValue = [];
        } else {
          newValue = [displayValue];
        }
      } else {
        newValue = displayValue;
      }
    } else {
      // currentVal represents the current display value of the combobox component
      var existingValue = this.combobox.currentValue ? this.combobox.currentValue.slice(0) : [];
      displayValue = this.combobox.search.val();

      if (displayValue === undefined || displayValue === null || displayValue === '') {
        newValue = existingValue;
      } else {
        existingValue.push(displayValue);
        newValue = existingValue;
      }
    }

    return newValue;
  },
  _getDropdown: function _getDropdown() {
    if (this.combobox && this.combobox._opened()) {
      var dropdown = $('.oj-listbox-drop');

      for (var i = 0; i < dropdown.length; i++) {
        if ($(dropdown[i]).attr('id') === 'oj-listbox-drop' && $(dropdown[i]).attr('data-oj-containerid') === this.combobox.containerId) {
          return $(dropdown[i]);
        }
      }
    }

    return null;
  },
  _findItem: function _findItem(list, value) {
    for (var i = 0; i < list.length; i++) {
      if ($(list[i]).data('ojcombobox').value === value) {
        return list[i];
      }
    }

    return null;
  },
  // ////////////////     SUB-IDS     //////////////////

  /**
   * <p>Sub-ID for the input field</p>
   * @ojsubid oj-combobox-input
   * @memberof oj.ojCombobox
   *
   * @example <caption>Get the input field element</caption>
   * var node = myElement.getNodeBySubId({'subId': 'oj-combobox-input'});
   */

  /**
   * <p>Sub-ID for the drop down arrow of single-select combobox.</p>
   *
   * @ojsubid oj-combobox-arrow
   * @memberof oj.ojComboboxOne
   *
   * @example <caption>Get the drop down arrow of the combobox</caption>
   * var node = myElement.getNodeBySubId({'subId': 'oj-combobox-arrow'});
   */

  /**
   * <p>Sub-ID for the list item.</p>
   *
   * @ojsubid oj-listitem
   * @memberof oj.ojCombobox
   *
   * @example <caption>Get the listitem corresponding to value "myVal"</caption>
   * var node = myElement.getNodeBySubId({'subId': 'oj-listitem', 'value': 'myVal'});
   */

  /**
   * <p>Sub-ID for the remove icon of selected item.</p>
   *
   * @ojsubid oj-combobox-remove
   * @memberof oj.ojComboboxMany
   *
   * @example <caption>Get the element corresponding to the remove icon for the selected item with
   * value "myVal"</caption>
   * var node = myElement.getNodeBySubId({'subId': 'oj-combobox-remove', 'value': 'myVal'});
   */

  /**
   * <p>Sub-ID for the dropdown box.</p>
   *
   * @ojsubid oj-combobox-drop
   * @deprecated 1.2.0 This sub-ID is not needed since it is not an interactive element.
   * @memberof oj.ojCombobox
   * @ignore
   *
   * @example <caption>Get the dropdown box</caption>
   * var node = myElement.getNodeBySubId({'subId': 'oj-combobox-drop'});
   */

  /**
   * <p>Sub-ID for the filtered result list.</p>
   *
   * @ojsubid oj-combobox-results
   * @deprecated 1.2.0 This sub-ID is not needed since it is not an interactive element.
   * @memberof oj.ojCombobox
   * @ignore
   *
   * @example <caption>Get the filtered result list</caption>
   * var node = myElement.getNodeBySubId({'subId': 'oj-combobox-results'});
   */

  /**
   * <p>Sub-ID for the selected items. This returns a
   * list of the selected items.</p>
   *
   * @ojsubid oj-combobox-selection
   * @deprecated 1.2.0 This sub-ID is not needed since it is not an interactive element.
   * @memberof oj.ojComboboxMany
   * @ignore
   *
   * @example <caption>Get the list of selected items</caption>
   * var node = myElement.getNodeBySubId({'subId': 'oj-combobox-selection'});
   */
  // @inheritdoc
  getNodeBySubId: function getNodeBySubId(locator) {
    var node = null;
    var subId;

    if (locator == null) {
      return this.combobox.container ? this.combobox.container[0] : null;
    }

    node = this._super(locator);

    if (!node) {
      subId = locator.subId;

      if (subId === 'oj-combobox-drop') {
        subId = 'oj-listbox-drop';
      }

      if (subId === 'oj-combobox-results') {
        subId = 'oj-listbox-results';
      }

      if (subId === 'oj-combobox-selection') {
        subId = 'oj-combobox-selected-choice';
      }

      var dropdown = this._getDropdown();

      switch (subId) {
        case 'oj-combobox-input':
        case 'oj-combobox-arrow':
          node = this.widget().find('.' + subId)[0];
          break;

        case 'oj-listitem':
          if (dropdown) {
            var list = dropdown.find('.oj-listbox-result');
            node = this._findItem(list, locator.value);
          }

          break;

        case 'oj-combobox-remove':
          var selectedItems = this.widget().find('.oj-combobox-selected-choice');

          var item = this._findItem(selectedItems, locator.value);

          node = item ? $(item).find('.oj-combobox-clear-entry-icon')[0] : null;
          break;

        case 'oj-listbox-drop':
          if (dropdown) {
            node = dropdown[0];
          }

          break;

        case 'oj-listbox-results':
          if (dropdown) {
            node = dropdown.find('.' + subId)[0];
          }

          break;

        case 'oj-combobox-selected-choice':
          node = this.widget().find('.' + subId).toArray();
          break;

        default:
          break;
      }
    } // Non-null locators have to be handled by the component subclasses


    return node || null;
  },

  /**
   * Returns the subId object for the given child DOM node.  For more details, see
   * <a href="#getNodeBySubId">getNodeBySubId</a>.
   *
   * @expose
   * @override
   * @ignore
   * @memberof oj.ojCombobox
   * @instance
   *
   * @param {!Element} node - child DOM node
   * @return {Object|null} The subId for the DOM node, or <code class="prettyprint">null</code> when none is found.
   *
   * @example <caption>Get the subId for a certain DOM node:</caption>
   * myElement.getSubIdByNode(node);
   */
  getSubIdByNode: function getSubIdByNode(node) {
    var subId = null;

    if (node != null) {
      var nodeCached = $(node);

      if (nodeCached.hasClass('oj-combobox-input')) {
        subId = {
          subId: 'oj-combobox-input'
        };
      } else if (nodeCached.hasClass('oj-combobox-arrow')) {
        subId = {
          subId: 'oj-combobox-arrow'
        };
      } else if (nodeCached.hasClass('oj-listbox-result')) {
        subId = {
          subId: 'oj-listitem',
          value: nodeCached.data('ojcombobox').value
        };
      } else if (nodeCached.hasClass('oj-combobox-clear-entry-icon')) {
        subId = {
          subId: 'oj-combobox-remove',
          value: nodeCached.closest('.oj-combobox-selected-choice').data('ojcombobox').value
        };
      } else {
        subId = this._super(node);
      }
    }

    return subId;
  } // Fragments:

  /**
  * <p>The &lt;oj-combobox-one> element accepts <code class="prettyprint">oj-option</code> elements as children. See the [oj-option]{@link oj.ojOption} documentation for details about
  * accepted children and slots.</p>
  *
  * @ojchild Default
  * @memberof oj.ojComboboxOne
  * @ojshortdesc The oj-combobox-one element accepts oj-option elements as children.
  *
  * @example <caption>Initialize the Combobox with child content specified:</caption>
  * &lt;oj-combobox-one>
  *   &lt;oj-option value="option1">Option 1&lt;/oj-option>
  *   &lt;oj-option value="option2">Option 2&lt;/oj-option>
  *   &lt;oj-option value="option3">Option 3&lt;/oj-option>
  * &lt;/oj-combobox-one>
  */

  /**
  * <p>The &lt;oj-combobox-many> element accepts <code class="prettyprint">oj-option</code> elements as children. See the [oj-option]{@link oj.ojOption} documentation for details about
  * accepted children and slots.</p>
  *
  * @ojchild Default
  * @memberof oj.ojComboboxMany
  * @ojshortdesc The oj-combobox-many element accepts oj-option elements as children.
  *
  * @example <caption>Initialize the Combobox with child content specified:</caption>
  * &lt;oj-combobox-many>
  *   &lt;oj-option value="option1">Option 1&lt;/oj-option>
  *   &lt;oj-option value="option2">Option 2&lt;/oj-option>
  *   &lt;oj-option value="option3">Option 3&lt;/oj-option>
  * &lt;/oj-combobox-many>
  */

  /**
  * <p>The <code class="prettyprint">end</code> slot is for replacing combobox one's drop down arrow and the divider.
  * For example, a magnifying glass icon for a search field can be provided in this slot.
  * When the slot is provided with empty content, nothing will be rendered in the slot.
  * When the slot is not provided, the default drop down arrow icon and the divider will be rendered.</p>
  *
  * @ojslot end
  * @ojshortdesc The end slot enables replacement of the combobox's drop down arrow and divider. See the Help documentation for more information.
  * @since 4.2.0
  *
  * @memberof oj.ojComboboxOne
  *
  * @example <caption>Initialize the Combobox one with child content specified for the end slot:</caption>
  * &lt;oj-combobox-one>
  *   &lt;a slot='end' class='mySearchButtonClass'>&lt;/a>
  * &lt;/oj-combobox-one>
  */

  /**
  * <table class="keyboard-table">
  *   <thead>
  *     <tr>
  *       <th>Target</th>
  *       <th>Gesture</th>
  *       <th>Action</th>
  *     </tr>
  *   </thead>
  *   <tbody>
  *     <tr>
  *       <td>Input Field</td>
  *       <td><kbd>Tap</kbd></td>
  *       <td> If the drop down is not open, expand the drop down list. Otherwise, close the drop down list.
  *       If hints, title or messages exist in a notewindow,
  *        pop up the notewindow.</td>
  *     </tr>
  *     <tr>
  *       <td>Arrow Button</td>
  *       <td><kbd>Tap</kbd></td>
  *       <td> If the drop down is not open, expand the drop down list. Otherwise, close the drop down list.</td>
  *     </tr>
  *     <tr>
  *       <td>Option Item</td>
  *       <td><kbd>Tap</kbd></td>
  *       <td>Tap on an option item in the drop down list to select.</td>
  *     </tr>
  *   </tbody>
  *  </table>
  *
  * <p>Disabled option items receive no highlight and are not selectable.</p>
  *
  * @ojfragment touchDocOne - Used in touch gesture section of classdesc, and standalone gesture doc
  * @memberof oj.ojComboboxOne
  * @instance
  */

  /**
  * <table class="keyboard-table">
  *   <thead>
  *     <tr>
  *       <th>Target</th>
  *       <th>Gesture</th>
  *       <th>Action</th>
  *     </tr>
  *   </thead>
  *   <tbody>
  *     <tr>
  *       <td>Input Field</td>
  *       <td><kbd>Tap</kbd></td>
  *       <td> If the drop down is not open, expand the drop down list. Otherwise, close the drop down list.
  *       If hints, title or messages exist in a notewindow,
  *        pop up the notewindow.</td>
  *     </tr>
  *     <tr>
  *       <td>Option Item</td>
  *       <td><kbd>Tap</kbd></td>
  *       <td>Tap on an option item in the drop down list to add to selection.</td>
  *     </tr>
  *     <tr>
  *       <td>Selected item with remove icon</td>
  *       <td><kbd>Tap</kbd></td>
  *       <td>Remove item from the selected items list by tapping on the remove icon.</td>
  *     </tr>
  *   </tbody>
  *  </table>
  *
  * <p>Disabled option items receive no highlight and are not selectable.</p>
  *
  * @ojfragment touchDocMany - Used in touch gesture section of classdesc, and standalone gesture doc
  * @memberof oj.ojComboboxMany
  * @instance
  */

  /**
  * <table class="keyboard-table">
  *   <thead>
  *     <tr>
  *       <th>Target</th>
  *       <th>Key</th>
  *       <th>Action</th>
  *     </tr>
  *   </thead>
  *   <tbody>
  *     <tr>
  *      <td>Option item</td>
  *       <td><kbd>Enter</kbd></td>
  *       <td> Select the highlighted choice from the drop down.</td>
  *     </tr>
  *     <tr>
  *       <td>Input field</td>
  *       <td><kbd>Enter</kbd></td>
  *       <td>Set the input text as the value.</td>
  *     </tr>
  *     <tr>
  *      <td>Drop down</td>
  *       <td><kbd>UpArrow or DownArrow</kbd></td>
  *       <td> Highlight the option item on the drop down list in the direction of the arrow.
  *         If the drop down is not open, expand the drop down list.</td>
  *     </tr>
  *     <tr>
  *      <td>Drop down</td>
  *       <td><kbd>Esc</kbd></td>
  *       <td> Collapse the drop down list. If the drop down is already closed, do nothing.</td>
  *     </tr>
  *     <tr>
  *      <td>Combobox</td>
  *       <td><kbd>Tab In</kbd></td>
  *       <td>Set focus to the combobox. If hints, title or messages exist in a notewindow,
  *        pop up the notewindow.</td>
  *     </tr>
  *   </tbody>
  *  </table>
  *
  * <p>Disabled option items receive no highlight and are not selectable.</p>
  *
  * @ojfragment keyboardDocOne - Used in keyboard section of classdesc, and standalone gesture doc
  * @memberof oj.ojComboboxOne
  * @instance
  */

  /**
  * <table class="keyboard-table">
  *   <thead>
  *     <tr>
  *       <th>Target</th>
  *       <th>Key</th>
  *       <th>Action</th>
  *     </tr>
  *   </thead>
  *   <tbody>
  *     <tr>
  *      <td>Option item</td>
  *       <td><kbd>Enter</kbd></td>
  *       <td> Select the highlighted item from the drop down.</td>
  *     </tr>
  *     <tr>
  *       <td>Input field</td>
  *       <td><kbd>Enter</kbd></td>
  *       <td>Add the input text to selections.</td>
  *     </tr>
  *     <tr>
  *      <td>Drop down</td>
  *       <td><kbd>UpArrow or DownArrow</kbd></td>
  *       <td> Highlight the option item on the drop down list in the direction of the arrow.
  *         If the drop down is not open, expand the drop down list.</td>
  *     </tr>
  *     <tr>
  *      <td>Combobox</td>
  *       <td><kbd>LeftArrow or RightArrow</kbd></td>
  *       <td> Move focus to the previous or next selected item.</td>
  *     </tr>
  *     <tr>
  *       <td>Selected item with remove icon</td>
  *       <td><kbd>Backspace or Delete</kbd></td>
  *       <td>Remove the selected item having focus.</td>
  *     </tr>
  *     <tr>
  *      <td>Drop down</td>
  *       <td><kbd>Esc</kbd></td>
  *       <td> Collapse the drop down list. If the drop down is already closed, do nothing.</td>
  *     </tr>
  *     <tr>
  *      <td>Combobox</td>
  *       <td><kbd>Tab In</kbd></td>
  *       <td>Set focus to the combobox. If hints, title or messages exist in a notewindow,
  *        pop up the notewindow.</td>
  *     </tr>
  *   </tbody>
  *  </table>
  *
  * <p>Disabled option items receive no highlight and are not selectable.</p>
  *
  * @ojfragment keyboardDocMany - Used in keyboard section of classdesc, and standalone gesture doc
  * @memberof oj.ojComboboxMany
  * @instance
  */

});



/* global _ComboUtils:false, _OjInputSeachContainer:false, Logger:false */

/**
 * @ojcomponent oj.ojInputSearchWidget
 * @ignore
 * @augments oj.editableValue
 * @since 1.2.0
 *
 * @classdesc
 * <h3 id="inputSearchOverview-section">
 *   JET InputSearch Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#inputSearchOverview-section"></a>
 * </h3>
 *
 * <p>Description: JET InputSearch enhances a html input into a auto-suggest search input field.</p>
 *
 * <p>A JET InputSearch can be created with the following markup.</p>
 *
 * <pre class="prettyprint">
 * <code>
 * &lt;input list="items" data-bind="ojComponent: {component: 'ojInputSearch'}"/>
 * &lt;datalist id="items">
 *   &lt;option value="option 1">option 1&lt;/option>
 *   &lt;option value="option 2">option 2&lt;/option>
 *   &lt;option value="option 3">option 3&lt;/option>
 *   &lt;option value="option 4">option 4&lt;/option>
 * &lt;/datalist>
 * </code></pre>
 *
 * <p>Static <code class="prettyprint">options</code> array to provide the option items.</p>
 *
 * <pre class="prettyprint">
 * <code>
 * &lt;input data-bind="ojComponent: {component: 'ojInputSearch', options:
 *                                     [{value: 'option1', label: 'option1'}, {value: 'option2', label: 'option2'}]}"/>
 * </code></pre>
 *
 * <p>Options can be provided dynamically based on input instead of statically specifying the options array as shown in the above example</p>
 *
 * <pre class="prettyprint">
 * <code>
 * &lt;input data-bind="ojComponent: {component: 'ojInputSearch', options: function(optionContext) {
 *                                                                           return new Promise(function(fulfill, reject) {
 *                                                                             var term = context.term;
 *
 *                                                                             // Prepare options based on current 'term'.
 *                                                                             var options = [];
 *
 *                                                                             fulfill(options);
 *                                                                           }
 *                                                                         }}"/>
 * </code></pre>
 *
 * <h3 id="touch-section">
 *   Touch End User Information
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
 * </h3>
 *
 * {@ojinclude "name":"touchDoc"}
 *
 * <h3 id="keyboard-section">
 *   Keyboard End User Information
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 *
 * {@ojinclude "name":"keyboardDoc"}
 *
 *
 *
 * <h3 id="rtl-section">
 *   Reading direction
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
 * </h3>
 *
 * <p>As with any JET component, in the unusual case that the directionality (LTR or RTL) changes post-init, the InputSearch must be <code class="prettyprint">refresh()</code>ed.</p>
 *
 *
 * <h3 id="pseudos-section">
 *   Pseudo-selectors
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#pseudos-section"></a>
 * </h3>
 *
 * <p>The <code class="prettyprint">:oj-inputsearch</code> pseudo-selector can be used in jQuery expressions to select JET InputSearch.  For example:</p>
 *
 * <pre class="prettyprint">
 * <code>$( ":oj-inputsearch" ) // selects all JET InputSearch on the page
 * $myEventTarget.closest( ":oj-inputsearch" ) // selects the closest ancestor that is a JET InputSearch
 * </code></pre>
 *
 * <h3 id="a11y-section">
 *   Accessibility
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
 * </h3>
 * <p>
 * It is up to the application developer to associate the label to the input component.
 * For InputSearch, you should put an <code>id</code> on the input, and then set
 * the <code>for</code> attribute on the label to be the input's id.
 * </p>
 * <h3 id="label-section">
 *   Label and InputSearch
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#label-section"></a>
 * </h3>
 * <p>
 * If not using the <code class="prettyprint">label-hint</code> attribute, for accessibility, you should associate a label element with the input
 * by putting an <code>id</code> on the input, and then setting the
 * <code>for</code> attribute on the label to be the input's id.
 * </p>
 * <p>
 * The component will decorate its associated label with required and help
 * information, if the <code>required</code> and <code>help</code> options are set.
 * </p>
 * <h3 id="jqui2jet-section">
 *   JET for jQuery UI developers
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#jqui2jet-section"></a>
 * </h3>
 *
 * <p>Event names for all JET components are prefixed with "oj", instead of component-specific prefixes like "InputSearch".</p>
 *
 * @desc Creates a JET InputSearch.
 * @example <caption>Initialize the InputSearch with no options specified:</caption>
 * $( ".selector" ).ojInputSearch();
 *
 * @example <caption>Initialize the InputSearch with some options:</caption>
 * $( ".selector" ).ojInputSearch( { "minLength": 2, "placeholder": "Search..." } );
 *
 * @example <caption>Initialize the InputSearch via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;div id="search" data-bind="ojComponent: { component: 'ojInputSearch',
 *                                                    minLength: 2}">
 */
oj.__registerWidget('oj.ojInputSearch', $.oj.editableValue, {
  defaultElement: '<input>',
  widgetEventPrefix: 'oj',
  options: {
    /**
     * The placeholder text to set on the element. Though it is possible to set placeholder
     * attribute on the element itself, the component will only read the value when the component
     * is created. Subsequent changes to the element's placeholder attribute will not be picked up
     * and page authors should update the option directly.
     *
     *
     * @example <caption>Initialize the InputSearch with the <code class="prettyprint">placeholder</code> option specified:</caption>
     * $( ".selector" ).ojInputSearch( { "placeholder": "Search ..." } );
     *
     * @default when the option is not set, the element's placeholder attribute is used if it exists.
     *
     * @expose
     * @access public
     * @instance
     * @memberof! oj.ojInputSearchWidget
     * @type {string|null|undefined}
     */
    placeholder: undefined,

    /**
      * Whether the component is required or optional. When required is set to true, an implicit
      * required validator is created using the RequiredValidator -
     * <code class="prettyprint">RequiredValidator()</code>.
      *
      * Translations specified using the <code class="prettyprint">translations.required</code> option
      * and the label associated with the component, are passed through to the options parameter of the
      * createValidator method.
      *
      * <p>
      * When <code class="prettyprint">required</code> option changes due to programmatic intervention,
      * the component may clear messages and run validation, based on the current state it's in. </br>
      *
      * <h4>Running Validation</h4>
      * <ul>
      * <li>if component is valid when required is set to true, then it runs deferred validation on
      * the option value. This is to ensure errors are not flagged unnecessarily.
      * </li>
      * <li>if component is invalid and has deferred messages when required is set to false, then
      * component messages are cleared but no deferred validation is run.
      * </li>
      * <li>if component is invalid and currently showing invalid messages when required is set, then
      * component messages are cleared and normal validation is run using the current display value.
      * <ul>
      *   <li>if there are validation errors, then <code class="prettyprint">value</code>
      *   option is not updated and the error is shown.
      *   </li>
      *   <li>if no errors result from the validation, the <code class="prettyprint">value</code>
      *   option is updated; page author can listen to the <code class="prettyprint">optionChange</code>
      *   event on the <code class="prettyprint">value</code> option to clear custom errors.</li>
      * </ul>
      * </li>
      * </ul>
      *
      * <h4>Clearing Messages</h4>
      * <ul>
      * <li>Only messages created by the component are cleared.</li>
      * <li><code class="prettyprint">messagesCustom</code> option is not cleared.</li>
      * </ul>
      *
      * </p>
      * <p>
      * This property set to <code class="prettyprint">false</code> implies that a value is not required to be provided by the user.
      * This is the default.
      * This property set to <code class="prettyprint">true</code> implies that a value is required to be provided by the user.
      * </p>
      * <p>
      * Additionally a required validator -
      * {@link oj.RequiredValidator} - is implicitly used if no explicit required validator is set.
      * An explicit required validator can be set by page authors using the validators attribute.
      * </p>
      * <p>
      * In the Alta theme the input's label will render a required icon. In the Redwood theme, by default,
      * a Required text is rendered inline when the field is empty.  If user-assistance-density is 'compact', it will show on the label as an icon.
      * </p>
      *
      * @example <caption>Initialize the component with the <code class="prettyprint">required</code> option:</caption>
      * $(".selector").ojInputSearch({required: true});<br/>
      * @example <caption>Initialize <code class="prettyprint">required</code> option from html attribute 'required':</caption>
      * &lt;input list="browsers" required/><br/>
      * // retreiving the required option returns true
      * $(".selector").ojInputSearch("option", "required");<br/>
      *
      * @example <caption>Customize messages and hints used by implicit required validator when
      * <code class="prettyprint">required</code> option is set:</caption>
      * &lt;input list="browsers" required data-bind="ojComponent: {
      *   component: 'ojInputSearch',
      *   value: password,
      *   translations: {'required': {
      *                 hint: 'custom: enter at least 3 alphabets',
      *                 messageSummary: 'custom: \'{label}\' is Required',
      *                 messageDetail: 'custom: please enter a valid value for \'{label}\''}}}"/\>
      * @expose
      * @access public
      * @instance
      * @default when the option is not set, the element's required property is used as its initial value if it exists.
      * @memberof! oj.ojInputSearchWidget
      * @type {boolean}
      * @default false
      * @since 0.7.0
      * @see #translations
      */
    required: false,

    /**
     * The id of the html list for the InputSearch.
     *
     * @example <caption>Initialize the InputSearch with the <code class="prettyprint">list</code> option specified:</caption>
     * $( ".selector" ).ojInputSearch( { "list": "list" } );
     *
     * @example <caption>The <code class="prettyprint">list</code> points to a html <code class="prettyprint">ul</code> element.
     * The value for the list item should be specified with <code class="prettyprint">oj-data-value</code> field. By default, we use the first text node for search filtering. An optional <code class="prettyprint">oj-data-label</code> field can be added to the list item, in which case it will take precedence over the text node.</caption>
     * &lt;ul id="list"&gt;
     * &lt;li oj-data-value="li1"&gt;Item 1&lt;/li&gt;
     * &lt;li oj-data-value="li2"&gt;Item 2&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @expose
     * @memberof! oj.ojInputSearchWidget
     * @instance
     * @type {string|null|undefined}
     */
    list: undefined,

    /**
     * The option items for the InputSearch. Options can be specified as an array of objects containing value and label.
     * The value is used as the value of the option item and label as the label. Both should be of string type.
     * Group data can be provided with label and a children array containing the option items.
     * Option item can be set as disabled.
     *
     * <p>Options can be provided dynamically based on the text typed in the input field
     * by specifying a function as <code class="prettyprint">options</code> instead of static array.
     * This function will be invoked when there is a change in input field and it should return a <code class="prettyprint">Promise</code>.
     * The return type should be an array of objects containing value and label as similar to the static array as mentioned above.</p>
     *
     * <p>The context paramter passed to the <code class="prettyprint">options</code> function contains the following keys:</p>
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Key</th>
     *       <th>Description</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td><kbd>component</kbd></td>
     *       <td>A reference to the InputSearch widget constructor.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>term</kbd></td>
     *       <td>The text based on which options have to be filtered.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>value</kbd></td>
     *       <td>The same options callback function will be used get the value-label object when <code class="prettyprint">value</code> is set programmatically. In such cases context object will have <code class="prettyprint">value</code> instead of <code class="prettyprint">term</code>. Value will be of type Array and when this key is passed in the context, callback function should return array of options for all values.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * @expose
     * @memberof! oj.ojInputSearchWidget
     * @instance
     * @type {Array|function(Object)}
     *
     * @example <caption>Initialize the InputSearch with the <code class="prettyprint">options</code> specified:</caption>
     * $( ".selector" ).ojInputSearch( { "options": [{value: 'option1', label: 'option1'}, {value: 'option2', label: 'option2', disabled: true}, {value: 'option3', label: 'option3'}] } );
     *
     * @example <caption>Initialize the InputSearch with group data:</caption>
     * $( ".selector" ).ojInputSearch( { "options": [{label : 'group1', children: [{value: 'option1', label: 'option1'}, {value: 'option2', label: 'option2'}]}, {label: 'group2', children: [{value: 'option3', label: 'option3'}]} ] } );
     *
     * @example <caption>Initialize the InputSearch <code class="prettyprint">options</code> with a function:</caption>
     * $( ".selector" ).ojInputSearch({ "options": function(optionContext) {
     *                                               return new Promise(function(fulfill, reject) {
     *                                                 var term = context.term;
     *
     *                                                 // Prepare options based on current 'term'.
     *                                                 var options = [];
     *
     *                                                 fulfill(options);
     *                                               }
     *                                             }});
     */
    options: null,

    /**
     * Specify the key names to use in the options array.
     *
     * @expose
     * @memberof! oj.ojInputSearchWidget
     * @instance
     * @type {Object}
     *
     * @example <caption>Initialize the InputSearch with <code class="prettyprint">optionsKeys</code> specified. This allows the key names to be redefined in the options array.</caption>
     * $( ".selector" ).ojInputSearch( { "optionsKeys": {value : "state_abbr", label : "state_name"} } );
     *
     * @example <caption>Redefine keys for data with subgroups.</caption>
     * $( ".selector" ).ojInputSearch( { "optionsKeys": {label : "regions", children : "states", childKeys : {value : "state_abbr", label : "state_name"}} } );
     */
    optionsKeys: null,

    /**
     * <p>Attributes specified here will be set on the picker DOM element when it's launched.
     * <p>The supported attribute is <code class="prettyprint">class</code>, which is appended to the picker's class, if any.
     * Note: 1) pickerAttributes is not applied in the native theme.
     * 2) setting this option after component creation has no effect.
     *
     * @example <caption>Initialize the inputSearch specifying the class attribute to be set on the picker DOM element:</caption>
     * $( ".selector" ).ojInputSearch({ "pickerAttributes": {
     *   "class": "my-class"
     * }});
     *
     * @example <caption>Get the <code class="prettyprint">pickerAttributes</code> option, after initialization:</caption>
     * // getter
     * var inputSearch = $( ".selector" ).ojInputSearch( "option", "pickerAttributes" );
     *
     * @expose
     * @memberof! oj.ojInputSearchWidget
     * @instance
     * @type {?Object}
     * @default <code class="prettyprint">null</code>
     */
    pickerAttributes: null,

    /**
     * The renderer function that renders the content of an each option.
     * The function must return a DOM element representing the content of the option.
     * If the developer chooses to manipulate the option content directly,
     * the function should return nothing.
     *
     * <p>The <code class="prettyprint">optionRenderer</code> decides only
     * how the options' content has to be rendered in the drop down.
     * Once an option is selected from the drop down,
     * what value has to be displayed in the in input field is decided by the
     * label field in the data object. See <a href="#options">options</a>
     * and <a href="#optionsKeys">optionsKeys</a> for configuring option label and value.
     * </p>
     *
     * <p>The context paramter passed to the renderer contains the following keys:</p>
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Key</th>
     *       <th>Description</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td><kbd>component</kbd></td>
     *       <td>A reference to the InputSearch widget constructor.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>parent</kbd></td>
     *       <td>The parent of the data item. The parent is null for root node.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>index</kbd></td>
     *       <td>The index of the option, where 0 is the index of the first option. In the hierarchical case the index is relative to its parent.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>depth</kbd></td>
     *       <td>The depth of the option. The depth of the first level children under the invisible root is 0.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>leaf</kbd></td>
     *       <td>Whether the option is a leaf or a group.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>data</kbd></td>
     *       <td>The data object for the option.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>parentElement</kbd></td>
     *       <td>The option label element.  The renderer can use this to directly append content.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * @expose
     * @memberof! oj.ojInputSearchWidget
     * @instance
     * @type {function(Object)|null}
     * @default <code class="prettyprint">null</code>
     *
     * @example <caption>Initialize the InputSearch with a renderer:</caption>
     * $( ".selector" ).ojInputSearch({ "optionRenderer": function(optionContext) {
     *                                                      return optionContext['data']['FIRST_NAME'];}});
     *
     * @example <caption>Get or set the <code class="prettyprint">renderer</code> option, after initialization:</caption>
     * // set the renderer function
     * $( ".selector" ).ojInputSearch( "option", "optionRenderer", myFunction});
     */
    optionRenderer: null,

    /**
     * The knockout template used to render the content of the option in drop down.
     *
     * This attribute is only exposed via the <code class="prettyprint">ojComponent</code> binding, and is not a
     * component option.
     *
     * @ojbindingonly
     * @name optionTemplate
     * @memberof! oj.ojInputSearchWidget
     * @instance
     * @type {string|null}
     * @default <code class="prettyprint">null</code>
     *
     * @example <caption>Specify the <code class="prettyprint">template</code> when initializing InputSearch:</caption>
     * // set the template
     * &lt;ul id="inputsearch" data-bind="ojComponent: {component: 'ojInputSearch', optionTemplate: 'my_template'}"&gt;&lt;/ul&gt;
     */

    /**
     * The minimum number of characters a user must type before a options
     * filtering is performed. Zero is useful for local data with just a few items,
     * but a higher value should be used when a single character search could match a few thousand items.
     *
     * @expose
     * @memberof! oj.ojInputSearchWidget
     * @instance
     * @type {?number}
     * @default <code class="prettyprint">0</code>
     *
     * @example <caption>Initialize the InputSearch with the <code class="prettyprint">minLength</code> option specified:</caption>
     * $( ".selector" ).ojInputSearch( { "minLength": 2 } );
     */
    minLength: 0,

    /**
     * Triggered immediately before the InputSearch drop down is expanded.
     *
     * @expose
     * @event
     * @memberof! oj.ojInputSearchWidget
     * @instance
     * @property {Event} event <code class="prettyprint">jQuery</code> event object
     * @property {Object} ui Parameters
     *
     * @example <caption>Initialize the InputSearch with the <code class="prettyprint">beforeExpand</code> callback specified:</caption>
     * $( ".selector" ).ojInputSearch({
     *     "beforeExpand": function( event, ui ) {}
     * });
     *
     * @example <caption>Bind an event listener to the <code class="prettyprint">ojbeforeexpand</code> event:</caption>
     * $( ".selector" ).on( "ojbeforeexpand", function( event, ui ) {} );
     */
    beforeExpand: null,

    /**
     * <p>The  <code class="prettyprint">rawValue</code> is the read-only option for retrieving
     * the currently displayed value from the input field in text form.</p>
     * <p>
     * The <code class="prettyprint">rawValue</code> updates on the 'input' javascript event,
     * so the <code class="prettyprint">rawValue</code> changes as the value of the input is changed.
     * If the user types in '1,200' into the field, the rawValue will be '1', then '1,', then '1,2',
     * ..., and finally '1,200'. Then when the user blurs or presses
     * Enter the <code class="prettyprint">value</code> option gets updated.
     * </p>
     * <p>This is a read-only option so page authors cannot set or change it directly.</p>
     * @expose
     * @access public
     * @instance
     * @memberof! oj.ojInputSearchWidget
     * @type {string|undefined}
     * @since 2.0.2
     * @readonly
     */
    rawValue: undefined,

    /**
     * Fired whenever a component option changes, whether due to user interaction or programmatic
     * intervention.  If the new value is the same as the previous value, no event will be fired.  The event
     * listener will receive two parameters described below:
     *
     * @expose
     * @event
     * @memberof! oj.ojInputSearchWidget
     * @instance
     * @property {Event} event <code class="prettyprint">jQuery</code> event object
     * @property {Object} ui event payload
     * @property {string} ui.option the name of the option that is changing
     * @property {Object} ui.previousValue - an Object holding the previous value of the option.
     * When previousValue is not a primitive type, i.e., is an Object, it may hold the same value as
     * the value property.
     * @property {Object} ui.value - an Object holding the current value of the option.
     * @property {?Object} ui.subproperty - an Object holding information about the subproperty that changed.
     * @property {string} ui.subproperty.path - the subproperty path that changed.
     * @property {Object} ui.subproperty.previousValue - an Object holding the previous value of the subproperty.
     * @property {Object} ui.subproperty.value - an Object holding the current value of the subproperty.
     * @property {Object} ui.optionMetadata information about the option that is changing
     * @property {string} ui.optionMetadata.writeback <code class="prettyprint">"shouldWrite"</code> or
     *           <code class="prettyprint">"shouldNotWrite"</code>.  For use by the JET writeback mechanism.
     * @property {string} ui.optionMetadata.trigger This property indicates the what triggered the
     *           <code class="prettyprint">value</code> option change. Possible trigger types are:
     *             <code class="prettyprint">enter_pressed</code>,
     *             <code class="prettyprint">option_selected</code>,
     *             <code class="prettyprint">blur</code> and
     *             <code class="prettyprint">search_icon_clicked</code>
     *
     * @example <caption>Initialize component with the <code class="prettyprint">optionChange</code> callback</caption>
     * $(".selector").ojInputSearch({
     *   'optionChange': function (event, ui) {
     *        if (ui['option'] === 'value') { // handle value change }
     *    }
     * });
     * @example <caption>Bind an event listener to the ojoptionchange event</caption>
     * $(".selector").on({
     *   'ojoptionchange': function (event, ui) {
     *       window.console.log("option that changed is: " + ui['option']);
     *   };
     * });
     */
    optionChange: null,

    /**
     * <p>Fired whenever the value is submitted by the user.</p>
     *
     * <p>This event is similar to the <code class="prettyprint">value</code>
     * <a href="#event:optionChange">optionChange</a> event. The optionChange
     * event will be fired only if there is a change in the value,
     * but the <code class="prettyprint">update</code> event will be fired
     * even if there is no change in the value. This will help the
     * application to re-submit the search query for the same value.</p>
     *
     * <p><code class="prettyprint">update</code> event will be fired after the
     * 'value' <code class="prettyprint">optionChange</code> event.</p>
     *
     * @expose
     * @event
     * @memberof! oj.ojInputSearchWidget
     * @instance
     * @property {Event} event <code class="prettyprint">jQuery</code> event object
     * @property {Object} ui Parameters
     * @property {Object} ui.value - an Object holding the current value.
     * @property {Object} ui.optionMetadata information about the event.
     * @property {string} ui.optionMetadata.trigger This property indicates the what triggered the
     *             <code class="prettyprint">update</code> event. Possible trigger types are:
     *             <code class="prettyprint">enter_pressed</code>,
     *             <code class="prettyprint">option_selected</code> and
     *             <code class="prettyprint">search_icon_clicked</code>
     *
     * @example <caption>Initialize component with the <code class="prettyprint">update</code> callback</caption>
     * $(".selector").ojInputSearch({
     *   'update': function (event, data) {
     *        // handle update event
     *    }
     * });
     * @example <caption>Bind an event listener to the ojupdate event</caption>
     * $(".selector").on({
     *   'ojupdate': function (event, data) {
     *       window.console.log("Update event fired");
     *   };
     * });
     */
    update: null,

    /**
     * List of validators used by component when performing validation. Each item is either an
     * instance that duck types {@link oj.Validator}, or is an Object literal containing the
     * properties listed below. Implicit validators created by a component when certain options
     * are present (e.g. <code class="prettyprint">required</code> option), are separate from
     * validators specified through this option. At runtime when the component runs validation, it
     * combines the implicit validators with the list specified through this option.
     * <p>
     * Hints exposed by validators are shown in the notewindow by default, or as determined by the
     * 'validatorHint' property set on the <code class="prettyprint">displayOptions</code>
     * option.
     * </p>
     *
     * <p>
     * When <code class="prettyprint">validators</code> option changes due to programmatic
     * intervention, the component may decide to clear messages and run validation, based on the
     * current state it is in. </br>
     *
     * <h4>Steps Performed Always</h4>
     * <ul>
     * <li>The cached list of validator instances are cleared and new validator hints is pushed to
     * messaging. E.g., notewindow displays the new hint(s).
     * </li>
     * </ul>
     *
     * <h4>Running Validation</h4>
     * <ul>
     * <li>if component is valid when validators changes, component does nothing other than the
     * steps it always performs.</li>
     * <li>if component is invalid and is showing messages when
     * <code class="prettyprint">validators</code> changes then all component messages are cleared
     * and full validation run using the display value on the component.
     * <ul>
     *   <li>if there are validation errors, then <code class="prettyprint">value</code>
     *   option is not updated and the error is shown.
     *   </li>
     *   <li>if no errors result from the validation, the <code class="prettyprint">value</code>
     *   option is updated; page author can listen to the <code class="prettyprint">optionChange</code>
     *   event on the <code class="prettyprint">value</code> option to clear custom errors.</li>
     * </ul>
     * </li>
     * <li>if component is invalid and has deferred messages when validators changes, it does
     * nothing other than the steps it performs always.</li>
     * </ul>
     * </p>
     *
     * <h4>Clearing Messages</h4>
     * <ul>
     * <li>Only messages created by the component are cleared.</li>
     * <li><code class="prettyprint">messagesCustom</code> option is not cleared.</li>
     * </ul>
     * </p>
     *
         *
     * @example <caption>Initialize the component with validator object literal:</caption>
     * $(".selector").ojInputSearch({
     *   validators: [{
     *     type: 'regExp',
     *     options : {
     *       pattern: '[a-zA-Z0-9]{3,}'
     *     }
     *   }],
     * });
     *
     * NOTE: oj.Validation.validatorFactory('numberRange') returns the validator factory that is used
     * to instantiate a range validator for numbers.
     *
     * @example <caption>Initialize the component with multiple validator instances:</caption>
     * var validator1 = new MyCustomValidator({'foo': 'A'});
     * var validator2 = new MyCustomValidator({'foo': 'B'});
     * $(".selector").ojInputSearch({
     *   value: 'option',
     *   validators: [validator1, validator2]
     * });
     *
     * @expose
     * @access public
     * @instance
     * @memberof! oj.ojInputSearchWidget
     * @type {Array|undefined}
     */
    validators: undefined
    /**
     * The type of value is an array, and an array will always be returned from the component.
     * The first element of the array will be used as the value.
     * As a convenience we allow a string to be passed into the setter,
     * but note that the value option can only be bound to a knockout observableArray.
     *
     * @example <caption>Initialize the InputSearch with the <code class="prettyprint">value</code> option specified:</caption>
     * $(".selector").ojInputSearch({'value': "option"});<br/>
     *
     * @example <caption>Get or set the <code class="prettyprint">value</code> option, after initialization:</caption>
     * // Getter: returns value
     * $(".selector").ojInputSearch("option", "value");
     * // Setter: sets value with array containing "option1"
     * $(".selector").ojInputSearch("option", "value", ["option1"]);
     * // Setter: sets value with string "option1"
     * $(".selector").ojInputSearch("option", "value", "option1");
     *
     * @member
     * @name  value
     * @access public
     * @instance
     * @default When the option is not set, the element's value property is used as its initial value if it exists.
     * @memberof! oj.ojInputSearchWidget
     * @type {string|Array}
     */

  },

  /**
   * Returns a jQuery object containing the element visually representing the InputSearch.
   *
   * <p>This method does not accept any arguments.
   *
   * @expose
   * @memberof! oj.ojInputSearchWidget
   * @instance
   * @return {jQuery} the ojInputSearch
   */
  widget: function widget() {
    return this.inputSearch.container;
  },

  /**
   * @override
   * @private
   */
  _ComponentCreate: function _ComponentCreate() {
    this._super();

    this._setup();
  },
  _InitOptions: function _InitOptions(originalDefaults, constructorOptions) {
    var props = [{
      attribute: 'disabled',
      validateOption: true
    }, {
      attribute: 'placeholder'
    }, {
      attribute: 'required',
      coerceDomValue: true,
      validateOption: true
    }, {
      attribute: 'title'
    }];

    this._super(originalDefaults, constructorOptions);

    oj.EditableValueUtils.initializeOptionsFromDom(props, constructorOptions, this);

    if (this.options.value === undefined) {
      this.options.value = this.element.attr('value') !== undefined ? _ComboUtils.splitVal(this.element.val(), ',') : null;
    } else {
      var value = this.options.value;

      if (Array.isArray(value)) {
        value = value.slice(0);
      } else if (typeof value === 'string') {
        value = [value];
      }

      this.options.value = value;
    }
  },

  /**
  * Performs post processing after _SetOption() is called. Different options when changed perform
  * different tasks. See _AfterSetOption[OptionName] method for details.
  *
  * @param {string} option
  * @param {Object|string=} previous
  * @param {Object=} flags
  * @protected
  * @memberof! oj.ojInputSearchWidget
  * @instance
  * @override
  */
  // eslint-disable-next-line no-unused-vars
  _AfterSetOption: function _AfterSetOption(option, previous, flags) {
    this._superApply(arguments);

    switch (option) {
      case 'required':
        this._AfterSetOptionRequired(option);

        break;

      case 'validators':
        this._AfterSetOptionValidators(option);

        break;

      default:
        break;
    }
  },

  /**
   * Whether the component is required.
   *
   * @return {boolean} true if required; false
   *
   * @memberof! oj.ojInputSearchWidget
   * @instance
   * @protected
   * @override
   */
  _IsRequired: function _IsRequired() {
    return this.options.required;
  },

  /**
   * Performs post processing after required option is set by taking the following steps.
   *
   * - if component is invalid and has messgesShown -> required: false/true -> clear component errors;
   * run full validation with UI value (we don't know if the UI error is from a required validator
   * or something else);<br/>
   * &nbsp;&nbsp;- if there are validation errors, then value not pushed to model; messagesShown is
   * updated<br/>
   * &nbsp;&nbsp;- if no errors result from the validation, push value to model; author needs to
   * listen to optionChange(value) to clear custom errors.<br/>
   *
   * - if component is invalid and has messagesHidden -> required: false -> clear component
   * errors; no deferred validation is run.<br/>
   * - if component has no error -> required: true -> run deferred validation (we don't want to flag
   * errors unnecessarily)<br/>
   * - messagesCustom is never cleared<br/>
   *
   * @param {string} option
   *
   * @memberof! oj.ojInputSearchWidget
   * @instance
   * @protected
   */
  _AfterSetOptionRequired: oj.EditableValueUtils._AfterSetOptionRequired,

  /**
   * When validators option changes, take the following steps.
   *
   * - Clear the cached normalized list of all validator instances. push new hints to messaging.<br/>
   * - if component is valid -> validators changes -> no change<br/>
   * - if component is invalid has messagesShown -> validators changes -> clear all component
   * messages and re-run full validation on displayValue. if there are no errors push value to
   * model;<br/>
   * - if component is invalid has messagesHidden -> validators changes -> do nothing; doesn't change
   * the required-ness of component <br/>
   * - messagesCustom is not cleared.<br/>
   *
   * NOTE: The behavior applies to any option that creates implicit validators - min, max, pattern,
   * etc. Components can call this method when these options change.
   *
   * @memberof! oj.ojInputSearchWidget
   * @instance
   * @protected
   */
  _AfterSetOptionValidators: oj.EditableValueUtils._AfterSetOptionValidators,

  /**
   * @memberof! oj.ojInputSearchWidget
   * @instance
   * @private
   */
  _refreshRequired: oj.EditableValueUtils._refreshRequired,

  /**
   * This returns an array of all validators
   * normalized from the validators option set on the component. <br/>
   * @return {Array} of validators.
   * @memberof! oj.ojInputSearchWidget
   * @instance
   * @protected
   */
  _GetNormalizedValidatorsFromOption: oj.EditableValueUtils._GetNormalizedValidatorsFromOption,

  /**
   * Called to find out if aria-required is unsupported.
   * @memberof! oj.ojInputSearchWidget
   * @instance
   * @protected
   */
  _AriaRequiredUnsupported: function _AriaRequiredUnsupported() {
    return false;
  },

  /**
   * @memberof! oj.ojInputSearchWidget
   * @instance
   * @private
   */
  _setup: function _setup() {
    var opts = {};
    opts.element = this.element;
    opts.ojContext = this;
    opts.inputSearch = true;
    opts = $.extend(this.options, opts);
    this.inputSearch = new _OjInputSeachContainer();

    this.inputSearch._init(opts);

    this._refreshRequired(this.options.required);
  },

  /**
   * @override
   * @private
   */
  _destroy: function _destroy() {
    this.inputSearch._destroy();

    this._super();
  },

  /**
   * Refreshes the InputSearch.
   *
   * <p>This method does not accept any arguments.
   *
   * @expose
   * @memberof! oj.ojInputSearchWidget
   * @instance
   */
  refresh: function refresh() {
    this._super();

    this.inputSearch._destroy();

    this._setup();

    this._SetRootAttributes();
  },

  /**
   * Handles options specific to InputSearch.
   * @override
   * @protected
   * @memberof! oj.ojInputSearchWidget
   */
  _setOption: function _setOption(key, _value, flags) {
    var value = _value;

    if (key === 'value') {
      // clone the value, otherwise _setDisplayValue will not be invoked on binding value to ko observableArray.
      // TODO: Need to revisit this once 18724975 is fixed.
      if (value != null) {
        if (Array.isArray(value)) {
          value = value.slice(0);
        } else if (typeof value === 'string') {
          value = [value];
        } else {
          Logger.error('ojInputSearch value has to be an array of string or a string.');
        }
      } // valueChangeTrigger will be used while setting the display value.


      if (flags && flags._context && flags._context.optionMetadata) {
        this.inputSearch.valueChangeTrigger = flags._context.optionMetadata.trigger;
      } else {
        this.inputSearch.valueChangeTrigger = null;
      }
    }

    this._super(key, value, flags);

    if (key === 'options') {
      this.inputSearch.opts.options = value;
      this.inputSearch.opts = this.inputSearch._prepareOpts(this.inputSearch.opts);
    }

    if (key === 'disabled') {
      if (value) {
        this.inputSearch._disable();
      } else {
        this.inputSearch._enable();
      }
    }
  },
  _NotifyDetached: function _NotifyDetached() {
    this._superApply(arguments);

    this.inputSearch.close();
  },
  // 19670748, dropdown popup should be closed on subtreeHidden notification.
  _NotifyHidden: function _NotifyHidden() {
    this._superApply(arguments);

    this.inputSearch.close();
  },

  /**
   * Updates display value of InputSearch.
   * @override
   * @protected
   * @memberof! oj.ojInputSearchWidget
   */
  // eslint-disable-next-line no-unused-vars
  _SetDisplayValue: function _SetDisplayValue(displayValue) {
    this.inputSearch._initSelection();
  },

  /**
   * Set the placeholder.
   * @override
   * @protected
   * @memberof! oj.ojInputSearchWidget
   */
  _SetPlaceholder: function _SetPlaceholder(value) {
    if (this.inputSearch) {
      this.inputSearch.opts.placeholder = value;

      if (this.inputSearch._setPlaceholder) {
        this.inputSearch._setPlaceholder();
      }
    }
  },

  /**
   * Validates the component's value using the converter and all validators registered on
   * the component.
   * @return {boolean} true if component passed validation,
   * false if there were validation errors.
   * @example <caption>Validate component using its current value.</caption>
   * // validate display value.
   * $(.selector).ojInputSearch('validate');
   *
   * @expose
   * @override
   * @memberof! oj.ojInputSearchWidget
   * @instance
   */
  validate: function validate() {
    var displayValue = this.inputSearch.search.val();
    var newValue = null;
    var existingValue = [];

    if (this.isValid()) {
      existingValue = this.inputSearch.getVal();
    }

    if (displayValue === undefined || displayValue === null || displayValue === '') {
      newValue = existingValue;
    } else {
      newValue = [displayValue];
    }

    return this._SetValue(newValue, null, this._VALIDATE_METHOD_OPTIONS);
  },

  /**
   * Parses the value using the converter set and returns the parsed value. If parsing fails the
   * error is written into the element
   *
   * @override
   * @protected
   * @memberof! oj.ojInputSearchWidget
   * @instance
   */
  _parseValue: function _parseValue(submittedValue) {
    var parsedVal = [];
    var parsed;

    if (submittedValue == null) {
      return parsedVal;
    }

    if (Array.isArray(submittedValue)) {
      for (var i = 0; i < submittedValue.length; i++) {
        parsed = this._super(submittedValue[i]);
        parsedVal.push(parsed.toString());
      }
    } else if (typeof submittedValue === 'string') {
      parsed = this._super(submittedValue);
      parsedVal.push(parsed.toString());
    } else {
      Logger.error('ojInputSearch value has to be an array of string or a string.');
    }

    return parsedVal;
  },

  /**
   * Returns the messaging launcher element  i.e., where user sets focus that triggers the popup.
   * Usually this is the element input or select that will receive focus and on which the popup
   * for messaging is initialized.
   *
   * @override
   * @protected
   * @memberof! oj.ojInputSearchWidget
   * @return {Object} jquery element which represents the messaging launcher component
   */
  _GetMessagingLauncherElement: function _GetMessagingLauncherElement() {
    return this.inputSearch.search;
  },

  /**
   * Returns the jquery element that represents the content part of the component.
   * This is usually the component that user sets focus on (tabindex is set 0) and
   * where aria attributes like aria-required, aria-labeledby etc. are set. This is
   * also the element where the new value is updated. Usually this is the same as
   * the _GetMessagingLauncherElement.
   *
   * @override
   * @protected
   * @memberof! oj.ojInputSearchWidget
   * @return {jQuery} jquery element which represents the content.
   */
  _GetContentElement: function _GetContentElement() {
    return this.inputSearch.search;
  },

  /**
   * Returns the default styleclass for the component.
   *
   * @return {string}
   * @expose
   * @memberof! oj.ojInputSearchWidget
   * @override
   * @protected
   */
  _GetDefaultStyleClass: function _GetDefaultStyleClass() {
    return 'oj-inputsearch';
  },
  _getDropdown: function _getDropdown() {
    if (this.inputSearch && this.inputSearch._opened()) {
      var dropdown = $('.oj-listbox-drop');

      for (var i = 0; i < dropdown.length; i++) {
        if ($(dropdown[i]).attr('id') === 'oj-listbox-drop' && $(dropdown[i]).attr('data-oj-containerid') === this.inputSearch.containerId) {
          return $(dropdown[i]);
        }
      }
    }

    return null;
  },

  /**
   * Opens the InputSearch drop-down.
   *
   * @expose
   * @memberof oj.ojInputSearchWidget
   * @instance
   */
  expand: function expand() {
    this.inputSearch.open();
  },

  /**
   * Closes the InputSearch drop-down.
   *
   * @expose
   * @memberof oj.ojInputSearchWidget
   * @instance
   */
  collapse: function collapse() {
    this.inputSearch.close();
  },
  // ////////////////     SUB-IDS     //////////////////

  /**
   * <p>Sub-ID for the input field
   *
   * <p>See the <a href="#getNodeBySubId">getNodeBySubId</a> and
   * <a href="#getSubIdByNode">getSubIdByNode</a> methods for details.
   *
   * @ojsubid
   * @member
   * @name oj-inputsearch-input
   * @memberof oj.ojInputSearchWidget
   * @instance
   *
   * @example <caption>Get the input field element</caption>
   * var node = $( ".selector" ).ojInputSearch( "getNodeBySubId", {'subId': 'oj-inputsearch-input'} );
   */

  /**
   * <p>Sub-ID for the search icon of InputSearch.
   *
   * <p>See the <a href="#getNodeBySubId">getNodeBySubId</a> and
   * <a href="#getSubIdByNode">getSubIdByNode</a> methods for details.
   *
   * @ojsubid
   * @member
   * @name oj-inputsearch-search
   * @memberof oj.ojInputSearchWidget
   * @instance
   *
   * @example <caption>Get the search icon of the InputSearch</caption>
   * var node = $( ".selector" ).ojInputSearch( "getNodeBySubId", {'subId': 'oj-inputsearch-search'} );
   */

  /**
   * <p>Sub-ID for the list item.</p>
   *
   * @ojsubid oj-listitem
   * @memberof oj.ojInputSearchWidget
   *
   * @example <caption>Get the listitem corresponding to value "myVal"</caption>
   * var node = $( ".selector" ).ojInputSearch( "getNodeBySubId", {'subId': 'oj-listitem', 'value': 'myVal'} );
   */
  getNodeBySubId: function getNodeBySubId(locator) {
    var node = null;
    var subId;

    if (locator === null) {
      return this.inputSearch.container ? this.inputSearch.container[0] : null;
    }

    node = this._super(locator);

    if (!node) {
      subId = locator.subId;

      if (subId === 'oj-inputsearch-search') {
        subId = 'oj-inputsearch-search-button';
      }

      switch (subId) {
        case 'oj-inputsearch-input':
        case 'oj-inputsearch-search-button':
          node = this.widget().find('.' + subId)[0];
          break;

        case 'oj-listitem':
          var dropdown = this._getDropdown();

          if (dropdown) {
            var list = dropdown.find('.oj-listbox-result');
            node = this.inputSearch._findItem(list, locator.value);
          }

          break;

        default:
          break;
      }
    } // Non-null locators have to be handled by the component subclasses


    return node || null;
  },

  /**
   * Returns the subId object for the given child DOM node.  For more details, see
   * <a href="#getNodeBySubId">getNodeBySubId</a>.
   *
   * @expose
   * @override
   * @ignore
   * @memberof oj.ojInputSearchWidget
   * @instance
   *
   * @param {!Element} node - child DOM node
   * @return {Object|null} The subId for the DOM node, or <code class="prettyprint">null</code> when none is found.
   *
   * @example <caption>Get the subId for a certain DOM node:</caption>
   * var subId = $( ".selector" ).ojInputSearch( "getSubIdByNode", node );
   */
  getSubIdByNode: function getSubIdByNode(node) {
    var subId = null;

    if (node != null) {
      var nodeCached = $(node);

      if (nodeCached.hasClass('oj-inputsearch-input')) {
        subId = {
          subId: 'oj-inputsearch-input'
        };
      } else if (nodeCached.hasClass('oj-inputsearch-search-button')) {
        subId = {
          subId: 'oj-inputsearch-search'
        };
      } else if (nodeCached.hasClass('oj-listbox-result')) {
        subId = {
          subId: 'oj-listitem',
          value: nodeCached.data('ojinputsearch').value
        };
      } else {
        subId = this._super(node);
      }
    }

    return subId;
  } // Fragments:

  /**
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Input Field</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td> If the drop down is not open, expand the drop down list. Otherwise, close the drop down list
     *       If hints, title or messages exist in a notewindow,
     *        pop up the notewindow.</td>
     *     </tr>
     *     <tr>
     *       <td>Search Button</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td> Updates the value with the text entered in the input field and fires the <code class="prettyprint">optionChange</code> event which can be used to perform search.</td>
     *     </tr>
     *     <tr>
     *       <td>Option Item</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Tap on a option item in the drop down list to select item.</td>
     *     </tr>
     *   </tbody>
     *  </table>
     *
     * <p>Disabled option items receive no highlight and are not selectable.</p>
   *
   *
   * @ojfragment touchDoc - Used in touch gesture section of classdesc, and standalone gesture doc
   * @memberof oj.ojInputSearchWidget
   */

  /**
     * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Target</th>
   *       <th>Key</th>
   *       <th>Action</th>
   *     </tr>
   *   </thead>
     *   <tbody>
     *     <tr>
     *      <td>Input</td>
     *       <td><kbd>Enter</kbd></td>
     *       <td> Select the highlighted choice from the drop down.</td>
     *     </tr>
     *     <tr>
     *      <td>Input</td>
     *       <td><kbd>UpArrow or DownArrow</kbd></td>
     *       <td> Highlight the option item on the drop down list in the direction of the arrow.
     *         If the drop down is not open, expand the drop down list.</td>
     *     </tr>
     *     <tr>
     *      <td>Input</td>
     *       <td><kbd>Esc</kbd></td>
     *       <td> Collapse the drop down list. If the drop down is already closed, do nothing.</td>
     *     </tr>
     *     <tr>
     *        <td>Input</td>
     *       <td><kbd>Tab In</kbd></td>
     *       <td>Set focus to the input. If hints, title or messages exist in a notewindow,
     *        pop up the notewindow.</td>
     *     </tr>
     *   </tbody>
     *  </table>
     *
     * <p>Disabled option items receive no highlight and are not selectable.</p>
   *
   * @ojfragment keyboardDoc - Used in keyboard section of classdesc, and standalone gesture doc
   * @memberof oj.ojInputSearchWidget
   */
  // -------------------- Styling start ------------------------
  // ------------------------------ oj-listbox-header ---------------------------------

  /**
   * Optional. Custom header options can be added to the drop down through this styling.
   * @ojstyleclass oj-listbox-header
   * @ojdisplayname Custom Header
   * @memberof oj.ojInputSearchWidget
   */
  // ------------------------------ oj-listbox-highlighter-section ---------------------------------

  /**
   * Optional. Styling to control the which part of the option label has to be considered for highlighting.
   * @ojstyleclass oj-listbox-highlighter-section
   * @ojdisplayname Highlighting Control
   * @memberof oj.ojInputSearchWidget
   */
  // -------------------- Styling end ------------------------

});



/* global _ComboUtils:false, _OjMultiSelect:false, _OjSingleSelect:false, Components:false, Logger:false, ThemeUtils:false, Promise:false */

/**
 * @ojcomponent oj.ojSelectOne
 * @augments oj.ojSelect
 * @since 0.6.0
 * @ojdisplayname Select (One)
 * @ojshortdesc A select one is a dropdown list that supports single selection and search filtering.
 * @ojdeprecated {since: "8.1.0", description: "Please use &lt;oj-select-single&gt; instead."}
 * @ojrole combobox
 * @ojsignature [{
 *                target: "Type",
 *                value: "class ojSelectOne<K, D, V = any> extends ojSelect<V, ojSelectOneSettableProperties<K, D, V>>",
 *                genericParameters: [{"name": "K", "description": "Type of key of the dataprovider"}, {"name": "D", "description": "Type of data from the dataprovider"},
 *                , {"name": "V", "description": "Type of value of the component"}]
 *               },
 *               {
 *                target: "Type",
 *                value: "ojSelectOneSettableProperties<K, D, V= any> extends ojSelectSettableProperties<V>",
 *                for: "SettableProperties"
 *               }
 *              ]
 * @ojtsimport {module: "ojdataprovider", type: "AMD", imported: ["DataProvider"]}
 * @ojtsimport {module: "ojvalidationfactory-base", type: "AMD", imported:["Validation"]}
 * @ojtsimport {module: "ojconverter", type: "AMD", importName: "Converter"}
 * @ojtsimport {module: "ojvalidator", type: "AMD", importName: "Validator"}
 * @ojtsimport {module: "ojvalidator-async", type: "AMD", importName: "AsyncValidator"}
 *
 * @ojpropertylayout {propertyGroup: "common", items: ["labelHint", "placeholder", "required", "disabled"]}
 * @ojpropertylayout {propertyGroup: "data", items: ["value", "options"]}
 * @ojvbdefaultcolumns 6
 * @ojvbmincolumns 2
 *
 * @classdesc
 * <h3 id="selectOverview-section">
 *   JET Select One
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#selectOverview-section"></a>
 * </h3>
 * <p>Description: JET Select One provides support for single-select and search filtering.</p>
 *
 * <p>A JET Select One can be created with the following markup.</p>
 *
 * <pre class="prettyprint">
 * <code>
 * &lt;oj-select-one>
 *   &lt;oj-option value="option 1">option 1&lt;/oj-option>
 *   &lt;oj-option value="option 2">option 2&lt;/oj-option>
 *   &lt;oj-option value="option 3">option 3&lt;/oj-option>
 *   &lt;oj-option value="option 4">option 4&lt;/oj-option>
 * &lt;/oj-select-one>
 * </code></pre>
 *
 * {@ojinclude "name":"validationAndMessagingDoc"}
 *
 * <h3 id="touch-section">
 *   Touch End User Information
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
 * </h3>
 *
 * {@ojinclude "name":"touchDocOne"}
 *
 * <h3 id="keyboard-section">
 *   Keyboard End User Information
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 *
 * {@ojinclude "name":"keyboardDocOne"}
 *
 * <h3 id="perf-section">
 *   Performance
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#perf-section"></a>
 * </h3>
 *
 * <h4>Page Load</h4>
 * <p>If the <a href="#options">options</a> attribute is a data provider, and if there is an initially selected value, setting the <a href="#valueOption">valueOption</a> attribute initially can improve page load performance because the element will not have to fetch the selected label from the data provider.</p>
 * <p>When using a data provider and renderMode is 'jet', the dropdown data isn't fetched until the user opens the dropdown.</p>
 *
 * {@ojinclude "name":"selectCommon"}
 */
// --------------------------------------------------- oj.ojSelectOne Styling Start ------------------------------------------------------------

/**
 * @classdesc The following CSS classes can be applied by the page author as needed.<br/>
 * The form control style classes can be applied to the component, or an ancestor element. <br/>
 * When applied to an ancestor element, all form components that support the style classes will be affected.
 */
// ---------------- oj-form-control-full-width --------------

/**
* Changes the max-width to 100% so that form components will occupy all the available horizontal space.
* @ojstyleclass oj-form-control-full-width
* @ojdisplayname FullWidth
* @memberof oj.ojSelectOne
* @ojtsexample
* &lt;oj-select-one class="oj-form-control-full-width">
*   &lt;oj-option value="option 1">option 1&lt;/oj-option>
*   &lt;oj-option value="option 2">option 2&lt;/oj-option>
*   &lt;oj-option value="option 3">option 3&lt;/oj-option>
*   &lt;oj-option value="option 4">option 4&lt;/oj-option>
* &lt;/oj-select-one>
*/
// ---------------- oj-form-control max-width --------------

/**
* In the Redwood theme the default max width of a text field is 100%.
* These max width convenience classes are available to create a medium or small field.<br>
* The class is applied to the root element.
* @ojstyleset form-control-max-width
* @ojdisplayname Max Width
* @ojstylesetitems ["form-control-max-width.oj-form-control-max-width-sm", "form-control-max-width.oj-form-control-max-width-md"]
* @ojstylerelation exclusive
* @memberof oj.ojSelectOne
* @ojtsexample
* &lt;oj-select-one class="oj-form-control-max-width-md">
*   &lt;oj-option value="option 1">option 1&lt;/oj-option>
*   &lt;oj-option value="option 2">option 2&lt;/oj-option>
*   &lt;oj-option value="option 3">option 3&lt;/oj-option>
* &lt;/oj-select-one>
*/

/**
* @ojstyleclass form-control-max-width.oj-form-control-max-width-sm
* @ojshortdesc Sets the max width for a small field
* @ojdisplayname Small
* @memberof! oj.ojSelectOne
 */

/**
* @ojstyleclass form-control-max-width.oj-form-control-max-width-md
* @ojshortdesc Sets the max width for a medium field
* @ojdisplayname Medium
* @memberof! oj.ojSelectOne
 */
// ---------------- oj-form-control width --------------

/**
* In the Redwood theme the default width of a text field is 100%.
* These width convenience classes are available to create a medium or small field.<br>
* The class is applied to the root element.
* @ojstyleset form-control-width
* @ojdisplayname Width
* @ojstylesetitems ["form-control-width.oj-form-control-width-sm", "form-control-width.oj-form-control-width-md"]
* @ojstylerelation exclusive
* @memberof oj.ojSelectOne
* @ojtsexample
* &lt;oj-select-one class="oj-form-control-width-md">
*   &lt;oj-option value="option 1">option 1&lt;/oj-option>
*   &lt;oj-option value="option 2">option 2&lt;/oj-option>
*   &lt;oj-option value="option 3">option 3&lt;/oj-option>
* &lt;/oj-select-one>
*/

/**
* @ojstyleclass form-control-width.oj-form-control-width-sm
* @ojshortdesc Sets the width for a small field
* @ojdisplayname Small
* @memberof! oj.ojSelectOne
 */

/**
* @ojstyleclass form-control-width.oj-form-control-width-md
* @ojshortdesc Sets the width for a medium field
* @ojdisplayname Medium
* @memberof! oj.ojSelectOne
 */
// ---------------- oj-form-control-text-align- --------------

/**
 * Classes that help align text of the element.
 * @ojstyleset text-align
 * @ojdisplayname Text Alignment
 * @ojstylesetitems ["text-align.oj-form-control-text-align-right", "text-align.oj-form-control-text-align-start", "text-align.oj-form-control-text-align-end"]
 * @ojstylerelation exclusive
 * @memberof oj.ojSelectOne
 * @ojtsexample
 * &lt;oj-select-one class="oj-form-control-text-align-right">
 *   &lt;oj-option value="option 1">option 1&lt;/oj-option>
 *   &lt;oj-option value="option 2">option 2&lt;/oj-option>
 *   &lt;oj-option value="option 3">option 3&lt;/oj-option>
 *   &lt;oj-option value="option 4">option 4&lt;/oj-option>
 * &lt;/oj-select-one>
 */

/**
 * @ojstyleclass text-align.oj-form-control-text-align-right
 * @ojshortdesc Aligns the text to the right regardless of the reading direction. This is normally used for right aligning numbers.
 * @ojdisplayname Align-Right
 * @memberof! oj.ojSelectOne
 */

/**
 * @ojstyleclass text-align.oj-form-control-text-align-start
 * @ojshortdesc Aligns the text to the left in LTR and to the right in RTL.
 * @ojdisplayname Align-Start
 * @memberof! oj.ojSelectOne
 */

/**
 * @ojstyleclass text-align.oj-form-control-text-align-end
 * @ojshortdesc Aligns the text to the right in LTR and to the left in RTL.
 * @ojdisplayname Align-End
 * @memberof! oj.ojSelectOne
 */
// --------------------------------------------------- oj.ojSelectOne Styling end ------------------------------------------------------------

/**
 * @ojcomponent oj.ojSelectMany
 * @augments oj.ojSelect
 * @since 0.6.0
 * @ojdisplayname Select (Many)
 * @ojshortdesc A select many is a dropdown list that supports multiple selections and search filtering.
 * @ojrole combobox
 * @ojsignature [{
 *                target: "Type",
 *                value: "class ojSelectMany<K, D, V=any> extends ojSelect<Array<V>, ojSelectManySettableProperties<K, D, V>>",
 *                genericParameters: [{"name": "K", "description": "Type of key of the dataprovider"}, {"name": "D", "description": "Type of data from the dataprovider"}
 *                , {"name": "V", "description": "Type of each item in the value of the component"}]
 *               },
 *               {
 *                target: "Type",
 *                value: "ojSelectManySettableProperties<K, D, V=Array<any>> extends ojSelectSettableProperties<Array<V>>",
 *                for: "SettableProperties"
 *               }
 *              ]
 *
 * @ojpropertylayout {propertyGroup: "common", items: ["labelHint", "placeholder", "required", "disabled"]}
 * @ojpropertylayout {propertyGroup: "data", items: ["value", "options"]}
 * @ojvbdefaultcolumns 6
 * @ojvbmincolumns 2
 *
 * @classdesc
 * <h3 id="selectOverview-section">
 *   JET Select Many
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#selectOverview-section"></a>
 * </h3>
 * <p>Description: JET Select Many provides support for multi-select and search filtering.</p>
 *
 * <p>A JET Select Many can be created with the following markup.</p>
 *
 * <pre class="prettyprint">
 * <code>
 * &lt;oj-select-many>
 *   &lt;oj-option value="option 1">option 1&lt;/oj-option>
 *   &lt;oj-option value="option 2">option 2&lt;/oj-option>
 *   &lt;oj-option value="option 3">option 3&lt;/oj-option>
 *   &lt;oj-option value="option 4">option 4&lt;/oj-option>
 * &lt;/oj-select-many>
 * </code></pre>
 *
 * {@ojinclude "name":"validationAndMessagingDoc"}
 *
 * <h3 id="touch-section">
 *   Touch End User Information
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
 * </h3>
 *
 * {@ojinclude "name":"touchDocMany"}
 *
 * <h3 id="keyboard-section">
 *   Keyboard End User Information
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 *
 * {@ojinclude "name":"keyboardDocMany"}
 *
 * <h3 id="perf-section">
 *   Performance
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#perf-section"></a>
 * </h3>
 *
 * <h4>Page Load</h4>
 * <p>If the <a href="#options">options</a> attribute is a data provider, and if there are initially selected values, setting the <a href="#valueOptions">valueOptions</a> attribute initially can improve page load performance because the element will not have to fetch the selected labels from the data provider.</p>
 * <p>When using a data provider and renderMode is 'jet', the dropdown data isn't fetched until the user opens the dropdown.</p>
 *
 *
 * {@ojinclude "name":"selectCommon"}
 */
// --------------------------------------------------- oj.ojSelectMany Styling Start ------------------------------------------------------------

/**
 * @classdesc The following CSS classes can be applied by the page author as needed.<br/>
 * The form control style classes can be applied to the component, or an ancestor element. <br/>
 * When applied to an ancestor element, all form components that support the style classes will be affected.
 */
// ---------------- oj-form-control-full-width --------------

/**
* Changes the max-width to 100% so that form components will occupy all the available horizontal space.
* @ojstyleclass oj-form-control-full-width
* @ojdisplayname Full Width
* @memberof oj.ojSelectMany
* @ojtsexample
* &lt;oj-select-many class="oj-form-control-full-width">
*   &lt;oj-option value="option 1">option 1&lt;/oj-option>
*   &lt;oj-option value="option 2">option 2&lt;/oj-option>
*   &lt;oj-option value="option 3">option 3&lt;/oj-option>
*   &lt;oj-option value="option 4">option 4&lt;/oj-option>
* &lt;/oj-select-many>
*/
// ---------------- oj-form-control max-width --------------

/**
* In the Redwood theme the default max width of a text field is 100%.
* These max width convenience classes are available to create a medium or small field.<br>
* The class is applied to the root element.
* @ojstyleset form-control-max-width
* @ojdisplayname Max Width
* @ojstylesetitems ["form-control-max-width.oj-form-control-max-width-sm", "form-control-max-width.oj-form-control-max-width-md"]
* @ojstylerelation exclusive
* @memberof oj.ojSelectMany
* @ojtsexample
* &lt;oj-select-many class="oj-form-control-max-width-md">
*   &lt;oj-option value="option 1">option 1&lt;/oj-option>
*   &lt;oj-option value="option 2">option 2&lt;/oj-option>
*   &lt;oj-option value="option 3">option 3&lt;/oj-option>
* &lt;/oj-select-many>
*/

/**
* @ojstyleclass form-control-max-width.oj-form-control-max-width-sm
* @ojshortdesc Sets the max width for a small field
* @ojdisplayname Small
* @memberof! oj.ojSelectMany
 */

/**
* @ojstyleclass form-control-max-width.oj-form-control-max-width-md
* @ojshortdesc Sets the max width for a medium field
* @ojdisplayname Medium
* @memberof! oj.ojSelectMany
 */
// ---------------- oj-form-control width --------------

/**
* In the Redwood theme the default width of a text field is 100%.
* These width convenience classes are available to create a medium or small field.<br>
* The class is applied to the root element.
* @ojstyleset form-control-width
* @ojdisplayname Width
* @ojstylesetitems ["form-control-width.oj-form-control-width-sm", "form-control-width.oj-form-control-width-md"]
* @ojstylerelation exclusive
* @memberof oj.ojSelectMany
* @ojtsexample
* &lt;oj-select-many class="oj-form-control-width-md">
*   &lt;oj-option value="option 1">option 1&lt;/oj-option>
*   &lt;oj-option value="option 2">option 2&lt;/oj-option>
*   &lt;oj-option value="option 3">option 3&lt;/oj-option>
* &lt;/oj-select-many>
*/

/**
* @ojstyleclass form-control-width.oj-form-control-width-sm
* @ojshortdesc Sets the width for a small field
* @ojdisplayname Small
* @memberof! oj.ojSelectMany
 */

/**
* @ojstyleclass form-control-width.oj-form-control-width-md
* @ojshortdesc Sets the width for a medium field
* @ojdisplayname Medium
* @memberof! oj.ojSelectMany
 */
// ---------------- oj-form-control-text-align- --------------

/**
 * Classes that help align text of the element.
 * @ojstyleset text-align
 * @ojdisplayname Text Alignment
 * @ojstylesetitems ["text-align.oj-form-control-text-align-right", "text-align.oj-form-control-text-align-start", "text-align.oj-form-control-text-align-end"]
 * @ojstylerelation exclusive
 * @memberof oj.ojSelectMany
 * @ojtsexample
 * &lt;oj-select-many class="oj-form-control-text-align-right">
 *   &lt;oj-option value="option 1">option 1&lt;/oj-option>
 *   &lt;oj-option value="option 2">option 2&lt;/oj-option>
 *   &lt;oj-option value="option 3">option 3&lt;/oj-option>
 *   &lt;oj-option value="option 4">option 4&lt;/oj-option>
 * &lt;/oj-select-many>
 */

/**
 * @ojstyleclass text-align.oj-form-control-text-align-right
 * @ojshortdesc Aligns the text to the right regardless of the reading direction. This is normally used for right aligning numbers.
 * @ojdisplayname Align-Right
 * @memberof! oj.ojSelectMany
 */

/**
 * @ojstyleclass text-align.oj-form-control-text-align-start
 * @ojshortdesc Aligns the text to the left in LTR and to the right in RTL.
 * @ojdisplayname Align-Start
 * @memberof! oj.ojSelectMany
 */

/**
 * @ojstyleclass text-align.oj-form-control-text-align-end
 * @ojshortdesc Aligns the text to the right in LTR and to the left in RTL.
 * @ojdisplayname Align-End
 * @memberof! oj.ojSelectMany
 */
// --------------------------------------------------- oj.ojSelectMany Styling end ------------------------------------------------------------

/**
 * @ojcomponent oj.ojSelect
 * @augments oj.editableValue
 * @ojimportmembers oj.ojDisplayOptions
 * @since 0.6.0
 * @abstract
 * @ojsignature [{
 *                target: "Type",
 *                value: "abstract class ojSelect<V, SP extends ojSelectSettableProperties<V, SV>, SV=V> extends editableValue<V, SP, SV>"
 *               },
 *               {
 *                target: "Type",
 *                value: "ojSelectSettableProperties<V, SV=V> extends editableValueSettableProperties<V, SV>",
 *                for: "SettableProperties"
 *               }
 *              ]
 *
 * @hideconstructor
 * @classdesc
 */

/**
 * <h3 id="rtl-section">
 *   Reading direction
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
 * </h3>
 *
 * <p>As with any JET element, in the unusual case that the directionality (LTR or RTL) changes post-init, the Select must be <code class="prettyprint">refresh()</code>ed.
 *
 * <h3 id="a11y-section">
 *   Accessibility
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
 * </h3>
 * <p>
 * It is up to the application developer to associate an oj-label to the select element.
 * You should put an <code>id</code> on the select element, and then set
 * the <code>for</code> attribute on the oj-label to be the select's id.
 * </p>
 * <p>
 * The element will decorate its associated label with required and help
 * information, if the <code>required</code> and <code>help</code> attributes are set.
 * </p>
 *
 * @ojfragment selectCommon
 * @memberof oj.ojSelect
 */
oj.__registerWidget('oj.ojSelect', $.oj.editableValue, {
  defaultElement: '<select>',
  widgetEventPrefix: 'oj',
  options: {
    /**
     * <p>
     * The oj-label sets the labelledBy property programmatically on the form component
     * to make it easy for the form component to find its oj-label component (a
     * document.getElementById call.)
     * </p>
     * <p>
     * The application developer should use the 'for'/'id api
     * to link the oj-label with the form component;
     * the 'for' on the oj-label to point to the 'id' on the input form component.
     * This is the most performant way for the oj-label to find its form component.
     * </p>
     *
     * @example <caption>Initialize component with <code class="prettyprint">for</code> attribute:</caption>
     * &lt;oj-label for="selectOneId">Name:&lt;/oj-label>
     * &lt;oj-select-one id="selectOneId">
     * &lt;/oj-select-one>
     * // ojLabel then writes the labelled-by attribute on the oj-switch.
     * &lt;oj-label id="labelId" for="selectOneId">Name:&lt;/oj-label>
     * &lt;oj-select-one id="selectOneId" labelled-by"labelId">
     * &lt;/oj-select-one>
     *
     * @example <caption>Get or set the <code class="prettyprint">labelledBy</code> property after initialization:</caption>
     * // getter
     * var labelledBy = myComp.labelledBy;
     *
     * // setter
     * myComp.labelledBy = "labelId";
     *
     * @expose
     * @name labelledBy
     * @ojshortdesc The oj-label sets the labelledBy property
     * programmatically on the form component.
     * @type {string|null}
     * @public
     * @instance
     * @since 7.0.0
     * @memberof oj.ojSelectOne
     */

    /**
      * <p>
      * The oj-label sets the labelledBy property programmatically on the form component
      * to make it easy for the form component to find its oj-label component (a
      * document.getElementById call.)
      * </p>
      * <p>
      * The application developer should use the 'for'/'id api
      * to link the oj-label with the form component;
      * the 'for' on the oj-label to point to the 'id' on the input form component.
      * This is the most performant way for the oj-label to find its form component.
      * </p>
      *
      * @example <caption>Initialize component with <code class="prettyprint">for</code> attribute:</caption>
      * &lt;oj-label for="selectManyId">Name:&lt;/oj-label>
      * &lt;oj-select-many id="selectManyId">
      * &lt;/oj-select-many>
      * // ojLabel then writes the labelled-by attribute on the oj-switch.
      * &lt;oj-label id="labelId" for="selectManyId">Name:&lt;/oj-label>
      * &lt;oj-select-many id="selectManyId" labelled-by"labelId">
      * &lt;/oj-select-many>
      *
      * @example <caption>Get or set the <code class="prettyprint">labelledBy</code> property after initialization:</caption>
      * // getter
      * var labelledBy = myComp.labelledBy;
      *
      * // setter
      * myComp.labelledBy = "labelId";
      *
      * @expose
      * @name labelledBy
      * @ojshortdesc The oj-label sets the labelledBy property
      * programmatically on the form component.
      * @type {string|null}
      * @public
      * @instance
      * @since 7.0.0
      * @memberof oj.ojSelectMany
      */

    /**
      * <p>
      * The oj-label sets the labelledBy property programmatically on the form component
      * to make it easy for the form component to find its oj-label component (a
      * document.getElementById call.)
      * </p>
      * <p>
      * The application developer should use the 'for'/'id api
      * to link the oj-label with the form component;
      * the 'for' on the oj-label to point to the 'id' on the input form component.
      * This is the most performant way for the oj-label to find its form component.
      * </p>
      *
      *
      * // setter
      * myComp.labelledBy = "labelId";
      *
      * @expose
      * @ojshortdesc The oj-label sets the labelledBy property
      * programmatically on the form component.
      * @type {string|null}
      * @default null
      * @public
      * @instance
      * @since 7.0.0
      * @memberof oj.ojSelect
      */
    labelledBy: null,

    /**
     * {@ojinclude "name":"selectCommonMaximumResultCount"}
     *
     * @example <caption>Initialize the select with the <code class="prettyprint">maximum-result-count</code> attribute specified:</caption>
     * &lt;oj-select-one maximum-result-count="25">&lt;/oj-select-one>
     *
     * @example <caption>Get or set the <code class="prettyprint">maximumResultCount</code> property after initialization:</caption>
     * // getter
     * var maximumResultCount = mySelect.maximumResultCount;
     *
     * // setter
     * mySelect.maximumResultCount = 25;
     *
     * @name maximumResultCount
     * @ojshortdesc The maximum number of results displayed in the dropdown.
     * @expose
     * @memberof oj.ojSelectOne
     * @since 8.0.0
     * @instance
     * @type {number}
     * @default 15
     */

    /**
     * {@ojinclude "name":"selectCommonMaximumResultCount"}
     *
     * @example <caption>Initialize the select with the <code class="prettyprint">maximum-result-count</code> attribute specified:</caption>
     * &lt;oj-select-many maximum-result-count="25">&lt;/oj-select-many>
     *
     * @example <caption>Get or set the <code class="prettyprint">maximumResultCount</code> property after initialization:</caption>
     * // getter
     * var maximumResultCount = mySelect.maximumResultCount;
     *
     * // setter
     * mySelect.maximumResultCount = 25;
     *
     * @name maximumResultCount
     * @ojshortdesc The maximum number of results displayed in the dropdown.
     * @expose
     * @memberof oj.ojSelectMany
     * @since 8.0.0
     * @instance
     * @type {number}
     * @default 15
     */

    /**
     * <p>The maximum number of results that will be displayed in the dropdown when the options attribute is bound to a data provider.</p>
     *
     * <p>If more than the maximum number of results are available from data provider then user needs to filter further.
     * A value less than 1 indicates there is no maximum limit and all the results will be fetched and displayed in the dropdown.</p>
     *
     * <p>When the options attribute is bound to a hierarchical data source like a <a href="oj.TreeDataProvider.html">oj.TreeDataProvider</a>,
     * this attribute represents the maximum number of leaf results that will be displayed in the dropdown.</p>
     *
     * <p>Note: This attribute has no effect when the options attribute is bound to an array/observable array or
     * when the component renders an oj-option element or an oj-optgroup element as children.</p>
     *
     * @expose
     * @memberof oj.ojSelect
     * @instance
     * @ojfragment selectCommonMaximumResultCount
     */
    maximumResultCount: 15,

    /**
     * {@ojinclude "name":"selectCommonMinimumResultsForSearch"}
     *
     * @example <caption>Initialize the select with the <code class="prettyprint">minimum-results-for-search</code> attribute specified:</caption>
     * &lt;oj-select-one minimum-results-for-search="10">&lt;/oj-select-one>
     *
     * @example <caption>Get or set the <code class="prettyprint">minimumResultsForSearch</code> property after initialization:</caption>
     * // getter
     * var minimumResultsForSearch = mySelect.minimumResultsForSearch;
     *
     * // setter
     * mySelect.minimumResultsForSearch = 10;
     *
     * @name minimumResultsForSearch
     * @ojshortdesc The threshold for showing the search box in the dropdown.
     * @expose
     * @memberof oj.ojSelectOne
     * @instance
     * @type {number}
     * @default 15
     * @ojmin 0
     */

    /**
     * {@ojinclude "name":"selectCommonMinimumResultsForSearch"}
     *
     * @example <caption>Initialize the select with the <code class="prettyprint">minimum-results-for-search</code> attribute specified:</caption>
     * &lt;oj-select-many minimum-results-for-search="10">&lt;/oj-select-many>
     *
     * @example <caption>Get or set the <code class="prettyprint">minimumResultsForSearch</code> property after initialization:</caption>
     * // getter
     * var minimumResultsForSearch = mySelect.minimumResultsForSearch;
     *
     * // setter
     * mySelect.minimumResultsForSearch = 10;
     *
     * @name minimumResultsForSearch
     * @ojshortdesc The threshold for showing the search box in the dropdown.
     * @expose
     * @memberof oj.ojSelectMany
     * @instance
     * @type {number}
     * @default 15
     * @ojmin 0
     */

    /**
     * The threshold for showing the search box in the dropdown when it's expanded.
     * The search box is always displayed when the results size is greater than
     * the threshold, otherwise the search box is initially turned off.
     * However, the search box is displayed as soon as the user starts typing.
     *
     * @ojshortdesc The threshold for showing the search box in the dropdown.
     * @expose
     * @memberof oj.ojSelect
     * @instance
     * @ojfragment selectCommonMinimumResultsForSearch
     */
    minimumResultsForSearch: 15,

    /**
     * The placeholder text to set on the element.<p>
     * If the <code class="prettyprint">placeholder</code> attribute is specified to a string, ojselect will adds a placeholder item at the beginning of the dropdown list with
     *  <ul>
     *  <li>displayValue: placeholder text</li>
     *  <li>value: an empty string</li>
     *  </ul>
     * The placeholder item in the dropdown is selectable. However, it's not a valid choice, i.e. validation will fail if the select element is a required field.<p>
     * The placeholder item doesn't participate in the filtering, so it will not appear in the result list with a filter specified.<p>
     * Placeholder text can be an empty string, please see the select placeholder cookbook demo.
     *
     * @example <caption>Initialize the select with the <code class="prettyprint">placeholder</code> attribute specified:</caption>
     * &lt;oj-select-one placeholder="Please select ...">&lt;/oj-select-one>
     *
     * @example <caption>Get or set the <code class="prettyprint">placeholder</code> property after initialization:</caption>
     * // getter
     * var placeholderValue = mySelect.placeholder;
     *
     * // setter
     * mySelect.placeholder = "Select a value";
     *
     * @name placeholder
     * @ojshortdesc A short hint that can be displayed before user selects a value.
     * @expose
     * @access public
     * @instance
     * @memberof oj.ojSelectOne
     * @type {string|null}
     * @default null
     * @ojtranslatable
     */

    /**
     * The placeholder text to set on the element. The placeholder specifies a short hint that can be displayed before user
     * selects a value.
     *
     * @example <caption>Initialize the select with the <code class="prettyprint">placeholder</code> attribute specified:</caption>
     * &lt;oj-select-many placeholder="Please select ...">&lt;/oj-select-many>
     *
     * @example <caption>Get or set the <code class="prettyprint">placeholder</code> property after initialization:</caption>
     * // getter
     * var placeholderValue = mySelect.placeholder;
     *
     * // setter
     * mySelect.placeholder = "Select values";
     *
     * @name placeholder
     * @ojshortdesc A short hint that can be displayed before user selects a value.
     * @expose
     * @access public
     * @instance
     * @memberof oj.ojSelectMany
     * @type {string|null}
     * @default null
     * @ojtranslatable
     */
    placeholder: null,

    /**
     * @typedef {Object} oj.ojSelect.OptionContext
     * @property {Element} componentElement A reference to the Select element.
     * @property {?Element} parent The parent of the data item. The parent is null for root node.
     * @property {number} index The index of the option, where 0 is the index of the first option. In the hierarchical case the index is relative to its parent.
     * @property {number } depth The depth of the option. The depth of the first level children under the invisible root is 0.
     * @property {boolean} leaf Whether the option is a leaf or a group.
     * @property {Object} data The data object for the option.
     * @property {Element} parentElement The option label element. The renderer can use this to directly append content.
     */

    /**
     * {@ojinclude "name":"selectCommonOptionRenderer"}
     * @name optionRenderer
     * @ojshortdesc The renderer function that renders the content of each option.
     * @expose
     * @memberof oj.ojSelectOne
     * @instance
     * @type {null|function(Object):Object}
     * @ojsignature { target: "Type",
     *                value: "?((param0: oj.ojSelect.OptionContext) => Element)|null",
     *                jsdocOverride: true}
     * @default null
     * @example <caption>Initialize the select with a renderer:</caption>
     * &lt;oj-select-one option-renderer="[[optionRenderer]]">&lt;/oj-select-one>
     * @example var optionRenderer = function(context) {
     *            var ojOption = document.createElement('oj-option');
     *            // Set the textContent or append other child nodes
     *            ojOption.textContent = context.data['FIRST_NAME'] + ' ' + context.data['LAST_NAME'];
     *            return ojOption;
     *          };
     */

    /**
     * {@ojinclude "name":"selectCommonOptionRenderer"}
     * @name optionRenderer
     * @ojshortdesc The renderer function that renders the content of each option.
     * @expose
     * @memberof oj.ojSelectMany
     * @instance
     * @type {null|function(Object):Object}
     * @ojsignature { target: "Type",
     *                value: "?((param0: oj.ojSelect.OptionContext) => Element)|null",
     *                jsdocOverride: true}
     * @default null
     * @example <caption>Initialize the Select with a renderer:</caption>
     * &lt;oj-select-many option-renderer="[[optionRenderer]]">&lt;/oj-select-many>
     * @example var optionRenderer = function(context) {
     *            var ojOption = document.createElement('oj-option');
     *            // Set the textContent or append other child nodes
     *            ojOption.textContent = context.data['FIRST_NAME'] + ' ' + context.data['LAST_NAME'];
     *            return ojOption;
     *          };
     */

    /**
     * The renderer function that renders the content of each option.
     * The function should return an oj-option element (for leaf option) or an oj-optgroup element (for group option).
     * <p>It is not necessary to set the "value" attribute on the oj-option as it is available from the options data.</p>
     * <p><b>
     * Note: Prior to version 6.1.0, the function could also return one of the following:
     * <ul>
     *   <li>An Object with the following property:
     *     <ul><li>insert: HTMLElement - A DOM element representing the content of the option.</li></ul>
     *   </li>
     *   <li>undefined: If the developer chooses to manipulate the option content directly, the function should return undefined.</li>
     * </ul>
     * This is deprecated and support may be removed in the future.
     * </b></p>
     *
     * <p>The <code class="prettyprint">option-renderer</code> decides only
     * how the options' content has to be rendered in the drop down.
     * Once an option is selected from the drop down,
     * what value has to be displayed in the in input field is decided by the
     * label field in the data object. See <a href="#options">options</a>
     * and <a href="#optionsKeys">options-keys</a> for configuring option label and value.
     * </p>
     *
     * <p>The context parameter passed to the renderer contains the following keys:</p>
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Key</th>
     *       <th>Description</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td><kbd>componentElement</kbd></td>
     *       <td>A reference to the Select element.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>parent</kbd></td>
     *       <td>The parent of the data item. The parent is null for root node.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>index</kbd></td>
     *       <td>The index of the option, where 0 is the index of the first option. In the hierarchical case the index is relative to its parent.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>depth</kbd></td>
     *       <td>The depth of the option. The depth of the first level children under the invisible root is 0.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>leaf</kbd></td>
     *       <td>Whether the option is a leaf or a group.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>data</kbd></td>
     *       <td>The data object for the option.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>parentElement</kbd></td>
     *       <td>The option label element.  The renderer can use this to directly append content.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * @expose
     * @memberof oj.ojSelect
     * @instance
     * @ojfragment selectCommonOptionRenderer
     */
    optionRenderer: null,

    /**
     * @typedef {Object} oj.ojSelect.Option
     * @property {boolean=} disabled Option item is disabled.
     * @property {string=} label The display label for the option item. If it's missing, string(value) will be used.
     * @property {any} value The value of the option item.
     */

    /**
     * @typedef {Object} oj.ojSelect.Optgroup
     * @property {boolean=} disabled Option group is disabled.
     * @property {string} label The display label for the option group.
     * @property {Array.<oj.ojSelect.Option|oj.ojSelect.Optgroup>} children The Option or Optgroup children.
     */

    /**
     * {@ojinclude "name":"selectCommonOptions"}
     *
     * @name options
     * @ojshortdesc The option items for the Select.
     * @expose
     * @access public
     * @instance
     * @type {Array.<Object>|Object|null}
     * @ojsignature { target: "Type",
     *                value: "Array<oj.ojSelect.Option|oj.ojSelect.Optgroup>|oj.DataProvider<K, D>|null",
     *                jsdocOverride: true}
     * @default null
     * @memberof oj.ojSelectOne
     *
     * @example <caption>Initialize the Select with the <code class="prettyprint">options</code> attribute specified:</caption>
     * &lt;oj-select-one options="[[dataArray]]">&lt;/oj-select-one>
     *
     * @example <caption>The options array should contain objects with value and label properties:</caption>
     * var dataArray = [{value: 'option1', label: 'Option 1'},
     *                  {value: 'option2', label: 'Option 2', disabled: true},
     *                  {value: 'option3', label: 'Option 3'}];
     *
     * @example <caption>Initialize the Select with a data provider and data mapping:</caption>
     * &lt;oj-select-one options="[[dataProvider]]">&lt;/oj-select-one>
     *
     * @example <caption>Data mapping can be used if data doesn't have value and label properties.</caption>
     * // actual field names are "id" and "name"
     * var dataArray = [
     *            {id: 'Id 1', name: 'Name 1'},
     *            {id: 'Id 2', name: 'Name 2'},
     *            {id: 'Id 3', name: 'Name 3'}];
     *
     * // In mapfields, map "name" to "label" and "id" to "value"
     * var mapFields = function(item) {
     *   var data = item['data'];
     *   var mappedItem = {};
     *   mappedItem['data'] = {};
     *   mappedItem['data']['label'] = data['name'];
     *   mappedItem['data']['value'] = data['id'];
     *   mappedItem['metadata'] = {'key': data['id']};
     *   return mappedItem;
     * };
     * var dataMapping = {'mapFields': mapFields};
     *
     * var arrayDataProvider = new oj.ArrayDataProvider(dataArray, {keyAttributes: 'id'});
     * var dataProvider = new oj.ListDataProviderView(arrayDataProvider, {'dataMapping': dataMapping});
     */

    /**
     * {@ojinclude "name":"selectCommonOptions"}
     *
     * @name options
     * @ojshortdesc The option items for the Select.
     * @expose
     * @access public
     * @instance
     * @type {Array.<Object>|Object|null}
     * @ojsignature { target: "Type",
     *                value: "Array<oj.ojSelect.Option|oj.ojSelect.Optgroup>|oj.DataProvider<K, D>|null",
     *                jsdocOverride: true}
     * @default null
     * @memberof oj.ojSelectMany
     *
     * @example <caption>Initialize the Select with the <code class="prettyprint">options</code> attribute specified:</caption>
     * &lt;oj-select-many options="[[dataArray]]">&lt;/oj-select-many>
     *
     * @example <caption>The options array should contain objects with value and label properties:</caption>
     * var dataArray = [{value: 'option1', label: 'Option 1'},
     *                  {value: 'option2', label: 'Option 2', disabled: true},
     *                  {value: 'option3', label: 'Option 3'}];
     *
     * @example <caption>Initialize the Select with a data provider and data mapping:</caption>
     * &lt;oj-select-many options="[[dataProvider]]">&lt;/oj-select-many>
     *
     * @example <caption>Data mapping can be used if data doesn't have value and label properties.</caption>
     * // actual field names are "id" and "name"
     * var dataArray = [
     *            {id: 'Id 1', name: 'Name 1'},
     *            {id: 'Id 2', name: 'Name 2'},
     *            {id: 'Id 3', name: 'Name 3'}];
     *
     * // In mapfields, map "name" to "label" and "id" to "value"
     * var mapFields = function(item) {
     *   var data = item['data'];
     *   var mappedItem = {};
     *   mappedItem['data'] = {};
     *   mappedItem['data']['label'] = data['name'];
     *   mappedItem['data']['value'] = data['id'];
     *   mappedItem['metadata'] = {'key': data['id']};
     *   return mappedItem;
     * };
     * var dataMapping = {'mapFields': mapFields};
     *
     * var arrayDataProvider = new oj.ArrayDataProvider(dataArray, {keyAttributes: 'id'});
     * var dataProvider = new oj.ListDataProviderView(arrayDataProvider, {'dataMapping': dataMapping});
     */

    /**
     * The option items for the Select. This attribute can be used instead of providing a list of <code class="prettyprint">oj-option</code> or <code class="prettyprint">oj-optgroup</code> child elements of the Select element.
     * This attribute accepts:
     * <ol>
     * <li>an array of <code class="prettyprint">oj.ojSelect.Option</code> and/or <code class="prettyprint">oj.ojSelect.Optgroup</code>.
     *   <ul>
     *   <li>Use <code class="prettyprint">oj.ojSelect.Option</code> for a leaf option.</li>
     *   <li>Use <code class="prettyprint">oj.ojSelect.Optgroup</code> for a group option.</li>
     *   </ul>
     * </li>
     * <li>a data provider. This data provider must implement <a href="oj.DataProvider.html">oj.DataProvider</a>.
     *   <ul>
     *   <li><code class="prettyprint">value</code> in <code class="prettyprint">oj.ojSelect.Option</code> must be the row key in the data provider.</li>
     *   <li>A maximum of 15 rows will be displayed in the dropdown. If more than 15 results are available then users need to filter further. Please note that users can't filter further if render-mode is <code class="prettyprint">native</code>.</li>
     *   <li>If the data provider supports the filter criteria capability including the contains (<code class="prettyprint">$co or $regex</code>) operator, JET Select will request the data provider to do filtering. Otherwise it will filter internally.</li>
     *   <li>See also <a href="#perf-section">Improve page load performance</a></li>
     *   </ul>
     * </li>
     * </ol>
     *
     * @expose
     * @memberof oj.ojSelect
     * @instance
     * @ojfragment selectCommonOptions
     */
    options: null,

    /**
     * @typedef {Object} oj.ojSelect.OptionsKeys
     * @property {?string=} label The key name for the label.
     * @property {?string=} value The key name for the value.
     * @property {?string=} children The key name for the children.
     * @property {?Object=} childKeys The object for the child keys.
     * @ojsignature {target:"Type", value:"?(oj.ojSelect.OptionsKeys)", for:"childKeys", jsdocOverride:true}
     */

    /**
     * {@ojinclude "name":"selectCommonOptionsKeys"}
     *
     * @example <caption>Initialize the Select with <code class="prettyprint">options-keys</code> specified. This allows the key names to be redefined in the options array.</caption>
     * &lt;oj-select-one options-keys="[[optionsKeys]]">&lt;/oj-select-one>
     * @example var optionsKeys = {value : "state_abbr", label : "state_name"};
     * @example <caption>Redefine keys for data with subgroups.</caption>
     * var optionsKeys = {label : "regions", children : "states",
     *                    childKeys : {value : "state_abbr", label : "state_name"}};
     *
     * @name optionsKeys
     * @ojshortdesc Specify the key names to use in the options array.  Depending on options-keys means that the signature of the data does not match what is supported by the options attribute.
     * @expose
     * @access public
     * @instance
     * @type {?Object}
     * @default null
     * @memberof oj.ojSelectOne
     * @ojsignature {target:"Type", value:"oj.ojSelect.OptionsKeys|null", jsdocOverride:true}
     */

    /**
     * {@ojinclude "name":"selectCommonOptionsKeys"}
     *
     * @example <caption>Initialize the Select with <code class="prettyprint">options-keys</code> specified. This allows the key names to be redefined in the options array.</caption>
     * &lt;oj-select-many options-keys="[[optionsKeys]]">&lt;/oj-select-many>
     * @example var optionsKeys = {value : "state_abbr", label : "state_name"};
     * @example <caption>Redefine keys for data with subgroups.</caption>
     * var optionsKeys = {label : "regions", children : "states",
     *                    childKeys : {value : "state_abbr", label : "state_name"}};
     *
     * @name optionsKeys
     * @ojshortdesc Specify the key names to use in the options array.  Depending on options-keys means that the signature of the data does not match what is supported by the options attribute.
     * @expose
     * @access public
     * @instance
     * @type {?Object}
     * @default null
     * @memberof oj.ojSelectMany
     * @ojsignature {target:"Type", value:"oj.ojSelect.OptionsKeys|null", jsdocOverride:true}
     */

    /**
     * Specify the key names to use in the options array.
     * <p>Depending on options-keys means that the signature of the data does not match what is supported by the options attribute. When using Typescript, this would result in a compilation error.</p>
     * <p>Best practice is to use a <a href="oj.ListDataProviderView.html">oj.ListDataProviderView</a> with data mapping as a replacement.</p>
     * <p>However, for the app that must fetch data from a REST endpoint where the data fields do not match those that are supported by the options attribute, you may use the options-keys with any dataProvider that implements <a href="oj.DataProvider.html">oj.DataProvider</a> interface.</p>
     * <p>Note: <code class="prettyprint">child-keys</code> and <code class="prettyprint">children</code> properties in <code class="prettyprint">options-keys</code> are ignored when using a <a href="oj.TreeDataProvider.html">oj.TreeDataProvider</a>.</p>
     *
     * @expose
     * @access public
     * @instance
     * @memberof oj.ojSelect
     * @ojfragment selectCommonOptionsKeys
     */
    optionsKeys: {
      /**
       * The key name for the label.
       *
       * @name optionsKeys.label
       * @expose
       * @public
       * @instance
       * @memberof! oj.ojSelectOne
       * @type {?string}
       * @ojsignature { target: "Type",
       *                value: "?"}
       * @default null
       */

      /**
       * The key name for the label.
       *
       * @name optionsKeys.label
       * @expose
       * @public
       * @instance
       * @memberof! oj.ojSelectMany
       * @type {?string}
       * @ojsignature { target: "Type",
       *                value: "?"}
       * @default null
       */

      /**
       * The key name for the value.
       *
       * @name optionsKeys.value
       * @expose
       * @public
       * @instance
       * @memberof! oj.ojSelectOne
       * @type {?string}
       * @ojsignature { target: "Type",
       *                value: "?"}
       * @default null
       */

      /**
       * The key name for the value.
       *
       * @name optionsKeys.value
       * @expose
       * @public
       * @instance
       * @memberof! oj.ojSelectMany
       * @type {?string}
       * @ojsignature { target: "Type",
       *                value: "?"}
       * @default null
       */

      /**
       * The key name for the children. It is ignored when using a <a href="oj.TreeDataProvider.html">oj.TreeDataProvider</a>.
       *
       * @name optionsKeys.children
       * @ojshortdesc The key name for the children. It is ignored when using a TreeDataProvider.
       * @expose
       * @public
       * @instance
       * @memberof! oj.ojSelectOne
       * @type {?string}
       * @ojsignature { target: "Type",
       *                value: "?"}
       * @default null
       */

      /**
       * The key name for the children. It is ignored when using a <a href="oj.TreeDataProvider.html">oj.TreeDataProvider</a>.
       *
       * @name optionsKeys.children
       * @ojshortdesc The key name for the children. It is ignored when using a TreeDataProvider.
       * @expose
       * @public
       * @instance
       * @memberof! oj.ojSelectMany
       * @type {?string}
       * @ojsignature { target: "Type",
       *                value: "?"}
       * @default null
       */

      /**
       * The object for the child keys. It is ignored when using a <a href="oj.TreeDataProvider.html">oj.TreeDataProvider</a>.
       *
       * @name optionsKeys.childKeys
       * @ojshortdesc The object for the child keys. It is ignored when using a TreeDataProvider.
       * @expose
       * @public
       * @instance
       * @memberof! oj.ojSelectOne
       * @type {?Object}
       * @default null
       * @ojsignature {target:"Type", value:"oj.ojSelect.OptionsKeys|null", jsdocOverride:true}
       */

      /**
       * The object for the child keys. It is ignored when using a <a href="oj.TreeDataProvider.html">oj.TreeDataProvider</a>.
       *
       * @name optionsKeys.childKeys
       * @ojshortdesc The object for the child keys. It is ignored when using a TreeDataProvider.
       * @expose
       * @public
       * @instance
       * @memberof! oj.ojSelectMany
       * @type {?Object}
       * @default null
       * @ojsignature {target:"Type", value:"oj.ojSelect.OptionsKeys|null", jsdocOverride:true}
       */
    },

    /**
     * <p>Attributes specified here will be set on the picker DOM element when it's launched.
     * <p>The supported attribute is <code class="prettyprint">class</code>, which is appended to the picker's class, if any.
     * Note: 1) picker-attributes is not applied in the native renderMode.
     * 2) setting this attribute after element creation has no effect.
     *
     * @property {string=} style The css style to append to the picker.
     * @property {string=} class The css class to append to the picker.
     *
     * @example <caption>Initialize the select specifying the class attribute to be set on the picker DOM element:</caption>
     * &lt;oj-select-one picker-attributes="[[pickerAttributes]]">&lt;/oj-select-one>
     * @example var pickerAttributes = {
     *   "class": "my-class"
     * };
     *
     * @name pickerAttributes
     * @ojshortdesc The style attributes for the drop down.
     * @expose
     * @memberof oj.ojSelectOne
     * @ojdeprecated {target: "property", for: "style", since: "7.0.0", description: "Style property of pickerAttribute is deprecated as it violates the recommended <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy'>Content Security Policy</a> for JET which disallows <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/style-src'>inline styles</a>. Use class property instead."}
     * @instance
     * @type {?Object}
     * @default null
     */

    /**
     * <p>Attributes specified here will be set on the picker DOM element when it's launched.
     * <p>The supported attribute is <code class="prettyprint">class</code>, which is appended to the picker's class, if any.
     * Note: 1) picker-attributes is not applied in the native renderMode.
     * 2) setting this attribute after element creation has no effect.
     *
     * @property {string=} style The css style to append to the picker.
     * @property {string=} class The css class to append to the picker.
     *
     * @example <caption>Initialize the select specifying the class attribute to be set on the picker DOM element:</caption>
     * &lt;oj-select-many picker-attributes="[[pickerAttributes]]">&lt;/oj-select-many>
     * @example var pickerAttributes = {
     *   "class": "my-class"
     * };
     *
     * @name pickerAttributes
     * @ojshortdesc The style attributes for the drop down.
     * @expose
     * @memberof oj.ojSelectMany
     * @ojdeprecated {target: "property", for: "style", since: "7.0.0", description: "Style property of pickerAttribute is deprecated as it violates the recommended <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy'>Content Security Policy</a> for JET which disallows <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/style-src'>inline styles</a>. Use class property instead."}
     * @instance
     * @type {?Object}
     * @default null
     */
    pickerAttributes: null,

    /**
    * {@ojinclude "name":"selectCommonRequired"}
    *
    * @example <caption>Initialize the select with the <code class="prettyprint">required</code> attribute:</caption>
    * &lt;oj-select-one required="[[isRequired]]">&lt;/oj-select-one>
    *
    * @example <caption>Get or set the <code class="prettyprint">required</code> property after initialization:</caption>
    * // getter
    * var requiredValue = mySelect.required;
    *
    * // setter
    * mySelect.required = true;
    *
    * @name required
    * @expose
    * @ojshortdesc Specifies whether a value is required.
    * @access public
    * @instance
    * @memberof oj.ojSelectOne
    * @type {boolean}
    * @default false
    * @since 0.7.0
    * @see #translations
    */

    /**
     * {@ojinclude "name":"selectCommonRequired"}
     *
     * @example <caption>Initialize the select with the <code class="prettyprint">required</code> attribute:</caption>
     * &lt;oj-select-many required="[[isRequired]]">&lt;/oj-select-many>
     *
     * @example <caption>Get or set the <code class="prettyprint">required</code> property after initialization:</caption>
     * // getter
     * var requiredValue = mySelect.required;
     *
     * // setter
     * mySelect.required = true;
     *
     * @name required
     * @expose
     * @ojshortdesc Specifies whether a value is required.
     * @access public
     * @instance
     * @memberof oj.ojSelectMany
     * @type {boolean}
     * @default false
     * @since 0.7.0
     * @see #translations
     */

    /**
     * Whether the element is required or optional. When required is set to true, an implicit
     * required validator is created using the RequiredValidator -
     * <code class="prettyprint">RequiredValidator()</code>.
     *
     * Translations specified using the <code class="prettyprint">translations.required</code> attribute
     * and the label associated with the element, are passed through to the options parameter of the
     * createValidator method.
     *
     * <p>
     * When <code class="prettyprint">required</code> property changes due to programmatic intervention,
     * the element may clear messages and run validation, based on the current state it's in. </br>
     *
     * <h4>Running Validation</h4>
     * <ul>
     * <li>if element is valid when required is set to true, then it runs deferred validation on
     * the value. This is to ensure errors are not flagged unnecessarily.
     * </li>
     * <li>if element is invalid and has deferred messages when required is set to false, then
     * element messages are cleared but no deferred validation is run.
     * </li>
     * <li>if element is invalid and currently showing invalid messages when required is set, then
     * element messages are cleared and normal validation is run using the current display value.
     * <ul>
     *   <li>if there are validation errors, then <code class="prettyprint">value</code>
     *   property is not updated and the error is shown.
     *   </li>
     *   <li>if no errors result from the validation, the <code class="prettyprint">value</code>
     *   property is updated; page author can listen to the <code class="prettyprint">optionChange</code>
     *   event on the <code class="prettyprint">value</code> property to clear custom errors.</li>
     * </ul>
     * </li>
     * </ul>
     *
     * <h4>Clearing Messages</h4>
     * <ul>
     * <li>Only messages created by the element are cleared.</li>
     * <li><code class="prettyprint">messages-custom</code> property is not cleared.</li>
     * </ul>
     *
     * </p>
     * <p>
     * This property set to <code class="prettyprint">false</code> implies that a value is not required to be provided by the user.
     * This is the default.
     * This property set to <code class="prettyprint">true</code> implies that a value is required to be provided by the user.
     * </p>
     * <p>
     * Additionally a required validator -
     * {@link oj.RequiredValidator} - is implicitly used if no explicit required validator is set.
     * An explicit required validator can be set by page authors using the validators attribute.
     * </p>
     * <p>
     * In the Alta theme the input's label will render a required icon. In the Redwood theme, by default,
     * a Required text is rendered inline when the field is empty.  If user-assistance-density is 'compact', it will show on the label as an icon.
     * </p>
     *
     * @expose
     * @access public
     * @instance
     * @memberof oj.ojSelect
     * @since 0.7.0
     * @see #translations
     * @ojfragment selectCommonRequired
     */
    required: false,

    /**
     * Dictates element's readonly state.
     * <p>
     * The default value for readonly is false. However, if the form component is a descendent of
     * <code class="prettyprint">oj-form-layout</code>, the default value for readonly could come from the
     * <code class="prettyprint">oj-form-layout</code> component's readonly attribute.
     * The <code class="prettyprint">oj-form-layout</code> uses the
     * <a href="MetadataTypes.html#PropertyBinding">MetadataTypes.PropertyBinding</a>
     * <code class="prettyprint">provide</code> property to provide its
     * <code class="prettyprint">readonly</code>
     * attribute value to be consumed by descendent components.
     * The form components are configured to consume the readonly property if an ancestor provides it and
     * it is not explicitly set.
     * For example, if the oj-form-layout's readonly attribute is set to true, and a descendent form component does
     * not have its readonly attribute set, the form component's readonly will be true.
     * </p>
     * @example <caption>Initialize the select with the <code class="prettyprint">readonly</code> attribute:</caption>
     * &lt;oj-some-element readonly>&lt;/oj-some-element>
     *
     * @example <caption>Get or set the <code class="prettyprint">readonly</code> property after initialization:</caption>
     * // getter
     * var ro = myComp.readonly;
     *
     * // setter
     * myComp.readonly = false;
     *
     * @name readOnly
     * @alias readonly
     * @expose
     * @ojshortdesc Specifies whether a value is readonly
     * @access public
     * @instance
     * @memberof oj.ojSelectOne
     * @type {boolean}
     * @default false
     */

    /**
     * Dictates element's readonly state.
     * <p>
     * The default value for readonly is false. However, if the form component is a descendent of
     * <code class="prettyprint">oj-form-layout</code>, the default value for readonly could come from the
     * <code class="prettyprint">oj-form-layout</code> component's readonly attribute.
     * The <code class="prettyprint">oj-form-layout</code> uses the
     * <a href="MetadataTypes.html#PropertyBinding">MetadataTypes.PropertyBinding</a>
     * <code class="prettyprint">provide</code> property to provide its
     * <code class="prettyprint">readonly</code>
     * attribute value to be consumed by descendent components.
     * The form components are configured to consume the readonly property if an ancestor provides it and
     * it is not explicitly set.
     * For example, if the oj-form-layout's readonly attribute is set to true, and a descendent form component does
     * not have its readonly attribute set, the form component's readonly will be true.
     * </p>
     * @example <caption>Initialize the select with <code class="prettyprint">readonly</code> attribute:</caption>
     * &lt;oj-some-element readonly>&lt;/oj-some-element>
     *
     * @example <caption>Get or set the <code class="prettyprint">readonly</code> property after initialization:</caption>
     * // getter
     * var ro = myComp.readonly;
     *
     * // setter
     * myComp.readonly = false;
     *
     * @name readOnly
     * @alias readonly
     * @expose
     * @ojshortdesc Specifies whether a value is readonly
     * @access public
     * @instance
     * @memberof oj.ojSelectMany
     * @type {boolean}
     * @default false
     */
    readOnly: false,

    /**
     * {@ojinclude "name":"selectCommonRenderMode"}
     * @example <caption>Set the <code class="prettyprint">render-mode</code> attribute:</caption>
     * &lt;oj-select-one render-mode="native">&lt;/oj-select-one>
     *
     * @example <caption>Get or set the <code class="prettyprint">renderMode</code> property after initialization:</caption>
     * // getter
     * var renderMode = mySelect.renderMode;
     *
     * // setter
     * mySelect.renderMode = "native";
     *
     * @name renderMode
     * @ojshortdesc Specifies whether to render select in JET or as a HTML Select tag.
     * @expose
     * @memberof oj.ojSelectOne
     * @instance
     * @type {string}
     * @ojvalue {string} "jet" Render the select in jet mode.
     * @ojvalue {string} "native" Render the select in native mode.
     *
     * @ojdeprecated {since: '8.0.0', description: 'The "native" mode rendering is deprecated because JET is promoting a consistent Oracle UX over native look and feel in Redwood. Since this property takes only two values the property itself is deprecated. The theme variable "$selectRenderModeOptionDefault" is also deprecated for the same reason.'}
     */

    /**
     * {@ojinclude "name":"selectCommonRenderMode"}
     * @example <caption>Set the <code class="prettyprint">render-mode</code> attribute:</caption>
     * &lt;oj-select-many render-mode="native">&lt;/oj-select-many>
     *
     * @example <caption>Get or set the <code class="prettyprint">renderMode</code> property after initialization:</caption>
     * // getter
     * var renderMode = mySelect.renderMode;
     *
     * // setter
     * mySelect.renderMode = "native";
     *
     * @name renderMode
     * @ojshortdesc Specifies whether to render select in JET or as a HTML Select tag.
     * @expose
     * @memberof oj.ojSelectMany
     * @instance
     * @type {string}
     * @ojvalue {string} "jet" Render the select in jet mode.
     * @ojvalue {string} "native" Render the select in native mode.
     *
     * @ojdeprecated {since: '8.0.0', description: 'The "native" mode rendering is deprecated because JET is promoting a consistent Oracle UX over native look and feel in Redwood. Since this property takes only two values the property itself is deprecated. The theme variable "$selectRenderModeOptionDefault" is also deprecated for the same reason.'}
     */

    /**
     * The render-mode attribute allows applications to specify whether to render select in JET or as a HTML Select tag.
     * Valid Values: jet, native
     *
     * <ul>
     *  <li> jet - Applications get full JET functionality.</li>
     *  <li> native - Applications get the HTML Select tag functionality and additional JET features below:
     *    <ul>
     *      <li>validation</li>
     *      <li>placeholder</li>
     *      <li>options (ko.observableArray)</li>
     *      <li>list</li>
     *      <li>optionKeys</li>
     *    </ul>
     *  With native renderMode, the functionality that is sacrificed compared to jet renderMode is:
     *    <ul>
     *      <li>no search box (no filtering)</li>
     *      <li>for multiple select, only number of selected items is displayed in the selectbox, not the selected values</li>
     *      <li>beforeExpand event isn't fired when the popup picker opens.</li>
     *      <li>only one level nesting optgroups in the popup picker due to the HTML optgroup limitation</li>
     *      <li>no image support in the option list</li>
     *      <li>All Sub-IDs are not available in the native renderMode.</li>
     *      <li>pickerAttributes is not applied in the native renderMode.</li>
     *      <li>when using data provider a maximum of 15 rows will be displayed in the dropdown, users can't filter further.</li>
     *      <li>if the <a href="#labelHint">label-hint</a> attribute is used in conjunction with a <a href="#labelEdge">label-edge</a> value of 'inside', no label will be rendered; as this can result in non-accessible pages, jet renderMode must be used in this case.</li>
     *    </ul>
     * </ul>
     *
     * The default value depends on the theme. In alta-android, alta-ios and alta-windows themes, the default is "native" and it's "jet" for all other themes.
     *
     * @expose
     * @memberof oj.ojSelect
     * @instance
     * @ojfragment selectCommonRenderMode
     */
    renderMode: 'jet',

    /**
     * The <code class="prettyprint">valueOption</code> is similar to the <code class="prettyprint">value</code>, but is an
     * Object which contains both a value and display label.
     * The <code class="prettyprint">value</code> and <code class="prettyprint">valueOption</code> are kept in sync.
     * If initially both are set, the selected value in the <code class="prettyprint">value</code> attribute has precedence.
     * <p>Note: When the <code class="prettyprint">options</code> attribute is bound to a data provider, the <code class="prettyprint">valueOptionChanged</code> event will include data and metadata information if it is available from data provider.</p>
     * <p>Setting the <code class="prettyprint">valueOption</code> attribute initially can improve page load performance if there are initially selected values.  But, the initial <code class="prettyprint">valueOptionChanged</code> event will not include data and metadata information, because the element doesn't have to fetch the selected label from the data provider.</p>
     * <p>If <code class="prettyprint">valueOption</code> is not specified or the selected value is missing, then the label will be fetched from the data provider.</p>
     *
     * @name valueOption
     * @ojshortdesc The current value of the element and its associated display label.
     * @expose
     * @instance
     * @type {null | Object}
     * @default null
     * @ojwriteback
     *
     * @property {any} value current value of JET Select
     * @property {string} [label] display label of value above. If missing, String(value) is used.
     * @memberof oj.ojSelectOne
     * @ojsignature { target: "Type",
     *                value: "V|null", for: "value"}
     *
     * @example <caption>Initialize the Select with the <code class="prettyprint">value-option</code> attribute specified:</caption>
     * &lt;oj-select-one value-option="[[valueOption]]">&lt;/oj-select-one>
     *
     * @example <caption>Object with value and label properties:</caption>
     * var valueOption = {'value': 'val1', 'label': 'Label 1'};
     *
     * @example <caption>Get or set the <code class="prettyprint">valueOption</code> property after initialization:</caption>
     * // getter
     * var valueOption = mySelect.valueOption;
     *
     * // setter
     * mySelect.valueOption = valueOption;
     */
    valueOption: null,

    /**
     * The <code class="prettyprint">valueOptions</code> is similar to the <code class="prettyprint">value</code>, but is an array
     * of Objects and each Object contains both a value and display label.
     * The <code class="prettyprint">value</code> and <code class="prettyprint">valueOptions</code> are kept in sync.
     * If initially both are set, the selected values in the <code class="prettyprint">value</code> attribute has precedence.
     * <p>Note: When the <code class="prettyprint">options</code> attribute is bound to a data provider, the <code class="prettyprint">valueOptionsChanged</code> event will include data and metadata information if it is available from data provider.</p>
     * <p>Setting the <code class="prettyprint">valueOptions</code> attribute initially can improve page load performance if there are initially selected values.  But, the initial <code class="prettyprint">valueOptionsChanged</code> event will not include data and metadata information, because the element doesn't have to fetch the selected label from the data provider.</p>
     *<p>If <code class="prettyprint">valueOptions</code> is not specified or one of the selected values is missing, then the labels will be fetched from the data provider.</p>
     *
     * @name valueOptions
     * @ojshortdesc The current values of the element and their associated display labels.
     * @expose
     * @instance
     * @type {null | Array.<Object>}
     * @default null
     * @ojwriteback
     *
     * @property {any} value a current value of JET Select
     * @property {string} [label] display label of value above. If missing, String(value) is used.
     * @ojsignature { target: "Type",
     *                value: "Array<{value: V, label?: string}> | null",
     *                jsdocOverride: true}
     *
     * @memberof oj.ojSelectMany
     *
     * @example <caption>Initialize the Select with the <code class="prettyprint">value-options</code> attribute specified:</caption>
     * &lt;oj-select-many value-options="[[optionsArray]]">&lt;/oj-select-many>
     *
     * @example <caption>Array of Objects with value and label properties:</caption>
     * var optionsArray = [{'value': 'val1', 'label': 'Label 1'},
     *                     {'value': 'val2', 'label': 'Label 2'}];
     *
     * @example <caption>Get or set the <code class="prettyprint">valueOptions</code> property after initialization:</caption>
     * // getter
     * var valueOptions = mySelect.valueOptions;
     *
     * // setter
     * mySelect.valueOptions = optionsArray;
     */
    valueOptions: null
    /**
     * The value of the element. It supports any type. Select only accepts a value that's in the drop down list.
     * When the value attribute is not set, the first option is used as its initial value if it exists.
     * Trying to set a new value that's not in the drop down list fails validation and the new value is not set.
     * <p>If a value is specified before the data for the drop down list is available, then that value is set initially.
     * When the data for the drop down list is available, the initially set value is validated.
     * If it fails validation, the first option will be set as the value instead.</p>
     * <p>Note: When the <code class="prettyprint">options</code> attribute is bound to a data provider, the <code class="prettyprint">valueChanged</code> event will include data and metadata information if it is available from data provider.</p>
     *
     * @example <caption>Initialize the select with the <code class="prettyprint">value</code> attribute specified:</caption>
     * &lt;oj-select-one value="option1">&lt;/oj-select-one>
     *
     * @example <caption>Get or set the <code class="prettyprint">value</code> property after initialization:</caption>
     * // getter
     * var value = mySelect.value;
     *
     * // setter
     * mySelect.value = "option1";
     *
     * @member
     * @name value
     * @ojshortdesc The value of the element.
     * @access public
     * @instance
     * @memberof oj.ojSelectOne
     * @type {any}
     * @ojsignature { target: "Type",
     *                value: "V|null"}
     * @ojwriteback
     * @ojeventgroup common
     */

    /**
     * The value of the element. The value is an array with any type of items.
     * <p>Note: When the <code class="prettyprint">options</code> attribute is bound to a data provider, the <code class="prettyprint">valueChanged</code> event will include data and metadata information if it is available from data provider.</p>
     *
     * @example <caption>Initialize the select with the <code class="prettyprint">value</code> attribute specified:</caption>
     * &lt;oj-select-many value="{{val}}">&lt;/oj-select-many>
     * @example var val = ['option1', 'option2'];
     *
     * @example <caption>Get or set the <code class="prettyprint">value</code> property after initialization:</caption>
     * // getter
     * var value = mySelect.value;
     *
     * // setter
     * mySelect.value = ["option1", "option2"];
     *
     * @member
     * @name value
     * @ojshortdesc The value of the element.
     * @access public
     * @instance
     * @memberof oj.ojSelectMany
     * @type {Array.<any>|null}
     * @ojsignature { target: "Type",
     *                value: "Array<V>|null"}
     * @default null
     * @ojwriteback
     * @ojeventgroup common
     */

  },

  /**
   * Returns a jQuery object containing the element visually representing the select.
   *
   * <p>This method does not accept any arguments.
   *
   * @expose
   * @memberof! oj.ojSelect
   * @instance
   * @public
   * @ignore
   * @return {jQuery} the select
   */
  widget: function widget() {
    // native renderMode
    if (this.select) {
      return this.select.container;
    }

    return this.element.parent().parent();
  },

  /**
   * @override
   * @protected
   * @instance
   * @memberof! oj.ojSelect
   */
  _ComponentCreate: function _ComponentCreate() {
    this._super();

    _ComboUtils.wrapDataProviderIfNeeded(this, null);

    this._setup();
  },

  /**
   * @override
   * @protected
   * @instance
   * @memberof! oj.ojSelect
   */
  _AfterCreate: function _AfterCreate() {
    var ariaLabelledBy;

    this._super(); // For custom element syntax, we need to get the label id and
    // set aria-labelledby on the focusable element.


    if (this._IsCustomElement()) {
      if (this.options.labelledBy) {
        var defaultLabelId = this.uuid + '_Label';
        ariaLabelledBy = oj.EditableValueUtils._getOjLabelAriaLabelledBy(this.options.labelledBy, defaultLabelId); // Readonly support

        if (ariaLabelledBy && (!this.multiple || !_ComboUtils.isReadonly(this))) {
          this._GetContentElement().attr('aria-labelledby', ariaLabelledBy);
        } // update the required translation text


        if (this._IsRequired() && this.options.translations.required) {
          this._implicitReqValidator = null;

          this._getImplicitRequiredValidator();
        }
      } // need to apply the oj-focus marker selector for control of the floating label.


      var rootElement = this._getRootElement();

      this._focusable({
        element: rootElement,
        applyHighlight: false,
        afterToggle: this._handleAfterFocusToggle.bind(this, rootElement)
      }); // If labelEdge is set to none, aria-label would have been set to the innerElem
      // so, we need to update the aria-label elsewhere


      if (this.select && this.options.labelEdge === 'none') {
        this.select.updateAriaLabelIfNeeded();
      }
    }
  },

  /**
   * If the dropdown is open and the afterToggle handler is called with focusout,
   * turn on the 'oj-focus' selector. This is needed for floating labels.  If focus
   * moves to the droplist, the label should be in the up position versus floating
   * down over the input on selection of a dropdown item.
   * @private
   * @instance
   * @memberof! oj.ojSelect
   */
  _handleAfterFocusToggle: function _handleAfterFocusToggle(element, eventType) {
    this.hasAfterToggleHandlerAddedFocusClass = false;

    if (eventType === 'focusout') {
      var dropdown = this._getDropdown();

      if (dropdown) {
        element.classList.add('oj-focus');
        this.hasAfterToggleHandlerAddedFocusClass = true;
      }
    }
  },

  /**
    * Performs post processing after _SetOption() is called. Different options when changed perform
    * different tasks. See _AfterSetOption[OptionName] method for details.
    *
    * @param {string} option
    * @param {Object|string=} previous
    * @param {Object=} flags
    * @protected
    * @memberof! oj.ojSelect
    * @instance
    * @override
    */
  // eslint-disable-next-line no-unused-vars
  _AfterSetOption: function _AfterSetOption(option, previous, flags) {
    this._superApply(arguments);

    switch (option) {
      case 'required':
        this._AfterSetOptionRequired(option);

        break;

      case 'labelHint':
      case 'labelEdge':
        // Changing labelHint and labelEdge might have updated
        // aria-label on the root element. Check if it is needed to
        // update the aria-label on inner elements.
        if (this.select) {
          this.select.updateAriaLabelIfNeeded();
        }

        break;

      default:
        break;
    }
  },

  /**
   * Whether the component is required.
   *
   * @return {boolean} true if required; false
   *
   * @memberof! oj.ojSelect
   * @instance
   * @protected
   * @override
   */
  _IsRequired: function _IsRequired() {
    return this.options.required;
  },

  /**
   * Performs post processing after required option is set by taking the following steps.
   *
   * - if component is invalid and has messgesShown -> required: false/true -> clear component errors;
   * run full validation with UI value (we don't know if the UI error is from a required validator
   * or something else);<br/>
   * &nbsp;&nbsp;- if there are validation errors, then value not pushed to model; messagesShown is
   * updated<br/>
   * &nbsp;&nbsp;- if no errors result from the validation, push value to model; author needs to
   * listen to optionChange(value) to clear custom errors.<br/>
   *
   * - if component is invalid and has messagesHidden -> required: false -> clear component
   * errors; no deferred validation is run.<br/>
   * - if component has no error -> required: true -> run deferred validation (we don't want to flag
   * errors unnecessarily)<br/>
   * - messagesCustom is never cleared<br/>
   *
   * @param {string} option
   *
   * @memberof! oj.ojSelect
   * @instance
   * @protected
   */
  _AfterSetOptionRequired: oj.EditableValueUtils._AfterSetOptionRequired,
  // native renderMode
  _nativeSetDisabled: function _nativeSetDisabled(disabled) {
    if (disabled) {
      this.element.attr('disabled', '');
      this.element.parent().parent().addClass('oj-disabled').removeClass('oj-enabled');
    } else {
      this.element.removeAttr('disabled');
      this.element.parent().parent().removeClass('oj-disabled').addClass('oj-enabled');
    }
  },
  _nativeChangeHandler: function _nativeChangeHandler(event) {
    var arr = [];
    var arrValOpts = [];

    var emptyValueAllowed = !this._IsRequired() && this._HasPlaceholderSet(); // NOTE: option and optgroup


    $(event.target).find('option').each(function () {
      if (this.selected && (this.value || emptyValueAllowed && this.value === '')) {
        arr.push(this.value);
        arrValOpts.push({
          value: this.value,
          label: this.text
        });
      }
    });

    if (_ComboUtils.duringFetchByKey(this.element)) {
      _ComboUtils.setValueChanged(this, true);
    } // - ie11 multiple select with keyboard fails


    if (!this._IsCustomElement() || this.multiple === true) {
      this._SetValue(arr, event, {
        doValueChangeCheck: false,
        _context: {
          internalSet: true
        }
      });

      _ComboUtils.setValueOptions(this, arrValOpts);
    } else {
      this._SetValue(arr[0], event, {
        doValueChangeCheck: false,
        _context: {
          internalSet: true
        }
      });

      _ComboUtils.setValueOptions(this, arrValOpts[0]);
    }
  },
  _nativeQueryCallback: function _nativeQueryCallback(data) {
    if (!data) {
      return;
    } // populate data in dropdown here


    var element = this.element; // if options is a dataProvider, it was wrapped with LPDV
    // don't pass in optionsKeys

    _ComboUtils.arrayPopulateResults(element, data, this._formatValue.bind(this), _ComboUtils.isDataProvider(this.options.options) ? null : this.options.optionsKeys);

    element.addClass(_ComboUtils.GENERATED_OPTIONS_SELECTOR);
  },
  _nativeSetSelected: function _nativeSetSelected(value) {
    var selected = null;

    if (value) {
      selected = value;
    } else {
      if (this._HasPlaceholderSet()) {
        if (this.options.required) {
          selected = this._nativeFindFirstEnabledOptionValue();
        }

        this._SetPlaceholder(this.options.placeholder);
      } // default to the first enabled option


      if (selected === null) {
        var option = this._nativeFindFirstEnabledOption();

        selected = this._nativeFindFirstEnabledOptionValue(option);

        _ComboUtils.setValueOptions(this, {
          value: selected,
          label: option.text()
        });
      }
    }

    this._setInitialSelectedValue(selected);
  },
  // fetch first block from data provider
  // when data available validate the selected value
  _nativeFetchFromDataProvider: function _nativeFetchFromDataProvider() {
    var self = this;

    _ComboUtils.fetchFirstBlockFromDataProvider(this.element, self.options).then(function (data) {
      self._nativeQueryCallback(data);

      if (data.length) {
        // make sure value still valid
        var selected = self.options.value;

        if (selected) {
          _ComboUtils.validateFromDataProvider(self.element, self.options, selected).then(function (results) {
            //  - need to be able to specify the initial value of select components bound to dprv
            if (_ComboUtils.isValueChanged(self) && self.multiple === false) {
              _ComboUtils.setValueChanged(self, undefined);
            } else {
              var vals;
              var valOpts;

              if (_ComboUtils.isValueChanged(self) && self.multiple) {
                valOpts = self.options.valueOptions;
                vals = self.options.value;

                _ComboUtils.setValueChanged(self, undefined);
              }

              if (results) {
                var valueOptions = results.valueOptions;

                if (Array.isArray(valueOptions) && valueOptions.length) {
                  _ComboUtils.setValueOptions(self, valOpts ? valueOptions.concat(valOpts) : valueOptions);
                } // only set value if it is valid


                var values = results.value;

                if (Array.isArray(values) && values.length) {
                  vals = vals ? values.concat(vals) : values;
                  var cval = self.multiple ? vals : values[0];

                  self._nativeSetSelected(cval); //  - select component binding broken in mobile
                  // need update the selected value property
                  // Note: setting multiple selected values causing
                  // the selection to be cleared


                  if (!self.multiple || cval.length === 1) {
                    self.element[0].value = cval;
                  }
                }
              }
            }
          });
        } else {
          // no selected value, default to placeholder or 1st item
          self._nativeSetSelected();
        }
      }
    });
  },
  _nativeSetup: function _nativeSetup() {
    var element = this.element;

    if (this._IsCustomElement()) {
      // The custom element will be the wrapper and we do not need to add another wrapper
      $(this.OuterWrapper).addClass('oj-select-native oj-component oj-select oj-form-control');
    } else {
      // add a <div> around <select> for validation error
      element.wrap('<div>').parent() // @HTMLUpdateOK
      .addClass('oj-select-native oj-component oj-select oj-form-control');
    }

    element.addClass('oj-select-select oj-component-initnode');
    element.wrap('<div class="oj-text-field-container" role="presentation">'); // @HTMLUpdateOK
    // multiple attr

    if (this.multiple) {
      if (!element[0].multiple) {
        element[0].multiple = true;
      }

      element.parent().prepend("<a class='oj-select-arrow oj-component-icon oj-clickable-icon-nocontext oj-select-multiple-open-icon' role='presentation'></a>"); // @HTMLUpdateOK
    } else {
      element.parent().prepend("<a class='oj-select-arrow oj-component-icon oj-clickable-icon-nocontext oj-select-open-icon' role='presentation'></a>"); // @HTMLUpdateOK
    } // disable attr


    this._nativeSetDisabled(this.options.disabled);

    if (this.options.list) {
      _ComboUtils.listPopulateResults(element, $('#' + this.options.list).children(), this._formatValue.bind(this));

      element.addClass(_ComboUtils.GENERATED_OPTIONS_SELECTOR);
    } else if (this.options.options) {
      if (_ComboUtils.getDataProvider(this.options)) {
        this._nativeFetchFromDataProvider();
      } else {
        this._nativeQueryCallback(this.options.options);
      }
    } else if (this._IsCustomElement()) {
      // TODO: TEST if the dropdown only contains a placeholder don't call ojOptionPopulateResults
      var children = element.children();

      if (children.length !== 1 || !children.hasClass('oj-listbox-placeholder')) {
        // handle custom element with oj-option, oj-optgroup case
        _ComboUtils.ojOptionPopulateResults(element, children, this._formatValue.bind(this));

        element.addClass(_ComboUtils.GENERATED_OPTIONS_SELECTOR);
      }
    }

    this._focusable({
      element: element,
      applyHighlight: true
    }); //  - the selected option of the ojselect not reflected in the value variable


    if (!this.options.value && !this._HasPlaceholderSet() && !_ComboUtils.getDataProvider(this.options)) {
      this._setInitialSelectedValue(this._nativeFindFirstEnabledOptionValue());
    } // add a change listener


    element.change(this._nativeChangeHandler.bind(this));

    _ComboUtils.addDataProviderEventListeners(this);

    var labelEdge = this._ResolveLabelEdgeStrategyType();

    if (labelEdge === 'top') {
      this._initComponentMessaging();
    }
  },

  /**
   * Resolves the labelEdge.
   * @memberof  oj.ojSelect
   * @instance
   * @protected
   * @return {string}
   */
  // eslint-disable-next-line no-unused-vars
  _ResolveLabelEdgeStrategyType: function _ResolveLabelEdgeStrategyType() {
    var labelEdge = this._superApply(arguments);

    if (this._IsCustomElement() && this._isNative()) {
      if (labelEdge === 'inside') {
        labelEdge = 'top';
      }
    }

    return labelEdge;
  },
  // native renderMode
  _jetSetup: function _jetSetup() {
    var opts = {};
    opts.element = this.element;
    opts.ojContext = this;
    opts = $.extend(this.options, opts);
    this.select = this.multiple ? new _OjMultiSelect() : new _OjSingleSelect();

    this.select._init(opts);

    this.select.container.addClass('oj-select-jet oj-form-control');

    this._focusable({
      element: this.select.selection,
      applyHighlight: true
    }); //      var arrow = this.select.selection.children(".oj-select-arrow");
    //      this._AddHoverable(arrow);
    //      this._AddActiveable(arrow);

  },
  //  - the selected option of the ojselect not reflected in the value variable
  _setInitialSelectedValue: function _setInitialSelectedValue(selectedVal) {
    var selected;

    if (!this._IsCustomElement()) {
      selected = Array.isArray(selectedVal) ? selectedVal : [selectedVal];
    } else {
      selected = selectedVal;
    }

    this._SetValue(selected, null, {
      doValueChangeCheck: false,
      _context: {
        internalSet: true,
        writeback: true
      },
      changed: true
    });
  },
  // ojselect
  _setup: function _setup() {
    // fixup valueOption(s) if placeholder is selected
    if (_ComboUtils.isValueForPlaceholder(this.multiple, this.options.value)) {
      if (this.multiple) {
        this.options.valueOptions = _ComboUtils.getValueOptionsForPlaceholder(this, this.options.valueOptions);
      } else {
        this.options.valueOption = _ComboUtils.getValueOptionsForPlaceholder(this, this.options.valueOption);
      }
    } //  - need to be able to specify the initial value of select components bound to dprv


    this._resolveValueOptionsLater = _ComboUtils.mergeValueAndValueOptions(this);

    if (this._isNative()) {
      this._nativeSetup();
    } else {
      this._jetSetup();
    }

    this._refreshRequired(this.options.required);
  },

  /**
   * Returns if the element is a text field element or not.
   * @memberof oj.ojSelect
   * @instance
   * @protected
   * @return {boolean}
   */
  _IsTextFieldComponent: function _IsTextFieldComponent() {
    return true;
  },

  /**
   * Returns the components wrapper under which label needs to be inserted in the inside strategy
   * @instance
   * @protected
   * @ignore
   * @return {Element|undefined}
   */
  _GetContentWrapper: function _GetContentWrapper() {
    if (this._IsCustomElement()) {
      return this.select._GetContentWrapper();
    }

    return undefined;
  },

  /**
   * Refreshes the visual state of the select. JET elements require a <code
   * class="prettyprint">refresh()</code> after the DOM is programmatically
   * changed.
   *
   * <p>This method does not accept any arguments.
   *
   * @expose
   * @memberof oj.ojSelect
   * @instance
   * @return {void}
   * @ojshortdesc Refreshes the visual state of the select.
   * @public
   */
  refresh: function refresh() {
    this._super(); // cleanup the old HTML and setup the new HTML markups


    this._cleanup();

    this._setup(); // TODO: apply value in options for the selected value


    if (this._isNative() && this.options.value) {
      this.element.val(this.options.value);
    } // re apply root attributes settings


    this._SetRootAttributes();

    this._initComponentMessaging();
  },

  /**
   * @memberof! oj.ojSelect
   * @instance
   * @private
   */
  _refreshRequired: oj.EditableValueUtils._refreshRequired,

  /**
   * Called to find out if aria-required is unsupported.
   * @memberof! oj.ojSelect
   * @instance
   * @protected
   */
  _AriaRequiredUnsupported: function _AriaRequiredUnsupported() {
    return false;
  },

  /**
   * @override
   * @private
   * @memberof! oj.ojSelect
   */
  _destroy: function _destroy() {
    // native renderMode
    this._cleanup();

    this._super();
  },
  // 19670760, dropdown popup should be closed on subtreeDetached notification.
  _NotifyDetached: function _NotifyDetached() {
    this._superApply(arguments); // native renderMode


    if (this.select) {
      this.select.close();
    }
  },
  // 19670760, dropdown popup should be closed on subtreeHidden notification.
  _NotifyHidden: function _NotifyHidden() {
    this._superApply(arguments); // native renderMode


    if (this.select) {
      this.select.close();
    }
  },

  /**
     * Override to do the delay connect/disconnect
     * @memberof oj.ojSelect
     * @override
     * @protected
     */
  _VerifyConnectedForSetup: function _VerifyConnectedForSetup() {
    //  - temp moving oj-select from one elem to another should not cause fetch
    return true;
  },

  /**
   * Set the placeholder.
   * @override
   * @protected
   * @memberof! oj.ojSelect
   */
  _SetPlaceholder: function _SetPlaceholder(value) {
    // native renderMode
    // add a placeholder option if needed
    if (this._isNative() && value != null) {
      var placeholder = $(this.element.children('option:first-child')); // if a placeholder option exists, use it

      if (placeholder && placeholder.attr('value') === '') {
        placeholder.text(this.options.placeholder);
        placeholder.attr('value', '');
      } else {
        placeholder = _ComboUtils.createOptionTag(0, '', value, this._formatValue.bind(this));
        placeholder.addClass('oj-listbox-placeholder'); //  - placeholder text is a selectable item that results in an error for ojcomponent

        this._hidePlaceholder(placeholder, this._IsRequired());

        placeholder.prependTo(this.element); // @HTMLUpdateOK
      }
    } else if (this.select) {
      // if using quiet forms, override the display text with an empty string when null.
      // a null value is passed when the component doesn't have focus so that the placeholder
      // and floating label will not occupy the same space.
      var tmpValue = value;

      if (this.options.labelEdge === 'inside') {
        tmpValue = !value ? '' : value;
      }

      this.select.opts.placeholder = tmpValue;

      this.select._setPlaceholder();
    }
  },

  /**
   * whether the placeholder option is set
   *
   * @memberof! oj.ojSelect
   * @instance
   * @protected
   */
  _HasPlaceholderSet: function _HasPlaceholderSet() {
    //  - an empty placeholder shows up if data changed after first binding
    return _ComboUtils.isPlaceholderSpecified(this.options);
  },

  /**
   * Clear the placeholder option
   *
   * @memberof! oj.ojSelect
   * @instance
   * @protected
   */
  _ClearPlaceholder: function _ClearPlaceholder() {
    //  - an empty placeholder shows up if data changed after first binding
    this._SetPlaceholderOption(null);

    this._SetPlaceholder(null);
  },

  /**
   * @memberof! oj.ojSelect
   * @instance
   * @protected
   * @override
   */
  _InitOptions: function _InitOptions(originalDefaults, constructorOptions) {
    var props = [{
      attribute: 'disabled',
      validateOption: true
    }, {
      attribute: 'placeholder'
    }, {
      attribute: 'required',
      coerceDomValue: true,
      validateOption: true
    }, {
      attribute: 'title'
    } // {attribute: "value"}
    ];

    this._super(originalDefaults, constructorOptions);

    oj.EditableValueUtils.initializeOptionsFromDom(props, constructorOptions, this);
    this.multiple = !this._IsCustomElement() ? this.options.multiple : this.OuterWrapper.nodeName === 'OJ-SELECT-MANY'; // TODO: PAVI - Let's discuss

    if (this.options.value === undefined) {
      if (!this._IsCustomElement()) {
        this.options.value = this.element.attr('value') !== undefined ? _ComboUtils.splitVal(this.element.val(), ',') : null;
      } else {
        // sanitize the value for custom element
        this.options.value = null;
      }
    } else {
      // clone the value, otherwise _setDisplayValue will not be invoked on binding value to ko observableArray.
      // TODO: Need to revisit this once 18724975 is fixed.
      var value = this.options.value;

      if (Array.isArray(value)) {
        if (!this._IsCustomElement()) {
          value = value.slice(0);
        }
      }

      this.options.value = value;
    }
  },

  /**
   * Updates display value.
   * @override
   * @protected
   * @memberof! oj.ojSelect
   */
  _SetDisplayValue: function _SetDisplayValue(displayValue) {
    if (this.select) {
      //  - need to be able to specify the initial value of select components bound to dprv
      if (!_ComboUtils.applyValueOptions(this.select, this.options)) {
        this.select._initSelection();
      }

      this._resolveValueOptionsLater = false;
    } else {
      // if the display value is the value for placeholder, let it default to 1st option or placeholder
      // see demo pages: disable and placeholder
      var opts;

      if (this._setPlaceholderStyle(displayValue)) {
        this.element[0].selectedIndex = 0;
      }

      if (displayValue == null) {
        // update valueOptions
        if (this._resolveValueOptionsLater) {
          //  - reseting value when value-option and placeholder are set
          // throws exception
          _ComboUtils.setValueOptions(this, _ComboUtils.getFixupValueOptionsForPlaceholder(this.multiple));
        }
      } else {
        //  - oj-select-one throws exception for mobile when selectedindex = -1 on refresh
        var valSet = false;
        var selectedVal = displayValue;
        var label;

        if (!this.multiple) {
          if (Array.isArray(displayValue)) {
            selectedVal = displayValue[0];
          }

          label = this._nativeFindLabel(selectedVal);

          if (label === null) {
            Logger.warn('JET select: selected value not found'); // default to 1st option if exists

            if (this.element[0].options && this.element[0].options.length > 0) {
              this.element[0].selectedIndex = 0;
              selectedVal = this.element[0].value;
              label = this.element[0].text;
              valSet = true;
            } else {
              label = String(displayValue);
            }
          }
        }

        if (!valSet) {
          this.element.val(displayValue);
        } // eslint-disable-next-line no-param-reassign


        displayValue = selectedVal; // update valueOptions

        if (this._resolveValueOptionsLater) {
          if (this.multiple) {
            // collect the selected values and labels
            var s = 0;
            opts = [];
            this.element.find('option').each(function () {
              if (this.selected) {
                opts.push({
                  value: displayValue[s],
                  label: this.text
                });
                s += 1;
              }
            });
          } else {
            opts = {
              value: displayValue,
              label: label
            };
          }

          _ComboUtils.setValueOptions(this, opts);
        }
      }

      this._resolveValueOptionsLater = false;
    }
  },

  /**
   * Returns the display value.
   * @override
   * @protected
   * @memberof! oj.ojSelect
   * @return {Array|Object|null} display value of the component
   */
  _GetDisplayValue: function _GetDisplayValue() {
    var displayValue = null;

    if (this.select) {
      var opts = _ComboUtils.getOpts(this);

      var data = this.select._getSelectionData();

      if (data != null) {
        if (this.multiple) {
          displayValue = [];

          if (Array.isArray(data)) {
            for (var i = 0; i < data.length; i++) {
              displayValue.push(opts.formatSelection(data[i]));
            }
          } else {
            displayValue.push(opts.formatSelection(data));
          }
        } else {
          // eslint-disable-next-line no-lonely-if
          if (Array.isArray(data) && data.length > 0) {
            displayValue = opts.formatSelection(data[0]);
          } else {
            displayValue = opts.formatSelection(data);
          }
        }
      } else {
        // get the display value from editable value if the selection data is unavailable
        displayValue = this._super();
      }
    } else {
      // native renderMode
      displayValue = this._super();
    }

    return displayValue;
  },

  /**
   * <ol>
   * <li>All messages are cleared, including custom messages added by the app. </li>
   * <li>The implicit required validator is run first if the component
   * is marked required. </li>
   * <li>At the end of validation if there are errors, the messages are shown.
   * If there were no errors, then the
   * <code class="prettyprint">value</code> option is updated.</li>
   * </ol>
   *
   * @example <caption>Validate component using its current value.</caption>
   * myComp.validate();
   *
   * @example <caption>Validate component and use the Promise's resolved state.</caption>
   * myComp.validate().then(
   *  function(result) {
   *    if(result === "valid")
   *    {
   *      submitForm();
   *    }
   *  });
   * @return {Promise} Promise resolves to "valid" if the component passed validation.
   * The Promise resolves to "invalid" if there were validation errors.
   * @ojshortdesc Validates the component's display value using all validators registered on the component. If there are no validation errors, then the value is updated. See the Help documentation for more information.
   * @method
   * @access public
   * @expose
   * @instance
   * @memberof oj.ojSelect
   *
   */
  validate: function validate() {
    var returnValue;
    var newValue = null;

    if (this.select) {
      if (this.multiple === true) {
        var displayValue = this.select.search.val();
        var existingValue = this.select.getVal() ? this.select.getVal() : [];

        if (displayValue === undefined || displayValue === null || displayValue === '') {
          newValue = existingValue;
        } else {
          existingValue.push(displayValue);
          newValue = existingValue;
        }
      } else {
        //  - select needs implementation fixes...
        newValue = this.select.getVal();
      }
    } else if (this._isNative()) {
      //  - native select
      newValue = this.options.value;
    } // _SetValue returns boolean when there is no async validator or
    // converter, else it returns a Promise. Since ojselect has no validator or
    // converter, this will always return true or false. validate needs to
    // return a Promise if customElement.


    returnValue = this._SetValue(newValue, null, this._VALIDATE_METHOD_OPTIONS); // for widget components, validate() returns boolean. Else it returns a Promise
    // that resolves to 'valid' or 'invalid'

    if (this._IsCustomElement()) {
      returnValue = Promise.resolve(returnValue ? 'valid' : 'invalid');
    }

    return returnValue;
  },

  /**
   * Whether a value can be set on the component. For example, if the component is
   * disabled or readOnly then setting value on component is a no-op.
   *
   * @see #_SetValue
   * @return {boolean}
   * @memberof oj.ojSelect
   * @override
   * @instance
   * @protected
   */
  _CanSetValue: function _CanSetValue() {
    // FIX  - VALUE UNCHANGED IN DISABLED SELECT WHEN CHANGING BOUND VALUEOPTION
    // _SetValue always performs validation, which calls _CanSetValue, which returns false if
    // the component is disabled, thereby disallowing the set.  Override _CanSetValue here
    // so that we can force it to return true when syncing the value with the valueOption[s]
    // from _ComboUtils.syncValueWithValueOption[s].
    if (this.forceCanSetValue) {
      return true;
    }

    return this._super();
  },
  // return 1st enabled option jquery object
  _nativeFindFirstEnabledOption: function _nativeFindFirstEnabledOption() {
    // find all the enabled options under the element
    var enaOptions = this.element.find('option:not(:disabled)'); // return the first enabled option

    return enaOptions.length > 0 ? $(enaOptions[0]) : null;
  },
  // native renderMode
  _nativeFindFirstEnabledOptionValue: function _nativeFindFirstEnabledOptionValue(enaOption) {
    if (!enaOption) {
      // eslint-disable-next-line no-param-reassign
      enaOption = this._nativeFindFirstEnabledOption();
    }

    if (enaOption) {
      if (this._IsCustomElement()) {
        // send the value as it is for custom element
        //  - oj-select-one writes initial value as array in native rendering mode
        return enaOption.attr('value');
      } // send the value in an array for widget


      return [enaOption.attr('value')];
    }

    return null;
  },
  _nativeSetOptions: function _nativeSetOptions(options) {
    var oSelected = this.options.value;
    var element = this.element; // if options list is generated during setup, remove it

    if (element.hasClass(_ComboUtils.GENERATED_OPTIONS_SELECTOR)) {
      _ComboUtils.cleanupResults(element);
    } else {
      var children = element.children();

      if (children.length > 0) {
        children.remove();
      }
    } // if data provider, fetch data


    if (_ComboUtils.isDataProvider(options)) {
      this._nativeFetchFromDataProvider();
    } else {
      _ComboUtils.arrayPopulateResults(element, options, this._formatValue.bind(this), this.options.optionsKeys);

      var defVal = null;

      if (this._HasPlaceholderSet()) {
        if (this.options.required) {
          defVal = this._nativeFindFirstEnabledOptionValue();
        }

        this._SetPlaceholder();
      } // default to the first enabled option


      if (defVal === null) {
        defVal = this._nativeFindFirstEnabledOptionValue();
      }

      this.options.value = defVal;
      this.option('value', oSelected);
    }

    element.addClass(_ComboUtils.GENERATED_OPTIONS_SELECTOR);
  },
  _removePlaceholderInMultiValues: function _removePlaceholderInMultiValues(valArr) {
    var val;
    var narr = [];

    for (var i = 0; i < valArr.length; i++) {
      val = valArr[i];

      if (val != null) {
        if (val.length > 0) {
          // remove placeholder if it was already added to arr
          if (narr.length === 1 && narr[0] === '') {
            narr.pop();
          }

          narr.push(val);
        } else if (narr.length === 0) {
          // val is a placeholder
          narr.push(val);
        }
      }
    }

    return narr;
  },
  //  - oj-select-one throws exception for mobile when selectedindex = -1 on refresh
  // return label if found otherwise null
  _nativeFindLabel: function _nativeFindLabel(value) {
    var options = this.element[0].options;

    if (options && options.length > 0) {
      for (var i = 0; i < options.length; i++) {
        if (options[i].value === value) {
          return $(options[i]).text();
        }
      }
    }

    return null;
  },
  // set oj-select-default on the select tag if the selected value is a placeholder and a singleton
  _setPlaceholderStyle: function _setPlaceholderStyle(value) {
    var multi = this.multiple; // set default style for placeholder
    // if the value is null or empty string and has the placeholder set or
    // for non-custom element, if the value specified is an 1 item array of empty string
    // for custom element, if the value specified is the value for placeholder

    if ((value == null || value === '') && this._HasPlaceholderSet() || !this._IsCustomElement() && Array.isArray(value) && value.length === 1 && value[0] === '' || this._IsCustomElement() && this._HasPlaceholderSet() && _ComboUtils.isValueForPlaceholder(multi, value)) {
      this.element.addClass('oj-select-default');
      return true;
    }

    this.element.removeClass('oj-select-default');
    return false;
  },

  /**
   * Handles options specific to select.
   * @override
   * @protected
   * @memberof! oj.ojSelect
   */
  _setOption: function _setOption(key, _value, flags) {
    var value = _value;
    var selected;
    var hasSelectedValue;
    var self = this;
    var selfSuper = this._super;
    var multi = this.multiple;
    var bRefresh = false;

    if (key === 'value') {
      // clone the value, otherwise _setDisplayValue will not be invoked on binding value to ko observableArray.
      // TODO: Need to revisit this once 18724975 is fixed.
      // BUG JET-31272 - For select many the valueOptions should be updated if the value is cleared
      if ((this._HasPlaceholderSet() || multi) && (value != null && value.length === 0 || this._IsCustomElement() && _ComboUtils.isValueForPlaceholder(multi, value))) {
        //  - placeholder is not displayed after removing selections from select many
        _ComboUtils.setValueOptions(this, _ComboUtils.getFixupValueOptionsForPlaceholder(multi));

        this._super(key, value, flags);

        return;
      } // native renderMode


      var element;

      if (this.select) {
        element = this.select.datalist;

        if (!element) {
          element = this.select.opts.element;
        }
      }

      var customSelectOne = this._IsCustomElement() && !multi; // turn value to an array

      if (!Array.isArray(value) && !customSelectOne) {
        value = [value];
      }

      if (this._isNative()) {
        if (!customSelectOne) {
          value = this._removePlaceholderInMultiValues(value);
        }

        this._setPlaceholderStyle(value);
      }

      if (_ComboUtils.getDataProvider(this.options) && value) {
        if (this.select) {
          this.select.opts.options = this.options.options;
        }

        _ComboUtils.validateFromDataProvider(this._isNative() ? this.element : this.select.container, this.options, value).then(function (results) {
          //  - need to be able to specify the initial value of select components bound to dprv
          if (results) {
            var valueOptions = results.valueOptions;

            if (Array.isArray(valueOptions) && valueOptions.length) {
              _ComboUtils.setValueOptions(self, valueOptions);
            } // only set value if it is valid


            var values = results.value;

            if (Array.isArray(values) && values.length) {
              var cval = multi ? values : values[0];
              selfSuper.call(self, key, cval); //  - select component binding broken in mobile

              if (self._isNative()) {
                // need update the selected value property
                self.element[0].value = cval;
              }
            }
          }
        }); //  - ojselect allows to set invalid value when using dataprovider


        return;
      } else if (!customSelectOne) {
        //  - ojselect should ignore the invalid value set programmatically
        var newArr = [];

        for (var i = 0; i < value.length; i++) {
          if (this.select) {
            // Note: both multi select and remote data cases, the validate function is not available
            if (!this.select.opts.validate || this.select.opts.validate(element, value[i]) || this._isOptionDataPending()) {
              newArr.push(value[i]);
            }
          } else if (this.element.find("option[value='" + value[i] + "']").length > 0) {
            newArr.push(value[i]);
          }
        } // only set values that are valid
        //  - can't remove last selected value in multi-select ojselect
        // multi select allows empty array


        if (newArr.length > 0 || multi) {
          if (this._isNative()) {
            this._nativeSetSelected(newArr);
          } else {
            this._super(key, newArr, flags); //  - need to be able to specify the initial value of select components bound to dprv


            _ComboUtils.updateValueOptions(this.select);
          }
        }

        return;
      }

      if (!(this.select && this.select.opts.validate) || this.select.opts.validate(element, value) || this._isOptionDataPending()) {
        this._super(key, value, flags); //  - need to be able to specify the initial value of select components bound to dprv


        _ComboUtils.updateValueOptions(this.select);
      }

      return;
    } else if (key === 'placeholder') {
      if (this.select) {
        this.select.opts.placeholder = value;

        if (_ComboUtils.isValueForPlaceholder(multi, this.options.value)) {
          this.select._setPlaceholder();
        }
      } else {
        // native renderMode
        selected = this.options.value;

        if (!selected || selected.length === 0 || !selected[0]) {
          this.element[0].selectedIndex = 0;
        }
      }
    } else if (key === 'maximumResultCount') {
      if (this.select) {
        this.select.opts.maximumResultCount = value;
      } else {
        // native renderMode
        bRefresh = true;
      }
    } else if (key === 'minimumResultsForSearch') {
      // native renderMode
      if (this.select) {
        this.select.opts.minimumResultsForSearch = value;
      }
    } else if (key === 'renderMode') {
      this._cleanup();

      bRefresh = true;
    } // if we have a new data provider, remove the old dataProvider event listeners


    if (key === 'options') {
      _ComboUtils.removeDataProviderEventListeners(this);

      _ComboUtils.clearDataProviderWrapper(this);
    } else if (key === 'optionsKeys') {
      _ComboUtils.clearDataProviderWrapper(this);
    } else if (key === 'valueOption' && multi !== true) {
      // fixup valueOption
      value = _ComboUtils.getValueOptionsForPlaceholder(this, value);

      if (this.select) {
        this.select.opts.valueOption = value;
      }
    } else if (key === 'valueOptions' && multi === true) {
      // fixup valueOptions
      value = _ComboUtils.getValueOptionsForPlaceholder(this, value);

      if (this.select) {
        this.select.opts.valueOptions = value;
      }
    }

    this._super(key, value, flags);

    if (bRefresh) {
      this.refresh();
    }

    if (key === 'disabled') {
      if (this.select) {
        if (value) {
          this.select._disable();
        } else {
          this.select._enable();
        }
      } else {
        this._nativeSetDisabled(value);
      } // Readonly support

    } else if (key === 'readOnly') {
      if (this.select) {
        this.select.applyReadonlyState();
      }

      if (this.options.renderMode === 'native') {
        this.refresh();
      }
    } else if (key === 'valueOption' && multi !== true) {
      //  - need to be able to specify the initial value of select components bound to dprv
      _ComboUtils.syncValueWithValueOption(this, value, this.options.value, this._isNative());
    } else if (key === 'valueOptions' && multi === true) {
      _ComboUtils.syncValueWithValueOptions(this, value, this.options.value, this._isNative());
    } else if (key === 'options') {
      // if options is a new data provider
      // wrap it with LVDP if it doesn't implement FetchByKeys
      // add event listeners
      if (_ComboUtils.isDataProvider(value)) {
        // update internal dataProviderWrapper
        _ComboUtils.wrapDataProviderIfNeeded(this, this.select ? this.select.opts : null);

        _ComboUtils.addDataProviderEventListeners(this);
      }

      if (this.select) {
        // make sure the value still valid
        selected = this.select.getVal(); // selected value can be an Array|null for select-many, any|null for select-one and an array for select-one widget.
        // select-many has selected values, if selected is a non-empty Array.
        // select-one has a selected value, if selected is not null.
        // select-one widget has a selected value, if selected array has a single non-null value.

        if (multi) {
          hasSelectedValue = selected && selected.length !== 0;
        } else {
          hasSelectedValue = this._IsCustomElement() ? selected != null : selected && selected[0] != null;
        }

        if (_ComboUtils.getDataProvider(this.options) && hasSelectedValue) {
          //  - need to be able to specify the initial value of select components bound to dprv
          if (_ComboUtils.applyValueOptions(this.select, this.options)) {
            this.select.opts.options = value;
            this.select.opts = self.select._prepareOpts(this.select.opts);
          } else {
            _ComboUtils.validateFromDataProvider(this.select.container, this.options, this.options.value).then(function (results) {
              //  - need to be able to specify the initial value of select components bound to dprv
              var values = results ? results.value : null;

              if (values) {
                var valueOptions = results.valueOptions;

                if (Array.isArray(valueOptions) && valueOptions.length) {
                  _ComboUtils.setValueOptions(self, valueOptions);
                } // only set value if it is valid


                if (Array.isArray(values) && values.length) {
                  selfSuper.call(self, 'value', multi ? values : values[0]);
                }
              } else if (self.options.placeholder) {
                // use placeholder if specified
                if (!multi) {
                  self.select._updateSelectedOption(self.options.placeholder);
                }
              } else {
                // eslint-disable-next-line no-lonely-if
                if (!multi) {
                  // the selected value is no longer valid, fetch 1st item from data provider
                  // for single select
                  _ComboUtils.fetchFirstBlockFromDataProvider(self.select.container, self.options, 1).then(function (data) {
                    // At this point if we still don't have a selected value then default to the first item
                    if (data && data.length > 0 && selected === self.select.getVal()) {
                      self.select._updateSelectedOption(data[0]);
                    } else {
                      selfSuper.call(self, 'value', null); // update select box

                      self.select.text.text('');
                    }
                  });
                } else {
                  // Set the default value for multi select
                  selfSuper.call(self, 'value', null);
                }
              }

              self.select.opts.options = value;
              self.select.opts = self.select._prepareOpts(self.select.opts);
            });
          }
        } else {
          //  - an empty placeholder shows up if data changed after first binding
          //  - ojselect - validator error message is not shown
          //  - ojselect tooltip no longer appears once options and value observables change
          this.select.opts.options = value;
          this.select.opts = this.select._prepareOpts(this.select.opts);

          if (!multi || hasSelectedValue) {
            // make sure the value still valid
            this.select.setValOpts(null);

            this._super('value', selected);
          }
        }
      } else {
        this._nativeSetOptions(value);
      }
    } else if (key === 'optionsKeys') {
      _ComboUtils.wrapDataProviderIfNeeded(this, this.select ? this.select.opts : null);
    } else if (key === 'required' && this._isNative()) {
      var placeholder = $(this.element.find('.oj-listbox-placeholder'));

      if (placeholder && placeholder.attr('value') === '') {
        // hide placeholder when required is true
        this._hidePlaceholder(placeholder, value);
      }
    } else if (key === 'multiple' && !this._IsCustomElement()) {
      this.multiple = value;
    } else if (key === 'labelledBy') {
      if (this.options.labelledBy) {
        var defaultLabelId = this.uuid + '_Label';

        var ariaLabelledBy = oj.EditableValueUtils._getOjLabelAriaLabelledBy(this.options.labelledBy, defaultLabelId); // Readonly support


        if (ariaLabelledBy && (!this.multiple || !_ComboUtils.isReadonly(this))) {
          this._GetContentElement().attr('aria-labelledby', ariaLabelledBy);
        } // Update the aria-labelledby attribute of the results container
        // Fix  - Acc error in the OATB tool


        if (this.select != null && this.select.results != null) {
          this.select.results.attr('aria-labelledby', ariaLabelledBy);
        } // update the required translation text


        if (this._IsRequired() && this.options.translations.required) {
          this._implicitReqValidator = null;

          this._getImplicitRequiredValidator();
        }
      }
    }
  },
  _isOptionDataPending: function _isOptionDataPending() {
    var options = this.options.options;
    var datalist = this.select.datalist;

    if (datalist) {
      // check if the data provided via html
      if (datalist.children().length === 0) {
        return true;
      }
    } else if (_ComboUtils.isDataProvider(options)) {
      //  - replacing options in select after value is set -> writes over the value
      // skip validation if a value is specified when the data is empty, don't fetch data until user opens dropdown.
      // We validate value and set displayValue when the drop down data is available
      return true;
    } else if (!options || options.length === 0) {
      // check the options array
      return true;
    }

    return false;
  },
  _getDropdown: function _getDropdown() {
    // native renderMode
    if (this.select && this.select._opened()) {
      //  - certain subids does not work inside a popup or dialog
      var dropdown = this.select.dropdown;

      if (dropdown && dropdown.attr('data-oj-containerid') === this.select.containerId) {
        return dropdown;
      }
    }

    return null;
  },
  _hidePlaceholder: function _hidePlaceholder(placeholder, hide) {
    if (hide) {
      placeholder.attr('disabled', '');
      placeholder.attr('hidden', '');
    } else {
      placeholder.removeAttr('disabled');
      placeholder.removeAttr('hidden');
    }
  },
  // native renderMode
  _isNative: function _isNative() {
    // Readonly support
    return this.options.renderMode === 'native' && !_ComboUtils.isReadonly(this);
  },
  // native renderMode
  _cleanup: function _cleanup() {
    // Readonly support
    if (this.element.parent().parent().hasClass('oj-select-native')) {
      // remove the change listner
      this.element.off('change'); // if options list is generated during setup, remove it

      if (this.element.hasClass(_ComboUtils.GENERATED_OPTIONS_SELECTOR)) {
        _ComboUtils.cleanupResults(this.element);
      } // remove wrapper


      if (this.element.parent().hasClass('oj-text-field-container')) {
        this.element.unwrap();
      }

      this.element.parent().children('.oj-select-arrow').remove();

      if (!this._IsCustomElement()) {
        // Widgets will have extra wrapper and it should be unwrapped
        this.element.unwrap();
      }

      this.element.removeClass('oj-select-select oj-component-initnode');
      this.element.attr({
        'aria-labelledby': ''
      }); // Readonly support
    } else if (this.select) {
      this.select._destroy();

      this.select = undefined;
    }
  },
  // ////////////////     SUB-IDS     //////////////////

  /**
   * <p>Sub-ID for the selected text in the select box. This is not available in the native renderMode.</p>
   *
   * @ojsubid oj-select-chosen
   * @deprecated 1.2.0 This sub-ID is not needed since it is not an interactive element.
   * @memberof oj.ojSelect
   * @ignore
   * @instance
   */

  /**
   * <p>Sub-ID for the dropdown box. See the <a href="#minimumResultsForSearch">minimum-results-for-search</a> attribute for details. This is not available in the native renderMode.</p>
   *
   * @ojsubid oj-select-drop
   * @deprecated 1.2.0 This sub-ID is not needed since it is not an interactive element.
   * @memberof oj.ojSelect
   * @ignore
   */

  /**
   * <p>Sub-ID for the search box. Note:</p>
   * <ul>
   * <li>the search box is not always visible</li>
   * <li>the Sub-Id is not available in the native renderMode</li>
   * </ul>
   * <p>See the <a href="#minimumResultsForSearch">minimum-results-for-search</a> attribute for details.
   * <p>See the <a href="#getNodeBySubId">getNodeBySubId</a> and
   * <a href="#getSubIdByNode">getSubIdByNode</a> methods for details.
   *
   * @ojsubid oj-select-search
   * @ignore
   * @deprecated 1.2.0 This sub-ID is not needed since it is not an interactive element.
   * @memberof oj.ojSelect
   */

  /**
   * <p>Sub-ID for the search input element. Note:</p>
   * <ul>
   * <li>the search input is not always visible</li>
   * <li>the Sub-Id is not available in the native renderMode</li>
   * </ul>
   *
   * <p>See the <a href="#minimumResultsForSearch">minimum-results-for-search</a> attribute for details.</p>
   *
   * @ojsubid oj-listbox-input
   * @deprecated 1.2.0 please see oj-select-input
   * @memberof oj.ojSelect
   * @ignore
   */

  /**
   * <p>Sub-ID for the filtered result list. This Sub-Id is not available in the native renderMode.</p>
   *
   * @ojsubid oj-select-results
   * @deprecated 1.2.0 This sub-ID is not needed since it is not an interactive element.
   * @memberof oj.ojSelect
   * @ignore
   */

  /**
   * <p>Sub-ID for the filtered result item. Note:</p>
   * <ul>
   * <li>To lookup a filtered result item, the dropdown must be open and the locator object should have:
   *     subId: 'oj-listbox-result-label' and index: number.
   * </li>
   * <li>the Sub-Id is not available in the native renderMode</li>
   * </ul>
   *
   * @ojsubid oj-listbox-result-label
   * @deprecated 1.2.0 This sub-ID is not needed since it is not an interactive element.
   * @memberof oj.ojSelect
   * @ignore
   */

  /**
   * <p>Sub-ID for the search input field. It's only visible when the results size is greater than the minimum-results-for-search threshold or when user starts typing into the select box. This Sub-Id is not available in the native renderMode.</p>
   * @ojsubid oj-select-input
   * @memberof oj.ojSelect
   *
   * @example <caption>Get the input field element</caption>
   * var node = myElement.getNodeBySubId({'subId': 'oj-select-input'});
   */

  /**
   * <p>Sub-ID for the drop down arrow. This Sub-Id is not available in the native renderMode.</p>
   *
   * @ojsubid oj-select-arrow
   * @memberof oj.ojSelectOne
   *
   * @example <caption>Get the drop down arrow of the select</caption>
   * var node = myElement.getNodeBySubId({'subId': 'oj-select-arrow'});
   */

  /**
   * <p>Sub-ID for the list item. This Sub-Id is not available in the native renderMode.</p>
   *
   * @ojsubid oj-listitem
   * @memberof oj.ojSelect
   *
   * @example <caption>Get the listitem corresponding to value "myVal"</caption>
   * var node = myElement.getNodeBySubId({'subId': 'oj-listitem', 'value': 'myVal'});
   */

  /**
   * <p>Sub-ID for the remove icon of selected item. This Sub-Id is not available in the native renderMode.</p>
   *
   * @ojsubid oj-select-remove
   * @memberof oj.ojSelectMany
   *
   * @example <caption>Get the element corresponding to the remove icon for the selected item with
   * value "myVal"</caption>
   * var node = myElement.getNodeBySubId({'subId': 'oj-select-remove', 'value': 'myVal'});
   */
  // @inheritdoc
  getNodeBySubId: function getNodeBySubId(locator) {
    var node = null;
    var subId;

    if (locator == null) {
      var container = this.widget();
      return container ? container[0] : null;
    } else if (this._isNative()) {
      // doesn't support any sub ID in native mode
      return null;
    }

    node = this._super(locator);

    if (!node) {
      var dropdown = this._getDropdown();

      subId = locator.subId;

      switch (subId) {
        case 'oj-select-drop':
          if (dropdown) {
            node = dropdown[0];
          }

          break;

        case 'oj-select-results':
          if (dropdown) {
            node = dropdown.find('.oj-listbox-results')[0];
          }

          break;

        case 'oj-select-search':
          if (dropdown) {
            node = dropdown.find('.oj-listbox-search')[0];
          }

          break;

        case 'oj-select-input':
        case 'oj-listbox-input':
          if (dropdown) {
            node = dropdown.find('.oj-listbox-input')[0];
          }

          break;

        case 'oj-select-choice':
        case 'oj-select-chosen':
        case 'oj-select-arrow':
          node = this.widget().find('.' + subId)[0];
          break;

        case 'oj-listitem':
          if (dropdown) {
            var list = dropdown.find('.oj-listbox-result');
            node = this.select._findItem(list, locator.value);
          }

          break;

        case 'oj-select-remove':
          var selectedItems = this.widget().find('.oj-select-selected-choice');

          var item = this.select._findItem(selectedItems, locator.value);

          node = item ? $(item).find('.oj-select-clear-entry-icon')[0] : null;
          break;
        //  - ojselect - not able to attach id for generated jet component

        case 'oj-listbox-result-label':
          if (dropdown) {
            // list of 'li'
            var ddlist = $('#' + this.select.results.attr('id')).children();
            var index = locator.index;

            if (ddlist.length && index < ddlist.length) {
              node = ddlist.eq(index).find('.' + subId)[0];
            }
          }

          break;

        default:
          break;
      }
    } // Non-null locators have to be handled by the component subclasses


    return node || null;
  },

  /**
   * Returns the subId object for the given child DOM node.  For more details, see
   * <a href="#getNodeBySubId">getNodeBySubId</a>.
   *
   * @expose
   * @ignore
   * @override
   * @memberof oj.ojSelect
   * @instance
   *
   * @param {!Element} node - child DOM node
   * @return {Object|null} The subId for the DOM node, or <code class="prettyprint">null</code> when none is found.
   *
   * @example <caption>Get the subId for a certain DOM node:</caption>
   * var subId = myElement.getSubIdByNode(node);
   */
  getSubIdByNode: function getSubIdByNode(node) {
    if (this._isNative()) {
      return this._super(node);
    }

    var subId = null;

    if (node != null) {
      var nodeCached = $(node);

      if (nodeCached.hasClass('oj-listbox-input')) {
        subId = {
          subId: 'oj-select-input'
        };
      } else if (nodeCached.hasClass('oj-select-arrow')) {
        subId = {
          subId: 'oj-select-arrow'
        };
      } else if (nodeCached.hasClass('oj-listbox-result')) {
        subId = {
          subId: 'oj-listitem',
          value: nodeCached.data('ojselect').value
        };
      } else if (nodeCached.hasClass('oj-select-clear-entry-icon')) {
        subId = {
          subId: 'oj-select-remove',
          value: nodeCached.closest('.oj-select-selected-choice').data('ojselect').value
        };
      } else {
        subId = this._super(node);
      }
    }

    return subId;
  },

  /**
   * Returns the default styleclass for the component. Currently this is
   * used to pass to the ojLabel component, which will append -label and
   * add the style class onto the label. This way we can style the label
   * specific to the input component. For example, for inline labels, the
   * radioset/checkboxset components need to have margin-top:0, whereas all the
   * other inputs need it to be .5em. So we'll have a special margin-top style
   * for .oj-label-inline.oj-radioset-label
   * All input components must override
   *
   * @return {string}
   * @expose
   * @memberof! oj.ojSelect
   * @override
   * @protected
   */
  _GetDefaultStyleClass: function _GetDefaultStyleClass() {
    return 'oj-select';
  },

  /**
   * Returns the messaging launcher element i.e., where user sets focus that triggers the popup.
   * Usually this is the element input or select that will receive focus and on which the popup
   * for messaging is initialized.
   *
   * @override
   * @protected
   * @memberof! oj.ojSelect
   * @return {Object} jquery element which represents the messaging launcher component
   */
  _GetMessagingLauncherElement: function _GetMessagingLauncherElement() {
    // native renderMode
    if (this.select) {
      return this.select.selection;
    }

    return this.element;
  },

  /**
   * Returns the jquery element that represents the content part of the component.
   * This is usually the component that user sets focus on (tabindex is set 0) and
   * where aria attributes like aria-required, aria-labeledby etc. are set. This is
   * also the element where the new value is updated. Usually this is the same as
   * the _GetMessagingLauncherElement.
   *
   * @override
   * @protected
   * @memberof! oj.ojSelect
   * @return {jQuery} jquery element which represents the content.
   */
  _GetContentElement: function _GetContentElement() {
    // native renderMode
    if (this.select) {
      return this.select.selection;
    }

    return this.element;
  },

  /**
   * Returns the element on which aria-label can be found.
   * For select components, it is the content element where the aria-label will be set.
   *
   * @override
   * @protected
   * @memberof! oj.ojSelect
   * @return {HTMLElement} The element in which we set the aria-label attribute
   */
  _GetAriaLabelElement: function _GetAriaLabelElement() {
    return this._GetContentElement()[0];
  } // Fragments:

  /**
   * <p>The &lt;oj-select-one> element accepts <code class="prettyprint">oj-option</code> elements as children. See the [oj-option]{@link oj.ojOption} documentation for details about
   * accepted children and slots.</p>
   *
   * @ojchild Default
   * @memberof oj.ojSelectOne
   * @ojshortdesc The oj-select-one element accepts oj-option elements as children.
   *
   * @example <caption>Initialize the select with child content specified:</caption>
   * &lt;oj-select-one>
   *   &lt;oj-option value="option1">Option 1&lt;/oj-option>
   *   &lt;oj-option value="option2">Option 2&lt;/oj-option>
   *   &lt;oj-option value="option3">Option 3&lt;/oj-option>
   * &lt;/oj-select-one>
   */

  /**
   * <p>The &lt;oj-select-many> element accepts <code class="prettyprint">oj-option</code> elements as children. See the [oj-option]{@link oj.ojOption} documentation for details about
   * accepted children and slots.</p>
   *
   * @ojchild Default
   * @memberof oj.ojSelectMany
   * @ojshortdesc The oj-select-many element accepts oj-option elements as children.
   *
   * @example <caption>Initialize the select with child content specified:</caption>
   * &lt;oj-select-many>
   *   &lt;oj-option value="option1">Option 1&lt;/oj-option>
   *   &lt;oj-option value="option2">Option 2&lt;/oj-option>
   *   &lt;oj-option value="option3">Option 3&lt;/oj-option>
   * &lt;/oj-select-many>
   */

  /**
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Target</th>
   *       <th>Gesture</th>
   *       <th>Action</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td>Select box or Arrow button</td>
   *       <td><kbd>Tap</kbd></td>
   *       <td>If the drop down is not open, expand the drop down list. Otherwise, close the drop down list.
   *       If hints, title or messages exist in a notewindow,
   *        pop up the notewindow on tapping on select box.</td>
   *     </tr>
   *     <tr>
   *       <td>Option item</td>
   *       <td><kbd>Tap</kbd></td>
   *       <td>Tap on a option item in the drop down list to select a new item.</td>
   *     </tr>
   *     <tr>
   *       <td>Drop down</td>
   *       <td><kbd>swipe up/down</kbd></td>
   *       <td>Scroll the drop down list vertically</td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   * @ojfragment touchDocOne - Used in touch gesture section of classdesc, and standalone gesture doc
   * @memberof oj.ojSelectOne
   * @instance
   */

  /**
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Target</th>
   *       <th>Gesture</th>
   *       <th>Action</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td>Select box</td>
   *       <td><kbd>Tap</kbd></td>
   *       <td>If the drop down is not open, expand the drop down list. Otherwise, close the drop down list.
   *       If hints, title or messages exist in a notewindow,
   *        pop up the notewindow.</td>
   *     </tr>
   *     <tr>
   *       <td>Option item</td>
   *       <td><kbd>Tap</kbd></td>
   *       <td>Tap on a option item in the drop down list to add to selection.</td>
   *     </tr>
   *     <tr>
   *       <td>Selected item with remove icon</td>
   *       <td><kbd>Tap</kbd></td>
   *       <td>Remove item from the selected items list by tapping on the remove icon.</td>
   *     </tr>
   *     <tr>
   *       <td>Drop down</td>
   *       <td><kbd>swipe up/down</kbd></td>
   *       <td>Scroll the drop down list vertically</td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   * @ojfragment touchDocMany - Used in touch gesture section of classdesc, and standalone gesture doc
   * @memberof oj.ojSelectMany
   * @instance
   */

  /**
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Target</th>
   *       <th>Key</th>
   *       <th>Action</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td>Option item</td>
   *       <td><kbd>Enter</kbd></td>
   *       <td>Select the highlighted choice from the drop down list.</tr>
   *     </tr>
   *     <tr>
   *       <td>Drop down</td>
   *       <td><kbd>UpArrow or DownArrow</kbd></td>
   *       <td>Highlight the option item in the direction of the arrow. If the drop down is not open, expand the drop down list.</tr>
   *     </tr>
   *     <tr>
   *       <td>Drop down</td>
   *       <td><kbd>Esc</kbd></td>
   *       <td>Collapse the drop down list. If the drop down is already closed, do nothing.</tr>
   *     </tr>
   *     <tr>
   *       <td>Select box or search box</td>
   *       <td><kbd>any characters for the search term</kbd></td>
   *       <td>filter down the results with the search term.</td>
   *     </tr>
   *     <tr>
   *       <td>Select</td>
   *       <td><kbd>Tab In</kbd></td>
   *       <td>Set focus to the select. If hints, title or messages exist in a notewindow,
   *        pop up the notewindow.</td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   * <p>Disabled option items receive no highlight and are not selectable.
   *
   * @ojfragment keyboardDocOne - Used in keyboard section of classdesc, and standalone gesture doc
   * @memberof oj.ojSelectOne
   * @instance
   */

  /**
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Target</th>
   *       <th>Key</th>
   *       <th>Action</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td>Option item</td>
   *       <td><kbd>Enter</kbd></td>
   *       <td>Select the highlighted choice from the drop down list.</tr>
   *     </tr>
   *     <tr>
   *       <td>Drop down</td>
   *       <td><kbd>UpArrow or DownArrow</kbd></td>
   *       <td>Highlight the option item in the direction of the arrow. If the drop down is not open, expand the drop down list.</tr>
   *     </tr>
   *     <tr>
   *      <td>Select box</td>
   *       <td><kbd>LeftArrow or RightArrow</kbd></td>
   *       <td> Move focus to the previous or next selected item.</td>
   *     </tr>
   *     <tr>
   *       <td>Selected item with remove icon</td>
   *       <td><kbd>Backspace or Delete</kbd></td>
   *       <td>Remove the selected item having focus.</td>
   *     </tr>
   *     <tr>
   *       <td>Drop down</td>
   *       <td><kbd>Esc</kbd></td>
   *       <td>Collapse the drop down list. If the drop down is already closed, do nothing.</tr>
   *     </tr>
   *     <tr>
   *       <td>Select box or search box</td>
   *       <td><kbd>any characters for the search term</kbd></td>
   *       <td>filter down the results with the search term.</td>
   *     </tr>
   *     <tr>
   *       <td>Select</td>
   *       <td><kbd>Tab In</kbd></td>
   *       <td>Set focus to the select. If hints, title or messages exist in a notewindow,
   *        pop up the notewindow.</td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   * <p>Disabled option items receive no highlight and are not selectable.
   *
   * @ojfragment keyboardDocMany - Used in keyboard section of classdesc, and standalone gesture doc
   * @memberof oj.ojSelectMany
   * @instance
   */

});

Components.setDefaultOptions({
  // converterHint is defaulted to placeholder and notewindow in EditableValue.
  // For ojselect, we don't want a converterHint.
  ojSelect: // properties for all ojSelect components
  {
    displayOptions: {
      converterHint: ['none']
    },
    // native renderMode
    renderMode: Components.createDynamicPropertyGetter(function () {
      return (ThemeUtils.parseJSONFromFontFamily('oj-select-option-defaults') || {}).renderMode;
    })
  }
});



/* global __oj_combobox_one_metadata:false */
(function () {
  var bindingMeta = {
    properties: {
      readonly: {
        binding: {
          consume: {
            name: 'readonly'
          }
        }
      },
      userAssistanceDensity: {
        binding: {
          consume: {
            name: 'userAssistanceDensity'
          }
        }
      }
    }
  };
  __oj_combobox_one_metadata.extension._WIDGET_NAME = 'ojCombobox';
  __oj_combobox_one_metadata.extension._INNER_ELEM = 'input';
  __oj_combobox_one_metadata.extension._GLOBAL_TRANSFER_ATTRS = ['aria-controls', 'aria-label', 'tabindex'];
  __oj_combobox_one_metadata.extension._ALIASED_PROPS = {
    readonly: 'readOnly'
  };
  oj.CustomElementBridge.register('oj-combobox-one', {
    metadata: oj.CollectionUtils.mergeDeep(__oj_combobox_one_metadata, bindingMeta)
  });
  /* global __oj_combobox_many_metadata:false */

  __oj_combobox_many_metadata.extension._WIDGET_NAME = 'ojCombobox';
  __oj_combobox_many_metadata.extension._INNER_ELEM = 'input';
  __oj_combobox_many_metadata.extension._GLOBAL_TRANSFER_ATTRS = ['aria-controls', 'aria-label', 'tabindex'];
  __oj_combobox_many_metadata.extension._ALIASED_PROPS = {
    readonly: 'readOnly'
  };
  oj.CustomElementBridge.register('oj-combobox-many', {
    metadata: oj.CollectionUtils.mergeDeep(__oj_combobox_many_metadata, bindingMeta)
  });
  /* global __oj_select_one_metadata:false */

  __oj_select_one_metadata.extension._WIDGET_NAME = 'ojSelect';
  __oj_select_one_metadata.extension._INNER_ELEM = 'select';
  __oj_select_one_metadata.extension._GLOBAL_TRANSFER_ATTRS = ['aria-controls', 'aria-label', 'tabindex'];
  __oj_select_one_metadata.extension._ALIASED_PROPS = {
    readonly: 'readOnly'
  };
  oj.CustomElementBridge.register('oj-select-one', {
    metadata: oj.CollectionUtils.mergeDeep(__oj_select_one_metadata, bindingMeta)
  });
  /* global __oj_select_many_metadata:false */

  __oj_select_many_metadata.extension._WIDGET_NAME = 'ojSelect';
  __oj_select_many_metadata.extension._INNER_ELEM = 'select';
  __oj_select_many_metadata.extension._GLOBAL_TRANSFER_ATTRS = ['aria-controls', 'aria-label', 'tabindex'];
  __oj_select_many_metadata.extension._ALIASED_PROPS = {
    readonly: 'readOnly'
  };
  oj.CustomElementBridge.register('oj-select-many', {
    metadata: oj.CollectionUtils.mergeDeep(__oj_select_many_metadata, bindingMeta)
  });
})();

});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojdataprovideradapter-base',['ojs/ojcore', 'jquery', 'ojs/ojeventtarget', 'ojs/ojdataprovider'], function(oj, $)
{
  "use strict";
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }


var DataSourceAdapter = /*#__PURE__*/function () {
  function DataSourceAdapter(dataSource) {
    _classCallCheck(this, DataSourceAdapter);

    this.dataSource = dataSource;

    this.AsyncIterable = /*#__PURE__*/function () {
      function _class(_asyncIterator) {
        _classCallCheck(this, _class);

        this._asyncIterator = _asyncIterator;

        this[Symbol.asyncIterator] = function () {
          return this._asyncIterator;
        };
      }

      return _class;
    }();

    this.AsyncIterator = /*#__PURE__*/function () {
      function _class2(_nextFunc, _params) {
        _classCallCheck(this, _class2);

        this._nextFunc = _nextFunc;
        this._params = _params;
        this._fetchFirst = true;
      }

      _createClass(_class2, [{
        key: 'next',
        value: function next() {
          var fetchFirst = this._fetchFirst;
          this._fetchFirst = false;
          return this._nextFunc(this._params, fetchFirst);
        }
      }]);

      return _class2;
    }();

    this.AsyncIteratorYieldResult = /*#__PURE__*/function () {
      function _class3(_parent, value) {
        _classCallCheck(this, _class3);

        this._parent = _parent;
        this.value = value;
        this[DataSourceAdapter._VALUE] = value;
        this[DataSourceAdapter._DONE] = false;
      }

      return _class3;
    }();

    this.AsyncIteratorReturnResult = /*#__PURE__*/function () {
      function _class4(_parent, value) {
        _classCallCheck(this, _class4);

        this._parent = _parent;
        this.value = value;
        this[DataSourceAdapter._VALUE] = value;
        this[DataSourceAdapter._DONE] = true;
      }

      return _class4;
    }();

    this.FetchListResult = /*#__PURE__*/function () {
      function _class5(_parent, fetchParameters, data, metadata) {
        _classCallCheck(this, _class5);

        this._parent = _parent;
        this.fetchParameters = fetchParameters;
        this.data = data;
        this.metadata = metadata;
        this[DataSourceAdapter._FETCHPARAMETERS] = fetchParameters;
        this[DataSourceAdapter._DATA] = data;
        this[DataSourceAdapter._METADATA] = metadata;
      }

      return _class5;
    }();

    this.ItemMetadata = /*#__PURE__*/function () {
      function _class6(_parent, key) {
        _classCallCheck(this, _class6);

        this._parent = _parent;
        this.key = key;
        this[DataSourceAdapter._KEY] = key;
      }

      return _class6;
    }();

    this.SortCriterion = /*#__PURE__*/function () {
      function _class7(_parent, attribute, direction) {
        _classCallCheck(this, _class7);

        this._parent = _parent;
        this.attribute = attribute;
        this.direction = direction;
        this[DataSourceAdapter._ATTRIBUTE] = attribute;
        this[DataSourceAdapter._DIRECTION] = direction;
      }

      return _class7;
    }();

    this.DataProviderMutationEventDetail = /*#__PURE__*/function () {
      function _class8(_parent, add, remove, update) {
        _classCallCheck(this, _class8);

        this._parent = _parent;
        this.add = add;
        this.remove = remove;
        this.update = update;
        this[DataSourceAdapter._ADD] = add;
        this[DataSourceAdapter._REMOVE] = remove;
        this[DataSourceAdapter._UPDATE] = update;
      }

      return _class8;
    }();

    this.DataProviderOperationEventDetail = /*#__PURE__*/function () {
      function _class9(_parent, keys, metadata, data, indexes) {
        _classCallCheck(this, _class9);

        this._parent = _parent;
        this.keys = keys;
        this.metadata = metadata;
        this.data = data;
        this.indexes = indexes;
        this[DataSourceAdapter._KEYS] = keys;
        this[DataSourceAdapter._METADATA] = metadata;
        this[DataSourceAdapter._DATA] = data;
        this[DataSourceAdapter._INDEXES] = indexes;
      }

      return _class9;
    }();

    this.DataProviderAddOperationEventDetail = /*#__PURE__*/function () {
      function _class10(_parent, keys, afterKeys, addBeforeKeys, parentKeys, metadata, data, indexes) {
        _classCallCheck(this, _class10);

        this._parent = _parent;
        this.keys = keys;
        this.afterKeys = afterKeys;
        this.addBeforeKeys = addBeforeKeys;
        this.parentKeys = parentKeys;
        this.metadata = metadata;
        this.data = data;
        this.indexes = indexes;
        this[DataSourceAdapter._KEYS] = keys;
        this[DataSourceAdapter._AFTERKEYS] = afterKeys;
        this[DataSourceAdapter._ADDBEFOREKEYS] = addBeforeKeys;
        this[DataSourceAdapter._METADATA] = metadata;
        this[DataSourceAdapter._DATA] = data;
        this[DataSourceAdapter._INDEXES] = indexes;
      }

      return _class10;
    }();
  }

  _createClass(DataSourceAdapter, [{
    key: "getCapability",
    value: function getCapability(capabilityName) {
      if (capabilityName == DataSourceAdapter._SORT && this.dataSource.getCapability(capabilityName) == 'full') {
        return {
          attributes: 'multiple'
        };
      } else if (capabilityName == 'fetchByKeys') {
        return {
          implementation: 'lookup'
        };
      } else if (capabilityName == 'fetchByOffset') {
        return {
          implementation: 'lookup'
        };
      }

      return null;
    }
  }, {
    key: "addListener",
    value: function addListener(eventType, eventHandler) {
      this._eventHandlerFuncs[eventType] = eventHandler.bind(this);
      this.dataSource.on(eventType, this._eventHandlerFuncs[eventType]);
    }
  }, {
    key: "removeListener",
    value: function removeListener(eventType) {
      this.dataSource.off(eventType, this._eventHandlerFuncs[eventType]);
    }
  }, {
    key: "removeAllListeners",
    value: function removeAllListeners() {
      this._eventHandlerFuncs = {};
    }
  }]);

  return DataSourceAdapter;
}();

DataSourceAdapter._SORT = 'sort';
DataSourceAdapter._DATA = 'data';
DataSourceAdapter._KEY = 'key';
DataSourceAdapter._ATTRIBUTE = 'attribute';
DataSourceAdapter._DIRECTION = 'direction';
DataSourceAdapter._VALUE = 'value';
DataSourceAdapter._DONE = 'done';
DataSourceAdapter._FETCHPARAMETERS = 'fetchParameters';
DataSourceAdapter._METADATA = 'metadata';
DataSourceAdapter._KEYS = 'keys';
DataSourceAdapter._INDEXES = 'indexes';
DataSourceAdapter._ADD = 'add';
DataSourceAdapter._REMOVE = 'remove';
DataSourceAdapter._UPDATE = 'update';
DataSourceAdapter._AFTERKEYS = 'afterKeys';
DataSourceAdapter._ADDBEFOREKEYS = 'addBeforeKeys';
oj.EventTargetMixin.applyMixin(DataSourceAdapter);

return DataSourceAdapter;
});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojkeysetimpl',['ojs/ojcore'], function(oj)
{
  "use strict";


/* global Set:false, Symbol:false */

/**
 * Contains all the core functionalities of KeySet.
 * @param {(Set|Array)=} keys A set of keys to initialize this KeySet with.
 *
 * @ignore
 * @ojtsignore
 * @export
 * @class KeySetImpl
 * @constructor
 * @since 5.1.0
 */
// eslint-disable-next-line no-unused-vars
var KeySetImpl = function KeySetImpl(initialValues) {
  this.NOT_A_KEY = {};
  /**
   * Returns whether the specified key is contained in this set.
   * @private
   * @param {any} key the key to check whether it is contained in this set.
   * @return {boolean} true if the specified key is contained in this set, false otherwise.
   */

  this.has = function (key) {
    return this.get(key) !== this.NOT_A_KEY;
  };
  /**
   * Finds the equavalent key of the specified key within this KeySet.
   * @private
   * @param {any} keyToFind the key to find
   * @return {any} the key in the key that is equivalent to keyToFind, or NO_KEY if nothing equivalent can be found.
   */


  this.get = function (keyToFind) {
    var iterator;
    var key;
    var found = this.NOT_A_KEY;
    var self = this;

    if (this._keys.has(keyToFind)) {
      return keyToFind;
    } // if it's a primitive, then we are done also


    if (!(keyToFind === Object(keyToFind))) {
      return this.NOT_A_KEY;
    } // using iterator if it's supported since we could break at any time


    if (typeof Symbol === 'function' && typeof Set.prototype[Symbol.iterator] === 'function') {
      iterator = this._keys[Symbol.iterator]();
      key = iterator.next();

      while (!key.done) {
        if (oj.KeyUtils.equals(key.value, keyToFind)) {
          return key.value;
        }

        key = iterator.next();
      }
    } else {
      // IE11 supports forEach
      this._keys.forEach(function (_key) {
        if (found === self.NOT_A_KEY && oj.KeyUtils.equals(_key, keyToFind)) {
          found = _key;
        }
      });
    }

    return found;
  };
  /**
   * Initialize the internal Set with a set of keys.
   * @private
   * @param {Set|Array|null|undefined} keys the initial keys to create the internal Set with.
   */


  this.InitializeWithKeys = function (keys) {
    this._keys = new Set(keys);
  };

  this.InitializeWithKeys(initialValues);
};

;return KeySetImpl;
});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojmap',['ojs/ojcore', 'ojs/ojkeysetimpl'],
/*
* @param {Object} oj 
* @param {Object} KeySetImpl
*/
function(oj, KeySetImpl)
{
  "use strict";


/* global KeySetImpl:false, Map:false */

/**
 * Implementation of the ES6 Map API:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map
 * that can deal with how equalities are handled when Object is used as key
 * @ignore
 * @ojtsignore
 * @export
 * @class ojMap
 * @constructor
 * @since 5.2.0
 */
var ojMap = function ojMap() {
  this._map = new Map();
  this._keyset = new KeySetImpl();
};

var _proto = ojMap.prototype;
Object.defineProperty(_proto, 'size', {
  get: function get() {
    return this._map.size;
  }
});

_proto.clear = function () {
  this._map.clear();

  this._keyset._keys.clear();
};

_proto.delete = function (key) {
  var theKey = this._keyset.get(key);

  if (theKey === this._keyset.NOT_A_KEY) {
    return false;
  }

  this._keyset._keys.delete(theKey);

  return this._map.delete(theKey);
};

_proto.forEach = function (callback) {
  this._map.forEach(callback);
};

_proto.get = function (key) {
  var theKey = this._keyset.get(key);

  return this._map.get(theKey);
};

_proto.has = function (key) {
  return this._keyset.has(key);
};

_proto.set = function (key, value) {
  var theKey = this._keyset.get(key);

  if (theKey === this._keyset.NOT_A_KEY) {
    this._keyset._keys.add(key);

    this._map.set(key, value);
  } else {
    // update value
    this._map.set(theKey, value);
  }

  return this;
};

;return ojMap;
});
/**
 * @license
 * Copyright (c) 2014, 2020, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojtreedataprovideradapter',['ojs/ojcore', 'jquery', 'ojs/ojdataprovideradapter-base', 'ojs/ojmap'], function(oj, $, DataSourceAdapter, KeyMap)
{
  "use strict";
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var TreeDataSourceAdapter = /*#__PURE__*/function (_DataSourceAdapter) {
  _inherits(TreeDataSourceAdapter, _DataSourceAdapter);

  var _super = _createSuper(TreeDataSourceAdapter);

  function TreeDataSourceAdapter(treeDataSource) {
    var _this;

    _classCallCheck(this, TreeDataSourceAdapter);

    _this = _super.call(this, treeDataSource);
    _this.treeDataSource = treeDataSource;

    _this._addTreeDataSourceEventListeners();

    _this._parentKey = null;
    _this._parentInfoMap = new KeyMap();
    return _this;
  }

  _createClass(TreeDataSourceAdapter, [{
    key: "destroy",
    value: function destroy() {
      this._removeTreeDataSourceEventListeners();
    }
  }, {
    key: "getChildDataProvider",
    value: function getChildDataProvider(parentKey) {
      if (this._parentInfoMap.has(parentKey)) {
        var childDataProvider = new TreeDataSourceAdapter(this.treeDataSource);
        childDataProvider._parentKey = parentKey;
        childDataProvider._parentInfoMap = this._parentInfoMap;
        return childDataProvider;
      } // todo: for the component use case, this is sufficient since parentKey should have been
      // fetched already, otherwise, we would probably need a private contract in TreeDataSource
      // to handle the case when parentKey has not been fetched yet


      return null;
    }
  }, {
    key: "fetchFirst",
    value: function fetchFirst(params) {
      return new this.AsyncIterable(new this.AsyncIterator(this._getFetchFunc(params), params));
    }
  }, {
    key: "getTotalSize",
    value: function getTotalSize() {
      return Promise.resolve(this.treeDataSource.getChildCount(this._parentKey));
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      var count = this.treeDataSource.getChildCount();

      if (count === -1) {
        return 'unknown';
      }

      return count > 0 ? 'no' : 'yes';
    }
  }, {
    key: "getCapability",
    value: function getCapability(capabilityName) {
      if (capabilityName == TreeDataSourceAdapter._SORT && this.treeDataSource.getCapability(capabilityName) == 'full') {
        return {
          attributes: 'multiple'
        };
      } else if (capabilityName == 'fetchByKeys') {
        return {
          implementation: 'iteration'
        };
      } else if (capabilityName == 'fetchByOffset') {
        return {
          implementation: 'iteration'
        };
      }

      return null;
    }
    /**
     * Get the function which performs the fetch
     */

  }, {
    key: "_getFetchFunc",
    value: function _getFetchFunc(params) {
      var self = this;

      if (params != null && params[TreeDataSourceAdapter._SORTCRITERIA] != null) {
        var attribute = params[TreeDataSourceAdapter._SORTCRITERIA][0][TreeDataSourceAdapter._ATTRIBUTE];
        var direction = params[TreeDataSourceAdapter._SORTCRITERIA][0][TreeDataSourceAdapter._DIRECTION];
        return function (attribute, direction) {
          return function (params, fetchFirst) {
            if (fetchFirst) {
              var sortParam = {};
              sortParam[TreeDataSourceAdapter._KEY] = attribute;
              sortParam[TreeDataSourceAdapter._DIRECTION] = direction;
              return new Promise(function (resolve, reject) {
                self.treeDataSource.sort(sortParam, {
                  success: function success() {
                    resolve(self._getTreeDataSourceFetch(params)(params));
                  },
                  error: function error(err) {
                    reject(err);
                  }
                });
              });
            } else {
              return self._getTreeDataSourceFetch(params)(params);
            }
          };
        }(attribute, direction);
      } else {
        return this._getTreeDataSourceFetch(params);
      }
    }
    /**
     * Get the function which invokes fetchChildren() on TreeDataSource
     */

  }, {
    key: "_getTreeDataSourceFetch",
    value: function _getTreeDataSourceFetch(params) {
      var self = this;
      return function (params, fetchFirst) {
        var sortCriteria = self.treeDataSource.getSortCriteria();

        if (sortCriteria != null && sortCriteria[TreeDataSourceAdapter._DIRECTION] != 'none' && params[TreeDataSourceAdapter._SORTCRITERIA] == null) {
          params[TreeDataSourceAdapter._SORTCRITERIA] = [];
          var sortCriterion = new self.SortCriterion(self, sortCriteria[TreeDataSourceAdapter._KEY], sortCriteria[TreeDataSourceAdapter._DIRECTION]);

          params[TreeDataSourceAdapter._SORTCRITERIA].push(sortCriterion);
        }

        self._isFetching = true;
        return new Promise(function (resolve, reject) {
          self.treeDataSource.fetchChildren(self._parentKey, {
            start: 0,
            end: -1
          }, {
            success: function success(nodeSet) {
              self._isFetching = false;
              var resultData = [];
              var resultMetadata = [];
              var start = nodeSet.getStart();
              var count = nodeSet.getCount();
              var i, data, metadata;

              for (i = 0; i < count; i++) {
                data = nodeSet.getData(start + i);
                resultData.push(data);
                metadata = nodeSet.getMetadata(start + i);

                if (!metadata[TreeDataSourceAdapter._LEAF]) {
                  self._parentInfoMap.set(metadata[TreeDataSourceAdapter._KEY], metadata);
                }

                resultMetadata.push(new self.ItemMetadata(self, metadata[TreeDataSourceAdapter._KEY]));
              }

              resolve(new self.AsyncIteratorReturnResult(self, new self.FetchListResult(self, params, resultData, resultMetadata)));
            },
            error: function error(_error) {
              self._isFetching = false;
              reject(_error);
            }
          });
        });
      };
    }
    /**
     * Add event listeners to TreeDataSource.  Note that currently none of the components
     * handle change event from TreeDataSource.
     */

  }, {
    key: "_addTreeDataSourceEventListeners",
    value: function _addTreeDataSourceEventListeners() {
      this.removeAllListeners();
      this.addListener('change', this._handleChange);
      this.addListener('refresh', this._handleRefresh);
    }
    /**
     * Remove event listeners to TableDataSource
     */

  }, {
    key: "_removeTreeDataSourceEventListeners",
    value: function _removeTreeDataSourceEventListeners() {
      this.removeListener('change');
      this.removeListener('refresh');
    }
  }, {
    key: "_handleChange",
    value: function _handleChange(event) {
      var operation = event[TreeDataSourceAdapter._OPERATION];

      if (operation === 'insert') {
        this._handleInsert(event);
      } else if (operation === 'delete') {
        this._handleDelete(event);
      } else if (operation === 'update') {
        this._handleUpdate(event);
      }
    }
  }, {
    key: "_handleInsert",
    value: function _handleInsert(event) {
      var data = event[TreeDataSourceAdapter._DATA];
      var index = event[TreeDataSourceAdapter._INDEX];
      var key = event[TreeDataSourceAdapter._KEY];
      var parentKey = event[TreeDataSourceAdapter._PARENT];
      var itemMetadata = new this.ItemMetadata(this, key);
      var keySet = new Set();
      keySet.add(key);
      var metadata = event[TreeDataSourceAdapter._METADATA];

      if (metadata != null && metadata[TreeDataSourceAdapter._LEAF]) {
        this._parentInfoMap.set(key, metadata);
      }

      var operationEventDetail = new this.DataProviderAddOperationEventDetail(this, keySet, null, null, [parentKey], [itemMetadata], [data], [index]);
      var mutationEventDetail = new this.DataProviderMutationEventDetail(this, operationEventDetail, null, null);
      this.dispatchEvent(new oj.DataProviderMutationEvent(mutationEventDetail));
    }
  }, {
    key: "_handleDelete",
    value: function _handleDelete(event) {
      var data = event[TreeDataSourceAdapter._DATA];
      var index = event[TreeDataSourceAdapter._INDEX];
      var key = event[TreeDataSourceAdapter._KEY];
      var itemMetadata = new this.ItemMetadata(this, key);
      var keySet = new Set();
      keySet.add(key);

      this._parentInfoMap.delete(key);

      var operationEventDetail = new this.DataProviderOperationEventDetail(this, keySet, [itemMetadata], [data], [index]);
      var mutationEventDetail = new this.DataProviderMutationEventDetail(this, null, operationEventDetail, null);
      this.dispatchEvent(new oj.DataProviderMutationEvent(mutationEventDetail));
    }
  }, {
    key: "_handleUpdate",
    value: function _handleUpdate(event) {
      var data = event[TreeDataSourceAdapter._DATA];
      var index = event[TreeDataSourceAdapter._INDEX];
      var key = event[TreeDataSourceAdapter._KEY];
      var itemMetadata = new this.ItemMetadata(this, key);
      var keySet = new Set();
      keySet.add(key);
      var operationEventDetail = new this.DataProviderOperationEventDetail(this, keySet, [itemMetadata], [data], [index]);
      var mutationEventDetail = new this.DataProviderMutationEventDetail(this, null, null, operationEventDetail);
      self.dispatchEvent(new oj.DataProviderMutationEvent(mutationEventDetail));
    }
  }, {
    key: "_handleRefresh",
    value: function _handleRefresh(event) {
      if (!this._isFetching) {
        this._parentInfoMap.clear();

        this.dispatchEvent(new oj.DataProviderRefreshEvent());
      }
    }
  }]);

  return TreeDataSourceAdapter;
}(DataSourceAdapter);

TreeDataSourceAdapter._SORTCRITERIA = 'sortCriteria';
TreeDataSourceAdapter._INDEX = 'index';
TreeDataSourceAdapter._PARENT = 'parent';
TreeDataSourceAdapter._LEAF = 'leaf';
TreeDataSourceAdapter._OPERATION = 'operation';
oj.TreeDataSourceAdapter = TreeDataSourceAdapter;
oj['TreeDataSourceAdapter'] = TreeDataSourceAdapter;
oj.FetchByKeysMixin.applyMixin(TreeDataSourceAdapter);
oj.FetchByOffsetMixin.applyMixin(TreeDataSourceAdapter);

return TreeDataSourceAdapter;
});

define("rjs_bundles/customerBundle_es5", function(){});
